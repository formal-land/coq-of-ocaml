<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Coq of OCaml - Demos</title>
    <link rel="icon" data-emoji="üêì" type="image/png">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/custom.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container-fluid">
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-list" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
              <a class="navbar-brand" href="../">üêìüê´ Coq of OCaml <span class="hidden-xs">- Demos</span></a>
          </div>

          <div class="collapse navbar-collapse" id="navbar-collapse-list">
            <ul class="nav navbar-nav">
              <li ><a href="../kernel/">Kernel of Coq</a></li>
              <li class="active"><a href="../tezos/">Protocol of Tezos</a></li>
              <li ><a href="../tezos-interface/">Interface of Tezos</a></li>
              <li><a href="https://github.com/clarus/coq-of-ocaml">Sources on GitHub</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="article">

<div class="row center-block not-full-width">
  <div class="col-md-12">
        <h2>
      Protocol of Tezos in&nbsp;Coq
      <small>
      <span class="label label-danger">Does not compile</span>
      </small>
    </h2>
    <p>These are the sources of the <a href="https://gitlab.com/tezos/tezos/tree/master/src/proto_alpha/lib_protocol">protocol</a> of <a href="https://tezos.com/">Tezos</a> imported to <a href="https://coq.inria.fr/">Coq</a> by the current development version of <a href="https://github.com/clarus/coq-of-ocaml">coq-of-ocaml</a>. Tezos is a crypto-currency with smart-contracts and an upgradable protocol.</p>

    <p>We show the original&nbsp;OCaml code on the left and the imported&nbsp;Coq code on the right. The imported code does not compile. Errors reported on the&nbsp;OCaml side are due to either various incompleteness in our tool, or to side-effects in the source code. Write at <code>web [at] clarus [dot] me</code> for more information. Work currently made at <a href="https://www.nomadic-labs.com/">Nomadic Labs</a>.</p>
    <ul>
      <li>OCaml size: 35828 lines</li>
      <li>Coq size: 45482 lines (+26% compared to&nbsp;OCaml)</li>
      <li>errors from coq-of-ocaml: 2861</li>
    </ul>
    
      <canvas id="chart" width="400" height="400"></canvas>
      <script>
        window.chart =       {
        compiling: [
          13,
          292,
          1784,
          1529,
          1147,
          1541,
          2680,
          3078,
        ],
        generated: [
          47563,
          41904,
          43481,
          43404,
          44618,
          45107,
          44768,
          45482,
        ],
        labels: [
          "01-14",
          "01-15",
          "01-16",
          "01-17",
          "01-18",
          "01-19",
          "01-20",
          "01-21",
        ]
      }
;
      </script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.bundle.min.js"></script>
      <script src="../js/display-chart.js"></script>
    
  </div>
</div>

<hr />
<div class="row">
  
  
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#alpha_context.ml">alpha_context.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#alpha_context.mli">alpha_context.mli</a>&nbsp;<span class="label label-danger">13</span>
      </li>
      
      <li>
        <a href="#alpha_services.ml">alpha_services.ml</a>&nbsp;<span class="label label-danger">34</span>
      </li>
      
      <li>
        <a href="#alpha_services.mli">alpha_services.mli</a>&nbsp;<span class="label label-danger">33</span>
      </li>
      
      <li>
        <a href="#amendment.ml">amendment.ml</a>&nbsp;<span class="label label-danger">11</span>
      </li>
      
      <li>
        <a href="#amendment.mli">amendment.mli</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#apply.ml">apply.ml</a>&nbsp;<span class="label label-danger">70</span>
      </li>
      
      <li>
        <a href="#apply_results.ml">apply_results.ml</a>&nbsp;<span class="label label-danger">13</span>
      </li>
      
      <li>
        <a href="#apply_results.mli">apply_results.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#baking.ml">baking.ml</a>&nbsp;<span class="label label-danger">19</span>
      </li>
      
      <li>
        <a href="#baking.mli">baking.mli</a>&nbsp;<span class="label label-danger">6</span>
      </li>
      
      <li>
        <a href="#blinded_public_key_hash.ml">blinded_public_key_hash.ml</a>&nbsp;<span class="label label-danger">3</span>
      </li>
      
      <li>
        <a href="#blinded_public_key_hash.mli">blinded_public_key_hash.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#block_header_repr.ml">block_header_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#block_header_repr.mli">block_header_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#bootstrap_storage.ml">bootstrap_storage.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#bootstrap_storage.mli">bootstrap_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_repr.ml">commitment_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_repr.mli">commitment_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_storage.ml">commitment_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_storage.mli">commitment_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#constants_repr.ml">constants_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#constants_services.ml">constants_services.ml</a>&nbsp;<span class="label label-danger">29</span>
      </li>
      
      <li>
        <a href="#constants_services.mli">constants_services.mli</a>&nbsp;<span class="label label-danger">26</span>
      </li>
      
      <li>
        <a href="#constants_storage.ml">constants_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#contract_hash.ml">contract_hash.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#contract_repr.ml">contract_repr.ml</a>&nbsp;<span class="label label-danger">17</span>
      </li>
      
      <li>
        <a href="#contract_repr.mli">contract_repr.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#contract_services.ml">contract_services.ml</a>&nbsp;<span class="label label-danger">224</span>
      </li>
      
      <li>
        <a href="#contract_services.mli">contract_services.mli</a>&nbsp;<span class="label label-danger">195</span>
      </li>
      
      <li>
        <a href="#contract_storage.ml">contract_storage.ml</a>&nbsp;<span class="label label-danger">16</span>
      </li>
      
      <li>
        <a href="#contract_storage.mli">contract_storage.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#cycle_repr.ml">cycle_repr.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#cycle_repr.mli">cycle_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#delegate_services.ml">delegate_services.ml</a>&nbsp;<span class="label label-danger">224</span>
      </li>
      
      <li>
        <a href="#delegate_services.mli">delegate_services.mli</a>&nbsp;<span class="label label-danger">195</span>
      </li>
      
      <li>
        <a href="#delegate_storage.ml">delegate_storage.ml</a>&nbsp;<span class="label label-danger">14</span>
      </li>
      
      <li>
        <a href="#delegate_storage.mli">delegate_storage.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#fees_storage.ml">fees_storage.ml</a>&nbsp;<span class="label label-danger">7</span>
      </li>
      
      <li>
        <a href="#fees_storage.mli">fees_storage.mli</a>&nbsp;<span class="label label-danger">3</span>
      </li>
      
      <li>
        <a href="#fitness_repr.ml">fitness_repr.ml</a>&nbsp;<span class="label label-danger">5</span>
      </li>
      
    </ul>
  </div>
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#fitness_storage.ml">fitness_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#gas_limit_repr.ml">gas_limit_repr.ml</a>&nbsp;<span class="label label-danger">5</span>
      </li>
      
      <li>
        <a href="#gas_limit_repr.mli">gas_limit_repr.mli</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#helpers_services.ml">helpers_services.ml</a>&nbsp;<span class="label label-danger">357</span>
      </li>
      
      <li>
        <a href="#helpers_services.mli">helpers_services.mli</a>&nbsp;<span class="label label-danger">313</span>
      </li>
      
      <li>
        <a href="#init_storage.ml">init_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#legacy_script_support_repr.ml">legacy_script_support_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#legacy_script_support_repr.mli">legacy_script_support_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#level_repr.ml">level_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#level_repr.mli">level_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#level_storage.ml">level_storage.ml</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#level_storage.mli">level_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#main.ml">main.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#main.mli">main.mli</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#manager_repr.ml">manager_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#manager_repr.mli">manager_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#michelson_v1_gas.ml">michelson_v1_gas.ml</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#michelson_v1_gas.mli">michelson_v1_gas.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#michelson_v1_primitives.ml">michelson_v1_primitives.ml</a>&nbsp;<span class="label label-danger">7</span>
      </li>
      
      <li>
        <a href="#michelson_v1_primitives.mli">michelson_v1_primitives.mli</a>&nbsp;<span class="label label-danger">3</span>
      </li>
      
      <li>
        <a href="#misc.ml">misc.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#misc.mli">misc.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#nonce_hash.ml">nonce_hash.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#nonce_storage.ml">nonce_storage.ml</a>&nbsp;<span class="label label-danger">7</span>
      </li>
      
      <li>
        <a href="#nonce_storage.mli">nonce_storage.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#operation_repr.ml">operation_repr.ml</a>&nbsp;<span class="label label-danger">9</span>
      </li>
      
      <li>
        <a href="#operation_repr.mli">operation_repr.mli</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#parameters_repr.ml">parameters_repr.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#parameters_repr.mli">parameters_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#period_repr.ml">period_repr.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#period_repr.mli">period_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#qty_repr.ml">qty_repr.ml</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#raw_context.ml">raw_context.ml</a>&nbsp;<span class="label label-danger">73</span>
      </li>
      
      <li>
        <a href="#raw_context.mli">raw_context.mli</a>&nbsp;<span class="label label-danger">8</span>
      </li>
      
      <li>
        <a href="#raw_level_repr.ml">raw_level_repr.ml</a>&nbsp;<span class="label label-danger">5</span>
      </li>
      
      <li>
        <a href="#raw_level_repr.mli">raw_level_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#roll_repr.ml">roll_repr.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#roll_repr.mli">roll_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#roll_storage.ml">roll_storage.ml</a>&nbsp;<span class="label label-danger">8</span>
      </li>
      
      <li>
        <a href="#roll_storage.mli">roll_storage.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#script_expr_hash.ml">script_expr_hash.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
    </ul>
  </div>
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#script_int_repr.ml">script_int_repr.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#script_int_repr.mli">script_int_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#script_interpreter.ml">script_interpreter.ml</a>&nbsp;<span class="label label-danger">30</span>
      </li>
      
      <li>
        <a href="#script_interpreter.mli">script_interpreter.mli</a>&nbsp;<span class="label label-danger">7</span>
      </li>
      
      <li>
        <a href="#script_ir_annot.ml">script_ir_annot.ml</a>&nbsp;<span class="label label-danger">138</span>
      </li>
      
      <li>
        <a href="#script_ir_annot.mli">script_ir_annot.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#script_ir_translator.ml">script_ir_translator.ml</a>&nbsp;<span class="label label-danger">264</span>
      </li>
      
      <li>
        <a href="#script_ir_translator.mli">script_ir_translator.mli</a>&nbsp;<span class="label label-danger">3</span>
      </li>
      
      <li>
        <a href="#script_repr.ml">script_repr.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#script_repr.mli">script_repr.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#script_tc_errors.ml">script_tc_errors.ml</a>&nbsp;<span class="label label-danger">46</span>
      </li>
      
      <li>
        <a href="#script_tc_errors_registration.ml">script_tc_errors_registration.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#script_timestamp_repr.ml">script_timestamp_repr.ml</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#script_timestamp_repr.mli">script_timestamp_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#script_typed_ir.ml">script_typed_ir.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#seed_repr.ml">seed_repr.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#seed_repr.mli">seed_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#seed_storage.ml">seed_storage.ml</a>&nbsp;<span class="label label-danger">4</span>
      </li>
      
      <li>
        <a href="#seed_storage.mli">seed_storage.mli</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#services_registration.ml">services_registration.ml</a>&nbsp;<span class="label label-danger">10</span>
      </li>
      
      <li>
        <a href="#state_hash.ml">state_hash.ml</a>&nbsp;<span class="label label-danger">1</span>
      </li>
      
      <li>
        <a href="#storage.ml">storage.ml</a>&nbsp;<span class="label label-danger">98</span>
      </li>
      
      <li>
        <a href="#storage.mli">storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#storage_description.ml">storage_description.ml</a>&nbsp;<span class="label label-danger">8</span>
      </li>
      
      <li>
        <a href="#storage_description.mli">storage_description.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#storage_functors.ml">storage_functors.ml</a>&nbsp;<span class="label label-danger">17</span>
      </li>
      
      <li>
        <a href="#storage_functors.mli">storage_functors.mli</a>&nbsp;<span class="label label-danger">7</span>
      </li>
      
      <li>
        <a href="#storage_sigs.ml">storage_sigs.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#tez_repr.ml">tez_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#tez_repr.mli">tez_repr.mli</a>&nbsp;<span class="label label-danger">5</span>
      </li>
      
      <li>
        <a href="#time_repr.ml">time_repr.ml</a>&nbsp;<span class="label label-danger">6</span>
      </li>
      
      <li>
        <a href="#time_repr.mli">time_repr.mli</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#vote_repr.ml">vote_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#vote_repr.mli">vote_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#vote_storage.ml">vote_storage.ml</a>&nbsp;<span class="label label-danger">3</span>
      </li>
      
      <li>
        <a href="#vote_storage.mli">vote_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#voting_period_repr.ml">voting_period_repr.ml</a>&nbsp;<span class="label label-danger">2</span>
      </li>
      
      <li>
        <a href="#voting_period_repr.mli">voting_period_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#voting_services.ml">voting_services.ml</a>&nbsp;<span class="label label-danger">104</span>
      </li>
      
      <li>
        <a href="#voting_services.mli">voting_services.mli</a>&nbsp;<span class="label label-danger">91</span>
      </li>
      
    </ul>
  </div>
  
</div>


<hr />
<div class="row conversion-row" id="alpha_context.ml">
  <div class="col-md-6">
    <a href="#alpha_context.ml"><code>alpha_context.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Raw_context.t

type context = t

module type BASIC_DATA = sig
  type t

  include Compare.S with type t := t

  val encoding : t Data_encoding.t

  val pp : Format.formatter -&gt; t -&gt; unit
end

module Tez = Tez_repr
module Period = Period_repr

module Timestamp = struct
  include Time_repr

  let current = Raw_context.current_timestamp
end

include Operation_repr

module Operation = struct
  type 'kind t = 'kind operation = {
    shell : Operation.shell_header;
    protocol_data : 'kind protocol_data;
  }

  type packed = packed_operation

  let unsigned_encoding = unsigned_operation_encoding

  include Operation_repr
end

module Block_header = Block_header_repr

module Vote = struct
  include Vote_repr
  include Vote_storage
end

module Raw_level = Raw_level_repr
module Cycle = Cycle_repr
module Script_int = Script_int_repr

module Script_timestamp = struct
  include Script_timestamp_repr

  let now ctxt =
    let {Constants_repr.time_between_blocks; _} = Raw_context.constants ctxt in
    match time_between_blocks with
    | [] -&gt;
        failwith
          &quot;Internal error: 'time_between_block' constants is an empty list.&quot;
    | first_delay :: _ -&gt;
        let current_timestamp = Raw_context.predecessor_timestamp ctxt in
        Time.add current_timestamp (Period_repr.to_seconds first_delay)
        |&gt; Timestamp.to_seconds |&gt; of_int64
end

module Script = struct
  include Michelson_v1_primitives
  include Script_repr

  let force_decode ctxt lexpr =
    Lwt.return
      ( Script_repr.force_decode lexpr
      &gt;&gt;? fun (v, cost) -&gt;
      Raw_context.consume_gas ctxt cost &gt;|? fun ctxt -&gt; (v, ctxt) )

  let force_bytes ctxt lexpr =
    Lwt.return
      ( Script_repr.force_bytes lexpr
      &gt;&gt;? fun (b, cost) -&gt;
      Raw_context.consume_gas ctxt cost &gt;|? fun ctxt -&gt; (b, ctxt) )

  module Legacy_support = Legacy_script_support_repr
end

module Fees = Fees_storage

type public_key = Signature.Public_key.t

type public_key_hash = Signature.Public_key_hash.t

type signature = Signature.t

module Constants = struct
  include Constants_repr
  include Constants_storage
end

module Voting_period = Voting_period_repr

module Gas = struct
  include Gas_limit_repr

  <abbr class="mark-error" title="Structure item `typext` not handled.">type error += Gas_limit_too_high = Raw_context.Gas_limit_too_high</abbr>

  let check_limit = Raw_context.check_gas_limit

  let set_limit = Raw_context.set_gas_limit

  let set_unlimited = Raw_context.set_gas_unlimited

  let consume = Raw_context.consume_gas

  let check_enough = Raw_context.check_enough_gas

  let level = Raw_context.gas_level

  let consumed = Raw_context.gas_consumed

  let block_level = Raw_context.block_gas_level
end

module Level = struct
  include Level_repr
  include Level_storage
end

module Contract = struct
  include Contract_repr
  include Contract_storage

  let originate c contract ~balance ~script ~delegate =
    originate c contract ~balance ~script ~delegate

  let init_origination_nonce = Raw_context.init_origination_nonce

  let unset_origination_nonce = Raw_context.unset_origination_nonce
end

module Big_map = struct
  type id = Z.t

  let fresh = Storage.Big_map.Next.incr

  let fresh_temporary = Raw_context.fresh_temporary_big_map

  let mem c m k = Storage.Big_map.Contents.mem (c, m) k

  let get_opt c m k = Storage.Big_map.Contents.get_option (c, m) k

  let rpc_arg = Storage.Big_map.rpc_arg

  let cleanup_temporary c =
    Raw_context.temporary_big_maps c Storage.Big_map.remove_rec c
    &gt;&gt;= fun c -&gt; Lwt.return (Raw_context.reset_temporary_big_map c)

  let exists c id =
    Lwt.return
      (Raw_context.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero))
    &gt;&gt;=? fun c -&gt;
    Storage.Big_map.Key_type.get_option c id
    &gt;&gt;=? fun kt -&gt;
    match kt with
    | None -&gt;
        return (c, None)
    | Some kt -&gt;
        Storage.Big_map.Value_type.get c id
        &gt;&gt;=? fun kv -&gt; return (c, Some (kt, kv))
end

module Delegate = Delegate_storage

module Roll = struct
  include Roll_repr
  include Roll_storage
end

module Nonce = Nonce_storage

module Seed = struct
  include Seed_repr
  include Seed_storage
end

module Fitness = struct
  include Fitness_repr
  include Fitness

  type fitness = t

  include Fitness_storage
end

module Bootstrap = Bootstrap_storage

module Commitment = struct
  include Commitment_repr
  include Commitment_storage
end

module Global = struct
  let get_block_priority = Storage.Block_priority.get

  let set_block_priority = Storage.Block_priority.set
end

let prepare_first_block = Init_storage.prepare_first_block

let prepare = Init_storage.prepare

let finalize ?commit_message:message c =
  let fitness = Fitness.from_int64 (Fitness.current c) in
  let context = Raw_context.recover c in
  {
    Updater.context;
    fitness;
    message;
    max_operations_ttl = 60;
    last_allowed_fork_level =
      Raw_level.to_int32 @@ Level.last_allowed_fork_level c;
  }

let activate = Raw_context.activate

let fork_test_chain = Raw_context.fork_test_chain

let record_endorsement = Raw_context.record_endorsement

let allowed_endorsements = Raw_context.allowed_endorsements

let init_endorsements = Raw_context.init_endorsements

let included_endorsements = Raw_context.included_endorsements

let reset_internal_nonce = Raw_context.reset_internal_nonce

let fresh_internal_nonce = Raw_context.fresh_internal_nonce

let record_internal_nonce = Raw_context.record_internal_nonce

let internal_nonce_already_recorded =
  Raw_context.internal_nonce_already_recorded

let add_deposit = Raw_context.add_deposit

let add_fees = Raw_context.add_fees

let add_rewards = Raw_context.add_rewards

let get_deposits = Raw_context.get_deposits

let get_fees = Raw_context.get_fees

let get_rewards = Raw_context.get_rewards

let description = Raw_context.description
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_context.ml"><code>Alpha_context.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Contract_storage.
Require Tezos.Gas_limit_repr.
Require Tezos.Init_storage.
Require Tezos.Period_repr.
Require Tezos.Raw_context.
Require Tezos.Script_repr.
Require Tezos.Storage.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

Definition t := Raw_context.t.

Definition context := t.

Module BASIC_DATA.
  Record signature {t : Set} := {
    t := t;
    op_eq : t -&gt; t -&gt; bool;
    op_ltgt : t -&gt; t -&gt; bool;
    op_lt : t -&gt; t -&gt; bool;
    op_lteq : t -&gt; t -&gt; bool;
    op_gteq : t -&gt; t -&gt; bool;
    op_gt : t -&gt; t -&gt; bool;
    compare : t -&gt; t -&gt; Z;
    equal : t -&gt; t -&gt; bool;
    max : t -&gt; t -&gt; t;
    min : t -&gt; t -&gt; t;
    encoding : Data_encoding.t t;
    pp : Format.formatter -&gt; t -&gt; unit;
  }.
  Arguments signature : clear implicits.
End BASIC_DATA.

Module Tez := Tez_repr.

Module Period := Period_repr.

Module Timestamp.
  Export Time_repr.
  
  Definition current : Raw_context.context -&gt; Time.t :=
    Raw_context.current_timestamp.
End Timestamp.

Export Operation_repr.

Module Operation.
  Module t.
    Record record {kind : Set} := {
      shell : Operation.shell_header;
      protocol_data : protocol_data kind }.
    Arguments record : clear implicits.
  End t.
  Definition t := t.record.
  
  Definition packed := packed_operation.
  
  Definition unsigned_encoding
    : Data_encoding.t (Operation.shell_header * packed_contents_list) :=
    unsigned_operation_encoding.
  
  Export Operation_repr.
End Operation.

Module Block_header := Block_header_repr.

Module Vote.
  Export Vote_repr.
  
  Export Vote_storage.
End Vote.

Module Raw_level := Raw_level_repr.

Module Cycle := Cycle_repr.

Module Script_int := Script_int_repr.

Module Script_timestamp.
  Export Script_timestamp_repr.
  
  Definition now (ctxt : Raw_context.context) : t :=
    let '{|
      Constants_repr.parametric.time_between_blocks := time_between_blocks
        |} := Raw_context.constants ctxt in
    match time_between_blocks with
    | [] =&gt;
      Pervasives.failwith
        &quot;Internal error: 'time_between_block' constants is an empty list.&quot; %
          string
    | cons first_delay _ =&gt;
      let current_timestamp := Raw_context.predecessor_timestamp ctxt in
      Pervasives.op_pipegt
        (Pervasives.op_pipegt
          (Time.add current_timestamp (Period_repr.to_seconds first_delay))
          Timestamp.to_seconds) of_int64
    end.
End Script_timestamp.

Module Script.
  Export Michelson_v1_primitives.
  
  Export Script_repr.
  
  Definition force_decode
    (ctxt : Raw_context.context) (lexpr : Script_repr.lazy_expr)
    : Lwt.t (Error_monad.tzresult (Script_repr.expr * Raw_context.context)) :=
    Lwt.__return
      (Error_monad.op_gtgtquestion (Script_repr.force_decode lexpr)
        (fun function_parameter =&gt;
          let '(v, cost) := function_parameter in
          Error_monad.op_gtpipequestion (Raw_context.consume_gas ctxt cost)
            (fun ctxt =&gt; (v, ctxt)))).
  
  Definition force_bytes
    (ctxt : Raw_context.context) (lexpr : Script_repr.lazy_expr)
    : Lwt.t (Error_monad.tzresult (MBytes.t * Raw_context.context)) :=
    Lwt.__return
      (Error_monad.op_gtgtquestion (Script_repr.force_bytes lexpr)
        (fun function_parameter =&gt;
          let '(b, cost) := function_parameter in
          Error_monad.op_gtpipequestion (Raw_context.consume_gas ctxt cost)
            (fun ctxt =&gt; (b, ctxt)))).
  
  Module Legacy_support := Legacy_script_support_repr.
End Script.

Module Fees := Fees_storage.

Definition public_key := Signature.Public_key.[S.SPublic_key.t].

Definition public_key_hash := Signature.Public_key_hash.[S.SPublic_key_hash.t].

Definition signature := Signature.t.

Module Constants.
  Export Constants_repr.
  
  Export Constants_storage.
End Constants.

Module Voting_period := Voting_period_repr.

Module Gas.
  Export Gas_limit_repr.
  
  (* ‚ùå Structure item `typext` not handled. *)
  (* type_extension *)
  
  Definition check_limit : Raw_context.t -&gt; Z.t -&gt; Error_monad.tzresult unit :=
    Raw_context.check_gas_limit.
  
  Definition set_limit : Raw_context.t -&gt; Z.t -&gt; Raw_context.t :=
    Raw_context.set_gas_limit.
  
  Definition set_unlimited : Raw_context.t -&gt; Raw_context.t :=
    Raw_context.set_gas_unlimited.
  
  Definition consume
    : Raw_context.context -&gt; Gas_limit_repr.cost -&gt;
    Error_monad.tzresult Raw_context.context := Raw_context.consume_gas.
  
  Definition check_enough
    : Raw_context.context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult unit :=
    Raw_context.check_enough_gas.
  
  Definition level : Raw_context.t -&gt; Gas_limit_repr.t := Raw_context.gas_level.
  
  Definition consumed : Raw_context.t -&gt; Raw_context.t -&gt; Z.t :=
    Raw_context.gas_consumed.
  
  Definition block_level : Raw_context.t -&gt; Z.t := Raw_context.block_gas_level.
End Gas.

Module Level.
  Export Level_repr.
  
  Export Level_storage.
End Level.

Module Contract.
  Export Contract_repr.
  
  Export Contract_storage.
  
  Definition originate
    (c : Raw_context.t) (contract : Contract_repr.t) (balance : Tez_repr.t)
    (script : Script_repr.t * option big_map_diff)
    (delegate : option Signature.Public_key_hash.[S.SPublic_key_hash.t])
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    originate c None contract balance script delegate.
  
  Definition init_origination_nonce
    : Raw_context.t -&gt; Operation_hash.[S.HASH.t] -&gt; Raw_context.t :=
    Raw_context.init_origination_nonce.
  
  Definition unset_origination_nonce : Raw_context.t -&gt; Raw_context.t :=
    Raw_context.unset_origination_nonce.
End Contract.

Module Big_map.
  Definition id := Z.t.
  
  Definition fresh
    : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t)) :=
    Storage.Big_map.Next.incr.
  
  Definition fresh_temporary
    : Raw_context.context -&gt; Raw_context.context * Z.t :=
    Raw_context.fresh_temporary_big_map.
  
  Definition mem
    (c : Raw_context.t) (m : Z.t) (k : Storage.Big_map.Contents.key)
    : Lwt.t (Error_monad.tzresult (Raw_context.t * bool)) :=
    Storage.Big_map.Contents.mem (c, m) k.
  
  Definition get_opt
    (c : Raw_context.t) (m : Z.t) (k : Storage.Big_map.Contents.key)
    : Lwt.t
      (Error_monad.tzresult
        (Raw_context.t * option Storage.Big_map.Contents.value)) :=
    Storage.Big_map.Contents.get_option (c, m) k.
  
  Definition rpc_arg : RPC_arg.t Z.t := Storage.Big_map.rpc_arg.
  
  Definition cleanup_temporary (c : Raw_context.context)
    : Lwt.t Raw_context.context :=
    Error_monad.op_gtgteq
      (Raw_context.temporary_big_maps c Storage.Big_map.remove_rec c)
      (fun c =&gt; Lwt.__return (Raw_context.reset_temporary_big_map c)).
  
  Definition __exists
    (c : Raw_context.context) (id : Storage.Big_map.Key_type.key)
    : Lwt.t
      (Error_monad.tzresult
        (Raw_context.context *
          option
            (Storage.Big_map.Key_type.value * Storage.Big_map.Value_type.value))) :=
    Error_monad.op_gtgteqquestion
      (Lwt.__return
        (Raw_context.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero)))
      (fun c =&gt;
        Error_monad.op_gtgteqquestion (Storage.Big_map.Key_type.get_option c id)
          (fun kt =&gt;
            match kt with
            | None =&gt; Error_monad.__return (c, None)
            | Some kt =&gt;
              Error_monad.op_gtgteqquestion
                (Storage.Big_map.Value_type.get c id)
                (fun kv =&gt; Error_monad.__return (c, (Some (kt, kv))))
            end)).
End Big_map.

Module Delegate := Delegate_storage.

Module Roll.
  Export Roll_repr.
  
  Export Roll_storage.
End Roll.

Module Nonce := Nonce_storage.

Module Seed.
  Export Seed_repr.
  
  Export Seed_storage.
End Seed.

Module Fitness.
  Export Fitness_repr.
  
  Definition t := Fitness.[S.T.t].
  
  Definition op_eq := Fitness.[S.T.op_eq].
  
  Definition op_ltgt := Fitness.[S.T.op_ltgt].
  
  Definition op_lt := Fitness.[S.T.op_lt].
  
  Definition op_lteq := Fitness.[S.T.op_lteq].
  
  Definition op_gteq := Fitness.[S.T.op_gteq].
  
  Definition op_gt := Fitness.[S.T.op_gt].
  
  Definition compare := Fitness.[S.T.compare].
  
  Definition equal := Fitness.[S.T.equal].
  
  Definition max := Fitness.[S.T.max].
  
  Definition min := Fitness.[S.T.min].
  
  Definition pp := Fitness.[S.T.pp].
  
  Definition encoding := Fitness.[S.T.encoding].
  
  Definition to_bytes := Fitness.[S.T.to_bytes].
  
  Definition of_bytes := Fitness.[S.T.of_bytes].
  
  Definition fitness := t.
  
  Export Fitness_storage.
End Fitness.

Module Bootstrap := Bootstrap_storage.

Module Commitment.
  Export Commitment_repr.
  
  Export Commitment_storage.
End Commitment.

Module Global.
  Definition get_block_priority
    : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Z) :=
    Storage.Block_priority.get.
  
  Definition set_block_priority
    : Raw_context.t -&gt; Z -&gt; Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Storage.Block_priority.set.
End Global.

Definition prepare_first_block
  : Context.t -&gt;
  (Raw_context.t -&gt; Script_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  -&gt; int32 -&gt; Time.t -&gt; Fitness.[S.T.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) := Init_storage.prepare_first_block.

Definition prepare
  : Context.t -&gt; Int32.t -&gt; Time.t -&gt; Time.t -&gt; Fitness.[S.T.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.context) := Init_storage.prepare.

Definition finalize (message : option string) (c : Raw_context.context)
  : Updater.validation_result :=
  let fitness := Fitness.from_int64 (Fitness.current c) in
  let context := Raw_context.recover c in
  {| Updater.validation_result.context := context;
    Updater.validation_result.fitness := fitness;
    Updater.validation_result.message := message;
    Updater.validation_result.max_operations_ttl := 60;
    Updater.validation_result.last_allowed_fork_level :=
      Pervasives.op_atat Raw_level.to_int32 (Level.last_allowed_fork_level c) |}.

Definition activate
  : Raw_context.context -&gt; Protocol_hash.[S.HASH.t] -&gt; Lwt.t Raw_context.t :=
  Raw_context.activate.

Definition fork_test_chain
  : Raw_context.context -&gt; Protocol_hash.[S.HASH.t] -&gt; Time.t -&gt;
  Lwt.t Raw_context.t := Raw_context.fork_test_chain.

Definition record_endorsement
  : Raw_context.context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Raw_context.context := Raw_context.record_endorsement.

Definition allowed_endorsements
  : Raw_context.context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    (Signature.Public_key.[S.SPublic_key.t] * list Z * bool) :=
  Raw_context.allowed_endorsements.

Definition init_endorsements
  : Raw_context.context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    (Signature.Public_key.[S.SPublic_key.t] * list Z * bool) -&gt;
  Raw_context.context := Raw_context.init_endorsements.

Definition included_endorsements : Raw_context.context -&gt; Z :=
  Raw_context.included_endorsements.

Definition reset_internal_nonce : Raw_context.context -&gt; Raw_context.context :=
  Raw_context.reset_internal_nonce.

Definition fresh_internal_nonce
  : Raw_context.context -&gt; Error_monad.tzresult (Raw_context.context * Z) :=
  Raw_context.fresh_internal_nonce.

Definition record_internal_nonce
  : Raw_context.context -&gt; Z -&gt; Raw_context.context :=
  Raw_context.record_internal_nonce.

Definition internal_nonce_already_recorded : Raw_context.context -&gt; Z -&gt; bool :=
  Raw_context.internal_nonce_already_recorded.

Definition add_deposit
  : Raw_context.context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.context) :=
  Raw_context.add_deposit.

Definition add_fees
  : Raw_context.context -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.context) := Raw_context.add_fees.

Definition add_rewards
  : Raw_context.context -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.context) := Raw_context.add_rewards.

Definition get_deposits
  : Raw_context.context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    Tez_repr.t := Raw_context.get_deposits.

Definition get_fees : Raw_context.context -&gt; Tez_repr.t := Raw_context.get_fees.

Definition get_rewards : Raw_context.context -&gt; Tez_repr.t :=
  Raw_context.get_rewards.

Definition description : Storage_description.t Raw_context.context :=
  Raw_context.description.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="alpha_context.mli">
  <div class="col-md-6">
    <a href="#alpha_context.mli"><code>alpha_context.mli</code></a>&nbsp;<span class="label label-danger">13 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module type BASIC_DATA = sig
  type t

  include Compare.S with type t := t

  val encoding : t Data_encoding.t

  val pp : Format.formatter -&gt; t -&gt; unit
end

type t

type context = t

type public_key = Signature.Public_key.t

type public_key_hash = Signature.Public_key_hash.t

type signature = Signature.t

module Tez : sig
  include BASIC_DATA

  type tez = t

  val zero : tez

  val one_mutez : tez

  val one_cent : tez

  val fifty_cents : tez

  val one : tez

  val ( -? ) : tez -&gt; tez -&gt; tez tzresult

  val ( +? ) : tez -&gt; tez -&gt; tez tzresult

  val ( *? ) : tez -&gt; int64 -&gt; tez tzresult

  val ( /? ) : tez -&gt; int64 -&gt; tez tzresult

  val of_string : string -&gt; tez option

  val to_string : tez -&gt; string

  val of_mutez : int64 -&gt; tez option

  val to_mutez : tez -&gt; int64
end

module Period : sig
  include BASIC_DATA

  type period = t

  val rpc_arg : period RPC_arg.arg

  val of_seconds : int64 -&gt; period tzresult

  val to_seconds : period -&gt; int64

  val mult : int32 -&gt; period -&gt; period tzresult

  val zero : period

  val one_second : period

  val one_minute : period

  val one_hour : period
end

module Timestamp : sig
  include BASIC_DATA with type t = Time.t

  type time = t

  val ( +? ) : time -&gt; Period.t -&gt; time tzresult

  val ( -? ) : time -&gt; time -&gt; Period.t tzresult

  val of_notation : string -&gt; time option

  val to_notation : time -&gt; string

  val of_seconds : string -&gt; time option

  val to_seconds_string : time -&gt; string

  val current : context -&gt; time
end

module Raw_level : sig
  include BASIC_DATA

  type raw_level = t

  val rpc_arg : raw_level RPC_arg.arg

  val diff : raw_level -&gt; raw_level -&gt; int32

  val root : raw_level

  val succ : raw_level -&gt; raw_level

  val pred : raw_level -&gt; raw_level option

  val to_int32 : raw_level -&gt; int32

  val of_int32 : int32 -&gt; raw_level tzresult
end

module Cycle : sig
  include BASIC_DATA

  type cycle = t

  val rpc_arg : cycle RPC_arg.arg

  val root : cycle

  val succ : cycle -&gt; cycle

  val pred : cycle -&gt; cycle option

  val add : cycle -&gt; int -&gt; cycle

  val sub : cycle -&gt; int -&gt; cycle option

  val to_int32 : cycle -&gt; int32

  module Map : S.MAP with type key = cycle
end

module Gas : sig
  type t = private Unaccounted | Limited of {remaining : Z.t}

  val encoding : t Data_encoding.encoding

  val pp : Format.formatter -&gt; t -&gt; unit

  type cost

  val cost_encoding : cost Data_encoding.encoding

  val pp_cost : Format.formatter -&gt; cost -&gt; unit

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Block_quota_exceeded</abbr> (* `Temporary *)

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Gas_limit_too_high</abbr> (* `Permanent *)

  val free : cost

  val atomic_step_cost : int -&gt; cost

  val step_cost : int -&gt; cost

  val alloc_cost : int -&gt; cost

  val alloc_bytes_cost : int -&gt; cost

  val alloc_mbytes_cost : int -&gt; cost

  val alloc_bits_cost : int -&gt; cost

  val read_bytes_cost : Z.t -&gt; cost

  val write_bytes_cost : Z.t -&gt; cost

  val ( *@ ) : int -&gt; cost -&gt; cost

  val ( +@ ) : cost -&gt; cost -&gt; cost

  val check_limit : context -&gt; Z.t -&gt; unit tzresult

  val set_limit : context -&gt; Z.t -&gt; context

  val set_unlimited : context -&gt; context

  val consume : context -&gt; cost -&gt; context tzresult

  val check_enough : context -&gt; cost -&gt; unit tzresult

  val level : context -&gt; t

  val consumed : since:context -&gt; until:context -&gt; Z.t

  val block_level : context -&gt; Z.t
end

<abbr class="mark-error" title="The typeof in module types is not handled">module Script_int : module type of Script_int_repr</abbr>

module Script_timestamp : sig
  open Script_int

  type t

  val compare : t -&gt; t -&gt; int

  val to_string : t -&gt; string

  val to_notation : t -&gt; string option

  val to_num_str : t -&gt; string

  val of_string : string -&gt; t option

  val diff : t -&gt; t -&gt; z num

  val add_delta : t -&gt; z num -&gt; t

  val sub_delta : t -&gt; z num -&gt; t

  val now : context -&gt; t

  val to_zint : t -&gt; Z.t

  val of_zint : Z.t -&gt; t
end

module Script : sig
  type prim = Michelson_v1_primitives.prim =
    | K_parameter
    | K_storage
    | K_code
    | D_False
    | D_Elt
    | D_Left
    | D_None
    | D_Pair
    | D_Right
    | D_Some
    | D_True
    | D_Unit
    | I_PACK
    | I_UNPACK
    | I_BLAKE2B
    | I_SHA256
    | I_SHA512
    | I_ABS
    | I_ADD
    | I_AMOUNT
    | I_AND
    | I_BALANCE
    | I_CAR
    | I_CDR
    | I_CHAIN_ID
    | I_CHECK_SIGNATURE
    | I_COMPARE
    | I_CONCAT
    | I_CONS
    | I_CREATE_ACCOUNT
    | I_CREATE_CONTRACT
    | I_IMPLICIT_ACCOUNT
    | I_DIP
    | I_DROP
    | I_DUP
    | I_EDIV
    | I_EMPTY_BIG_MAP
    | I_EMPTY_MAP
    | I_EMPTY_SET
    | I_EQ
    | I_EXEC
    | I_APPLY
    | I_FAILWITH
    | I_GE
    | I_GET
    | I_GT
    | I_HASH_KEY
    | I_IF
    | I_IF_CONS
    | I_IF_LEFT
    | I_IF_NONE
    | I_INT
    | I_LAMBDA
    | I_LE
    | I_LEFT
    | I_LOOP
    | I_LSL
    | I_LSR
    | I_LT
    | I_MAP
    | I_MEM
    | I_MUL
    | I_NEG
    | I_NEQ
    | I_NIL
    | I_NONE
    | I_NOT
    | I_NOW
    | I_OR
    | I_PAIR
    | I_PUSH
    | I_RIGHT
    | I_SIZE
    | I_SOME
    | I_SOURCE
    | I_SENDER
    | I_SELF
    | I_SLICE
    | I_STEPS_TO_QUOTA
    | I_SUB
    | I_SWAP
    | I_TRANSFER_TOKENS
    | I_SET_DELEGATE
    | I_UNIT
    | I_UPDATE
    | I_XOR
    | I_ITER
    | I_LOOP_LEFT
    | I_ADDRESS
    | I_CONTRACT
    | I_ISNAT
    | I_CAST
    | I_RENAME
    | I_DIG
    | I_DUG
    | T_bool
    | T_contract
    | T_int
    | T_key
    | T_key_hash
    | T_lambda
    | T_list
    | T_map
    | T_big_map
    | T_nat
    | T_option
    | T_or
    | T_pair
    | T_set
    | T_signature
    | T_string
    | T_bytes
    | T_mutez
    | T_timestamp
    | T_unit
    | T_operation
    | T_address
    | T_chain_id

  type location = Micheline.canonical_location

  type annot = Micheline.annot

  type expr = prim Micheline.canonical

  type lazy_expr = expr Data_encoding.lazy_t

  val lazy_expr : expr -&gt; lazy_expr

  type node = (location, prim) Micheline.node

  type t = {code : lazy_expr; storage : lazy_expr}

  val location_encoding : location Data_encoding.t

  val expr_encoding : expr Data_encoding.t

  val prim_encoding : prim Data_encoding.t

  val encoding : t Data_encoding.t

  val lazy_expr_encoding : lazy_expr Data_encoding.t

  val deserialized_cost : expr -&gt; Gas.cost

  val serialized_cost : MBytes.t -&gt; Gas.cost

  val traversal_cost : node -&gt; Gas.cost

  val node_cost : node -&gt; Gas.cost

  val int_node_cost : Z.t -&gt; Gas.cost

  val int_node_cost_of_numbits : int -&gt; Gas.cost

  val string_node_cost : string -&gt; Gas.cost

  val string_node_cost_of_length : int -&gt; Gas.cost

  val bytes_node_cost : MBytes.t -&gt; Gas.cost

  val bytes_node_cost_of_length : int -&gt; Gas.cost

  val prim_node_cost_nonrec : expr list -&gt; annot -&gt; Gas.cost

  val prim_node_cost_nonrec_of_length : int -&gt; annot -&gt; Gas.cost

  val seq_node_cost_nonrec : expr list -&gt; Gas.cost

  val seq_node_cost_nonrec_of_length : int -&gt; Gas.cost

  val minimal_deserialize_cost : lazy_expr -&gt; Gas.cost

  val force_decode : context -&gt; lazy_expr -&gt; (expr * context) tzresult Lwt.t

  val force_bytes : context -&gt; lazy_expr -&gt; (MBytes.t * context) tzresult Lwt.t

  val unit_parameter : lazy_expr

  module Legacy_support : sig
    val manager_script_code : lazy_expr

    val add_do :
      manager_pkh:Signature.Public_key_hash.t -&gt;
      script_code:lazy_expr -&gt;
      script_storage:lazy_expr -&gt;
      (lazy_expr * lazy_expr) tzresult Lwt.t

    val add_set_delegate :
      manager_pkh:Signature.Public_key_hash.t -&gt;
      script_code:lazy_expr -&gt;
      script_storage:lazy_expr -&gt;
      (lazy_expr * lazy_expr) tzresult Lwt.t

    val has_default_entrypoint : lazy_expr -&gt; bool

    val add_root_entrypoint : script_code:lazy_expr -&gt; lazy_expr tzresult Lwt.t
  end
end

module Constants : sig
  (** Fixed constants *)
  type fixed = {
    proof_of_work_nonce_size : int;
    nonce_length : int;
    max_revelations_per_block : int;
    max_operation_data_length : int;
    max_proposals_per_delegate : int;
  }

  val fixed_encoding : fixed Data_encoding.t

  val fixed : fixed

  val proof_of_work_nonce_size : int

  val nonce_length : int

  val max_revelations_per_block : int

  val max_operation_data_length : int

  val max_proposals_per_delegate : int

  (** Constants parameterized by context *)
  type parametric = {
    preserved_cycles : int;
    blocks_per_cycle : int32;
    blocks_per_commitment : int32;
    blocks_per_roll_snapshot : int32;
    blocks_per_voting_period : int32;
    time_between_blocks : Period.t list;
    endorsers_per_block : int;
    hard_gas_limit_per_operation : Z.t;
    hard_gas_limit_per_block : Z.t;
    proof_of_work_threshold : int64;
    tokens_per_roll : Tez.t;
    michelson_maximum_type_size : int;
    seed_nonce_revelation_tip : Tez.t;
    origination_size : int;
    block_security_deposit : Tez.t;
    endorsement_security_deposit : Tez.t;
    block_reward : Tez.t;
    endorsement_reward : Tez.t;
    cost_per_byte : Tez.t;
    hard_storage_limit_per_operation : Z.t;
    test_chain_duration : int64;
    quorum_min : int32;
    quorum_max : int32;
    min_proposal_quorum : int32;
    initial_endorsers : int;
    delay_per_missing_endorsement : Period.t;
  }

  val parametric_encoding : parametric Data_encoding.t

  val parametric : context -&gt; parametric

  val preserved_cycles : context -&gt; int

  val blocks_per_cycle : context -&gt; int32

  val blocks_per_commitment : context -&gt; int32

  val blocks_per_roll_snapshot : context -&gt; int32

  val blocks_per_voting_period : context -&gt; int32

  val time_between_blocks : context -&gt; Period.t list

  val endorsers_per_block : context -&gt; int

  val initial_endorsers : context -&gt; int

  val delay_per_missing_endorsement : context -&gt; Period.t

  val hard_gas_limit_per_operation : context -&gt; Z.t

  val hard_gas_limit_per_block : context -&gt; Z.t

  val cost_per_byte : context -&gt; Tez.t

  val hard_storage_limit_per_operation : context -&gt; Z.t

  val proof_of_work_threshold : context -&gt; int64

  val tokens_per_roll : context -&gt; Tez.t

  val michelson_maximum_type_size : context -&gt; int

  val block_reward : context -&gt; Tez.t

  val endorsement_reward : context -&gt; Tez.t

  val seed_nonce_revelation_tip : context -&gt; Tez.t

  val origination_size : context -&gt; int

  val block_security_deposit : context -&gt; Tez.t

  val endorsement_security_deposit : context -&gt; Tez.t

  val test_chain_duration : context -&gt; int64

  val quorum_min : context -&gt; int32

  val quorum_max : context -&gt; int32

  val min_proposal_quorum : context -&gt; int32

  (** All constants: fixed and parametric *)
  type t = {fixed : fixed; parametric : parametric}

  val encoding : t Data_encoding.t
end

module Voting_period : sig
  include BASIC_DATA

  type voting_period = t

  val rpc_arg : voting_period RPC_arg.arg

  val root : voting_period

  val succ : voting_period -&gt; voting_period

  type kind = Proposal | Testing_vote | Testing | Promotion_vote

  val kind_encoding : kind Data_encoding.encoding

  val to_int32 : voting_period -&gt; int32
end

module Level : sig
  type t = private {
    level : Raw_level.t;
    level_position : int32;
    cycle : Cycle.t;
    cycle_position : int32;
    voting_period : Voting_period.t;
    voting_period_position : int32;
    expected_commitment : bool;
  }

  include BASIC_DATA with type t := t

  val pp_full : Format.formatter -&gt; t -&gt; unit

  type level = t

  val root : context -&gt; level

  val succ : context -&gt; level -&gt; level

  val pred : context -&gt; level -&gt; level option

  val from_raw : context -&gt; ?offset:int32 -&gt; Raw_level.t -&gt; level

  val diff : level -&gt; level -&gt; int32

  val current : context -&gt; level

  val last_level_in_cycle : context -&gt; Cycle.t -&gt; level

  val levels_in_cycle : context -&gt; Cycle.t -&gt; level list

  val levels_in_current_cycle : context -&gt; ?offset:int32 -&gt; unit -&gt; level list

  val last_allowed_fork_level : context -&gt; Raw_level.t
end

module Fitness : sig
  <abbr class="mark-error" title="Name for the included signature not found">include </abbr><abbr class="mark-error" title="Name for the included signature not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

The typeof in module types is not handled">module type of Fitness</abbr>

  type fitness = t

  val increase : ?gap:int -&gt; context -&gt; context

  val current : context -&gt; int64

  val to_int64 : fitness -&gt; int64 tzresult
end

module Nonce : sig
  type t

  type nonce = t

  val encoding : nonce Data_encoding.t

  type unrevealed = {
    nonce_hash : Nonce_hash.t;
    delegate : public_key_hash;
    rewards : Tez.t;
    fees : Tez.t;
  }

  val record_hash : context -&gt; unrevealed -&gt; context tzresult Lwt.t

  val reveal : context -&gt; Level.t -&gt; nonce -&gt; context tzresult Lwt.t

  type status = Unrevealed of unrevealed | Revealed of nonce

  val get : context -&gt; Level.t -&gt; status tzresult Lwt.t

  val of_bytes : MBytes.t -&gt; nonce tzresult

  val hash : nonce -&gt; Nonce_hash.t

  val check_hash : nonce -&gt; Nonce_hash.t -&gt; bool
end

module Seed : sig
  type seed

  <abbr class="mark-error" title="Extensible types are not handled.">type error +=
    | Unknown of {oldest : Cycle.t; cycle : Cycle.t; latest : Cycle.t}</abbr>

  val for_cycle : context -&gt; Cycle.t -&gt; seed tzresult Lwt.t

  val cycle_end :
    context -&gt; Cycle.t -&gt; (context * Nonce.unrevealed list) tzresult Lwt.t

  val seed_encoding : seed Data_encoding.t
end

module Big_map : sig
  type id = Z.t

  val fresh : context -&gt; (context * id) tzresult Lwt.t

  val fresh_temporary : context -&gt; context * id

  val mem :
    context -&gt; id -&gt; Script_expr_hash.t -&gt; (context * bool) tzresult Lwt.t

  val get_opt :
    context -&gt;
    id -&gt;
    Script_expr_hash.t -&gt;
    (context * Script.expr option) tzresult Lwt.t

  val rpc_arg : id RPC_arg.t

  val cleanup_temporary : context -&gt; context Lwt.t

  val exists :
    context -&gt;
    id -&gt;
    (context * (Script.expr * Script.expr) option) tzresult Lwt.t
end

module Contract : sig
  include BASIC_DATA

  type contract = t

  val rpc_arg : contract RPC_arg.arg

  val to_b58check : contract -&gt; string

  val of_b58check : string -&gt; contract tzresult

  val implicit_contract : public_key_hash -&gt; contract

  val is_implicit : contract -&gt; public_key_hash option

  val exists : context -&gt; contract -&gt; bool tzresult Lwt.t

  val must_exist : context -&gt; contract -&gt; unit tzresult Lwt.t

  val allocated : context -&gt; contract -&gt; bool tzresult Lwt.t

  val must_be_allocated : context -&gt; contract -&gt; unit tzresult Lwt.t

  val list : context -&gt; contract list Lwt.t

  val get_manager_key : context -&gt; public_key_hash -&gt; public_key tzresult Lwt.t

  val is_manager_key_revealed :
    context -&gt; public_key_hash -&gt; bool tzresult Lwt.t

  val reveal_manager_key :
    context -&gt; public_key_hash -&gt; public_key -&gt; context tzresult Lwt.t

  val get_script_code :
    context -&gt; contract -&gt; (context * Script.lazy_expr option) tzresult Lwt.t

  val get_script :
    context -&gt; contract -&gt; (context * Script.t option) tzresult Lwt.t

  val get_storage :
    context -&gt; contract -&gt; (context * Script.expr option) tzresult Lwt.t

  val get_counter : context -&gt; public_key_hash -&gt; Z.t tzresult Lwt.t

  val get_balance : context -&gt; contract -&gt; Tez.t tzresult Lwt.t

  val init_origination_nonce : context -&gt; Operation_hash.t -&gt; context

  val unset_origination_nonce : context -&gt; context

  val fresh_contract_from_current_nonce :
    context -&gt; (context * t) tzresult Lwt.t

  val originated_from_current_nonce :
    since:context -&gt; until:context -&gt; contract list tzresult Lwt.t

  type big_map_diff_item =
    | Update of {
        big_map : Big_map.id;
        diff_key : Script.expr;
        diff_key_hash : Script_expr_hash.t;
        diff_value : Script.expr option;
      }
    | Clear of Big_map.id
    | Copy of Big_map.id * Big_map.id
    | Alloc of {
        big_map : Big_map.id;
        key_type : Script.expr;
        value_type : Script.expr;
      }

  type big_map_diff = big_map_diff_item list

  val big_map_diff_encoding : big_map_diff Data_encoding.t

  val originate :
    context -&gt;
    contract -&gt;
    balance:Tez.t -&gt;
    script:Script.t * big_map_diff option -&gt;
    delegate:public_key_hash option -&gt;
    context tzresult Lwt.t

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Balance_too_low of contract * Tez.t * Tez.t</abbr>

  val spend : context -&gt; contract -&gt; Tez.t -&gt; context tzresult Lwt.t

  val credit : context -&gt; contract -&gt; Tez.t -&gt; context tzresult Lwt.t

  val update_script_storage :
    context -&gt;
    contract -&gt;
    Script.expr -&gt;
    big_map_diff option -&gt;
    context tzresult Lwt.t

  val used_storage_space : context -&gt; t -&gt; Z.t tzresult Lwt.t

  val increment_counter : context -&gt; public_key_hash -&gt; context tzresult Lwt.t

  val check_counter_increment :
    context -&gt; public_key_hash -&gt; Z.t -&gt; unit tzresult Lwt.t

  (**/**)

  (* Only for testing *)
  type origination_nonce

  val initial_origination_nonce : Operation_hash.t -&gt; origination_nonce

  val originated_contract : origination_nonce -&gt; contract
end

module Delegate : sig
  type balance =
    | Contract of Contract.t
    | Rewards of Signature.Public_key_hash.t * Cycle.t
    | Fees of Signature.Public_key_hash.t * Cycle.t
    | Deposits of Signature.Public_key_hash.t * Cycle.t

  type balance_update = Debited of Tez.t | Credited of Tez.t

  type balance_updates = (balance * balance_update) list

  val balance_updates_encoding : balance_updates Data_encoding.t

  val cleanup_balance_updates : balance_updates -&gt; balance_updates

  val get : context -&gt; Contract.t -&gt; public_key_hash option tzresult Lwt.t

  val set :
    context -&gt; Contract.t -&gt; public_key_hash option -&gt; context tzresult Lwt.t

  val fold :
    context -&gt; init:'a -&gt; f:(public_key_hash -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val list : context -&gt; public_key_hash list Lwt.t

  val freeze_deposit :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; context tzresult Lwt.t

  val freeze_rewards :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; context tzresult Lwt.t

  val freeze_fees :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; context tzresult Lwt.t

  val cycle_end :
    context -&gt;
    Cycle.t -&gt;
    Nonce.unrevealed list -&gt;
    (context * balance_updates * Signature.Public_key_hash.t list) tzresult
    Lwt.t

  type frozen_balance = {deposit : Tez.t; fees : Tez.t; rewards : Tez.t}

  val punish :
    context -&gt;
    public_key_hash -&gt;
    Cycle.t -&gt;
    (context * frozen_balance) tzresult Lwt.t

  val full_balance : context -&gt; public_key_hash -&gt; Tez.t tzresult Lwt.t

  val has_frozen_balance :
    context -&gt; public_key_hash -&gt; Cycle.t -&gt; bool tzresult Lwt.t

  val frozen_balance : context -&gt; public_key_hash -&gt; Tez.t tzresult Lwt.t

  val frozen_balance_encoding : frozen_balance Data_encoding.t

  val frozen_balance_by_cycle_encoding :
    frozen_balance Cycle.Map.t Data_encoding.t

  val frozen_balance_by_cycle :
    context -&gt; Signature.Public_key_hash.t -&gt; frozen_balance Cycle.Map.t Lwt.t

  val staking_balance :
    context -&gt; Signature.Public_key_hash.t -&gt; Tez.t tzresult Lwt.t

  val delegated_contracts :
    context -&gt; Signature.Public_key_hash.t -&gt; Contract_repr.t list Lwt.t

  val delegated_balance :
    context -&gt; Signature.Public_key_hash.t -&gt; Tez.t tzresult Lwt.t

  val deactivated :
    context -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

  val grace_period :
    context -&gt; Signature.Public_key_hash.t -&gt; Cycle.t tzresult Lwt.t
end

module Vote : sig
  type proposal = Protocol_hash.t

  val record_proposal :
    context -&gt; Protocol_hash.t -&gt; public_key_hash -&gt; context tzresult Lwt.t

  val get_proposals : context -&gt; int32 Protocol_hash.Map.t tzresult Lwt.t

  val clear_proposals : context -&gt; context Lwt.t

  val recorded_proposal_count_for_delegate :
    context -&gt; public_key_hash -&gt; int tzresult Lwt.t

  val listings_encoding :
    (Signature.Public_key_hash.t * int32) list Data_encoding.t

  val freeze_listings : context -&gt; context tzresult Lwt.t

  val clear_listings : context -&gt; context tzresult Lwt.t

  val listing_size : context -&gt; int32 tzresult Lwt.t

  val in_listings : context -&gt; public_key_hash -&gt; bool Lwt.t

  val get_listings : context -&gt; (public_key_hash * int32) list Lwt.t

  type ballot = Yay | Nay | Pass

  val ballot_encoding : ballot Data_encoding.t

  type ballots = {yay : int32; nay : int32; pass : int32}

  val ballots_encoding : ballots Data_encoding.t

  val has_recorded_ballot : context -&gt; public_key_hash -&gt; bool Lwt.t

  val record_ballot :
    context -&gt; public_key_hash -&gt; ballot -&gt; context tzresult Lwt.t

  val get_ballots : context -&gt; ballots tzresult Lwt.t

  val get_ballot_list :
    context -&gt; (Signature.Public_key_hash.t * ballot) list Lwt.t

  val clear_ballots : context -&gt; context Lwt.t

  val get_current_period_kind : context -&gt; Voting_period.kind tzresult Lwt.t

  val set_current_period_kind :
    context -&gt; Voting_period.kind -&gt; context tzresult Lwt.t

  val get_current_quorum : context -&gt; int32 tzresult Lwt.t

  val get_participation_ema : context -&gt; int32 tzresult Lwt.t

  val set_participation_ema : context -&gt; int32 -&gt; context tzresult Lwt.t

  val get_current_proposal : context -&gt; proposal tzresult Lwt.t

  val init_current_proposal : context -&gt; proposal -&gt; context tzresult Lwt.t

  val clear_current_proposal : context -&gt; context tzresult Lwt.t
end

module Block_header : sig
  type t = {shell : Block_header.shell_header; protocol_data : protocol_data}

  and protocol_data = {contents : contents; signature : Signature.t}

  and contents = {
    priority : int;
    seed_nonce_hash : Nonce_hash.t option;
    proof_of_work_nonce : MBytes.t;
  }

  type block_header = t

  type raw = Block_header.t

  type shell_header = Block_header.shell_header

  val raw : block_header -&gt; raw

  val hash : block_header -&gt; Block_hash.t

  val hash_raw : raw -&gt; Block_hash.t

  val encoding : block_header Data_encoding.encoding

  val raw_encoding : raw Data_encoding.t

  val contents_encoding : contents Data_encoding.t

  val unsigned_encoding : (shell_header * contents) Data_encoding.t

  val protocol_data_encoding : protocol_data Data_encoding.encoding

  val shell_header_encoding : shell_header Data_encoding.encoding

  (** The maximum size of block headers in bytes *)
  val max_header_length : int
end

module Kind : sig
  type seed_nonce_revelation = Seed_nonce_revelation_kind

  type double_endorsement_evidence = Double_endorsement_evidence_kind

  type double_baking_evidence = Double_baking_evidence_kind

  type activate_account = Activate_account_kind

  type endorsement = Endorsement_kind

  type proposals = Proposals_kind

  type ballot = Ballot_kind

  type reveal = Reveal_kind

  type transaction = Transaction_kind

  type origination = Origination_kind

  type delegation = Delegation_kind

  type 'a manager =
    | Reveal_manager_kind : reveal manager
    | Transaction_manager_kind : transaction manager
    | Origination_manager_kind : origination manager
    | Delegation_manager_kind : delegation manager
end

type 'kind operation = {
  shell : Operation.shell_header;
  protocol_data : 'kind protocol_data;
}

and 'kind protocol_data = {
  contents : 'kind contents_list;
  signature : Signature.t option;
}

and _ contents_list =
  | Single : 'kind contents -&gt; 'kind contents_list
  | Cons :
      'kind Kind.manager contents * 'rest Kind.manager contents_list
      -&gt; ('kind * 'rest) Kind.manager contents_list

and _ contents =
  | Endorsement : {level : Raw_level.t} -&gt; Kind.endorsement contents
  | Seed_nonce_revelation : {
      level : Raw_level.t;
      nonce : Nonce.t;
    }
      -&gt; Kind.seed_nonce_revelation contents
  | Double_endorsement_evidence : {
      op1 : Kind.endorsement operation;
      op2 : Kind.endorsement operation;
    }
      -&gt; Kind.double_endorsement_evidence contents
  | Double_baking_evidence : {
      bh1 : Block_header.t;
      bh2 : Block_header.t;
    }
      -&gt; Kind.double_baking_evidence contents
  | Activate_account : {
      id : Ed25519.Public_key_hash.t;
      activation_code : Blinded_public_key_hash.activation_code;
    }
      -&gt; Kind.activate_account contents
  | Proposals : {
      source : Signature.Public_key_hash.t;
      period : Voting_period.t;
      proposals : Protocol_hash.t list;
    }
      -&gt; Kind.proposals contents
  | Ballot : {
      source : Signature.Public_key_hash.t;
      period : Voting_period.t;
      proposal : Protocol_hash.t;
      ballot : Vote.ballot;
    }
      -&gt; Kind.ballot contents
  | Manager_operation : {
      source : Signature.Public_key_hash.t;
      fee : Tez.tez;
      counter : counter;
      operation : 'kind manager_operation;
      gas_limit : Z.t;
      storage_limit : Z.t;
    }
      -&gt; 'kind Kind.manager contents

and _ manager_operation =
  | Reveal : Signature.Public_key.t -&gt; Kind.reveal manager_operation
  | Transaction : {
      amount : Tez.tez;
      parameters : Script.lazy_expr;
      entrypoint : string;
      destination : Contract.contract;
    }
      -&gt; Kind.transaction manager_operation
  | Origination : {
      delegate : Signature.Public_key_hash.t option;
      script : Script.t;
      credit : Tez.tez;
      preorigination : Contract.t option;
    }
      -&gt; Kind.origination manager_operation
  | Delegation :
      Signature.Public_key_hash.t option
      -&gt; Kind.delegation manager_operation

and counter = Z.t

type 'kind internal_operation = {
  source : Contract.contract;
  operation : 'kind manager_operation;
  nonce : int;
}

type packed_manager_operation =
  | Manager : 'kind manager_operation -&gt; packed_manager_operation

type packed_contents = Contents : 'kind contents -&gt; packed_contents

type packed_contents_list =
  | Contents_list : 'kind contents_list -&gt; packed_contents_list

type packed_protocol_data =
  | Operation_data : 'kind protocol_data -&gt; packed_protocol_data

type packed_operation = {
  shell : Operation.shell_header;
  protocol_data : packed_protocol_data;
}

type packed_internal_operation =
  | Internal_operation : 'kind internal_operation -&gt; packed_internal_operation

val manager_kind : 'kind manager_operation -&gt; 'kind Kind.manager

module Fees : sig
  val origination_burn : context -&gt; (context * Tez.t) tzresult Lwt.t

  val record_paid_storage_space :
    context -&gt; Contract.t -&gt; (context * Z.t * Z.t * Tez.t) tzresult Lwt.t

  val start_counting_storage_fees : context -&gt; context

  val burn_storage_fees :
    context -&gt; storage_limit:Z.t -&gt; payer:Contract.t -&gt; context tzresult Lwt.t

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Cannot_pay_storage_fee</abbr> (* `Temporary *)

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Storage_limit_too_high</abbr> (* `Permanent *)

  val check_storage_limit : context -&gt; storage_limit:Z.t -&gt; unit tzresult
end

module Operation : sig
  type nonrec 'kind contents = 'kind contents

  type nonrec packed_contents = packed_contents

  val contents_encoding : packed_contents Data_encoding.t

  type nonrec 'kind protocol_data = 'kind protocol_data

  type nonrec packed_protocol_data = packed_protocol_data

  val protocol_data_encoding : packed_protocol_data Data_encoding.t

  val unsigned_encoding :
    (Operation.shell_header * packed_contents_list) Data_encoding.t

  type raw = Operation.t = {shell : Operation.shell_header; proto : MBytes.t}

  val raw_encoding : raw Data_encoding.t

  val contents_list_encoding : packed_contents_list Data_encoding.t

  type 'kind t = 'kind operation = {
    shell : Operation.shell_header;
    protocol_data : 'kind protocol_data;
  }

  type nonrec packed = packed_operation

  val encoding : packed Data_encoding.t

  val raw : _ operation -&gt; raw

  val hash : _ operation -&gt; Operation_hash.t

  val hash_raw : raw -&gt; Operation_hash.t

  val hash_packed : packed_operation -&gt; Operation_hash.t

  val acceptable_passes : packed_operation -&gt; int list

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Missing_signature</abbr> (* `Permanent *)

  <abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

  val check_signature :
    public_key -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult Lwt.t

  val check_signature_sync :
    public_key -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult

  val internal_operation_encoding : packed_internal_operation Data_encoding.t

  val pack : 'kind operation -&gt; packed_operation

  type ('a, 'b) eq = Eq : ('a, 'a) eq

  val equal : 'a operation -&gt; 'b operation -&gt; ('a, 'b) eq option

  module Encoding : sig
    type 'b case =
      | Case : {
          tag : int;
          name : string;
          encoding : 'a Data_encoding.t;
          select : packed_contents -&gt; 'b contents option;
          proj : 'b contents -&gt; 'a;
          inj : 'a -&gt; 'b contents;
        }
          -&gt; 'b case

    val endorsement_case : Kind.endorsement case

    val seed_nonce_revelation_case : Kind.seed_nonce_revelation case

    val double_endorsement_evidence_case :
      Kind.double_endorsement_evidence case

    val double_baking_evidence_case : Kind.double_baking_evidence case

    val activate_account_case : Kind.activate_account case

    val proposals_case : Kind.proposals case

    val ballot_case : Kind.ballot case

    val reveal_case : Kind.reveal Kind.manager case

    val transaction_case : Kind.transaction Kind.manager case

    val origination_case : Kind.origination Kind.manager case

    val delegation_case : Kind.delegation Kind.manager case

    module Manager_operations : sig
      type 'b case =
        | MCase : {
            tag : int;
            name : string;
            encoding : 'a Data_encoding.t;
            select :
              packed_manager_operation -&gt; 'kind manager_operation option;
            proj : 'kind manager_operation -&gt; 'a;
            inj : 'a -&gt; 'kind manager_operation;
          }
            -&gt; 'kind case

      val reveal_case : Kind.reveal case

      val transaction_case : Kind.transaction case

      val origination_case : Kind.origination case

      val delegation_case : Kind.delegation case
    end
  end

  val of_list : packed_contents list -&gt; packed_contents_list

  val to_list : packed_contents_list -&gt; packed_contents list
end

module Roll : sig
  type t = private int32

  type roll = t

  val encoding : roll Data_encoding.t

  val snapshot_rolls : context -&gt; context tzresult Lwt.t

  val cycle_end : context -&gt; Cycle.t -&gt; context tzresult Lwt.t

  val baking_rights_owner :
    context -&gt; Level.t -&gt; priority:int -&gt; public_key tzresult Lwt.t

  val endorsement_rights_owner :
    context -&gt; Level.t -&gt; slot:int -&gt; public_key tzresult Lwt.t

  val delegate_pubkey : context -&gt; public_key_hash -&gt; public_key tzresult Lwt.t

  val get_rolls :
    context -&gt; Signature.Public_key_hash.t -&gt; roll list tzresult Lwt.t

  val get_change :
    context -&gt; Signature.Public_key_hash.t -&gt; Tez.t tzresult Lwt.t
end

module Commitment : sig
  type t = {
    blinded_public_key_hash : Blinded_public_key_hash.t;
    amount : Tez.tez;
  }

  val get_opt :
    context -&gt; Blinded_public_key_hash.t -&gt; Tez.t option tzresult Lwt.t

  val delete : context -&gt; Blinded_public_key_hash.t -&gt; context tzresult Lwt.t
end

module Bootstrap : sig
  val cycle_end : context -&gt; Cycle.t -&gt; context tzresult Lwt.t
end

module Global : sig
  val get_block_priority : context -&gt; int tzresult Lwt.t

  val set_block_priority : context -&gt; int -&gt; context tzresult Lwt.t
end

val prepare_first_block :
  Context.t -&gt;
  typecheck:(context -&gt;
            Script.t -&gt;
            ((Script.t * Contract.big_map_diff option) * context) tzresult
            Lwt.t) -&gt;
  level:Int32.t -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  context tzresult Lwt.t

val prepare :
  Context.t -&gt;
  level:Int32.t -&gt;
  predecessor_timestamp:Time.t -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  context tzresult Lwt.t

val finalize : ?commit_message:string -&gt; context -&gt; Updater.validation_result

val activate : context -&gt; Protocol_hash.t -&gt; context Lwt.t

val fork_test_chain : context -&gt; Protocol_hash.t -&gt; Time.t -&gt; context Lwt.t

val record_endorsement : context -&gt; Signature.Public_key_hash.t -&gt; context

val allowed_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t

val init_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t -&gt;
  context

val included_endorsements : context -&gt; int

val reset_internal_nonce : context -&gt; context

val fresh_internal_nonce : context -&gt; (context * int) tzresult

val record_internal_nonce : context -&gt; int -&gt; context

val internal_nonce_already_recorded : context -&gt; int -&gt; bool

val add_fees : context -&gt; Tez.t -&gt; context tzresult Lwt.t

val add_rewards : context -&gt; Tez.t -&gt; context tzresult Lwt.t

val add_deposit :
  context -&gt; Signature.Public_key_hash.t -&gt; Tez.t -&gt; context tzresult Lwt.t

val get_fees : context -&gt; Tez.t

val get_rewards : context -&gt; Tez.t

val get_deposits : context -&gt; Tez.t Signature.Public_key_hash.Map.t

val description : context Storage_description.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_context.mli"><code>Alpha_context_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Nonce_hash.
Require Tezos.Script_expr_hash.
Require Tezos.Storage_description.

Module BASIC_DATA.
  Record signature {t : Set} := {
    t := t;
    op_eq : t -&gt; t -&gt; bool;
    op_ltgt : t -&gt; t -&gt; bool;
    op_lt : t -&gt; t -&gt; bool;
    op_lteq : t -&gt; t -&gt; bool;
    op_gteq : t -&gt; t -&gt; bool;
    op_gt : t -&gt; t -&gt; bool;
    compare : t -&gt; t -&gt; Z;
    equal : t -&gt; t -&gt; bool;
    max : t -&gt; t -&gt; t;
    min : t -&gt; t -&gt; t;
    encoding : Data_encoding.t t;
    pp : Format.formatter -&gt; t -&gt; unit;
  }.
  Arguments signature : clear implicits.
End BASIC_DATA.

Parameter t : Set.

Definition context := t.

Definition public_key := Signature.Public_key.[S.SPublic_key.t].

Definition public_key_hash := Signature.Public_key_hash.[S.SPublic_key_hash.t].

Definition signature := Signature.t.

Module Tez.
  Parameter Included_BASIC_DATA : {t : _ &amp; BASIC_DATA.signature t}.
  
  Definition t := Included_BASIC_DATA.[BASIC_DATA.t].
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Definition tez := t.
  
  Parameter zero : tez.
  
  Parameter one_mutez : tez.
  
  Parameter one_cent : tez.
  
  Parameter fifty_cents : tez.
  
  Parameter one : tez.
  
  Parameter op_minusquestion : tez -&gt; tez -&gt; Error_monad.tzresult tez.
  
  Parameter op_plusquestion : tez -&gt; tez -&gt; Error_monad.tzresult tez.
  
  Parameter op_starquestion : tez -&gt; int64 -&gt; Error_monad.tzresult tez.
  
  Parameter op_divquestion : tez -&gt; int64 -&gt; Error_monad.tzresult tez.
  
  Parameter of_string : string -&gt; option tez.
  
  Parameter to_string : tez -&gt; string.
  
  Parameter of_mutez : int64 -&gt; option tez.
  
  Parameter to_mutez : tez -&gt; int64.
End Tez.

Module Period.
  Parameter Included_BASIC_DATA : {t : _ &amp; BASIC_DATA.signature t}.
  
  Definition t := Included_BASIC_DATA.[BASIC_DATA.t].
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Definition period := t.
  
  Parameter rpc_arg : RPC_arg.arg period.
  
  Parameter of_seconds : int64 -&gt; Error_monad.tzresult period.
  
  Parameter to_seconds : period -&gt; int64.
  
  Parameter mult : int32 -&gt; period -&gt; Error_monad.tzresult period.
  
  Parameter zero : period.
  
  Parameter one_second : period.
  
  Parameter one_minute : period.
  
  Parameter one_hour : period.
End Period.

Module Timestamp.
  Parameter Included_BASIC_DATA : {_ : unit &amp; BASIC_DATA.signature Time.t}.
  
  Definition t := Included_BASIC_DATA.[BASIC_DATA.t].
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Definition time := t.
  
  Parameter op_plusquestion : time -&gt; Period.t -&gt; Error_monad.tzresult time.
  
  Parameter op_minusquestion : time -&gt; time -&gt; Error_monad.tzresult Period.t.
  
  Parameter of_notation : string -&gt; option time.
  
  Parameter to_notation : time -&gt; string.
  
  Parameter of_seconds : string -&gt; option time.
  
  Parameter to_seconds_string : time -&gt; string.
  
  Parameter current : context -&gt; time.
End Timestamp.

Module Raw_level.
  Parameter Included_BASIC_DATA : {t : _ &amp; BASIC_DATA.signature t}.
  
  Definition t := Included_BASIC_DATA.[BASIC_DATA.t].
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Definition raw_level := t.
  
  Parameter rpc_arg : RPC_arg.arg raw_level.
  
  Parameter diff : raw_level -&gt; raw_level -&gt; int32.
  
  Parameter root : raw_level.
  
  Parameter succ : raw_level -&gt; raw_level.
  
  Parameter pred : raw_level -&gt; option raw_level.
  
  Parameter to_int32 : raw_level -&gt; int32.
  
  Parameter of_int32 : int32 -&gt; Error_monad.tzresult raw_level.
End Raw_level.

Module Cycle.
  Parameter Included_BASIC_DATA : {t : _ &amp; BASIC_DATA.signature t}.
  
  Definition t := Included_BASIC_DATA.[BASIC_DATA.t].
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Definition cycle := t.
  
  Parameter rpc_arg : RPC_arg.arg cycle.
  
  Parameter root : cycle.
  
  Parameter succ : cycle -&gt; cycle.
  
  Parameter pred : cycle -&gt; option cycle.
  
  Parameter add : cycle -&gt; Z -&gt; cycle.
  
  Parameter sub : cycle -&gt; Z -&gt; option cycle.
  
  Parameter to_int32 : cycle -&gt; int32.
  
  Parameter Map : {t : _ &amp; S.MAP.signature cycle t}.
End Cycle.

Module Gas.
  Module t.
    Module Limited.
      Record record {remaining : Set} := {
        remaining : remaining }.
      Arguments record : clear implicits.
    End Limited.
    Definition Limited := Limited.record.
  End t.
  
  Inductive t : Set :=
  | Unaccounted : t
  | Limited : t.Limited Z.t -&gt; t.
  
  Parameter encoding : Data_encoding.encoding t.
  
  Parameter pp : Format.formatter -&gt; t -&gt; unit.
  
  Parameter cost : Set.
  
  Parameter cost_encoding : Data_encoding.encoding cost.
  
  Parameter pp_cost : Format.formatter -&gt; cost -&gt; unit.
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  Parameter free : cost.
  
  Parameter atomic_step_cost : Z -&gt; cost.
  
  Parameter step_cost : Z -&gt; cost.
  
  Parameter alloc_cost : Z -&gt; cost.
  
  Parameter alloc_bytes_cost : Z -&gt; cost.
  
  Parameter alloc_mbytes_cost : Z -&gt; cost.
  
  Parameter alloc_bits_cost : Z -&gt; cost.
  
  Parameter read_bytes_cost : Z.t -&gt; cost.
  
  Parameter write_bytes_cost : Z.t -&gt; cost.
  
  Parameter op_starat : Z -&gt; cost -&gt; cost.
  
  Parameter op_plusat : cost -&gt; cost -&gt; cost.
  
  Parameter check_limit : context -&gt; Z.t -&gt; Error_monad.tzresult unit.
  
  Parameter set_limit : context -&gt; Z.t -&gt; context.
  
  Parameter set_unlimited : context -&gt; context.
  
  Parameter consume : context -&gt; cost -&gt; Error_monad.tzresult context.
  
  Parameter check_enough : context -&gt; cost -&gt; Error_monad.tzresult unit.
  
  Parameter level : context -&gt; t.
  
  Parameter consumed : context -&gt; context -&gt; Z.t.
  
  Parameter block_level : context -&gt; Z.t.
End Gas.

Parameter Script_int : typeof.

Module Script_timestamp.
  Parameter t : Set.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter to_string : t -&gt; string.
  
  Parameter to_notation : t -&gt; option string.
  
  Parameter to_num_str : t -&gt; string.
  
  Parameter of_string : string -&gt; option t.
  
  Parameter diff : t -&gt; t -&gt; Script_int.num Script_int.z.
  
  Parameter add_delta : t -&gt; Script_int.num Script_int.z -&gt; t.
  
  Parameter sub_delta : t -&gt; Script_int.num Script_int.z -&gt; t.
  
  Parameter now : context -&gt; t.
  
  Parameter to_zint : t -&gt; Z.t.
  
  Parameter of_zint : Z.t -&gt; t.
End Script_timestamp.

Module Script.
  Inductive prim : Set :=
  | K_parameter : prim
  | K_storage : prim
  | K_code : prim
  | D_False : prim
  | D_Elt : prim
  | D_Left : prim
  | D_None : prim
  | D_Pair : prim
  | D_Right : prim
  | D_Some : prim
  | D_True : prim
  | D_Unit : prim
  | I_PACK : prim
  | I_UNPACK : prim
  | I_BLAKE2B : prim
  | I_SHA256 : prim
  | I_SHA512 : prim
  | I_ABS : prim
  | I_ADD : prim
  | I_AMOUNT : prim
  | I_AND : prim
  | I_BALANCE : prim
  | I_CAR : prim
  | I_CDR : prim
  | I_CHAIN_ID : prim
  | I_CHECK_SIGNATURE : prim
  | I_COMPARE : prim
  | I_CONCAT : prim
  | I_CONS : prim
  | I_CREATE_ACCOUNT : prim
  | I_CREATE_CONTRACT : prim
  | I_IMPLICIT_ACCOUNT : prim
  | I_DIP : prim
  | I_DROP : prim
  | I_DUP : prim
  | I_EDIV : prim
  | I_EMPTY_BIG_MAP : prim
  | I_EMPTY_MAP : prim
  | I_EMPTY_SET : prim
  | I_EQ : prim
  | I_EXEC : prim
  | I_APPLY : prim
  | I_FAILWITH : prim
  | I_GE : prim
  | I_GET : prim
  | I_GT : prim
  | I_HASH_KEY : prim
  | I_IF : prim
  | I_IF_CONS : prim
  | I_IF_LEFT : prim
  | I_IF_NONE : prim
  | I_INT : prim
  | I_LAMBDA : prim
  | I_LE : prim
  | I_LEFT : prim
  | I_LOOP : prim
  | I_LSL : prim
  | I_LSR : prim
  | I_LT : prim
  | I_MAP : prim
  | I_MEM : prim
  | I_MUL : prim
  | I_NEG : prim
  | I_NEQ : prim
  | I_NIL : prim
  | I_NONE : prim
  | I_NOT : prim
  | I_NOW : prim
  | I_OR : prim
  | I_PAIR : prim
  | I_PUSH : prim
  | I_RIGHT : prim
  | I_SIZE : prim
  | I_SOME : prim
  | I_SOURCE : prim
  | I_SENDER : prim
  | I_SELF : prim
  | I_SLICE : prim
  | I_STEPS_TO_QUOTA : prim
  | I_SUB : prim
  | I_SWAP : prim
  | I_TRANSFER_TOKENS : prim
  | I_SET_DELEGATE : prim
  | I_UNIT : prim
  | I_UPDATE : prim
  | I_XOR : prim
  | I_ITER : prim
  | I_LOOP_LEFT : prim
  | I_ADDRESS : prim
  | I_CONTRACT : prim
  | I_ISNAT : prim
  | I_CAST : prim
  | I_RENAME : prim
  | I_DIG : prim
  | I_DUG : prim
  | T_bool : prim
  | T_contract : prim
  | T_int : prim
  | T_key : prim
  | T_key_hash : prim
  | T_lambda : prim
  | T_list : prim
  | T_map : prim
  | T_big_map : prim
  | T_nat : prim
  | T_option : prim
  | T_or : prim
  | T_pair : prim
  | T_set : prim
  | T_signature : prim
  | T_string : prim
  | T_bytes : prim
  | T_mutez : prim
  | T_timestamp : prim
  | T_unit : prim
  | T_operation : prim
  | T_address : prim
  | T_chain_id : prim.
  
  Definition location := Micheline.canonical_location.
  
  Definition annot := Micheline.annot.
  
  Definition expr := Micheline.canonical prim.
  
  Definition lazy_expr := Data_encoding.lazy_t expr.
  
  Parameter lazy_expr : expr -&gt; lazy_expr.
  
  Definition node := Micheline.node location prim.
  
  Module t.
    Record record := {
      code : lazy_expr;
      storage : lazy_expr }.
  End t.
  Definition t := t.record.
  
  Parameter location_encoding : Data_encoding.t location.
  
  Parameter expr_encoding : Data_encoding.t expr.
  
  Parameter prim_encoding : Data_encoding.t prim.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter lazy_expr_encoding : Data_encoding.t lazy_expr.
  
  Parameter deserialized_cost : expr -&gt; Gas.cost.
  
  Parameter serialized_cost : MBytes.t -&gt; Gas.cost.
  
  Parameter traversal_cost : node -&gt; Gas.cost.
  
  Parameter node_cost : node -&gt; Gas.cost.
  
  Parameter int_node_cost : Z.t -&gt; Gas.cost.
  
  Parameter int_node_cost_of_numbits : Z -&gt; Gas.cost.
  
  Parameter string_node_cost : string -&gt; Gas.cost.
  
  Parameter string_node_cost_of_length : Z -&gt; Gas.cost.
  
  Parameter bytes_node_cost : MBytes.t -&gt; Gas.cost.
  
  Parameter bytes_node_cost_of_length : Z -&gt; Gas.cost.
  
  Parameter prim_node_cost_nonrec : list expr -&gt; annot -&gt; Gas.cost.
  
  Parameter prim_node_cost_nonrec_of_length : Z -&gt; annot -&gt; Gas.cost.
  
  Parameter seq_node_cost_nonrec : list expr -&gt; Gas.cost.
  
  Parameter seq_node_cost_nonrec_of_length : Z -&gt; Gas.cost.
  
  Parameter minimal_deserialize_cost : lazy_expr -&gt; Gas.cost.
  
  Parameter force_decode :
    context -&gt; lazy_expr -&gt; Lwt.t (Error_monad.tzresult (expr * context)).
  
  Parameter force_bytes :
    context -&gt; lazy_expr -&gt; Lwt.t (Error_monad.tzresult (MBytes.t * context)).
  
  Parameter unit_parameter : lazy_expr.
  
  Module Legacy_support.
    Parameter manager_script_code : lazy_expr.
    
    Parameter add_do :
      Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; lazy_expr -&gt;
      lazy_expr -&gt; Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter add_set_delegate :
      Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; lazy_expr -&gt;
      lazy_expr -&gt; Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter has_default_entrypoint : lazy_expr -&gt; bool.
    
    Parameter add_root_entrypoint :
      lazy_expr -&gt; Lwt.t (Error_monad.tzresult lazy_expr).
  End Legacy_support.
End Script.

Module Constants.
  Module fixed.
    Record record := {
      proof_of_work_nonce_size : Z;
      nonce_length : Z;
      max_revelations_per_block : Z;
      max_operation_data_length : Z;
      max_proposals_per_delegate : Z }.
  End fixed.
  Definition fixed := fixed.record.
  
  Parameter fixed_encoding : Data_encoding.t fixed.
  
  Parameter fixed : fixed.
  
  Parameter proof_of_work_nonce_size : Z.
  
  Parameter nonce_length : Z.
  
  Parameter max_revelations_per_block : Z.
  
  Parameter max_operation_data_length : Z.
  
  Parameter max_proposals_per_delegate : Z.
  
  Module parametric.
    Record record := {
      preserved_cycles : Z;
      blocks_per_cycle : int32;
      blocks_per_commitment : int32;
      blocks_per_roll_snapshot : int32;
      blocks_per_voting_period : int32;
      time_between_blocks : list Period.t;
      endorsers_per_block : Z;
      hard_gas_limit_per_operation : Z.t;
      hard_gas_limit_per_block : Z.t;
      proof_of_work_threshold : int64;
      tokens_per_roll : Tez.t;
      michelson_maximum_type_size : Z;
      seed_nonce_revelation_tip : Tez.t;
      origination_size : Z;
      block_security_deposit : Tez.t;
      endorsement_security_deposit : Tez.t;
      block_reward : Tez.t;
      endorsement_reward : Tez.t;
      cost_per_byte : Tez.t;
      hard_storage_limit_per_operation : Z.t;
      test_chain_duration : int64;
      quorum_min : int32;
      quorum_max : int32;
      min_proposal_quorum : int32;
      initial_endorsers : Z;
      delay_per_missing_endorsement : Period.t }.
  End parametric.
  Definition parametric := parametric.record.
  
  Parameter parametric_encoding : Data_encoding.t parametric.
  
  Parameter parametric : context -&gt; parametric.
  
  Parameter preserved_cycles : context -&gt; Z.
  
  Parameter blocks_per_cycle : context -&gt; int32.
  
  Parameter blocks_per_commitment : context -&gt; int32.
  
  Parameter blocks_per_roll_snapshot : context -&gt; int32.
  
  Parameter blocks_per_voting_period : context -&gt; int32.
  
  Parameter time_between_blocks : context -&gt; list Period.t.
  
  Parameter endorsers_per_block : context -&gt; Z.
  
  Parameter initial_endorsers : context -&gt; Z.
  
  Parameter delay_per_missing_endorsement : context -&gt; Period.t.
  
  Parameter hard_gas_limit_per_operation : context -&gt; Z.t.
  
  Parameter hard_gas_limit_per_block : context -&gt; Z.t.
  
  Parameter cost_per_byte : context -&gt; Tez.t.
  
  Parameter hard_storage_limit_per_operation : context -&gt; Z.t.
  
  Parameter proof_of_work_threshold : context -&gt; int64.
  
  Parameter tokens_per_roll : context -&gt; Tez.t.
  
  Parameter michelson_maximum_type_size : context -&gt; Z.
  
  Parameter block_reward : context -&gt; Tez.t.
  
  Parameter endorsement_reward : context -&gt; Tez.t.
  
  Parameter seed_nonce_revelation_tip : context -&gt; Tez.t.
  
  Parameter origination_size : context -&gt; Z.
  
  Parameter block_security_deposit : context -&gt; Tez.t.
  
  Parameter endorsement_security_deposit : context -&gt; Tez.t.
  
  Parameter test_chain_duration : context -&gt; int64.
  
  Parameter quorum_min : context -&gt; int32.
  
  Parameter quorum_max : context -&gt; int32.
  
  Parameter min_proposal_quorum : context -&gt; int32.
  
  Module t.
    Record record := {
      fixed : fixed;
      parametric : parametric }.
  End t.
  Definition t := t.record.
  
  Parameter encoding : Data_encoding.t t.
End Constants.

Module Voting_period.
  Parameter Included_BASIC_DATA : {t : _ &amp; BASIC_DATA.signature t}.
  
  Definition t := Included_BASIC_DATA.[BASIC_DATA.t].
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Definition voting_period := t.
  
  Parameter rpc_arg : RPC_arg.arg voting_period.
  
  Parameter root : voting_period.
  
  Parameter succ : voting_period -&gt; voting_period.
  
  Inductive kind : Set :=
  | Proposal : kind
  | Testing_vote : kind
  | Testing : kind
  | Promotion_vote : kind.
  
  Parameter kind_encoding : Data_encoding.encoding kind.
  
  Parameter to_int32 : voting_period -&gt; int32.
End Voting_period.

Module Level.
  Module t.
    Record record := {
      level : Raw_level.t;
      level_position : int32;
      cycle : Cycle.t;
      cycle_position : int32;
      voting_period : Voting_period.t;
      voting_period_position : int32;
      expected_commitment : bool }.
  End t.
  Definition t := t.record.
  
  Parameter Included_BASIC_DATA : {_ : unit &amp; BASIC_DATA.signature t}.
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Parameter pp_full : Format.formatter -&gt; t -&gt; unit.
  
  Definition level := t.
  
  Parameter root : context -&gt; level.
  
  Parameter succ : context -&gt; level -&gt; level.
  
  Parameter pred : context -&gt; level -&gt; option level.
  
  Parameter from_raw : context -&gt; option int32 -&gt; Raw_level.t -&gt; level.
  
  Parameter diff : level -&gt; level -&gt; int32.
  
  Parameter current : context -&gt; level.
  
  Parameter last_level_in_cycle : context -&gt; Cycle.t -&gt; level.
  
  Parameter levels_in_cycle : context -&gt; Cycle.t -&gt; list level.
  
  Parameter levels_in_current_cycle :
    context -&gt; option int32 -&gt; unit -&gt; list level.
  
  Parameter last_allowed_fork_level : context -&gt; Raw_level.t.
End Level.

Module Fitness.
  Definition fitness := t.
  
  Parameter increase : option Z -&gt; context -&gt; context.
  
  Parameter current : context -&gt; int64.
  
  Parameter to_int64 : fitness -&gt; Error_monad.tzresult int64.
End Fitness.

Module Nonce.
  Parameter t : Set.
  
  Definition nonce := t.
  
  Parameter encoding : Data_encoding.t nonce.
  
  Module unrevealed.
    Record record := {
      nonce_hash : Nonce_hash.t;
      delegate : public_key_hash;
      rewards : Tez.t;
      fees : Tez.t }.
  End unrevealed.
  Definition unrevealed := unrevealed.record.
  
  Parameter record_hash :
    context -&gt; unrevealed -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter reveal :
    context -&gt; Level.t -&gt; nonce -&gt; Lwt.t (Error_monad.tzresult context).
  
  Inductive status : Set :=
  | Unrevealed : unrevealed -&gt; status
  | Revealed : nonce -&gt; status.
  
  Parameter get : context -&gt; Level.t -&gt; Lwt.t (Error_monad.tzresult status).
  
  Parameter of_bytes : MBytes.t -&gt; Error_monad.tzresult nonce.
  
  Parameter __hash_value : nonce -&gt; Nonce_hash.t.
  
  Parameter check_hash : nonce -&gt; Nonce_hash.t -&gt; bool.
End Nonce.

Module Seed.
  Parameter seed : Set.
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  Parameter for_cycle : context -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult seed).
  
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt;
    Lwt.t (Error_monad.tzresult (context * list Nonce.unrevealed)).
  
  Parameter seed_encoding : Data_encoding.t seed.
End Seed.

Module Big_map.
  Definition id := Z.t.
  
  Parameter fresh : context -&gt; Lwt.t (Error_monad.tzresult (context * id)).
  
  Parameter fresh_temporary : context -&gt; context * id.
  
  Parameter mem :
    context -&gt; id -&gt; Script_expr_hash.t -&gt;
    Lwt.t (Error_monad.tzresult (context * bool)).
  
  Parameter get_opt :
    context -&gt; id -&gt; Script_expr_hash.t -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter rpc_arg : RPC_arg.t id.
  
  Parameter cleanup_temporary : context -&gt; Lwt.t context.
  
  Parameter __exists :
    context -&gt; id -&gt;
    Lwt.t (Error_monad.tzresult (context * option (Script.expr * Script.expr))).
End Big_map.

Module Contract.
  Parameter Included_BASIC_DATA : {t : _ &amp; BASIC_DATA.signature t}.
  
  Definition t := Included_BASIC_DATA.[BASIC_DATA.t].
  
  Definition op_eq := Included_BASIC_DATA.[BASIC_DATA.op_eq].
  
  Definition op_ltgt := Included_BASIC_DATA.[BASIC_DATA.op_ltgt].
  
  Definition op_lt := Included_BASIC_DATA.[BASIC_DATA.op_lt].
  
  Definition op_lteq := Included_BASIC_DATA.[BASIC_DATA.op_lteq].
  
  Definition op_gteq := Included_BASIC_DATA.[BASIC_DATA.op_gteq].
  
  Definition op_gt := Included_BASIC_DATA.[BASIC_DATA.op_gt].
  
  Definition compare := Included_BASIC_DATA.[BASIC_DATA.compare].
  
  Definition equal := Included_BASIC_DATA.[BASIC_DATA.equal].
  
  Definition max := Included_BASIC_DATA.[BASIC_DATA.max].
  
  Definition min := Included_BASIC_DATA.[BASIC_DATA.min].
  
  Definition encoding := Included_BASIC_DATA.[BASIC_DATA.encoding].
  
  Definition pp := Included_BASIC_DATA.[BASIC_DATA.pp].
  
  Definition contract := t.
  
  Parameter rpc_arg : RPC_arg.arg contract.
  
  Parameter to_b58check : contract -&gt; string.
  
  Parameter of_b58check : string -&gt; Error_monad.tzresult contract.
  
  Parameter implicit_contract : public_key_hash -&gt; contract.
  
  Parameter is_implicit : contract -&gt; option public_key_hash.
  
  Parameter __exists : context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_exist :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult unit).
  
  Parameter allocated :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_be_allocated :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult unit).
  
  Parameter __list_value : context -&gt; Lwt.t (list contract).
  
  Parameter get_manager_key :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter is_manager_key_revealed :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter reveal_manager_key :
    context -&gt; public_key_hash -&gt; public_key -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_script_code :
    context -&gt; contract -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.lazy_expr)).
  
  Parameter get_script :
    context -&gt; contract -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.t)).
  
  Parameter get_storage :
    context -&gt; contract -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter get_counter :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter get_balance :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter init_origination_nonce :
    context -&gt; Operation_hash.[S.HASH.t] -&gt; context.
  
  Parameter unset_origination_nonce : context -&gt; context.
  
  Parameter fresh_contract_from_current_nonce :
    context -&gt; Lwt.t (Error_monad.tzresult (context * t)).
  
  Parameter originated_from_current_nonce :
    context -&gt; context -&gt; Lwt.t (Error_monad.tzresult (list contract)).
  
  Module big_map_diff_item.
    Module Update.
      Record record {big_map diff_key diff_key_hash diff_value : Set} := {
        big_map : big_map;
        diff_key : diff_key;
        diff_key_hash : diff_key_hash;
        diff_value : diff_value }.
      Arguments record : clear implicits.
    End Update.
    Definition Update := Update.record.
    
    Module Alloc.
      Record record {big_map key_type value_type : Set} := {
        big_map : big_map;
        key_type : key_type;
        value_type : value_type }.
      Arguments record : clear implicits.
    End Alloc.
    Definition Alloc := Alloc.record.
  End big_map_diff_item.
  
  Inductive big_map_diff_item : Set :=
  | Update :
    big_map_diff_item.Update Big_map.id Script.expr Script_expr_hash.t
      (option Script.expr) -&gt; big_map_diff_item
  | Clear : Big_map.id -&gt; big_map_diff_item
  | Copy : Big_map.id -&gt; Big_map.id -&gt; big_map_diff_item
  | Alloc :
    big_map_diff_item.Alloc Big_map.id Script.expr Script.expr -&gt;
    big_map_diff_item.
  
  Definition big_map_diff := list big_map_diff_item.
  
  Parameter big_map_diff_encoding : Data_encoding.t big_map_diff.
  
  Parameter originate :
    context -&gt; contract -&gt; Tez.t -&gt; Script.t * option big_map_diff -&gt;
    option public_key_hash -&gt; Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  Parameter spend :
    context -&gt; contract -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter credit :
    context -&gt; contract -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter update_script_storage :
    context -&gt; contract -&gt; Script.expr -&gt; option big_map_diff -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter used_storage_space :
    context -&gt; t -&gt; Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter increment_counter :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter check_counter_increment :
    context -&gt; public_key_hash -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult unit).
  
  Parameter origination_nonce : Set.
  
  Parameter initial_origination_nonce :
    Operation_hash.[S.HASH.t] -&gt; origination_nonce.
  
  Parameter originated_contract : origination_nonce -&gt; contract.
End Contract.

Module Delegate.
  Inductive balance : Set :=
  | Contract : Contract.t -&gt; balance
  | Rewards :
    Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle.t -&gt; balance
  | Fees :
    Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle.t -&gt; balance
  | Deposits :
    Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle.t -&gt; balance.
  
  Inductive balance_update : Set :=
  | Debited : Tez.t -&gt; balance_update
  | Credited : Tez.t -&gt; balance_update.
  
  Definition balance_updates := list (balance * balance_update).
  
  Parameter balance_updates_encoding : Data_encoding.t balance_updates.
  
  Parameter cleanup_balance_updates : balance_updates -&gt; balance_updates.
  
  Parameter get :
    context -&gt; Contract.t -&gt;
    Lwt.t (Error_monad.tzresult (option public_key_hash)).
  
  Parameter set :
    context -&gt; Contract.t -&gt; option public_key_hash -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter fold : forall {a : Set},
    context -&gt; a -&gt; (public_key_hash -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter __list_value : context -&gt; Lwt.t (list public_key_hash).
  
  Parameter freeze_deposit :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_rewards :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_fees :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt; list Nonce.unrevealed -&gt;
    Lwt.t
      (Error_monad.tzresult
        (context * balance_updates *
          list Signature.Public_key_hash.[S.SPublic_key_hash.t])).
  
  Module frozen_balance.
    Record record := {
      deposit : Tez.t;
      fees : Tez.t;
      rewards : Tez.t }.
  End frozen_balance.
  Definition frozen_balance := frozen_balance.record.
  
  Parameter punish :
    context -&gt; public_key_hash -&gt; Cycle.t -&gt;
    Lwt.t (Error_monad.tzresult (context * frozen_balance)).
  
  Parameter full_balance :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter has_frozen_balance :
    context -&gt; public_key_hash -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter frozen_balance :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter frozen_balance_encoding : Data_encoding.t frozen_balance.
  
  Parameter frozen_balance_by_cycle_encoding :
    Data_encoding.t (Cycle.Map.[S.MAP.t] frozen_balance).
  
  Parameter frozen_balance_by_cycle :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Cycle.Map.[S.MAP.t] frozen_balance).
  
  Parameter staking_balance :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter delegated_contracts :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (list Contract_repr.t).
  
  Parameter delegated_balance :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter deactivated :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult bool).
  
  Parameter grace_period :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult Cycle.t).
End Delegate.

Module Vote.
  Definition proposal := Protocol_hash.[S.HASH.t].
  
  Parameter record_proposal :
    context -&gt; Protocol_hash.[S.HASH.t] -&gt; public_key_hash -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_proposals :
    context -&gt;
    Lwt.t
      (Error_monad.tzresult (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.t) int32)).
  
  Parameter clear_proposals : context -&gt; Lwt.t context.
  
  Parameter recorded_proposal_count_for_delegate :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult Z).
  
  Parameter listings_encoding :
    Data_encoding.t
      (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * int32)).
  
  Parameter freeze_listings : context -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_listings : context -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter listing_size : context -&gt; Lwt.t (Error_monad.tzresult int32).
  
  Parameter in_listings : context -&gt; public_key_hash -&gt; Lwt.t bool.
  
  Parameter get_listings : context -&gt; Lwt.t (list (public_key_hash * int32)).
  
  Inductive ballot : Set :=
  | Yay : ballot
  | Nay : ballot
  | Pass : ballot.
  
  Parameter ballot_encoding : Data_encoding.t ballot.
  
  Module ballots.
    Record record := {
      yay : int32;
      nay : int32;
      pass : int32 }.
  End ballots.
  Definition ballots := ballots.record.
  
  Parameter ballots_encoding : Data_encoding.t ballots.
  
  Parameter has_recorded_ballot : context -&gt; public_key_hash -&gt; Lwt.t bool.
  
  Parameter record_ballot :
    context -&gt; public_key_hash -&gt; ballot -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter get_ballots : context -&gt; Lwt.t (Error_monad.tzresult ballots).
  
  Parameter get_ballot_list :
    context -&gt;
    Lwt.t (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * ballot)).
  
  Parameter clear_ballots : context -&gt; Lwt.t context.
  
  Parameter get_current_period_kind :
    context -&gt; Lwt.t (Error_monad.tzresult Voting_period.kind).
  
  Parameter set_current_period_kind :
    context -&gt; Voting_period.kind -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_quorum : context -&gt; Lwt.t (Error_monad.tzresult int32).
  
  Parameter get_participation_ema :
    context -&gt; Lwt.t (Error_monad.tzresult int32).
  
  Parameter set_participation_ema :
    context -&gt; int32 -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_proposal :
    context -&gt; Lwt.t (Error_monad.tzresult proposal).
  
  Parameter init_current_proposal :
    context -&gt; proposal -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_current_proposal :
    context -&gt; Lwt.t (Error_monad.tzresult context).
End Vote.

Module Block_header.
  Reserved Notation &quot;'t&quot;.
  Reserved Notation &quot;'protocol_data&quot;.
  Reserved Notation &quot;'contents&quot;.
  
  Module contents.
    Record record {priority seed_nonce_hash proof_of_work_nonce : Set} := {
      priority : priority;
      seed_nonce_hash : seed_nonce_hash;
      proof_of_work_nonce : proof_of_work_nonce }.
    Arguments record : clear implicits.
  End contents.
  Definition contents_skeleton := contents.record.
  
  Module protocol_data.
    Record record {contents signature : Set} := {
      contents : contents;
      signature : signature }.
    Arguments record : clear implicits.
  End protocol_data.
  Definition protocol_data_skeleton := protocol_data.record.
  
  Module t.
    Record record {shell protocol_data : Set} := {
      shell : shell;
      protocol_data : protocol_data }.
    Arguments record : clear implicits.
  End t.
  Definition t_skeleton := t.record.
  
  
  
  where &quot;'t&quot; := (t_skeleton Block_header.shell_header 'protocol_data)
  and &quot;'protocol_data&quot; := (protocol_data_skeleton 'contents Signature.t)
  and &quot;'contents&quot; := (contents_skeleton Z (option Nonce_hash.t) MBytes.t).
  
  Definition t := 't.
  Definition protocol_data := 'protocol_data.
  Definition contents := 'contents.
  
  Definition block_header := t.
  
  Definition raw := Block_header.t.
  
  Definition shell_header := Block_header.shell_header.
  
  Parameter raw : block_header -&gt; raw.
  
  Parameter __hash_value : block_header -&gt; Block_hash.[S.HASH.t].
  
  Parameter hash_raw : raw -&gt; Block_hash.[S.HASH.t].
  
  Parameter encoding : Data_encoding.encoding block_header.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_encoding : Data_encoding.t contents.
  
  Parameter unsigned_encoding : Data_encoding.t (shell_header * contents).
  
  Parameter protocol_data_encoding : Data_encoding.encoding protocol_data.
  
  Parameter shell_header_encoding : Data_encoding.encoding shell_header.
  
  Parameter max_header_length : Z.
End Block_header.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Reserved Notation &quot;'manager&quot;.
  
  Inductive manager_gadt : Set :=
  | Reveal_manager_kind : manager_gadt
  | Transaction_manager_kind : manager_gadt
  | Origination_manager_kind : manager_gadt
  | Delegation_manager_kind : manager_gadt
  
  where &quot;'manager&quot; := (fun (a : Set) =&gt; manager_gadt).
  
  Definition manager := 'manager.
End Kind.

Module contents.
  Module Endorsement.
    Record record {level : Set} := {
      level : level }.
    Arguments record : clear implicits.
  End Endorsement.
  Definition Endorsement := Endorsement.record.
  
  Module Seed_nonce_revelation.
    Record record {level nonce : Set} := {
      level : level;
      nonce : nonce }.
    Arguments record : clear implicits.
  End Seed_nonce_revelation.
  Definition Seed_nonce_revelation := Seed_nonce_revelation.record.
  
  Module Double_endorsement_evidence.
    Record record {op1 op2 : Set} := {
      op1 : op1;
      op2 : op2 }.
    Arguments record : clear implicits.
  End Double_endorsement_evidence.
  Definition Double_endorsement_evidence := Double_endorsement_evidence.record.
  
  Module Double_baking_evidence.
    Record record {bh1 bh2 : Set} := {
      bh1 : bh1;
      bh2 : bh2 }.
    Arguments record : clear implicits.
  End Double_baking_evidence.
  Definition Double_baking_evidence := Double_baking_evidence.record.
  
  Module Activate_account.
    Record record {id activation_code : Set} := {
      id : id;
      activation_code : activation_code }.
    Arguments record : clear implicits.
  End Activate_account.
  Definition Activate_account := Activate_account.record.
  
  Module Proposals.
    Record record {source period proposals : Set} := {
      source : source;
      period : period;
      proposals : proposals }.
    Arguments record : clear implicits.
  End Proposals.
  Definition Proposals := Proposals.record.
  
  Module Ballot.
    Record record {source period proposal ballot : Set} := {
      source : source;
      period : period;
      proposal : proposal;
      ballot : ballot }.
    Arguments record : clear implicits.
  End Ballot.
  Definition Ballot := Ballot.record.
  
  Module Manager_operation.
    Record record {source fee counter operation gas_limit storage_limit : Set} := {
      source : source;
      fee : fee;
      counter : counter;
      operation : operation;
      gas_limit : gas_limit;
      storage_limit : storage_limit }.
    Arguments record : clear implicits.
  End Manager_operation.
  Definition Manager_operation := Manager_operation.record.
End contents.

Module manager_operation.
  Module Transaction.
    Record record {amount parameters entrypoint destination : Set} := {
      amount : amount;
      parameters : parameters;
      entrypoint : entrypoint;
      destination : destination }.
    Arguments record : clear implicits.
  End Transaction.
  Definition Transaction := Transaction.record.
  
  Module Origination.
    Record record {delegate script credit preorigination : Set} := {
      delegate : delegate;
      script : script;
      credit : credit;
      preorigination : preorigination }.
    Arguments record : clear implicits.
  End Origination.
  Definition Origination := Origination.record.
End manager_operation.

Reserved Notation &quot;'operation&quot;.
Reserved Notation &quot;'protocol_data&quot;.
Reserved Notation &quot;'contents_list&quot;.
Reserved Notation &quot;'contents&quot;.
Reserved Notation &quot;'manager_operation&quot;.
Reserved Notation &quot;'counter&quot;.

Module protocol_data.
  Record record {contents signature : Set} := {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Module operation.
  Record record {shell protocol_data : Set} := {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
End operation.
Definition operation_skeleton := operation.record.

Inductive contents_list_gadt : Set :=
| Single : forall {kind : Set}, 'contents kind -&gt; contents_list_gadt
| Cons : forall {kind : Set},
  'contents (Kind.manager kind) -&gt; contents_list_gadt -&gt; contents_list_gadt

with contents_gadt : Set :=
| Endorsement : contents.Endorsement Raw_level.t -&gt; contents_gadt
| Seed_nonce_revelation :
  contents.Seed_nonce_revelation Raw_level.t Nonce.t -&gt; contents_gadt
| Double_endorsement_evidence :
  contents.Double_endorsement_evidence ('operation Kind.endorsement)
    ('operation Kind.endorsement) -&gt; contents_gadt
| Double_baking_evidence :
  contents.Double_baking_evidence Block_header.t Block_header.t -&gt; contents_gadt
| Activate_account :
  contents.Activate_account
    Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code -&gt; contents_gadt
| Proposals :
  contents.Proposals Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Voting_period.t (list Protocol_hash.[S.HASH.t]) -&gt; contents_gadt
| Ballot :
  contents.Ballot Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Voting_period.t Protocol_hash.[S.HASH.t] Vote.ballot -&gt; contents_gadt
| Manager_operation : forall {kind : Set},
  contents.Manager_operation Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Tez.tez 'counter ('manager_operation kind) Z.t Z.t -&gt; contents_gadt

with manager_operation_gadt : Set :=
| Reveal : Signature.Public_key.[S.SPublic_key.t] -&gt; manager_operation_gadt
| Transaction :
  manager_operation.Transaction Tez.tez Script.lazy_expr string
    Contract.contract -&gt; manager_operation_gadt
| Origination :
  manager_operation.Origination
    (option Signature.Public_key_hash.[S.SPublic_key_hash.t]) Script.t Tez.tez
    (option Contract.t) -&gt; manager_operation_gadt
| Delegation :
  option Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  manager_operation_gadt

where &quot;'operation&quot; := (fun (kind : Set) =&gt;
  operation_skeleton Operation.shell_header ('protocol_data kind))
and &quot;'protocol_data&quot; := (fun (kind : Set) =&gt;
  protocol_data_skeleton ('contents_list kind) (option Signature.t))
and &quot;'contents_list&quot; := (fun (_ : Set) =&gt; contents_list_gadt)
and &quot;'contents&quot; := (fun (_ : Set) =&gt; contents_gadt)
and &quot;'manager_operation&quot; := (fun (_ : Set) =&gt; manager_operation_gadt)
and &quot;'counter&quot; := (Z.t).

Definition operation := 'operation.
Definition protocol_data := 'protocol_data.
Definition contents_list := 'contents_list.
Definition contents := 'contents.
Definition manager_operation := 'manager_operation.
Definition counter := 'counter.

Module internal_operation.
  Record record {kind : Set} := {
    source : Contract.contract;
    operation : manager_operation kind;
    nonce : Z }.
  Arguments record : clear implicits.
End internal_operation.
Definition internal_operation := internal_operation.record.

Reserved Notation &quot;'packed_manager_operation&quot;.

Inductive packed_manager_operation_gadt : Set :=
| Manager : forall {kind : Set},
  manager_operation kind -&gt; packed_manager_operation_gadt

where &quot;'packed_manager_operation&quot; := (packed_manager_operation_gadt).

Definition packed_manager_operation := 'packed_manager_operation.

Reserved Notation &quot;'packed_contents&quot;.

Inductive packed_contents_gadt : Set :=
| Contents : forall {kind : Set}, contents kind -&gt; packed_contents_gadt

where &quot;'packed_contents&quot; := (packed_contents_gadt).

Definition packed_contents := 'packed_contents.

Reserved Notation &quot;'packed_contents_list&quot;.

Inductive packed_contents_list_gadt : Set :=
| Contents_list : forall {kind : Set},
  contents_list kind -&gt; packed_contents_list_gadt

where &quot;'packed_contents_list&quot; := (packed_contents_list_gadt).

Definition packed_contents_list := 'packed_contents_list.

Reserved Notation &quot;'packed_protocol_data&quot;.

Inductive packed_protocol_data_gadt : Set :=
| Operation_data : forall {kind : Set},
  protocol_data kind -&gt; packed_protocol_data_gadt

where &quot;'packed_protocol_data&quot; := (packed_protocol_data_gadt).

Definition packed_protocol_data := 'packed_protocol_data.

Module packed_operation.
  Record record := {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
End packed_operation.
Definition packed_operation := packed_operation.record.

Reserved Notation &quot;'packed_internal_operation&quot;.

Inductive packed_internal_operation_gadt : Set :=
| Internal_operation : forall {kind : Set},
  internal_operation kind -&gt; packed_internal_operation_gadt

where &quot;'packed_internal_operation&quot; := (packed_internal_operation_gadt).

Definition packed_internal_operation := 'packed_internal_operation.

Parameter manager_kind : forall {kind : Set},
  manager_operation kind -&gt; Kind.manager kind.

Module Fees.
  Parameter origination_burn :
    context -&gt; Lwt.t (Error_monad.tzresult (context * Tez.t)).
  
  Parameter record_paid_storage_space :
    context -&gt; Contract.t -&gt;
    Lwt.t (Error_monad.tzresult (context * Z.t * Z.t * Tez.t)).
  
  Parameter start_counting_storage_fees : context -&gt; context.
  
  Parameter burn_storage_fees :
    context -&gt; Z.t -&gt; Contract.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  Parameter check_storage_limit : context -&gt; Z.t -&gt; Error_monad.tzresult unit.
End Fees.

Module Operation.
  Definition contents (kind : Set) := contents kind.
  
  Definition packed_contents := packed_contents.
  
  Parameter contents_encoding : Data_encoding.t packed_contents.
  
  Definition protocol_data (kind : Set) := protocol_data kind.
  
  Definition packed_protocol_data := packed_protocol_data.
  
  Parameter protocol_data_encoding : Data_encoding.t packed_protocol_data.
  
  Parameter unsigned_encoding :
    Data_encoding.t (Operation.shell_header * packed_contents_list).
  
  Module raw.
    Record record := {
      shell : Operation.shell_header;
      proto : MBytes.t }.
  End raw.
  Definition raw := raw.record.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_list_encoding : Data_encoding.t packed_contents_list.
  
  Module t.
    Record record {kind : Set} := {
      shell : Operation.shell_header;
      protocol_data : protocol_data kind }.
    Arguments record : clear implicits.
  End t.
  Definition t := t.record.
  
  Definition packed := packed_operation.
  
  Parameter encoding : Data_encoding.t packed.
  
  Parameter raw : forall {A : Set}, operation A -&gt; raw.
  
  Parameter __hash_value : forall {A : Set},
    operation A -&gt; Operation_hash.[S.HASH.t].
  
  Parameter hash_raw : raw -&gt; Operation_hash.[S.HASH.t].
  
  Parameter hash_packed : packed_operation -&gt; Operation_hash.[S.HASH.t].
  
  Parameter acceptable_passes : packed_operation -&gt; list Z.
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
  
  Parameter check_signature : forall {A : Set},
    public_key -&gt; Chain_id.[S.HASH.t] -&gt; operation A -&gt;
    Lwt.t (Error_monad.tzresult unit).
  
  Parameter check_signature_sync : forall {A : Set},
    public_key -&gt; Chain_id.[S.HASH.t] -&gt; operation A -&gt;
    Error_monad.tzresult unit.
  
  Parameter internal_operation_encoding :
    Data_encoding.t packed_internal_operation.
  
  Parameter pack : forall {kind : Set}, operation kind -&gt; packed_operation.
  
  Reserved Notation &quot;'eq&quot;.
  
  Inductive eq_gadt : Set :=
  | Eq : eq_gadt
  
  where &quot;'eq&quot; := (fun (a b : Set) =&gt; eq_gadt).
  
  Definition eq := 'eq.
  
  Parameter equal : forall {a b : Set},
    operation a -&gt; operation b -&gt; option (eq a b).
  
  Module Encoding.
    Module case.
      Module Case.
        Record record {tag name encoding select proj inj : Set} := {
          tag : tag;
          name : name;
          encoding : encoding;
          select : select;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
      End Case.
      Definition Case := Case.record.
    End case.
    
    Reserved Notation &quot;'case&quot;.
    
    Inductive case_gadt : Set :=
    | Case : forall {a b : Set},
      case.Case Z string (Data_encoding.t a)
        (packed_contents -&gt; option (contents b)) (contents b -&gt; a)
        (a -&gt; contents b) -&gt; case_gadt
    
    where &quot;'case&quot; := (fun (b : Set) =&gt; case_gadt).
    
    Definition case := 'case.
    
    Parameter endorsement_case : case Kind.endorsement.
    
    Parameter seed_nonce_revelation_case : case Kind.seed_nonce_revelation.
    
    Parameter double_endorsement_evidence_case :
      case Kind.double_endorsement_evidence.
    
    Parameter double_baking_evidence_case : case Kind.double_baking_evidence.
    
    Parameter activate_account_case : case Kind.activate_account.
    
    Parameter proposals_case : case Kind.proposals.
    
    Parameter ballot_case : case Kind.ballot.
    
    Parameter reveal_case : case (Kind.manager Kind.reveal).
    
    Parameter transaction_case : case (Kind.manager Kind.transaction).
    
    Parameter origination_case : case (Kind.manager Kind.origination).
    
    Parameter delegation_case : case (Kind.manager Kind.delegation).
    
    Module Manager_operations.
      Module case.
        Module MCase.
          Record record {tag name encoding select proj inj : Set} := {
            tag : tag;
            name : name;
            encoding : encoding;
            select : select;
            proj : proj;
            inj : inj }.
          Arguments record : clear implicits.
        End MCase.
        Definition MCase := MCase.record.
      End case.
      
      Reserved Notation &quot;'case&quot;.
      
      Inductive case_gadt : Set :=
      | MCase : forall {a kind : Set},
        case.MCase Z string (Data_encoding.t a)
          (packed_manager_operation -&gt; option (manager_operation kind))
          (manager_operation kind -&gt; a) (a -&gt; manager_operation kind) -&gt;
        case_gadt
      
      where &quot;'case&quot; := (fun (b : Set) =&gt; case_gadt).
      
      Definition case := 'case.
      
      Parameter reveal_case : case Kind.reveal.
      
      Parameter transaction_case : case Kind.transaction.
      
      Parameter origination_case : case Kind.origination.
      
      Parameter delegation_case : case Kind.delegation.
    End Manager_operations.
  End Encoding.
  
  Parameter of_list : list packed_contents -&gt; packed_contents_list.
  
  Parameter to_list : packed_contents_list -&gt; list packed_contents.
End Operation.

Module Roll.
  Definition t := int32.
  
  Definition roll := t.
  
  Parameter encoding : Data_encoding.t roll.
  
  Parameter snapshot_rolls : context -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter baking_rights_owner :
    context -&gt; Level.t -&gt; Z -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter endorsement_rights_owner :
    context -&gt; Level.t -&gt; Z -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter delegate_pubkey :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter get_rolls :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult (list roll)).
  
  Parameter get_change :
    context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult Tez.t).
End Roll.

Module Commitment.
  Module t.
    Record record := {
      blinded_public_key_hash : Blinded_public_key_hash.t;
      amount : Tez.tez }.
  End t.
  Definition t := t.record.
  
  Parameter get_opt :
    context -&gt; Blinded_public_key_hash.t -&gt;
    Lwt.t (Error_monad.tzresult (option Tez.t)).
  
  Parameter delete :
    context -&gt; Blinded_public_key_hash.t -&gt; Lwt.t (Error_monad.tzresult context).
End Commitment.

Module Bootstrap.
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult context).
End Bootstrap.

Module Global.
  Parameter get_block_priority : context -&gt; Lwt.t (Error_monad.tzresult Z).
  
  Parameter set_block_priority :
    context -&gt; Z -&gt; Lwt.t (Error_monad.tzresult context).
End Global.

Parameter prepare_first_block :
  Context.t -&gt;
  (context -&gt; Script.t -&gt;
  Lwt.t
    (Error_monad.tzresult ((Script.t * option Contract.big_map_diff) * context)))
  -&gt; Int32.t -&gt; Time.t -&gt; Fitness.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter prepare :
  Context.t -&gt; Int32.t -&gt; Time.t -&gt; Time.t -&gt; Fitness.t -&gt;
  Lwt.t (Error_monad.tzresult context).

Parameter finalize : option string -&gt; context -&gt; Updater.validation_result.

Parameter activate : context -&gt; Protocol_hash.[S.HASH.t] -&gt; Lwt.t context.

Parameter fork_test_chain :
  context -&gt; Protocol_hash.[S.HASH.t] -&gt; Time.t -&gt; Lwt.t context.

Parameter record_endorsement :
  context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; context.

Parameter allowed_endorsements :
  context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    (Signature.Public_key.[S.SPublic_key.t] * list Z * bool).

Parameter init_endorsements :
  context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    (Signature.Public_key.[S.SPublic_key.t] * list Z * bool) -&gt; context.

Parameter included_endorsements : context -&gt; Z.

Parameter reset_internal_nonce : context -&gt; context.

Parameter fresh_internal_nonce : context -&gt; Error_monad.tzresult (context * Z).

Parameter record_internal_nonce : context -&gt; Z -&gt; context.

Parameter internal_nonce_already_recorded : context -&gt; Z -&gt; bool.

Parameter add_fees : context -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_rewards :
  context -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_deposit :
  context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Tez.t -&gt;
  Lwt.t (Error_monad.tzresult context).

Parameter get_fees : context -&gt; Tez.t.

Parameter get_rewards : context -&gt; Tez.t.

Parameter get_deposits :
  context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t) Tez.t.

Parameter description : Storage_description.t context.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="alpha_services.ml">
  <div class="col-md-6">
    <a href="#alpha_services.ml"><code>alpha_services.ml</code></a>&nbsp;<span class="label label-danger">34 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

let custom_root = RPC_path.open_root

module Seed = struct
  module S = struct
    open Data_encoding

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">seed</abbr> =
      RPC_service.post_service
        ~description:&quot;Seed of the cycle to which the block belongs.&quot;
        ~query:RPC_query.empty
        ~input:empty
        ~output:Seed.seed_encoding
        RPC_path.(custom_root / &quot;context&quot; / &quot;seed&quot;)
  end

  <abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
    let open Services_registration in
    register0 S.seed (fun ctxt () () -&gt;
        let l = Level.current ctxt in
        Seed.for_cycle ctxt l.cycle)</abbr>

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">get</abbr> ctxt block = RPC_context.make_call0 S.seed ctxt block () ()
end

module Nonce = struct
  type info = Revealed of Nonce.t | Missing of Nonce_hash.t | Forgotten

  let info_encoding =
    let open Data_encoding in
    union
      [ case
          (Tag 0)
          ~title:&quot;Revealed&quot;
          (obj1 (req &quot;nonce&quot; Nonce.encoding))
          (function Revealed nonce -&gt; Some nonce | _ -&gt; None)
          (fun nonce -&gt; Revealed nonce);
        case
          (Tag 1)
          ~title:&quot;Missing&quot;
          (obj1 (req &quot;hash&quot; Nonce_hash.encoding))
          (function Missing nonce -&gt; Some nonce | _ -&gt; None)
          (fun nonce -&gt; Missing nonce);
        case
          (Tag 2)
          ~title:&quot;Forgotten&quot;
          empty
          (function Forgotten -&gt; Some () | _ -&gt; None)
          (fun () -&gt; Forgotten) ]

  module S = struct
    let <abbr class="mark-error" title="Polymorphic variant types are not handled">get</abbr> =
      RPC_service.get_service
        ~description:&quot;Info about the nonce of a previous block.&quot;
        ~query:RPC_query.empty
        ~output:info_encoding
        RPC_path.(custom_root / &quot;context&quot; / &quot;nonces&quot; /: Raw_level.rpc_arg)
  end

  let register () =
    let open Services_registration in
    register1 S.get (fun ctxt raw_level () () -&gt;
        let level = Level.from_raw ctxt raw_level in
        Nonce.get ctxt level
        &gt;&gt;= function
        | Ok (Revealed nonce) -&gt;
            return (Revealed nonce)
        | Ok (Unrevealed {nonce_hash; _}) -&gt;
            return (Missing nonce_hash)
        | Error _ -&gt;
            return Forgotten)

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">get</abbr> ctxt block level =
    RPC_context.make_call1 S.get ctxt block level () ()
end

module Contract = Contract_services
module Constants = Constants_services
module Delegate = Delegate_services
module Helpers = Helpers_services
module Forge = Helpers_services.Forge
module Parse = Helpers_services.Parse
module Voting = Voting_services

let register () =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Contract.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Constants.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Delegate.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Helpers.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Nonce.register () ;
  Voting.register ()</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_services.ml"><code>Alpha_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Nonce_hash.
Require Tezos.Services_registration.

Import Alpha_context.

Definition custom_root {A : Set} : RPC_path.context A := RPC_path.open_root.

Module Seed.
  Module S.
    Import Data_encoding.
    
    Definition seed
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit unit Alpha_context.Seed.seed :=
      RPC_service.post_service
        (Some &quot;Seed of the cycle to which the block belongs.&quot; % string)
        RPC_query.empty Data_encoding.empty Alpha_context.Seed.seed_encoding
        (RPC_path.op_div (RPC_path.op_div custom_root &quot;context&quot; % string)
          &quot;seed&quot; % string).
  End S.
  
  (* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
  (* top_level_evaluation *)
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    : Lwt.t (Error_monad.shell_tzresult Alpha_context.Seed.seed) :=
    RPC_context.make_call0 S.seed ctxt block tt tt.
End Seed.

Module Nonce.
  Inductive info : Set :=
  | Revealed : Alpha_context.Nonce.t -&gt; info
  | Missing : Nonce_hash.t -&gt; info
  | Forgotten : info.
  
  Definition info_encoding : Data_encoding.encoding info :=
    Data_encoding.union None
      (cons
        (Data_encoding.__case_value &quot;Revealed&quot; % string None
          (Data_encoding.Tag 0)
          (Data_encoding.obj1
            (Data_encoding.req None None &quot;nonce&quot; % string
              Alpha_context.Nonce.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Revealed nonce =&gt; Some nonce
            | _ =&gt; None
            end) (fun nonce =&gt; Revealed nonce))
        (cons
          (Data_encoding.__case_value &quot;Missing&quot; % string None
            (Data_encoding.Tag 1)
            (Data_encoding.obj1
              (Data_encoding.req None None &quot;hash&quot; % string Nonce_hash.encoding))
            (fun function_parameter =&gt;
              match function_parameter with
              | Missing nonce =&gt; Some nonce
              | _ =&gt; None
              end) (fun nonce =&gt; Missing nonce))
          (cons
            (Data_encoding.__case_value &quot;Forgotten&quot; % string None
              (Data_encoding.Tag 2) Data_encoding.empty
              (fun function_parameter =&gt;
                match function_parameter with
                | Forgotten =&gt; Some tt
                | _ =&gt; None
                end)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Forgotten)) []))).
  
  Module S.
    Definition get
      : RPC_service.service (* `GET *) unit Updater.rpc_context
        (Updater.rpc_context * Alpha_context.Raw_level.raw_level) unit unit info :=
      RPC_service.get_service
        (Some &quot;Info about the nonce of a previous block.&quot; % string)
        RPC_query.empty info_encoding
        (RPC_path.op_divcolon
          (RPC_path.op_div (RPC_path.op_div custom_root &quot;context&quot; % string)
            &quot;nonces&quot; % string) Alpha_context.Raw_level.rpc_arg).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    Services_registration.register1 S.get
      (fun ctxt =&gt;
        fun raw_level =&gt;
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            fun function_parameter =&gt;
              let 'tt := function_parameter in
              let level := Alpha_context.Level.from_raw ctxt None raw_level in
              Error_monad.op_gtgteq (Alpha_context.Nonce.get ctxt level)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | Pervasives.Ok (Alpha_context.Nonce.Revealed nonce) =&gt;
                    Error_monad.__return (Revealed nonce)
                  |
                    Pervasives.Ok
                      (Alpha_context.Nonce.Unrevealed {|
                        Alpha_context.Nonce.unrevealed.nonce_hash := nonce_hash
                          |}) =&gt; Error_monad.__return (Missing nonce_hash)
                  | Pervasives.Error _ =&gt; Error_monad.__return Forgotten
                  end)).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (level : Alpha_context.Raw_level.raw_level)
    : Lwt.t (Error_monad.shell_tzresult info) :=
    RPC_context.make_call1 S.get ctxt block level tt tt.
End Nonce.

Module Contract := Contract_services.

Module Constants := Constants_services.

Module Delegate := Delegate_services.

Module Helpers := Helpers_services.

Module Forge := Helpers_services.Forge.

Module Parse := Helpers_services.Parse.

Module Voting := Voting_services.

Definition register (function_parameter : unit) : unit :=
  let 'tt := function_parameter in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Voting.register tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="alpha_services.mli">
  <div class="col-md-6">
    <a href="#alpha_services.mli"><code>alpha_services.mli</code></a>&nbsp;<span class="label label-danger">33 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

module Seed : sig
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val get : 'a #RPC_context.simple -&gt; 'a -&gt; Seed.seed shell_tzresult Lwt.t</abbr>
end

module Nonce : sig
  type info = Revealed of Nonce.t | Missing of Nonce_hash.t | Forgotten

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val get :
    'a #RPC_context.simple -&gt; 'a -&gt; Raw_level.t -&gt; info shell_tzresult Lwt.t</abbr>
end

<abbr class="mark-error" title="Aliases in module types are not handled">module Contract = Contract_services</abbr>
<abbr class="mark-error" title="Aliases in module types are not handled">module Constants = Constants_services</abbr>
<abbr class="mark-error" title="Aliases in module types are not handled">module Delegate = Delegate_services</abbr>
<abbr class="mark-error" title="Aliases in module types are not handled">module Helpers = Helpers_services</abbr>
<abbr class="mark-error" title="Aliases in module types are not handled">module Forge = Helpers_services.Forge</abbr>
<abbr class="mark-error" title="Aliases in module types are not handled">module Parse = Helpers_services.Parse</abbr>
<abbr class="mark-error" title="Aliases in module types are not handled">module Voting = Voting_services</abbr>

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_services.mli"><code>Alpha_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Nonce_hash.

Module Seed.
  Parameter get : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Seed.seed).
End Seed.

Module Nonce.
  Inductive info : Set :=
  | Revealed : Alpha_context.Nonce.t -&gt; info
  | Missing : Nonce_hash.t -&gt; info
  | Forgotten : info.
  
  Parameter get : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Raw_level.t -&gt; Lwt.t (Error_monad.shell_tzresult info).
End Nonce.

Parameter Contract : alias.

Parameter Constants : alias.

Parameter Delegate : alias.

Parameter Helpers : alias.

Parameter Forge : alias.

Parameter Parse : alias.

Parameter Voting : alias.

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="amendment.ml">
  <div class="col-md-6">
    <a href="#amendment.ml"><code>amendment.ml</code></a>&nbsp;<span class="label label-danger">11 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

(** Returns the proposal submitted by the most delegates.
    Returns None in case of a tie, if proposal quorum is below required
    minimum or if there are no proposals. *)
let select_winning_proposal ctxt =
  Vote.get_proposals ctxt
  &gt;&gt;=? fun proposals -&gt;
  let merge proposal vote winners =
    match winners with
    | None -&gt;
        Some ([proposal], vote)
    | Some (winners, winners_vote) as previous -&gt;
        if Compare.Int32.(vote = winners_vote) then
          Some (proposal :: winners, winners_vote)
        else if Compare.Int32.(vote &gt; winners_vote) then Some ([proposal], vote)
        else previous
  in
  match Protocol_hash.Map.fold merge proposals None with
  | Some ([proposal], vote) -&gt;
      Vote.listing_size ctxt
      &gt;&gt;=? fun max_vote -&gt;
      let min_proposal_quorum = Constants.min_proposal_quorum ctxt in
      let min_vote_to_pass =
        Int32.div (Int32.mul min_proposal_quorum max_vote) 100_00l
      in
      if Compare.Int32.(vote &gt;= min_vote_to_pass) then return_some proposal
      else return_none
  | _ -&gt;
      return_none

(* in case of a tie, let's do nothing. *)

(** A proposal is approved if it has supermajority and the participation reaches
    the current quorum.
    Supermajority means the yays are more 8/10 of casted votes.
    The participation is the ratio of all received votes, including passes, with
    respect to the number of possible votes.
    The participation EMA (exponential moving average) uses the last
    participation EMA and the current participation./
    The expected quorum is calculated using the last participation EMA, capped
    by the min/max quorum protocol constants. *)
let check_approval_and_update_participation_ema ctxt =
  Vote.get_ballots ctxt
  &gt;&gt;=? fun ballots -&gt;
  Vote.listing_size ctxt
  &gt;&gt;=? fun maximum_vote -&gt;
  Vote.get_participation_ema ctxt
  &gt;&gt;=? fun participation_ema -&gt;
  Vote.get_current_quorum ctxt
  &gt;&gt;=? fun expected_quorum -&gt;
  (* Note overflows: considering a maximum of 8e8 tokens, with roll size as
     small as 1e3, there is a maximum of 8e5 rolls and thus votes.
     In 'participation' an Int64 is used because in the worst case 'all_votes is
     8e5 and after the multiplication is 8e9, making it potentially overflow a
     signed Int32 which is 2e9. *)
  let casted_votes = Int32.add ballots.yay ballots.nay in
  let all_votes = Int32.add casted_votes ballots.pass in
  let supermajority = Int32.div (Int32.mul 8l casted_votes) 10l in
  let participation =
    (* in centile of percentage *)
    Int64.(
      to_int32 (div (mul (of_int32 all_votes) 100_00L) (of_int32 maximum_vote)))
  in
  let outcome =
    Compare.Int32.(
      participation &gt;= expected_quorum &amp;&amp; ballots.yay &gt;= supermajority)
  in
  let new_participation_ema =
    Int32.(div (add (mul 8l participation_ema) (mul 2l participation)) 10l)
  in
  Vote.set_participation_ema ctxt new_participation_ema
  &gt;&gt;=? fun ctxt -&gt; return (ctxt, outcome)

(** Implements the state machine of the amendment procedure.
    Note that [freeze_listings], that computes the vote weight of each delegate,
    is run at the beginning of each voting period.
*)
let start_new_voting_period ctxt =
  Vote.get_current_period_kind ctxt
  &gt;&gt;=? function
  | Proposal -&gt; (
      select_winning_proposal ctxt
      &gt;&gt;=? fun proposal -&gt;
      Vote.clear_proposals ctxt
      &gt;&gt;= fun ctxt -&gt;
      Vote.clear_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      match proposal with
      | None -&gt;
          Vote.freeze_listings ctxt &gt;&gt;=? fun ctxt -&gt; return ctxt
      | Some proposal -&gt;
          Vote.init_current_proposal ctxt proposal
          &gt;&gt;=? fun ctxt -&gt;
          Vote.freeze_listings ctxt
          &gt;&gt;=? fun ctxt -&gt;
          Vote.set_current_period_kind ctxt Testing_vote
          &gt;&gt;=? fun ctxt -&gt; return ctxt )
  | Testing_vote -&gt;
      check_approval_and_update_participation_ema ctxt
      &gt;&gt;=? fun (ctxt, approved) -&gt;
      Vote.clear_ballots ctxt
      &gt;&gt;= fun ctxt -&gt;
      Vote.clear_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      if approved then
        let expiration =
          (* in two days maximum... *)
          Time.add
            (Timestamp.current ctxt)
            (Constants.test_chain_duration ctxt)
        in
        Vote.get_current_proposal ctxt
        &gt;&gt;=? fun proposal -&gt;
        fork_test_chain ctxt proposal expiration
        &gt;&gt;= fun ctxt -&gt;
        Vote.set_current_period_kind ctxt Testing &gt;&gt;=? fun ctxt -&gt; return ctxt
      else
        Vote.clear_current_proposal ctxt
        &gt;&gt;=? fun ctxt -&gt;
        Vote.freeze_listings ctxt
        &gt;&gt;=? fun ctxt -&gt;
        Vote.set_current_period_kind ctxt Proposal &gt;&gt;=? fun ctxt -&gt; return ctxt
  | Testing -&gt;
      Vote.freeze_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.set_current_period_kind ctxt Promotion_vote
      &gt;&gt;=? fun ctxt -&gt; return ctxt
  | Promotion_vote -&gt;
      check_approval_and_update_participation_ema ctxt
      &gt;&gt;=? fun (ctxt, approved) -&gt;
      ( if approved then
        Vote.get_current_proposal ctxt
        &gt;&gt;=? fun proposal -&gt; activate ctxt proposal &gt;&gt;= fun ctxt -&gt; return ctxt
      else return ctxt )
      &gt;&gt;=? fun ctxt -&gt;
      Vote.clear_ballots ctxt
      &gt;&gt;= fun ctxt -&gt;
      Vote.clear_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.clear_current_proposal ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.freeze_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.set_current_period_kind ctxt Proposal &gt;&gt;=? fun ctxt -&gt; return ctxt

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | (* `Branch *)
      Invalid_proposal
  | Unexpected_proposal
  | Unauthorized_proposal
  | Too_many_proposals
  | Empty_proposal
  | Unexpected_ballot
  | Unauthorized_ballot</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  (* Invalid proposal *)
  register_error_kind
    `Branch
    ~id:&quot;invalid_proposal&quot;
    ~title:&quot;Invalid proposal&quot;
    ~description:&quot;Ballot provided for a proposal that is not the current one.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid proposal&quot;)
    empty
    (function Invalid_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_proposal) ;
  (* Unexpected proposal *)
  register_error_kind
    `Branch
    ~id:&quot;unexpected_proposal&quot;
    ~title:&quot;Unexpected proposal&quot;
    ~description:&quot;Proposal recorded outside of a proposal period.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unexpected proposal&quot;)
    empty
    (function Unexpected_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_proposal) ;
  (* Unauthorized proposal *)
  register_error_kind
    `Branch
    ~id:&quot;unauthorized_proposal&quot;
    ~title:&quot;Unauthorized proposal&quot;
    ~description:
      &quot;The delegate provided for the proposal is not in the voting listings.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unauthorized proposal&quot;)
    empty
    (function Unauthorized_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unauthorized_proposal) ;
  (* Unexpected ballot *)
  register_error_kind
    `Branch
    ~id:&quot;unexpected_ballot&quot;
    ~title:&quot;Unexpected ballot&quot;
    ~description:&quot;Ballot recorded outside of a voting period.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unexpected ballot&quot;)
    empty
    (function Unexpected_ballot -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_ballot) ;
  (* Unauthorized ballot *)
  register_error_kind
    `Branch
    ~id:&quot;unauthorized_ballot&quot;
    ~title:&quot;Unauthorized ballot&quot;
    ~description:
      &quot;The delegate provided for the ballot is not in the voting listings.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unauthorized ballot&quot;)
    empty
    (function Unauthorized_ballot -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unauthorized_ballot) ;
  (* Too many proposals *)
  register_error_kind
    `Branch
    ~id:&quot;too_many_proposals&quot;
    ~title:&quot;Too many proposals&quot;
    ~description:
      &quot;The delegate reached the maximum number of allowed proposals.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Too many proposals&quot;)
    empty
    (function Too_many_proposals -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_many_proposals) ;
  (* Empty proposal *)
  register_error_kind
    `Branch
    ~id:&quot;empty_proposal&quot;
    ~title:&quot;Empty proposal&quot;
    ~description:&quot;Proposal lists cannot be empty.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Empty proposal&quot;)
    empty
    (function Empty_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Empty_proposal)</abbr>

(* @return [true] if [List.length l] &gt; [n] w/o computing length *)
let rec longer_than l n =
  if Compare.Int.(n &lt; 0) then <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  else
    match l with
    | [] -&gt;
        false
    | _ :: rest -&gt;
        if Compare.Int.(n = 0) then true
        else (* n &gt; 0 *)
          longer_than rest (n - 1)

let record_proposals ctxt delegate proposals =
  (match proposals with [] -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">Empty_proposal</abbr> | _ :: _ -&gt; return_unit)
  &gt;&gt;=? fun () -&gt;
  Vote.get_current_period_kind ctxt
  &gt;&gt;=? function
  | Proposal -&gt;
      Vote.in_listings ctxt delegate
      &gt;&gt;= fun in_listings -&gt;
      if in_listings then
        Vote.recorded_proposal_count_for_delegate ctxt delegate
        &gt;&gt;=? fun count -&gt;
        fail_when
          (longer_than proposals (Constants.max_proposals_per_delegate - count))
          <abbr class="mark-error" title="Values of extensible types are not handled">Too_many_proposals</abbr>
        &gt;&gt;=? fun () -&gt;
        fold_left_s
          (fun ctxt proposal -&gt; Vote.record_proposal ctxt proposal delegate)
          ctxt
          proposals
        &gt;&gt;=? fun ctxt -&gt; return ctxt
      else fail <abbr class="mark-error" title="Values of extensible types are not handled">Unauthorized_proposal</abbr>
  | Testing_vote | Testing | Promotion_vote -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">Unexpected_proposal</abbr>

let record_ballot ctxt delegate proposal ballot =
  Vote.get_current_period_kind ctxt
  &gt;&gt;=? function
  | Testing_vote | Promotion_vote -&gt;
      Vote.get_current_proposal ctxt
      &gt;&gt;=? fun current_proposal -&gt;
      fail_unless
        (Protocol_hash.equal proposal current_proposal)
        <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_proposal</abbr>
      &gt;&gt;=? fun () -&gt;
      Vote.has_recorded_ballot ctxt delegate
      &gt;&gt;= fun has_ballot -&gt;
      fail_when has_ballot <abbr class="mark-error" title="Values of extensible types are not handled">Unauthorized_ballot</abbr>
      &gt;&gt;=? fun () -&gt;
      Vote.in_listings ctxt delegate
      &gt;&gt;= fun in_listings -&gt;
      if in_listings then Vote.record_ballot ctxt delegate ballot
      else fail <abbr class="mark-error" title="Values of extensible types are not handled">Unauthorized_ballot</abbr>
  | Testing | Proposal -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">Unexpected_ballot</abbr>

let last_of_a_voting_period ctxt l =
  Compare.Int32.(
    Int32.succ l.Level.voting_period_position
    = Constants.blocks_per_voting_period ctxt)

let may_start_new_voting_period ctxt =
  let level = Level.current ctxt in
  if last_of_a_voting_period ctxt level then start_new_voting_period ctxt
  else return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#amendment.ml"><code>Amendment.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.

Import Alpha_context.

Definition select_winning_proposal (ctxt : Alpha_context.context)
  : Lwt.t
    (Error_monad.tzresult
      (option Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.key))) :=
  Error_monad.op_gtgteqquestion (Alpha_context.Vote.get_proposals ctxt)
    (fun proposals =&gt;
      let merge {A : Set}
        (proposal : A) (vote : Compare.Int32.[Compare.S.t])
        (winners : option (list A * Compare.Int32.[Compare.S.t]))
        : option (list A * Compare.Int32.[Compare.S.t]) :=
        match winners with
        | None =&gt; Some ((cons proposal []), vote)
        | (Some (winners, winners_vote)) as previous =&gt;
          if Compare.Int32.[Compare.S.op_eq] vote winners_vote then
            Some ((cons proposal winners), winners_vote)
          else
            if Compare.Int32.[Compare.S.op_gt] vote winners_vote then
              Some ((cons proposal []), vote)
            else
              previous
        end in
      match Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.fold) merge proposals None
        with
      | Some (cons proposal [], vote) =&gt;
        Error_monad.op_gtgteqquestion (Alpha_context.Vote.listing_size ctxt)
          (fun max_vote =&gt;
            let min_proposal_quorum :=
              Alpha_context.Constants.min_proposal_quorum ctxt in
            let min_vote_to_pass :=
              Int32.div (Int32.mul min_proposal_quorum max_vote)
                (* ‚ùå Constant of type int32 is converted to int *)
                10000 in
            if Compare.Int32.[Compare.S.op_gteq] vote min_vote_to_pass then
              Error_monad.return_some proposal
            else
              Error_monad.return_none)
      | _ =&gt; Error_monad.return_none
      end).

Definition check_approval_and_update_participation_ema
  (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult (Alpha_context.context * bool)) :=
  Error_monad.op_gtgteqquestion (Alpha_context.Vote.get_ballots ctxt)
    (fun ballots =&gt;
      Error_monad.op_gtgteqquestion (Alpha_context.Vote.listing_size ctxt)
        (fun maximum_vote =&gt;
          Error_monad.op_gtgteqquestion
            (Alpha_context.Vote.get_participation_ema ctxt)
            (fun participation_ema =&gt;
              Error_monad.op_gtgteqquestion
                (Alpha_context.Vote.get_current_quorum ctxt)
                (fun expected_quorum =&gt;
                  let casted_votes :=
                    Int32.add (Alpha_context.Vote.ballots.yay ballots)
                      (Alpha_context.Vote.ballots.nay ballots) in
                  let all_votes :=
                    Int32.add casted_votes
                      (Alpha_context.Vote.ballots.pass ballots) in
                  let supermajority :=
                    Int32.div
                      (Int32.mul
                        (* ‚ùå Constant of type int32 is converted to int *)
                        8 casted_votes)
                      (* ‚ùå Constant of type int32 is converted to int *)
                      10 in
                  let participation :=
                    Int64.to_int32
                      (Int64.div
                        (Int64.mul (Int64.of_int32 all_votes)
                          (* ‚ùå Constant of type int64 is converted to int *)
                          10000) (Int64.of_int32 maximum_vote)) in
                  let outcome :=
                    Pervasives.op_andand
                      (Compare.Int32.[Compare.S.op_gteq] participation
                        expected_quorum)
                      (Compare.Int32.[Compare.S.op_gteq]
                        (Alpha_context.Vote.ballots.yay ballots) supermajority)
                    in
                  let new_participation_ema :=
                    Int32.div
                      (Int32.add
                        (Int32.mul
                          (* ‚ùå Constant of type int32 is converted to int *)
                          8 participation_ema)
                        (Int32.mul
                          (* ‚ùå Constant of type int32 is converted to int *)
                          2 participation))
                      (* ‚ùå Constant of type int32 is converted to int *)
                      10 in
                  Error_monad.op_gtgteqquestion
                    (Alpha_context.Vote.set_participation_ema ctxt
                      new_participation_ema)
                    (fun ctxt =&gt; Error_monad.__return (ctxt, outcome)))))).

Definition start_new_voting_period (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  Error_monad.op_gtgteqquestion
    (Alpha_context.Vote.get_current_period_kind ctxt)
    (fun function_parameter =&gt;
      match function_parameter with
      | Alpha_context.Voting_period.Proposal =&gt;
        Error_monad.op_gtgteqquestion (select_winning_proposal ctxt)
          (fun proposal =&gt;
            Error_monad.op_gtgteq (Alpha_context.Vote.clear_proposals ctxt)
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Alpha_context.Vote.clear_listings ctxt)
                  (fun ctxt =&gt;
                    match proposal with
                    | None =&gt;
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Vote.freeze_listings ctxt)
                        (fun ctxt =&gt; Error_monad.__return ctxt)
                    | Some proposal =&gt;
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Vote.init_current_proposal ctxt proposal)
                        (fun ctxt =&gt;
                          Error_monad.op_gtgteqquestion
                            (Alpha_context.Vote.freeze_listings ctxt)
                            (fun ctxt =&gt;
                              Error_monad.op_gtgteqquestion
                                (Alpha_context.Vote.set_current_period_kind ctxt
                                  Alpha_context.Voting_period.Testing_vote)
                                (fun ctxt =&gt; Error_monad.__return ctxt)))
                    end)))
      | Alpha_context.Voting_period.Testing_vote =&gt;
        Error_monad.op_gtgteqquestion
          (check_approval_and_update_participation_ema ctxt)
          (fun function_parameter =&gt;
            let '(ctxt, approved) := function_parameter in
            Error_monad.op_gtgteq (Alpha_context.Vote.clear_ballots ctxt)
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Alpha_context.Vote.clear_listings ctxt)
                  (fun ctxt =&gt;
                    if approved then
                      let expiration :=
                        Time.add (Alpha_context.Timestamp.current ctxt)
                          (Alpha_context.Constants.test_chain_duration ctxt) in
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Vote.get_current_proposal ctxt)
                        (fun proposal =&gt;
                          Error_monad.op_gtgteq
                            (Alpha_context.fork_test_chain ctxt proposal
                              expiration)
                            (fun ctxt =&gt;
                              Error_monad.op_gtgteqquestion
                                (Alpha_context.Vote.set_current_period_kind ctxt
                                  Alpha_context.Voting_period.Testing)
                                (fun ctxt =&gt; Error_monad.__return ctxt)))
                    else
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Vote.clear_current_proposal ctxt)
                        (fun ctxt =&gt;
                          Error_monad.op_gtgteqquestion
                            (Alpha_context.Vote.freeze_listings ctxt)
                            (fun ctxt =&gt;
                              Error_monad.op_gtgteqquestion
                                (Alpha_context.Vote.set_current_period_kind ctxt
                                  Alpha_context.Voting_period.Proposal)
                                (fun ctxt =&gt; Error_monad.__return ctxt))))))
      | Alpha_context.Voting_period.Testing =&gt;
        Error_monad.op_gtgteqquestion (Alpha_context.Vote.freeze_listings ctxt)
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion
              (Alpha_context.Vote.set_current_period_kind ctxt
                Alpha_context.Voting_period.Promotion_vote)
              (fun ctxt =&gt; Error_monad.__return ctxt))
      | Alpha_context.Voting_period.Promotion_vote =&gt;
        Error_monad.op_gtgteqquestion
          (check_approval_and_update_participation_ema ctxt)
          (fun function_parameter =&gt;
            let '(ctxt, approved) := function_parameter in
            Error_monad.op_gtgteqquestion
              (if approved then
                Error_monad.op_gtgteqquestion
                  (Alpha_context.Vote.get_current_proposal ctxt)
                  (fun proposal =&gt;
                    Error_monad.op_gtgteq (Alpha_context.activate ctxt proposal)
                      (fun ctxt =&gt; Error_monad.__return ctxt))
              else
                Error_monad.__return ctxt)
              (fun ctxt =&gt;
                Error_monad.op_gtgteq (Alpha_context.Vote.clear_ballots ctxt)
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Vote.clear_listings ctxt)
                      (fun ctxt =&gt;
                        Error_monad.op_gtgteqquestion
                          (Alpha_context.Vote.clear_current_proposal ctxt)
                          (fun ctxt =&gt;
                            Error_monad.op_gtgteqquestion
                              (Alpha_context.Vote.freeze_listings ctxt)
                              (fun ctxt =&gt;
                                Error_monad.op_gtgteqquestion
                                  (Alpha_context.Vote.set_current_period_kind
                                    ctxt Alpha_context.Voting_period.Proposal)
                                  (fun ctxt =&gt; Error_monad.__return ctxt)))))))
      end).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Fixpoint longer_than {A : Set} (l : list A) (n : Compare.Int.[Compare.S.t])
  {struct l} : bool :=
  if Compare.Int.[Compare.S.op_lt] n 0 then
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  else
    match l with
    | [] =&gt; false
    | cons _ rest =&gt;
      if Compare.Int.[Compare.S.op_eq] n 0 then
        true
      else
        longer_than rest (Pervasives.op_minus n 1)
    end.

Definition record_proposals
  (ctxt : Alpha_context.context) (delegate : Alpha_context.public_key_hash)
  (proposals : list Protocol_hash.[S.HASH.t])
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  Error_monad.op_gtgteqquestion
    match proposals with
    | [] =&gt; Error_monad.fail extensible_type_value
    | cons _ _ =&gt; Error_monad.return_unit
    end
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      Error_monad.op_gtgteqquestion
        (Alpha_context.Vote.get_current_period_kind ctxt)
        (fun function_parameter =&gt;
          match function_parameter with
          | Alpha_context.Voting_period.Proposal =&gt;
            Error_monad.op_gtgteq (Alpha_context.Vote.in_listings ctxt delegate)
              (fun in_listings =&gt;
                if in_listings then
                  Error_monad.op_gtgteqquestion
                    (Alpha_context.Vote.recorded_proposal_count_for_delegate
                      ctxt delegate)
                    (fun count =&gt;
                      Error_monad.op_gtgteqquestion
                        (Error_monad.fail_when
                          (longer_than proposals
                            (Pervasives.op_minus
                              Alpha_context.Constants.max_proposals_per_delegate
                              count)) extensible_type_value)
                        (fun function_parameter =&gt;
                          let 'tt := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (Error_monad.fold_left_s
                              (fun ctxt =&gt;
                                fun proposal =&gt;
                                  Alpha_context.Vote.record_proposal ctxt
                                    proposal delegate) ctxt proposals)
                            (fun ctxt =&gt; Error_monad.__return ctxt)))
                else
                  Error_monad.fail extensible_type_value)
          |
            Alpha_context.Voting_period.Testing_vote |
            Alpha_context.Voting_period.Testing |
            Alpha_context.Voting_period.Promotion_vote =&gt;
            Error_monad.fail extensible_type_value
          end)).

Definition record_ballot
  (ctxt : Alpha_context.context) (delegate : Alpha_context.public_key_hash)
  (proposal : Protocol_hash.[S.HASH.t]) (ballot : Alpha_context.Vote.ballot)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  Error_monad.op_gtgteqquestion
    (Alpha_context.Vote.get_current_period_kind ctxt)
    (fun function_parameter =&gt;
      match function_parameter with
      |
        Alpha_context.Voting_period.Testing_vote |
        Alpha_context.Voting_period.Promotion_vote =&gt;
        Error_monad.op_gtgteqquestion
          (Alpha_context.Vote.get_current_proposal ctxt)
          (fun current_proposal =&gt;
            Error_monad.op_gtgteqquestion
              (Error_monad.fail_unless
                (Protocol_hash.[S.HASH.equal] proposal current_proposal)
                extensible_type_value)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteq
                  (Alpha_context.Vote.has_recorded_ballot ctxt delegate)
                  (fun has_ballot =&gt;
                    Error_monad.op_gtgteqquestion
                      (Error_monad.fail_when has_ballot extensible_type_value)
                      (fun function_parameter =&gt;
                        let 'tt := function_parameter in
                        Error_monad.op_gtgteq
                          (Alpha_context.Vote.in_listings ctxt delegate)
                          (fun in_listings =&gt;
                            if in_listings then
                              Alpha_context.Vote.record_ballot ctxt delegate
                                ballot
                            else
                              Error_monad.fail extensible_type_value)))))
      |
        Alpha_context.Voting_period.Testing |
        Alpha_context.Voting_period.Proposal =&gt;
        Error_monad.fail extensible_type_value
      end).

Definition last_of_a_voting_period
  (ctxt : Alpha_context.context) (l : Alpha_context.Level.t) : bool :=
  Compare.Int32.[Compare.S.op_eq]
    (Int32.succ (Alpha_context.Level.t.voting_period_position l))
    (Alpha_context.Constants.blocks_per_voting_period ctxt).

Definition may_start_new_voting_period (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let level := Alpha_context.Level.current ctxt in
  if last_of_a_voting_period ctxt level then
    start_new_voting_period ctxt
  else
    Error_monad.__return ctxt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="amendment.mli">
  <div class="col-md-6">
    <a href="#amendment.mli"><code>amendment.mli</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(**
   Only delegates with at least one roll take part in the amendment procedure.
   It works as follows:
   - Proposal period: delegates can submit protocol amendment proposals using
     the proposal operation. At the end of a proposal period, the proposal with
     most supporters is selected and we move to a testing_vote period.
     If there are no proposals, or a tie between proposals, a new proposal
     period starts.
   - Testing_vote period: delegates can cast votes to test or not the winning
     proposal using the ballot operation.
     At the end of a testing_vote period if participation reaches the quorum
     and the proposal has a supermajority in favor, we proceed to a testing
     period. Otherwise we go back to a proposal period.
     In any case, if there is enough participation the quorum is updated.
   - Testing period: a test chain is forked for the lengh of the period.
     At the end of a testing period we move to a promotion_vote period.
   - Promotion_vote period: delegates can cast votes to promote or not the
     tested proposal using the ballot operation.
     At the end of a promotion_vote period if participation reaches the quorum
     and the tested proposal has a supermajority in favor, it is activated as
     the new protocol. Otherwise we go back to a proposal period.
     In any case, if there is enough participation the quorum is updated.
*)

open Alpha_context

(** If at the end of a voting period, moves to the next one following
    the state machine of the amendment procedure. *)
val may_start_new_voting_period : context -&gt; context tzresult Lwt.t

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Unexpected_proposal
  | Unauthorized_proposal
  | Too_many_proposals
  | Empty_proposal</abbr>

(** Records a list of proposals for a delegate.
    @raise Unexpected_proposal if [ctxt] is not in a proposal period.
    @raise Unauthorized_proposal if [delegate] is not in the listing. *)
val record_proposals :
  context -&gt; public_key_hash -&gt; Protocol_hash.t list -&gt; context tzresult Lwt.t

<abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_proposal | Unexpected_ballot | Unauthorized_ballot</abbr>

val record_ballot :
  context -&gt;
  public_key_hash -&gt;
  Protocol_hash.t -&gt;
  Vote.ballot -&gt;
  context tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#amendment.mli"><code>Amendment_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.

Parameter may_start_new_voting_period :
  Alpha_context.context -&gt; Lwt.t (Error_monad.tzresult Alpha_context.context).

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter record_proposals :
  Alpha_context.context -&gt; Alpha_context.public_key_hash -&gt;
  list Protocol_hash.[S.HASH.t] -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.context).

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter record_ballot :
  Alpha_context.context -&gt; Alpha_context.public_key_hash -&gt;
  Protocol_hash.[S.HASH.t] -&gt; Alpha_context.Vote.ballot -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.context).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="apply.ml">
  <div class="col-md-6">
    <a href="#apply.ml"><code>apply.ml</code></a>&nbsp;<span class="label label-danger">70 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Main Entry Points *)

open Alpha_context

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Wrong_voting_period of Voting_period.t * Voting_period.t</abbr>

(* `Temporary *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Wrong_endorsement_predecessor of Block_hash.t * Block_hash.t</abbr>

(* `Temporary *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Duplicate_endorsement of Signature.Public_key_hash.t</abbr>

(* `Branch *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_endorsement_level</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_commitment of {expected : bool}</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Internal_operation_replay of packed_internal_operation</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_double_endorsement_evidence</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Inconsistent_double_endorsement_evidence of {
      delegate1 : Signature.Public_key_hash.t;
      delegate2 : Signature.Public_key_hash.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unrequired_double_endorsement_evidence</abbr> (* `Branch*)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Too_early_double_endorsement_evidence of {
      level : Raw_level.t;
      current : Raw_level.t;
    }</abbr>

(* `Temporary *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Outdated_double_endorsement_evidence of {
      level : Raw_level.t;
      last : Raw_level.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Invalid_double_baking_evidence of {
      hash1 : Block_hash.t;
      level1 : Int32.t;
      hash2 : Block_hash.t;
      level2 : Int32.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Inconsistent_double_baking_evidence of {
      delegate1 : Signature.Public_key_hash.t;
      delegate2 : Signature.Public_key_hash.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unrequired_double_baking_evidence</abbr> (* `Branch*)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Too_early_double_baking_evidence of {
      level : Raw_level.t;
      current : Raw_level.t;
    }</abbr>

(* `Temporary *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Outdated_double_baking_evidence of {
      level : Raw_level.t;
      last : Raw_level.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_activation of {pkh : Ed25519.Public_key_hash.t}</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Multiple_revelation</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Gas_quota_exceeded_init_deserialize</abbr> (* Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Not_enough_endorsements_for_priority of {
      required : int;
      priority : int;
      endorsements : int;
      timestamp : Time.t;
    }</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Temporary
    ~id:&quot;operation.wrong_endorsement_predecessor&quot;
    ~title:&quot;Wrong endorsement predecessor&quot;
    ~description:
      &quot;Trying to include an endorsement in a block that is not the successor \
       of the endorsed one&quot;
    ~pp:(fun ppf (e, p) -&gt;
      Format.fprintf
        ppf
        &quot;Wrong predecessor %a, expected %a&quot;
        Block_hash.pp
        p
        Block_hash.pp
        e)
    Data_encoding.(
      obj2
        (req &quot;expected&quot; Block_hash.encoding)
        (req &quot;provided&quot; Block_hash.encoding))
    (function
      | Wrong_endorsement_predecessor (e, p) -&gt; Some (e, p) | _ -&gt; None)
    (fun (e, p) -&gt; Wrong_endorsement_predecessor (e, p)) ;
  register_error_kind
    `Temporary
    ~id:&quot;operation.wrong_voting_period&quot;
    ~title:&quot;Wrong voting period&quot;
    ~description:
      &quot;Trying to onclude a proposal or ballot meant for another voting period&quot;
    ~pp:(fun ppf (e, p) -&gt;
      Format.fprintf
        ppf
        &quot;Wrong voting period %a, current is %a&quot;
        Voting_period.pp
        p
        Voting_period.pp
        e)
    Data_encoding.(
      obj2
        (req &quot;current&quot; Voting_period.encoding)
        (req &quot;provided&quot; Voting_period.encoding))
    (function Wrong_voting_period (e, p) -&gt; Some (e, p) | _ -&gt; None)
    (fun (e, p) -&gt; Wrong_voting_period (e, p)) ;
  register_error_kind
    `Branch
    ~id:&quot;operation.duplicate_endorsement&quot;
    ~title:&quot;Duplicate endorsement&quot;
    ~description:&quot;Two endorsements received from same delegate&quot;
    ~pp:(fun ppf k -&gt;
      Format.fprintf
        ppf
        &quot;Duplicate endorsement from delegate %a (possible replay attack).&quot;
        Signature.Public_key_hash.pp_short
        k)
    Data_encoding.(obj1 (req &quot;delegate&quot; Signature.Public_key_hash.encoding))
    (function Duplicate_endorsement k -&gt; Some k | _ -&gt; None)
    (fun k -&gt; Duplicate_endorsement k) ;
  register_error_kind
    `Temporary
    ~id:&quot;operation.invalid_endorsement_level&quot;
    ~title:&quot;Unexpected level in endorsement&quot;
    ~description:
      &quot;The level of an endorsement is inconsistent with the  provided block \
       hash.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unexpected level in endorsement.&quot;)
    Data_encoding.unit
    (function Invalid_endorsement_level -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_endorsement_level) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.invalid_commitment&quot;
    ~title:&quot;Invalid commitment in block header&quot;
    ~description:&quot;The block header has invalid commitment.&quot;
    ~pp:(fun ppf expected -&gt;
      if expected then
        Format.fprintf ppf &quot;Missing seed's nonce commitment in block header.&quot;
      else
        Format.fprintf
          ppf
          &quot;Unexpected seed's nonce commitment in block header.&quot;)
    Data_encoding.(obj1 (req &quot;expected&quot; bool))
    (function Invalid_commitment {expected} -&gt; Some expected | _ -&gt; None)
    (fun expected -&gt; Invalid_commitment {expected}) ;
  register_error_kind
    `Permanent
    ~id:&quot;internal_operation_replay&quot;
    ~title:&quot;Internal operation replay&quot;
    ~description:&quot;An internal operation was emitted twice by a script&quot;
    ~pp:(fun ppf (Internal_operation {nonce; _}) -&gt;
      Format.fprintf
        ppf
        &quot;Internal operation %d was emitted twice by a script&quot;
        nonce)
    Operation.internal_operation_encoding
    (function Internal_operation_replay op -&gt; Some op | _ -&gt; None)
    (fun op -&gt; Internal_operation_replay op) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.invalid_double_endorsement_evidence&quot;
    ~title:&quot;Invalid double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is malformed&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;Malformed double-endorsement evidence&quot;)
    Data_encoding.empty
    (function Invalid_double_endorsement_evidence -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_double_endorsement_evidence) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.inconsistent_double_endorsement_evidence&quot;
    ~title:&quot;Inconsistent double endorsement evidence&quot;
    ~description:
      &quot;A double-endorsement evidence is inconsistent  (two distinct delegates)&quot;
    ~pp:(fun ppf (delegate1, delegate2) -&gt;
      Format.fprintf
        ppf
        &quot;Inconsistent double-endorsement evidence  (distinct delegate: %a and \
         %a)&quot;
        Signature.Public_key_hash.pp_short
        delegate1
        Signature.Public_key_hash.pp_short
        delegate2)
    Data_encoding.(
      obj2
        (req &quot;delegate1&quot; Signature.Public_key_hash.encoding)
        (req &quot;delegate2&quot; Signature.Public_key_hash.encoding))
    (function
      | Inconsistent_double_endorsement_evidence {delegate1; delegate2} -&gt;
          Some (delegate1, delegate2)
      | _ -&gt;
          None)
    (fun (delegate1, delegate2) -&gt;
      Inconsistent_double_endorsement_evidence {delegate1; delegate2}) ;
  register_error_kind
    `Branch
    ~id:&quot;block.unrequired_double_endorsement_evidence&quot;
    ~title:&quot;Unrequired double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is unrequired&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;A valid double-endorsement operation cannot  be applied: the \
         associated delegate  has previously been denunciated in this cycle.&quot;)
    Data_encoding.empty
    (function Unrequired_double_endorsement_evidence -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unrequired_double_endorsement_evidence) ;
  register_error_kind
    `Temporary
    ~id:&quot;block.too_early_double_endorsement_evidence&quot;
    ~title:&quot;Too early double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is in the future&quot;
    ~pp:(fun ppf (level, current) -&gt;
      Format.fprintf
        ppf
        &quot;A double-endorsement evidence is in the future  (current level: %a, \
         endorsement level: %a)&quot;
        Raw_level.pp
        current
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;current&quot; Raw_level.encoding))
    (function
      | Too_early_double_endorsement_evidence {level; current} -&gt;
          Some (level, current)
      | _ -&gt;
          None)
    (fun (level, current) -&gt;
      Too_early_double_endorsement_evidence {level; current}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.outdated_double_endorsement_evidence&quot;
    ~title:&quot;Outdated double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is outdated.&quot;
    ~pp:(fun ppf (level, last) -&gt;
      Format.fprintf
        ppf
        &quot;A double-endorsement evidence is outdated  (last acceptable level: \
         %a, endorsement level: %a)&quot;
        Raw_level.pp
        last
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;last&quot; Raw_level.encoding))
    (function
      | Outdated_double_endorsement_evidence {level; last} -&gt;
          Some (level, last)
      | _ -&gt;
          None)
    (fun (level, last) -&gt; Outdated_double_endorsement_evidence {level; last}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.invalid_double_baking_evidence&quot;
    ~title:&quot;Invalid double baking evidence&quot;
    ~description:
      &quot;A double-baking evidence is inconsistent  (two distinct level)&quot;
    ~pp:(fun ppf (hash1, level1, hash2, level2) -&gt;
      Format.fprintf
        ppf
        &quot;Invalid double-baking evidence (hash: %a and %a, levels: %ld and %ld)&quot;
        Block_hash.pp
        hash1
        Block_hash.pp
        hash2
        level1
        level2)
    Data_encoding.(
      obj4
        (req &quot;hash1&quot; Block_hash.encoding)
        (req &quot;level1&quot; int32)
        (req &quot;hash2&quot; Block_hash.encoding)
        (req &quot;level2&quot; int32))
    (function
      | Invalid_double_baking_evidence {hash1; level1; hash2; level2} -&gt;
          Some (hash1, level1, hash2, level2)
      | _ -&gt;
          None)
    (fun (hash1, level1, hash2, level2) -&gt;
      Invalid_double_baking_evidence {hash1; level1; hash2; level2}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.inconsistent_double_baking_evidence&quot;
    ~title:&quot;Inconsistent double baking evidence&quot;
    ~description:
      &quot;A double-baking evidence is inconsistent  (two distinct delegates)&quot;
    ~pp:(fun ppf (delegate1, delegate2) -&gt;
      Format.fprintf
        ppf
        &quot;Inconsistent double-baking evidence  (distinct delegate: %a and %a)&quot;
        Signature.Public_key_hash.pp_short
        delegate1
        Signature.Public_key_hash.pp_short
        delegate2)
    Data_encoding.(
      obj2
        (req &quot;delegate1&quot; Signature.Public_key_hash.encoding)
        (req &quot;delegate2&quot; Signature.Public_key_hash.encoding))
    (function
      | Inconsistent_double_baking_evidence {delegate1; delegate2} -&gt;
          Some (delegate1, delegate2)
      | _ -&gt;
          None)
    (fun (delegate1, delegate2) -&gt;
      Inconsistent_double_baking_evidence {delegate1; delegate2}) ;
  register_error_kind
    `Branch
    ~id:&quot;block.unrequired_double_baking_evidence&quot;
    ~title:&quot;Unrequired double baking evidence&quot;
    ~description:&quot;A double-baking evidence is unrequired&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;A valid double-baking operation cannot  be applied: the associated \
         delegate  has previously been denunciated in this cycle.&quot;)
    Data_encoding.empty
    (function Unrequired_double_baking_evidence -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unrequired_double_baking_evidence) ;
  register_error_kind
    `Temporary
    ~id:&quot;block.too_early_double_baking_evidence&quot;
    ~title:&quot;Too early double baking evidence&quot;
    ~description:&quot;A double-baking evidence is in the future&quot;
    ~pp:(fun ppf (level, current) -&gt;
      Format.fprintf
        ppf
        &quot;A double-baking evidence is in the future  (current level: %a, \
         baking level: %a)&quot;
        Raw_level.pp
        current
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;current&quot; Raw_level.encoding))
    (function
      | Too_early_double_baking_evidence {level; current} -&gt;
          Some (level, current)
      | _ -&gt;
          None)
    (fun (level, current) -&gt; Too_early_double_baking_evidence {level; current}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.outdated_double_baking_evidence&quot;
    ~title:&quot;Outdated double baking evidence&quot;
    ~description:&quot;A double-baking evidence is outdated.&quot;
    ~pp:(fun ppf (level, last) -&gt;
      Format.fprintf
        ppf
        &quot;A double-baking evidence is outdated  (last acceptable level: %a, \
         baking level: %a)&quot;
        Raw_level.pp
        last
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;last&quot; Raw_level.encoding))
    (function
      | Outdated_double_baking_evidence {level; last} -&gt;
          Some (level, last)
      | _ -&gt;
          None)
    (fun (level, last) -&gt; Outdated_double_baking_evidence {level; last}) ;
  register_error_kind
    `Permanent
    ~id:&quot;operation.invalid_activation&quot;
    ~title:&quot;Invalid activation&quot;
    ~description:
      &quot;The given key and secret do not correspond to any existing \
       preallocated contract&quot;
    ~pp:(fun ppf pkh -&gt;
      Format.fprintf
        ppf
        &quot;Invalid activation. The public key %a does not match any commitment.&quot;
        Ed25519.Public_key_hash.pp
        pkh)
    Data_encoding.(obj1 (req &quot;pkh&quot; Ed25519.Public_key_hash.encoding))
    (function Invalid_activation {pkh} -&gt; Some pkh | _ -&gt; None)
    (fun pkh -&gt; Invalid_activation {pkh}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.multiple_revelation&quot;
    ~title:&quot;Multiple revelations were included in a manager operation&quot;
    ~description:
      &quot;A manager operation should not contain more than one revelation&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;Multiple revelations were included in a manager operation&quot;)
    Data_encoding.empty
    (function Multiple_revelation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Multiple_revelation) ;
  register_error_kind
    `Permanent
    ~id:&quot;gas_exhausted.init_deserialize&quot;
    ~title:&quot;Not enough gas for initial deserialization of script expresions&quot;
    ~description:
      &quot;Gas limit was not high enough to deserialize the transaction \
       parameters or origination script code or initial storage, making the \
       operation impossible to parse within the provided gas bounds.&quot;
    Data_encoding.empty
    (function Gas_quota_exceeded_init_deserialize -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Gas_quota_exceeded_init_deserialize) ;
  register_error_kind
    `Permanent
    ~id:&quot;operation.not_enought_endorsements_for_priority&quot;
    ~title:&quot;Not enough endorsements for priority&quot;
    ~description:
      &quot;The block being validated does not include the required minimum number \
       of endorsements for this priority.&quot;
    ~pp:(fun ppf (required, endorsements, priority, timestamp) -&gt;
      Format.fprintf
        ppf
        &quot;Wrong number of endorsements (%i) for priority (%i), %i are expected \
         at %a&quot;
        endorsements
        priority
        required
        Time.pp_hum
        timestamp)
    Data_encoding.(
      obj4
        (req &quot;required&quot; int31)
        (req &quot;endorsements&quot; int31)
        (req &quot;priority&quot; int31)
        (req &quot;timestamp&quot; Time.encoding))
    (function
      | Not_enough_endorsements_for_priority
          {required; endorsements; priority; timestamp} -&gt;
          Some (required, endorsements, priority, timestamp)
      | _ -&gt;
          None)
    (fun (required, endorsements, priority, timestamp) -&gt;
      Not_enough_endorsements_for_priority
        {required; endorsements; priority; timestamp})</abbr>

open Apply_results

let apply_manager_operation_content :
    type kind.
    Alpha_context.t -&gt;
    Script_ir_translator.unparsing_mode -&gt;
    payer:Contract.t -&gt;
    source:Contract.t -&gt;
    chain_id:Chain_id.t -&gt;
    internal:bool -&gt;
    kind manager_operation -&gt;
    ( context
    * kind successful_manager_operation_result
    * packed_internal_operation list )
    tzresult
    Lwt.t =
 fun ctxt mode ~payer ~source ~chain_id ~internal operation -&gt;
  let before_operation =
    (* This context is not used for backtracking. Only to compute
         gas consumption and originations for the operation result. *)
    ctxt
  in
  Contract.must_exist ctxt source
  &gt;&gt;=? fun () -&gt;
  Lwt.return (Gas.consume ctxt Michelson_v1_gas.Cost_of.manager_operation)
  &gt;&gt;=? fun ctxt -&gt;
  match operation with
  | Reveal _ -&gt;
      return
        (* No-op: action already performed by `precheck_manager_contents`. *)
        ( ctxt,
          ( Reveal_result
              {consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt}
            : kind successful_manager_operation_result ),
          [] )
  | Transaction {amount; parameters; destination; entrypoint} -&gt; (
      Contract.spend ctxt source amount
      &gt;&gt;=? fun ctxt -&gt;
      ( match Contract.is_implicit destination with
      | None -&gt;
          return (ctxt, [], false)
      | Some _ -&gt; (
          Contract.allocated ctxt destination
          &gt;&gt;=? function
          | true -&gt;
              return (ctxt, [], false)
          | false -&gt;
              Fees.origination_burn ctxt
              &gt;&gt;=? fun (ctxt, origination_burn) -&gt;
              return
                ( ctxt,
                  [(Delegate.Contract payer, Delegate.Debited origination_burn)],
                  true ) ) )
      &gt;&gt;=? fun (ctxt, maybe_burn_balance_update, allocated_destination_contract)
               -&gt;
      Contract.credit ctxt destination amount
      &gt;&gt;=? fun ctxt -&gt;
      Contract.get_script ctxt destination
      &gt;&gt;=? fun (ctxt, script) -&gt;
      match script with
      | None -&gt;
          ( match entrypoint with
          | &quot;default&quot; -&gt;
              return ()
          | entrypoint -&gt;
              fail <abbr class="mark-error" title="Values of extensible types are not handled">(Script_tc_errors.No_such_entrypoint entrypoint)</abbr> )
          &gt;&gt;=? (fun () -&gt;
                 Script.force_decode ctxt parameters
                 &gt;&gt;=? fun (arg, ctxt) -&gt;
                 (* see [note] *)
                 (* [note]: for toplevel ops, cost is nil since the
               lazy value has already been forced at precheck, so
               we compute and consume the full cost again *)
                 let cost_arg = Script.deserialized_cost arg in
                 Lwt.return (Gas.consume ctxt cost_arg)
                 &gt;&gt;=? fun ctxt -&gt;
                 match Micheline.root arg with
                 | Prim (_, D_Unit, [], _) -&gt;
                     (* Allow [Unit] parameter to non-scripted contracts. *)
                     return ctxt
                 | _ -&gt;
                     fail
                       <abbr class="mark-error" title="Values of extensible types are not handled">(Script_interpreter.Bad_contract_parameter destination)</abbr>)
          &gt;&gt;=? fun ctxt -&gt;
          let result =
            Transaction_result
              {
                storage = None;
                big_map_diff = None;
                balance_updates =
                  Delegate.cleanup_balance_updates
                    ( [ (Delegate.Contract source, Delegate.Debited amount);
                        (Contract destination, Credited amount) ]
                    @ maybe_burn_balance_update );
                originated_contracts = [];
                consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt;
                storage_size = Z.zero;
                paid_storage_size_diff = Z.zero;
                allocated_destination_contract;
              }
          in
          return (ctxt, result, [])
      | Some script -&gt;
          Script.force_decode ctxt parameters
          &gt;&gt;=? fun (parameter, ctxt) -&gt;
          (* see [note] *)
          let cost_parameter = Script.deserialized_cost parameter in
          Lwt.return (Gas.consume ctxt cost_parameter)
          &gt;&gt;=? fun ctxt -&gt;
          let step_constants =
            let open Script_interpreter in
            {source; payer; self = destination; amount; chain_id}
          in
          Script_interpreter.execute
            ctxt
            mode
            step_constants
            ~script
            ~parameter
            ~entrypoint
          &gt;&gt;=? fun {ctxt; storage; big_map_diff; operations} -&gt;
          Contract.update_script_storage ctxt destination storage big_map_diff
          &gt;&gt;=? fun ctxt -&gt;
          Fees.record_paid_storage_space ctxt destination
          &gt;&gt;=? fun (ctxt, new_size, paid_storage_size_diff, fees) -&gt;
          Contract.originated_from_current_nonce
            ~since:before_operation
            ~until:ctxt
          &gt;&gt;=? fun originated_contracts -&gt;
          let result =
            Transaction_result
              {
                storage = Some storage;
                big_map_diff;
                balance_updates =
                  Delegate.cleanup_balance_updates
                    [ (Contract payer, Debited fees);
                      (Contract source, Debited amount);
                      (Contract destination, Credited amount) ];
                originated_contracts;
                consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt;
                storage_size = new_size;
                paid_storage_size_diff;
                allocated_destination_contract;
              }
          in
          return (ctxt, result, operations) )
  | Origination {delegate; script; preorigination; credit} -&gt;
      Script.force_decode ctxt script.storage
      &gt;&gt;=? fun (unparsed_storage, ctxt) -&gt;
      (* see [note] *)
      Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_storage))
      &gt;&gt;=? fun ctxt -&gt;
      Script.force_decode ctxt script.code
      &gt;&gt;=? fun (unparsed_code, ctxt) -&gt;
      (* see [note] *)
      Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_code))
      &gt;&gt;=? fun ctxt -&gt;
      Script_ir_translator.parse_script ctxt ~legacy:false script
      &gt;&gt;=? fun (Ex_script parsed_script, ctxt) -&gt;
      Script_ir_translator.collect_big_maps
        ctxt
        parsed_script.storage_type
        parsed_script.storage
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = Script_ir_translator.no_big_map_id in
      Script_ir_translator.extract_big_map_diff
        ctxt
        Optimized
        parsed_script.storage_type
        parsed_script.storage
        ~to_duplicate
        ~to_update
        ~temporary:false
      &gt;&gt;=? fun (storage, big_map_diff, ctxt) -&gt;
      Script_ir_translator.unparse_data
        ctxt
        Optimized
        parsed_script.storage_type
        storage
      &gt;&gt;=? fun (storage, ctxt) -&gt;
      let storage = Script.lazy_expr (Micheline.strip_locations storage) in
      let script = <abbr class="mark-error" title="Record substitution not handled">{script with storage}</abbr> in
      Contract.spend ctxt source credit
      &gt;&gt;=? fun ctxt -&gt;
      ( match preorigination with
      | Some contract -&gt;
          <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert internal ;
          (* The preorigination field is only used to early return
                 the address of an originated contract in Michelson.
                 It cannot come from the outside. *)
          return (ctxt, contract)</abbr>
      | None -&gt;
          Contract.fresh_contract_from_current_nonce ctxt )
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      Contract.originate
        ctxt
        contract
        ~delegate
        ~balance:credit
        ~script:(script, big_map_diff)
      &gt;&gt;=? fun ctxt -&gt;
      Fees.origination_burn ctxt
      &gt;&gt;=? fun (ctxt, origination_burn) -&gt;
      Fees.record_paid_storage_space ctxt contract
      &gt;&gt;=? fun (ctxt, size, paid_storage_size_diff, fees) -&gt;
      let result =
        Origination_result
          {
            big_map_diff;
            balance_updates =
              Delegate.cleanup_balance_updates
                [ (Contract payer, Debited fees);
                  (Contract payer, Debited origination_burn);
                  (Contract source, Debited credit);
                  (Contract contract, Credited credit) ];
            originated_contracts = [contract];
            consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt;
            storage_size = size;
            paid_storage_size_diff;
          }
      in
      return (ctxt, result, [])
  | Delegation delegate -&gt;
      Delegate.set ctxt source delegate
      &gt;&gt;=? fun ctxt -&gt;
      return
        ( ctxt,
          Delegation_result
            {consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt},
          [] )

let <abbr class="mark-error" title="Polymorphic variant types are not handled">apply_internal_manager_operations</abbr> ctxt mode ~payer ~chain_id ops =
  let rec <abbr class="mark-error" title="Polymorphic variant types are not handled">apply</abbr> ctxt applied worklist =
    match worklist with
    | [] -&gt;
        Lwt.return (<abbr class="mark-error" title="Variants not supported">`Success ctxt</abbr>, List.rev applied)
    | Internal_operation ({source; operation; nonce} as op) :: rest -&gt; (
        ( if internal_nonce_already_recorded ctxt nonce then
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Internal_operation_replay (Internal_operation op))</abbr>
        else
          let ctxt = record_internal_nonce ctxt nonce in
          apply_manager_operation_content
            ctxt
            mode
            ~source
            ~payer
            ~chain_id
            ~internal:true
            operation )
        &gt;&gt;= function
        | Error errors -&gt;
            let result =
              Internal_operation_result
                (op, Failed (manager_kind op.operation, errors))
            in
            let skipped =
              List.rev_map
                (fun (Internal_operation op) -&gt;
                  Internal_operation_result
                    (op, Skipped (manager_kind op.operation)))
                rest
            in
            Lwt.return (<abbr class="mark-error" title="Variants not supported">`Failure</abbr>, List.rev (skipped @ (result :: applied)))
        | Ok (ctxt, result, emitted) -&gt;
            apply
              ctxt
              (Internal_operation_result (op, Applied result) :: applied)
              (rest @ emitted) )
  in
  apply ctxt [] ops

let precheck_manager_contents (type kind) ctxt chain_id raw_operation
    (op : kind Kind.manager contents) : context tzresult Lwt.t =
  let (Manager_operation
        {source; fee; counter; operation; gas_limit; storage_limit}) =
    op
  in
  Lwt.return (Gas.check_limit ctxt gas_limit)
  &gt;&gt;=? fun () -&gt;
  let ctxt = Gas.set_limit ctxt gas_limit in
  Lwt.return (Fees.check_storage_limit ctxt storage_limit)
  &gt;&gt;=? fun () -&gt;
  Contract.must_be_allocated ctxt (Contract.implicit_contract source)
  &gt;&gt;=? fun () -&gt;
  Contract.check_counter_increment ctxt source counter
  &gt;&gt;=? fun () -&gt;
  ( match operation with
  | Reveal pk -&gt;
      Contract.reveal_manager_key ctxt source pk
  | Transaction {parameters; _} -&gt;
      (* Fail quickly if not enough gas for minimal deserialization cost *)
      Lwt.return
      @@ record_trace <abbr class="mark-error" title="Values of extensible types are not handled">Gas_quota_exceeded_init_deserialize</abbr>
      @@ Gas.check_enough ctxt (Script.minimal_deserialize_cost parameters)
      &gt;&gt;=? fun () -&gt;
      (* Fail if not enough gas for complete deserialization cost *)
      trace <abbr class="mark-error" title="Values of extensible types are not handled">Gas_quota_exceeded_init_deserialize</abbr>
      @@ Script.force_decode ctxt parameters
      &gt;&gt;|? fun (_arg, ctxt) -&gt; ctxt
  | Origination {script; _} -&gt;
      (* Fail quickly if not enough gas for minimal deserialization cost *)
      Lwt.return
      @@ record_trace <abbr class="mark-error" title="Values of extensible types are not handled">Gas_quota_exceeded_init_deserialize</abbr>
      @@ ( Gas.consume ctxt (Script.minimal_deserialize_cost script.code)
         &gt;&gt;? fun ctxt -&gt;
         Gas.check_enough ctxt (Script.minimal_deserialize_cost script.storage)
         )
      &gt;&gt;=? fun () -&gt;
      (* Fail if not enough gas for complete deserialization cost *)
      trace <abbr class="mark-error" title="Values of extensible types are not handled">Gas_quota_exceeded_init_deserialize</abbr>
      @@ Script.force_decode ctxt script.code
      &gt;&gt;=? fun (_code, ctxt) -&gt;
      trace <abbr class="mark-error" title="Values of extensible types are not handled">Gas_quota_exceeded_init_deserialize</abbr>
      @@ Script.force_decode ctxt script.storage
      &gt;&gt;|? fun (_storage, ctxt) -&gt; ctxt
  | _ -&gt;
      return ctxt )
  &gt;&gt;=? fun ctxt -&gt;
  Contract.get_manager_key ctxt source
  &gt;&gt;=? fun public_key -&gt;
  (* Currently, the `raw_operation` only contains one signature, so
     all operations are required to be from the same manager. This may
     change in the future, allowing several managers to group-sign a
     sequence of transactions.  *)
  Operation.check_signature public_key chain_id raw_operation
  &gt;&gt;=? fun () -&gt;
  Contract.increment_counter ctxt source
  &gt;&gt;=? fun ctxt -&gt;
  Contract.spend ctxt (Contract.implicit_contract source) fee
  &gt;&gt;=? fun ctxt -&gt; add_fees ctxt fee &gt;&gt;=? fun ctxt -&gt; return ctxt

let <abbr class="mark-error" title="Polymorphic variant types are not handled">apply_manager_contents</abbr> (type kind) ctxt mode chain_id
    (op : kind Kind.manager contents) :
    ( [`Success of context | `Failure]
    * kind manager_operation_result
    * packed_internal_operation_result list )
    Lwt.t =
  let (Manager_operation {source; operation; gas_limit; storage_limit}) = op in
  let ctxt = Gas.set_limit ctxt gas_limit in
  let ctxt = Fees.start_counting_storage_fees ctxt in
  let source = Contract.implicit_contract source in
  apply_manager_operation_content
    ctxt
    mode
    ~source
    ~payer:source
    ~internal:false
    ~chain_id
    operation
  &gt;&gt;= function
  | Ok (ctxt, operation_results, internal_operations) -&gt; (
      apply_internal_manager_operations
        ctxt
        mode
        ~payer:source
        ~chain_id
        internal_operations
      &gt;&gt;= function
      | (<abbr class="mark-error" title="Patterns on variants are not supported">`Success ctxt</abbr>, internal_operations_results) -&gt; (
          Fees.burn_storage_fees ctxt ~storage_limit ~payer:source
          &gt;&gt;= function
          | Ok ctxt -&gt;
              Lwt.return
                ( <abbr class="mark-error" title="Variants not supported">`Success ctxt</abbr>,
                  Applied operation_results,
                  internal_operations_results )
          | Error errors -&gt;
              Lwt.return
                ( <abbr class="mark-error" title="Variants not supported">`Failure</abbr>,
                  Backtracked (operation_results, Some errors),
                  internal_operations_results ) )
      | (<abbr class="mark-error" title="Patterns on variants are not supported">`Failure</abbr>, internal_operations_results) -&gt;
          Lwt.return
            (<abbr class="mark-error" title="Variants not supported">`Failure</abbr>, Applied operation_results, internal_operations_results)
      )
  | Error errors -&gt;
      Lwt.return (<abbr class="mark-error" title="Variants not supported">`Failure</abbr>, Failed (manager_kind operation, errors), [])

let skipped_operation_result :
    type kind. kind manager_operation -&gt; kind manager_operation_result =
  function
  | operation -&gt; (
    match operation with
    | Reveal _ -&gt;
        Applied
          ( Reveal_result {consumed_gas = Z.zero}
            : kind successful_manager_operation_result )
    | _ -&gt;
        Skipped (manager_kind operation) )

let rec mark_skipped :
    type kind.
    baker:Signature.Public_key_hash.t -&gt;
    Level.t -&gt;
    kind Kind.manager contents_list -&gt;
    kind Kind.manager contents_result_list =
 fun ~baker level -&gt; function
  | Single (Manager_operation {source; fee; operation}) -&gt;
      let source = Contract.implicit_contract source in
      Single_result
        (Manager_operation_result
           {
             balance_updates =
               Delegate.cleanup_balance_updates
                 [ (Contract source, Debited fee);
                   (Fees (baker, level.cycle), Credited fee) ];
             operation_result = skipped_operation_result operation;
             internal_operation_results = [];
           })
  | Cons (Manager_operation {source; fee; operation}, rest) -&gt;
      let source = Contract.implicit_contract source in
      Cons_result
        ( Manager_operation_result
            {
              balance_updates =
                Delegate.cleanup_balance_updates
                  [ (Contract source, Debited fee);
                    (Fees (baker, level.cycle), Credited fee) ];
              operation_result = skipped_operation_result operation;
              internal_operation_results = [];
            },
          mark_skipped ~baker level rest )

let rec precheck_manager_contents_list :
    type kind.
    Alpha_context.t -&gt;
    Chain_id.t -&gt;
    _ Operation.t -&gt;
    kind Kind.manager contents_list -&gt;
    context tzresult Lwt.t =
 fun ctxt chain_id raw_operation contents_list -&gt;
  match contents_list with
  | Single (Manager_operation _ as op) -&gt;
      precheck_manager_contents ctxt chain_id raw_operation op
  | Cons ((Manager_operation _ as op), rest) -&gt;
      precheck_manager_contents ctxt chain_id raw_operation op
      &gt;&gt;=? fun ctxt -&gt;
      precheck_manager_contents_list ctxt chain_id raw_operation rest

let rec <abbr class="mark-error" title="Polymorphic variant types are not handled">apply_manager_contents_list_rec</abbr> :
    type kind.
    Alpha_context.t -&gt;
    Script_ir_translator.unparsing_mode -&gt;
    public_key_hash -&gt;
    Chain_id.t -&gt;
    kind Kind.manager contents_list -&gt;
    ([`Success of context | `Failure] * kind Kind.manager contents_result_list)
    Lwt.t =
 fun ctxt mode baker chain_id contents_list -&gt;
  let level = Level.current ctxt in
  match contents_list with
  | Single (Manager_operation {source; fee; _} as op) -&gt;
      let source = Contract.implicit_contract source in
      apply_manager_contents ctxt mode chain_id op
      &gt;&gt;= fun (ctxt_result, operation_result, internal_operation_results) -&gt;
      let result =
        Manager_operation_result
          {
            balance_updates =
              Delegate.cleanup_balance_updates
                [ (Contract source, Debited fee);
                  (Fees (baker, level.cycle), Credited fee) ];
            operation_result;
            internal_operation_results;
          }
      in
      Lwt.return (ctxt_result, Single_result result)
  | Cons ((Manager_operation {source; fee; _} as op), rest) -&gt; (
      let source = Contract.implicit_contract source in
      apply_manager_contents ctxt mode chain_id op
      &gt;&gt;= function
      | (<abbr class="mark-error" title="Patterns on variants are not supported">`Failure</abbr>, operation_result, internal_operation_results) -&gt;
          let result =
            Manager_operation_result
              {
                balance_updates =
                  Delegate.cleanup_balance_updates
                    [ (Contract source, Debited fee);
                      (Fees (baker, level.cycle), Credited fee) ];
                operation_result;
                internal_operation_results;
              }
          in
          Lwt.return
            (<abbr class="mark-error" title="Variants not supported">`Failure</abbr>, Cons_result (result, mark_skipped ~baker level rest))
      | (<abbr class="mark-error" title="Patterns on variants are not supported">`Success ctxt</abbr>, operation_result, internal_operation_results) -&gt;
          let result =
            Manager_operation_result
              {
                balance_updates =
                  Delegate.cleanup_balance_updates
                    [ (Contract source, Debited fee);
                      (Fees (baker, level.cycle), Credited fee) ];
                operation_result;
                internal_operation_results;
              }
          in
          apply_manager_contents_list_rec ctxt mode baker chain_id rest
          &gt;&gt;= fun (ctxt_result, results) -&gt;
          Lwt.return (ctxt_result, Cons_result (result, results)) )

let mark_backtracked results =
  <abbr class="mark-error" title="Mutually recursive definition are only handled at top-level">let rec mark_contents_list :
      type kind.
      kind Kind.manager contents_result_list -&gt;
      kind Kind.manager contents_result_list = function
    | Single_result (Manager_operation_result op) -&gt;
        Single_result
          (Manager_operation_result
             {
               balance_updates = op.balance_updates;
               operation_result =
                 mark_manager_operation_result op.operation_result;
               internal_operation_results =
                 List.map
                   mark_internal_operation_results
                   op.internal_operation_results;
             })
    | Cons_result (Manager_operation_result op, rest) -&gt;
        Cons_result
          ( Manager_operation_result
              {
                balance_updates = op.balance_updates;
                operation_result =
                  mark_manager_operation_result op.operation_result;
                internal_operation_results =
                  List.map
                    mark_internal_operation_results
                    op.internal_operation_results;
              },
            mark_contents_list rest )
  and mark_internal_operation_results
      (Internal_operation_result (kind, result)) =
    Internal_operation_result (kind, mark_manager_operation_result result)
  and mark_manager_operation_result :
      type kind. kind manager_operation_result -&gt; kind manager_operation_result
      = function
    | (Failed _ | Skipped _ | Backtracked _) as result -&gt;
        result
    | Applied (Reveal_result _) as result -&gt;
        result
    | Applied result -&gt;
        Backtracked (result, None)
  in
  mark_contents_list results</abbr>

let apply_manager_contents_list ctxt mode baker chain_id contents_list =
  apply_manager_contents_list_rec ctxt mode baker chain_id contents_list
  &gt;&gt;= fun (ctxt_result, results) -&gt;
  match ctxt_result with
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Failure</abbr> -&gt;
      Lwt.return (ctxt (* backtracked *), mark_backtracked results)
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Success ctxt</abbr> -&gt;
      Big_map.cleanup_temporary ctxt &gt;&gt;= fun ctxt -&gt; Lwt.return (ctxt, results)

let apply_contents_list (type kind) ctxt chain_id mode pred_block baker
    (operation : kind operation) (contents_list : kind contents_list) :
    (context * kind contents_result_list) tzresult Lwt.t =
  match contents_list with
  | Single (Endorsement {level}) -&gt;
      let block = operation.shell.branch in
      fail_unless
        (Block_hash.equal block pred_block)
        <abbr class="mark-error" title="Values of extensible types are not handled">(Wrong_endorsement_predecessor (pred_block, block))</abbr>
      &gt;&gt;=? fun () -&gt;
      let current_level = (Level.current ctxt).level in
      fail_unless
        Raw_level.(succ level = current_level)
        <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_endorsement_level</abbr>
      &gt;&gt;=? fun () -&gt;
      Baking.check_endorsement_rights ctxt chain_id operation
      &gt;&gt;=? fun (delegate, slots, used) -&gt;
      if used then fail <abbr class="mark-error" title="Values of extensible types are not handled">(Duplicate_endorsement delegate)</abbr>
      else
        let ctxt = record_endorsement ctxt delegate in
        let gap = List.length slots in
        Lwt.return
          Tez.(Constants.endorsement_security_deposit ctxt *? Int64.of_int gap)
        &gt;&gt;=? fun deposit -&gt;
        Delegate.freeze_deposit ctxt delegate deposit
        &gt;&gt;=? fun ctxt -&gt;
        Global.get_block_priority ctxt
        &gt;&gt;=? fun block_priority -&gt;
        Baking.endorsing_reward ctxt ~block_priority gap
        &gt;&gt;=? fun reward -&gt;
        Delegate.freeze_rewards ctxt delegate reward
        &gt;&gt;=? fun ctxt -&gt;
        let level = Level.from_raw ctxt level in
        return
          ( ctxt,
            Single_result
              (Endorsement_result
                 {
                   balance_updates =
                     Delegate.cleanup_balance_updates
                       [ ( Contract (Contract.implicit_contract delegate),
                           Debited deposit );
                         (Deposits (delegate, level.cycle), Credited deposit);
                         (Rewards (delegate, level.cycle), Credited reward) ];
                   delegate;
                   slots;
                 }) )
  | Single (Seed_nonce_revelation {level; nonce}) -&gt;
      let level = Level.from_raw ctxt level in
      Nonce.reveal ctxt level nonce
      &gt;&gt;=? fun ctxt -&gt;
      let seed_nonce_revelation_tip =
        Constants.seed_nonce_revelation_tip ctxt
      in
      add_rewards ctxt seed_nonce_revelation_tip
      &gt;&gt;=? fun ctxt -&gt;
      return
        ( ctxt,
          Single_result
            (Seed_nonce_revelation_result
               [ ( Rewards (baker, level.cycle),
                   Credited seed_nonce_revelation_tip ) ]) )
  | Single (Double_endorsement_evidence {op1; op2}) -&gt; (
    match (op1.protocol_data.contents, op2.protocol_data.contents) with
    | (Single (Endorsement e1), Single (Endorsement e2))
      when Raw_level.(e1.level = e2.level)
           &amp;&amp; not (Block_hash.equal op1.shell.branch op2.shell.branch) -&gt;
        let level = Level.from_raw ctxt e1.level in
        let oldest_level = Level.last_allowed_fork_level ctxt in
        fail_unless
          Level.(level &lt; Level.current ctxt)
          <abbr class="mark-error" title="Values of extensible types are not handled">(Too_early_double_endorsement_evidence
             {level = level.level; current = (Level.current ctxt).level})</abbr>
        &gt;&gt;=? fun () -&gt;
        fail_unless
          Raw_level.(oldest_level &lt;= level.level)
          <abbr class="mark-error" title="Values of extensible types are not handled">(Outdated_double_endorsement_evidence
             {level = level.level; last = oldest_level})</abbr>
        &gt;&gt;=? fun () -&gt;
        Baking.check_endorsement_rights ctxt chain_id op1
        &gt;&gt;=? fun (delegate1, _, _) -&gt;
        Baking.check_endorsement_rights ctxt chain_id op2
        &gt;&gt;=? fun (delegate2, _, _) -&gt;
        fail_unless
          (Signature.Public_key_hash.equal delegate1 delegate2)
          <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_double_endorsement_evidence {delegate1; delegate2})</abbr>
        &gt;&gt;=? fun () -&gt;
        Delegate.has_frozen_balance ctxt delegate1 level.cycle
        &gt;&gt;=? fun valid -&gt;
        fail_unless valid <abbr class="mark-error" title="Values of extensible types are not handled">Unrequired_double_endorsement_evidence</abbr>
        &gt;&gt;=? fun () -&gt;
        Delegate.punish ctxt delegate1 level.cycle
        &gt;&gt;=? fun (ctxt, balance) -&gt;
        Lwt.return Tez.(balance.deposit +? balance.fees)
        &gt;&gt;=? fun burned -&gt;
        let reward =
          match Tez.(burned /? 2L) with Ok v -&gt; v | Error _ -&gt; Tez.zero
        in
        add_rewards ctxt reward
        &gt;&gt;=? fun ctxt -&gt;
        let current_cycle = (Level.current ctxt).cycle in
        return
          ( ctxt,
            Single_result
              (Double_endorsement_evidence_result
                 (Delegate.cleanup_balance_updates
                    [ ( Deposits (delegate1, level.cycle),
                        Debited balance.deposit );
                      (Fees (delegate1, level.cycle), Debited balance.fees);
                      ( Rewards (delegate1, level.cycle),
                        Debited balance.rewards );
                      (Rewards (baker, current_cycle), Credited reward) ])) )
    | (_, _) -&gt;
        fail <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_double_endorsement_evidence</abbr> )
  | Single (Double_baking_evidence {bh1; bh2}) -&gt;
      let hash1 = Block_header.hash bh1 in
      let hash2 = Block_header.hash bh2 in
      fail_unless
        ( Compare.Int32.(bh1.shell.level = bh2.shell.level)
        &amp;&amp; not (Block_hash.equal hash1 hash2) )
        <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_double_baking_evidence
           {hash1; level1 = bh1.shell.level; hash2; level2 = bh2.shell.level})</abbr>
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Raw_level.of_int32 bh1.shell.level)
      &gt;&gt;=? fun raw_level -&gt;
      let oldest_level = Level.last_allowed_fork_level ctxt in
      fail_unless
        Raw_level.(raw_level &lt; (Level.current ctxt).level)
        <abbr class="mark-error" title="Values of extensible types are not handled">(Too_early_double_baking_evidence
           {level = raw_level; current = (Level.current ctxt).level})</abbr>
      &gt;&gt;=? fun () -&gt;
      fail_unless
        Raw_level.(oldest_level &lt;= raw_level)
        <abbr class="mark-error" title="Values of extensible types are not handled">(Outdated_double_baking_evidence
           {level = raw_level; last = oldest_level})</abbr>
      &gt;&gt;=? fun () -&gt;
      let level = Level.from_raw ctxt raw_level in
      Roll.baking_rights_owner
        ctxt
        level
        ~priority:bh1.protocol_data.contents.priority
      &gt;&gt;=? fun delegate1 -&gt;
      Baking.check_signature bh1 chain_id delegate1
      &gt;&gt;=? fun () -&gt;
      Roll.baking_rights_owner
        ctxt
        level
        ~priority:bh2.protocol_data.contents.priority
      &gt;&gt;=? fun delegate2 -&gt;
      Baking.check_signature bh2 chain_id delegate2
      &gt;&gt;=? fun () -&gt;
      fail_unless
        (Signature.Public_key.equal delegate1 delegate2)
        <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_double_baking_evidence
           {
             delegate1 = Signature.Public_key.hash delegate1;
             delegate2 = Signature.Public_key.hash delegate2;
           })</abbr>
      &gt;&gt;=? fun () -&gt;
      let delegate = Signature.Public_key.hash delegate1 in
      Delegate.has_frozen_balance ctxt delegate level.cycle
      &gt;&gt;=? fun valid -&gt;
      fail_unless valid <abbr class="mark-error" title="Values of extensible types are not handled">Unrequired_double_baking_evidence</abbr>
      &gt;&gt;=? fun () -&gt;
      Delegate.punish ctxt delegate level.cycle
      &gt;&gt;=? fun (ctxt, balance) -&gt;
      Lwt.return Tez.(balance.deposit +? balance.fees)
      &gt;&gt;=? fun burned -&gt;
      let reward =
        match Tez.(burned /? 2L) with Ok v -&gt; v | Error _ -&gt; Tez.zero
      in
      add_rewards ctxt reward
      &gt;&gt;=? fun ctxt -&gt;
      let current_cycle = (Level.current ctxt).cycle in
      return
        ( ctxt,
          Single_result
            (Double_baking_evidence_result
               (Delegate.cleanup_balance_updates
                  [ (Deposits (delegate, level.cycle), Debited balance.deposit);
                    (Fees (delegate, level.cycle), Debited balance.fees);
                    (Rewards (delegate, level.cycle), Debited balance.rewards);
                    (Rewards (baker, current_cycle), Credited reward) ])) )
  | Single (Activate_account {id = pkh; activation_code}) -&gt; (
      let blinded_pkh =
        Blinded_public_key_hash.of_ed25519_pkh activation_code pkh
      in
      Commitment.get_opt ctxt blinded_pkh
      &gt;&gt;=? function
      | None -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_activation {pkh})</abbr>
      | Some amount -&gt;
          Commitment.delete ctxt blinded_pkh
          &gt;&gt;=? fun ctxt -&gt;
          let contract =
            Contract.implicit_contract (Signature.Ed25519Hash pkh)
          in
          Contract.(credit ctxt contract amount)
          &gt;&gt;=? fun ctxt -&gt;
          return
            ( ctxt,
              Single_result
                (Activate_account_result [(Contract contract, Credited amount)])
            ) )
  | Single (Proposals {source; period; proposals}) -&gt;
      Roll.delegate_pubkey ctxt source
      &gt;&gt;=? fun delegate -&gt;
      Operation.check_signature delegate chain_id operation
      &gt;&gt;=? fun () -&gt;
      let level = Level.current ctxt in
      fail_unless
        Voting_period.(level.voting_period = period)
        <abbr class="mark-error" title="Values of extensible types are not handled">(Wrong_voting_period (level.voting_period, period))</abbr>
      &gt;&gt;=? fun () -&gt;
      Amendment.record_proposals ctxt source proposals
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, Single_result Proposals_result)
  | Single (Ballot {source; period; proposal; ballot}) -&gt;
      Roll.delegate_pubkey ctxt source
      &gt;&gt;=? fun delegate -&gt;
      Operation.check_signature delegate chain_id operation
      &gt;&gt;=? fun () -&gt;
      let level = Level.current ctxt in
      fail_unless
        Voting_period.(level.voting_period = period)
        <abbr class="mark-error" title="Values of extensible types are not handled">(Wrong_voting_period (level.voting_period, period))</abbr>
      &gt;&gt;=? fun () -&gt;
      Amendment.record_ballot ctxt source proposal ballot
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, Single_result Ballot_result)
  | Single (Manager_operation _) as op -&gt;
      precheck_manager_contents_list ctxt chain_id operation op
      &gt;&gt;=? fun ctxt -&gt;
      apply_manager_contents_list ctxt mode baker chain_id op
      &gt;&gt;= fun (ctxt, result) -&gt; return (ctxt, result)
  | Cons (Manager_operation _, _) as op -&gt;
      precheck_manager_contents_list ctxt chain_id operation op
      &gt;&gt;=? fun ctxt -&gt;
      apply_manager_contents_list ctxt mode baker chain_id op
      &gt;&gt;= fun (ctxt, result) -&gt; return (ctxt, result)

let apply_operation ctxt chain_id mode pred_block baker hash operation =
  let ctxt = Contract.init_origination_nonce ctxt hash in
  apply_contents_list
    ctxt
    chain_id
    mode
    pred_block
    baker
    operation
    operation.protocol_data.contents
  &gt;&gt;=? fun (ctxt, result) -&gt;
  let ctxt = Gas.set_unlimited ctxt in
  let ctxt = Contract.unset_origination_nonce ctxt in
  return (ctxt, {contents = result})

let may_snapshot_roll ctxt =
  let level = Alpha_context.Level.current ctxt in
  let blocks_per_roll_snapshot = Constants.blocks_per_roll_snapshot ctxt in
  if
    Compare.Int32.equal
      (Int32.rem level.cycle_position blocks_per_roll_snapshot)
      (Int32.pred blocks_per_roll_snapshot)
  then Alpha_context.Roll.snapshot_rolls ctxt &gt;&gt;=? fun ctxt -&gt; return ctxt
  else return ctxt

let may_start_new_cycle ctxt =
  Baking.dawn_of_a_new_cycle ctxt
  &gt;&gt;=? function
  | None -&gt;
      return (ctxt, [], [])
  | Some last_cycle -&gt;
      Seed.cycle_end ctxt last_cycle
      &gt;&gt;=? fun (ctxt, unrevealed) -&gt;
      Roll.cycle_end ctxt last_cycle
      &gt;&gt;=? fun ctxt -&gt;
      Delegate.cycle_end ctxt last_cycle unrevealed
      &gt;&gt;=? fun (ctxt, update_balances, deactivated) -&gt;
      Bootstrap.cycle_end ctxt last_cycle
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, update_balances, deactivated)

let begin_full_construction ctxt pred_timestamp protocol_data =
  Alpha_context.Global.set_block_priority
    ctxt
    protocol_data.Block_header.priority
  &gt;&gt;=? fun ctxt -&gt;
  Baking.check_baking_rights ctxt protocol_data pred_timestamp
  &gt;&gt;=? fun (delegate_pk, block_delay) -&gt;
  let ctxt = Fitness.increase ctxt in
  match Level.pred ctxt (Level.current ctxt) with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* genesis *)
  | Some pred_level -&gt;
      Baking.endorsement_rights ctxt pred_level
      &gt;&gt;=? fun rights -&gt;
      let ctxt = init_endorsements ctxt rights in
      return (ctxt, protocol_data, delegate_pk, block_delay)

let begin_partial_construction ctxt =
  let ctxt = Fitness.increase ctxt in
  match Level.pred ctxt (Level.current ctxt) with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* genesis *)
  | Some pred_level -&gt;
      Baking.endorsement_rights ctxt pred_level
      &gt;&gt;=? fun rights -&gt;
      let ctxt = init_endorsements ctxt rights in
      return ctxt

let begin_application ctxt chain_id block_header pred_timestamp =
  Alpha_context.Global.set_block_priority
    ctxt
    block_header.Block_header.protocol_data.contents.priority
  &gt;&gt;=? fun ctxt -&gt;
  let current_level = Alpha_context.Level.current ctxt in
  Baking.check_proof_of_work_stamp ctxt block_header
  &gt;&gt;=? fun () -&gt;
  Baking.check_fitness_gap ctxt block_header
  &gt;&gt;=? fun () -&gt;
  Baking.check_baking_rights
    ctxt
    block_header.protocol_data.contents
    pred_timestamp
  &gt;&gt;=? fun (delegate_pk, block_delay) -&gt;
  Baking.check_signature block_header chain_id delegate_pk
  &gt;&gt;=? fun () -&gt;
  let has_commitment =
    match block_header.protocol_data.contents.seed_nonce_hash with
    | None -&gt;
        false
    | Some _ -&gt;
        true
  in
  fail_unless
    Compare.Bool.(has_commitment = current_level.expected_commitment)
    <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_commitment {expected = current_level.expected_commitment})</abbr>
  &gt;&gt;=? fun () -&gt;
  let ctxt = Fitness.increase ctxt in
  match Level.pred ctxt (Level.current ctxt) with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* genesis *)
  | Some pred_level -&gt;
      Baking.endorsement_rights ctxt pred_level
      &gt;&gt;=? fun rights -&gt;
      let ctxt = init_endorsements ctxt rights in
      return (ctxt, delegate_pk, block_delay)

let check_minimum_endorsements ctxt protocol_data block_delay
    included_endorsements =
  let minimum = Baking.minimum_allowed_endorsements ctxt ~block_delay in
  let timestamp = Timestamp.current ctxt in
  fail_unless
    Compare.Int.(included_endorsements &gt;= minimum)
    <abbr class="mark-error" title="Values of extensible types are not handled">(Not_enough_endorsements_for_priority
       {
         required = minimum;
         priority = protocol_data.Block_header.priority;
         endorsements = included_endorsements;
         timestamp;
       })</abbr>

let finalize_application ctxt protocol_data delegate ~block_delay =
  let included_endorsements = included_endorsements ctxt in
  check_minimum_endorsements
    ctxt
    protocol_data
    block_delay
    included_endorsements
  &gt;&gt;=? fun () -&gt;
  let deposit = Constants.block_security_deposit ctxt in
  add_deposit ctxt delegate deposit
  &gt;&gt;=? fun ctxt -&gt;
  Baking.baking_reward
    ctxt
    ~block_priority:protocol_data.priority
    ~included_endorsements
  &gt;&gt;=? fun reward -&gt;
  add_rewards ctxt reward
  &gt;&gt;=? fun ctxt -&gt;
  Signature.Public_key_hash.Map.fold
    (fun delegate deposit ctxt -&gt;
      ctxt &gt;&gt;=? fun ctxt -&gt; Delegate.freeze_deposit ctxt delegate deposit)
    (get_deposits ctxt)
    (return ctxt)
  &gt;&gt;=? fun ctxt -&gt;
  (* end of level (from this point nothing should fail) *)
  let fees = Alpha_context.get_fees ctxt in
  Delegate.freeze_fees ctxt delegate fees
  &gt;&gt;=? fun ctxt -&gt;
  let rewards = Alpha_context.get_rewards ctxt in
  Delegate.freeze_rewards ctxt delegate rewards
  &gt;&gt;=? fun ctxt -&gt;
  ( match protocol_data.Block_header.seed_nonce_hash with
  | None -&gt;
      return ctxt
  | Some nonce_hash -&gt;
      Nonce.record_hash ctxt {nonce_hash; delegate; rewards; fees} )
  &gt;&gt;=? fun ctxt -&gt;
  (* end of cycle *)
  may_snapshot_roll ctxt
  &gt;&gt;=? fun ctxt -&gt;
  may_start_new_cycle ctxt
  &gt;&gt;=? fun (ctxt, balance_updates, deactivated) -&gt;
  Amendment.may_start_new_voting_period ctxt
  &gt;&gt;=? fun ctxt -&gt;
  let cycle = (Level.current ctxt).cycle in
  let balance_updates =
    Delegate.(
      cleanup_balance_updates
        ( [ (Contract (Contract.implicit_contract delegate), Debited deposit);
            (Deposits (delegate, cycle), Credited deposit);
            (Rewards (delegate, cycle), Credited reward) ]
        @ balance_updates ))
  in
  let consumed_gas =
    Z.sub
      (Constants.hard_gas_limit_per_block ctxt)
      (Alpha_context.Gas.block_level ctxt)
  in
  Alpha_context.Vote.get_current_period_kind ctxt
  &gt;&gt;=? fun voting_period_kind -&gt;
  let receipt =
    Apply_results.
      {
        baker = delegate;
        level = Level.current ctxt;
        voting_period_kind;
        nonce_hash = protocol_data.seed_nonce_hash;
        consumed_gas;
        deactivated;
        balance_updates;
      }
  in
  return (ctxt, receipt)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#apply.ml"><code>Apply.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Amendment.
Require Tezos.Apply_results.
Require Tezos.Baking.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Michelson_v1_gas.
Require Tezos.Script_interpreter.
Require Tezos.Script_ir_translator.
Require Tezos.Script_typed_ir.

Import Alpha_context.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Import Apply_results.

Definition apply_manager_operation_content {kind : Set}
  (ctxt : Alpha_context.t) (mode : Script_ir_translator.unparsing_mode)
  (payer : Alpha_context.Contract.t) (source : Alpha_context.Contract.t)
  (chain_id : Chain_id.[S.HASH.t]) (internal : bool)
  (operation : Alpha_context.manager_operation kind)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context *
        Apply_results.successful_manager_operation_result kind *
        list Alpha_context.packed_internal_operation)) :=
  let before_operation := ctxt in
  Error_monad.op_gtgteqquestion (Alpha_context.Contract.must_exist ctxt source)
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      Error_monad.op_gtgteqquestion
        (Lwt.__return
          (Alpha_context.Gas.consume ctxt
            Michelson_v1_gas.Cost_of.manager_operation))
        (fun ctxt =&gt;
          match operation with
          | Alpha_context.Reveal _ =&gt;
            Error_monad.__return
              (ctxt,
                (Apply_results.Reveal_result
                  {|
                    Apply_results.successful_manager_operation_result.Reveal_result.consumed_gas :=
                      Alpha_context.Gas.consumed before_operation ctxt |}), [])
          |
            Alpha_context.Transaction {|
              Alpha_context.manager_operation.Transaction.amount := amount;
                Alpha_context.manager_operation.Transaction.parameters :=
                  parameters;
                Alpha_context.manager_operation.Transaction.entrypoint :=
                  entrypoint;
                Alpha_context.manager_operation.Transaction.destination :=
                  destination
                |} =&gt;
            Error_monad.op_gtgteqquestion
              (Alpha_context.Contract.spend ctxt source amount)
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  match Alpha_context.Contract.is_implicit destination with
                  | None =&gt; Error_monad.__return (ctxt, [], false)
                  | Some _ =&gt;
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Contract.allocated ctxt destination)
                      (fun function_parameter =&gt;
                        match function_parameter with
                        | true =&gt; Error_monad.__return (ctxt, [], false)
                        | false =&gt;
                          Error_monad.op_gtgteqquestion
                            (Alpha_context.Fees.origination_burn ctxt)
                            (fun function_parameter =&gt;
                              let '(ctxt, origination_burn) :=
                                function_parameter in
                              Error_monad.__return
                                (ctxt,
                                  (cons
                                    ((Alpha_context.Delegate.Contract payer),
                                      (Alpha_context.Delegate.Debited
                                        origination_burn)) []), true))
                        end)
                  end
                  (fun function_parameter =&gt;
                    let
                      '(ctxt, maybe_burn_balance_update,
                        allocated_destination_contract) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Contract.credit ctxt destination amount)
                      (fun ctxt =&gt;
                        Error_monad.op_gtgteqquestion
                          (Alpha_context.Contract.get_script ctxt destination)
                          (fun function_parameter =&gt;
                            let '(ctxt, script) := function_parameter in
                            match script with
                            | None =&gt;
                              Error_monad.op_gtgteqquestion
                                (Error_monad.op_gtgteqquestion
                                  match entrypoint with
                                  | &quot;default&quot; % string =&gt;
                                    Error_monad.__return tt
                                  | entrypoint =&gt;
                                    Error_monad.fail extensible_type_value
                                  end
                                  (fun function_parameter =&gt;
                                    let 'tt := function_parameter in
                                    Error_monad.op_gtgteqquestion
                                      (Alpha_context.Script.force_decode ctxt
                                        parameters)
                                      (fun function_parameter =&gt;
                                        let '(arg, ctxt) := function_parameter
                                          in
                                        let cost_arg :=
                                          Alpha_context.Script.deserialized_cost
                                            arg in
                                        Error_monad.op_gtgteqquestion
                                          (Lwt.__return
                                            (Alpha_context.Gas.consume ctxt
                                              cost_arg))
                                          (fun ctxt =&gt;
                                            match Micheline.root arg with
                                            |
                                              Micheline.Prim _
                                                Alpha_context.Script.D_Unit [] _
                                              =&gt; Error_monad.__return ctxt
                                            | _ =&gt;
                                              Error_monad.fail
                                                extensible_type_value
                                            end))))
                                (fun ctxt =&gt;
                                  let __result_value :=
                                    Apply_results.Transaction_result
                                      {|
                                        Apply_results.successful_manager_operation_result.Transaction_result.storage :=
                                          None;
                                        Apply_results.successful_manager_operation_result.Transaction_result.big_map_diff :=
                                          None;
                                        Apply_results.successful_manager_operation_result.Transaction_result.balance_updates :=
                                          Alpha_context.Delegate.cleanup_balance_updates
                                            (Pervasives.op_at
                                              (cons
                                                ((Alpha_context.Delegate.Contract
                                                  source),
                                                  (Alpha_context.Delegate.Debited
                                                    amount))
                                                (cons
                                                  ((Alpha_context.Delegate.Contract
                                                    destination),
                                                    (Alpha_context.Delegate.Credited
                                                      amount)) []))
                                              maybe_burn_balance_update);
                                        Apply_results.successful_manager_operation_result.Transaction_result.originated_contracts :=
                                          [];
                                        Apply_results.successful_manager_operation_result.Transaction_result.consumed_gas :=
                                          Alpha_context.Gas.consumed
                                            before_operation ctxt;
                                        Apply_results.successful_manager_operation_result.Transaction_result.storage_size :=
                                          Z.zero;
                                        Apply_results.successful_manager_operation_result.Transaction_result.paid_storage_size_diff :=
                                          Z.zero;
                                        Apply_results.successful_manager_operation_result.Transaction_result.allocated_destination_contract :=
                                          allocated_destination_contract |} in
                                  Error_monad.__return
                                    (ctxt, __result_value, []))
                            | Some script =&gt;
                              Error_monad.op_gtgteqquestion
                                (Alpha_context.Script.force_decode ctxt
                                  parameters)
                                (fun function_parameter =&gt;
                                  let '(parameter, ctxt) := function_parameter
                                    in
                                  let cost_parameter :=
                                    Alpha_context.Script.deserialized_cost
                                      parameter in
                                  Error_monad.op_gtgteqquestion
                                    (Lwt.__return
                                      (Alpha_context.Gas.consume ctxt
                                        cost_parameter))
                                    (fun ctxt =&gt;
                                      let step_constants :=
                                        {|
                                          Script_interpreter.step_constants.source :=
                                            source;
                                          Script_interpreter.step_constants.payer :=
                                            payer;
                                          Script_interpreter.step_constants.self :=
                                            destination;
                                          Script_interpreter.step_constants.amount :=
                                            amount;
                                          Script_interpreter.step_constants.chain_id :=
                                            chain_id |} in
                                      Error_monad.op_gtgteqquestion
                                        (Script_interpreter.execute ctxt mode
                                          step_constants script entrypoint
                                          parameter)
                                        (fun function_parameter =&gt;
                                          let '{|
                                            Script_interpreter.execution_result.ctxt := ctxt;
                                              Script_interpreter.execution_result.storage
                                                :=
                                                storage;
                                              Script_interpreter.execution_result.big_map_diff
                                                :=
                                                big_map_diff;
                                              Script_interpreter.execution_result.operations
                                                :=
                                                operations
                                              |} := function_parameter in
                                          Error_monad.op_gtgteqquestion
                                            (Alpha_context.Contract.update_script_storage
                                              ctxt destination storage
                                              big_map_diff)
                                            (fun ctxt =&gt;
                                              Error_monad.op_gtgteqquestion
                                                (Alpha_context.Fees.record_paid_storage_space
                                                  ctxt destination)
                                                (fun function_parameter =&gt;
                                                  let
                                                    '(ctxt, new_size,
                                                      paid_storage_size_diff,
                                                      fees) :=
                                                    function_parameter in
                                                  Error_monad.op_gtgteqquestion
                                                    (Alpha_context.Contract.originated_from_current_nonce
                                                      before_operation ctxt)
                                                    (fun originated_contracts =&gt;
                                                      let __result_value :=
                                                        Apply_results.Transaction_result
                                                          {|
                                                            Apply_results.successful_manager_operation_result.Transaction_result.storage :=
                                                              Some storage;
                                                            Apply_results.successful_manager_operation_result.Transaction_result.big_map_diff :=
                                                              big_map_diff;
                                                            Apply_results.successful_manager_operation_result.Transaction_result.balance_updates :=
                                                              Alpha_context.Delegate.cleanup_balance_updates
                                                                (cons
                                                                  ((Alpha_context.Delegate.Contract
                                                                    payer),
                                                                    (Alpha_context.Delegate.Debited
                                                                      fees))
                                                                  (cons
                                                                    ((Alpha_context.Delegate.Contract
                                                                      source),
                                                                      (Alpha_context.Delegate.Debited
                                                                        amount))
                                                                    (cons
                                                                      ((Alpha_context.Delegate.Contract
                                                                        destination),
                                                                        (Alpha_context.Delegate.Credited
                                                                          amount))
                                                                      [])));
                                                            Apply_results.successful_manager_operation_result.Transaction_result.originated_contracts :=
                                                              originated_contracts;
                                                            Apply_results.successful_manager_operation_result.Transaction_result.consumed_gas :=
                                                              Alpha_context.Gas.consumed
                                                                before_operation
                                                                ctxt;
                                                            Apply_results.successful_manager_operation_result.Transaction_result.storage_size :=
                                                              new_size;
                                                            Apply_results.successful_manager_operation_result.Transaction_result.paid_storage_size_diff :=
                                                              paid_storage_size_diff;
                                                            Apply_results.successful_manager_operation_result.Transaction_result.allocated_destination_contract :=
                                                              allocated_destination_contract
                                                            |} in
                                                      Error_monad.__return
                                                        (ctxt, __result_value,
                                                          operations)))))))
                            end))))
          |
            Alpha_context.Origination {|
              Alpha_context.manager_operation.Origination.delegate := delegate;
                Alpha_context.manager_operation.Origination.script := script;
                Alpha_context.manager_operation.Origination.credit := credit;
                Alpha_context.manager_operation.Origination.preorigination :=
                  preorigination
                |} =&gt;
            Error_monad.op_gtgteqquestion
              (Alpha_context.Script.force_decode ctxt
                (Alpha_context.Script.t.storage script))
              (fun function_parameter =&gt;
                let '(unparsed_storage, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt
                      (Alpha_context.Script.deserialized_cost unparsed_storage)))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Script.force_decode ctxt
                        (Alpha_context.Script.t.code script))
                      (fun function_parameter =&gt;
                        let '(unparsed_code, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (Lwt.__return
                            (Alpha_context.Gas.consume ctxt
                              (Alpha_context.Script.deserialized_cost
                                unparsed_code)))
                          (fun ctxt =&gt;
                            Error_monad.op_gtgteqquestion
                              (Script_ir_translator.parse_script None ctxt false
                                script)
                              (fun function_parameter =&gt;
                                let
                                  '(Script_ir_translator.Ex_script parsed_script,
                                    ctxt) := function_parameter in
                                Error_monad.op_gtgteqquestion
                                  (Script_ir_translator.collect_big_maps ctxt
                                    (Script_typed_ir.script.storage_type
                                      parsed_script)
                                    (Script_typed_ir.script.storage
                                      parsed_script))
                                  (fun function_parameter =&gt;
                                    let '(to_duplicate, ctxt) :=
                                      function_parameter in
                                    let to_update :=
                                      Script_ir_translator.no_big_map_id in
                                    Error_monad.op_gtgteqquestion
                                      (Script_ir_translator.extract_big_map_diff
                                        ctxt Script_ir_translator.Optimized
                                        false to_duplicate to_update
                                        (Script_typed_ir.script.storage_type
                                          parsed_script)
                                        (Script_typed_ir.script.storage
                                          parsed_script))
                                      (fun function_parameter =&gt;
                                        let '(storage, big_map_diff, ctxt) :=
                                          function_parameter in
                                        Error_monad.op_gtgteqquestion
                                          (Script_ir_translator.unparse_data
                                            ctxt Script_ir_translator.Optimized
                                            (Script_typed_ir.script.storage_type
                                              parsed_script) storage)
                                          (fun function_parameter =&gt;
                                            let '(storage, ctxt) :=
                                              function_parameter in
                                            let storage :=
                                              Alpha_context.Script.lazy_expr
                                                (Micheline.strip_locations
                                                  storage) in
                                            let script :=
                                              (* ‚ùå Record substitution not handled *)
                                              record_substitution in
                                            Error_monad.op_gtgteqquestion
                                              (Alpha_context.Contract.spend ctxt
                                                source credit)
                                              (fun ctxt =&gt;
                                                Error_monad.op_gtgteqquestion
                                                  match preorigination with
                                                  | Some contract =&gt;
                                                    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
                                                    (* ‚ùå instruction_sequence &quot;;&quot; *)
                                                    Error_monad.__return
                                                      (ctxt, contract)
                                                  | None =&gt;
                                                    Alpha_context.Contract.fresh_contract_from_current_nonce
                                                      ctxt
                                                  end
                                                  (fun function_parameter =&gt;
                                                    let '(ctxt, contract) :=
                                                      function_parameter in
                                                    Error_monad.op_gtgteqquestion
                                                      (Alpha_context.Contract.originate
                                                        ctxt contract credit
                                                        (script, big_map_diff)
                                                        delegate)
                                                      (fun ctxt =&gt;
                                                        Error_monad.op_gtgteqquestion
                                                          (Alpha_context.Fees.origination_burn
                                                            ctxt)
                                                          (fun
                                                            function_parameter
                                                            =&gt;
                                                            let
                                                              '(ctxt,
                                                                origination_burn) :=
                                                              function_parameter
                                                              in
                                                            Error_monad.op_gtgteqquestion
                                                              (Alpha_context.Fees.record_paid_storage_space
                                                                ctxt contract)
                                                              (fun
                                                                function_parameter
                                                                =&gt;
                                                                let
                                                                  '(ctxt, size,
                                                                    paid_storage_size_diff,
                                                                    fees) :=
                                                                  function_parameter
                                                                  in
                                                                let
                                                                  __result_value :=
                                                                  Apply_results.Origination_result
                                                                    {|
                                                                      Apply_results.successful_manager_operation_result.Origination_result.big_map_diff :=
                                                                        big_map_diff;
                                                                      Apply_results.successful_manager_operation_result.Origination_result.balance_updates :=
                                                                        Alpha_context.Delegate.cleanup_balance_updates
                                                                          (cons
                                                                            ((Alpha_context.Delegate.Contract
                                                                              payer),
                                                                              (Alpha_context.Delegate.Debited
                                                                                fees))
                                                                            (cons
                                                                              ((Alpha_context.Delegate.Contract
                                                                                payer),
                                                                                (Alpha_context.Delegate.Debited
                                                                                  origination_burn))
                                                                              (cons
                                                                                ((Alpha_context.Delegate.Contract
                                                                                  source),
                                                                                  (Alpha_context.Delegate.Debited
                                                                                    credit))
                                                                                (cons
                                                                                  ((Alpha_context.Delegate.Contract
                                                                                    contract),
                                                                                    (Alpha_context.Delegate.Credited
                                                                                      credit))
                                                                                  []))));
                                                                      Apply_results.successful_manager_operation_result.Origination_result.originated_contracts :=
                                                                        cons
                                                                          contract
                                                                          [];
                                                                      Apply_results.successful_manager_operation_result.Origination_result.consumed_gas :=
                                                                        Alpha_context.Gas.consumed
                                                                          before_operation
                                                                          ctxt;
                                                                      Apply_results.successful_manager_operation_result.Origination_result.storage_size :=
                                                                        size;
                                                                      Apply_results.successful_manager_operation_result.Origination_result.paid_storage_size_diff :=
                                                                        paid_storage_size_diff
                                                                      |} in
                                                                Error_monad.__return
                                                                  (ctxt,
                                                                    __result_value,
                                                                    []))))))))))))))
          | Alpha_context.Delegation delegate =&gt;
            Error_monad.op_gtgteqquestion
              (Alpha_context.Delegate.set ctxt source delegate)
              (fun ctxt =&gt;
                Error_monad.__return
                  (ctxt,
                    (Apply_results.Delegation_result
                      {|
                        Apply_results.successful_manager_operation_result.Delegation_result.consumed_gas :=
                          Alpha_context.Gas.consumed before_operation ctxt |}),
                    []))
          end)).

Definition apply_internal_manager_operations
  (ctxt : Alpha_context.context) (mode : Script_ir_translator.unparsing_mode)
  (payer : Alpha_context.Contract.t) (chain_id : Chain_id.[S.HASH.t])
  (ops : list Alpha_context.packed_internal_operation)
  : Lwt.t
    (((* `Success *) Alpha_context.context + (* `Failure *) unit) *
      list Apply_results.packed_internal_operation_result) :=
  let fix apply
    (ctxt : Alpha_context.context)
    (applied : list Apply_results.packed_internal_operation_result)
    (worklist : list Alpha_context.packed_internal_operation) {struct ctxt}
    : Lwt.t
      ((* `Success *) Alpha_context.context *
        list Apply_results.packed_internal_operation_result) :=
    match worklist with
    | [] =&gt;
      Lwt.__return
        ((* ‚ùå Variants not supported *)
        (* ‚ùå `Success *)
        ctxt, (List.rev applied))
    |
      cons
        (Alpha_context.Internal_operation
          ({|
            Alpha_context.internal_operation.source := source;
              Alpha_context.internal_operation.operation := operation;
              Alpha_context.internal_operation.nonce := nonce
              |} as op)) rest =&gt;
      Error_monad.op_gtgteq
        (if Alpha_context.internal_nonce_already_recorded ctxt nonce then
          Error_monad.fail extensible_type_value
        else
          let ctxt := Alpha_context.record_internal_nonce ctxt nonce in
          apply_manager_operation_content ctxt mode payer source chain_id true
            operation)
        (fun function_parameter =&gt;
          match function_parameter with
          | Pervasives.Error errors =&gt;
            let __result_value :=
              Apply_results.Internal_operation_result op
                (Apply_results.Failed
                  (Alpha_context.manager_kind
                    (Alpha_context.internal_operation.operation op)) errors) in
            let skipped :=
              List.rev_map
                (fun function_parameter =&gt;
                  let 'Alpha_context.Internal_operation op := function_parameter
                    in
                  Apply_results.Internal_operation_result op
                    (Apply_results.Skipped
                      (Alpha_context.manager_kind
                        (Alpha_context.internal_operation.operation op)))) rest
              in
            Lwt.__return
              ((* ‚ùå Variants not supported *)
              (* ‚ùå `Failure *)
              tt,
                (List.rev
                  (Pervasives.op_at skipped (cons __result_value applied))))
          | Pervasives.Ok (ctxt, __result_value, emitted) =&gt;
            apply ctxt
              (cons
                (Apply_results.Internal_operation_result op
                  (Apply_results.Applied __result_value)) applied)
              (Pervasives.op_at rest emitted)
          end)
    end in
  apply ctxt [] ops.

Definition precheck_manager_contents {A B : Set}
  (ctxt : Alpha_context.context) (chain_id : Chain_id.[S.HASH.t])
  (raw_operation : Alpha_context.operation A)
  (op : Alpha_context.contents (Alpha_context.Kind.manager B))
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let
    'Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.source := source;
        Alpha_context.contents.Manager_operation.fee := fee;
        Alpha_context.contents.Manager_operation.counter := counter;
        Alpha_context.contents.Manager_operation.operation := operation;
        Alpha_context.contents.Manager_operation.gas_limit := gas_limit;
        Alpha_context.contents.Manager_operation.storage_limit := storage_limit
        |} := op in
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Alpha_context.Gas.check_limit ctxt gas_limit))
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      let ctxt := Alpha_context.Gas.set_limit ctxt gas_limit in
      Error_monad.op_gtgteqquestion
        (Lwt.__return
          (Alpha_context.Fees.check_storage_limit ctxt storage_limit))
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgteqquestion
            (Alpha_context.Contract.must_be_allocated ctxt
              (Alpha_context.Contract.implicit_contract source))
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion
                (Alpha_context.Contract.check_counter_increment ctxt source
                  counter)
                (fun function_parameter =&gt;
                  let 'tt := function_parameter in
                  Error_monad.op_gtgteqquestion
                    match operation with
                    | Alpha_context.Reveal pk =&gt;
                      Alpha_context.Contract.reveal_manager_key ctxt source pk
                    |
                      Alpha_context.Transaction {|
                        Alpha_context.manager_operation.Transaction.parameters := parameters
                          |} =&gt;
                      Error_monad.op_gtgteqquestion
                        (Pervasives.op_atat Lwt.__return
                          (Pervasives.op_atat
                            (Error_monad.record_trace extensible_type_value)
                            (Alpha_context.Gas.check_enough ctxt
                              (Alpha_context.Script.minimal_deserialize_cost
                                parameters))))
                        (fun function_parameter =&gt;
                          let 'tt := function_parameter in
                          Error_monad.op_gtgtpipequestion
                            (Pervasives.op_atat
                              (Error_monad.trace extensible_type_value)
                              (Alpha_context.Script.force_decode ctxt parameters))
                            (fun function_parameter =&gt;
                              let '(_arg, ctxt) := function_parameter in
                              ctxt))
                    |
                      Alpha_context.Origination {|
                        Alpha_context.manager_operation.Origination.script := script
                          |} =&gt;
                      Error_monad.op_gtgteqquestion
                        (Pervasives.op_atat Lwt.__return
                          (Pervasives.op_atat
                            (Error_monad.record_trace extensible_type_value)
                            (Error_monad.op_gtgtquestion
                              (Alpha_context.Gas.consume ctxt
                                (Alpha_context.Script.minimal_deserialize_cost
                                  (Alpha_context.Script.t.code script)))
                              (fun ctxt =&gt;
                                Alpha_context.Gas.check_enough ctxt
                                  (Alpha_context.Script.minimal_deserialize_cost
                                    (Alpha_context.Script.t.storage script))))))
                        (fun function_parameter =&gt;
                          let 'tt := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (Pervasives.op_atat
                              (Error_monad.trace extensible_type_value)
                              (Alpha_context.Script.force_decode ctxt
                                (Alpha_context.Script.t.code script)))
                            (fun function_parameter =&gt;
                              let '(_code, ctxt) := function_parameter in
                              Error_monad.op_gtgtpipequestion
                                (Pervasives.op_atat
                                  (Error_monad.trace extensible_type_value)
                                  (Alpha_context.Script.force_decode ctxt
                                    (Alpha_context.Script.t.storage script)))
                                (fun function_parameter =&gt;
                                  let '(_storage, ctxt) := function_parameter in
                                  ctxt)))
                    | _ =&gt; Error_monad.__return ctxt
                    end
                    (fun ctxt =&gt;
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Contract.get_manager_key ctxt source)
                        (fun public_key =&gt;
                          Error_monad.op_gtgteqquestion
                            (Alpha_context.Operation.check_signature public_key
                              chain_id raw_operation)
                            (fun function_parameter =&gt;
                              let 'tt := function_parameter in
                              Error_monad.op_gtgteqquestion
                                (Alpha_context.Contract.increment_counter ctxt
                                  source)
                                (fun ctxt =&gt;
                                  Error_monad.op_gtgteqquestion
                                    (Alpha_context.Contract.spend ctxt
                                      (Alpha_context.Contract.implicit_contract
                                        source) fee)
                                    (fun ctxt =&gt;
                                      Error_monad.op_gtgteqquestion
                                        (Alpha_context.add_fees ctxt fee)
                                        (fun ctxt =&gt; Error_monad.__return ctxt)))))))))).

Definition apply_manager_contents {A : Set}
  (ctxt : Alpha_context.context) (mode : Script_ir_translator.unparsing_mode)
  (chain_id : Chain_id.[S.HASH.t])
  (op : Alpha_context.contents (Alpha_context.Kind.manager A))
  : Lwt.t
    (((* `Failure *) unit + (* `Success *) Alpha_context.context) *
      Apply_results.manager_operation_result A *
      list Apply_results.packed_internal_operation_result) :=
  let
    'Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.source := source;
        Alpha_context.contents.Manager_operation.operation := operation;
        Alpha_context.contents.Manager_operation.gas_limit := gas_limit;
        Alpha_context.contents.Manager_operation.storage_limit := storage_limit
        |} := op in
  let ctxt := Alpha_context.Gas.set_limit ctxt gas_limit in
  let ctxt := Alpha_context.Fees.start_counting_storage_fees ctxt in
  let source := Alpha_context.Contract.implicit_contract source in
  Error_monad.op_gtgteq
    (apply_manager_operation_content ctxt mode source source chain_id false
      operation)
    (fun function_parameter =&gt;
      match function_parameter with
      | Pervasives.Ok (ctxt, operation_results, internal_operations) =&gt;
        Error_monad.op_gtgteq
          (apply_internal_manager_operations ctxt mode source chain_id
            internal_operations)
          (fun function_parameter =&gt;
            match function_parameter with
            | (Success ctxt, internal_operations_results) =&gt;
              Error_monad.op_gtgteq
                (Alpha_context.Fees.burn_storage_fees ctxt storage_limit source)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | Pervasives.Ok ctxt =&gt;
                    Lwt.__return
                      ((* ‚ùå Variants not supported *)
                      (* ‚ùå `Success *)
                      ctxt, (Apply_results.Applied operation_results),
                        internal_operations_results)
                  | Pervasives.Error errors =&gt;
                    Lwt.__return
                      ((* ‚ùå Variants not supported *)
                      (* ‚ùå `Failure *)
                      tt,
                        (Apply_results.Backtracked operation_results
                          (Some errors)), internal_operations_results)
                  end)
            | (Failure, internal_operations_results) =&gt;
              Lwt.__return
                ((* ‚ùå Variants not supported *)
                (* ‚ùå `Failure *)
                tt, (Apply_results.Applied operation_results),
                  internal_operations_results)
            end)
      | Pervasives.Error errors =&gt;
        Lwt.__return
          ((* ‚ùå Variants not supported *)
          (* ‚ùå `Failure *)
          tt,
            (Apply_results.Failed (Alpha_context.manager_kind operation) errors),
            [])
      end).

Definition skipped_operation_result {kind : Set}
  (operation : Alpha_context.manager_operation kind)
  : Apply_results.manager_operation_result kind :=
  match operation with
  | Alpha_context.Reveal _ =&gt;
    Apply_results.Applied
      (Apply_results.Reveal_result
        {|
          Apply_results.successful_manager_operation_result.Reveal_result.consumed_gas :=
            Z.zero |})
  | _ =&gt; Apply_results.Skipped (Alpha_context.manager_kind operation)
  end.

Fixpoint mark_skipped {kind : Set}
  (baker : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (level : Alpha_context.Level.t)
  (function_parameter :
    Alpha_context.contents_list (Alpha_context.Kind.manager kind))
  {struct baker}
  : Apply_results.contents_result_list (Alpha_context.Kind.manager kind) :=
  match function_parameter with
  |
    Alpha_context.Single
      (Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee;
          Alpha_context.contents.Manager_operation.operation := operation
          |}) =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    Apply_results.Single_result
      (Apply_results.Manager_operation_result
        {|
          Apply_results.contents_result.Manager_operation_result.balance_updates :=
            Alpha_context.Delegate.cleanup_balance_updates
              (cons
                ((Alpha_context.Delegate.Contract source),
                  (Alpha_context.Delegate.Debited fee))
                (cons
                  ((Alpha_context.Delegate.Fees baker
                    (Alpha_context.Level.t.cycle level)),
                    (Alpha_context.Delegate.Credited fee)) []));
          Apply_results.contents_result.Manager_operation_result.operation_result :=
            skipped_operation_result operation;
          Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
            [] |})
  |
    Alpha_context.Cons
      (Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee;
          Alpha_context.contents.Manager_operation.operation := operation
          |}) rest =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    Apply_results.Cons_result
      (Apply_results.Manager_operation_result
        {|
          Apply_results.contents_result.Manager_operation_result.balance_updates :=
            Alpha_context.Delegate.cleanup_balance_updates
              (cons
                ((Alpha_context.Delegate.Contract source),
                  (Alpha_context.Delegate.Debited fee))
                (cons
                  ((Alpha_context.Delegate.Fees baker
                    (Alpha_context.Level.t.cycle level)),
                    (Alpha_context.Delegate.Credited fee)) []));
          Apply_results.contents_result.Manager_operation_result.operation_result :=
            skipped_operation_result operation;
          Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
            [] |}) (mark_skipped baker level rest)
  end.

Fixpoint precheck_manager_contents_list {A kind : Set}
  (ctxt : Alpha_context.t) (chain_id : Chain_id.[S.HASH.t])
  (raw_operation : Alpha_context.Operation.t A)
  (contents_list : Alpha_context.contents_list (Alpha_context.Kind.manager kind))
  {struct ctxt} : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  match contents_list with
  | Alpha_context.Single ((Alpha_context.Manager_operation _) as op) =&gt;
    precheck_manager_contents ctxt chain_id raw_operation op
  | Alpha_context.Cons ((Alpha_context.Manager_operation _) as op) rest =&gt;
    Error_monad.op_gtgteqquestion
      (precheck_manager_contents ctxt chain_id raw_operation op)
      (fun ctxt =&gt;
        precheck_manager_contents_list ctxt chain_id raw_operation rest)
  end.

Fixpoint apply_manager_contents_list_rec {kind : Set}
  (ctxt : Alpha_context.t) (mode : Script_ir_translator.unparsing_mode)
  (baker : Alpha_context.public_key_hash) (chain_id : Chain_id.[S.HASH.t])
  (contents_list : Alpha_context.contents_list (Alpha_context.Kind.manager kind))
  {struct ctxt}
  : Lwt.t
    (((* `Failure *) unit + (* `Success *) Alpha_context.context) *
      Apply_results.contents_result_list (Alpha_context.Kind.manager kind)) :=
  let level := Alpha_context.Level.current ctxt in
  match contents_list with
  |
    Alpha_context.Single
      ((Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee
          |}) as op) =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    Error_monad.op_gtgteq (apply_manager_contents ctxt mode chain_id op)
      (fun function_parameter =&gt;
        let '(ctxt_result, operation_result, internal_operation_results) :=
          function_parameter in
        let __result_value :=
          Apply_results.Manager_operation_result
            {|
              Apply_results.contents_result.Manager_operation_result.balance_updates :=
                Alpha_context.Delegate.cleanup_balance_updates
                  (cons
                    ((Alpha_context.Delegate.Contract source),
                      (Alpha_context.Delegate.Debited fee))
                    (cons
                      ((Alpha_context.Delegate.Fees baker
                        (Alpha_context.Level.t.cycle level)),
                        (Alpha_context.Delegate.Credited fee)) []));
              Apply_results.contents_result.Manager_operation_result.operation_result :=
                operation_result;
              Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
                internal_operation_results |} in
        Lwt.__return (ctxt_result, (Apply_results.Single_result __result_value)))
  |
    Alpha_context.Cons
      ((Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee
          |}) as op) rest =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    Error_monad.op_gtgteq (apply_manager_contents ctxt mode chain_id op)
      (fun function_parameter =&gt;
        match function_parameter with
        | (Failure, operation_result, internal_operation_results) =&gt;
          let __result_value :=
            Apply_results.Manager_operation_result
              {|
                Apply_results.contents_result.Manager_operation_result.balance_updates :=
                  Alpha_context.Delegate.cleanup_balance_updates
                    (cons
                      ((Alpha_context.Delegate.Contract source),
                        (Alpha_context.Delegate.Debited fee))
                      (cons
                        ((Alpha_context.Delegate.Fees baker
                          (Alpha_context.Level.t.cycle level)),
                          (Alpha_context.Delegate.Credited fee)) []));
                Apply_results.contents_result.Manager_operation_result.operation_result :=
                  operation_result;
                Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
                  internal_operation_results |} in
          Lwt.__return
            ((* ‚ùå Variants not supported *)
            (* ‚ùå `Failure *)
            tt,
              (Apply_results.Cons_result __result_value
                (mark_skipped baker level rest)))
        | (Success ctxt, operation_result, internal_operation_results) =&gt;
          let __result_value :=
            Apply_results.Manager_operation_result
              {|
                Apply_results.contents_result.Manager_operation_result.balance_updates :=
                  Alpha_context.Delegate.cleanup_balance_updates
                    (cons
                      ((Alpha_context.Delegate.Contract source),
                        (Alpha_context.Delegate.Debited fee))
                      (cons
                        ((Alpha_context.Delegate.Fees baker
                          (Alpha_context.Level.t.cycle level)),
                          (Alpha_context.Delegate.Credited fee)) []));
                Apply_results.contents_result.Manager_operation_result.operation_result :=
                  operation_result;
                Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
                  internal_operation_results |} in
          Error_monad.op_gtgteq
            (apply_manager_contents_list_rec ctxt mode baker chain_id rest)
            (fun function_parameter =&gt;
              let '(ctxt_result, results) := function_parameter in
              Lwt.__return
                (ctxt_result, (Apply_results.Cons_result __result_value results)))
        end)
  end.

Definition mark_backtracked {A : Set}
  (results : Apply_results.contents_result_list (Alpha_context.Kind.manager A))
  : Apply_results.contents_result_list (Alpha_context.Kind.manager A) :=
  let fix mark_contents_list {kind : Set}
    (function_parameter :
      Apply_results.contents_result_list (Alpha_context.Kind.manager kind))
    {struct function_parameter}
    : Apply_results.contents_result_list (Alpha_context.Kind.manager kind) :=
    match function_parameter with
    | Apply_results.Single_result (Apply_results.Manager_operation_result op) =&gt;
      Apply_results.Single_result
        (Apply_results.Manager_operation_result
          {|
            Apply_results.contents_result.Manager_operation_result.balance_updates :=
              Apply_results.contents_result.Manager_operation_result.balance_updates
                op;
            Apply_results.contents_result.Manager_operation_result.operation_result :=
              mark_manager_operation_result
                (Apply_results.contents_result.Manager_operation_result.operation_result
                  op);
            Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
              List.map mark_internal_operation_results
                (Apply_results.contents_result.Manager_operation_result.internal_operation_results
                  op) |})
    | Apply_results.Cons_result (Apply_results.Manager_operation_result op) rest
      =&gt;
      Apply_results.Cons_result
        (Apply_results.Manager_operation_result
          {|
            Apply_results.contents_result.Manager_operation_result.balance_updates :=
              Apply_results.contents_result.Manager_operation_result.balance_updates
                op;
            Apply_results.contents_result.Manager_operation_result.operation_result :=
              mark_manager_operation_result
                (Apply_results.contents_result.Manager_operation_result.operation_result
                  op);
            Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
              List.map mark_internal_operation_results
                (Apply_results.contents_result.Manager_operation_result.internal_operation_results
                  op) |}) (mark_contents_list rest)
    end
  with mark_internal_operation_results
    (function_parameter : Apply_results.packed_internal_operation_result)
    {struct function_parameter}
    : Apply_results.packed_internal_operation_result :=
    let 'Apply_results.Internal_operation_result kind __result_value :=
      function_parameter in
    Apply_results.Internal_operation_result kind
      (mark_manager_operation_result __result_value)
  with mark_manager_operation_result {kind : Set}
    (function_parameter : Apply_results.manager_operation_result kind)
    {struct function_parameter} : Apply_results.manager_operation_result kind :=
    match function_parameter with
    |
      (Apply_results.Failed _ _ | Apply_results.Skipped _ |
      Apply_results.Backtracked _ _) as __result_value =&gt; __result_value
    | (Apply_results.Applied (Apply_results.Reveal_result _)) as __result_value
      =&gt; __result_value
    | Apply_results.Applied __result_value =&gt;
      Apply_results.Backtracked __result_value None
    end in
  mark_contents_list results.

Definition apply_manager_contents_list {A : Set}
  (ctxt : Alpha_context.t) (mode : Script_ir_translator.unparsing_mode)
  (baker : Alpha_context.public_key_hash) (chain_id : Chain_id.[S.HASH.t])
  (contents_list : Alpha_context.contents_list (Alpha_context.Kind.manager A))
  : Lwt.t
    (Alpha_context.t *
      Apply_results.contents_result_list (Alpha_context.Kind.manager A)) :=
  Error_monad.op_gtgteq
    (apply_manager_contents_list_rec ctxt mode baker chain_id contents_list)
    (fun function_parameter =&gt;
      let '(ctxt_result, results) := function_parameter in
      match ctxt_result with
      | Failure =&gt; Lwt.__return (ctxt, (mark_backtracked results))
      | Success ctxt =&gt;
        Error_monad.op_gtgteq (Alpha_context.Big_map.cleanup_temporary ctxt)
          (fun ctxt =&gt; Lwt.__return (ctxt, results))
      end).

Definition apply_contents_list {A : Set}
  (ctxt : Alpha_context.context) (chain_id : Chain_id.[S.HASH.t])
  (mode : Script_ir_translator.unparsing_mode)
  (pred_block : Block_hash.[S.HASH.t])
  (baker : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (operation : Alpha_context.operation A)
  (contents_list : Alpha_context.contents_list A)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Apply_results.contents_result_list A)) :=
  match contents_list with
  |
    Alpha_context.Single
      (Alpha_context.Endorsement {|
        Alpha_context.contents.Endorsement.level := level |}) =&gt;
    let block :=
      Operation.shell_header.branch (Alpha_context.operation.shell operation) in
    Error_monad.op_gtgteqquestion
      (Error_monad.fail_unless (Block_hash.[S.HASH.equal] block pred_block)
        extensible_type_value)
      (fun function_parameter =&gt;
        let 'tt := function_parameter in
        let current_level :=
          Alpha_context.Level.t.level (Alpha_context.Level.current ctxt) in
        Error_monad.op_gtgteqquestion
          (Error_monad.fail_unless
            (Alpha_context.Raw_level.op_eq (Alpha_context.Raw_level.succ level)
              current_level) extensible_type_value)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Baking.check_endorsement_rights ctxt chain_id operation)
              (fun function_parameter =&gt;
                let '(delegate, slots, used) := function_parameter in
                if used then
                  Error_monad.fail extensible_type_value
                else
                  let ctxt := Alpha_context.record_endorsement ctxt delegate in
                  let gap := List.length slots in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Tez.op_starquestion
                        (Alpha_context.Constants.endorsement_security_deposit
                          ctxt) (Int64.of_int gap)))
                    (fun deposit =&gt;
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Delegate.freeze_deposit ctxt delegate
                          deposit)
                        (fun ctxt =&gt;
                          Error_monad.op_gtgteqquestion
                            (Alpha_context.Global.get_block_priority ctxt)
                            (fun block_priority =&gt;
                              Error_monad.op_gtgteqquestion
                                (Baking.endorsing_reward ctxt block_priority gap)
                                (fun reward =&gt;
                                  Error_monad.op_gtgteqquestion
                                    (Alpha_context.Delegate.freeze_rewards ctxt
                                      delegate reward)
                                    (fun ctxt =&gt;
                                      let level :=
                                        Alpha_context.Level.from_raw ctxt None
                                          level in
                                      Error_monad.__return
                                        (ctxt,
                                          (Apply_results.Single_result
                                            (Apply_results.Endorsement_result
                                              {|
                                                Apply_results.contents_result.Endorsement_result.balance_updates :=
                                                  Alpha_context.Delegate.cleanup_balance_updates
                                                    (cons
                                                      ((Alpha_context.Delegate.Contract
                                                        (Alpha_context.Contract.implicit_contract
                                                          delegate)),
                                                        (Alpha_context.Delegate.Debited
                                                          deposit))
                                                      (cons
                                                        ((Alpha_context.Delegate.Deposits
                                                          delegate
                                                          (Alpha_context.Level.t.cycle
                                                            level)),
                                                          (Alpha_context.Delegate.Credited
                                                            deposit))
                                                        (cons
                                                          ((Alpha_context.Delegate.Rewards
                                                            delegate
                                                            (Alpha_context.Level.t.cycle
                                                              level)),
                                                            (Alpha_context.Delegate.Credited
                                                              reward)) [])));
                                                Apply_results.contents_result.Endorsement_result.delegate :=
                                                  delegate;
                                                Apply_results.contents_result.Endorsement_result.slots :=
                                                  slots |})))))))))))
  |
    Alpha_context.Single
      (Alpha_context.Seed_nonce_revelation {|
        Alpha_context.contents.Seed_nonce_revelation.level := level;
          Alpha_context.contents.Seed_nonce_revelation.nonce := nonce
          |}) =&gt;
    let level := Alpha_context.Level.from_raw ctxt None level in
    Error_monad.op_gtgteqquestion (Alpha_context.Nonce.reveal ctxt level nonce)
      (fun ctxt =&gt;
        let seed_nonce_revelation_tip :=
          Alpha_context.Constants.seed_nonce_revelation_tip ctxt in
        Error_monad.op_gtgteqquestion
          (Alpha_context.add_rewards ctxt seed_nonce_revelation_tip)
          (fun ctxt =&gt;
            Error_monad.__return
              (ctxt,
                (Apply_results.Single_result
                  (Apply_results.Seed_nonce_revelation_result
                    (cons
                      ((Alpha_context.Delegate.Rewards baker
                        (Alpha_context.Level.t.cycle level)),
                        (Alpha_context.Delegate.Credited
                          seed_nonce_revelation_tip)) []))))))
  |
    Alpha_context.Single
      (Alpha_context.Double_endorsement_evidence {|
        Alpha_context.contents.Double_endorsement_evidence.op1 := op1;
          Alpha_context.contents.Double_endorsement_evidence.op2 := op2
          |}) =&gt;
    match
      (((Alpha_context.protocol_data.contents
        (Alpha_context.operation.protocol_data op1)),
        (Alpha_context.protocol_data.contents
          (Alpha_context.operation.protocol_data op2))),
        match
          ((Alpha_context.protocol_data.contents
            (Alpha_context.operation.protocol_data op1)),
            (Alpha_context.protocol_data.contents
              (Alpha_context.operation.protocol_data op2))) with
        |
          (Alpha_context.Single (Alpha_context.Endorsement e1),
            Alpha_context.Single (Alpha_context.Endorsement e2)) =&gt;
          Pervasives.op_andand
            (Alpha_context.Raw_level.op_eq
              (Alpha_context.contents.Endorsement.level e1)
              (Alpha_context.contents.Endorsement.level e2))
            (Pervasives.not
              (Block_hash.[S.HASH.equal]
                (Operation.shell_header.branch
                  (Alpha_context.operation.shell op1))
                (Operation.shell_header.branch
                  (Alpha_context.operation.shell op2))))
        | _ =&gt; false
        end) with
    |
      ((Alpha_context.Single (Alpha_context.Endorsement e1),
        Alpha_context.Single (Alpha_context.Endorsement e2)), true) =&gt;
      let level :=
        Alpha_context.Level.from_raw ctxt None
          (Alpha_context.contents.Endorsement.level e1) in
      let oldest_level := Alpha_context.Level.last_allowed_fork_level ctxt in
      Error_monad.op_gtgteqquestion
        (Error_monad.fail_unless
          (Alpha_context.Level.op_lt level (Alpha_context.Level.current ctxt))
          extensible_type_value)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgteqquestion
            (Error_monad.fail_unless
              (Alpha_context.Raw_level.op_lteq oldest_level
                (Alpha_context.Level.t.level level)) extensible_type_value)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion
                (Baking.check_endorsement_rights ctxt chain_id op1)
                (fun function_parameter =&gt;
                  let '(delegate1, _, _) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Baking.check_endorsement_rights ctxt chain_id op2)
                    (fun function_parameter =&gt;
                      let '(delegate2, _, _) := function_parameter in
                      Error_monad.op_gtgteqquestion
                        (Error_monad.fail_unless
                          (Signature.Public_key_hash.[S.SPublic_key_hash.equal]
                            delegate1 delegate2) extensible_type_value)
                        (fun function_parameter =&gt;
                          let 'tt := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (Alpha_context.Delegate.has_frozen_balance ctxt
                              delegate1 (Alpha_context.Level.t.cycle level))
                            (fun valid =&gt;
                              Error_monad.op_gtgteqquestion
                                (Error_monad.fail_unless valid
                                  extensible_type_value)
                                (fun function_parameter =&gt;
                                  let 'tt := function_parameter in
                                  Error_monad.op_gtgteqquestion
                                    (Alpha_context.Delegate.punish ctxt
                                      delegate1
                                      (Alpha_context.Level.t.cycle level))
                                    (fun function_parameter =&gt;
                                      let '(ctxt, balance) := function_parameter
                                        in
                                      Error_monad.op_gtgteqquestion
                                        (Lwt.__return
                                          (Alpha_context.Tez.op_plusquestion
                                            (Alpha_context.Delegate.frozen_balance.deposit
                                              balance)
                                            (Alpha_context.Delegate.frozen_balance.fees
                                              balance)))
                                        (fun burned =&gt;
                                          let reward :=
                                            match
                                              Alpha_context.Tez.op_divquestion
                                                burned
                                                (* ‚ùå Constant of type int64 is converted to int *)
                                                2 with
                                            | Pervasives.Ok v =&gt; v
                                            | Pervasives.Error _ =&gt;
                                              Alpha_context.Tez.zero
                                            end in
                                          Error_monad.op_gtgteqquestion
                                            (Alpha_context.add_rewards ctxt
                                              reward)
                                            (fun ctxt =&gt;
                                              let current_cycle :=
                                                Alpha_context.Level.t.cycle
                                                  (Alpha_context.Level.current
                                                    ctxt) in
                                              Error_monad.__return
                                                (ctxt,
                                                  (Apply_results.Single_result
                                                    (Apply_results.Double_endorsement_evidence_result
                                                      (Alpha_context.Delegate.cleanup_balance_updates
                                                        (cons
                                                          ((Alpha_context.Delegate.Deposits
                                                            delegate1
                                                            (Alpha_context.Level.t.cycle
                                                              level)),
                                                            (Alpha_context.Delegate.Debited
                                                              (Alpha_context.Delegate.frozen_balance.deposit
                                                                balance)))
                                                          (cons
                                                            ((Alpha_context.Delegate.Fees
                                                              delegate1
                                                              (Alpha_context.Level.t.cycle
                                                                level)),
                                                              (Alpha_context.Delegate.Debited
                                                                (Alpha_context.Delegate.frozen_balance.fees
                                                                  balance)))
                                                            (cons
                                                              ((Alpha_context.Delegate.Rewards
                                                                delegate1
                                                                (Alpha_context.Level.t.cycle
                                                                  level)),
                                                                (Alpha_context.Delegate.Debited
                                                                  (Alpha_context.Delegate.frozen_balance.rewards
                                                                    balance)))
                                                              (cons
                                                                ((Alpha_context.Delegate.Rewards
                                                                  baker
                                                                  current_cycle),
                                                                  (Alpha_context.Delegate.Credited
                                                                    reward)) []))))))))))))))))))
    | ((_, _), _) =&gt; Error_monad.fail extensible_type_value
    end
  |
    Alpha_context.Single
      (Alpha_context.Double_baking_evidence {|
        Alpha_context.contents.Double_baking_evidence.bh1 := bh1;
          Alpha_context.contents.Double_baking_evidence.bh2 := bh2
          |}) =&gt;
    let hash1 := Alpha_context.Block_header.__hash_value bh1 in
    let hash2 := Alpha_context.Block_header.__hash_value bh2 in
    Error_monad.op_gtgteqquestion
      (Error_monad.fail_unless
        (Pervasives.op_andand
          (Compare.Int32.[Compare.S.op_eq]
            (Block_header.shell_header.level
              (Alpha_context.Block_header.t.shell bh1))
            (Block_header.shell_header.level
              (Alpha_context.Block_header.t.shell bh2)))
          (Pervasives.not (Block_hash.[S.HASH.equal] hash1 hash2)))
        extensible_type_value)
      (fun function_parameter =&gt;
        let 'tt := function_parameter in
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Raw_level.of_int32
              (Block_header.shell_header.level
                (Alpha_context.Block_header.t.shell bh1))))
          (fun raw_level =&gt;
            let oldest_level := Alpha_context.Level.last_allowed_fork_level ctxt
              in
            Error_monad.op_gtgteqquestion
              (Error_monad.fail_unless
                (Alpha_context.Raw_level.op_lt raw_level
                  (Alpha_context.Level.t.level
                    (Alpha_context.Level.current ctxt))) extensible_type_value)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Error_monad.fail_unless
                    (Alpha_context.Raw_level.op_lteq oldest_level raw_level)
                    extensible_type_value)
                  (fun function_parameter =&gt;
                    let 'tt := function_parameter in
                    let level :=
                      Alpha_context.Level.from_raw ctxt None raw_level in
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Roll.baking_rights_owner ctxt level
                        (Alpha_context.Block_header.contents.priority
                          (Alpha_context.Block_header.protocol_data.contents
                            (Alpha_context.Block_header.t.protocol_data bh1))))
                      (fun delegate1 =&gt;
                        Error_monad.op_gtgteqquestion
                          (Baking.check_signature bh1 chain_id delegate1)
                          (fun function_parameter =&gt;
                            let 'tt := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Alpha_context.Roll.baking_rights_owner ctxt level
                                (Alpha_context.Block_header.contents.priority
                                  (Alpha_context.Block_header.protocol_data.contents
                                    (Alpha_context.Block_header.t.protocol_data
                                      bh2))))
                              (fun delegate2 =&gt;
                                Error_monad.op_gtgteqquestion
                                  (Baking.check_signature bh2 chain_id delegate2)
                                  (fun function_parameter =&gt;
                                    let 'tt := function_parameter in
                                    Error_monad.op_gtgteqquestion
                                      (Error_monad.fail_unless
                                        (Signature.Public_key.[S.SPublic_key.equal]
                                          delegate1 delegate2)
                                        extensible_type_value)
                                      (fun function_parameter =&gt;
                                        let 'tt := function_parameter in
                                        let delegate :=
                                          Signature.Public_key.[S.SPublic_key.__hash_value]
                                            delegate1 in
                                        Error_monad.op_gtgteqquestion
                                          (Alpha_context.Delegate.has_frozen_balance
                                            ctxt delegate
                                            (Alpha_context.Level.t.cycle level))
                                          (fun valid =&gt;
                                            Error_monad.op_gtgteqquestion
                                              (Error_monad.fail_unless valid
                                                extensible_type_value)
                                              (fun function_parameter =&gt;
                                                let 'tt := function_parameter in
                                                Error_monad.op_gtgteqquestion
                                                  (Alpha_context.Delegate.punish
                                                    ctxt delegate
                                                    (Alpha_context.Level.t.cycle
                                                      level))
                                                  (fun function_parameter =&gt;
                                                    let '(ctxt, balance) :=
                                                      function_parameter in
                                                    Error_monad.op_gtgteqquestion
                                                      (Lwt.__return
                                                        (Alpha_context.Tez.op_plusquestion
                                                          (Alpha_context.Delegate.frozen_balance.deposit
                                                            balance)
                                                          (Alpha_context.Delegate.frozen_balance.fees
                                                            balance)))
                                                      (fun burned =&gt;
                                                        let reward :=
                                                          match
                                                            Alpha_context.Tez.op_divquestion
                                                              burned
                                                              (* ‚ùå Constant of type int64 is converted to int *)
                                                              2 with
                                                          | Pervasives.Ok v =&gt; v
                                                          | Pervasives.Error _
                                                            =&gt;
                                                            Alpha_context.Tez.zero
                                                          end in
                                                        Error_monad.op_gtgteqquestion
                                                          (Alpha_context.add_rewards
                                                            ctxt reward)
                                                          (fun ctxt =&gt;
                                                            let current_cycle :=
                                                              Alpha_context.Level.t.cycle
                                                                (Alpha_context.Level.current
                                                                  ctxt) in
                                                            Error_monad.__return
                                                              (ctxt,
                                                                (Apply_results.Single_result
                                                                  (Apply_results.Double_baking_evidence_result
                                                                    (Alpha_context.Delegate.cleanup_balance_updates
                                                                      (cons
                                                                        ((Alpha_context.Delegate.Deposits
                                                                          delegate
                                                                          (Alpha_context.Level.t.cycle
                                                                            level)),
                                                                          (Alpha_context.Delegate.Debited
                                                                            (Alpha_context.Delegate.frozen_balance.deposit
                                                                              balance)))
                                                                        (cons
                                                                          ((Alpha_context.Delegate.Fees
                                                                            delegate
                                                                            (Alpha_context.Level.t.cycle
                                                                              level)),
                                                                            (Alpha_context.Delegate.Debited
                                                                              (Alpha_context.Delegate.frozen_balance.fees
                                                                                balance)))
                                                                          (cons
                                                                            ((Alpha_context.Delegate.Rewards
                                                                              delegate
                                                                              (Alpha_context.Level.t.cycle
                                                                                level)),
                                                                              (Alpha_context.Delegate.Debited
                                                                                (Alpha_context.Delegate.frozen_balance.rewards
                                                                                  balance)))
                                                                            (cons
                                                                              ((Alpha_context.Delegate.Rewards
                                                                                baker
                                                                                current_cycle),
                                                                                (Alpha_context.Delegate.Credited
                                                                                  reward))
                                                                              []))))))))))))))))))))))
  |
    Alpha_context.Single
      (Alpha_context.Activate_account {|
        Alpha_context.contents.Activate_account.id := pkh;
          Alpha_context.contents.Activate_account.activation_code :=
            activation_code
          |}) =&gt;
    let blinded_pkh :=
      Blinded_public_key_hash.of_ed25519_pkh activation_code pkh in
    Error_monad.op_gtgteqquestion
      (Alpha_context.Commitment.get_opt ctxt blinded_pkh)
      (fun function_parameter =&gt;
        match function_parameter with
        | None =&gt; Error_monad.fail extensible_type_value
        | Some amount =&gt;
          Error_monad.op_gtgteqquestion
            (Alpha_context.Commitment.delete ctxt blinded_pkh)
            (fun ctxt =&gt;
              let contract :=
                Alpha_context.Contract.implicit_contract
                  (Signature.Ed25519Hash pkh) in
              Error_monad.op_gtgteqquestion
                (Alpha_context.Contract.credit ctxt contract amount)
                (fun ctxt =&gt;
                  Error_monad.__return
                    (ctxt,
                      (Apply_results.Single_result
                        (Apply_results.Activate_account_result
                          (cons
                            ((Alpha_context.Delegate.Contract contract),
                              (Alpha_context.Delegate.Credited amount)) []))))))
        end)
  |
    Alpha_context.Single
      (Alpha_context.Proposals {|
        Alpha_context.contents.Proposals.source := source;
          Alpha_context.contents.Proposals.period := period;
          Alpha_context.contents.Proposals.proposals := proposals
          |}) =&gt;
    Error_monad.op_gtgteqquestion
      (Alpha_context.Roll.delegate_pubkey ctxt source)
      (fun delegate =&gt;
        Error_monad.op_gtgteqquestion
          (Alpha_context.Operation.check_signature delegate chain_id operation)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            let level := Alpha_context.Level.current ctxt in
            Error_monad.op_gtgteqquestion
              (Error_monad.fail_unless
                (Alpha_context.Voting_period.op_eq
                  (Alpha_context.Level.t.voting_period level) period)
                extensible_type_value)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Amendment.record_proposals ctxt source proposals)
                  (fun ctxt =&gt;
                    Error_monad.__return
                      (ctxt,
                        (Apply_results.Single_result
                          Apply_results.Proposals_result))))))
  |
    Alpha_context.Single
      (Alpha_context.Ballot {|
        Alpha_context.contents.Ballot.source := source;
          Alpha_context.contents.Ballot.period := period;
          Alpha_context.contents.Ballot.proposal := proposal;
          Alpha_context.contents.Ballot.ballot := ballot
          |}) =&gt;
    Error_monad.op_gtgteqquestion
      (Alpha_context.Roll.delegate_pubkey ctxt source)
      (fun delegate =&gt;
        Error_monad.op_gtgteqquestion
          (Alpha_context.Operation.check_signature delegate chain_id operation)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            let level := Alpha_context.Level.current ctxt in
            Error_monad.op_gtgteqquestion
              (Error_monad.fail_unless
                (Alpha_context.Voting_period.op_eq
                  (Alpha_context.Level.t.voting_period level) period)
                extensible_type_value)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Amendment.record_ballot ctxt source proposal ballot)
                  (fun ctxt =&gt;
                    Error_monad.__return
                      (ctxt,
                        (Apply_results.Single_result Apply_results.Ballot_result))))))
  | (Alpha_context.Single (Alpha_context.Manager_operation _)) as op =&gt;
    Error_monad.op_gtgteqquestion
      (precheck_manager_contents_list ctxt chain_id operation op)
      (fun ctxt =&gt;
        Error_monad.op_gtgteq
          (apply_manager_contents_list ctxt mode baker chain_id op)
          (fun function_parameter =&gt;
            let '(ctxt, __result_value) := function_parameter in
            Error_monad.__return (ctxt, __result_value)))
  | (Alpha_context.Cons (Alpha_context.Manager_operation _) _) as op =&gt;
    Error_monad.op_gtgteqquestion
      (precheck_manager_contents_list ctxt chain_id operation op)
      (fun ctxt =&gt;
        Error_monad.op_gtgteq
          (apply_manager_contents_list ctxt mode baker chain_id op)
          (fun function_parameter =&gt;
            let '(ctxt, __result_value) := function_parameter in
            Error_monad.__return (ctxt, __result_value)))
  end.

Definition apply_operation {A : Set}
  (ctxt : Alpha_context.context) (chain_id : Chain_id.[S.HASH.t])
  (mode : Script_ir_translator.unparsing_mode)
  (pred_block : Block_hash.[S.HASH.t])
  (baker : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (__hash_value : Operation_hash.[S.HASH.t])
  (operation : Alpha_context.operation A)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Apply_results.operation_metadata A)) :=
  let ctxt := Alpha_context.Contract.init_origination_nonce ctxt __hash_value in
  Error_monad.op_gtgteqquestion
    (apply_contents_list ctxt chain_id mode pred_block baker operation
      (Alpha_context.protocol_data.contents
        (Alpha_context.operation.protocol_data operation)))
    (fun function_parameter =&gt;
      let '(ctxt, __result_value) := function_parameter in
      let ctxt := Alpha_context.Gas.set_unlimited ctxt in
      let ctxt := Alpha_context.Contract.unset_origination_nonce ctxt in
      Error_monad.__return
        (ctxt, {| Apply_results.operation_metadata.contents := __result_value |})).

Definition may_snapshot_roll (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let level := Alpha_context.Level.current ctxt in
  let blocks_per_roll_snapshot :=
    Alpha_context.Constants.blocks_per_roll_snapshot ctxt in
  if
    Compare.Int32.[Compare.S.equal]
      (Int32.rem (Alpha_context.Level.t.cycle_position level)
        blocks_per_roll_snapshot) (Int32.pred blocks_per_roll_snapshot) then
    Error_monad.op_gtgteqquestion (Alpha_context.Roll.snapshot_rolls ctxt)
      (fun ctxt =&gt; Error_monad.__return ctxt)
  else
    Error_monad.__return ctxt.

Definition may_start_new_cycle (ctxt : Alpha_context.context)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Alpha_context.Delegate.balance_updates *
        list Signature.Public_key_hash.[S.SPublic_key_hash.t])) :=
  Error_monad.op_gtgteqquestion (Baking.dawn_of_a_new_cycle ctxt)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return (ctxt, [], [])
      | Some last_cycle =&gt;
        Error_monad.op_gtgteqquestion
          (Alpha_context.Seed.cycle_end ctxt last_cycle)
          (fun function_parameter =&gt;
            let '(ctxt, unrevealed) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Alpha_context.Roll.cycle_end ctxt last_cycle)
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Alpha_context.Delegate.cycle_end ctxt last_cycle unrevealed)
                  (fun function_parameter =&gt;
                    let '(ctxt, update_balances, deactivated) :=
                      function_parameter in
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Bootstrap.cycle_end ctxt last_cycle)
                      (fun ctxt =&gt;
                        Error_monad.__return
                          (ctxt, update_balances, deactivated)))))
      end).

Definition begin_full_construction
  (ctxt : Alpha_context.context) (pred_timestamp : Time.t)
  (protocol_data : Alpha_context.Block_header.contents)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Alpha_context.Block_header.contents *
        Alpha_context.public_key * Alpha_context.Period.t)) :=
  Error_monad.op_gtgteqquestion
    (Alpha_context.Global.set_block_priority ctxt
      (Alpha_context.Block_header.contents.priority protocol_data))
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Baking.check_baking_rights ctxt protocol_data pred_timestamp)
        (fun function_parameter =&gt;
          let '(delegate_pk, block_delay) := function_parameter in
          let ctxt := Alpha_context.Fitness.increase None ctxt in
          match Alpha_context.Level.pred ctxt (Alpha_context.Level.current ctxt)
            with
          | None =&gt;
            (* ‚ùå Assert instruction is not handled. *)
            assert false
          | Some pred_level =&gt;
            Error_monad.op_gtgteqquestion
              (Baking.endorsement_rights ctxt pred_level)
              (fun rights =&gt;
                let ctxt := Alpha_context.init_endorsements ctxt rights in
                Error_monad.__return
                  (ctxt, protocol_data, delegate_pk, block_delay))
          end)).

Definition begin_partial_construction (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let ctxt := Alpha_context.Fitness.increase None ctxt in
  match Alpha_context.Level.pred ctxt (Alpha_context.Level.current ctxt) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some pred_level =&gt;
    Error_monad.op_gtgteqquestion (Baking.endorsement_rights ctxt pred_level)
      (fun rights =&gt;
        let ctxt := Alpha_context.init_endorsements ctxt rights in
        Error_monad.__return ctxt)
  end.

Definition begin_application
  (ctxt : Alpha_context.context) (chain_id : Chain_id.[S.HASH.t])
  (block_header : Alpha_context.Block_header.t) (pred_timestamp : Time.t)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Alpha_context.public_key * Alpha_context.Period.t)) :=
  Error_monad.op_gtgteqquestion
    (Alpha_context.Global.set_block_priority ctxt
      (Alpha_context.Block_header.contents.priority
        (Alpha_context.Block_header.protocol_data.contents
          (Alpha_context.Block_header.t.protocol_data block_header))))
    (fun ctxt =&gt;
      let current_level := Alpha_context.Level.current ctxt in
      Error_monad.op_gtgteqquestion
        (Baking.check_proof_of_work_stamp ctxt block_header)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgteqquestion
            (Baking.check_fitness_gap ctxt block_header)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion
                (Baking.check_baking_rights ctxt
                  (Alpha_context.Block_header.protocol_data.contents
                    (Alpha_context.Block_header.t.protocol_data block_header))
                  pred_timestamp)
                (fun function_parameter =&gt;
                  let '(delegate_pk, block_delay) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Baking.check_signature block_header chain_id delegate_pk)
                    (fun function_parameter =&gt;
                      let 'tt := function_parameter in
                      let has_commitment :=
                        match
                          Alpha_context.Block_header.contents.seed_nonce_hash
                            (Alpha_context.Block_header.protocol_data.contents
                              (Alpha_context.Block_header.t.protocol_data
                                block_header)) with
                        | None =&gt; false
                        | Some _ =&gt; true
                        end in
                      Error_monad.op_gtgteqquestion
                        (Error_monad.fail_unless
                          (Compare.Bool.[Compare.S.op_eq] has_commitment
                            (Alpha_context.Level.t.expected_commitment
                              current_level)) extensible_type_value)
                        (fun function_parameter =&gt;
                          let 'tt := function_parameter in
                          let ctxt := Alpha_context.Fitness.increase None ctxt
                            in
                          match
                            Alpha_context.Level.pred ctxt
                              (Alpha_context.Level.current ctxt) with
                          | None =&gt;
                            (* ‚ùå Assert instruction is not handled. *)
                            assert false
                          | Some pred_level =&gt;
                            Error_monad.op_gtgteqquestion
                              (Baking.endorsement_rights ctxt pred_level)
                              (fun rights =&gt;
                                let ctxt :=
                                  Alpha_context.init_endorsements ctxt rights in
                                Error_monad.__return
                                  (ctxt, delegate_pk, block_delay))
                          end)))))).

Definition check_minimum_endorsements
  (ctxt : Alpha_context.context)
  (protocol_data : Alpha_context.Block_header.contents)
  (block_delay : Alpha_context.Period.t)
  (included_endorsements : Compare.Int.[Compare.S.t])
  : Lwt.t (Error_monad.tzresult unit) :=
  let minimum := Baking.minimum_allowed_endorsements ctxt block_delay in
  let timestamp := Alpha_context.Timestamp.current ctxt in
  Error_monad.fail_unless
    (Compare.Int.[Compare.S.op_gteq] included_endorsements minimum)
    extensible_type_value.

Definition finalize_application
  (ctxt : Alpha_context.context)
  (protocol_data : Alpha_context.Block_header.contents)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (block_delay : Alpha_context.Period.t)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.context * Apply_results.block_metadata)) :=
  let included_endorsements := Alpha_context.included_endorsements ctxt in
  Error_monad.op_gtgteqquestion
    (check_minimum_endorsements ctxt protocol_data block_delay
      included_endorsements)
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      let deposit := Alpha_context.Constants.block_security_deposit ctxt in
      Error_monad.op_gtgteqquestion
        (Alpha_context.add_deposit ctxt delegate deposit)
        (fun ctxt =&gt;
          Error_monad.op_gtgteqquestion
            (Baking.baking_reward ctxt
              (Alpha_context.Block_header.contents.priority protocol_data)
              included_endorsements)
            (fun reward =&gt;
              Error_monad.op_gtgteqquestion
                (Alpha_context.add_rewards ctxt reward)
                (fun ctxt =&gt;
                  Error_monad.op_gtgteqquestion
                    (Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.fold)
                      (fun delegate =&gt;
                        fun deposit =&gt;
                          fun ctxt =&gt;
                            Error_monad.op_gtgteqquestion ctxt
                              (fun ctxt =&gt;
                                Alpha_context.Delegate.freeze_deposit ctxt
                                  delegate deposit))
                      (Alpha_context.get_deposits ctxt)
                      (Error_monad.__return ctxt))
                    (fun ctxt =&gt;
                      let fees := Alpha_context.get_fees ctxt in
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Delegate.freeze_fees ctxt delegate fees)
                        (fun ctxt =&gt;
                          let rewards := Alpha_context.get_rewards ctxt in
                          Error_monad.op_gtgteqquestion
                            (Alpha_context.Delegate.freeze_rewards ctxt delegate
                              rewards)
                            (fun ctxt =&gt;
                              Error_monad.op_gtgteqquestion
                                match
                                  Alpha_context.Block_header.contents.seed_nonce_hash
                                    protocol_data with
                                | None =&gt; Error_monad.__return ctxt
                                | Some nonce_hash =&gt;
                                  Alpha_context.Nonce.record_hash ctxt
                                    {|
                                      Alpha_context.Nonce.unrevealed.nonce_hash :=
                                        nonce_hash;
                                      Alpha_context.Nonce.unrevealed.delegate :=
                                        delegate;
                                      Alpha_context.Nonce.unrevealed.rewards :=
                                        rewards;
                                      Alpha_context.Nonce.unrevealed.fees :=
                                        fees |}
                                end
                                (fun ctxt =&gt;
                                  Error_monad.op_gtgteqquestion
                                    (may_snapshot_roll ctxt)
                                    (fun ctxt =&gt;
                                      Error_monad.op_gtgteqquestion
                                        (may_start_new_cycle ctxt)
                                        (fun function_parameter =&gt;
                                          let
                                            '(ctxt, balance_updates, deactivated) :=
                                            function_parameter in
                                          Error_monad.op_gtgteqquestion
                                            (Amendment.may_start_new_voting_period
                                              ctxt)
                                            (fun ctxt =&gt;
                                              let cycle :=
                                                Alpha_context.Level.t.cycle
                                                  (Alpha_context.Level.current
                                                    ctxt) in
                                              let balance_updates :=
                                                Alpha_context.Delegate.cleanup_balance_updates
                                                  (Pervasives.op_at
                                                    (cons
                                                      ((Alpha_context.Delegate.Contract
                                                        (Alpha_context.Contract.implicit_contract
                                                          delegate)),
                                                        (Alpha_context.Delegate.Debited
                                                          deposit))
                                                      (cons
                                                        ((Alpha_context.Delegate.Deposits
                                                          delegate cycle),
                                                          (Alpha_context.Delegate.Credited
                                                            deposit))
                                                        (cons
                                                          ((Alpha_context.Delegate.Rewards
                                                            delegate cycle),
                                                            (Alpha_context.Delegate.Credited
                                                              reward)) [])))
                                                    balance_updates) in
                                              let consumed_gas :=
                                                Z.sub
                                                  (Alpha_context.Constants.hard_gas_limit_per_block
                                                    ctxt)
                                                  (Alpha_context.Gas.block_level
                                                    ctxt) in
                                              Error_monad.op_gtgteqquestion
                                                (Alpha_context.Vote.get_current_period_kind
                                                  ctxt)
                                                (fun voting_period_kind =&gt;
                                                  let receipt :=
                                                    {|
                                                      Apply_results.block_metadata.baker :=
                                                        delegate;
                                                      Apply_results.block_metadata.level :=
                                                        Alpha_context.Level.current
                                                          ctxt;
                                                      Apply_results.block_metadata.voting_period_kind :=
                                                        voting_period_kind;
                                                      Apply_results.block_metadata.nonce_hash :=
                                                        Alpha_context.Block_header.contents.seed_nonce_hash
                                                          protocol_data;
                                                      Apply_results.block_metadata.consumed_gas :=
                                                        consumed_gas;
                                                      Apply_results.block_metadata.deactivated :=
                                                        deactivated;
                                                      Apply_results.block_metadata.balance_updates :=
                                                        balance_updates |} in
                                                  Error_monad.__return
                                                    (ctxt, receipt))))))))))))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="apply_results.ml">
  <div class="col-md-6">
    <a href="#apply_results.ml"><code>apply_results.ml</code></a>&nbsp;<span class="label label-danger">13 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Data_encoding

let error_encoding =
  <abbr class="mark-error" title="expected an argument">def
    &quot;error&quot;
    ~description:
      &quot;The full list of RPC errors would be too long to include.\n\
       It is available at RPC `/errors` (GET).\n\
       Errors specific to protocol Alpha have an id that starts with \
       `proto.alpha`.&quot;</abbr>
  @@ splitted
       ~json:
         (conv
            (fun err -&gt;
              Data_encoding.Json.construct Error_monad.error_encoding err)
            (fun json -&gt;
              Data_encoding.Json.destruct Error_monad.error_encoding json)
            json)
       ~binary:Error_monad.error_encoding

type _ successful_manager_operation_result =
  | Reveal_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.reveal successful_manager_operation_result
  | Transaction_result : {
      storage : Script.expr option;
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
      allocated_destination_contract : bool;
    }
      -&gt; Kind.transaction successful_manager_operation_result
  | Origination_result : {
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
    }
      -&gt; Kind.origination successful_manager_operation_result
  | Delegation_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.delegation successful_manager_operation_result

type packed_successful_manager_operation_result =
  | Successful_manager_result :
      'kind successful_manager_operation_result
      -&gt; packed_successful_manager_operation_result

type 'kind manager_operation_result =
  | Applied of 'kind successful_manager_operation_result
  | Backtracked of
      'kind successful_manager_operation_result * error list option
  | Failed : 'kind Kind.manager * error list -&gt; 'kind manager_operation_result
  | Skipped : 'kind Kind.manager -&gt; 'kind manager_operation_result

type packed_internal_operation_result =
  | Internal_operation_result :
      'kind internal_operation * 'kind manager_operation_result
      -&gt; packed_internal_operation_result

module Manager_result = struct
  type 'kind case =
    | MCase : {
        op_case : 'kind Operation.Encoding.Manager_operations.case;
        encoding : 'a Data_encoding.t;
        kind : 'kind Kind.manager;
        iselect :
          packed_internal_operation_result -&gt;
          ('kind internal_operation * 'kind manager_operation_result) option;
        select :
          packed_successful_manager_operation_result -&gt;
          'kind successful_manager_operation_result option;
        proj : 'kind successful_manager_operation_result -&gt; 'a;
        inj : 'a -&gt; 'kind successful_manager_operation_result;
        t : 'kind manager_operation_result Data_encoding.t;
      }
        -&gt; 'kind case

  let make ~op_case ~encoding ~kind ~iselect ~select ~proj ~inj =
    let (Operation.Encoding.Manager_operations.MCase {name; _}) = op_case in
    let t =
      def (Format.asprintf &quot;operation.alpha.operation_result.%s&quot; name)
      @@ union
           ~tag_size:<abbr class="mark-error" title="Variants not supported">`Uint8</abbr>
           [ case
               (Tag 0)
               ~title:&quot;Applied&quot;
               (merge_objs (obj1 (req &quot;status&quot; (constant &quot;applied&quot;))) encoding)
               (fun o -&gt;
                 match o with
                 | Skipped _ | Failed _ | Backtracked _ -&gt;
                     None
                 | Applied o -&gt; (
                   match select (Successful_manager_result o) with
                   | None -&gt;
                       None
                   | Some o -&gt;
                       Some ((), proj o) ))
               (fun ((), x) -&gt; Applied (inj x));
             case
               (Tag 1)
               ~title:&quot;Failed&quot;
               (obj2
                  (req &quot;status&quot; (constant &quot;failed&quot;))
                  (req &quot;errors&quot; (list error_encoding)))
               (function Failed (_, errs) -&gt; Some ((), errs) | _ -&gt; None)
               (fun ((), errs) -&gt; Failed (kind, errs));
             case
               (Tag 2)
               ~title:&quot;Skipped&quot;
               (obj1 (req &quot;status&quot; (constant &quot;skipped&quot;)))
               (function Skipped _ -&gt; Some () | _ -&gt; None)
               (fun () -&gt; Skipped kind);
             case
               (Tag 3)
               ~title:&quot;Backtracked&quot;
               (merge_objs
                  (obj2
                     (req &quot;status&quot; (constant &quot;backtracked&quot;))
                     (opt &quot;errors&quot; (list error_encoding)))
                  encoding)
               (fun o -&gt;
                 match o with
                 | Skipped _ | Failed _ | Applied _ -&gt;
                     None
                 | Backtracked (o, errs) -&gt; (
                   match select (Successful_manager_result o) with
                   | None -&gt;
                       None
                   | Some o -&gt;
                       Some (((), errs), proj o) ))
               (fun (((), errs), x) -&gt; Backtracked (inj x, errs)) ]
    in
    MCase {op_case; encoding; kind; iselect; select; proj; inj; t}

  let reveal_case =
    make
      ~op_case:Operation.Encoding.Manager_operations.reveal_case
      ~encoding:Data_encoding.(obj1 (dft &quot;consumed_gas&quot; z Z.zero))
      ~iselect:(function
        | Internal_operation_result (({operation = Reveal _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Reveal_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~kind:Kind.Reveal_manager_kind
      ~proj:(function Reveal_result {consumed_gas} -&gt; consumed_gas)
      ~inj:(fun consumed_gas -&gt; Reveal_result {consumed_gas})

  let transaction_case =
    make
      ~op_case:Operation.Encoding.Manager_operations.transaction_case
      ~encoding:
        (obj8
           (opt &quot;storage&quot; Script.expr_encoding)
           (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding)
           (dft &quot;balance_updates&quot; Delegate.balance_updates_encoding [])
           (dft &quot;originated_contracts&quot; (list Contract.encoding) [])
           (dft &quot;consumed_gas&quot; z Z.zero)
           (dft &quot;storage_size&quot; z Z.zero)
           (dft &quot;paid_storage_size_diff&quot; z Z.zero)
           (dft &quot;allocated_destination_contract&quot; bool false))
      ~iselect:(function
        | Internal_operation_result
            (({operation = Transaction _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Transaction_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~kind:Kind.Transaction_manager_kind
      ~proj:(function
        | Transaction_result
            { storage;
              big_map_diff;
              balance_updates;
              originated_contracts;
              consumed_gas;
              storage_size;
              paid_storage_size_diff;
              allocated_destination_contract } -&gt;
            ( storage,
              big_map_diff,
              balance_updates,
              originated_contracts,
              consumed_gas,
              storage_size,
              paid_storage_size_diff,
              allocated_destination_contract ))
      ~inj:
        (fun ( storage,
               big_map_diff,
               balance_updates,
               originated_contracts,
               consumed_gas,
               storage_size,
               paid_storage_size_diff,
               allocated_destination_contract ) -&gt;
        Transaction_result
          {
            storage;
            big_map_diff;
            balance_updates;
            originated_contracts;
            consumed_gas;
            storage_size;
            paid_storage_size_diff;
            allocated_destination_contract;
          })

  let origination_case =
    make
      ~op_case:Operation.Encoding.Manager_operations.origination_case
      ~encoding:
        (obj6
           (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding)
           (dft &quot;balance_updates&quot; Delegate.balance_updates_encoding [])
           (dft &quot;originated_contracts&quot; (list Contract.encoding) [])
           (dft &quot;consumed_gas&quot; z Z.zero)
           (dft &quot;storage_size&quot; z Z.zero)
           (dft &quot;paid_storage_size_diff&quot; z Z.zero))
      ~iselect:(function
        | Internal_operation_result
            (({operation = Origination _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Origination_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~proj:(function
        | Origination_result
            { big_map_diff;
              balance_updates;
              originated_contracts;
              consumed_gas;
              storage_size;
              paid_storage_size_diff } -&gt;
            ( big_map_diff,
              balance_updates,
              originated_contracts,
              consumed_gas,
              storage_size,
              paid_storage_size_diff ))
      ~kind:Kind.Origination_manager_kind
      ~inj:
        (fun ( big_map_diff,
               balance_updates,
               originated_contracts,
               consumed_gas,
               storage_size,
               paid_storage_size_diff ) -&gt;
        Origination_result
          {
            big_map_diff;
            balance_updates;
            originated_contracts;
            consumed_gas;
            storage_size;
            paid_storage_size_diff;
          })

  let delegation_case =
    make
      ~op_case:Operation.Encoding.Manager_operations.delegation_case
      ~encoding:Data_encoding.(obj1 (dft &quot;consumed_gas&quot; z Z.zero))
      ~iselect:(function
        | Internal_operation_result (({operation = Delegation _; _} as op), res)
          -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Delegation_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~kind:Kind.Delegation_manager_kind
      ~proj:(function Delegation_result {consumed_gas} -&gt; consumed_gas)
      ~inj:(fun consumed_gas -&gt; Delegation_result {consumed_gas})
end

let internal_operation_result_encoding :
    packed_internal_operation_result Data_encoding.t =
  let make (type kind)
      (Manager_result.MCase res_case : kind Manager_result.case) =
    let (Operation.Encoding.Manager_operations.MCase op_case) =
      res_case.op_case
    in
    case
      (Tag op_case.tag)
      ~title:op_case.name
      (merge_objs
         (obj3
            (req &quot;kind&quot; (constant op_case.name))
            (req &quot;source&quot; Contract.encoding)
            (req &quot;nonce&quot; uint16))
         (merge_objs op_case.encoding (obj1 (req &quot;result&quot; res_case.t))))
      (fun op -&gt;
        match res_case.iselect op with
        | Some (op, res) -&gt;
            Some (((), op.source, op.nonce), (op_case.proj op.operation, res))
        | None -&gt;
            None)
      (fun (((), source, nonce), (op, res)) -&gt;
        let op = {source; operation = op_case.inj op; nonce} in
        Internal_operation_result (op, res))
  in
  def &quot;operation.alpha.internal_operation_result&quot;
  @@ union
       [ make Manager_result.reveal_case;
         make Manager_result.transaction_case;
         make Manager_result.origination_case;
         make Manager_result.delegation_case ]

type 'kind contents_result =
  | Endorsement_result : {
      balance_updates : Delegate.balance_updates;
      delegate : Signature.Public_key_hash.t;
      slots : int list;
    }
      -&gt; Kind.endorsement contents_result
  | Seed_nonce_revelation_result :
      Delegate.balance_updates
      -&gt; Kind.seed_nonce_revelation contents_result
  | Double_endorsement_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_endorsement_evidence contents_result
  | Double_baking_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_baking_evidence contents_result
  | Activate_account_result :
      Delegate.balance_updates
      -&gt; Kind.activate_account contents_result
  | Proposals_result : Kind.proposals contents_result
  | Ballot_result : Kind.ballot contents_result
  | Manager_operation_result : {
      balance_updates : Delegate.balance_updates;
      operation_result : 'kind manager_operation_result;
      internal_operation_results : packed_internal_operation_result list;
    }
      -&gt; 'kind Kind.manager contents_result

type packed_contents_result =
  | Contents_result : 'kind contents_result -&gt; packed_contents_result

type packed_contents_and_result =
  | Contents_and_result :
      'kind Operation.contents * 'kind contents_result
      -&gt; packed_contents_and_result

type ('a, 'b) eq = Eq : ('a, 'a) eq

let equal_manager_kind :
    type a b. a Kind.manager -&gt; b Kind.manager -&gt; (a, b) eq option =
 fun ka kb -&gt;
  match (ka, kb) with
  | (Kind.Reveal_manager_kind, Kind.Reveal_manager_kind) -&gt;
      Some Eq
  | (Kind.Reveal_manager_kind, _) -&gt;
      None
  | (Kind.Transaction_manager_kind, Kind.Transaction_manager_kind) -&gt;
      Some Eq
  | (Kind.Transaction_manager_kind, _) -&gt;
      None
  | (Kind.Origination_manager_kind, Kind.Origination_manager_kind) -&gt;
      Some Eq
  | (Kind.Origination_manager_kind, _) -&gt;
      None
  | (Kind.Delegation_manager_kind, Kind.Delegation_manager_kind) -&gt;
      Some Eq
  | (Kind.Delegation_manager_kind, _) -&gt;
      None

module Encoding = struct
  type 'kind case =
    | Case : {
        op_case : 'kind Operation.Encoding.case;
        encoding : 'a Data_encoding.t;
        select : packed_contents_result -&gt; 'kind contents_result option;
        mselect :
          packed_contents_and_result -&gt;
          ('kind contents * 'kind contents_result) option;
        proj : 'kind contents_result -&gt; 'a;
        inj : 'a -&gt; 'kind contents_result;
      }
        -&gt; 'kind case

  let tagged_case tag name args proj inj =
    let open Data_encoding in
    case
      tag
      ~title:(String.capitalize_ascii name)
      (merge_objs (obj1 (req &quot;kind&quot; (constant name))) args)
      (fun x -&gt; match proj x with None -&gt; None | Some x -&gt; Some ((), x))
      (fun ((), x) -&gt; inj x)

  let endorsement_case =
    Case
      {
        op_case = Operation.Encoding.endorsement_case;
        encoding =
          obj3
            (req &quot;balance_updates&quot; Delegate.balance_updates_encoding)
            (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
            (req &quot;slots&quot; (list uint8));
        select =
          (function
          | Contents_result (Endorsement_result _ as op) -&gt; Some op | _ -&gt; None);
        mselect =
          (function
          | Contents_and_result ((Endorsement _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj =
          (function
          | Endorsement_result {balance_updates; delegate; slots} -&gt;
              (balance_updates, delegate, slots));
        inj =
          (fun (balance_updates, delegate, slots) -&gt;
            Endorsement_result {balance_updates; delegate; slots});
      }

  let seed_nonce_revelation_case =
    Case
      {
        op_case = Operation.Encoding.seed_nonce_revelation_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Seed_nonce_revelation_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Seed_nonce_revelation _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun (Seed_nonce_revelation_result bus) -&gt; bus);
        inj = (fun bus -&gt; Seed_nonce_revelation_result bus);
      }

  let double_endorsement_evidence_case =
    Case
      {
        op_case = Operation.Encoding.double_endorsement_evidence_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Double_endorsement_evidence_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Double_endorsement_evidence _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun (Double_endorsement_evidence_result bus) -&gt; bus);
        inj = (fun bus -&gt; Double_endorsement_evidence_result bus);
      }

  let double_baking_evidence_case =
    Case
      {
        op_case = Operation.Encoding.double_baking_evidence_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Double_baking_evidence_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Double_baking_evidence _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun (Double_baking_evidence_result bus) -&gt; bus);
        inj = (fun bus -&gt; Double_baking_evidence_result bus);
      }

  let activate_account_case =
    Case
      {
        op_case = Operation.Encoding.activate_account_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Activate_account_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Activate_account _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun (Activate_account_result bus) -&gt; bus);
        inj = (fun bus -&gt; Activate_account_result bus);
      }

  let proposals_case =
    Case
      {
        op_case = Operation.Encoding.proposals_case;
        encoding = Data_encoding.empty;
        select =
          (function
          | Contents_result (Proposals_result as op) -&gt; Some op | _ -&gt; None);
        mselect =
          (function
          | Contents_and_result ((Proposals _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun Proposals_result -&gt; ());
        inj = (fun () -&gt; Proposals_result);
      }

  let ballot_case =
    Case
      {
        op_case = Operation.Encoding.ballot_case;
        encoding = Data_encoding.empty;
        select =
          (function
          | Contents_result (Ballot_result as op) -&gt; Some op | _ -&gt; None);
        mselect =
          (function
          | Contents_and_result ((Ballot _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun Ballot_result -&gt; ());
        inj = (fun () -&gt; Ballot_result);
      }

  let make_manager_case (type kind)
      (Operation.Encoding.Case op_case :
        kind Kind.manager Operation.Encoding.case)
      (Manager_result.MCase res_case : kind Manager_result.case) mselect =
    Case
      {
        op_case = Operation.Encoding.Case op_case;
        encoding =
          obj3
            (req &quot;balance_updates&quot; Delegate.balance_updates_encoding)
            (req &quot;operation_result&quot; res_case.t)
            (dft
               &quot;internal_operation_results&quot;
               (list internal_operation_result_encoding)
               []);
        select =
          (function
          | Contents_result
              (Manager_operation_result
                ({operation_result = Applied res; _} as op)) -&gt; (
            match res_case.select (Successful_manager_result res) with
            | Some res -&gt;
                Some
                  (Manager_operation_result
                     <abbr class="mark-error" title="Record substitution not handled">{op with operation_result = Applied res}</abbr>)
            | None -&gt;
                None )
          | Contents_result
              (Manager_operation_result
                ({operation_result = Backtracked (res, errs); _} as op)) -&gt; (
            match res_case.select (Successful_manager_result res) with
            | Some res -&gt;
                Some
                  (Manager_operation_result
                     <abbr class="mark-error" title="Record substitution not handled">{op with operation_result = Backtracked (res, errs)}</abbr>)
            | None -&gt;
                None )
          | Contents_result
              (Manager_operation_result
                ({operation_result = Skipped kind; _} as op)) -&gt; (
            match equal_manager_kind kind res_case.kind with
            | None -&gt;
                None
            | Some Eq -&gt;
                Some
                  (Manager_operation_result
                     <abbr class="mark-error" title="Record substitution not handled">{op with operation_result = Skipped kind}</abbr>) )
          | Contents_result
              (Manager_operation_result
                ({operation_result = Failed (kind, errs); _} as op)) -&gt; (
            match equal_manager_kind kind res_case.kind with
            | None -&gt;
                None
            | Some Eq -&gt;
                Some
                  (Manager_operation_result
                     <abbr class="mark-error" title="Record substitution not handled">{op with operation_result = Failed (kind, errs)}</abbr>) )
          | Contents_result Ballot_result -&gt;
              None
          | Contents_result (Endorsement_result _) -&gt;
              None
          | Contents_result (Seed_nonce_revelation_result _) -&gt;
              None
          | Contents_result (Double_endorsement_evidence_result _) -&gt;
              None
          | Contents_result (Double_baking_evidence_result _) -&gt;
              None
          | Contents_result (Activate_account_result _) -&gt;
              None
          | Contents_result Proposals_result -&gt;
              None);
        mselect;
        proj =
          (fun (Manager_operation_result
                 { balance_updates = bus;
                   operation_result = r;
                   internal_operation_results = rs }) -&gt;
            (bus, r, rs));
        inj =
          (fun (bus, r, rs) -&gt;
            Manager_operation_result
              {
                balance_updates = bus;
                operation_result = r;
                internal_operation_results = rs;
              });
      }

  let reveal_case =
    make_manager_case
      Operation.Encoding.reveal_case
      Manager_result.reveal_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Reveal _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)

  let transaction_case =
    make_manager_case
      Operation.Encoding.transaction_case
      Manager_result.transaction_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Transaction _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)

  let origination_case =
    make_manager_case
      Operation.Encoding.origination_case
      Manager_result.origination_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Origination _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)

  let delegation_case =
    make_manager_case
      Operation.Encoding.delegation_case
      Manager_result.delegation_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Delegation _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
end

let contents_result_encoding =
  let open Encoding in
  let make
      (Case
        { op_case = Operation.Encoding.Case {tag; name; _};
          encoding;
          mselect = _;
          select;
          proj;
          inj }) =
    let proj x =
      match select x with None -&gt; None | Some x -&gt; Some (proj x)
    in
    let inj x = Contents_result (inj x) in
    tagged_case (Tag tag) name encoding proj inj
  in
  def &quot;operation.alpha.contents_result&quot;
  @@ union
       [ make endorsement_case;
         make seed_nonce_revelation_case;
         make double_endorsement_evidence_case;
         make double_baking_evidence_case;
         make activate_account_case;
         make proposals_case;
         make ballot_case;
         make reveal_case;
         make transaction_case;
         make origination_case;
         make delegation_case ]

let contents_and_result_encoding =
  let open Encoding in
  let make
      (Case
        { op_case = Operation.Encoding.Case {tag; name; encoding; proj; inj; _};
          mselect;
          encoding = meta_encoding;
          proj = meta_proj;
          inj = meta_inj;
          _ }) =
    let proj c =
      match mselect c with
      | Some (op, res) -&gt;
          Some (proj op, meta_proj res)
      | _ -&gt;
          None
    in
    let inj (op, res) = Contents_and_result (inj op, meta_inj res) in
    let encoding = merge_objs encoding (obj1 (req &quot;metadata&quot; meta_encoding)) in
    tagged_case (Tag tag) name encoding proj inj
  in
  def &quot;operation.alpha.operation_contents_and_result&quot;
  @@ union
       [ make endorsement_case;
         make seed_nonce_revelation_case;
         make double_endorsement_evidence_case;
         make double_baking_evidence_case;
         make activate_account_case;
         make proposals_case;
         make ballot_case;
         make reveal_case;
         make transaction_case;
         make origination_case;
         make delegation_case ]

type 'kind contents_result_list =
  | Single_result : 'kind contents_result -&gt; 'kind contents_result_list
  | Cons_result :
      'kind Kind.manager contents_result
      * 'rest Kind.manager contents_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_result_list

type packed_contents_result_list =
  | Contents_result_list :
      'kind contents_result_list
      -&gt; packed_contents_result_list

let contents_result_list_encoding =
  let rec to_list = function
    | Contents_result_list (Single_result o) -&gt;
        [Contents_result o]
    | Contents_result_list (Cons_result (o, os)) -&gt;
        Contents_result o :: to_list (Contents_result_list os)
  in
  let rec of_list = function
    | [] -&gt;
        Pervasives.failwith &quot;cannot decode empty operation result&quot;
    | [Contents_result o] -&gt;
        Contents_result_list (Single_result o)
    | Contents_result o :: os -&gt; (
        let (Contents_result_list os) = of_list os in
        match (o, os) with
        | ( Manager_operation_result _,
            Single_result (Manager_operation_result _) ) -&gt;
            Contents_result_list (Cons_result (o, os))
        | (Manager_operation_result _, Cons_result _) -&gt;
            Contents_result_list (Cons_result (o, os))
        | _ -&gt;
            Pervasives.failwith &quot;cannot decode ill-formed operation result&quot; )
  in
  def &quot;operation.alpha.contents_list_result&quot;
  @@ conv to_list of_list (list contents_result_encoding)

type 'kind contents_and_result_list =
  | Single_and_result :
      'kind Alpha_context.contents * 'kind contents_result
      -&gt; 'kind contents_and_result_list
  | Cons_and_result :
      'kind Kind.manager Alpha_context.contents
      * 'kind Kind.manager contents_result
      * 'rest Kind.manager contents_and_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_and_result_list

type packed_contents_and_result_list =
  | Contents_and_result_list :
      'kind contents_and_result_list
      -&gt; packed_contents_and_result_list

let contents_and_result_list_encoding =
  let rec to_list = function
    | Contents_and_result_list (Single_and_result (op, res)) -&gt;
        [Contents_and_result (op, res)]
    | Contents_and_result_list (Cons_and_result (op, res, rest)) -&gt;
        Contents_and_result (op, res)
        :: to_list (Contents_and_result_list rest)
  in
  let rec of_list = function
    | [] -&gt;
        Pervasives.failwith &quot;cannot decode empty combined operation result&quot;
    | [Contents_and_result (op, res)] -&gt;
        Contents_and_result_list (Single_and_result (op, res))
    | Contents_and_result (op, res) :: rest -&gt; (
        let (Contents_and_result_list rest) = of_list rest in
        match (op, rest) with
        | (Manager_operation _, Single_and_result (Manager_operation _, _)) -&gt;
            Contents_and_result_list (Cons_and_result (op, res, rest))
        | (Manager_operation _, Cons_and_result (_, _, _)) -&gt;
            Contents_and_result_list (Cons_and_result (op, res, rest))
        | _ -&gt;
            Pervasives.failwith
              &quot;cannot decode ill-formed combined operation result&quot; )
  in
  conv to_list of_list (Variable.list contents_and_result_encoding)

type 'kind operation_metadata = {contents : 'kind contents_result_list}

type packed_operation_metadata =
  | Operation_metadata : 'kind operation_metadata -&gt; packed_operation_metadata
  | No_operation_metadata : packed_operation_metadata

let operation_metadata_encoding =
  def &quot;operation.alpha.result&quot;
  @@ union
       [ case
           (Tag 0)
           ~title:&quot;Operation_metadata&quot;
           contents_result_list_encoding
           (function
             | Operation_metadata {contents} -&gt;
                 Some (Contents_result_list contents)
             | _ -&gt;
                 None)
           (fun (Contents_result_list contents) -&gt;
             Operation_metadata {contents});
         case
           (Tag 1)
           ~title:&quot;No_operation_metadata&quot;
           empty
           (function No_operation_metadata -&gt; Some () | _ -&gt; None)
           (fun () -&gt; No_operation_metadata) ]

let kind_equal :
    type kind kind2.
    kind contents -&gt; kind2 contents_result -&gt; (kind, kind2) eq option =
 fun op res -&gt;
  match (op, res) with
  | (Endorsement _, Endorsement_result _) -&gt;
      Some Eq
  | (Endorsement _, _) -&gt;
      None
  | (Seed_nonce_revelation _, Seed_nonce_revelation_result _) -&gt;
      Some Eq
  | (Seed_nonce_revelation _, _) -&gt;
      None
  | (Double_endorsement_evidence _, Double_endorsement_evidence_result _) -&gt;
      Some Eq
  | (Double_endorsement_evidence _, _) -&gt;
      None
  | (Double_baking_evidence _, Double_baking_evidence_result _) -&gt;
      Some Eq
  | (Double_baking_evidence _, _) -&gt;
      None
  | (Activate_account _, Activate_account_result _) -&gt;
      Some Eq
  | (Activate_account _, _) -&gt;
      None
  | (Proposals _, Proposals_result) -&gt;
      Some Eq
  | (Proposals _, _) -&gt;
      None
  | (Ballot _, Ballot_result) -&gt;
      Some Eq
  | (Ballot _, _) -&gt;
      None
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result {operation_result = Applied (Reveal_result _); _}
    ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result
        {operation_result = Backtracked (Reveal_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result
        { operation_result = Failed (Alpha_context.Kind.Reveal_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result
        {operation_result = Skipped Alpha_context.Kind.Reveal_manager_kind; _}
    ) -&gt;
      Some Eq
  | (Manager_operation {operation = Reveal _; _}, _) -&gt;
      None
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        {operation_result = Applied (Transaction_result _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        {operation_result = Backtracked (Transaction_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        { operation_result =
            Failed (Alpha_context.Kind.Transaction_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        { operation_result = Skipped Alpha_context.Kind.Transaction_manager_kind;
          _ } ) -&gt;
      Some Eq
  | (Manager_operation {operation = Transaction _; _}, _) -&gt;
      None
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        {operation_result = Applied (Origination_result _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        {operation_result = Backtracked (Origination_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        { operation_result =
            Failed (Alpha_context.Kind.Origination_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        { operation_result = Skipped Alpha_context.Kind.Origination_manager_kind;
          _ } ) -&gt;
      Some Eq
  | (Manager_operation {operation = Origination _; _}, _) -&gt;
      None
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        {operation_result = Applied (Delegation_result _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        {operation_result = Backtracked (Delegation_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        { operation_result =
            Failed (Alpha_context.Kind.Delegation_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        { operation_result = Skipped Alpha_context.Kind.Delegation_manager_kind;
          _ } ) -&gt;
      Some Eq
  | (Manager_operation {operation = Delegation _; _}, _) -&gt;
      None

let rec kind_equal_list :
    type kind kind2.
    kind contents_list -&gt; kind2 contents_result_list -&gt; (kind, kind2) eq option
    =
 fun contents res -&gt;
  match (contents, res) with
  | (Single op, Single_result res) -&gt; (
    match kind_equal op res with None -&gt; None | Some Eq -&gt; Some Eq )
  | (Cons (op, ops), Cons_result (res, ress)) -&gt; (
    match kind_equal op res with
    | None -&gt;
        None
    | Some Eq -&gt; (
      match kind_equal_list ops ress with None -&gt; None | Some Eq -&gt; Some Eq ) )
  | _ -&gt;
      None

let rec pack_contents_list :
    type kind.
    kind contents_list -&gt;
    kind contents_result_list -&gt;
    kind contents_and_result_list =
 fun contents res -&gt;
  match (contents, res) with
  | (Single op, Single_result res) -&gt;
      Single_and_result (op, res)
  | (Cons (op, ops), Cons_result (res, ress)) -&gt;
      Cons_and_result (op, res, pack_contents_list ops ress)
  | ( Single (Manager_operation _),
      Cons_result (Manager_operation_result _, Single_result _) ) -&gt;
      <abbr class="mark-error" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result (Manager_operation_result {operation_result = Failed _; _})
    ) -&gt;
      <abbr class="mark-error" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result
        (Manager_operation_result {operation_result = Skipped _; _}) ) -&gt;
      <abbr class="mark-error" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result
        (Manager_operation_result {operation_result = Applied _; _}) ) -&gt;
      <abbr class="mark-error" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result
        (Manager_operation_result {operation_result = Backtracked _; _}) ) -&gt;
      <abbr class="mark-error" title="Unreachable expressions are not supported">.</abbr>
  | (Single _, Cons_result _) -&gt;
      <abbr class="mark-error" title="Unreachable expressions are not supported">.</abbr>

let rec unpack_contents_list :
    type kind.
    kind contents_and_result_list -&gt;
    kind contents_list * kind contents_result_list = function
  | Single_and_result (op, res) -&gt;
      (Single op, Single_result res)
  | Cons_and_result (op, res, rest) -&gt;
      let (ops, ress) = unpack_contents_list rest in
      (Cons (op, ops), Cons_result (res, ress))

let rec to_list = function
  | Contents_result_list (Single_result o) -&gt;
      [Contents_result o]
  | Contents_result_list (Cons_result (o, os)) -&gt;
      Contents_result o :: to_list (Contents_result_list os)

let rec of_list = function
  | [] -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | [Contents_result o] -&gt;
      Contents_result_list (Single_result o)
  | Contents_result o :: os -&gt; (
      let (Contents_result_list os) = of_list os in
      match (o, os) with
      | (Manager_operation_result _, Single_result (Manager_operation_result _))
        -&gt;
          Contents_result_list (Cons_result (o, os))
      | (Manager_operation_result _, Cons_result _) -&gt;
          Contents_result_list (Cons_result (o, os))
      | _ -&gt;
          Pervasives.failwith
            &quot;Operation result list of length &gt; 1 should only contains manager \
             operations result.&quot; )

let operation_data_and_metadata_encoding =
  def &quot;operation.alpha.operation_with_metadata&quot;
  @@ union
       [ case
           (Tag 0)
           ~title:&quot;Operation_with_metadata&quot;
           (obj2
              (req &quot;contents&quot; (dynamic_size contents_and_result_list_encoding))
              (opt &quot;signature&quot; Signature.encoding))
           (function
             | (Operation_data _, No_operation_metadata) -&gt;
                 None
             | (Operation_data op, Operation_metadata res) -&gt; (
               match kind_equal_list op.contents res.contents with
               | None -&gt;
                   Pervasives.failwith
                     &quot;cannot decode inconsistent combined operation result&quot;
               | Some Eq -&gt;
                   Some
                     ( Contents_and_result_list
                         (pack_contents_list op.contents res.contents),
                       op.signature ) ))
           (fun (Contents_and_result_list contents, signature) -&gt;
             let (op_contents, res_contents) = unpack_contents_list contents in
             ( Operation_data {contents = op_contents; signature},
               Operation_metadata {contents = res_contents} ));
         case
           (Tag 1)
           ~title:&quot;Operation_without_metadata&quot;
           (obj2
              (req &quot;contents&quot; (dynamic_size Operation.contents_list_encoding))
              (opt &quot;signature&quot; Signature.encoding))
           (function
             | (Operation_data op, No_operation_metadata) -&gt;
                 Some (Contents_list op.contents, op.signature)
             | (Operation_data _, Operation_metadata _) -&gt;
                 None)
           (fun (Contents_list contents, signature) -&gt;
             (Operation_data {contents; signature}, No_operation_metadata)) ]

type block_metadata = {
  baker : Signature.Public_key_hash.t;
  level : Level.t;
  voting_period_kind : Voting_period.kind;
  nonce_hash : Nonce_hash.t option;
  consumed_gas : Z.t;
  deactivated : Signature.Public_key_hash.t list;
  balance_updates : Delegate.balance_updates;
}

let block_metadata_encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.metadata&quot;
  @@ conv
       (fun { baker;
              level;
              voting_period_kind;
              nonce_hash;
              consumed_gas;
              deactivated;
              balance_updates } -&gt;
         ( baker,
           level,
           voting_period_kind,
           nonce_hash,
           consumed_gas,
           deactivated,
           balance_updates ))
       (fun ( baker,
              level,
              voting_period_kind,
              nonce_hash,
              consumed_gas,
              deactivated,
              balance_updates ) -&gt;
         {
           baker;
           level;
           voting_period_kind;
           nonce_hash;
           consumed_gas;
           deactivated;
           balance_updates;
         })
       (obj7
          (req &quot;baker&quot; Signature.Public_key_hash.encoding)
          (req &quot;level&quot; Level.encoding)
          (req &quot;voting_period_kind&quot; Voting_period.kind_encoding)
          (req &quot;nonce_hash&quot; (option Nonce_hash.encoding))
          (req &quot;consumed_gas&quot; (check_size 10 n))
          (req &quot;deactivated&quot; (list Signature.Public_key_hash.encoding))
          (req &quot;balance_updates&quot; Delegate.balance_updates_encoding))
</pre>
  </div>
  <div class="col-md-6">
    <a href="#apply_results.ml"><code>Apply_results.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Nonce_hash.

Import Alpha_context.

Import Data_encoding.

Definition error_encoding : Data_encoding.encoding Error_monad.__error :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;error&quot; % string
        (* ‚ùå expected an argument *)
        expected_argument
        (Some
          &quot;The full list of RPC errors would be too long to include.\nIt is available at RPC `/errors` (GET).\nErrors specific to protocol Alpha have an id that starts with `proto.alpha`.&quot;
            % string) in
    fun eta =&gt; arg None eta)
    (Data_encoding.splitted
      (Data_encoding.conv
        (fun err =&gt; Data_encoding.Json.construct Error_monad.error_encoding err)
        (fun __json_value =&gt;
          Data_encoding.Json.destruct Error_monad.error_encoding __json_value)
        None Data_encoding.__json_value) Error_monad.error_encoding).

Module successful_manager_operation_result.
  Module Reveal_result.
    Record record {consumed_gas : Set} := {
      consumed_gas : consumed_gas }.
    Arguments record : clear implicits.
  End Reveal_result.
  Definition Reveal_result := Reveal_result.record.
  
  Module Transaction_result.
    Record record {storage big_map_diff balance_updates originated_contracts
      consumed_gas storage_size paid_storage_size_diff
      allocated_destination_contract : Set} := {
      storage : storage;
      big_map_diff : big_map_diff;
      balance_updates : balance_updates;
      originated_contracts : originated_contracts;
      consumed_gas : consumed_gas;
      storage_size : storage_size;
      paid_storage_size_diff : paid_storage_size_diff;
      allocated_destination_contract : allocated_destination_contract }.
    Arguments record : clear implicits.
  End Transaction_result.
  Definition Transaction_result := Transaction_result.record.
  
  Module Origination_result.
    Record record {big_map_diff balance_updates originated_contracts
      consumed_gas storage_size paid_storage_size_diff : Set} := {
      big_map_diff : big_map_diff;
      balance_updates : balance_updates;
      originated_contracts : originated_contracts;
      consumed_gas : consumed_gas;
      storage_size : storage_size;
      paid_storage_size_diff : paid_storage_size_diff }.
    Arguments record : clear implicits.
  End Origination_result.
  Definition Origination_result := Origination_result.record.
  
  Module Delegation_result.
    Record record {consumed_gas : Set} := {
      consumed_gas : consumed_gas }.
    Arguments record : clear implicits.
  End Delegation_result.
  Definition Delegation_result := Delegation_result.record.
End successful_manager_operation_result.

Reserved Notation &quot;'successful_manager_operation_result&quot;.

Inductive successful_manager_operation_result_gadt : Set :=
| Reveal_result :
  successful_manager_operation_result.Reveal_result Z.t -&gt;
  successful_manager_operation_result_gadt
| Transaction_result :
  successful_manager_operation_result.Transaction_result
    (option Alpha_context.Script.expr)
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t bool -&gt; successful_manager_operation_result_gadt
| Origination_result :
  successful_manager_operation_result.Origination_result
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t -&gt; successful_manager_operation_result_gadt
| Delegation_result :
  successful_manager_operation_result.Delegation_result Z.t -&gt;
  successful_manager_operation_result_gadt

where &quot;'successful_manager_operation_result&quot; := (fun (_ : Set) =&gt;
  successful_manager_operation_result_gadt).

Definition successful_manager_operation_result :=
  'successful_manager_operation_result.

Reserved Notation &quot;'packed_successful_manager_operation_result&quot;.

Inductive packed_successful_manager_operation_result_gadt : Set :=
| Successful_manager_result : forall {kind : Set},
  successful_manager_operation_result kind -&gt;
  packed_successful_manager_operation_result_gadt

where &quot;'packed_successful_manager_operation_result&quot; :=
  (packed_successful_manager_operation_result_gadt).

Definition packed_successful_manager_operation_result :=
  'packed_successful_manager_operation_result.

Reserved Notation &quot;'manager_operation_result&quot;.

Inductive manager_operation_result_gadt : Set :=
| Applied : forall {kind : Set},
  successful_manager_operation_result kind -&gt; manager_operation_result_gadt
| Backtracked : forall {kind : Set},
  successful_manager_operation_result kind -&gt;
  option (list Error_monad.__error) -&gt; manager_operation_result_gadt
| Failed : forall {kind : Set},
  Alpha_context.Kind.manager kind -&gt; list Error_monad.__error -&gt;
  manager_operation_result_gadt
| Skipped : forall {kind : Set},
  Alpha_context.Kind.manager kind -&gt; manager_operation_result_gadt

where &quot;'manager_operation_result&quot; := (fun (kind : Set) =&gt;
  manager_operation_result_gadt).

Definition manager_operation_result := 'manager_operation_result.

Reserved Notation &quot;'packed_internal_operation_result&quot;.

Inductive packed_internal_operation_result_gadt : Set :=
| Internal_operation_result : forall {kind : Set},
  Alpha_context.internal_operation kind -&gt; manager_operation_result kind -&gt;
  packed_internal_operation_result_gadt

where &quot;'packed_internal_operation_result&quot; :=
  (packed_internal_operation_result_gadt).

Definition packed_internal_operation_result :=
  'packed_internal_operation_result.

Module Manager_result.
  Module case.
    Module MCase.
      Record record {op_case encoding kind iselect select proj inj t : Set} := {
        op_case : op_case;
        encoding : encoding;
        kind : kind;
        iselect : iselect;
        select : select;
        proj : proj;
        inj : inj;
        t : t }.
      Arguments record : clear implicits.
    End MCase.
    Definition MCase := MCase.record.
  End case.
  
  Reserved Notation &quot;'case&quot;.
  
  Inductive case_gadt : Set :=
  | MCase : forall {a kind : Set},
    case.MCase (Alpha_context.Operation.Encoding.Manager_operations.case kind)
      (Data_encoding.t a) (Alpha_context.Kind.manager kind)
      (packed_internal_operation_result -&gt;
      option
        (Alpha_context.internal_operation kind * manager_operation_result kind))
      (packed_successful_manager_operation_result -&gt;
      option (successful_manager_operation_result kind))
      (successful_manager_operation_result kind -&gt; a)
      (a -&gt; successful_manager_operation_result kind)
      (Data_encoding.t (manager_operation_result kind)) -&gt; case_gadt
  
  where &quot;'case&quot; := (fun (kind : Set) =&gt; case_gadt).
  
  Definition case := 'case.
  
  Definition make {A B : Set}
    (op_case : Alpha_context.Operation.Encoding.Manager_operations.case A)
    (encoding : Data_encoding.encoding B) (kind : Alpha_context.Kind.manager A)
    (iselect :
      packed_internal_operation_result -&gt;
      option (Alpha_context.internal_operation A * manager_operation_result A))
    (select :
      packed_successful_manager_operation_result -&gt;
      option (successful_manager_operation_result A))
    (proj : successful_manager_operation_result A -&gt; B)
    (inj : B -&gt; successful_manager_operation_result A) : case A :=
    let
      'Alpha_context.Operation.Encoding.Manager_operations.MCase {|
        Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name := name
          |} := op_case in
    let t :=
      Pervasives.op_atat
        (let arg :=
          Data_encoding.def
            (Format.asprintf
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.String_literal
                  &quot;operation.alpha.operation_result.&quot; % string
                  (CamlinternalFormatBasics.String
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.End_of_format))
                &quot;operation.alpha.operation_result.%s&quot; % string) name) in
        fun eta =&gt; arg None None eta)
        (Data_encoding.union
          (Some
            (* ‚ùå Variants not supported *)
            (* ‚ùå `Uint8 *)
            tt)
          (cons
            (Data_encoding.__case_value &quot;Applied&quot; % string None
              (Data_encoding.Tag 0)
              (Data_encoding.merge_objs
                (Data_encoding.obj1
                  (Data_encoding.req None None &quot;status&quot; % string
                    (Data_encoding.constant &quot;applied&quot; % string))) encoding)
              (fun o =&gt;
                match o with
                | Skipped _ | Failed _ _ | Backtracked _ _ =&gt; None
                | Applied o =&gt;
                  match select (Successful_manager_result o) with
                  | None =&gt; None
                  | Some o =&gt; Some (tt, (proj o))
                  end
                end)
              (fun function_parameter =&gt;
                let '(tt, x) := function_parameter in
                Applied (inj x)))
            (cons
              (Data_encoding.__case_value &quot;Failed&quot; % string None
                (Data_encoding.Tag 1)
                (Data_encoding.obj2
                  (Data_encoding.req None None &quot;status&quot; % string
                    (Data_encoding.constant &quot;failed&quot; % string))
                  (Data_encoding.req None None &quot;errors&quot; % string
                    (Data_encoding.__list_value None error_encoding)))
                (fun function_parameter =&gt;
                  match function_parameter with
                  | Failed _ errs =&gt; Some (tt, errs)
                  | _ =&gt; None
                  end)
                (fun function_parameter =&gt;
                  let '(tt, errs) := function_parameter in
                  Failed kind errs))
              (cons
                (Data_encoding.__case_value &quot;Skipped&quot; % string None
                  (Data_encoding.Tag 2)
                  (Data_encoding.obj1
                    (Data_encoding.req None None &quot;status&quot; % string
                      (Data_encoding.constant &quot;skipped&quot; % string)))
                  (fun function_parameter =&gt;
                    match function_parameter with
                    | Skipped _ =&gt; Some tt
                    | _ =&gt; None
                    end)
                  (fun function_parameter =&gt;
                    let 'tt := function_parameter in
                    Skipped kind))
                (cons
                  (Data_encoding.__case_value &quot;Backtracked&quot; % string None
                    (Data_encoding.Tag 3)
                    (Data_encoding.merge_objs
                      (Data_encoding.obj2
                        (Data_encoding.req None None &quot;status&quot; % string
                          (Data_encoding.constant &quot;backtracked&quot; % string))
                        (Data_encoding.opt None None &quot;errors&quot; % string
                          (Data_encoding.__list_value None error_encoding)))
                      encoding)
                    (fun o =&gt;
                      match o with
                      | Skipped _ | Failed _ _ | Applied _ =&gt; None
                      | Backtracked o errs =&gt;
                        match select (Successful_manager_result o) with
                        | None =&gt; None
                        | Some o =&gt; Some ((tt, errs), (proj o))
                        end
                      end)
                    (fun function_parameter =&gt;
                      let '((tt, errs), x) := function_parameter in
                      Backtracked (inj x) errs)) []))))) in
    MCase
      {| case.MCase.op_case := op_case; case.MCase.encoding := encoding;
        case.MCase.kind := kind; case.MCase.iselect := iselect;
        case.MCase.select := select; case.MCase.proj := proj;
        case.MCase.inj := inj; case.MCase.t := t |}.
  
  Definition reveal_case : case Alpha_context.Kind.reveal :=
    make Alpha_context.Operation.Encoding.Manager_operations.reveal_case
      (Data_encoding.obj1
        (Data_encoding.dft None None &quot;consumed_gas&quot; % string Data_encoding.z
          Z.zero)) Alpha_context.Kind.Reveal_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Reveal _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Reveal_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        let
          'Reveal_result {|
            successful_manager_operation_result.Reveal_result.consumed_gas := consumed_gas
              |} := function_parameter in
        consumed_gas)
      (fun consumed_gas =&gt;
        Reveal_result
          {|
            successful_manager_operation_result.Reveal_result.consumed_gas :=
              consumed_gas |}).
  
  Definition transaction_case : case Alpha_context.Kind.transaction :=
    make Alpha_context.Operation.Encoding.Manager_operations.transaction_case
      (Data_encoding.obj8
        (Data_encoding.opt None None &quot;storage&quot; % string
          Alpha_context.Script.expr_encoding)
        (Data_encoding.opt None None &quot;big_map_diff&quot; % string
          Alpha_context.Contract.big_map_diff_encoding)
        (Data_encoding.dft None None &quot;balance_updates&quot; % string
          Alpha_context.Delegate.balance_updates_encoding [])
        (Data_encoding.dft None None &quot;originated_contracts&quot; % string
          (Data_encoding.__list_value None Alpha_context.Contract.encoding) [])
        (Data_encoding.dft None None &quot;consumed_gas&quot; % string Data_encoding.z
          Z.zero)
        (Data_encoding.dft None None &quot;storage_size&quot; % string Data_encoding.z
          Z.zero)
        (Data_encoding.dft None None &quot;paid_storage_size_diff&quot; % string
          Data_encoding.z Z.zero)
        (Data_encoding.dft None None &quot;allocated_destination_contract&quot; % string
          Data_encoding.__bool_value false))
      Alpha_context.Kind.Transaction_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Transaction _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Transaction_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        let
          'Transaction_result {|
            successful_manager_operation_result.Transaction_result.storage := storage;
              successful_manager_operation_result.Transaction_result.big_map_diff
                := big_map_diff;
              successful_manager_operation_result.Transaction_result.balance_updates
                := balance_updates;
              successful_manager_operation_result.Transaction_result.originated_contracts
                := originated_contracts;
              successful_manager_operation_result.Transaction_result.consumed_gas
                := consumed_gas;
              successful_manager_operation_result.Transaction_result.storage_size
                := storage_size;
              successful_manager_operation_result.Transaction_result.paid_storage_size_diff
                := paid_storage_size_diff;
              successful_manager_operation_result.Transaction_result.allocated_destination_contract
                := allocated_destination_contract
              |} := function_parameter in
        (storage, big_map_diff, balance_updates, originated_contracts,
          consumed_gas, storage_size, paid_storage_size_diff,
          allocated_destination_contract))
      (fun function_parameter =&gt;
        let
          '(storage, big_map_diff, balance_updates, originated_contracts,
            consumed_gas, storage_size, paid_storage_size_diff,
            allocated_destination_contract) := function_parameter in
        Transaction_result
          {|
            successful_manager_operation_result.Transaction_result.storage :=
              storage;
            successful_manager_operation_result.Transaction_result.big_map_diff :=
              big_map_diff;
            successful_manager_operation_result.Transaction_result.balance_updates :=
              balance_updates;
            successful_manager_operation_result.Transaction_result.originated_contracts :=
              originated_contracts;
            successful_manager_operation_result.Transaction_result.consumed_gas :=
              consumed_gas;
            successful_manager_operation_result.Transaction_result.storage_size :=
              storage_size;
            successful_manager_operation_result.Transaction_result.paid_storage_size_diff :=
              paid_storage_size_diff;
            successful_manager_operation_result.Transaction_result.allocated_destination_contract :=
              allocated_destination_contract |}).
  
  Definition origination_case : case Alpha_context.Kind.origination :=
    make Alpha_context.Operation.Encoding.Manager_operations.origination_case
      (Data_encoding.obj6
        (Data_encoding.opt None None &quot;big_map_diff&quot; % string
          Alpha_context.Contract.big_map_diff_encoding)
        (Data_encoding.dft None None &quot;balance_updates&quot; % string
          Alpha_context.Delegate.balance_updates_encoding [])
        (Data_encoding.dft None None &quot;originated_contracts&quot; % string
          (Data_encoding.__list_value None Alpha_context.Contract.encoding) [])
        (Data_encoding.dft None None &quot;consumed_gas&quot; % string Data_encoding.z
          Z.zero)
        (Data_encoding.dft None None &quot;storage_size&quot; % string Data_encoding.z
          Z.zero)
        (Data_encoding.dft None None &quot;paid_storage_size_diff&quot; % string
          Data_encoding.z Z.zero)) Alpha_context.Kind.Origination_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Origination _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Origination_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        let
          'Origination_result {|
            successful_manager_operation_result.Origination_result.big_map_diff :=
              big_map_diff;
              successful_manager_operation_result.Origination_result.balance_updates
                := balance_updates;
              successful_manager_operation_result.Origination_result.originated_contracts
                := originated_contracts;
              successful_manager_operation_result.Origination_result.consumed_gas
                := consumed_gas;
              successful_manager_operation_result.Origination_result.storage_size
                := storage_size;
              successful_manager_operation_result.Origination_result.paid_storage_size_diff
                := paid_storage_size_diff
              |} := function_parameter in
        (big_map_diff, balance_updates, originated_contracts, consumed_gas,
          storage_size, paid_storage_size_diff))
      (fun function_parameter =&gt;
        let
          '(big_map_diff, balance_updates, originated_contracts, consumed_gas,
            storage_size, paid_storage_size_diff) := function_parameter in
        Origination_result
          {|
            successful_manager_operation_result.Origination_result.big_map_diff :=
              big_map_diff;
            successful_manager_operation_result.Origination_result.balance_updates :=
              balance_updates;
            successful_manager_operation_result.Origination_result.originated_contracts :=
              originated_contracts;
            successful_manager_operation_result.Origination_result.consumed_gas :=
              consumed_gas;
            successful_manager_operation_result.Origination_result.storage_size :=
              storage_size;
            successful_manager_operation_result.Origination_result.paid_storage_size_diff :=
              paid_storage_size_diff |}).
  
  Definition delegation_case : case Alpha_context.Kind.delegation :=
    make Alpha_context.Operation.Encoding.Manager_operations.delegation_case
      (Data_encoding.obj1
        (Data_encoding.dft None None &quot;consumed_gas&quot; % string Data_encoding.z
          Z.zero)) Alpha_context.Kind.Delegation_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Delegation _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Delegation_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        let
          'Delegation_result {|
            successful_manager_operation_result.Delegation_result.consumed_gas :=
              consumed_gas
              |} := function_parameter in
        consumed_gas)
      (fun consumed_gas =&gt;
        Delegation_result
          {|
            successful_manager_operation_result.Delegation_result.consumed_gas :=
              consumed_gas |}).
End Manager_result.

Definition internal_operation_result_encoding
  : Data_encoding.t packed_internal_operation_result :=
  let make {A : Set} (function_parameter : Manager_result.case A)
    : Data_encoding.case packed_internal_operation_result :=
    let 'Manager_result.MCase res_case := function_parameter in
    let 'Alpha_context.Operation.Encoding.Manager_operations.MCase op_case :=
      Manager_result.case.MCase.op_case res_case in
    Data_encoding.__case_value
      (Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name
        op_case) None
      (Data_encoding.Tag
        (Alpha_context.Operation.Encoding.Manager_operations.case.MCase.tag
          op_case))
      (Data_encoding.merge_objs
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;kind&quot; % string
            (Data_encoding.constant
              (Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name
                op_case)))
          (Data_encoding.req None None &quot;source&quot; % string
            Alpha_context.Contract.encoding)
          (Data_encoding.req None None &quot;nonce&quot; % string Data_encoding.uint16))
        (Data_encoding.merge_objs
          (Alpha_context.Operation.Encoding.Manager_operations.case.MCase.encoding
            op_case)
          (Data_encoding.obj1
            (Data_encoding.req None None &quot;result&quot; % string
              (Manager_result.case.MCase.t res_case)))))
      (fun op =&gt;
        match (Manager_result.case.MCase.iselect res_case) op with
        | Some (op, res) =&gt;
          Some
            ((tt, (Alpha_context.internal_operation.source op),
              (Alpha_context.internal_operation.nonce op)),
              (((Alpha_context.Operation.Encoding.Manager_operations.case.MCase.proj
                op_case) (Alpha_context.internal_operation.operation op)), res))
        | None =&gt; None
        end)
      (fun function_parameter =&gt;
        let '((tt, source, nonce), (op, res)) := function_parameter in
        let op :=
          {| Alpha_context.internal_operation.source := source;
            Alpha_context.internal_operation.operation :=
              (Alpha_context.Operation.Encoding.Manager_operations.case.MCase.inj
                op_case) op; Alpha_context.internal_operation.nonce := nonce |}
          in
        Internal_operation_result op res) in
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;operation.alpha.internal_operation_result&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      (cons (make Manager_result.reveal_case)
        (cons (make Manager_result.transaction_case)
          (cons (make Manager_result.origination_case)
            (cons (make Manager_result.delegation_case) []))))).

Module contents_result.
  Module Endorsement_result.
    Record record {balance_updates delegate slots : Set} := {
      balance_updates : balance_updates;
      delegate : delegate;
      slots : slots }.
    Arguments record : clear implicits.
  End Endorsement_result.
  Definition Endorsement_result := Endorsement_result.record.
  
  Module Manager_operation_result.
    Record record {balance_updates operation_result internal_operation_results :
      Set} := {
      balance_updates : balance_updates;
      operation_result : operation_result;
      internal_operation_results : internal_operation_results }.
    Arguments record : clear implicits.
  End Manager_operation_result.
  Definition Manager_operation_result := Manager_operation_result.record.
End contents_result.

Reserved Notation &quot;'contents_result&quot;.

Inductive contents_result_gadt : Set :=
| Endorsement_result :
  contents_result.Endorsement_result Alpha_context.Delegate.balance_updates
    Signature.Public_key_hash.[S.SPublic_key_hash.t] (list Z) -&gt;
  contents_result_gadt
| Seed_nonce_revelation_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Double_endorsement_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Double_baking_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Activate_account_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Proposals_result : contents_result_gadt
| Ballot_result : contents_result_gadt
| Manager_operation_result : forall {kind : Set},
  contents_result.Manager_operation_result
    Alpha_context.Delegate.balance_updates (manager_operation_result kind)
    (list packed_internal_operation_result) -&gt; contents_result_gadt

where &quot;'contents_result&quot; := (fun (kind : Set) =&gt; contents_result_gadt).

Definition contents_result := 'contents_result.

Reserved Notation &quot;'packed_contents_result&quot;.

Inductive packed_contents_result_gadt : Set :=
| Contents_result : forall {kind : Set},
  contents_result kind -&gt; packed_contents_result_gadt

where &quot;'packed_contents_result&quot; := (packed_contents_result_gadt).

Definition packed_contents_result := 'packed_contents_result.

Reserved Notation &quot;'packed_contents_and_result&quot;.

Inductive packed_contents_and_result_gadt : Set :=
| Contents_and_result : forall {kind : Set},
  Alpha_context.Operation.contents kind -&gt; contents_result kind -&gt;
  packed_contents_and_result_gadt

where &quot;'packed_contents_and_result&quot; := (packed_contents_and_result_gadt).

Definition packed_contents_and_result := 'packed_contents_and_result.

Reserved Notation &quot;'eq&quot;.

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where &quot;'eq&quot; := (fun (a b : Set) =&gt; eq_gadt).

Definition eq := 'eq.

Definition equal_manager_kind {a b : Set}
  (ka : Alpha_context.Kind.manager a) (kb : Alpha_context.Kind.manager b)
  : option (eq a b) :=
  match (ka, kb) with
  |
    (Alpha_context.Kind.Reveal_manager_kind,
      Alpha_context.Kind.Reveal_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Reveal_manager_kind, _) =&gt; None
  |
    (Alpha_context.Kind.Transaction_manager_kind,
      Alpha_context.Kind.Transaction_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Transaction_manager_kind, _) =&gt; None
  |
    (Alpha_context.Kind.Origination_manager_kind,
      Alpha_context.Kind.Origination_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Origination_manager_kind, _) =&gt; None
  |
    (Alpha_context.Kind.Delegation_manager_kind,
      Alpha_context.Kind.Delegation_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Delegation_manager_kind, _) =&gt; None
  end.

Module Encoding.
  Module case.
    Module Case.
      Record record {op_case encoding select mselect proj inj : Set} := {
        op_case : op_case;
        encoding : encoding;
        select : select;
        mselect : mselect;
        proj : proj;
        inj : inj }.
      Arguments record : clear implicits.
    End Case.
    Definition Case := Case.record.
  End case.
  
  Reserved Notation &quot;'case&quot;.
  
  Inductive case_gadt : Set :=
  | Case : forall {a kind : Set},
    case.Case (Alpha_context.Operation.Encoding.case kind) (Data_encoding.t a)
      (packed_contents_result -&gt; option (contents_result kind))
      (packed_contents_and_result -&gt;
      option (Alpha_context.contents kind * contents_result kind))
      (contents_result kind -&gt; a) (a -&gt; contents_result kind) -&gt; case_gadt
  
  where &quot;'case&quot; := (fun (kind : Set) =&gt; case_gadt).
  
  Definition case := 'case.
  
  Definition tagged_case {A B : Set}
    (tag : Data_encoding.case_tag) (name : string)
    (args : Data_encoding.encoding A) (proj : B -&gt; option A) (inj : A -&gt; B)
    : Data_encoding.case B :=
    Data_encoding.__case_value (String.capitalize_ascii name) None tag
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;kind&quot; % string
            (Data_encoding.constant name))) args)
      (fun x =&gt;
        match proj x with
        | None =&gt; None
        | Some x =&gt; Some (tt, x)
        end)
      (fun function_parameter =&gt;
        let '(tt, x) := function_parameter in
        inj x).
  
  Definition endorsement_case : case Alpha_context.Kind.endorsement :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.endorsement_case;
        case.Case.encoding :=
          Data_encoding.obj3
            (Data_encoding.req None None &quot;balance_updates&quot; % string
              Alpha_context.Delegate.balance_updates_encoding)
            (Data_encoding.req None None &quot;delegate&quot; % string
              Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
            (Data_encoding.req None None &quot;slots&quot; % string
              (Data_encoding.__list_value None Data_encoding.uint8));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Endorsement_result _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Endorsement _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              'Endorsement_result {|
                contents_result.Endorsement_result.balance_updates := balance_updates;
                  contents_result.Endorsement_result.delegate := delegate;
                  contents_result.Endorsement_result.slots := slots
                  |} := function_parameter in
            (balance_updates, delegate, slots);
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(balance_updates, delegate, slots) := function_parameter in
            Endorsement_result
              {|
                contents_result.Endorsement_result.balance_updates :=
                  balance_updates;
                contents_result.Endorsement_result.delegate := delegate;
                contents_result.Endorsement_result.slots := slots |} |}.
  
  Definition seed_nonce_revelation_case
    : case Alpha_context.Kind.seed_nonce_revelation :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.seed_nonce_revelation_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot; % string
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Seed_nonce_revelation_result _) as op) =&gt;
              Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Seed_nonce_revelation _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let 'Seed_nonce_revelation_result bus := function_parameter in
            bus; case.Case.inj := fun bus =&gt; Seed_nonce_revelation_result bus |}.
  
  Definition double_endorsement_evidence_case
    : case Alpha_context.Kind.double_endorsement_evidence :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.double_endorsement_evidence_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot; % string
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Double_endorsement_evidence_result _) as op) =&gt;
              Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Double_endorsement_evidence _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let 'Double_endorsement_evidence_result bus := function_parameter in
            bus;
        case.Case.inj := fun bus =&gt; Double_endorsement_evidence_result bus |}.
  
  Definition double_baking_evidence_case
    : case Alpha_context.Kind.double_baking_evidence :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.double_baking_evidence_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot; % string
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Double_baking_evidence_result _) as op) =&gt;
              Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Double_baking_evidence _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let 'Double_baking_evidence_result bus := function_parameter in
            bus; case.Case.inj := fun bus =&gt; Double_baking_evidence_result bus
        |}.
  
  Definition activate_account_case : case Alpha_context.Kind.activate_account :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.activate_account_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot; % string
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Activate_account_result _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Activate_account _) as op) res
              =&gt; Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let 'Activate_account_result bus := function_parameter in
            bus; case.Case.inj := fun bus =&gt; Activate_account_result bus |}.
  
  Definition proposals_case : case Alpha_context.Kind.proposals :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.proposals_case;
        case.Case.encoding := Data_encoding.empty;
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result (Proposals_result as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Proposals _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let 'Proposals_result := function_parameter in
            tt;
        case.Case.inj :=
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            Proposals_result |}.
  
  Definition ballot_case : case Alpha_context.Kind.ballot :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.ballot_case;
        case.Case.encoding := Data_encoding.empty;
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result (Ballot_result as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Ballot _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let 'Ballot_result := function_parameter in
            tt;
        case.Case.inj :=
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            Ballot_result |}.
  
  Definition make_manager_case {A : Set}
    (function_parameter :
      Alpha_context.Operation.Encoding.case (Alpha_context.Kind.manager A))
    : Manager_result.case A -&gt;
    (packed_contents_and_result -&gt;
    option
      (Alpha_context.contents (Alpha_context.Kind.manager A) *
        contents_result (Alpha_context.Kind.manager A))) -&gt;
    case (Alpha_context.Kind.manager A) :=
    let 'Alpha_context.Operation.Encoding.Case op_case := function_parameter in
    fun function_parameter =&gt;
      let 'Manager_result.MCase res_case := function_parameter in
      fun mselect =&gt;
        Case
          {| case.Case.op_case := Alpha_context.Operation.Encoding.Case op_case;
            case.Case.encoding :=
              Data_encoding.obj3
                (Data_encoding.req None None &quot;balance_updates&quot; % string
                  Alpha_context.Delegate.balance_updates_encoding)
                (Data_encoding.req None None &quot;operation_result&quot; % string
                  (Manager_result.case.MCase.t res_case))
                (Data_encoding.dft None None
                  &quot;internal_operation_results&quot; % string
                  (Data_encoding.__list_value None
                    internal_operation_result_encoding) []);
            case.Case.select :=
              fun function_parameter =&gt;
                match function_parameter with
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Applied res
                          |} as op)) =&gt;
                  match
                    (Manager_result.case.MCase.select res_case)
                      (Successful_manager_result res) with
                  | Some res =&gt;
                    Some
                      (Manager_operation_result
                        (* ‚ùå Record substitution not handled *)
                        record_substitution)
                  | None =&gt; None
                  end
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result :=
                          Backtracked res errs
                          |} as op)) =&gt;
                  match
                    (Manager_result.case.MCase.select res_case)
                      (Successful_manager_result res) with
                  | Some res =&gt;
                    Some
                      (Manager_operation_result
                        (* ‚ùå Record substitution not handled *)
                        record_substitution)
                  | None =&gt; None
                  end
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Skipped kind
                          |} as op)) =&gt;
                  match
                    equal_manager_kind kind
                      (Manager_result.case.MCase.kind res_case) with
                  | None =&gt; None
                  | Some Eq =&gt;
                    Some
                      (Manager_operation_result
                        (* ‚ùå Record substitution not handled *)
                        record_substitution)
                  end
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Failed kind errs
                          |} as op)) =&gt;
                  match
                    equal_manager_kind kind
                      (Manager_result.case.MCase.kind res_case) with
                  | None =&gt; None
                  | Some Eq =&gt;
                    Some
                      (Manager_operation_result
                        (* ‚ùå Record substitution not handled *)
                        record_substitution)
                  end
                | Contents_result Ballot_result =&gt; None
                | Contents_result (Endorsement_result _) =&gt; None
                | Contents_result (Seed_nonce_revelation_result _) =&gt; None
                | Contents_result (Double_endorsement_evidence_result _) =&gt; None
                | Contents_result (Double_baking_evidence_result _) =&gt; None
                | Contents_result (Activate_account_result _) =&gt; None
                | Contents_result Proposals_result =&gt; None
                end; case.Case.mselect := mselect;
            case.Case.proj :=
              fun function_parameter =&gt;
                let
                  'Manager_operation_result {|
                    contents_result.Manager_operation_result.balance_updates := bus;
                      contents_result.Manager_operation_result.operation_result
                        := r;
                      contents_result.Manager_operation_result.internal_operation_results
                        := rs
                      |} := function_parameter in
                (bus, r, rs);
            case.Case.inj :=
              fun function_parameter =&gt;
                let '(bus, r, rs) := function_parameter in
                Manager_operation_result
                  {|
                    contents_result.Manager_operation_result.balance_updates :=
                      bus;
                    contents_result.Manager_operation_result.operation_result :=
                      r;
                    contents_result.Manager_operation_result.internal_operation_results :=
                      rs |} |}.
  
  Definition reveal_case
    : case (Alpha_context.Kind.manager Alpha_context.Kind.reveal) :=
    make_manager_case Alpha_context.Operation.Encoding.reveal_case
      Manager_result.reveal_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
  
  Definition transaction_case
    : case (Alpha_context.Kind.manager Alpha_context.Kind.transaction) :=
    make_manager_case Alpha_context.Operation.Encoding.transaction_case
      Manager_result.transaction_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Transaction _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
  
  Definition origination_case
    : case (Alpha_context.Kind.manager Alpha_context.Kind.origination) :=
    make_manager_case Alpha_context.Operation.Encoding.origination_case
      Manager_result.origination_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Origination _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
  
  Definition delegation_case
    : case (Alpha_context.Kind.manager Alpha_context.Kind.delegation) :=
    make_manager_case Alpha_context.Operation.Encoding.delegation_case
      Manager_result.delegation_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Delegation _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
End Encoding.

Definition contents_result_encoding
  : Data_encoding.encoding packed_contents_result :=
  let make {A : Set} (function_parameter : Encoding.case A)
    : Data_encoding.case packed_contents_result :=
    let
      'Encoding.Case {|
        Encoding.case.Case.op_case :=
          Alpha_context.Operation.Encoding.Case {|
            Alpha_context.Operation.Encoding.case.Case.tag := tag;
              Alpha_context.Operation.Encoding.case.Case.name :=
                name
              |};
          Encoding.case.Case.encoding := encoding;
          Encoding.case.Case.select := select;
          Encoding.case.Case.mselect := _;
          Encoding.case.Case.proj := proj;
          Encoding.case.Case.inj := inj
          |} := function_parameter in
    let proj (x : packed_contents_result) : option op_dollarCase_'a :=
      match select x with
      | None =&gt; None
      | Some x =&gt; Some (proj x)
      end in
    let inj (x : op_dollarCase_'a) : packed_contents_result :=
      Contents_result (inj x) in
    tagged_case (Data_encoding.Tag tag) name encoding proj inj in
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;operation.alpha.contents_result&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      (cons (make endorsement_case)
        (cons (make seed_nonce_revelation_case)
          (cons (make double_endorsement_evidence_case)
            (cons (make double_baking_evidence_case)
              (cons (make activate_account_case)
                (cons (make proposals_case)
                  (cons (make ballot_case)
                    (cons (make reveal_case)
                      (cons (make transaction_case)
                        (cons (make origination_case)
                          (cons (make delegation_case) [])))))))))))).

Definition contents_and_result_encoding
  : Data_encoding.encoding packed_contents_and_result :=
  let make {A : Set} (function_parameter : Encoding.case A)
    : Data_encoding.case packed_contents_and_result :=
    let
      'Encoding.Case {|
        Encoding.case.Case.op_case :=
          Alpha_context.Operation.Encoding.Case {|
            Alpha_context.Operation.Encoding.case.Case.tag := tag;
              Alpha_context.Operation.Encoding.case.Case.name :=
                name;
              Alpha_context.Operation.Encoding.case.Case.encoding :=
                encoding;
              Alpha_context.Operation.Encoding.case.Case.proj :=
                proj;
              Alpha_context.Operation.Encoding.case.Case.inj := inj
              |};
          Encoding.case.Case.encoding := meta_encoding;
          Encoding.case.Case.mselect := mselect;
          Encoding.case.Case.proj := meta_proj;
          Encoding.case.Case.inj := meta_inj
          |} := function_parameter in
    let proj (c : packed_contents_and_result)
      : option (op_dollarCase_'a1 * op_dollarCase_'a) :=
      match mselect c with
      | Some (op, res) =&gt; Some ((proj op), (meta_proj res))
      | _ =&gt; None
      end in
    let inj (function_parameter : op_dollarCase_'a1 * op_dollarCase_'a)
      : packed_contents_and_result :=
      let '(op, res) := function_parameter in
      Contents_and_result (inj op) (meta_inj res) in
    let encoding :=
      Data_encoding.merge_objs encoding
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;metadata&quot; % string meta_encoding)) in
    tagged_case (Data_encoding.Tag tag) name encoding proj inj in
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;operation.alpha.operation_contents_and_result&quot; % string
      in
    fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      (cons (make endorsement_case)
        (cons (make seed_nonce_revelation_case)
          (cons (make double_endorsement_evidence_case)
            (cons (make double_baking_evidence_case)
              (cons (make activate_account_case)
                (cons (make proposals_case)
                  (cons (make ballot_case)
                    (cons (make reveal_case)
                      (cons (make transaction_case)
                        (cons (make origination_case)
                          (cons (make delegation_case) [])))))))))))).

Reserved Notation &quot;'contents_result_list&quot;.

Inductive contents_result_list_gadt : Set :=
| Single_result : forall {kind : Set},
  contents_result kind -&gt; contents_result_list_gadt
| Cons_result : forall {kind : Set},
  contents_result (Alpha_context.Kind.manager kind) -&gt;
  contents_result_list_gadt -&gt; contents_result_list_gadt

where &quot;'contents_result_list&quot; := (fun (kind : Set) =&gt; contents_result_list_gadt).

Definition contents_result_list := 'contents_result_list.

Reserved Notation &quot;'packed_contents_result_list&quot;.

Inductive packed_contents_result_list_gadt : Set :=
| Contents_result_list : forall {kind : Set},
  contents_result_list kind -&gt; packed_contents_result_list_gadt

where &quot;'packed_contents_result_list&quot; := (packed_contents_result_list_gadt).

Definition packed_contents_result_list := 'packed_contents_result_list.

Definition contents_result_list_encoding
  : Data_encoding.encoding packed_contents_result_list :=
  let fix to_list (function_parameter : packed_contents_result_list)
    {struct function_parameter} : list packed_contents_result :=
    match function_parameter with
    | Contents_result_list (Single_result o) =&gt; cons (Contents_result o) []
    | Contents_result_list (Cons_result o os) =&gt;
      cons (Contents_result o) (to_list (Contents_result_list os))
    end in
  let fix of_list (function_parameter : list packed_contents_result)
    {struct function_parameter} : packed_contents_result_list :=
    match function_parameter with
    | [] =&gt; Pervasives.failwith &quot;cannot decode empty operation result&quot; % string
    | cons (Contents_result o) [] =&gt; Contents_result_list (Single_result o)
    | cons (Contents_result o) os =&gt;
      let 'Contents_result_list os := of_list os in
      match (o, os) with
      | (Manager_operation_result _, Single_result (Manager_operation_result _))
        =&gt; Contents_result_list (Cons_result o os)
      | (Manager_operation_result _, Cons_result _ _) =&gt;
        Contents_result_list (Cons_result o os)
      | _ =&gt;
        Pervasives.failwith &quot;cannot decode ill-formed operation result&quot; % string
      end
    end in
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;operation.alpha.contents_list_result&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.conv to_list of_list None
      (Data_encoding.__list_value None contents_result_encoding)).

Reserved Notation &quot;'contents_and_result_list&quot;.

Inductive contents_and_result_list_gadt : Set :=
| Single_and_result : forall {kind : Set},
  Alpha_context.contents kind -&gt; contents_result kind -&gt;
  contents_and_result_list_gadt
| Cons_and_result : forall {kind : Set},
  Alpha_context.contents (Alpha_context.Kind.manager kind) -&gt;
  contents_result (Alpha_context.Kind.manager kind) -&gt;
  contents_and_result_list_gadt -&gt; contents_and_result_list_gadt

where &quot;'contents_and_result_list&quot; := (fun (kind : Set) =&gt;
  contents_and_result_list_gadt).

Definition contents_and_result_list := 'contents_and_result_list.

Reserved Notation &quot;'packed_contents_and_result_list&quot;.

Inductive packed_contents_and_result_list_gadt : Set :=
| Contents_and_result_list : forall {kind : Set},
  contents_and_result_list kind -&gt; packed_contents_and_result_list_gadt

where &quot;'packed_contents_and_result_list&quot; :=
  (packed_contents_and_result_list_gadt).

Definition packed_contents_and_result_list := 'packed_contents_and_result_list.

Definition contents_and_result_list_encoding
  : Data_encoding.encoding packed_contents_and_result_list :=
  let fix to_list (function_parameter : packed_contents_and_result_list)
    {struct function_parameter} : list packed_contents_and_result :=
    match function_parameter with
    | Contents_and_result_list (Single_and_result op res) =&gt;
      cons (Contents_and_result op res) []
    | Contents_and_result_list (Cons_and_result op res rest) =&gt;
      cons (Contents_and_result op res)
        (to_list (Contents_and_result_list rest))
    end in
  let fix of_list (function_parameter : list packed_contents_and_result)
    {struct function_parameter} : packed_contents_and_result_list :=
    match function_parameter with
    | [] =&gt;
      Pervasives.failwith
        &quot;cannot decode empty combined operation result&quot; % string
    | cons (Contents_and_result op res) [] =&gt;
      Contents_and_result_list (Single_and_result op res)
    | cons (Contents_and_result op res) rest =&gt;
      let 'Contents_and_result_list rest := of_list rest in
      match (op, rest) with
      |
        (Alpha_context.Manager_operation _,
          Single_and_result (Alpha_context.Manager_operation _) _) =&gt;
        Contents_and_result_list (Cons_and_result op res rest)
      | (Alpha_context.Manager_operation _, Cons_and_result _ _ _) =&gt;
        Contents_and_result_list (Cons_and_result op res rest)
      | _ =&gt;
        Pervasives.failwith
          &quot;cannot decode ill-formed combined operation result&quot; % string
      end
    end in
  Data_encoding.conv to_list of_list None
    (Data_encoding.__Variable.__list_value None contents_and_result_encoding).

Module operation_metadata.
  Record record {kind : Set} := {
    contents : contents_result_list kind }.
  Arguments record : clear implicits.
End operation_metadata.
Definition operation_metadata := operation_metadata.record.

Reserved Notation &quot;'packed_operation_metadata&quot;.

Inductive packed_operation_metadata_gadt : Set :=
| Operation_metadata : forall {kind : Set},
  operation_metadata kind -&gt; packed_operation_metadata_gadt
| No_operation_metadata : packed_operation_metadata_gadt

where &quot;'packed_operation_metadata&quot; := (packed_operation_metadata_gadt).

Definition packed_operation_metadata := 'packed_operation_metadata.

Definition operation_metadata_encoding
  : Data_encoding.encoding packed_operation_metadata :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;operation.alpha.result&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      (cons
        (Data_encoding.__case_value &quot;Operation_metadata&quot; % string None
          (Data_encoding.Tag 0) contents_result_list_encoding
          (fun function_parameter =&gt;
            match function_parameter with
            | Operation_metadata {| operation_metadata.contents := contents |}
              =&gt; Some (Contents_result_list contents)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let 'Contents_result_list contents := function_parameter in
            Operation_metadata {| operation_metadata.contents := contents |}))
        (cons
          (Data_encoding.__case_value &quot;No_operation_metadata&quot; % string None
            (Data_encoding.Tag 1) Data_encoding.empty
            (fun function_parameter =&gt;
              match function_parameter with
              | No_operation_metadata =&gt; Some tt
              | _ =&gt; None
              end)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              No_operation_metadata)) []))).

Definition kind_equal {kind kind2 : Set}
  (op : Alpha_context.contents kind) (res : contents_result kind2)
  : option (eq kind kind2) :=
  match (op, res) with
  | (Alpha_context.Endorsement _, Endorsement_result _) =&gt; Some Eq
  | (Alpha_context.Endorsement _, _) =&gt; None
  | (Alpha_context.Seed_nonce_revelation _, Seed_nonce_revelation_result _) =&gt;
    Some Eq
  | (Alpha_context.Seed_nonce_revelation _, _) =&gt; None
  |
    (Alpha_context.Double_endorsement_evidence _,
      Double_endorsement_evidence_result _) =&gt; Some Eq
  | (Alpha_context.Double_endorsement_evidence _, _) =&gt; None
  | (Alpha_context.Double_baking_evidence _, Double_baking_evidence_result _) =&gt;
    Some Eq
  | (Alpha_context.Double_baking_evidence _, _) =&gt; None
  | (Alpha_context.Activate_account _, Activate_account_result _) =&gt; Some Eq
  | (Alpha_context.Activate_account _, _) =&gt; None
  | (Alpha_context.Proposals _, Proposals_result) =&gt; Some Eq
  | (Alpha_context.Proposals _, _) =&gt; None
  | (Alpha_context.Ballot _, Ballot_result) =&gt; Some Eq
  | (Alpha_context.Ballot _, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Reveal_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Reveal_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Reveal_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Reveal_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |}, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Transaction_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Transaction_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Transaction_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Transaction_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |}, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Origination_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Origination_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Origination_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Origination_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |}, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Delegation_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Delegation_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Delegation_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Delegation_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |}, _) =&gt; None
  end.

Fixpoint kind_equal_list {kind kind2 : Set}
  (contents : Alpha_context.contents_list kind)
  (res : contents_result_list kind2) {struct contents}
  : option (eq kind kind2) :=
  match (contents, res) with
  | (Alpha_context.Single op, Single_result res) =&gt;
    match kind_equal op res with
    | None =&gt; None
    | Some Eq =&gt; Some Eq
    end
  | (Alpha_context.Cons op ops, Cons_result res ress) =&gt;
    match kind_equal op res with
    | None =&gt; None
    | Some Eq =&gt;
      match kind_equal_list ops ress with
      | None =&gt; None
      | Some Eq =&gt; Some Eq
      end
    end
  | _ =&gt; None
  end.

Fixpoint pack_contents_list {kind : Set}
  (contents : Alpha_context.contents_list kind)
  (res : contents_result_list kind) {struct contents}
  : contents_and_result_list kind :=
  match (contents, res) with
  | (Alpha_context.Single op, Single_result res) =&gt; Single_and_result op res
  | (Alpha_context.Cons op ops, Cons_result res ress) =&gt;
    Cons_and_result op res (pack_contents_list ops ress)
  |
    (Alpha_context.Single (Alpha_context.Manager_operation _),
      Cons_result (Manager_operation_result _) (Single_result _)) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Failed _ _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Skipped _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Applied _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Backtracked _ _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  | (Alpha_context.Single _, Cons_result _ _) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  end.

Fixpoint unpack_contents_list {kind : Set}
  (function_parameter : contents_and_result_list kind)
  {struct function_parameter}
  : Alpha_context.contents_list kind * contents_result_list kind :=
  match function_parameter with
  | Single_and_result op res =&gt; ((Alpha_context.Single op), (Single_result res))
  | Cons_and_result op res rest =&gt;
    let '(ops, ress) := unpack_contents_list rest in
    ((Alpha_context.Cons op ops), (Cons_result res ress))
  end.

Fixpoint to_list (function_parameter : packed_contents_result_list)
  {struct function_parameter} : list packed_contents_result :=
  match function_parameter with
  | Contents_result_list (Single_result o) =&gt; cons (Contents_result o) []
  | Contents_result_list (Cons_result o os) =&gt;
    cons (Contents_result o) (to_list (Contents_result_list os))
  end.

Fixpoint of_list (function_parameter : list packed_contents_result)
  {struct function_parameter} : packed_contents_result_list :=
  match function_parameter with
  | [] =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | cons (Contents_result o) [] =&gt; Contents_result_list (Single_result o)
  | cons (Contents_result o) os =&gt;
    let 'Contents_result_list os := of_list os in
    match (o, os) with
    | (Manager_operation_result _, Single_result (Manager_operation_result _))
      =&gt; Contents_result_list (Cons_result o os)
    | (Manager_operation_result _, Cons_result _ _) =&gt;
      Contents_result_list (Cons_result o os)
    | _ =&gt;
      Pervasives.failwith
        &quot;Operation result list of length &gt; 1 should only contains manager operations result.&quot;
          % string
    end
  end.

Definition operation_data_and_metadata_encoding
  : Data_encoding.encoding
    (Alpha_context.packed_protocol_data * packed_operation_metadata) :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;operation.alpha.operation_with_metadata&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      (cons
        (Data_encoding.__case_value &quot;Operation_with_metadata&quot; % string None
          (Data_encoding.Tag 0)
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;contents&quot; % string
              (Data_encoding.dynamic_size None contents_and_result_list_encoding))
            (Data_encoding.opt None None &quot;signature&quot; % string Signature.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | (Alpha_context.Operation_data _, No_operation_metadata) =&gt; None
            | (Alpha_context.Operation_data op, Operation_metadata res) =&gt;
              match
                kind_equal_list (Alpha_context.protocol_data.contents op)
                  (operation_metadata.contents res) with
              | None =&gt;
                Pervasives.failwith
                  &quot;cannot decode inconsistent combined operation result&quot; %
                    string
              | Some Eq =&gt;
                Some
                  ((Contents_and_result_list
                    (pack_contents_list
                      (Alpha_context.protocol_data.contents op)
                      (operation_metadata.contents res))),
                    (Alpha_context.protocol_data.signature op))
              end
            end)
          (fun function_parameter =&gt;
            let '(Contents_and_result_list contents, signature) :=
              function_parameter in
            let '(op_contents, res_contents) := unpack_contents_list contents in
            ((Alpha_context.Operation_data
              {| Alpha_context.protocol_data.contents := op_contents;
                Alpha_context.protocol_data.signature := signature |}),
              (Operation_metadata
                {| operation_metadata.contents := res_contents |}))))
        (cons
          (Data_encoding.__case_value &quot;Operation_without_metadata&quot; % string None
            (Data_encoding.Tag 1)
            (Data_encoding.obj2
              (Data_encoding.req None None &quot;contents&quot; % string
                (Data_encoding.dynamic_size None
                  Alpha_context.Operation.contents_list_encoding))
              (Data_encoding.opt None None &quot;signature&quot; % string
                Signature.encoding))
            (fun function_parameter =&gt;
              match function_parameter with
              | (Alpha_context.Operation_data op, No_operation_metadata) =&gt;
                Some
                  ((Alpha_context.Contents_list
                    (Alpha_context.protocol_data.contents op)),
                    (Alpha_context.protocol_data.signature op))
              | (Alpha_context.Operation_data _, Operation_metadata _) =&gt; None
              end)
            (fun function_parameter =&gt;
              let '(Alpha_context.Contents_list contents, signature) :=
                function_parameter in
              ((Alpha_context.Operation_data
                {| Alpha_context.protocol_data.contents := contents;
                  Alpha_context.protocol_data.signature := signature |}),
                No_operation_metadata))) []))).

Module block_metadata.
  Record record := {
    baker : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    level : Alpha_context.Level.t;
    voting_period_kind : Alpha_context.Voting_period.kind;
    nonce_hash : option Nonce_hash.t;
    consumed_gas : Z.t;
    deactivated : list Signature.Public_key_hash.[S.SPublic_key_hash.t];
    balance_updates : Alpha_context.Delegate.balance_updates }.
End block_metadata.
Definition block_metadata := block_metadata.record.

Definition block_metadata_encoding : Data_encoding.encoding block_metadata :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;block_header.alpha.metadata&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          block_metadata.baker := baker;
            block_metadata.level := level;
            block_metadata.voting_period_kind := voting_period_kind;
            block_metadata.nonce_hash := nonce_hash;
            block_metadata.consumed_gas := consumed_gas;
            block_metadata.deactivated := deactivated;
            block_metadata.balance_updates := balance_updates
            |} := function_parameter in
        (baker, level, voting_period_kind, nonce_hash, consumed_gas,
          deactivated, balance_updates))
      (fun function_parameter =&gt;
        let
          '(baker, level, voting_period_kind, nonce_hash, consumed_gas,
            deactivated, balance_updates) := function_parameter in
        {| block_metadata.baker := baker; block_metadata.level := level;
          block_metadata.voting_period_kind := voting_period_kind;
          block_metadata.nonce_hash := nonce_hash;
          block_metadata.consumed_gas := consumed_gas;
          block_metadata.deactivated := deactivated;
          block_metadata.balance_updates := balance_updates |}) None
      (Data_encoding.obj7
        (Data_encoding.req None None &quot;baker&quot; % string
          Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
        (Data_encoding.req None None &quot;level&quot; % string
          Alpha_context.Level.encoding)
        (Data_encoding.req None None &quot;voting_period_kind&quot; % string
          Alpha_context.Voting_period.kind_encoding)
        (Data_encoding.req None None &quot;nonce_hash&quot; % string
          (Data_encoding.__option_value Nonce_hash.encoding))
        (Data_encoding.req None None &quot;consumed_gas&quot; % string
          (Data_encoding.check_size 10 Data_encoding.n))
        (Data_encoding.req None None &quot;deactivated&quot; % string
          (Data_encoding.__list_value None
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding]))
        (Data_encoding.req None None &quot;balance_updates&quot; % string
          Alpha_context.Delegate.balance_updates_encoding))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="apply_results.mli">
  <div class="col-md-6">
    <a href="#apply_results.mli"><code>apply_results.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Result of applying an operation, can be used for experimenting
    with protocol updates, by clients to print out a summary of the
    operation at pre-injection simulation and at confirmation time,
    and by block explorers. *)

open Alpha_context

(** Result of applying a {!Operation.t}. Follows the same structure. *)
type 'kind operation_metadata = {contents : 'kind contents_result_list}

and packed_operation_metadata =
  | Operation_metadata : 'kind operation_metadata -&gt; packed_operation_metadata
  | No_operation_metadata : packed_operation_metadata

(** Result of applying a {!Operation.contents_list}. Follows the same structure. *)
and 'kind contents_result_list =
  | Single_result : 'kind contents_result -&gt; 'kind contents_result_list
  | Cons_result :
      'kind Kind.manager contents_result
      * 'rest Kind.manager contents_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_result_list

and packed_contents_result_list =
  | Contents_result_list :
      'kind contents_result_list
      -&gt; packed_contents_result_list

(** Result of applying an {!Operation.contents}. Follows the same structure. *)
and 'kind contents_result =
  | Endorsement_result : {
      balance_updates : Delegate.balance_updates;
      delegate : Signature.Public_key_hash.t;
      slots : int list;
    }
      -&gt; Kind.endorsement contents_result
  | Seed_nonce_revelation_result :
      Delegate.balance_updates
      -&gt; Kind.seed_nonce_revelation contents_result
  | Double_endorsement_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_endorsement_evidence contents_result
  | Double_baking_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_baking_evidence contents_result
  | Activate_account_result :
      Delegate.balance_updates
      -&gt; Kind.activate_account contents_result
  | Proposals_result : Kind.proposals contents_result
  | Ballot_result : Kind.ballot contents_result
  | Manager_operation_result : {
      balance_updates : Delegate.balance_updates;
      operation_result : 'kind manager_operation_result;
      internal_operation_results : packed_internal_operation_result list;
    }
      -&gt; 'kind Kind.manager contents_result

and packed_contents_result =
  | Contents_result : 'kind contents_result -&gt; packed_contents_result

(** The result of an operation in the queue. [Skipped] ones should
    always be at the tail, and after a single [Failed]. *)
and 'kind manager_operation_result =
  | Applied of 'kind successful_manager_operation_result
  | Backtracked of
      'kind successful_manager_operation_result * error list option
  | Failed : 'kind Kind.manager * error list -&gt; 'kind manager_operation_result
  | Skipped : 'kind Kind.manager -&gt; 'kind manager_operation_result

(** Result of applying a {!manager_operation_content}, either internal
    or external. *)
and _ successful_manager_operation_result =
  | Reveal_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.reveal successful_manager_operation_result
  | Transaction_result : {
      storage : Script.expr option;
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
      allocated_destination_contract : bool;
    }
      -&gt; Kind.transaction successful_manager_operation_result
  | Origination_result : {
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
    }
      -&gt; Kind.origination successful_manager_operation_result
  | Delegation_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.delegation successful_manager_operation_result

and packed_successful_manager_operation_result =
  | Successful_manager_result :
      'kind successful_manager_operation_result
      -&gt; packed_successful_manager_operation_result

and packed_internal_operation_result =
  | Internal_operation_result :
      'kind internal_operation * 'kind manager_operation_result
      -&gt; packed_internal_operation_result

(** Serializer for {!packed_operation_result}. *)
val operation_metadata_encoding : packed_operation_metadata Data_encoding.t

val operation_data_and_metadata_encoding :
  (Operation.packed_protocol_data * packed_operation_metadata) Data_encoding.t

type 'kind contents_and_result_list =
  | Single_and_result :
      'kind Alpha_context.contents * 'kind contents_result
      -&gt; 'kind contents_and_result_list
  | Cons_and_result :
      'kind Kind.manager Alpha_context.contents
      * 'kind Kind.manager contents_result
      * 'rest Kind.manager contents_and_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_and_result_list

type packed_contents_and_result_list =
  | Contents_and_result_list :
      'kind contents_and_result_list
      -&gt; packed_contents_and_result_list

val contents_and_result_list_encoding :
  packed_contents_and_result_list Data_encoding.t

val pack_contents_list :
  'kind contents_list -&gt;
  'kind contents_result_list -&gt;
  'kind contents_and_result_list

val unpack_contents_list :
  'kind contents_and_result_list -&gt;
  'kind contents_list * 'kind contents_result_list

val to_list : packed_contents_result_list -&gt; packed_contents_result list

val of_list : packed_contents_result list -&gt; packed_contents_result_list

type ('a, 'b) eq = Eq : ('a, 'a) eq

val kind_equal_list :
  'kind contents_list -&gt;
  'kind2 contents_result_list -&gt;
  ('kind, 'kind2) eq option

type block_metadata = {
  baker : Signature.Public_key_hash.t;
  level : Level.t;
  voting_period_kind : Voting_period.kind;
  nonce_hash : Nonce_hash.t option;
  consumed_gas : Z.t;
  deactivated : Signature.Public_key_hash.t list;
  balance_updates : Delegate.balance_updates;
}

val block_metadata_encoding : block_metadata Data_encoding.encoding
</pre>
  </div>
  <div class="col-md-6">
    <a href="#apply_results.mli"><code>Apply_results_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Nonce_hash.

Module contents_result.
  Module Endorsement_result.
    Record record {balance_updates delegate slots : Set} := {
      balance_updates : balance_updates;
      delegate : delegate;
      slots : slots }.
    Arguments record : clear implicits.
  End Endorsement_result.
  Definition Endorsement_result := Endorsement_result.record.
  
  Module Manager_operation_result.
    Record record {balance_updates operation_result internal_operation_results :
      Set} := {
      balance_updates : balance_updates;
      operation_result : operation_result;
      internal_operation_results : internal_operation_results }.
    Arguments record : clear implicits.
  End Manager_operation_result.
  Definition Manager_operation_result := Manager_operation_result.record.
End contents_result.

Module successful_manager_operation_result.
  Module Reveal_result.
    Record record {consumed_gas : Set} := {
      consumed_gas : consumed_gas }.
    Arguments record : clear implicits.
  End Reveal_result.
  Definition Reveal_result := Reveal_result.record.
  
  Module Transaction_result.
    Record record {storage big_map_diff balance_updates originated_contracts
      consumed_gas storage_size paid_storage_size_diff
      allocated_destination_contract : Set} := {
      storage : storage;
      big_map_diff : big_map_diff;
      balance_updates : balance_updates;
      originated_contracts : originated_contracts;
      consumed_gas : consumed_gas;
      storage_size : storage_size;
      paid_storage_size_diff : paid_storage_size_diff;
      allocated_destination_contract : allocated_destination_contract }.
    Arguments record : clear implicits.
  End Transaction_result.
  Definition Transaction_result := Transaction_result.record.
  
  Module Origination_result.
    Record record {big_map_diff balance_updates originated_contracts
      consumed_gas storage_size paid_storage_size_diff : Set} := {
      big_map_diff : big_map_diff;
      balance_updates : balance_updates;
      originated_contracts : originated_contracts;
      consumed_gas : consumed_gas;
      storage_size : storage_size;
      paid_storage_size_diff : paid_storage_size_diff }.
    Arguments record : clear implicits.
  End Origination_result.
  Definition Origination_result := Origination_result.record.
  
  Module Delegation_result.
    Record record {consumed_gas : Set} := {
      consumed_gas : consumed_gas }.
    Arguments record : clear implicits.
  End Delegation_result.
  Definition Delegation_result := Delegation_result.record.
End successful_manager_operation_result.

Reserved Notation &quot;'operation_metadata&quot;.
Reserved Notation &quot;'packed_operation_metadata&quot;.
Reserved Notation &quot;'contents_result_list&quot;.
Reserved Notation &quot;'packed_contents_result_list&quot;.
Reserved Notation &quot;'contents_result&quot;.
Reserved Notation &quot;'packed_contents_result&quot;.
Reserved Notation &quot;'manager_operation_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result&quot;.
Reserved Notation &quot;'packed_successful_manager_operation_result&quot;.
Reserved Notation &quot;'packed_internal_operation_result&quot;.

Module operation_metadata.
  Record record {contents : Set} := {
    contents : contents }.
  Arguments record : clear implicits.
End operation_metadata.
Definition operation_metadata_skeleton := operation_metadata.record.

Inductive packed_operation_metadata_gadt : Set :=
| Operation_metadata : forall {kind : Set},
  'operation_metadata kind -&gt; packed_operation_metadata_gadt
| No_operation_metadata : packed_operation_metadata_gadt

with contents_result_list_gadt : Set :=
| Single_result : forall {kind : Set},
  'contents_result kind -&gt; contents_result_list_gadt
| Cons_result : forall {kind : Set},
  'contents_result (Alpha_context.Kind.manager kind) -&gt;
  contents_result_list_gadt -&gt; contents_result_list_gadt

with packed_contents_result_list_gadt : Set :=
| Contents_result_list : forall {kind : Set},
  'contents_result_list kind -&gt; packed_contents_result_list_gadt

with contents_result_gadt : Set :=
| Endorsement_result :
  contents_result.Endorsement_result Alpha_context.Delegate.balance_updates
    Signature.Public_key_hash.[S.SPublic_key_hash.t] (list Z) -&gt;
  contents_result_gadt
| Seed_nonce_revelation_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Double_endorsement_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Double_baking_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Activate_account_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result_gadt
| Proposals_result : contents_result_gadt
| Ballot_result : contents_result_gadt
| Manager_operation_result : forall {kind : Set},
  contents_result.Manager_operation_result
    Alpha_context.Delegate.balance_updates ('manager_operation_result kind)
    (list 'packed_internal_operation_result) -&gt; contents_result_gadt

with packed_contents_result_gadt : Set :=
| Contents_result : forall {kind : Set},
  'contents_result kind -&gt; packed_contents_result_gadt

with manager_operation_result_gadt : Set :=
| Applied : forall {kind : Set},
  'successful_manager_operation_result kind -&gt; manager_operation_result_gadt
| Backtracked : forall {kind : Set},
  'successful_manager_operation_result kind -&gt;
  option (list Error_monad.__error) -&gt; manager_operation_result_gadt
| Failed : forall {kind : Set},
  Alpha_context.Kind.manager kind -&gt; list Error_monad.__error -&gt;
  manager_operation_result_gadt
| Skipped : forall {kind : Set},
  Alpha_context.Kind.manager kind -&gt; manager_operation_result_gadt

with successful_manager_operation_result_gadt : Set :=
| Reveal_result :
  successful_manager_operation_result.Reveal_result Z.t -&gt;
  successful_manager_operation_result_gadt
| Transaction_result :
  successful_manager_operation_result.Transaction_result
    (option Alpha_context.Script.expr)
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t bool -&gt; successful_manager_operation_result_gadt
| Origination_result :
  successful_manager_operation_result.Origination_result
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t -&gt; successful_manager_operation_result_gadt
| Delegation_result :
  successful_manager_operation_result.Delegation_result Z.t -&gt;
  successful_manager_operation_result_gadt

with packed_successful_manager_operation_result_gadt : Set :=
| Successful_manager_result : forall {kind : Set},
  'successful_manager_operation_result kind -&gt;
  packed_successful_manager_operation_result_gadt

with packed_internal_operation_result_gadt : Set :=
| Internal_operation_result : forall {kind : Set},
  Alpha_context.internal_operation kind -&gt; 'manager_operation_result kind -&gt;
  packed_internal_operation_result_gadt

where &quot;'operation_metadata&quot; := (fun (kind : Set) =&gt;
  operation_metadata_skeleton ('contents_result_list kind))
and &quot;'packed_operation_metadata&quot; := (packed_operation_metadata_gadt)
and &quot;'contents_result_list&quot; := (fun (kind : Set) =&gt; contents_result_list_gadt)
and &quot;'packed_contents_result_list&quot; := (packed_contents_result_list_gadt)
and &quot;'contents_result&quot; := (fun (kind : Set) =&gt; contents_result_gadt)
and &quot;'packed_contents_result&quot; := (packed_contents_result_gadt)
and &quot;'manager_operation_result&quot; := (fun (kind : Set) =&gt;
  manager_operation_result_gadt)
and &quot;'successful_manager_operation_result&quot; := (fun (_ : Set) =&gt;
  successful_manager_operation_result_gadt)
and &quot;'packed_successful_manager_operation_result&quot; :=
  (packed_successful_manager_operation_result_gadt)
and &quot;'packed_internal_operation_result&quot; :=
  (packed_internal_operation_result_gadt).

Definition operation_metadata := 'operation_metadata.
Definition packed_operation_metadata := 'packed_operation_metadata.
Definition contents_result_list := 'contents_result_list.
Definition packed_contents_result_list := 'packed_contents_result_list.
Definition contents_result := 'contents_result.
Definition packed_contents_result := 'packed_contents_result.
Definition manager_operation_result := 'manager_operation_result.
Definition successful_manager_operation_result :=
  'successful_manager_operation_result.
Definition packed_successful_manager_operation_result :=
  'packed_successful_manager_operation_result.
Definition packed_internal_operation_result :=
  'packed_internal_operation_result.

Parameter operation_metadata_encoding :
  Data_encoding.t packed_operation_metadata.

Parameter operation_data_and_metadata_encoding :
  Data_encoding.t
    (Alpha_context.Operation.packed_protocol_data * packed_operation_metadata).

Reserved Notation &quot;'contents_and_result_list&quot;.

Inductive contents_and_result_list_gadt : Set :=
| Single_and_result : forall {kind : Set},
  Alpha_context.contents kind -&gt; contents_result kind -&gt;
  contents_and_result_list_gadt
| Cons_and_result : forall {kind : Set},
  Alpha_context.contents (Alpha_context.Kind.manager kind) -&gt;
  contents_result (Alpha_context.Kind.manager kind) -&gt;
  contents_and_result_list_gadt -&gt; contents_and_result_list_gadt

where &quot;'contents_and_result_list&quot; := (fun (kind : Set) =&gt;
  contents_and_result_list_gadt).

Definition contents_and_result_list := 'contents_and_result_list.

Reserved Notation &quot;'packed_contents_and_result_list&quot;.

Inductive packed_contents_and_result_list_gadt : Set :=
| Contents_and_result_list : forall {kind : Set},
  contents_and_result_list kind -&gt; packed_contents_and_result_list_gadt

where &quot;'packed_contents_and_result_list&quot; :=
  (packed_contents_and_result_list_gadt).

Definition packed_contents_and_result_list := 'packed_contents_and_result_list.

Parameter contents_and_result_list_encoding :
  Data_encoding.t packed_contents_and_result_list.

Parameter pack_contents_list : forall {kind : Set},
  Alpha_context.contents_list kind -&gt; contents_result_list kind -&gt;
  contents_and_result_list kind.

Parameter unpack_contents_list : forall {kind : Set},
  contents_and_result_list kind -&gt;
  Alpha_context.contents_list kind * contents_result_list kind.

Parameter to_list : packed_contents_result_list -&gt; list packed_contents_result.

Parameter of_list : list packed_contents_result -&gt; packed_contents_result_list.

Reserved Notation &quot;'eq&quot;.

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where &quot;'eq&quot; := (fun (a b : Set) =&gt; eq_gadt).

Definition eq := 'eq.

Parameter kind_equal_list : forall {kind kind2 : Set},
  Alpha_context.contents_list kind -&gt; contents_result_list kind2 -&gt;
  option (eq kind kind2).

Module block_metadata.
  Record record := {
    baker : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    level : Alpha_context.Level.t;
    voting_period_kind : Alpha_context.Voting_period.kind;
    nonce_hash : option Nonce_hash.t;
    consumed_gas : Z.t;
    deactivated : list Signature.Public_key_hash.[S.SPublic_key_hash.t];
    balance_updates : Alpha_context.Delegate.balance_updates }.
End block_metadata.
Definition block_metadata := block_metadata.record.

Parameter block_metadata_encoding : Data_encoding.encoding block_metadata.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="baking.ml">
  <div class="col-md-6">
    <a href="#baking.ml"><code>baking.ml</code></a>&nbsp;<span class="label label-danger">19 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Misc

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_fitness_gap of int64 * int64</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Timestamp_too_early of Timestamp.t * Timestamp.t</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unexpected_endorsement</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Invalid_block_signature of Block_hash.t * Signature.Public_key_hash.t</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_stamp</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;baking.timestamp_too_early&quot;
    ~title:&quot;Block forged too early&quot;
    ~description:
      &quot;The block timestamp is before the first slot for this baker at this \
       level&quot;
    ~pp:(fun ppf (r, p) -&gt;
      Format.fprintf
        ppf
        &quot;Block forged too early (%a is before %a)&quot;
        Time.pp_hum
        p
        Time.pp_hum
        r)
    Data_encoding.(
      obj2 (req &quot;minimum&quot; Time.encoding) (req &quot;provided&quot; Time.encoding))
    (function Timestamp_too_early (r, p) -&gt; Some (r, p) | _ -&gt; None)
    (fun (r, p) -&gt; Timestamp_too_early (r, p)) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.invalid_fitness_gap&quot;
    ~title:&quot;Invalid fitness gap&quot;
    ~description:&quot;The gap of fitness is out of bounds&quot;
    ~pp:(fun ppf (m, g) -&gt;
      Format.fprintf ppf &quot;The gap of fitness %Ld is not between 0 and %Ld&quot; g m)
    Data_encoding.(obj2 (req &quot;maximum&quot; int64) (req &quot;provided&quot; int64))
    (function Invalid_fitness_gap (m, g) -&gt; Some (m, g) | _ -&gt; None)
    (fun (m, g) -&gt; Invalid_fitness_gap (m, g)) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.invalid_block_signature&quot;
    ~title:&quot;Invalid block signature&quot;
    ~description:&quot;A block was not signed with the expected private key.&quot;
    ~pp:(fun ppf (block, pkh) -&gt;
      Format.fprintf
        ppf
        &quot;Invalid signature for block %a. Expected: %a.&quot;
        Block_hash.pp_short
        block
        Signature.Public_key_hash.pp_short
        pkh)
    Data_encoding.(
      obj2
        (req &quot;block&quot; Block_hash.encoding)
        (req &quot;expected&quot; Signature.Public_key_hash.encoding))
    (function
      | Invalid_block_signature (block, pkh) -&gt; Some (block, pkh) | _ -&gt; None)
    (fun (block, pkh) -&gt; Invalid_block_signature (block, pkh)) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.invalid_signature&quot;
    ~title:&quot;Invalid block signature&quot;
    ~description:&quot;The block's signature is invalid&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid block signature&quot;)
    Data_encoding.empty
    (function Invalid_signature -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_signature) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.insufficient_proof_of_work&quot;
    ~title:&quot;Insufficient block proof-of-work stamp&quot;
    ~description:&quot;The block's proof-of-work stamp is insufficient&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Insufficient proof-of-work stamp&quot;)
    Data_encoding.empty
    (function Invalid_stamp -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_stamp) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.unexpected_endorsement&quot;
    ~title:&quot;Endorsement from unexpected delegate&quot;
    ~description:
      &quot;The operation is signed by a delegate without endorsement rights.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;The endorsement is signed by a delegate without endorsement rights.&quot;)
    Data_encoding.unit
    (function Unexpected_endorsement -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_endorsement)</abbr>

let minimal_time c priority pred_timestamp =
  let priority = Int32.of_int priority in
  let rec cumsum_time_between_blocks acc durations p =
    if Compare.Int32.( &lt;= ) p 0l then ok acc
    else
      match durations with
      | [] -&gt;
          cumsum_time_between_blocks acc [Period.one_minute] p
      | [last] -&gt;
          Period.mult p last &gt;&gt;? fun period -&gt; Timestamp.(acc +? period)
      | first :: durations -&gt;
          Timestamp.(acc +? first)
          &gt;&gt;? fun acc -&gt;
          let p = Int32.pred p in
          cumsum_time_between_blocks acc durations p
  in
  Lwt.return
    (cumsum_time_between_blocks
       pred_timestamp
       (Constants.time_between_blocks c)
       (Int32.succ priority))

let earlier_predecessor_timestamp ctxt level =
  let current = Level.current ctxt in
  let current_timestamp = Timestamp.current ctxt in
  let gap = Level.diff level current in
  let step = List.hd (Constants.time_between_blocks ctxt) in
  if Compare.Int32.(gap &lt; 1l) then
    failwith &quot;Baking.earlier_block_timestamp: past block.&quot;
  else
    Lwt.return (Period.mult (Int32.pred gap) step)
    &gt;&gt;=? fun delay -&gt;
    Lwt.return Timestamp.(current_timestamp +? delay)
    &gt;&gt;=? fun result -&gt; return result

let check_timestamp c priority pred_timestamp =
  minimal_time c priority pred_timestamp
  &gt;&gt;=? fun minimal_time -&gt;
  let timestamp = Alpha_context.Timestamp.current c in
  Lwt.return
    (record_trace
       <abbr class="mark-error" title="Values of extensible types are not handled">(Timestamp_too_early (minimal_time, timestamp))</abbr>
       Timestamp.(timestamp -? minimal_time))

let check_baking_rights c {Block_header.priority; _} pred_timestamp =
  let level = Level.current c in
  Roll.baking_rights_owner c level ~priority
  &gt;&gt;=? fun delegate -&gt;
  check_timestamp c priority pred_timestamp
  &gt;&gt;=? fun block_delay -&gt; return (delegate, block_delay)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Incorrect_priority</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Incorrect_number_of_endorsements</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;incorrect_priority&quot;
    ~title:&quot;Incorrect priority&quot;
    ~description:&quot;Block priority must be non-negative.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;The block priority must be non-negative.&quot;)
    Data_encoding.unit
    (function Incorrect_priority -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Incorrect_priority)</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let description =
    &quot;The number of endorsements must be non-negative and at most the \
     endosers_per_block constant.&quot;
  in
  register_error_kind
    `Permanent
    ~id:&quot;incorrect_number_of_endorsements&quot;
    ~title:&quot;Incorrect number of endorsements&quot;
    ~description
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;%s&quot; description)
    Data_encoding.unit
    (function Incorrect_number_of_endorsements -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Incorrect_number_of_endorsements)</abbr>

let baking_reward ctxt ~block_priority:prio ~included_endorsements:num_endo =
  fail_unless Compare.Int.(prio &gt;= 0) <abbr class="mark-error" title="Values of extensible types are not handled">Incorrect_priority</abbr>
  &gt;&gt;=? fun () -&gt;
  let max_endorsements = Constants.endorsers_per_block ctxt in
  fail_unless
    Compare.Int.(num_endo &gt;= 0 &amp;&amp; num_endo &lt;= max_endorsements)
    <abbr class="mark-error" title="Values of extensible types are not handled">Incorrect_number_of_endorsements</abbr>
  &gt;&gt;=? fun () -&gt;
  let prio_factor_denominator = Int64.(succ (of_int prio)) in
  let endo_factor_numerator =
    Int64.of_int (8 + (2 * num_endo / max_endorsements))
  in
  let endo_factor_denominator = 10L in
  Lwt.return
    Tez.(
      Constants.block_reward ctxt *? endo_factor_numerator
      &gt;&gt;? fun val1 -&gt;
      val1 /? endo_factor_denominator
      &gt;&gt;? fun val2 -&gt; val2 /? prio_factor_denominator)

let endorsing_reward ctxt ~block_priority:prio n =
  if Compare.Int.(prio &gt;= 0) then
    Lwt.return
      Tez.(Constants.endorsement_reward ctxt /? Int64.(succ (of_int prio)))
    &gt;&gt;=? fun tez -&gt; Lwt.return Tez.(tez *? Int64.of_int n)
  else fail <abbr class="mark-error" title="Values of extensible types are not handled">Incorrect_priority</abbr>

let baking_priorities c level =
  let rec f priority =
    Roll.baking_rights_owner c level ~priority
    &gt;&gt;=? fun delegate -&gt; return (LCons (delegate, fun () -&gt; f (succ priority)))
  in
  f 0

let endorsement_rights c level =
  fold_left_s
    (fun acc slot -&gt;
      Roll.endorsement_rights_owner c level ~slot
      &gt;&gt;=? fun pk -&gt;
      let pkh = Signature.Public_key.hash pk in
      let right =
        match Signature.Public_key_hash.Map.find_opt pkh acc with
        | None -&gt;
            (pk, [slot], false)
        | Some (pk, slots, used) -&gt;
            (pk, slot :: slots, used)
      in
      return (Signature.Public_key_hash.Map.add pkh right acc))
    Signature.Public_key_hash.Map.empty
    (0 --&gt; (Constants.endorsers_per_block c - 1))

let check_endorsement_rights ctxt chain_id (op : Kind.endorsement Operation.t)
    =
  let current_level = Level.current ctxt in
  let (Single (Endorsement {level; _})) = op.protocol_data.contents in
  ( if Raw_level.(succ level = current_level.level) then
    return (Alpha_context.allowed_endorsements ctxt)
  else endorsement_rights ctxt (Level.from_raw ctxt level) )
  &gt;&gt;=? fun endorsements -&gt;
  match
    Signature.Public_key_hash.Map.fold (* no find_first *)
      (fun pkh (pk, slots, used) acc -&gt;
        match Operation.check_signature_sync pk chain_id op with
        | Error _ -&gt;
            acc
        | Ok () -&gt;
            Some (pkh, slots, used))
      endorsements
      None
  with
  | None -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">Unexpected_endorsement</abbr>
  | Some v -&gt;
      return v

let select_delegate delegate delegate_list max_priority =
  let rec loop acc l n =
    if Compare.Int.(n &gt;= max_priority) then return (List.rev acc)
    else
      let (LCons (pk, t)) = l in
      let acc =
        if
          Signature.Public_key_hash.equal
            delegate
            (Signature.Public_key.hash pk)
        then n :: acc
        else acc
      in
      t () &gt;&gt;=? fun t -&gt; loop acc t (succ n)
  in
  loop [] delegate_list 0

let first_baking_priorities ctxt ?(max_priority = 32) delegate level =
  baking_priorities ctxt level
  &gt;&gt;=? fun delegate_list -&gt; select_delegate delegate delegate_list max_priority

let check_hash hash stamp_threshold =
  let bytes = Block_hash.to_bytes hash in
  let word = MBytes.get_int64 bytes 0 in
  Compare.Uint64.(word &lt;= stamp_threshold)

let check_header_proof_of_work_stamp shell contents stamp_threshold =
  let hash =
    Block_header.hash
      {shell; protocol_data = {contents; signature = Signature.zero}}
  in
  check_hash hash stamp_threshold

let check_proof_of_work_stamp ctxt block =
  let proof_of_work_threshold = Constants.proof_of_work_threshold ctxt in
  if
    check_header_proof_of_work_stamp
      block.Block_header.shell
      block.protocol_data.contents
      proof_of_work_threshold
  then return_unit
  else fail <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_stamp</abbr>

let check_signature block chain_id key =
  let check_signature key
      {Block_header.shell; protocol_data = {contents; signature}} =
    let unsigned_header =
      Data_encoding.Binary.to_bytes_exn
        Block_header.unsigned_encoding
        (shell, contents)
    in
    Signature.check
      ~watermark:(Block_header chain_id)
      key
      signature
      unsigned_header
  in
  if check_signature key block then return_unit
  else
    fail
      <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_block_signature
         (Block_header.hash block, Signature.Public_key.hash key))</abbr>

let max_fitness_gap _ctxt = 1L

let check_fitness_gap ctxt (block : Block_header.t) =
  let current_fitness = Fitness.current ctxt in
  Lwt.return (Fitness.to_int64 block.shell.fitness)
  &gt;&gt;=? fun announced_fitness -&gt;
  let gap = Int64.sub announced_fitness current_fitness in
  if Compare.Int64.(gap &lt;= 0L || max_fitness_gap ctxt &lt; gap) then
    fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_fitness_gap (max_fitness_gap ctxt, gap))</abbr>
  else return_unit

let last_of_a_cycle ctxt l =
  Compare.Int32.(
    Int32.succ l.Level.cycle_position = Constants.blocks_per_cycle ctxt)

let dawn_of_a_new_cycle ctxt =
  let level = Level.current ctxt in
  if last_of_a_cycle ctxt level then return_some level.cycle else return_none

let minimum_allowed_endorsements ctxt ~block_delay =
  let minimum = Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement =
    Int64.to_int
      (Period.to_seconds (Constants.delay_per_missing_endorsement ctxt))
  in
  let reduced_time_constraint =
    let delay = Int64.to_int (Period.to_seconds block_delay) in
    if Compare.Int.(delay_per_missing_endorsement = 0) then delay
    else delay / delay_per_missing_endorsement
  in
  Compare.Int.max 0 (minimum - reduced_time_constraint)

let minimal_valid_time ctxt ~priority ~endorsing_power =
  let predecessor_timestamp = Timestamp.current ctxt in
  minimal_time ctxt priority predecessor_timestamp
  &gt;&gt;=? fun minimal_time -&gt;
  let minimal_required_endorsements = Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement =
    Constants.delay_per_missing_endorsement ctxt
  in
  let missing_endorsements =
    Compare.Int.max 0 (minimal_required_endorsements - endorsing_power)
  in
  match
    Period.mult
      (Int32.of_int missing_endorsements)
      delay_per_missing_endorsement
  with
  | Ok delay -&gt;
      return (Time.add minimal_time (Period.to_seconds delay))
  | Error _ as err -&gt;
      Lwt.return err
</pre>
  </div>
  <div class="col-md-6">
    <a href="#baking.ml"><code>Baking.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Misc.

Import Alpha_context.

Import Misc.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition minimal_time
  (c : Alpha_context.context) (priority : Z)
  (pred_timestamp : Alpha_context.Timestamp.time)
  : Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.time) :=
  let priority := Int32.of_int priority in
  let fix cumsum_time_between_blocks
    (acc : Alpha_context.Timestamp.time)
    (durations : list Alpha_context.Period.period)
    (p : Compare.Int32.[Compare.S.t]) {struct acc}
    : Error_monad.tzresult Alpha_context.Timestamp.time :=
    if
      Compare.Int32.[Compare.S.op_lteq] p
        (* ‚ùå Constant of type int32 is converted to int *)
        0 then
      Error_monad.ok acc
    else
      match durations with
      | [] =&gt;
        cumsum_time_between_blocks acc (cons Alpha_context.Period.one_minute [])
          p
      | cons last [] =&gt;
        Error_monad.op_gtgtquestion (Alpha_context.Period.mult p last)
          (fun period =&gt; Alpha_context.Timestamp.op_plusquestion acc period)
      | cons first durations =&gt;
        Error_monad.op_gtgtquestion
          (Alpha_context.Timestamp.op_plusquestion acc first)
          (fun acc =&gt;
            let p := Int32.pred p in
            cumsum_time_between_blocks acc durations p)
      end in
  Lwt.__return
    (cumsum_time_between_blocks pred_timestamp
      (Alpha_context.Constants.time_between_blocks c) (Int32.succ priority)).

Definition earlier_predecessor_timestamp
  (ctxt : Alpha_context.context) (level : Alpha_context.Level.level)
  : Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.time) :=
  let current := Alpha_context.Level.current ctxt in
  let current_timestamp := Alpha_context.Timestamp.current ctxt in
  let gap := Alpha_context.Level.diff level current in
  let step := List.hd (Alpha_context.Constants.time_between_blocks ctxt) in
  if
    Compare.Int32.[Compare.S.op_lt] gap
      (* ‚ùå Constant of type int32 is converted to int *)
      1 then
    Pervasives.failwith &quot;Baking.earlier_block_timestamp: past block.&quot; % string
  else
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Period.mult (Int32.pred gap) step))
      (fun delay =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Timestamp.op_plusquestion current_timestamp delay))
          (fun __result_value =&gt; Error_monad.__return __result_value)).

Definition check_timestamp
  (c : Alpha_context.context) (priority : Z)
  (pred_timestamp : Alpha_context.Timestamp.time)
  : Lwt.t (Error_monad.tzresult Alpha_context.Period.t) :=
  Error_monad.op_gtgteqquestion (minimal_time c priority pred_timestamp)
    (fun minimal_time =&gt;
      let timestamp := Alpha_context.Timestamp.current c in
      Lwt.__return
        (Error_monad.record_trace extensible_type_value
          (Alpha_context.Timestamp.op_minusquestion timestamp minimal_time))).

Definition check_baking_rights
  (c : Alpha_context.context)
  (function_parameter : Alpha_context.Block_header.contents)
  : Alpha_context.Timestamp.time -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.public_key * Alpha_context.Period.t)) :=
  let '{| Alpha_context.Block_header.contents.priority := priority |} :=
    function_parameter in
  fun pred_timestamp =&gt;
    let level := Alpha_context.Level.current c in
    Error_monad.op_gtgteqquestion
      (Alpha_context.Roll.baking_rights_owner c level priority)
      (fun delegate =&gt;
        Error_monad.op_gtgteqquestion
          (check_timestamp c priority pred_timestamp)
          (fun block_delay =&gt; Error_monad.__return (delegate, block_delay))).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition baking_reward
  (ctxt : Alpha_context.context) (prio : Compare.Int.[Compare.S.t])
  (num_endo : Compare.Int.[Compare.S.t])
  : Lwt.t (Error_monad.tzresult Alpha_context.Tez.tez) :=
  Error_monad.op_gtgteqquestion
    (Error_monad.fail_unless (Compare.Int.[Compare.S.op_gteq] prio 0)
      extensible_type_value)
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      let max_endorsements := Alpha_context.Constants.endorsers_per_block ctxt
        in
      Error_monad.op_gtgteqquestion
        (Error_monad.fail_unless
          (Pervasives.op_andand (Compare.Int.[Compare.S.op_gteq] num_endo 0)
            (Compare.Int.[Compare.S.op_lteq] num_endo max_endorsements))
          extensible_type_value)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          let prio_factor_denominator := Int64.succ (Int64.of_int prio) in
          let endo_factor_numerator :=
            Int64.of_int
              (Pervasives.op_plus 8
                (Pervasives.op_div (Pervasives.op_star 2 num_endo)
                  max_endorsements)) in
          let endo_factor_denominator :=
            (* ‚ùå Constant of type int64 is converted to int *)
            10 in
          Lwt.__return
            (Error_monad.op_gtgtquestion
              (Alpha_context.Tez.op_starquestion
                (Alpha_context.Constants.block_reward ctxt)
                endo_factor_numerator)
              (fun val1 =&gt;
                Error_monad.op_gtgtquestion
                  (Alpha_context.Tez.op_divquestion val1 endo_factor_denominator)
                  (fun val2 =&gt;
                    Alpha_context.Tez.op_divquestion val2
                      prio_factor_denominator))))).

Definition endorsing_reward
  (ctxt : Alpha_context.context) (prio : Compare.Int.[Compare.S.t]) (n : Z)
  : Lwt.t (Error_monad.tzresult Alpha_context.Tez.tez) :=
  if Compare.Int.[Compare.S.op_gteq] prio 0 then
    Error_monad.op_gtgteqquestion
      (Lwt.__return
        (Alpha_context.Tez.op_divquestion
          (Alpha_context.Constants.endorsement_reward ctxt)
          (Int64.succ (Int64.of_int prio))))
      (fun tez =&gt;
        Lwt.__return (Alpha_context.Tez.op_starquestion tez (Int64.of_int n)))
  else
    Error_monad.fail extensible_type_value.

Definition baking_priorities
  (c : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t (Error_monad.tzresult (Misc.lazy_list_t Alpha_context.public_key)) :=
  let fix f (priority : Z) {struct priority}
    : Lwt.t (Error_monad.tzresult (Misc.lazy_list_t Alpha_context.public_key)) :=
    Error_monad.op_gtgteqquestion
      (Alpha_context.Roll.baking_rights_owner c level priority)
      (fun delegate =&gt;
        Error_monad.__return
          (Misc.LCons delegate
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              f (Pervasives.succ priority)))) in
  f 0.

Definition endorsement_rights
  (c : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t
    (Error_monad.tzresult
      (Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
        (Alpha_context.public_key * list Z * bool))) :=
  Error_monad.fold_left_s
    (fun acc =&gt;
      fun slot =&gt;
        Error_monad.op_gtgteqquestion
          (Alpha_context.Roll.endorsement_rights_owner c level slot)
          (fun pk =&gt;
            let pkh := Signature.Public_key.[S.SPublic_key.__hash_value] pk in
            let right :=
              match
                Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.find_opt)
                  pkh acc with
              | None =&gt; (pk, (cons slot []), false)
              | Some (pk, slots, used) =&gt; (pk, (cons slot slots), used)
              end in
            Error_monad.__return
              (Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.add)
                pkh right acc)))
    Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.empty)
    (Misc.op_minusminusgt 0
      (Pervasives.op_minus (Alpha_context.Constants.endorsers_per_block c) 1)).

Definition check_endorsement_rights
  (ctxt : Alpha_context.context) (chain_id : Chain_id.[S.HASH.t])
  (op : Alpha_context.Operation.t Alpha_context.Kind.endorsement)
  : Lwt.t
    (Error_monad.tzresult
      (Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.key) *
        list Z * bool)) :=
  let current_level := Alpha_context.Level.current ctxt in
  let
    'Alpha_context.Single
      (Alpha_context.Endorsement {|
        Alpha_context.contents.Endorsement.level := level |}) :=
    Alpha_context.protocol_data.contents
      (Alpha_context.operation.protocol_data op) in
  Error_monad.op_gtgteqquestion
    (if
      Alpha_context.Raw_level.op_eq (Alpha_context.Raw_level.succ level)
        (Alpha_context.Level.t.level current_level) then
      Error_monad.__return (Alpha_context.allowed_endorsements ctxt)
    else
      endorsement_rights ctxt (Alpha_context.Level.from_raw ctxt None level))
    (fun endorsements =&gt;
      match
        Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.fold)
          (fun pkh =&gt;
            fun function_parameter =&gt;
              let '(pk, slots, used) := function_parameter in
              fun acc =&gt;
                match
                  Alpha_context.Operation.check_signature_sync pk chain_id op
                  with
                | Pervasives.Error _ =&gt; acc
                | Pervasives.Ok tt =&gt; Some (pkh, slots, used)
                end) endorsements None with
      | None =&gt; Error_monad.fail extensible_type_value
      | Some v =&gt; Error_monad.__return v
      end).

Definition select_delegate
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (delegate_list : Misc.lazy_list_t Signature.Public_key.[S.SPublic_key.t])
  (max_priority : Compare.Int.[Compare.S.t])
  : Lwt.t (Error_monad.tzresult (list Compare.Int.[Compare.S.t])) :=
  let fix loop
    (acc : list Compare.Int.[Compare.S.t])
    (l : Misc.lazy_list_t Signature.Public_key.[S.SPublic_key.t])
    (n : Compare.Int.[Compare.S.t]) {struct acc}
    : Lwt.t (Error_monad.tzresult (list Compare.Int.[Compare.S.t])) :=
    if Compare.Int.[Compare.S.op_gteq] n max_priority then
      Error_monad.__return (List.rev acc)
    else
      let 'Misc.LCons pk t := l in
      let acc :=
        if
          Signature.Public_key_hash.[S.SPublic_key_hash.equal] delegate
            (Signature.Public_key.[S.SPublic_key.__hash_value] pk) then
          cons n acc
        else
          acc in
      Error_monad.op_gtgteqquestion (t tt)
        (fun t =&gt; loop acc t (Pervasives.succ n)) in
  loop [] delegate_list 0.

Definition first_baking_priorities
  (ctxt : Alpha_context.context)
  (op_staroptstar : option Compare.Int.[Compare.S.t])
  : Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Alpha_context.Level.t -&gt;
  Lwt.t (Error_monad.tzresult (list Compare.Int.[Compare.S.t])) :=
  let max_priority :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; 32
    end in
  fun delegate =&gt;
    fun level =&gt;
      Error_monad.op_gtgteqquestion (baking_priorities ctxt level)
        (fun delegate_list =&gt;
          select_delegate delegate delegate_list max_priority).

Definition check_hash
  (__hash_value : Block_hash.[S.HASH.t])
  (stamp_threshold : Compare.Uint64.[Compare.S.t]) : bool :=
  let __bytes_value := Block_hash.[S.HASH.to_bytes] __hash_value in
  let word := MBytes.get_int64 __bytes_value 0 in
  Compare.Uint64.[Compare.S.op_lteq] word stamp_threshold.

Definition check_header_proof_of_work_stamp
  (shell : Block_header.shell_header)
  (contents : Alpha_context.Block_header.contents)
  (stamp_threshold : Compare.Uint64.[Compare.S.t]) : bool :=
  let __hash_value :=
    Alpha_context.Block_header.__hash_value
      {| Alpha_context.Block_header.t.shell := shell;
        Alpha_context.Block_header.t.protocol_data :=
          {| Alpha_context.Block_header.protocol_data.contents := contents;
            Alpha_context.Block_header.protocol_data.signature := Signature.zero
            |} |} in
  check_hash __hash_value stamp_threshold.

Definition check_proof_of_work_stamp
  (ctxt : Alpha_context.context) (block : Alpha_context.Block_header.t)
  : Lwt.t (Error_monad.tzresult unit) :=
  let proof_of_work_threshold :=
    Alpha_context.Constants.proof_of_work_threshold ctxt in
  if
    check_header_proof_of_work_stamp (Alpha_context.Block_header.t.shell block)
      (Alpha_context.Block_header.protocol_data.contents
        (Alpha_context.Block_header.t.protocol_data block))
      proof_of_work_threshold then
    Error_monad.return_unit
  else
    Error_monad.fail extensible_type_value.

Definition check_signature
  (block : Alpha_context.Block_header.t) (chain_id : Chain_id.[S.HASH.t])
  (key : Signature.Public_key.[S.SPublic_key.t])
  : Lwt.t (Error_monad.tzresult unit) :=
  let check_signature
    (key : Signature.Public_key.[S.SPublic_key.t])
    (function_parameter : Alpha_context.Block_header.t) : bool :=
    let '{|
      Alpha_context.Block_header.t.shell := shell;
        Alpha_context.Block_header.t.protocol_data := {|
          Alpha_context.Block_header.protocol_data.contents := contents;
            Alpha_context.Block_header.protocol_data.signature :=
              signature
            |}
        |} := function_parameter in
    let unsigned_header :=
      Data_encoding.Binary.to_bytes_exn
        Alpha_context.Block_header.unsigned_encoding (shell, contents) in
    Signature.check (Some (Signature.Block_header chain_id)) key signature
      unsigned_header in
  if check_signature key block then
    Error_monad.return_unit
  else
    Error_monad.fail extensible_type_value.

Definition max_fitness_gap {A : Set} (_ctxt : A) : int64 :=
  (* ‚ùå Constant of type int64 is converted to int *)
  1.

Definition check_fitness_gap
  (ctxt : Alpha_context.context) (block : Alpha_context.Block_header.t)
  : Lwt.t (Error_monad.tzresult unit) :=
  let current_fitness := Alpha_context.Fitness.current ctxt in
  Error_monad.op_gtgteqquestion
    (Lwt.__return
      (Alpha_context.Fitness.to_int64
        (Block_header.shell_header.fitness
          (Alpha_context.Block_header.t.shell block))))
    (fun announced_fitness =&gt;
      let gap := Int64.sub announced_fitness current_fitness in
      if
        Pervasives.op_pipepipe
          (Compare.Int64.[Compare.S.op_lteq] gap
            (* ‚ùå Constant of type int64 is converted to int *)
            0) (Compare.Int64.[Compare.S.op_lt] (max_fitness_gap ctxt) gap) then
        Error_monad.fail extensible_type_value
      else
        Error_monad.return_unit).

Definition last_of_a_cycle
  (ctxt : Alpha_context.context) (l : Alpha_context.Level.t) : bool :=
  Compare.Int32.[Compare.S.op_eq]
    (Int32.succ (Alpha_context.Level.t.cycle_position l))
    (Alpha_context.Constants.blocks_per_cycle ctxt).

Definition dawn_of_a_new_cycle (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult (option Alpha_context.Cycle.t)) :=
  let level := Alpha_context.Level.current ctxt in
  if last_of_a_cycle ctxt level then
    Error_monad.return_some (Alpha_context.Level.t.cycle level)
  else
    Error_monad.return_none.

Definition minimum_allowed_endorsements
  (ctxt : Alpha_context.context) (block_delay : Alpha_context.Period.period)
  : Compare.Int.[Compare.S.t] :=
  let minimum := Alpha_context.Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement :=
    Int64.to_int
      (Alpha_context.Period.to_seconds
        (Alpha_context.Constants.delay_per_missing_endorsement ctxt)) in
  let reduced_time_constraint :=
    let delay := Int64.to_int (Alpha_context.Period.to_seconds block_delay) in
    if Compare.Int.[Compare.S.op_eq] delay_per_missing_endorsement 0 then
      delay
    else
      Pervasives.op_div delay delay_per_missing_endorsement in
  Compare.Int.[Compare.S.max] 0
    (Pervasives.op_minus minimum reduced_time_constraint).

Definition minimal_valid_time
  (ctxt : Alpha_context.context) (priority : Z) (endorsing_power : Z)
  : Lwt.t (Error_monad.tzresult Time.t) :=
  let predecessor_timestamp := Alpha_context.Timestamp.current ctxt in
  Error_monad.op_gtgteqquestion
    (minimal_time ctxt priority predecessor_timestamp)
    (fun minimal_time =&gt;
      let minimal_required_endorsements :=
        Alpha_context.Constants.initial_endorsers ctxt in
      let delay_per_missing_endorsement :=
        Alpha_context.Constants.delay_per_missing_endorsement ctxt in
      let missing_endorsements :=
        Compare.Int.[Compare.S.max] 0
          (Pervasives.op_minus minimal_required_endorsements endorsing_power) in
      match
        Alpha_context.Period.mult (Int32.of_int missing_endorsements)
          delay_per_missing_endorsement with
      | Pervasives.Ok delay =&gt;
        Error_monad.__return
          (Time.add minimal_time (Alpha_context.Period.to_seconds delay))
      | (Pervasives.Error _) as err =&gt; Lwt.__return err
      end).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="baking.mli">
  <div class="col-md-6">
    <a href="#baking.mli"><code>baking.mli</code></a>&nbsp;<span class="label label-danger">6 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Misc

<abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_fitness_gap of int64 * int64</abbr> (* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Timestamp_too_early of Timestamp.t * Timestamp.t</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Invalid_block_signature of Block_hash.t * Signature.Public_key_hash.t</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Unexpected_endorsement</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_stamp</abbr> (* `Permanent *)

(** [minimal_time ctxt priority pred_block_time] returns the minimal
    time, given the predecessor block timestamp [pred_block_time],
    after which a baker with priority [priority] is allowed to
    bake. Fail with [Invalid_time_between_blocks_constant] if the minimal
    time cannot be computed. *)
val minimal_time : context -&gt; int -&gt; Time.t -&gt; Time.t tzresult Lwt.t

(** [check_baking_rights ctxt block pred_timestamp] verifies that:
    * the contract that owned the roll at cycle start has the block signer as delegate.
    * the timestamp is coherent with the announced slot.
*)
val check_baking_rights :
  context -&gt;
  Block_header.contents -&gt;
  Time.t -&gt;
  (public_key * Period.t) tzresult Lwt.t

(** For a given level computes who has the right to
    include an endorsement in the next block.
    The result can be stored in Alpha_context.allowed_endorsements *)
val endorsement_rights :
  context -&gt;
  Level.t -&gt;
  (public_key * int list * bool) Signature.Public_key_hash.Map.t tzresult Lwt.t

(** Check that the operation was signed by a delegate allowed
    to endorse at the level specified by the endorsement. *)
val check_endorsement_rights :
  context -&gt;
  Chain_id.t -&gt;
  Kind.endorsement Operation.t -&gt;
  (public_key_hash * int list * bool) tzresult Lwt.t

(** Returns the baking reward calculated w.r.t a given priority [p] and a
    number [e] of included endorsements as follows:
      (block_reward / (p+1)) * (0.8 + 0.2 * e / endorsers_per_block)
*)
val baking_reward :
  context -&gt;
  block_priority:int -&gt;
  included_endorsements:int -&gt;
  Tez.t tzresult Lwt.t

(** Returns the endorsing reward calculated w.r.t a given priority.  *)
val endorsing_reward :
  context -&gt; block_priority:int -&gt; int -&gt; Tez.t tzresult Lwt.t

(** [baking_priorities ctxt level] is the lazy list of contract's
    public key hashes that are allowed to bake for [level]. *)
val baking_priorities : context -&gt; Level.t -&gt; public_key lazy_list

(** [first_baking_priorities ctxt ?max_priority contract_hash level]
    is a list of priorities of max [?max_priority] elements, where the
    delegate of [contract_hash] is allowed to bake for [level]. If
    [?max_priority] is [None], a sensible number of priorities is
    returned. *)
val first_baking_priorities :
  context -&gt;
  ?max_priority:int -&gt;
  public_key_hash -&gt;
  Level.t -&gt;
  int list tzresult Lwt.t

(** [check_signature ctxt chain_id block id] check if the block is
    signed with the given key, and belongs to the given [chain_id] *)
val check_signature :
  Block_header.t -&gt; Chain_id.t -&gt; public_key -&gt; unit tzresult Lwt.t

(** Checks if the header that would be built from the given components
    is valid for the given diffculty. The signature is not passed as it
    is does not impact the proof-of-work stamp. The stamp is checked on
    the hash of a block header whose signature has been zeroed-out. *)
val check_header_proof_of_work_stamp :
  Block_header.shell_header -&gt; Block_header.contents -&gt; int64 -&gt; bool

(** verify if the proof of work stamp is valid *)
val check_proof_of_work_stamp :
  context -&gt; Block_header.t -&gt; unit tzresult Lwt.t

(** check if the gap between the fitness of the current context
    and the given block is within the protocol parameters *)
val check_fitness_gap : context -&gt; Block_header.t -&gt; unit tzresult Lwt.t

val dawn_of_a_new_cycle : context -&gt; Cycle.t option tzresult Lwt.t

val earlier_predecessor_timestamp :
  context -&gt; Level.t -&gt; Timestamp.t tzresult Lwt.t

(** Since Emmy+

    A block is valid only if its timestamp has a minimal delay with
    respect to the previous block's timestamp, and this minimal delay
    depends not only on the block's priority but also on the number of
    endorsement operations included in the block.

    In Emmy+, blocks' fitness increases by one unit with each level.

    In this way, Emmy+ simplifies the optimal baking strategy: The
    bakers used to have to choose whether to wait for more endorsements
    to include in their block, or to publish the block immediately,
    without waiting. The incentive for including more endorsements was
    to increase the fitness and win against unknown blocks. However,
    when a block was produced too late in the priority period, there
    was the risk that the block did not reach endorsers before the
    block of next priority. In Emmy+, the baker does not need to take
    such a decision, because the baker cannot publish a block too
    early. *)

(** Given a delay of a block's timestamp with respect to the minimum
    time to bake at the block's priority (as returned by
    `minimum_time`), it returns the minimum number of endorsements that
    the block has to contain *)
val minimum_allowed_endorsements : context -&gt; block_delay:Period.t -&gt; int

(** This is the somehow the dual of the previous function. Given a
    block priority and a number of endorsement slots (given by the
    `endorsing_power` argument), it returns the minimum time at which
    the next block can be baked. *)
val minimal_valid_time :
  context -&gt; priority:int -&gt; endorsing_power:int -&gt; Time.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#baking.mli"><code>Baking_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Misc.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter minimal_time :
  Alpha_context.context -&gt; Z -&gt; Time.t -&gt; Lwt.t (Error_monad.tzresult Time.t).

Parameter check_baking_rights :
  Alpha_context.context -&gt; Alpha_context.Block_header.contents -&gt; Time.t -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.public_key * Alpha_context.Period.t)).

Parameter endorsement_rights :
  Alpha_context.context -&gt; Alpha_context.Level.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
        (Alpha_context.public_key * list Z * bool))).

Parameter check_endorsement_rights :
  Alpha_context.context -&gt; Chain_id.[S.HASH.t] -&gt;
  Alpha_context.Operation.t Alpha_context.Kind.endorsement -&gt;
  Lwt.t (Error_monad.tzresult (Alpha_context.public_key_hash * list Z * bool)).

Parameter baking_reward :
  Alpha_context.context -&gt; Z -&gt; Z -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.Tez.t).

Parameter endorsing_reward :
  Alpha_context.context -&gt; Z -&gt; Z -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.Tez.t).

Parameter baking_priorities :
  Alpha_context.context -&gt; Alpha_context.Level.t -&gt;
  Misc.lazy_list Alpha_context.public_key.

Parameter first_baking_priorities :
  Alpha_context.context -&gt; option Z -&gt; Alpha_context.public_key_hash -&gt;
  Alpha_context.Level.t -&gt; Lwt.t (Error_monad.tzresult (list Z)).

Parameter check_signature :
  Alpha_context.Block_header.t -&gt; Chain_id.[S.HASH.t] -&gt;
  Alpha_context.public_key -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter check_header_proof_of_work_stamp :
  Alpha_context.Block_header.shell_header -&gt;
  Alpha_context.Block_header.contents -&gt; int64 -&gt; bool.

Parameter check_proof_of_work_stamp :
  Alpha_context.context -&gt; Alpha_context.Block_header.t -&gt;
  Lwt.t (Error_monad.tzresult unit).

Parameter check_fitness_gap :
  Alpha_context.context -&gt; Alpha_context.Block_header.t -&gt;
  Lwt.t (Error_monad.tzresult unit).

Parameter dawn_of_a_new_cycle :
  Alpha_context.context -&gt;
  Lwt.t (Error_monad.tzresult (option Alpha_context.Cycle.t)).

Parameter earlier_predecessor_timestamp :
  Alpha_context.context -&gt; Alpha_context.Level.t -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.t).

Parameter minimum_allowed_endorsements :
  Alpha_context.context -&gt; Alpha_context.Period.t -&gt; Z.

Parameter minimal_valid_time :
  Alpha_context.context -&gt; Z -&gt; Z -&gt; Lwt.t (Error_monad.tzresult Time.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="blinded_public_key_hash.ml">
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.ml"><code>blinded_public_key_hash.ml</code></a>&nbsp;<span class="label label-danger">3 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module H =
  Blake2B.Make
    (Base58)
    (struct
      let name = &quot;Blinded public key hash&quot;

      let title = &quot;A blinded public key hash&quot;

      let b58check_prefix = &quot;\001\002\049\223&quot;

      let size = Some Ed25519.Public_key_hash.size
    end)

include H

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () = Base58.check_encoded_prefix b58check_encoding &quot;btz1&quot; 37</abbr>

let of_ed25519_pkh activation_code pkh =
  hash_bytes ~key:activation_code [Ed25519.Public_key_hash.to_bytes pkh]

type activation_code = MBytes.t

let activation_code_size = Ed25519.Public_key_hash.size

let activation_code_encoding = Data_encoding.Fixed.bytes activation_code_size

let activation_code_of_hex h =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Compare.Int.(String.length h &lt;&gt; activation_code_size * 2) then
    invalid_arg &quot;Blinded_public_key_hash.activation_code_of_hex&quot; ;
  MBytes.of_hex </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Variants not supported">(`Hex h)</abbr>

module Index = H
</pre>
  </div>
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.ml"><code>Blinded_public_key_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition H :=
  (Blake2B.Make
    (existT _ tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
        |}))
    (let name := &quot;Blinded public key hash&quot; % string in
    let title := &quot;A blinded public key hash&quot; % string in
    let b58check_prefix := &quot;\001\0021\223&quot; % string in
    let size :=
      Some Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.size) in
    existT _ tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
        |}).

Definition t := H.[S.HASH.t].

Definition name := H.[S.HASH.name].

Definition title := H.[S.HASH.title].

Definition pp := H.[S.HASH.pp].

Definition pp_short := H.[S.HASH.pp_short].

Definition op_eq := H.[S.HASH.op_eq].

Definition op_ltgt := H.[S.HASH.op_ltgt].

Definition op_lt := H.[S.HASH.op_lt].

Definition op_lteq := H.[S.HASH.op_lteq].

Definition op_gteq := H.[S.HASH.op_gteq].

Definition op_gt := H.[S.HASH.op_gt].

Definition compare := H.[S.HASH.compare].

Definition equal := H.[S.HASH.equal].

Definition max := H.[S.HASH.max].

Definition min := H.[S.HASH.min].

Definition hash_bytes := H.[S.HASH.hash_bytes].

Definition hash_string := H.[S.HASH.hash_string].

Definition zero := H.[S.HASH.zero].

Definition size := H.[S.HASH.size].

Definition to_bytes := H.[S.HASH.to_bytes].

Definition of_bytes_opt := H.[S.HASH.of_bytes_opt].

Definition of_bytes_exn := H.[S.HASH.of_bytes_exn].

Definition to_b58check := H.[S.HASH.to_b58check].

Definition to_short_b58check := H.[S.HASH.to_short_b58check].

Definition of_b58check_exn := H.[S.HASH.of_b58check_exn].

Definition of_b58check_opt := H.[S.HASH.of_b58check_opt].

Definition b58check_encoding := H.[S.HASH.b58check_encoding].

Definition encoding := H.[S.HASH.encoding].

Definition rpc_arg := H.[S.HASH.rpc_arg].

Definition to_path := H.[S.HASH.to_path].

Definition of_path := H.[S.HASH.of_path].

Definition of_path_exn := H.[S.HASH.of_path_exn].

Definition prefix_path := H.[S.HASH.prefix_path].

Definition path_length := H.[S.HASH.path_length].

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition of_ed25519_pkh
  (activation_code : MBytes.t)
  (pkh : Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.t)) : t :=
  hash_bytes (Some activation_code)
    (cons
      (Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.to_bytes) pkh)
      []).

Definition activation_code := MBytes.t.

Definition activation_code_size : Z :=
  Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.size).

Definition activation_code_encoding : Data_encoding.encoding MBytes.t :=
  Data_encoding.Fixed.__bytes_value activation_code_size.

Definition activation_code_of_hex (h : string) : MBytes.t :=
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  MBytes.of_hex
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Hex *)
    h.

Definition Index := H.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="blinded_public_key_hash.mli">
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.mli"><code>blinded_public_key_hash.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Type extension not handled">include S.HASH</abbr>

type activation_code

val activation_code_encoding : activation_code Data_encoding.t

val of_ed25519_pkh : activation_code -&gt; Ed25519.Public_key_hash.t -&gt; t

val activation_code_of_hex : string -&gt; activation_code

module Index : Storage_description.INDEX with type t = t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.mli"><code>Blinded_public_key_hash_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Storage_description.

Parameter Included_HASH :
  {'[t, __Set_t, Map_t] : _ &amp; S.HASH.signature t __Set_t Map_t}.

Definition t := Included_HASH.[S.HASH.t].

Definition name := Included_HASH.[S.HASH.name].

Definition title := Included_HASH.[S.HASH.title].

Definition pp := Included_HASH.[S.HASH.pp].

Definition pp_short := Included_HASH.[S.HASH.pp_short].

Definition op_eq := Included_HASH.[S.HASH.op_eq].

Definition op_ltgt := Included_HASH.[S.HASH.op_ltgt].

Definition op_lt := Included_HASH.[S.HASH.op_lt].

Definition op_lteq := Included_HASH.[S.HASH.op_lteq].

Definition op_gteq := Included_HASH.[S.HASH.op_gteq].

Definition op_gt := Included_HASH.[S.HASH.op_gt].

Definition compare := Included_HASH.[S.HASH.compare].

Definition equal := Included_HASH.[S.HASH.equal].

Definition max := Included_HASH.[S.HASH.max].

Definition min := Included_HASH.[S.HASH.min].

Definition hash_bytes := Included_HASH.[S.HASH.hash_bytes].

Definition hash_string := Included_HASH.[S.HASH.hash_string].

Definition zero := Included_HASH.[S.HASH.zero].

Definition size := Included_HASH.[S.HASH.size].

Definition to_bytes := Included_HASH.[S.HASH.to_bytes].

Definition of_bytes_opt := Included_HASH.[S.HASH.of_bytes_opt].

Definition of_bytes_exn := Included_HASH.[S.HASH.of_bytes_exn].

Definition to_b58check := Included_HASH.[S.HASH.to_b58check].

Definition to_short_b58check := Included_HASH.[S.HASH.to_short_b58check].

Definition of_b58check_exn := Included_HASH.[S.HASH.of_b58check_exn].

Definition of_b58check_opt := Included_HASH.[S.HASH.of_b58check_opt].

Definition b58check_encoding := Included_HASH.[S.HASH.b58check_encoding].

Definition encoding := Included_HASH.[S.HASH.encoding].

Definition rpc_arg := Included_HASH.[S.HASH.rpc_arg].

Definition to_path := Included_HASH.[S.HASH.to_path].

Definition of_path := Included_HASH.[S.HASH.of_path].

Definition of_path_exn := Included_HASH.[S.HASH.of_path_exn].

Definition prefix_path := Included_HASH.[S.HASH.prefix_path].

Definition path_length := Included_HASH.[S.HASH.path_length].

Definition __Set := existT (fun _ =&gt; _) tt Included_HASH.[S.HASH.__Set].

Definition Map := existT (fun _ =&gt; _) tt Included_HASH.[S.HASH.Map].

Parameter activation_code : Set.

Parameter activation_code_encoding : Data_encoding.t activation_code.

Parameter of_ed25519_pkh :
  activation_code -&gt;
  Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.t) -&gt; t.

Parameter activation_code_of_hex : string -&gt; activation_code.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature t}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="block_header_repr.ml">
  <div class="col-md-6">
    <a href="#block_header_repr.ml"><code>block_header_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Block header *)

type contents = {
  priority : int;
  seed_nonce_hash : Nonce_hash.t option;
  proof_of_work_nonce : MBytes.t;
}

type protocol_data = {contents : contents; signature : Signature.t}

type t = {shell : Block_header.shell_header; protocol_data : protocol_data}

type block_header = t

type raw = Block_header.t

type shell_header = Block_header.shell_header

let raw_encoding = Block_header.encoding

let shell_header_encoding = Block_header.shell_header_encoding

let contents_encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.unsigned_contents&quot;
  @@ conv
       (fun {priority; seed_nonce_hash; proof_of_work_nonce} -&gt;
         (priority, proof_of_work_nonce, seed_nonce_hash))
       (fun (priority, proof_of_work_nonce, seed_nonce_hash) -&gt;
         {priority; seed_nonce_hash; proof_of_work_nonce})
       (obj3
          (req &quot;priority&quot; uint16)
          (req
             &quot;proof_of_work_nonce&quot;
             (Fixed.bytes Constants_repr.proof_of_work_nonce_size))
          (opt &quot;seed_nonce_hash&quot; Nonce_hash.encoding))

let protocol_data_encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.signed_contents&quot;
  @@ conv
       (fun {contents; signature} -&gt; (contents, signature))
       (fun (contents, signature) -&gt; {contents; signature})
       (merge_objs
          contents_encoding
          (obj1 (req &quot;signature&quot; Signature.encoding)))

let raw {shell; protocol_data} =
  let protocol_data =
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data
  in
  {Block_header.shell; protocol_data}

let unsigned_encoding =
  let open Data_encoding in
  merge_objs Block_header.shell_header_encoding contents_encoding

let encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.full_header&quot;
  @@ conv
       (fun {shell; protocol_data} -&gt; (shell, protocol_data))
       (fun (shell, protocol_data) -&gt; {shell; protocol_data})
       (merge_objs Block_header.shell_header_encoding protocol_data_encoding)

(** Constants *)

let max_header_length =
  let fake_shell =
    {
      Block_header.level = 0l;
      proto_level = 0;
      predecessor = Block_hash.zero;
      timestamp = Time.of_seconds 0L;
      validation_passes = 0;
      operations_hash = Operation_list_list_hash.zero;
      fitness = Fitness_repr.from_int64 0L;
      context = Context_hash.zero;
    }
  and fake_contents =
    {
      priority = 0;
      proof_of_work_nonce =
        MBytes.create Constants_repr.proof_of_work_nonce_size;
      seed_nonce_hash = Some Nonce_hash.zero;
    }
  in
  Data_encoding.Binary.length
    encoding
    {
      shell = fake_shell;
      protocol_data = {contents = fake_contents; signature = Signature.zero};
    }

(** Header parsing entry point  *)

let hash_raw = Block_header.hash

let hash {shell; protocol_data} =
  Block_header.hash
    {
      shell;
      protocol_data =
        Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data;
    }
</pre>
  </div>
  <div class="col-md-6">
    <a href="#block_header_repr.ml"><code>Block_header_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Fitness_repr.
Require Tezos.Nonce_hash.

Module contents.
  Record record := {
    priority : Z;
    seed_nonce_hash : option Nonce_hash.t;
    proof_of_work_nonce : MBytes.t }.
End contents.
Definition contents := contents.record.

Module protocol_data.
  Record record := {
    contents : contents;
    signature : Signature.t }.
End protocol_data.
Definition protocol_data := protocol_data.record.

Module t.
  Record record := {
    shell : Block_header.shell_header;
    protocol_data : protocol_data }.
End t.
Definition t := t.record.

Definition block_header := t.

Definition raw := Block_header.t.

Definition shell_header := Block_header.shell_header.

Definition raw_encoding : Data_encoding.t Block_header.t :=
  Block_header.encoding.

Definition shell_header_encoding : Data_encoding.t Block_header.shell_header :=
  Block_header.shell_header_encoding.

Definition contents_encoding : Data_encoding.encoding contents :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;block_header.alpha.unsigned_contents&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          contents.priority := priority;
            contents.seed_nonce_hash := seed_nonce_hash;
            contents.proof_of_work_nonce := proof_of_work_nonce
            |} := function_parameter in
        (priority, proof_of_work_nonce, seed_nonce_hash))
      (fun function_parameter =&gt;
        let '(priority, proof_of_work_nonce, seed_nonce_hash) :=
          function_parameter in
        {| contents.priority := priority;
          contents.seed_nonce_hash := seed_nonce_hash;
          contents.proof_of_work_nonce := proof_of_work_nonce |}) None
      (Data_encoding.obj3
        (Data_encoding.req None None &quot;priority&quot; % string Data_encoding.uint16)
        (Data_encoding.req None None &quot;proof_of_work_nonce&quot; % string
          (Data_encoding.Fixed.__bytes_value
            Constants_repr.proof_of_work_nonce_size))
        (Data_encoding.opt None None &quot;seed_nonce_hash&quot; % string
          Nonce_hash.encoding))).

Definition protocol_data_encoding : Data_encoding.encoding protocol_data :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;block_header.alpha.signed_contents&quot; % string
      in
    fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          protocol_data.contents := contents;
            protocol_data.signature := signature
            |} := function_parameter in
        (contents, signature))
      (fun function_parameter =&gt;
        let '(contents, signature) := function_parameter in
        {| protocol_data.contents := contents;
          protocol_data.signature := signature |}) None
      (Data_encoding.merge_objs contents_encoding
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;signature&quot; % string Signature.encoding)))).

Definition raw (function_parameter : t) : Block_header.t :=
  let '{| t.shell := shell; t.protocol_data := protocol_data |} :=
    function_parameter in
  let protocol_data :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data in
  {| Block_header.t.shell := shell;
    Block_header.t.protocol_data := protocol_data |}.

Definition unsigned_encoding
  : Data_encoding.encoding (Block_header.shell_header * contents) :=
  Data_encoding.merge_objs Block_header.shell_header_encoding contents_encoding.

Definition encoding : Data_encoding.encoding t :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;block_header.alpha.full_header&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{| t.shell := shell; t.protocol_data := protocol_data |} :=
          function_parameter in
        (shell, protocol_data))
      (fun function_parameter =&gt;
        let '(shell, protocol_data) := function_parameter in
        {| t.shell := shell; t.protocol_data := protocol_data |}) None
      (Data_encoding.merge_objs Block_header.shell_header_encoding
        protocol_data_encoding)).

Definition max_header_length : Z :=
  let fake_shell : Block_header.shell_header :=
    {|
      Block_header.shell_header.level :=
        (* ‚ùå Constant of type int32 is converted to int *)
        0; Block_header.shell_header.proto_level := 0;
      Block_header.shell_header.predecessor := Block_hash.[S.HASH.zero];
      Block_header.shell_header.timestamp :=
        Time.of_seconds
          (* ‚ùå Constant of type int64 is converted to int *)
          0; Block_header.shell_header.validation_passes := 0;
      Block_header.shell_header.operations_hash :=
        Operation_list_list_hash.[S.MERKLE_TREE.zero];
      Block_header.shell_header.fitness :=
        Fitness_repr.from_int64
          (* ‚ùå Constant of type int64 is converted to int *)
          0; Block_header.shell_header.context := Context_hash.[S.HASH.zero] |}
  with fake_contents : contents :=
    {| contents.priority := 0; contents.seed_nonce_hash := Some Nonce_hash.zero;
      contents.proof_of_work_nonce :=
        MBytes.create Constants_repr.proof_of_work_nonce_size |} in
  Data_encoding.Binary.length encoding
    {| t.shell := fake_shell;
      t.protocol_data :=
        {| protocol_data.contents := fake_contents;
          protocol_data.signature := Signature.zero |} |}.

Definition hash_raw : Block_header.t -&gt; Block_hash.[S.HASH.t] :=
  Block_header.__hash_value.

Definition __hash_value (function_parameter : t) : Block_hash.[S.HASH.t] :=
  let '{| t.shell := shell; t.protocol_data := protocol_data |} :=
    function_parameter in
  Block_header.__hash_value
    {| Block_header.t.shell := shell;
      Block_header.t.protocol_data :=
        Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data
      |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="block_header_repr.mli">
  <div class="col-md-6">
    <a href="#block_header_repr.mli"><code>block_header_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type contents = {
  priority : int;
  seed_nonce_hash : Nonce_hash.t option;
  proof_of_work_nonce : MBytes.t;
}

type protocol_data = {contents : contents; signature : Signature.t}

type t = {shell : Block_header.shell_header; protocol_data : protocol_data}

type block_header = t

type raw = Block_header.t

type shell_header = Block_header.shell_header

val raw : block_header -&gt; raw

val encoding : block_header Data_encoding.encoding

val raw_encoding : raw Data_encoding.t

val contents_encoding : contents Data_encoding.t

val unsigned_encoding : (Block_header.shell_header * contents) Data_encoding.t

val protocol_data_encoding : protocol_data Data_encoding.encoding

val shell_header_encoding : shell_header Data_encoding.encoding

(** The maximum size of block headers in bytes *)
val max_header_length : int

val hash : block_header -&gt; Block_hash.t

val hash_raw : raw -&gt; Block_hash.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#block_header_repr.mli"><code>Block_header_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Nonce_hash.

Module contents.
  Record record := {
    priority : Z;
    seed_nonce_hash : option Nonce_hash.t;
    proof_of_work_nonce : MBytes.t }.
End contents.
Definition contents := contents.record.

Module protocol_data.
  Record record := {
    contents : contents;
    signature : Signature.t }.
End protocol_data.
Definition protocol_data := protocol_data.record.

Module t.
  Record record := {
    shell : Block_header.shell_header;
    protocol_data : protocol_data }.
End t.
Definition t := t.record.

Definition block_header := t.

Definition raw := Block_header.t.

Definition shell_header := Block_header.shell_header.

Parameter raw : block_header -&gt; raw.

Parameter encoding : Data_encoding.encoding block_header.

Parameter raw_encoding : Data_encoding.t raw.

Parameter contents_encoding : Data_encoding.t contents.

Parameter unsigned_encoding :
  Data_encoding.t (Block_header.shell_header * contents).

Parameter protocol_data_encoding : Data_encoding.encoding protocol_data.

Parameter shell_header_encoding : Data_encoding.encoding shell_header.

Parameter max_header_length : Z.

Parameter __hash_value : block_header -&gt; Block_hash.[S.HASH.t].

Parameter hash_raw : raw -&gt; Block_hash.[S.HASH.t].
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="bootstrap_storage.ml">
  <div class="col-md-6">
    <a href="#bootstrap_storage.ml"><code>bootstrap_storage.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Misc

let init_account ctxt
    ({public_key_hash; public_key; amount} : Parameters_repr.bootstrap_account)
    =
  let contract = Contract_repr.implicit_contract public_key_hash in
  Contract_storage.credit ctxt contract amount
  &gt;&gt;=? fun ctxt -&gt;
  match public_key with
  | Some public_key -&gt;
      Contract_storage.reveal_manager_key ctxt public_key_hash public_key
      &gt;&gt;=? fun ctxt -&gt;
      Delegate_storage.set ctxt contract (Some public_key_hash)
      &gt;&gt;=? fun ctxt -&gt; return ctxt
  | None -&gt;
      return ctxt

let init_contract ~typecheck ctxt
    ({delegate; amount; script} : Parameters_repr.bootstrap_contract) =
  Contract_storage.fresh_contract_from_current_nonce ctxt
  &gt;&gt;=? fun (ctxt, contract) -&gt;
  typecheck ctxt script
  &gt;&gt;=? fun (script, ctxt) -&gt;
  Contract_storage.originate
    ctxt
    contract
    ~balance:amount
    ~prepaid_bootstrap_storage:true
    ~script
    ~delegate:(Some delegate)
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let init ctxt ~typecheck ?ramp_up_cycles ?no_reward_cycles accounts contracts =
  let nonce =
    Operation_hash.hash_bytes [MBytes.of_string &quot;Un festival de GADT.&quot;]
  in
  let ctxt = Raw_context.init_origination_nonce ctxt nonce in
  fold_left_s init_account ctxt accounts
  &gt;&gt;=? fun ctxt -&gt;
  fold_left_s (init_contract ~typecheck) ctxt contracts
  &gt;&gt;=? fun ctxt -&gt;
  ( match no_reward_cycles with
  | None -&gt;
      return ctxt
  | Some cycles -&gt;
      (* Store pending ramp ups. *)
      let constants = Raw_context.constants ctxt in
      (* Start without reward *)
      Raw_context.patch_constants ctxt (fun c -&gt;
          <abbr class="mark-error" title="Record substitution not handled">{
            c with
            block_reward = Tez_repr.zero;
            endorsement_reward = Tez_repr.zero;
          }</abbr>)
      &gt;&gt;= fun ctxt -&gt;
      (* Store the final reward. *)
      Storage.Ramp_up.Rewards.init
        ctxt
        (Cycle_repr.of_int32_exn (Int32.of_int cycles))
        (constants.block_reward, constants.endorsement_reward) )
  &gt;&gt;=? fun ctxt -&gt;
  match ramp_up_cycles with
  | None -&gt;
      return ctxt
  | Some cycles -&gt;
      (* Store pending ramp ups. *)
      let constants = Raw_context.constants ctxt in
      Lwt.return
        Tez_repr.(constants.block_security_deposit /? Int64.of_int cycles)
      &gt;&gt;=? fun block_step -&gt;
      Lwt.return
        Tez_repr.(
          constants.endorsement_security_deposit /? Int64.of_int cycles)
      &gt;&gt;=? fun endorsement_step -&gt;
      (* Start without security_deposit *)
      Raw_context.patch_constants ctxt (fun c -&gt;
          <abbr class="mark-error" title="Record substitution not handled">{
            c with
            block_security_deposit = Tez_repr.zero;
            endorsement_security_deposit = Tez_repr.zero;
          }</abbr>)
      &gt;&gt;= fun ctxt -&gt;
      fold_left_s
        (fun ctxt cycle -&gt;
          Lwt.return Tez_repr.(block_step *? Int64.of_int cycle)
          &gt;&gt;=? fun block_security_deposit -&gt;
          Lwt.return Tez_repr.(endorsement_step *? Int64.of_int cycle)
          &gt;&gt;=? fun endorsement_security_deposit -&gt;
          let cycle = Cycle_repr.of_int32_exn (Int32.of_int cycle) in
          Storage.Ramp_up.Security_deposits.init
            ctxt
            cycle
            (block_security_deposit, endorsement_security_deposit))
        ctxt
        (1 --&gt; (cycles - 1))
      &gt;&gt;=? fun ctxt -&gt;
      (* Store the final security deposits. *)
      Storage.Ramp_up.Security_deposits.init
        ctxt
        (Cycle_repr.of_int32_exn (Int32.of_int cycles))
        ( constants.block_security_deposit,
          constants.endorsement_security_deposit )
      &gt;&gt;=? fun ctxt -&gt; return ctxt

let cycle_end ctxt last_cycle =
  let next_cycle = Cycle_repr.succ last_cycle in
  Storage.Ramp_up.Rewards.get_option ctxt next_cycle
  &gt;&gt;=? (function
         | None -&gt;
             return ctxt
         | Some (block_reward, endorsement_reward) -&gt;
             Storage.Ramp_up.Rewards.delete ctxt next_cycle
             &gt;&gt;=? fun ctxt -&gt;
             Raw_context.patch_constants ctxt (fun c -&gt;
                 <abbr class="mark-error" title="Record substitution not handled">{c with block_reward; endorsement_reward}</abbr>)
             &gt;&gt;= fun ctxt -&gt; return ctxt)
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Ramp_up.Security_deposits.get_option ctxt next_cycle
  &gt;&gt;=? function
  | None -&gt;
      return ctxt
  | Some (block_security_deposit, endorsement_security_deposit) -&gt;
      Storage.Ramp_up.Security_deposits.delete ctxt next_cycle
      &gt;&gt;=? fun ctxt -&gt;
      Raw_context.patch_constants ctxt (fun c -&gt;
          <abbr class="mark-error" title="Record substitution not handled">{c with block_security_deposit; endorsement_security_deposit}</abbr>)
      &gt;&gt;= fun ctxt -&gt; return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#bootstrap_storage.ml"><code>Bootstrap_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Contract_storage.
Require Tezos.Cycle_repr.
Require Tezos.Delegate_storage.
Require Tezos.Misc.
Require Tezos.Parameters_repr.
Require Tezos.Raw_context.
Require Tezos.Script_repr.
Require Tezos.Storage.
Require Tezos.Tez_repr.

Import Misc.

Definition init_account
  (ctxt : Raw_context.t)
  (function_parameter : Parameters_repr.bootstrap_account)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{|
    Parameters_repr.bootstrap_account.public_key_hash := public_key_hash;
      Parameters_repr.bootstrap_account.public_key := public_key;
      Parameters_repr.bootstrap_account.amount := amount
      |} := function_parameter in
  let contract := Contract_repr.implicit_contract public_key_hash in
  Error_monad.op_gtgteqquestion (Contract_storage.credit ctxt contract amount)
    (fun ctxt =&gt;
      match public_key with
      | Some public_key =&gt;
        Error_monad.op_gtgteqquestion
          (Contract_storage.reveal_manager_key ctxt public_key_hash public_key)
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion
              (Delegate_storage.set ctxt contract (Some public_key_hash))
              (fun ctxt =&gt; Error_monad.__return ctxt))
      | None =&gt; Error_monad.__return ctxt
      end).

Definition init_contract
  (typecheck :
    Raw_context.t -&gt; Script_repr.t -&gt;
    Lwt.t
      (Error_monad.tzresult
        ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  (ctxt : Raw_context.t)
  (function_parameter : Parameters_repr.bootstrap_contract)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{|
    Parameters_repr.bootstrap_contract.delegate := delegate;
      Parameters_repr.bootstrap_contract.amount := amount;
      Parameters_repr.bootstrap_contract.script := script
      |} := function_parameter in
  Error_monad.op_gtgteqquestion
    (Contract_storage.fresh_contract_from_current_nonce ctxt)
    (fun function_parameter =&gt;
      let '(ctxt, contract) := function_parameter in
      Error_monad.op_gtgteqquestion (typecheck ctxt script)
        (fun function_parameter =&gt;
          let '(script, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Contract_storage.originate ctxt (Some true) contract amount script
              (Some delegate)) (fun ctxt =&gt; Error_monad.__return ctxt))).

Definition init
  (ctxt : Raw_context.t)
  (typecheck :
    Raw_context.t -&gt; Script_repr.t -&gt;
    Lwt.t
      (Error_monad.tzresult
        ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  (ramp_up_cycles : option Z) (no_reward_cycles : option Z)
  (accounts : list Parameters_repr.bootstrap_account)
  (contracts : list Parameters_repr.bootstrap_contract)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let nonce :=
    Operation_hash.[S.HASH.hash_bytes] None
      (cons (MBytes.of_string &quot;Un festival de GADT.&quot; % string) []) in
  let ctxt := Raw_context.init_origination_nonce ctxt nonce in
  Error_monad.op_gtgteqquestion
    (Error_monad.fold_left_s init_account ctxt accounts)
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Error_monad.fold_left_s (init_contract typecheck) ctxt contracts)
        (fun ctxt =&gt;
          Error_monad.op_gtgteqquestion
            match no_reward_cycles with
            | None =&gt; Error_monad.__return ctxt
            | Some cycles =&gt;
              let constants := Raw_context.constants ctxt in
              Error_monad.op_gtgteq
                (Raw_context.patch_constants ctxt
                  (fun c =&gt;
                    (* ‚ùå Record substitution not handled *)
                    record_substitution))
                (fun ctxt =&gt;
                  Storage.Ramp_up.Rewards.init ctxt
                    (Cycle_repr.of_int32_exn (Int32.of_int cycles))
                    ((Constants_repr.parametric.block_reward constants),
                      (Constants_repr.parametric.endorsement_reward constants)))
            end
            (fun ctxt =&gt;
              match ramp_up_cycles with
              | None =&gt; Error_monad.__return ctxt
              | Some cycles =&gt;
                let constants := Raw_context.constants ctxt in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Tez_repr.op_divquestion
                      (Constants_repr.parametric.block_security_deposit
                        constants) (Int64.of_int cycles)))
                  (fun block_step =&gt;
                    Error_monad.op_gtgteqquestion
                      (Lwt.__return
                        (Tez_repr.op_divquestion
                          (Constants_repr.parametric.endorsement_security_deposit
                            constants) (Int64.of_int cycles)))
                      (fun endorsement_step =&gt;
                        Error_monad.op_gtgteq
                          (Raw_context.patch_constants ctxt
                            (fun c =&gt;
                              (* ‚ùå Record substitution not handled *)
                              record_substitution))
                          (fun ctxt =&gt;
                            Error_monad.op_gtgteqquestion
                              (Error_monad.fold_left_s
                                (fun ctxt =&gt;
                                  fun cycle =&gt;
                                    Error_monad.op_gtgteqquestion
                                      (Lwt.__return
                                        (Tez_repr.op_starquestion block_step
                                          (Int64.of_int cycle)))
                                      (fun block_security_deposit =&gt;
                                        Error_monad.op_gtgteqquestion
                                          (Lwt.__return
                                            (Tez_repr.op_starquestion
                                              endorsement_step
                                              (Int64.of_int cycle)))
                                          (fun endorsement_security_deposit =&gt;
                                            let cycle :=
                                              Cycle_repr.of_int32_exn
                                                (Int32.of_int cycle) in
                                            Storage.Ramp_up.Security_deposits.init
                                              ctxt cycle
                                              (block_security_deposit,
                                                endorsement_security_deposit))))
                                ctxt
                                (Misc.op_minusminusgt 1
                                  (Pervasives.op_minus cycles 1)))
                              (fun ctxt =&gt;
                                Error_monad.op_gtgteqquestion
                                  (Storage.Ramp_up.Security_deposits.init ctxt
                                    (Cycle_repr.of_int32_exn
                                      (Int32.of_int cycles))
                                    ((Constants_repr.parametric.block_security_deposit
                                      constants),
                                      (Constants_repr.parametric.endorsement_security_deposit
                                        constants)))
                                  (fun ctxt =&gt; Error_monad.__return ctxt)))))
              end))).

Definition cycle_end
  (ctxt : Storage.Ramp_up.Rewards.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t (Error_monad.tzresult Storage.Ramp_up.Rewards.context) :=
  let next_cycle := Cycle_repr.succ last_cycle in
  Error_monad.op_gtgteqquestion
    (Error_monad.op_gtgteqquestion
      (Storage.Ramp_up.Rewards.get_option ctxt next_cycle)
      (fun function_parameter =&gt;
        match function_parameter with
        | None =&gt; Error_monad.__return ctxt
        | Some (block_reward, endorsement_reward) =&gt;
          Error_monad.op_gtgteqquestion
            (Storage.Ramp_up.Rewards.delete ctxt next_cycle)
            (fun ctxt =&gt;
              Error_monad.op_gtgteq
                (Raw_context.patch_constants ctxt
                  (fun c =&gt;
                    (* ‚ùå Record substitution not handled *)
                    record_substitution))
                (fun ctxt =&gt; Error_monad.__return ctxt))
        end))
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Storage.Ramp_up.Security_deposits.get_option ctxt next_cycle)
        (fun function_parameter =&gt;
          match function_parameter with
          | None =&gt; Error_monad.__return ctxt
          | Some (block_security_deposit, endorsement_security_deposit) =&gt;
            Error_monad.op_gtgteqquestion
              (Storage.Ramp_up.Security_deposits.delete ctxt next_cycle)
              (fun ctxt =&gt;
                Error_monad.op_gtgteq
                  (Raw_context.patch_constants ctxt
                    (fun c =&gt;
                      (* ‚ùå Record substitution not handled *)
                      record_substitution))
                  (fun ctxt =&gt; Error_monad.__return ctxt))
          end)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="bootstrap_storage.mli">
  <div class="col-md-6">
    <a href="#bootstrap_storage.mli"><code>bootstrap_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val init :
  Raw_context.t -&gt;
  typecheck:(Raw_context.t -&gt;
            Script_repr.t -&gt;
            ( (Script_repr.t * Contract_storage.big_map_diff option)
            * Raw_context.t )
            tzresult
            Lwt.t) -&gt;
  ?ramp_up_cycles:int -&gt;
  ?no_reward_cycles:int -&gt;
  Parameters_repr.bootstrap_account list -&gt;
  Parameters_repr.bootstrap_contract list -&gt;
  Raw_context.t tzresult Lwt.t

val cycle_end : Raw_context.t -&gt; Cycle_repr.t -&gt; Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#bootstrap_storage.mli"><code>Bootstrap_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_storage.
Require Tezos.Cycle_repr.
Require Tezos.Parameters_repr.
Require Tezos.Raw_context.
Require Tezos.Script_repr.

Parameter init :
  Raw_context.t -&gt;
  (Raw_context.t -&gt; Script_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  -&gt; option Z -&gt; option Z -&gt; list Parameters_repr.bootstrap_account -&gt;
  list Parameters_repr.bootstrap_contract -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_repr.ml">
  <div class="col-md-6">
    <a href="#commitment_repr.ml"><code>commitment_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = {
  blinded_public_key_hash : Blinded_public_key_hash.t;
  amount : Tez_repr.t;
}

let encoding =
  let open Data_encoding in
  conv
    (fun {blinded_public_key_hash; amount} -&gt;
      (blinded_public_key_hash, amount))
    (fun (blinded_public_key_hash, amount) -&gt;
      {blinded_public_key_hash; amount})
    (tup2 Blinded_public_key_hash.encoding Tez_repr.encoding)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_repr.ml"><code>Commitment_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Tez_repr.

Module t.
  Record record := {
    blinded_public_key_hash : Blinded_public_key_hash.t;
    amount : Tez_repr.t }.
End t.
Definition t := t.record.

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        t.blinded_public_key_hash := blinded_public_key_hash;
          t.amount := amount
          |} := function_parameter in
      (blinded_public_key_hash, amount))
    (fun function_parameter =&gt;
      let '(blinded_public_key_hash, amount) := function_parameter in
      {| t.blinded_public_key_hash := blinded_public_key_hash;
        t.amount := amount |}) None
    (Data_encoding.tup2 Blinded_public_key_hash.encoding Tez_repr.encoding).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_repr.mli">
  <div class="col-md-6">
    <a href="#commitment_repr.mli"><code>commitment_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = {
  blinded_public_key_hash : Blinded_public_key_hash.t;
  amount : Tez_repr.t;
}

val encoding : t Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_repr.mli"><code>Commitment_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Tez_repr.

Module t.
  Record record := {
    blinded_public_key_hash : Blinded_public_key_hash.t;
    amount : Tez_repr.t }.
End t.
Definition t := t.record.

Parameter encoding : Data_encoding.t t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_storage.ml">
  <div class="col-md-6">
    <a href="#commitment_storage.ml"><code>commitment_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let get_opt = Storage.Commitments.get_option

let delete = Storage.Commitments.delete

let init ctxt commitments =
  let init_commitment ctxt Commitment_repr.{blinded_public_key_hash; amount} =
    Storage.Commitments.init ctxt blinded_public_key_hash amount
  in
  fold_left_s init_commitment ctxt commitments &gt;&gt;=? fun ctxt -&gt; return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_storage.ml"><code>Commitment_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Commitment_repr.
Require Tezos.Raw_context.
Require Tezos.Storage.

Definition get_opt
  : Storage.Commitments.context -&gt; Storage.Commitments.key -&gt;
  Lwt.t (Error_monad.tzresult (option Storage.Commitments.value)) :=
  Storage.Commitments.get_option.

Definition delete
  : Storage.Commitments.context -&gt; Storage.Commitments.key -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) := Storage.Commitments.delete.

Definition init
  (ctxt : Storage.Commitments.context) (commitments : list Commitment_repr.t)
  : Lwt.t (Error_monad.tzresult Storage.Commitments.context) :=
  let init_commitment
    (ctxt : Storage.Commitments.context)
    (function_parameter : Commitment_repr.t)
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let '{|
      Commitment_repr.t.blinded_public_key_hash := blinded_public_key_hash;
        Commitment_repr.t.amount := amount
        |} := function_parameter in
    Storage.Commitments.init ctxt blinded_public_key_hash amount in
  Error_monad.op_gtgteqquestion
    (Error_monad.fold_left_s init_commitment ctxt commitments)
    (fun ctxt =&gt; Error_monad.__return ctxt).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_storage.mli">
  <div class="col-md-6">
    <a href="#commitment_storage.mli"><code>commitment_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val init :
  Raw_context.t -&gt; Commitment_repr.t list -&gt; Raw_context.t tzresult Lwt.t

val get_opt :
  Raw_context.t -&gt;
  Blinded_public_key_hash.t -&gt;
  Tez_repr.t option tzresult Lwt.t

val delete :
  Raw_context.t -&gt; Blinded_public_key_hash.t -&gt; Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_storage.mli"><code>Commitment_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Commitment_repr.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

Parameter init :
  Raw_context.t -&gt; list Commitment_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_opt :
  Raw_context.t -&gt; Blinded_public_key_hash.t -&gt;
  Lwt.t (Error_monad.tzresult (option Tez_repr.t)).

Parameter delete :
  Raw_context.t -&gt; Blinded_public_key_hash.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_repr.ml">
  <div class="col-md-6">
    <a href="#constants_repr.ml"><code>constants_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let version_number_004 = &quot;\000&quot;

let version_number = &quot;\001&quot;

let proof_of_work_nonce_size = 8

let nonce_length = 32

let max_revelations_per_block = 32

let max_proposals_per_delegate = 20

let max_operation_data_length = 16 * 1024 (* 16kB *)

type fixed = {
  proof_of_work_nonce_size : int;
  nonce_length : int;
  max_revelations_per_block : int;
  max_operation_data_length : int;
  max_proposals_per_delegate : int;
}

let fixed_encoding =
  let open Data_encoding in
  conv
    (fun c -&gt;
      ( c.proof_of_work_nonce_size,
        c.nonce_length,
        c.max_revelations_per_block,
        c.max_operation_data_length,
        c.max_proposals_per_delegate ))
    (fun ( proof_of_work_nonce_size,
           nonce_length,
           max_revelations_per_block,
           max_operation_data_length,
           max_proposals_per_delegate ) -&gt;
      {
        proof_of_work_nonce_size;
        nonce_length;
        max_revelations_per_block;
        max_operation_data_length;
        max_proposals_per_delegate;
      })
    (obj5
       (req &quot;proof_of_work_nonce_size&quot; uint8)
       (req &quot;nonce_length&quot; uint8)
       (req &quot;max_revelations_per_block&quot; uint8)
       (req &quot;max_operation_data_length&quot; int31)
       (req &quot;max_proposals_per_delegate&quot; uint8))

let fixed =
  {
    proof_of_work_nonce_size;
    nonce_length;
    max_revelations_per_block;
    max_operation_data_length;
    max_proposals_per_delegate;
  }

type parametric = {
  preserved_cycles : int;
  blocks_per_cycle : int32;
  blocks_per_commitment : int32;
  blocks_per_roll_snapshot : int32;
  blocks_per_voting_period : int32;
  time_between_blocks : Period_repr.t list;
  endorsers_per_block : int;
  hard_gas_limit_per_operation : Z.t;
  hard_gas_limit_per_block : Z.t;
  proof_of_work_threshold : int64;
  tokens_per_roll : Tez_repr.t;
  michelson_maximum_type_size : int;
  seed_nonce_revelation_tip : Tez_repr.t;
  origination_size : int;
  block_security_deposit : Tez_repr.t;
  endorsement_security_deposit : Tez_repr.t;
  block_reward : Tez_repr.t;
  endorsement_reward : Tez_repr.t;
  cost_per_byte : Tez_repr.t;
  hard_storage_limit_per_operation : Z.t;
  test_chain_duration : int64;
  (* in seconds *)
  quorum_min : int32;
  quorum_max : int32;
  min_proposal_quorum : int32;
  initial_endorsers : int;
  delay_per_missing_endorsement : Period_repr.t;
}

let parametric_encoding =
  let open Data_encoding in
  conv
    (fun c -&gt;
      ( ( c.preserved_cycles,
          c.blocks_per_cycle,
          c.blocks_per_commitment,
          c.blocks_per_roll_snapshot,
          c.blocks_per_voting_period,
          c.time_between_blocks,
          c.endorsers_per_block,
          c.hard_gas_limit_per_operation,
          c.hard_gas_limit_per_block ),
        ( ( c.proof_of_work_threshold,
            c.tokens_per_roll,
            c.michelson_maximum_type_size,
            c.seed_nonce_revelation_tip,
            c.origination_size,
            c.block_security_deposit,
            c.endorsement_security_deposit,
            c.block_reward ),
          ( c.endorsement_reward,
            c.cost_per_byte,
            c.hard_storage_limit_per_operation,
            c.test_chain_duration,
            c.quorum_min,
            c.quorum_max,
            c.min_proposal_quorum,
            c.initial_endorsers,
            c.delay_per_missing_endorsement ) ) ))
    (fun ( ( preserved_cycles,
             blocks_per_cycle,
             blocks_per_commitment,
             blocks_per_roll_snapshot,
             blocks_per_voting_period,
             time_between_blocks,
             endorsers_per_block,
             hard_gas_limit_per_operation,
             hard_gas_limit_per_block ),
           ( ( proof_of_work_threshold,
               tokens_per_roll,
               michelson_maximum_type_size,
               seed_nonce_revelation_tip,
               origination_size,
               block_security_deposit,
               endorsement_security_deposit,
               block_reward ),
             ( endorsement_reward,
               cost_per_byte,
               hard_storage_limit_per_operation,
               test_chain_duration,
               quorum_min,
               quorum_max,
               min_proposal_quorum,
               initial_endorsers,
               delay_per_missing_endorsement ) ) ) -&gt;
      {
        preserved_cycles;
        blocks_per_cycle;
        blocks_per_commitment;
        blocks_per_roll_snapshot;
        blocks_per_voting_period;
        time_between_blocks;
        endorsers_per_block;
        hard_gas_limit_per_operation;
        hard_gas_limit_per_block;
        proof_of_work_threshold;
        tokens_per_roll;
        michelson_maximum_type_size;
        seed_nonce_revelation_tip;
        origination_size;
        block_security_deposit;
        endorsement_security_deposit;
        block_reward;
        endorsement_reward;
        cost_per_byte;
        hard_storage_limit_per_operation;
        test_chain_duration;
        quorum_min;
        quorum_max;
        min_proposal_quorum;
        initial_endorsers;
        delay_per_missing_endorsement;
      })
    (merge_objs
       (obj9
          (req &quot;preserved_cycles&quot; uint8)
          (req &quot;blocks_per_cycle&quot; int32)
          (req &quot;blocks_per_commitment&quot; int32)
          (req &quot;blocks_per_roll_snapshot&quot; int32)
          (req &quot;blocks_per_voting_period&quot; int32)
          (req &quot;time_between_blocks&quot; (list Period_repr.encoding))
          (req &quot;endorsers_per_block&quot; uint16)
          (req &quot;hard_gas_limit_per_operation&quot; z)
          (req &quot;hard_gas_limit_per_block&quot; z))
       (merge_objs
          (obj8
             (req &quot;proof_of_work_threshold&quot; int64)
             (req &quot;tokens_per_roll&quot; Tez_repr.encoding)
             (req &quot;michelson_maximum_type_size&quot; uint16)
             (req &quot;seed_nonce_revelation_tip&quot; Tez_repr.encoding)
             (req &quot;origination_size&quot; int31)
             (req &quot;block_security_deposit&quot; Tez_repr.encoding)
             (req &quot;endorsement_security_deposit&quot; Tez_repr.encoding)
             (req &quot;block_reward&quot; Tez_repr.encoding))
          (obj9
             (req &quot;endorsement_reward&quot; Tez_repr.encoding)
             (req &quot;cost_per_byte&quot; Tez_repr.encoding)
             (req &quot;hard_storage_limit_per_operation&quot; z)
             (req &quot;test_chain_duration&quot; int64)
             (req &quot;quorum_min&quot; int32)
             (req &quot;quorum_max&quot; int32)
             (req &quot;min_proposal_quorum&quot; int32)
             (req &quot;initial_endorsers&quot; uint16)
             (req &quot;delay_per_missing_endorsement&quot; Period_repr.encoding))))

type t = {fixed : fixed; parametric : parametric}

let encoding =
  let open Data_encoding in
  conv
    (fun {fixed; parametric} -&gt; (fixed, parametric))
    (fun (fixed, parametric) -&gt; {fixed; parametric})
    (merge_objs fixed_encoding parametric_encoding)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_repr.ml"><code>Constants_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Period_repr.
Require Tezos.Tez_repr.

Definition version_number_004 : string := &quot;\000&quot; % string.

Definition version_number : string := &quot;\001&quot; % string.

Definition proof_of_work_nonce_size : Z := 8.

Definition nonce_length : Z := 32.

Definition max_revelations_per_block : Z := 32.

Definition max_proposals_per_delegate : Z := 20.

Definition max_operation_data_length : Z := Pervasives.op_star 16 1024.

Module fixed.
  Record record := {
    proof_of_work_nonce_size : Z;
    nonce_length : Z;
    max_revelations_per_block : Z;
    max_operation_data_length : Z;
    max_proposals_per_delegate : Z }.
End fixed.
Definition fixed := fixed.record.

Definition fixed_encoding : Data_encoding.encoding fixed :=
  Data_encoding.conv
    (fun c =&gt;
      ((fixed.proof_of_work_nonce_size c), (fixed.nonce_length c),
        (fixed.max_revelations_per_block c),
        (fixed.max_operation_data_length c),
        (fixed.max_proposals_per_delegate c)))
    (fun function_parameter =&gt;
      let
        '(proof_of_work_nonce_size, nonce_length, max_revelations_per_block,
          max_operation_data_length, max_proposals_per_delegate) :=
        function_parameter in
      {| fixed.proof_of_work_nonce_size := proof_of_work_nonce_size;
        fixed.nonce_length := nonce_length;
        fixed.max_revelations_per_block := max_revelations_per_block;
        fixed.max_operation_data_length := max_operation_data_length;
        fixed.max_proposals_per_delegate := max_proposals_per_delegate |}) None
    (Data_encoding.obj5
      (Data_encoding.req None None &quot;proof_of_work_nonce_size&quot; % string
        Data_encoding.uint8)
      (Data_encoding.req None None &quot;nonce_length&quot; % string Data_encoding.uint8)
      (Data_encoding.req None None &quot;max_revelations_per_block&quot; % string
        Data_encoding.uint8)
      (Data_encoding.req None None &quot;max_operation_data_length&quot; % string
        Data_encoding.int31)
      (Data_encoding.req None None &quot;max_proposals_per_delegate&quot; % string
        Data_encoding.uint8)).

Definition fixed : fixed :=
  {| fixed.proof_of_work_nonce_size := proof_of_work_nonce_size;
    fixed.nonce_length := nonce_length;
    fixed.max_revelations_per_block := max_revelations_per_block;
    fixed.max_operation_data_length := max_operation_data_length;
    fixed.max_proposals_per_delegate := max_proposals_per_delegate |}.

Module parametric.
  Record record := {
    preserved_cycles : Z;
    blocks_per_cycle : int32;
    blocks_per_commitment : int32;
    blocks_per_roll_snapshot : int32;
    blocks_per_voting_period : int32;
    time_between_blocks : list Period_repr.t;
    endorsers_per_block : Z;
    hard_gas_limit_per_operation : Z.t;
    hard_gas_limit_per_block : Z.t;
    proof_of_work_threshold : int64;
    tokens_per_roll : Tez_repr.t;
    michelson_maximum_type_size : Z;
    seed_nonce_revelation_tip : Tez_repr.t;
    origination_size : Z;
    block_security_deposit : Tez_repr.t;
    endorsement_security_deposit : Tez_repr.t;
    block_reward : Tez_repr.t;
    endorsement_reward : Tez_repr.t;
    cost_per_byte : Tez_repr.t;
    hard_storage_limit_per_operation : Z.t;
    test_chain_duration : int64;
    quorum_min : int32;
    quorum_max : int32;
    min_proposal_quorum : int32;
    initial_endorsers : Z;
    delay_per_missing_endorsement : Period_repr.t }.
End parametric.
Definition parametric := parametric.record.

Definition parametric_encoding : Data_encoding.encoding parametric :=
  Data_encoding.conv
    (fun c =&gt;
      (((parametric.preserved_cycles c), (parametric.blocks_per_cycle c),
        (parametric.blocks_per_commitment c),
        (parametric.blocks_per_roll_snapshot c),
        (parametric.blocks_per_voting_period c),
        (parametric.time_between_blocks c), (parametric.endorsers_per_block c),
        (parametric.hard_gas_limit_per_operation c),
        (parametric.hard_gas_limit_per_block c)),
        (((parametric.proof_of_work_threshold c),
          (parametric.tokens_per_roll c),
          (parametric.michelson_maximum_type_size c),
          (parametric.seed_nonce_revelation_tip c),
          (parametric.origination_size c),
          (parametric.block_security_deposit c),
          (parametric.endorsement_security_deposit c),
          (parametric.block_reward c)),
          ((parametric.endorsement_reward c), (parametric.cost_per_byte c),
            (parametric.hard_storage_limit_per_operation c),
            (parametric.test_chain_duration c), (parametric.quorum_min c),
            (parametric.quorum_max c), (parametric.min_proposal_quorum c),
            (parametric.initial_endorsers c),
            (parametric.delay_per_missing_endorsement c)))))
    (fun function_parameter =&gt;
      let
        '((preserved_cycles, blocks_per_cycle, blocks_per_commitment,
          blocks_per_roll_snapshot, blocks_per_voting_period,
          time_between_blocks, endorsers_per_block,
          hard_gas_limit_per_operation, hard_gas_limit_per_block),
          ((proof_of_work_threshold, tokens_per_roll,
            michelson_maximum_type_size, seed_nonce_revelation_tip,
            origination_size, block_security_deposit,
            endorsement_security_deposit, block_reward),
            (endorsement_reward, cost_per_byte,
              hard_storage_limit_per_operation, test_chain_duration, quorum_min,
              quorum_max, min_proposal_quorum, initial_endorsers,
              delay_per_missing_endorsement))) := function_parameter in
      {| parametric.preserved_cycles := preserved_cycles;
        parametric.blocks_per_cycle := blocks_per_cycle;
        parametric.blocks_per_commitment := blocks_per_commitment;
        parametric.blocks_per_roll_snapshot := blocks_per_roll_snapshot;
        parametric.blocks_per_voting_period := blocks_per_voting_period;
        parametric.time_between_blocks := time_between_blocks;
        parametric.endorsers_per_block := endorsers_per_block;
        parametric.hard_gas_limit_per_operation := hard_gas_limit_per_operation;
        parametric.hard_gas_limit_per_block := hard_gas_limit_per_block;
        parametric.proof_of_work_threshold := proof_of_work_threshold;
        parametric.tokens_per_roll := tokens_per_roll;
        parametric.michelson_maximum_type_size := michelson_maximum_type_size;
        parametric.seed_nonce_revelation_tip := seed_nonce_revelation_tip;
        parametric.origination_size := origination_size;
        parametric.block_security_deposit := block_security_deposit;
        parametric.endorsement_security_deposit := endorsement_security_deposit;
        parametric.block_reward := block_reward;
        parametric.endorsement_reward := endorsement_reward;
        parametric.cost_per_byte := cost_per_byte;
        parametric.hard_storage_limit_per_operation :=
          hard_storage_limit_per_operation;
        parametric.test_chain_duration := test_chain_duration;
        parametric.quorum_min := quorum_min;
        parametric.quorum_max := quorum_max;
        parametric.min_proposal_quorum := min_proposal_quorum;
        parametric.initial_endorsers := initial_endorsers;
        parametric.delay_per_missing_endorsement :=
          delay_per_missing_endorsement |}) None
    (Data_encoding.merge_objs
      (Data_encoding.obj9
        (Data_encoding.req None None &quot;preserved_cycles&quot; % string
          Data_encoding.uint8)
        (Data_encoding.req None None &quot;blocks_per_cycle&quot; % string
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;blocks_per_commitment&quot; % string
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;blocks_per_roll_snapshot&quot; % string
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;blocks_per_voting_period&quot; % string
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;time_between_blocks&quot; % string
          (Data_encoding.__list_value None Period_repr.encoding))
        (Data_encoding.req None None &quot;endorsers_per_block&quot; % string
          Data_encoding.uint16)
        (Data_encoding.req None None &quot;hard_gas_limit_per_operation&quot; % string
          Data_encoding.z)
        (Data_encoding.req None None &quot;hard_gas_limit_per_block&quot; % string
          Data_encoding.z))
      (Data_encoding.merge_objs
        (Data_encoding.obj8
          (Data_encoding.req None None &quot;proof_of_work_threshold&quot; % string
            Data_encoding.__int64_value)
          (Data_encoding.req None None &quot;tokens_per_roll&quot; % string
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;michelson_maximum_type_size&quot; % string
            Data_encoding.uint16)
          (Data_encoding.req None None &quot;seed_nonce_revelation_tip&quot; % string
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;origination_size&quot; % string
            Data_encoding.int31)
          (Data_encoding.req None None &quot;block_security_deposit&quot; % string
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;endorsement_security_deposit&quot; % string
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;block_reward&quot; % string Tez_repr.encoding))
        (Data_encoding.obj9
          (Data_encoding.req None None &quot;endorsement_reward&quot; % string
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;cost_per_byte&quot; % string
            Tez_repr.encoding)
          (Data_encoding.req None None
            &quot;hard_storage_limit_per_operation&quot; % string Data_encoding.z)
          (Data_encoding.req None None &quot;test_chain_duration&quot; % string
            Data_encoding.__int64_value)
          (Data_encoding.req None None &quot;quorum_min&quot; % string
            Data_encoding.__int32_value)
          (Data_encoding.req None None &quot;quorum_max&quot; % string
            Data_encoding.__int32_value)
          (Data_encoding.req None None &quot;min_proposal_quorum&quot; % string
            Data_encoding.__int32_value)
          (Data_encoding.req None None &quot;initial_endorsers&quot; % string
            Data_encoding.uint16)
          (Data_encoding.req None None &quot;delay_per_missing_endorsement&quot; % string
            Period_repr.encoding)))).

Module t.
  Record record := {
    fixed : fixed;
    parametric : parametric }.
End t.
Definition t := t.record.

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{| t.fixed := fixed; t.parametric := parametric |} :=
        function_parameter in
      (fixed, parametric))
    (fun function_parameter =&gt;
      let '(fixed, parametric) := function_parameter in
      {| t.fixed := fixed; t.parametric := parametric |}) None
    (Data_encoding.merge_objs fixed_encoding parametric_encoding).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_services.ml">
  <div class="col-md-6">
    <a href="#constants_services.ml"><code>constants_services.ml</code></a>&nbsp;<span class="label label-danger">29 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

let custom_root =
  ( RPC_path.(open_root / &quot;context&quot; / &quot;constants&quot;)
    : RPC_context.t RPC_path.context )

module S = struct
  open Data_encoding

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">errors</abbr> =
    RPC_service.get_service
      ~description:&quot;Schema for all the RPC errors from this protocol version&quot;
      ~query:RPC_query.empty
      ~output:json_schema
      RPC_path.(custom_root / &quot;errors&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">all</abbr> =
    RPC_service.get_service
      ~description:&quot;All constants&quot;
      ~query:RPC_query.empty
      ~output:Alpha_context.Constants.encoding
      custom_root
end

let register () =
  let open Services_registration in
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0_noctxt S.errors (fun () () -&gt;
      return Data_encoding.Json.(schema error_encoding)) ;
  register0 S.all (fun ctxt () () -&gt;
      let open Constants in
      return {fixed; parametric = parametric ctxt})</abbr>

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">errors</abbr> ctxt block = RPC_context.make_call0 S.errors ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">all</abbr> ctxt block = RPC_context.make_call0 S.all ctxt block () ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_services.ml"><code>Constants_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Services_registration.

Import Alpha_context.

Definition custom_root : RPC_path.context RPC_context.t :=
  RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot; % string)
    &quot;constants&quot; % string.

Module S.
  Import Data_encoding.
  
  Definition errors
    : RPC_service.service (* `GET *) unit RPC_context.t RPC_context.t unit unit
      Data_encoding.json_schema :=
    RPC_service.get_service
      (Some &quot;Schema for all the RPC errors from this protocol version&quot; % string)
      RPC_query.empty Data_encoding.__json_schema_value
      (RPC_path.op_div custom_root &quot;errors&quot; % string).
  
  Definition all
    : RPC_service.service (* `GET *) unit RPC_context.t RPC_context.t unit unit
      Alpha_context.Constants.t :=
    RPC_service.get_service (Some &quot;All constants&quot; % string) RPC_query.empty
      Alpha_context.Constants.encoding custom_root.
End S.

Definition register (function_parameter : unit) : unit :=
  let 'tt := function_parameter in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register0 S.all
    (fun ctxt =&gt;
      fun function_parameter =&gt;
        let 'tt := function_parameter in
        fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.__return
            {| Alpha_context.Constants.t.fixed := Alpha_context.Constants.fixed;
              Alpha_context.Constants.t.parametric :=
                Alpha_context.Constants.parametric ctxt |}).

Definition errors {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t (Error_monad.shell_tzresult Data_encoding.json_schema) :=
  RPC_context.make_call0 S.errors ctxt block tt tt.

Definition all {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Constants.t) :=
  RPC_context.make_call0 S.all ctxt block tt tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_services.mli">
  <div class="col-md-6">
    <a href="#constants_services.mli"><code>constants_services.mli</code></a>&nbsp;<span class="label label-danger">26 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val errors :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Data_encoding.json_schema shell_tzresult Lwt.t</abbr>

(** Returns all the constants of the protocol *)
<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val all : 'a #RPC_context.simple -&gt; 'a -&gt; Constants.t shell_tzresult Lwt.t</abbr>

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_services.mli"><code>Constants_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.

Parameter errors : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Lwt.t (Error_monad.shell_tzresult Data_encoding.json_schema).

Parameter all : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Lwt.t (Error_monad.shell_tzresult Alpha_context.Constants.t).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_storage.ml">
  <div class="col-md-6">
    <a href="#constants_storage.ml"><code>constants_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let preserved_cycles c =
  let constants = Raw_context.constants c in
  constants.preserved_cycles

let blocks_per_cycle c =
  let constants = Raw_context.constants c in
  constants.blocks_per_cycle

let blocks_per_commitment c =
  let constants = Raw_context.constants c in
  constants.blocks_per_commitment

let blocks_per_roll_snapshot c =
  let constants = Raw_context.constants c in
  constants.blocks_per_roll_snapshot

let blocks_per_voting_period c =
  let constants = Raw_context.constants c in
  constants.blocks_per_voting_period

let time_between_blocks c =
  let constants = Raw_context.constants c in
  constants.time_between_blocks

let endorsers_per_block c =
  let constants = Raw_context.constants c in
  constants.endorsers_per_block

let initial_endorsers c =
  let constants = Raw_context.constants c in
  constants.initial_endorsers

let delay_per_missing_endorsement c =
  let constants = Raw_context.constants c in
  constants.delay_per_missing_endorsement

let hard_gas_limit_per_operation c =
  let constants = Raw_context.constants c in
  constants.hard_gas_limit_per_operation

let hard_gas_limit_per_block c =
  let constants = Raw_context.constants c in
  constants.hard_gas_limit_per_block

let cost_per_byte c =
  let constants = Raw_context.constants c in
  constants.cost_per_byte

let hard_storage_limit_per_operation c =
  let constants = Raw_context.constants c in
  constants.hard_storage_limit_per_operation

let proof_of_work_threshold c =
  let constants = Raw_context.constants c in
  constants.proof_of_work_threshold

let tokens_per_roll c =
  let constants = Raw_context.constants c in
  constants.tokens_per_roll

let michelson_maximum_type_size c =
  let constants = Raw_context.constants c in
  constants.michelson_maximum_type_size

let seed_nonce_revelation_tip c =
  let constants = Raw_context.constants c in
  constants.seed_nonce_revelation_tip

let origination_size c =
  let constants = Raw_context.constants c in
  constants.origination_size

let block_security_deposit c =
  let constants = Raw_context.constants c in
  constants.block_security_deposit

let endorsement_security_deposit c =
  let constants = Raw_context.constants c in
  constants.endorsement_security_deposit

let block_reward c =
  let constants = Raw_context.constants c in
  constants.block_reward

let endorsement_reward c =
  let constants = Raw_context.constants c in
  constants.endorsement_reward

let test_chain_duration c =
  let constants = Raw_context.constants c in
  constants.test_chain_duration

let quorum_min c =
  let constants = Raw_context.constants c in
  constants.quorum_min

let quorum_max c =
  let constants = Raw_context.constants c in
  constants.quorum_max

let min_proposal_quorum c =
  let constants = Raw_context.constants c in
  constants.min_proposal_quorum

let parametric c = Raw_context.constants c
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_storage.ml"><code>Constants_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Period_repr.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

Definition preserved_cycles (c : Raw_context.context) : Z :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.preserved_cycles constants.

Definition blocks_per_cycle (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.blocks_per_cycle constants.

Definition blocks_per_commitment (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.blocks_per_commitment constants.

Definition blocks_per_roll_snapshot (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.blocks_per_roll_snapshot constants.

Definition blocks_per_voting_period (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.blocks_per_voting_period constants.

Definition time_between_blocks (c : Raw_context.context) : list Period_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.time_between_blocks constants.

Definition endorsers_per_block (c : Raw_context.context) : Z :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.endorsers_per_block constants.

Definition initial_endorsers (c : Raw_context.context) : Z :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.initial_endorsers constants.

Definition delay_per_missing_endorsement (c : Raw_context.context)
  : Period_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.delay_per_missing_endorsement constants.

Definition hard_gas_limit_per_operation (c : Raw_context.context) : Z.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.hard_gas_limit_per_operation constants.

Definition hard_gas_limit_per_block (c : Raw_context.context) : Z.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.hard_gas_limit_per_block constants.

Definition cost_per_byte (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.cost_per_byte constants.

Definition hard_storage_limit_per_operation (c : Raw_context.context) : Z.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.hard_storage_limit_per_operation constants.

Definition proof_of_work_threshold (c : Raw_context.context) : int64 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.proof_of_work_threshold constants.

Definition tokens_per_roll (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.tokens_per_roll constants.

Definition michelson_maximum_type_size (c : Raw_context.context) : Z :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.michelson_maximum_type_size constants.

Definition seed_nonce_revelation_tip (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.seed_nonce_revelation_tip constants.

Definition origination_size (c : Raw_context.context) : Z :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.origination_size constants.

Definition block_security_deposit (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.block_security_deposit constants.

Definition endorsement_security_deposit (c : Raw_context.context)
  : Tez_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.endorsement_security_deposit constants.

Definition block_reward (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.block_reward constants.

Definition endorsement_reward (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.endorsement_reward constants.

Definition test_chain_duration (c : Raw_context.context) : int64 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.test_chain_duration constants.

Definition quorum_min (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.quorum_min constants.

Definition quorum_max (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.quorum_max constants.

Definition min_proposal_quorum (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  Constants_repr.parametric.min_proposal_quorum constants.

Definition parametric (c : Raw_context.context) : Constants_repr.parametric :=
  Raw_context.constants c.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_hash.ml">
  <div class="col-md-6">
    <a href="#contract_hash.ml"><code>contract_hash.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* 20 *)
let contract_hash = &quot;\002\090\121&quot; (* KT1(36) *)

module Blake2BModule = Blake2B.Make
          (Base58)
          (struct
            let name = &quot;Contract_hash&quot;

            let title = &quot;A contract ID&quot;

            let b58check_prefix = contract_hash

            let size = Some 20
          end)

include Blake2BModule

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () = Base58.check_encoded_prefix b58check_encoding &quot;KT1&quot; 36</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_hash.ml"><code>Contract_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition contract_hash : string := &quot;\002Zy&quot; % string.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT _ tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
        |}))
    (let name := &quot;Contract_hash&quot; % string in
    let title := &quot;A contract ID&quot; % string in
    let b58check_prefix := contract_hash in
    let size := Some 20 in
    existT _ tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
        |}).

Definition t := Blake2BModule.[S.HASH.t].

Definition name := Blake2BModule.[S.HASH.name].

Definition title := Blake2BModule.[S.HASH.title].

Definition pp := Blake2BModule.[S.HASH.pp].

Definition pp_short := Blake2BModule.[S.HASH.pp_short].

Definition op_eq := Blake2BModule.[S.HASH.op_eq].

Definition op_ltgt := Blake2BModule.[S.HASH.op_ltgt].

Definition op_lt := Blake2BModule.[S.HASH.op_lt].

Definition op_lteq := Blake2BModule.[S.HASH.op_lteq].

Definition op_gteq := Blake2BModule.[S.HASH.op_gteq].

Definition op_gt := Blake2BModule.[S.HASH.op_gt].

Definition compare := Blake2BModule.[S.HASH.compare].

Definition equal := Blake2BModule.[S.HASH.equal].

Definition max := Blake2BModule.[S.HASH.max].

Definition min := Blake2BModule.[S.HASH.min].

Definition hash_bytes := Blake2BModule.[S.HASH.hash_bytes].

Definition hash_string := Blake2BModule.[S.HASH.hash_string].

Definition zero := Blake2BModule.[S.HASH.zero].

Definition size := Blake2BModule.[S.HASH.size].

Definition to_bytes := Blake2BModule.[S.HASH.to_bytes].

Definition of_bytes_opt := Blake2BModule.[S.HASH.of_bytes_opt].

Definition of_bytes_exn := Blake2BModule.[S.HASH.of_bytes_exn].

Definition to_b58check := Blake2BModule.[S.HASH.to_b58check].

Definition to_short_b58check := Blake2BModule.[S.HASH.to_short_b58check].

Definition of_b58check_exn := Blake2BModule.[S.HASH.of_b58check_exn].

Definition of_b58check_opt := Blake2BModule.[S.HASH.of_b58check_opt].

Definition b58check_encoding := Blake2BModule.[S.HASH.b58check_encoding].

Definition encoding := Blake2BModule.[S.HASH.encoding].

Definition rpc_arg := Blake2BModule.[S.HASH.rpc_arg].

Definition to_path := Blake2BModule.[S.HASH.to_path].

Definition of_path := Blake2BModule.[S.HASH.of_path].

Definition of_path_exn := Blake2BModule.[S.HASH.of_path_exn].

Definition prefix_path := Blake2BModule.[S.HASH.prefix_path].

Definition path_length := Blake2BModule.[S.HASH.path_length].

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_repr.ml">
  <div class="col-md-6">
    <a href="#contract_repr.ml"><code>contract_repr.ml</code></a>&nbsp;<span class="label label-danger">17 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t =
  | Implicit of Signature.Public_key_hash.t
  | Originated of Contract_hash.t

module CompareModule = Compare.Make (struct
  type nonrec t = t

  let compare l1 l2 =
    match (l1, l2) with
    | (Implicit pkh1, Implicit pkh2) -&gt;
        Signature.Public_key_hash.compare pkh1 pkh2
    | (Originated h1, Originated h2) -&gt;
        Contract_hash.compare h1 h2
    | (Implicit _, Originated _) -&gt;
        -1
    | (Originated _, Implicit _) -&gt;
        1
end)

include CompareModule

type contract = t

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_contract_notation of string</abbr> (* `Permanent *)

let to_b58check = function
  | Implicit pbk -&gt;
      Signature.Public_key_hash.to_b58check pbk
  | Originated h -&gt;
      Contract_hash.to_b58check h

let of_b58check s =
  match Base58.decode s with
  | Some (Ed25519.Public_key_hash.Data h) -&gt;
      ok (Implicit (Signature.Ed25519Hash h))
  | Some (Secp256k1.Public_key_hash.Data h) -&gt;
      ok (Implicit (Signature.Secp256k1Hash h))
  | Some (P256.Public_key_hash.Data h) -&gt;
      ok (Implicit (Signature.P256Hash h))
  | Some (Contract_hash.Data h) -&gt;
      ok (Originated h)
  | _ -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_contract_notation s)</abbr>

let pp ppf = function
  | Implicit pbk -&gt;
      Signature.Public_key_hash.pp ppf pbk
  | Originated h -&gt;
      Contract_hash.pp ppf h

let pp_short ppf = function
  | Implicit pbk -&gt;
      Signature.Public_key_hash.pp_short ppf pbk
  | Originated h -&gt;
      Contract_hash.pp_short ppf h

let encoding =
  let open Data_encoding in
  def
    &quot;contract_id&quot;
    ~title:&quot;A contract handle&quot;
    ~description:
      &quot;A contract notation as given to an RPC or inside scripts. Can be a \
       base58 implicit contract hash or a base58 originated contract hash.&quot;
  @@ splitted
       ~binary:
         (union
            ~tag_size:<abbr class="mark-error" title="Variants not supported">`Uint8</abbr>
            [ case
                (Tag 0)
                ~title:&quot;Implicit&quot;
                Signature.Public_key_hash.encoding
                (function Implicit k -&gt; Some k | _ -&gt; None)
                (fun k -&gt; Implicit k);
              case
                (Tag 1)
                (Fixed.add_padding Contract_hash.encoding 1)
                ~title:&quot;Originated&quot;
                (function Originated k -&gt; Some k | _ -&gt; None)
                (fun k -&gt; Originated k) ])
       ~json:
         (conv
            to_b58check
            (fun s -&gt;
              match of_b58check s with
              | Ok s -&gt;
                  s
              | Error _ -&gt;
                  Json.cannot_destruct &quot;Invalid contract notation.&quot;)
            string)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;contract.invalid_contract_notation&quot;
    ~title:&quot;Invalid contract notation&quot;
    ~pp:(fun ppf x -&gt; Format.fprintf ppf &quot;Invalid contract notation %S&quot; x)
    ~description:
      &quot;A malformed contract notation was given to an RPC or in a script.&quot;
    (obj1 (req &quot;notation&quot; string))
    (function Invalid_contract_notation loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Invalid_contract_notation loc)</abbr>

let implicit_contract id = Implicit id

let is_implicit = function Implicit m -&gt; Some m | Originated _ -&gt; None

let is_originated = function Implicit _ -&gt; None | Originated h -&gt; Some h

type origination_nonce = {
  operation_hash : Operation_hash.t;
  origination_index : int32;
}

let origination_nonce_encoding =
  let open Data_encoding in
  conv
    (fun {operation_hash; origination_index} -&gt;
      (operation_hash, origination_index))
    (fun (operation_hash, origination_index) -&gt;
      {operation_hash; origination_index})
  @@ obj2 (req &quot;operation&quot; Operation_hash.encoding) (dft &quot;index&quot; int32 0l)

let originated_contract nonce =
  let data =
    Data_encoding.Binary.to_bytes_exn origination_nonce_encoding nonce
  in
  Originated (Contract_hash.hash_bytes [data])

let originated_contracts
    ~since:{origination_index = first; operation_hash = first_hash}
    ~until:( {origination_index = last; operation_hash = last_hash} as
           origination_nonce ) =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Operation_hash.equal first_hash last_hash) ;
  let rec contracts acc origination_index =
    if Compare.Int32.(origination_index &lt; first) then acc
    else
      let origination_nonce = </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Record substitution not handled">{origination_nonce with origination_index}</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> in
      let acc = originated_contract origination_nonce :: acc in
      contracts acc (Int32.pred origination_index)
  in
  contracts [] (Int32.pred last)</abbr>

let initial_origination_nonce operation_hash =
  {operation_hash; origination_index = 0l}

let incr_origination_nonce nonce =
  let origination_index = Int32.succ nonce.origination_index in
  <abbr class="mark-error" title="Record substitution not handled">{nonce with origination_index}</abbr>

let rpc_arg =
  let construct = to_b58check in
  let destruct hash =
    match of_b58check hash with
    | Error _ -&gt;
        Error &quot;Cannot parse contract id&quot;
    | Ok contract -&gt;
        Ok contract
  in
  RPC_arg.make
    ~descr:&quot;A contract identifier encoded in b58check.&quot;
    ~name:&quot;contract_id&quot;
    ~construct
    ~destruct
    ()

module Index = struct
  type t = contract

  let path_length = 7

  let to_path c l =
    let raw_key = Data_encoding.Binary.to_bytes_exn encoding c in
    let <abbr class="mark-error" title="Patterns on variants are not supported">(`Hex key)</abbr> = MBytes.to_hex raw_key in
    let <abbr class="mark-error" title="Patterns on variants are not supported">(`Hex index_key)</abbr> = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
    String.sub index_key 0 2 :: String.sub index_key 2 2
    :: String.sub index_key 4 2 :: String.sub index_key 6 2
    :: String.sub index_key 8 2 :: String.sub index_key 10 2 :: key :: l

  let of_path = function
    | []
    | [_]
    | [_; _]
    | [_; _; _]
    | [_; _; _; _]
    | [_; _; _; _; _]
    | [_; _; _; _; _; _]
    | _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ -&gt;
        None
    | [index1; index2; index3; index4; index5; index6; key] -&gt;
        let raw_key = MBytes.of_hex <abbr class="mark-error" title="Variants not supported">(`Hex key)</abbr> in
        let <abbr class="mark-error" title="Patterns on variants are not supported">(`Hex index_key)</abbr> = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
        <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 0 2 = index1)) ;
        </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 2 2 = index2)) ;
        </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 4 2 = index3)) ;
        </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 6 2 = index4)) ;
        </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 8 2 = index5)) ;
        </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 10 2 = index6)) ;
        Data_encoding.Binary.of_bytes encoding raw_key</abbr>

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_repr.ml"><code>Contract_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_hash.

Inductive t : Set :=
| Implicit : Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; t
| Originated : Contract_hash.t -&gt; t.

Definition CompareModule :=
  Compare.Make
    (let compare (l1 : t) (l2 : t) : Z :=
      match (l1, l2) with
      | (Implicit pkh1, Implicit pkh2) =&gt;
        Signature.Public_key_hash.[S.SPublic_key_hash.compare] pkh1 pkh2
      | (Originated h1, Originated h2) =&gt; Contract_hash.compare h1 h2
      | (Implicit _, Originated _) =&gt; (-1)
      | (Originated _, Implicit _) =&gt; 1
      end in
    existT _ _
      {|
        Compare.COMPARABLE.compare := compare
        |}).

Definition op_eq := CompareModule.[Compare.S.op_eq].

Definition op_ltgt := CompareModule.[Compare.S.op_ltgt].

Definition op_lt := CompareModule.[Compare.S.op_lt].

Definition op_lteq := CompareModule.[Compare.S.op_lteq].

Definition op_gteq := CompareModule.[Compare.S.op_gteq].

Definition op_gt := CompareModule.[Compare.S.op_gt].

Definition compare := CompareModule.[Compare.S.compare].

Definition equal := CompareModule.[Compare.S.equal].

Definition max := CompareModule.[Compare.S.max].

Definition min := CompareModule.[Compare.S.min].

Definition contract := t.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

Definition to_b58check (function_parameter : t) : string :=
  match function_parameter with
  | Implicit pbk =&gt;
    Signature.Public_key_hash.[S.SPublic_key_hash.to_b58check] pbk
  | Originated h =&gt; Contract_hash.to_b58check h
  end.

Definition of_b58check (s : string) : Error_monad.tzresult t :=
  match Base58.decode s with
  | Some (Base58.Data h) =&gt; Error_monad.ok (Implicit (Signature.Ed25519Hash h))
  | Some (Base58.Data h) =&gt;
    Error_monad.ok (Implicit (Signature.Secp256k1Hash h))
  | Some (Base58.Data h) =&gt; Error_monad.ok (Implicit (Signature.P256Hash h))
  | Some (Base58.Data h) =&gt; Error_monad.ok (Originated h)
  | _ =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition pp (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Implicit pbk =&gt; Signature.Public_key_hash.[S.SPublic_key_hash.pp] ppf pbk
  | Originated h =&gt; Contract_hash.pp ppf h
  end.

Definition pp_short (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Implicit pbk =&gt;
    Signature.Public_key_hash.[S.SPublic_key_hash.pp_short] ppf pbk
  | Originated h =&gt; Contract_hash.pp_short ppf h
  end.

Definition encoding : Data_encoding.encoding t :=
  Pervasives.op_atat
    (Data_encoding.def &quot;contract_id&quot; % string
      (Some &quot;A contract handle&quot; % string)
      (Some
        &quot;A contract notation as given to an RPC or inside scripts. Can be a base58 implicit contract hash or a base58 originated contract hash.&quot;
          % string))
    (Data_encoding.splitted
      (Data_encoding.conv to_b58check
        (fun s =&gt;
          match of_b58check s with
          | Pervasives.Ok s =&gt; s
          | Pervasives.Error _ =&gt;
            Data_encoding.Json.cannot_destruct
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.String_literal
                  &quot;Invalid contract notation.&quot; % string
                  CamlinternalFormatBasics.End_of_format)
                &quot;Invalid contract notation.&quot; % string)
          end) None Data_encoding.__string_value)
      (Data_encoding.union
        (Some
          (* ‚ùå Variants not supported *)
          (* ‚ùå `Uint8 *)
          tt)
        (cons
          (Data_encoding.__case_value &quot;Implicit&quot; % string None
            (Data_encoding.Tag 0)
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
            (fun function_parameter =&gt;
              match function_parameter with
              | Implicit k =&gt; Some k
              | _ =&gt; None
              end) (fun k =&gt; Implicit k))
          (cons
            (Data_encoding.__case_value &quot;Originated&quot; % string None
              (Data_encoding.Tag 1)
              (Data_encoding.Fixed.add_padding Contract_hash.encoding 1)
              (fun function_parameter =&gt;
                match function_parameter with
                | Originated k =&gt; Some k
                | _ =&gt; None
                end) (fun k =&gt; Originated k)) [])))).

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition implicit_contract
  (id : Signature.Public_key_hash.[S.SPublic_key_hash.t]) : t := Implicit id.

Definition is_implicit (function_parameter : t)
  : option Signature.Public_key_hash.[S.SPublic_key_hash.t] :=
  match function_parameter with
  | Implicit m =&gt; Some m
  | Originated _ =&gt; None
  end.

Definition is_originated (function_parameter : t) : option Contract_hash.t :=
  match function_parameter with
  | Implicit _ =&gt; None
  | Originated h =&gt; Some h
  end.

Module origination_nonce.
  Record record := {
    operation_hash : Operation_hash.[S.HASH.t];
    origination_index : int32 }.
End origination_nonce.
Definition origination_nonce := origination_nonce.record.

Definition origination_nonce_encoding
  : Data_encoding.encoding origination_nonce :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.conv
        (fun function_parameter =&gt;
          let '{|
            origination_nonce.operation_hash := operation_hash;
              origination_nonce.origination_index := origination_index
              |} := function_parameter in
          (operation_hash, origination_index))
        (fun function_parameter =&gt;
          let '(operation_hash, origination_index) := function_parameter in
          {| origination_nonce.operation_hash := operation_hash;
            origination_nonce.origination_index := origination_index |}) in
    fun eta =&gt; arg None eta)
    (Data_encoding.obj2
      (Data_encoding.req None None &quot;operation&quot; % string
        Operation_hash.[S.HASH.encoding])
      (Data_encoding.dft None None &quot;index&quot; % string Data_encoding.__int32_value
        (* ‚ùå Constant of type int32 is converted to int *)
        0)).

Definition originated_contract (nonce : origination_nonce) : t :=
  let data := Data_encoding.Binary.to_bytes_exn origination_nonce_encoding nonce
    in
  Originated (Contract_hash.hash_bytes None (cons data [])).

Definition originated_contracts (function_parameter : origination_nonce)
  : origination_nonce -&gt; list t :=
  let '{|
    origination_nonce.operation_hash := first_hash;
      origination_nonce.origination_index := first
      |} := function_parameter in
  fun function_parameter =&gt;
    let
      '{|
        origination_nonce.operation_hash := last_hash;
          origination_nonce.origination_index := last
          |} as origination_nonce := function_parameter in
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    let fix contracts
      (acc : list t) (origination_index : Compare.Int32.[Compare.S.t])
      {struct acc} : list t :=
      if Compare.Int32.[Compare.S.op_lt] origination_index first then
        acc
      else
        let origination_nonce :=
          (* ‚ùå Record substitution not handled *)
          record_substitution in
        let acc := cons (originated_contract origination_nonce) acc in
        contracts acc (Int32.pred origination_index) in
    contracts [] (Int32.pred last).

Definition initial_origination_nonce
  (operation_hash : Operation_hash.[S.HASH.t]) : origination_nonce :=
  {| origination_nonce.operation_hash := operation_hash;
    origination_nonce.origination_index :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0 |}.

Definition incr_origination_nonce (nonce : origination_nonce)
  : origination_nonce :=
  let origination_index :=
    Int32.succ (origination_nonce.origination_index nonce) in
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition rpc_arg : RPC_arg.arg t :=
  let construct := to_b58check in
  let destruct (__hash_value : string) : Pervasives.result t string :=
    match of_b58check __hash_value with
    | Pervasives.Error _ =&gt; Pervasives.Error &quot;Cannot parse contract id&quot; % string
    | Pervasives.Ok contract =&gt; Pervasives.Ok contract
    end in
  RPC_arg.make (Some &quot;A contract identifier encoded in b58check.&quot; % string)
    &quot;contract_id&quot; % string destruct construct tt.

Module Index.
  Definition t := contract.
  
  Definition path_length : Z := 7.
  
  Definition to_path (c : t) (l : list string) : list string :=
    let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
    let 'Hex key := MBytes.to_hex raw_key in
    let 'Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
    cons (String.sub index_key 0 2)
      (cons (String.sub index_key 2 2)
        (cons (String.sub index_key 4 2)
          (cons (String.sub index_key 6 2)
            (cons (String.sub index_key 8 2)
              (cons (String.sub index_key 10 2) (cons key l)))))).
  
  Definition of_path (function_parameter : list Compare.String.[Compare.S.t])
    : option t :=
    match function_parameter with
    |
      [] | cons _ [] | cons _ (cons _ []) | cons _ (cons _ (cons _ [])) |
      cons _ (cons _ (cons _ (cons _ []))) |
      cons _ (cons _ (cons _ (cons _ (cons _ [])))) |
      cons _ (cons _ (cons _ (cons _ (cons _ (cons _ []))))) |
      cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ _))))))) =&gt;
      None
    |
      cons index1
        (cons index2
          (cons index3 (cons index4 (cons index5 (cons index6 (cons key []))))))
      =&gt;
      let raw_key :=
        MBytes.of_hex
          (* ‚ùå Variants not supported *)
          (* ‚ùå `Hex *)
          key in
      let 'Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      Data_encoding.Binary.of_bytes encoding raw_key
    end.
  
  Definition rpc_arg : RPC_arg.arg t := rpc_arg.
  
  Definition encoding : Data_encoding.encoding t := encoding.
  
  Definition compare : t -&gt; t -&gt; Z := compare.
End Index.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_repr.mli">
  <div class="col-md-6">
    <a href="#contract_repr.mli"><code>contract_repr.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = private
  | Implicit of Signature.Public_key_hash.t
  | Originated of Contract_hash.t

type contract = t

include Compare.S with type t := contract

(** {2 Implicit contracts} *)

val implicit_contract : Signature.Public_key_hash.t -&gt; contract

val is_implicit : contract -&gt; Signature.Public_key_hash.t option

(** {2 Originated contracts} *)

(** Originated contracts handles are crafted from the hash of the
    operation that triggered their origination (and nothing else).
    As a single operation can trigger several originations, the
    corresponding handles are forged from a deterministic sequence of
    nonces, initialized with the hash of the operation. *)
type origination_nonce

val originated_contract : origination_nonce -&gt; contract

val originated_contracts :
  since:origination_nonce -&gt; until:origination_nonce -&gt; contract list

val initial_origination_nonce : Operation_hash.t -&gt; origination_nonce

val incr_origination_nonce : origination_nonce -&gt; origination_nonce

val is_originated : contract -&gt; Contract_hash.t option

(** {2 Human readable notation} *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_contract_notation of string</abbr> (* `Permanent *)

val to_b58check : contract -&gt; string

val of_b58check : string -&gt; contract tzresult

val pp : Format.formatter -&gt; contract -&gt; unit

val pp_short : Format.formatter -&gt; contract -&gt; unit

(** {2 Serializers} *)

val encoding : contract Data_encoding.t

val origination_nonce_encoding : origination_nonce Data_encoding.t

val rpc_arg : contract RPC_arg.arg

module Index : Storage_description.INDEX with type t = t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_repr.mli"><code>Contract_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_hash.
Require Tezos.Storage_description.

Inductive t : Set :=
| Implicit : Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; t
| Originated : Contract_hash.t -&gt; t.

Definition contract := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature contract}.

Definition op_eq := Included_S.[Compare.S.op_eq].

Definition op_ltgt := Included_S.[Compare.S.op_ltgt].

Definition op_lt := Included_S.[Compare.S.op_lt].

Definition op_lteq := Included_S.[Compare.S.op_lteq].

Definition op_gteq := Included_S.[Compare.S.op_gteq].

Definition op_gt := Included_S.[Compare.S.op_gt].

Definition compare := Included_S.[Compare.S.compare].

Definition equal := Included_S.[Compare.S.equal].

Definition max := Included_S.[Compare.S.max].

Definition min := Included_S.[Compare.S.min].

Parameter implicit_contract :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; contract.

Parameter is_implicit :
  contract -&gt; option Signature.Public_key_hash.[S.SPublic_key_hash.t].

Parameter origination_nonce : Set.

Parameter originated_contract : origination_nonce -&gt; contract.

Parameter originated_contracts :
  origination_nonce -&gt; origination_nonce -&gt; list contract.

Parameter initial_origination_nonce :
  Operation_hash.[S.HASH.t] -&gt; origination_nonce.

Parameter incr_origination_nonce : origination_nonce -&gt; origination_nonce.

Parameter is_originated : contract -&gt; option Contract_hash.t.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter to_b58check : contract -&gt; string.

Parameter of_b58check : string -&gt; Error_monad.tzresult contract.

Parameter pp : Format.formatter -&gt; contract -&gt; unit.

Parameter pp_short : Format.formatter -&gt; contract -&gt; unit.

Parameter encoding : Data_encoding.t contract.

Parameter origination_nonce_encoding : Data_encoding.t origination_nonce.

Parameter rpc_arg : RPC_arg.arg contract.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature t}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_services.ml">
  <div class="col-md-6">
    <a href="#contract_services.ml"><code>contract_services.ml</code></a>&nbsp;<span class="label label-danger">224 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

let custom_root =
  ( RPC_path.(open_root / &quot;context&quot; / &quot;contracts&quot;)
    : RPC_context.t RPC_path.context )

let big_map_root =
  ( RPC_path.(open_root / &quot;context&quot; / &quot;big_maps&quot;)
    : RPC_context.t RPC_path.context )

type info = {
  balance : Tez.t;
  delegate : public_key_hash option;
  counter : counter option;
  script : Script.t option;
}

let info_encoding =
  let open Data_encoding in
  conv
    (fun {balance; delegate; script; counter} -&gt;
      (balance, delegate, script, counter))
    (fun (balance, delegate, script, counter) -&gt;
      {balance; delegate; script; counter})
  @@ obj4
       (req &quot;balance&quot; Tez.encoding)
       (opt &quot;delegate&quot; Signature.Public_key_hash.encoding)
       (opt &quot;script&quot; Script.encoding)
       (opt &quot;counter&quot; n)

module S = struct
  open Data_encoding

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">balance</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the balance of a contract.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;balance&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">manager_key</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the manager of a contract.&quot;
      ~query:RPC_query.empty
      ~output:(option Signature.Public_key.encoding)
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;manager_key&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">delegate</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the delegate of a contract, if any.&quot;
      ~query:RPC_query.empty
      ~output:Signature.Public_key_hash.encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;delegate&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">counter</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the counter of a contract, if any.&quot;
      ~query:RPC_query.empty
      ~output:z
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;counter&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">script</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the code and data of the contract.&quot;
      ~query:RPC_query.empty
      ~output:Script.encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;script&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">storage</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the data of the contract.&quot;
      ~query:RPC_query.empty
      ~output:Script.expr_encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;storage&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">entrypoint_type</abbr> =
    RPC_service.get_service
      ~description:&quot;Return the type of the given entrypoint of the contract&quot;
      ~query:RPC_query.empty
      ~output:Script.expr_encoding
      RPC_path.(
        custom_root /: Contract.rpc_arg / &quot;entrypoints&quot; /: RPC_arg.string)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">list_entrypoints</abbr> =
    RPC_service.get_service
      ~description:&quot;Return the list of entrypoints of the contract&quot;
      ~query:RPC_query.empty
      ~output:
        (obj2
           (dft
              &quot;unreachable&quot;
              (Data_encoding.list
                 (obj1
                    (req
                       &quot;path&quot;
                       (Data_encoding.list
                          Michelson_v1_primitives.prim_encoding))))
              [])
           (req &quot;entrypoints&quot; (assoc Script.expr_encoding)))
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;entrypoints&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">contract_big_map_get_opt</abbr> =
    RPC_service.post_service
      ~description:
        &quot;Access the value associated with a key in a big map of the contract \
         (deprecated).&quot;
      ~query:RPC_query.empty
      ~input:
        (obj2
           (req &quot;key&quot; Script.expr_encoding)
           (req &quot;type&quot; Script.expr_encoding))
      ~output:(option Script.expr_encoding)
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;big_map_get&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">big_map_get</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the value associated with a key in a big map.&quot;
      ~query:RPC_query.empty
      ~output:Script.expr_encoding
      RPC_path.(big_map_root /: Big_map.rpc_arg /: Script_expr_hash.rpc_arg)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">info</abbr> =
    RPC_service.get_service
      ~description:&quot;Access the complete status of a contract.&quot;
      ~query:RPC_query.empty
      ~output:info_encoding
      RPC_path.(custom_root /: Contract.rpc_arg)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">list</abbr> =
    RPC_service.get_service
      ~description:
        &quot;All existing contracts (including non-empty default contracts).&quot;
      ~query:RPC_query.empty
      ~output:(list Contract.encoding)
      custom_root
end

let register () =
  let open Services_registration in
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.list (fun ctxt () () -&gt; Contract.list ctxt &gt;&gt;= return) ;
  let </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">register_field</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> s f =
    register1 s (fun ctxt contract () () -&gt;
        Contract.exists ctxt contract
        &gt;&gt;=? function true -&gt; f ctxt contract | false -&gt; raise </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">Not_found</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)
  in
  let </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">register_opt_field</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> s f =
    register_field s (fun ctxt a1 -&gt;
        f ctxt a1 &gt;&gt;=? function None -&gt; raise </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">Not_found</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> | Some v -&gt; return v)
  in
  let do_big_map_get ctxt id key =
    let open Script_ir_translator in
    let ctxt = Gas.set_unlimited ctxt in
    Big_map.exists ctxt id
    &gt;&gt;=? fun (ctxt, types) -&gt;
    match types with
    | None -&gt;
        raise </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">Not_found</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
    | Some (_, value_type) -&gt; (
        Lwt.return
          (parse_ty
             ctxt
             ~legacy:true
             ~allow_big_map:false
             ~allow_operation:false
             ~allow_contract:true
             (Micheline.root value_type))
        &gt;&gt;=? fun (Ex_ty value_type, ctxt) -&gt;
        Big_map.get_opt ctxt id key
        &gt;&gt;=? fun (_ctxt, value) -&gt;
        match value with
        | None -&gt;
            raise </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">Not_found</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
        | Some value -&gt;
            parse_data ctxt ~legacy:true value_type (Micheline.root value)
            &gt;&gt;=? fun (value, ctxt) -&gt;
            unparse_data ctxt Readable value_type value
            &gt;&gt;=? fun (value, _ctxt) -&gt; return (Micheline.strip_locations value)
        )
  in
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_field S.balance Contract.get_balance ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.manager_key (fun ctxt contract () () -&gt;
      match Contract.is_implicit contract with
      | None -&gt;
          raise Not_found
      | Some mgr -&gt; (
          Contract.is_manager_key_revealed ctxt mgr
          &gt;&gt;=? function
          | false -&gt;
              return_none
          | true -&gt;
              Contract.get_manager_key ctxt mgr &gt;&gt;=? return_some )) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_opt_field S.delegate Delegate.get ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.counter (fun ctxt contract () () -&gt;
      match Contract.is_implicit contract with
      | None -&gt;
          raise Not_found
      | Some mgr -&gt;
          Contract.get_counter ctxt mgr) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_opt_field S.script (fun c v -&gt;
      Contract.get_script c v &gt;&gt;=? fun (_, v) -&gt; return v) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_opt_field S.storage (fun ctxt contract -&gt;
      Contract.get_script ctxt contract
      &gt;&gt;=? fun (ctxt, script) -&gt;
      match script with
      | None -&gt;
          return_none
      | Some script -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let open Script_ir_translator in
          parse_script ctxt ~legacy:true script
          &gt;&gt;=? fun (Ex_script script, ctxt) -&gt;
          unparse_script ctxt Readable script
          &gt;&gt;=? fun (script, ctxt) -&gt;
          Script.force_decode ctxt script.storage
          &gt;&gt;=? fun (storage, _ctxt) -&gt; return_some storage) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register2 S.entrypoint_type (fun ctxt v entrypoint () () -&gt;
      Contract.get_script_code ctxt v
      &gt;&gt;=? fun (_, expr) -&gt;
      match expr with
      | None -&gt;
          raise Not_found
      | Some expr -&gt; (
          let ctxt = Gas.set_unlimited ctxt in
          let legacy = true in
          let open Script_ir_translator in
          Script.force_decode ctxt expr
          &gt;&gt;=? fun (expr, _) -&gt;
          Lwt.return
            ( parse_toplevel ~legacy expr
            &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
            parse_ty
              ctxt
              ~legacy
              ~allow_big_map:true
              ~allow_operation:false
              ~allow_contract:true
              arg_type
            &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
            Script_ir_translator.find_entrypoint ~root_name arg_type entrypoint
            )
          &gt;&gt;= function
          | Ok (_f, Ex_ty ty) -&gt;
              unparse_ty ctxt ty
              &gt;&gt;=? fun (ty_node, _) -&gt;
              return (Micheline.strip_locations ty_node)
          | Error _ -&gt;
              raise Not_found )) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.list_entrypoints (fun ctxt v () () -&gt;
      Contract.get_script_code ctxt v
      &gt;&gt;=? fun (_, expr) -&gt;
      match expr with
      | None -&gt;
          raise Not_found
      | Some expr -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let legacy = true in
          let open Script_ir_translator in
          Script.force_decode ctxt expr
          &gt;&gt;=? fun (expr, _) -&gt;
          Lwt.return
            ( parse_toplevel ~legacy expr
            &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
            parse_ty
              ctxt
              ~legacy
              ~allow_big_map:true
              ~allow_operation:false
              ~allow_contract:true
              arg_type
            &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
            Script_ir_translator.list_entrypoints ~root_name arg_type ctxt )
          &gt;&gt;=? fun (unreachable_entrypoint, map) -&gt;
          return
            ( unreachable_entrypoint,
              Entrypoints_map.fold
                (fun entry (_, ty) acc -&gt;
                  (entry, Micheline.strip_locations ty) :: acc)
                map
                [] )) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.contract_big_map_get_opt (fun ctxt contract () (key, key_type) -&gt;
      Contract.get_script ctxt contract
      &gt;&gt;=? fun (ctxt, script) -&gt;
      Lwt.return
        (Script_ir_translator.parse_packable_ty
           ctxt
           ~legacy:true
           (Micheline.root key_type))
      &gt;&gt;=? fun (Ex_ty key_type, ctxt) -&gt;
      Script_ir_translator.parse_data
        ctxt
        ~legacy:true
        key_type
        (Micheline.root key)
      &gt;&gt;=? fun (key, ctxt) -&gt;
      Script_ir_translator.hash_data ctxt key_type key
      &gt;&gt;=? fun (key, ctxt) -&gt;
      match script with
      | None -&gt;
          raise Not_found
      | Some script -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let open Script_ir_translator in
          parse_script ctxt ~legacy:true script
          &gt;&gt;=? fun (Ex_script script, ctxt) -&gt;
          Script_ir_translator.collect_big_maps
            ctxt
            script.storage_type
            script.storage
          &gt;&gt;=? fun (ids, _ctxt) -&gt;
          let ids = Script_ir_translator.list_of_big_map_ids ids in
          let rec find = function
            | [] -&gt;
                return_none
            | (id : Z.t) :: ids -&gt; (
              try do_big_map_get ctxt id key &gt;&gt;=? return_some
              with Not_found -&gt; find ids )
          in
          find ids) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register2 S.big_map_get (fun ctxt id key () () -&gt; do_big_map_get ctxt id key) ;
  register_field S.info (fun ctxt contract -&gt;
      Contract.get_balance ctxt contract
      &gt;&gt;=? fun balance -&gt;
      Delegate.get ctxt contract
      &gt;&gt;=? fun delegate -&gt;
      ( match Contract.is_implicit contract with
      | Some manager -&gt;
          Contract.get_counter ctxt manager
          &gt;&gt;=? fun counter -&gt; return_some counter
      | None -&gt;
          return None )
      &gt;&gt;=? fun counter -&gt;
      Contract.get_script ctxt contract
      &gt;&gt;=? fun (ctxt, script) -&gt;
      ( match script with
      | None -&gt;
          return (None, ctxt)
      | Some script -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let open Script_ir_translator in
          parse_script ctxt ~legacy:true script
          &gt;&gt;=? fun (Ex_script script, ctxt) -&gt;
          unparse_script ctxt Readable script
          &gt;&gt;=? fun (script, ctxt) -&gt; return (Some script, ctxt) )
      &gt;&gt;=? fun (script, _ctxt) -&gt; return {balance; delegate; script; counter})</abbr>

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">list</abbr> ctxt block = RPC_context.make_call0 S.list ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">info</abbr> ctxt block contract =
  RPC_context.make_call1 S.info ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">balance</abbr> ctxt block contract =
  RPC_context.make_call1 S.balance ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">manager_key</abbr> ctxt block mgr =
  RPC_context.make_call1
    S.manager_key
    ctxt
    block
    (Contract.implicit_contract mgr)
    ()
    ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">delegate</abbr> ctxt block contract =
  RPC_context.make_call1 S.delegate ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">delegate_opt</abbr> ctxt block contract =
  RPC_context.make_opt_call1 S.delegate ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">counter</abbr> ctxt block mgr =
  RPC_context.make_call1
    S.counter
    ctxt
    block
    (Contract.implicit_contract mgr)
    ()
    ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">script</abbr> ctxt block contract =
  RPC_context.make_call1 S.script ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">script_opt</abbr> ctxt block contract =
  RPC_context.make_opt_call1 S.script ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">storage</abbr> ctxt block contract =
  RPC_context.make_call1 S.storage ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">entrypoint_type</abbr> ctxt block contract entrypoint =
  RPC_context.make_call2 S.entrypoint_type ctxt block contract entrypoint () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">list_entrypoints</abbr> ctxt block contract =
  RPC_context.make_call1 S.list_entrypoints ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">storage_opt</abbr> ctxt block contract =
  RPC_context.make_opt_call1 S.storage ctxt block contract () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">big_map_get</abbr> ctxt block id key =
  RPC_context.make_call2 S.big_map_get ctxt block id key () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">contract_big_map_get_opt</abbr> ctxt block contract key =
  RPC_context.make_call1 S.contract_big_map_get_opt ctxt block contract () key
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_services.ml"><code>Contract_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_expr_hash.
Require Tezos.Script_ir_translator.
Require Tezos.Services_registration.

Import Alpha_context.

Definition custom_root : RPC_path.context RPC_context.t :=
  RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot; % string)
    &quot;contracts&quot; % string.

Definition big_map_root : RPC_path.context RPC_context.t :=
  RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot; % string)
    &quot;big_maps&quot; % string.

Module info.
  Record record := {
    balance : Alpha_context.Tez.t;
    delegate : option Alpha_context.public_key_hash;
    counter : option Alpha_context.counter;
    script : option Alpha_context.Script.t }.
End info.
Definition info := info.record.

Definition info_encoding : Data_encoding.encoding info :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.conv
        (fun function_parameter =&gt;
          let '{|
            info.balance := balance;
              info.delegate := delegate;
              info.counter := counter;
              info.script := script
              |} := function_parameter in
          (balance, delegate, script, counter))
        (fun function_parameter =&gt;
          let '(balance, delegate, script, counter) := function_parameter in
          {| info.balance := balance; info.delegate := delegate;
            info.counter := counter; info.script := script |}) in
    fun eta =&gt; arg None eta)
    (Data_encoding.obj4
      (Data_encoding.req None None &quot;balance&quot; % string Alpha_context.Tez.encoding)
      (Data_encoding.opt None None &quot;delegate&quot; % string
        Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
      (Data_encoding.opt None None &quot;script&quot; % string
        Alpha_context.Script.encoding)
      (Data_encoding.opt None None &quot;counter&quot; % string Data_encoding.n)).

Module S.
  Import Data_encoding.
  
  Definition balance
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service (Some &quot;Access the balance of a contract.&quot; % string)
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;balance&quot; % string).
  
  Definition manager_key
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      (option Signature.Public_key.[S.SPublic_key.t]) :=
    RPC_service.get_service (Some &quot;Access the manager of a contract.&quot; % string)
      RPC_query.empty
      (Data_encoding.__option_value
        Signature.Public_key.[S.SPublic_key.encoding])
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;manager_key&quot; % string).
  
  Definition delegate
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      Signature.Public_key_hash.[S.SPublic_key_hash.t] :=
    RPC_service.get_service
      (Some &quot;Access the delegate of a contract, if any.&quot; % string)
      RPC_query.empty Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;delegate&quot; % string).
  
  Definition counter
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit Z.t :=
    RPC_service.get_service
      (Some &quot;Access the counter of a contract, if any.&quot; % string)
      RPC_query.empty Data_encoding.z
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;counter&quot; % string).
  
  Definition script
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      Alpha_context.Script.t :=
    RPC_service.get_service
      (Some &quot;Access the code and data of the contract.&quot; % string)
      RPC_query.empty Alpha_context.Script.encoding
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;script&quot; % string).
  
  Definition storage
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      Alpha_context.Script.expr :=
    RPC_service.get_service (Some &quot;Access the data of the contract.&quot; % string)
      RPC_query.empty Alpha_context.Script.expr_encoding
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;storage&quot; % string).
  
  Definition entrypoint_type
    : RPC_service.service (* `GET *) unit RPC_context.t
      ((RPC_context.t * Alpha_context.Contract.contract) * string) unit unit
      Alpha_context.Script.expr :=
    RPC_service.get_service
      (Some &quot;Return the type of the given entrypoint of the contract&quot; % string)
      RPC_query.empty Alpha_context.Script.expr_encoding
      (RPC_path.op_divcolon
        (RPC_path.op_div
          (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
          &quot;entrypoints&quot; % string) RPC_arg.__string_value).
  
  Definition list_entrypoints
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      (list (list Michelson_v1_primitives.prim) *
        list (string * Alpha_context.Script.expr)) :=
    RPC_service.get_service
      (Some &quot;Return the list of entrypoints of the contract&quot; % string)
      RPC_query.empty
      (Data_encoding.obj2
        (Data_encoding.dft None None &quot;unreachable&quot; % string
          (Data_encoding.__list_value None
            (Data_encoding.obj1
              (Data_encoding.req None None &quot;path&quot; % string
                (Data_encoding.__list_value None
                  Michelson_v1_primitives.prim_encoding)))) [])
        (Data_encoding.req None None &quot;entrypoints&quot; % string
          (Data_encoding.assoc Alpha_context.Script.expr_encoding)))
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;entrypoints&quot; % string).
  
  Definition contract_big_map_get_opt
    : RPC_service.service (* `POST *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit
      (Alpha_context.Script.expr * Alpha_context.Script.expr)
      (option Alpha_context.Script.expr) :=
    RPC_service.post_service
      (Some
        &quot;Access the value associated with a key in a big map of the contract (deprecated).&quot;
          % string) RPC_query.empty
      (Data_encoding.obj2
        (Data_encoding.req None None &quot;key&quot; % string
          Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;type&quot; % string
          Alpha_context.Script.expr_encoding))
      (Data_encoding.__option_value Alpha_context.Script.expr_encoding)
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;big_map_get&quot; % string).
  
  Definition big_map_get
    : RPC_service.service (* `GET *) unit RPC_context.t
      ((RPC_context.t * Alpha_context.Big_map.id) * Script_expr_hash.t) unit
      unit Alpha_context.Script.expr :=
    RPC_service.get_service
      (Some &quot;Access the value associated with a key in a big map.&quot; % string)
      RPC_query.empty Alpha_context.Script.expr_encoding
      (RPC_path.op_divcolon
        (RPC_path.op_divcolon big_map_root Alpha_context.Big_map.rpc_arg)
        Script_expr_hash.rpc_arg).
  
  Definition info
    : RPC_service.service (* `GET *) unit RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit info :=
    RPC_service.get_service
      (Some &quot;Access the complete status of a contract.&quot; % string)
      RPC_query.empty info_encoding
      (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg).
  
  Definition __list_value
    : RPC_service.service (* `GET *) unit RPC_context.t RPC_context.t unit unit
      (list Alpha_context.Contract.t) :=
    RPC_service.get_service
      (Some
        &quot;All existing contracts (including non-empty default contracts).&quot; %
          string) RPC_query.empty
      (Data_encoding.__list_value None Alpha_context.Contract.encoding)
      custom_root.
End S.

Definition register (function_parameter : unit) : unit :=
  let 'tt := function_parameter in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  let register_field {A : Set}
    (s :
      RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
        (Updater.rpc_context * Alpha_context.Contract.contract) unit unit A)
    (f :
      Alpha_context.t -&gt; Alpha_context.Contract.contract -&gt;
      Lwt.t (Error_monad.tzresult A)) : unit :=
    Services_registration.register1 s
      (fun ctxt =&gt;
        fun contract =&gt;
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion
                (Alpha_context.Contract.__exists ctxt contract)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | true =&gt; f ctxt contract
                  | false =&gt; Pervasives.raise extensible_type_value
                  end)) in
  let register_opt_field {A : Set}
    (s :
      RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
        (Updater.rpc_context * Alpha_context.Contract.contract) unit unit A)
    (f :
      Alpha_context.t -&gt; Alpha_context.Contract.contract -&gt;
      Lwt.t (Error_monad.tzresult (option A))) : unit :=
    register_field s
      (fun ctxt =&gt;
        fun a1 =&gt;
          Error_monad.op_gtgteqquestion (f ctxt a1)
            (fun function_parameter =&gt;
              match function_parameter with
              | None =&gt; Pervasives.raise extensible_type_value
              | Some v =&gt; Error_monad.__return v
              end)) in
  let do_big_map_get
    (ctxt : Alpha_context.context) (id : Alpha_context.Big_map.id)
    (key : Script_expr_hash.t)
    : Lwt.t
      (Error_monad.tzresult (Micheline.canonical Alpha_context.Script.prim)) :=
    let ctxt := Alpha_context.Gas.set_unlimited ctxt in
    Error_monad.op_gtgteqquestion (Alpha_context.Big_map.__exists ctxt id)
      (fun function_parameter =&gt;
        let '(ctxt, types) := function_parameter in
        match types with
        | None =&gt; Pervasives.raise extensible_type_value
        | Some (_, value_type) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Script_ir_translator.parse_ty ctxt true false false true
                (Micheline.root value_type)))
            (fun function_parameter =&gt;
              let '(Script_ir_translator.Ex_ty value_type, ctxt) :=
                function_parameter in
              Error_monad.op_gtgteqquestion
                (Alpha_context.Big_map.get_opt ctxt id key)
                (fun function_parameter =&gt;
                  let '(_ctxt, value) := function_parameter in
                  match value with
                  | None =&gt; Pervasives.raise extensible_type_value
                  | Some value =&gt;
                    Error_monad.op_gtgteqquestion
                      (Script_ir_translator.parse_data None ctxt true value_type
                        (Micheline.root value))
                      (fun function_parameter =&gt;
                        let '(value, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (Script_ir_translator.unparse_data ctxt
                            Script_ir_translator.Readable value_type value)
                          (fun function_parameter =&gt;
                            let '(value, _ctxt) := function_parameter in
                            Error_monad.__return
                              (Micheline.strip_locations value)))
                  end))
        end) in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  register_field S.info
    (fun ctxt =&gt;
      fun contract =&gt;
        Error_monad.op_gtgteqquestion
          (Alpha_context.Contract.get_balance ctxt contract)
          (fun balance =&gt;
            Error_monad.op_gtgteqquestion
              (Alpha_context.Delegate.get ctxt contract)
              (fun delegate =&gt;
                Error_monad.op_gtgteqquestion
                  match Alpha_context.Contract.is_implicit contract with
                  | Some manager =&gt;
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Contract.get_counter ctxt manager)
                      (fun counter =&gt; Error_monad.return_some counter)
                  | None =&gt; Error_monad.__return None
                  end
                  (fun counter =&gt;
                    Error_monad.op_gtgteqquestion
                      (Alpha_context.Contract.get_script ctxt contract)
                      (fun function_parameter =&gt;
                        let '(ctxt, script) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          match script with
                          | None =&gt; Error_monad.__return (None, ctxt)
                          | Some script =&gt;
                            let ctxt := Alpha_context.Gas.set_unlimited ctxt in
                            Error_monad.op_gtgteqquestion
                              (Script_ir_translator.parse_script None ctxt true
                                script)
                              (fun function_parameter =&gt;
                                let
                                  '(Script_ir_translator.Ex_script script, ctxt) :=
                                  function_parameter in
                                Error_monad.op_gtgteqquestion
                                  (Script_ir_translator.unparse_script ctxt
                                    Script_ir_translator.Readable script)
                                  (fun function_parameter =&gt;
                                    let '(script, ctxt) := function_parameter in
                                    Error_monad.__return ((Some script), ctxt)))
                          end
                          (fun function_parameter =&gt;
                            let '(script, _ctxt) := function_parameter in
                            Error_monad.__return
                              {| info.balance := balance;
                                info.delegate := delegate;
                                info.counter := counter; info.script := script
                                |})))))).

Definition __list_value {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Contract.t)) :=
  RPC_context.make_call0 S.__list_value ctxt block tt tt.

Definition info {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult info) :=
  RPC_context.make_call1 S.info ctxt block contract tt tt.

Definition balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.balance ctxt block contract tt tt.

Definition manager_key {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (mgr : Alpha_context.public_key_hash)
  : Lwt.t
    (Error_monad.shell_tzresult (option Signature.Public_key.[S.SPublic_key.t])) :=
  RPC_context.make_call1 S.manager_key ctxt block
    (Alpha_context.Contract.implicit_contract mgr) tt tt.

Definition delegate {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t
    (Error_monad.shell_tzresult Signature.Public_key_hash.[S.SPublic_key_hash.t]) :=
  RPC_context.make_call1 S.delegate ctxt block contract tt tt.

Definition delegate_opt {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t
    (Error_monad.shell_tzresult
      (option Signature.Public_key_hash.[S.SPublic_key_hash.t])) :=
  RPC_context.make_opt_call1 S.delegate ctxt block contract tt tt.

Definition counter {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (mgr : Alpha_context.public_key_hash)
  : Lwt.t (Error_monad.shell_tzresult Z.t) :=
  RPC_context.make_call1 S.counter ctxt block
    (Alpha_context.Contract.implicit_contract mgr) tt tt.

Definition script {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.t) :=
  RPC_context.make_call1 S.script ctxt block contract tt tt.

Definition script_opt {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.t)) :=
  RPC_context.make_opt_call1 S.script ctxt block contract tt tt.

Definition storage {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
  RPC_context.make_call1 S.storage ctxt block contract tt tt.

Definition entrypoint_type {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract) (entrypoint : string)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
  RPC_context.make_call2 S.entrypoint_type ctxt block contract entrypoint tt tt.

Definition list_entrypoints {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t
    (Error_monad.shell_tzresult
      (list (list Michelson_v1_primitives.prim) *
        list (string * Alpha_context.Script.expr))) :=
  RPC_context.make_call1 S.list_entrypoints ctxt block contract tt tt.

Definition storage_opt {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)) :=
  RPC_context.make_opt_call1 S.storage ctxt block contract tt tt.

Definition big_map_get {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (id : Alpha_context.Big_map.id) (key : Script_expr_hash.t)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
  RPC_context.make_call2 S.big_map_get ctxt block id key tt tt.

Definition contract_big_map_get_opt {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (contract : Alpha_context.Contract.contract)
  (key : Alpha_context.Script.expr * Alpha_context.Script.expr)
  : Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)) :=
  RPC_context.make_call1 S.contract_big_map_get_opt ctxt block contract tt key.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_services.mli">
  <div class="col-md-6">
    <a href="#contract_services.mli"><code>contract_services.mli</code></a>&nbsp;<span class="label label-danger">195 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val list : 'a #RPC_context.simple -&gt; 'a -&gt; Contract.t list shell_tzresult Lwt.t</abbr>

type info = {
  balance : Tez.t;
  delegate : public_key_hash option;
  counter : counter option;
  script : Script.t option;
}

val info_encoding : info Data_encoding.t

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val info :
  'a #RPC_context.simple -&gt; 'a -&gt; Contract.t -&gt; info shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val balance :
  'a #RPC_context.simple -&gt; 'a -&gt; Contract.t -&gt; Tez.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val manager_key :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  public_key_hash -&gt;
  public_key option shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val delegate :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  public_key_hash shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val delegate_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  public_key_hash option shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val counter :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  public_key_hash -&gt;
  counter shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val script :
  'a #RPC_context.simple -&gt; 'a -&gt; Contract.t -&gt; Script.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val script_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.t option shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val storage :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.expr shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val entrypoint_type :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  string -&gt;
  Script.expr shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val list_entrypoints :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  (Michelson_v1_primitives.prim list list * (string * Script.expr) list)
  shell_tzresult
  Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val storage_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.expr option shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val big_map_get :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Z.t -&gt;
  Script_expr_hash.t -&gt;
  Script.expr shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val contract_big_map_get_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.expr * Script.expr -&gt;
  Script.expr option shell_tzresult Lwt.t</abbr>

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_services.mli"><code>Contract_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_expr_hash.

Parameter __list_value : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Contract.t)).

Module info.
  Record record := {
    balance : Alpha_context.Tez.t;
    delegate : option Alpha_context.public_key_hash;
    counter : option Alpha_context.counter;
    script : option Alpha_context.Script.t }.
End info.
Definition info := info.record.

Parameter info_encoding : Data_encoding.t info.

Parameter info : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult info).

Parameter balance : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter manager_key : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.public_key_hash -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.public_key)).

Parameter delegate : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.public_key_hash).

Parameter delegate_opt : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.public_key_hash)).

Parameter counter : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.public_key_hash -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.counter).

Parameter script : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.t).

Parameter script_opt : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.t)).

Parameter storage : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).

Parameter entrypoint_type : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt; string -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).

Parameter list_entrypoints : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list (list Michelson_v1_primitives.prim) *
        list (string * Alpha_context.Script.expr))).

Parameter storage_opt : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)).

Parameter big_map_get : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Z.t -&gt; Script_expr_hash.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).

Parameter contract_big_map_get_opt : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Alpha_context.Script.expr * Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_storage.ml">
  <div class="col-md-6">
    <a href="#contract_storage.ml"><code>contract_storage.ml</code></a>&nbsp;<span class="label label-danger">16 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Balance_too_low of Contract_repr.contract * Tez_repr.t * Tez_repr.t
  | (* `Temporary *)
      Counter_in_the_past of Contract_repr.contract * Z.t * Z.t
  | (* `Branch *)
      Counter_in_the_future of Contract_repr.contract * Z.t * Z.t
  | (* `Temporary *)
      Unspendable_contract of Contract_repr.contract
  | (* `Permanent *)
      Non_existing_contract of Contract_repr.contract
  | (* `Temporary *)
      Empty_implicit_contract of Signature.Public_key_hash.t
  | (* `Temporary *)
      Empty_transaction of Contract_repr.t (* `Temporary *)
  | Inconsistent_hash of
      Signature.Public_key.t
      * Signature.Public_key_hash.t
      * Signature.Public_key_hash.t
  | (* `Permanent *)
      Inconsistent_public_key of
      Signature.Public_key.t * Signature.Public_key.t
  | (* `Permanent *)
      Failure of string (* `Permanent *)
  | Previously_revealed_key of Contract_repr.t (* `Permanent *)
  | Unrevealed_manager_key of Contract_repr.t</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;contract.unspendable_contract&quot;
    ~title:&quot;Unspendable contract&quot;
    ~description:
      &quot;An operation tried to spend tokens from an unspendable contract&quot;
    ~pp:(fun ppf c -&gt;
      Format.fprintf
        ppf
        &quot;The tokens of contract %a can only be spent by its script&quot;
        Contract_repr.pp
        c)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Unspendable_contract c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Unspendable_contract c) ;
  register_error_kind
    `Temporary
    ~id:&quot;contract.balance_too_low&quot;
    ~title:&quot;Balance too low&quot;
    ~description:
      &quot;An operation tried to spend more tokens than the contract has&quot;
    ~pp:(fun ppf (c, b, a) -&gt;
      Format.fprintf
        ppf
        &quot;Balance of contract %a too low (%a) to spend %a&quot;
        Contract_repr.pp
        c
        Tez_repr.pp
        b
        Tez_repr.pp
        a)
    Data_encoding.(
      obj3
        (req &quot;contract&quot; Contract_repr.encoding)
        (req &quot;balance&quot; Tez_repr.encoding)
        (req &quot;amount&quot; Tez_repr.encoding))
    (function Balance_too_low (c, b, a) -&gt; Some (c, b, a) | _ -&gt; None)
    (fun (c, b, a) -&gt; Balance_too_low (c, b, a)) ;
  register_error_kind
    `Temporary
    ~id:&quot;contract.counter_in_the_future&quot;
    ~title:&quot;Invalid counter (not yet reached) in a manager operation&quot;
    ~description:&quot;An operation assumed a contract counter in the future&quot;
    ~pp:(fun ppf (contract, exp, found) -&gt;
      Format.fprintf
        ppf
        &quot;Counter %s not yet reached for contract %a (expected %s)&quot;
        (Z.to_string found)
        Contract_repr.pp
        contract
        (Z.to_string exp))
    Data_encoding.(
      obj3
        (req &quot;contract&quot; Contract_repr.encoding)
        (req &quot;expected&quot; z)
        (req &quot;found&quot; z))
    (function Counter_in_the_future (c, x, y) -&gt; Some (c, x, y) | _ -&gt; None)
    (fun (c, x, y) -&gt; Counter_in_the_future (c, x, y)) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.counter_in_the_past&quot;
    ~title:&quot;Invalid counter (already used) in a manager operation&quot;
    ~description:&quot;An operation assumed a contract counter in the past&quot;
    ~pp:(fun ppf (contract, exp, found) -&gt;
      Format.fprintf
        ppf
        &quot;Counter %s already used for contract %a (expected %s)&quot;
        (Z.to_string found)
        Contract_repr.pp
        contract
        (Z.to_string exp))
    Data_encoding.(
      obj3
        (req &quot;contract&quot; Contract_repr.encoding)
        (req &quot;expected&quot; z)
        (req &quot;found&quot; z))
    (function Counter_in_the_past (c, x, y) -&gt; Some (c, x, y) | _ -&gt; None)
    (fun (c, x, y) -&gt; Counter_in_the_past (c, x, y)) ;
  register_error_kind
    `Temporary
    ~id:&quot;contract.non_existing_contract&quot;
    ~title:&quot;Non existing contract&quot;
    ~description:
      &quot;A contract handle is not present in the context (either it never was \
       or it has been destroyed)&quot;
    ~pp:(fun ppf contract -&gt;
      Format.fprintf ppf &quot;Contract %a does not exist&quot; Contract_repr.pp contract)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Non_existing_contract c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Non_existing_contract c) ;
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.inconsistent_hash&quot;
    ~title:&quot;Inconsistent public key hash&quot;
    ~description:
      &quot;A revealed manager public key is inconsistent with the announced hash&quot;
    ~pp:(fun ppf (k, eh, ph) -&gt;
      Format.fprintf
        ppf
        &quot;The hash of the manager public key %s is not %a as announced but %a&quot;
        (Signature.Public_key.to_b58check k)
        Signature.Public_key_hash.pp
        ph
        Signature.Public_key_hash.pp
        eh)
    Data_encoding.(
      obj3
        (req &quot;public_key&quot; Signature.Public_key.encoding)
        (req &quot;expected_hash&quot; Signature.Public_key_hash.encoding)
        (req &quot;provided_hash&quot; Signature.Public_key_hash.encoding))
    (function Inconsistent_hash (k, eh, ph) -&gt; Some (k, eh, ph) | _ -&gt; None)
    (fun (k, eh, ph) -&gt; Inconsistent_hash (k, eh, ph)) ;
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.inconsistent_public_key&quot;
    ~title:&quot;Inconsistent public key&quot;
    ~description:
      &quot;A provided manager public key is different with the public key stored \
       in the contract&quot;
    ~pp:(fun ppf (eh, ph) -&gt;
      Format.fprintf
        ppf
        &quot;Expected manager public key %s but %s was provided&quot;
        (Signature.Public_key.to_b58check ph)
        (Signature.Public_key.to_b58check eh))
    Data_encoding.(
      obj2
        (req &quot;public_key&quot; Signature.Public_key.encoding)
        (req &quot;expected_public_key&quot; Signature.Public_key.encoding))
    (function Inconsistent_public_key (eh, ph) -&gt; Some (eh, ph) | _ -&gt; None)
    (fun (eh, ph) -&gt; Inconsistent_public_key (eh, ph)) ;
  register_error_kind
    `Permanent
    ~id:&quot;contract.failure&quot;
    ~title:&quot;Contract storage failure&quot;
    ~description:&quot;Unexpected contract storage error&quot;
    ~pp:(fun ppf s -&gt; Format.fprintf ppf &quot;Contract_storage.Failure %S&quot; s)
    Data_encoding.(obj1 (req &quot;message&quot; string))
    (function Failure s -&gt; Some s | _ -&gt; None)
    (fun s -&gt; Failure s) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.unrevealed_key&quot;
    ~title:&quot;Manager operation precedes key revelation&quot;
    ~description:
      &quot;One tried to apply a manager operation without revealing the manager \
       public key&quot;
    ~pp:(fun ppf s -&gt;
      Format.fprintf
        ppf
        &quot;Unrevealed manager key for contract %a.&quot;
        Contract_repr.pp
        s)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Unrevealed_manager_key s -&gt; Some s | _ -&gt; None)
    (fun s -&gt; Unrevealed_manager_key s) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.previously_revealed_key&quot;
    ~title:&quot;Manager operation already revealed&quot;
    ~description:&quot;One tried to revealed twice a manager public key&quot;
    ~pp:(fun ppf s -&gt;
      Format.fprintf
        ppf
        &quot;Previously revealed manager key for contract %a.&quot;
        Contract_repr.pp
        s)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Previously_revealed_key s -&gt; Some s | _ -&gt; None)
    (fun s -&gt; Previously_revealed_key s) ;
  register_error_kind
    `Branch
    ~id:&quot;implicit.empty_implicit_contract&quot;
    ~title:&quot;Empty implicit contract&quot;
    ~description:
      &quot;No manager operations are allowed on an empty implicit contract.&quot;
    ~pp:(fun ppf implicit -&gt;
      Format.fprintf
        ppf
        &quot;Empty implicit contract (%a)&quot;
        Signature.Public_key_hash.pp
        implicit)
    Data_encoding.(obj1 (req &quot;implicit&quot; Signature.Public_key_hash.encoding))
    (function Empty_implicit_contract c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Empty_implicit_contract c) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.empty_transaction&quot;
    ~title:&quot;Empty transaction&quot;
    ~description:&quot;Forbidden to credit 0√™¬ú¬© to a contract without code.&quot;
    ~pp:(fun ppf contract -&gt;
      Format.fprintf
        ppf
        &quot;Transaction of 0√™¬ú¬© towards a contract without code are forbidden \
         (%a).&quot;
        Contract_repr.pp
        contract)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Empty_transaction c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Empty_transaction c)</abbr>

let failwith msg = fail <abbr class="mark-error" title="Values of extensible types are not handled">(Failure msg)</abbr>

type big_map_diff_item =
  | Update of {
      big_map : Z.t;
      diff_key : Script_repr.expr;
      diff_key_hash : Script_expr_hash.t;
      diff_value : Script_repr.expr option;
    }
  | Clear of Z.t
  | Copy of Z.t * Z.t
  | Alloc of {
      big_map : Z.t;
      key_type : Script_repr.expr;
      value_type : Script_repr.expr;
    }

type big_map_diff = big_map_diff_item list

let big_map_diff_item_encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;update&quot;
        (obj5
           (req &quot;action&quot; (constant &quot;update&quot;))
           (req &quot;big_map&quot; z)
           (req &quot;key_hash&quot; Script_expr_hash.encoding)
           (req &quot;key&quot; Script_repr.expr_encoding)
           (opt &quot;value&quot; Script_repr.expr_encoding))
        (function
          | Update {big_map; diff_key_hash; diff_key; diff_value} -&gt;
              Some ((), big_map, diff_key_hash, diff_key, diff_value)
          | _ -&gt;
              None)
        (fun ((), big_map, diff_key_hash, diff_key, diff_value) -&gt;
          Update {big_map; diff_key_hash; diff_key; diff_value});
      case
        (Tag 1)
        ~title:&quot;remove&quot;
        (obj2 (req &quot;action&quot; (constant &quot;remove&quot;)) (req &quot;big_map&quot; z))
        (function Clear big_map -&gt; Some ((), big_map) | _ -&gt; None)
        (fun ((), big_map) -&gt; Clear big_map);
      case
        (Tag 2)
        ~title:&quot;copy&quot;
        (obj3
           (req &quot;action&quot; (constant &quot;copy&quot;))
           (req &quot;source_big_map&quot; z)
           (req &quot;destination_big_map&quot; z))
        (function Copy (src, dst) -&gt; Some ((), src, dst) | _ -&gt; None)
        (fun ((), src, dst) -&gt; Copy (src, dst));
      case
        (Tag 3)
        ~title:&quot;alloc&quot;
        (obj4
           (req &quot;action&quot; (constant &quot;alloc&quot;))
           (req &quot;big_map&quot; z)
           (req &quot;key_type&quot; Script_repr.expr_encoding)
           (req &quot;value_type&quot; Script_repr.expr_encoding))
        (function
          | Alloc {big_map; key_type; value_type} -&gt;
              Some ((), big_map, key_type, value_type)
          | _ -&gt;
              None)
        (fun ((), big_map, key_type, value_type) -&gt;
          Alloc {big_map; key_type; value_type}) ]

let big_map_diff_encoding =
  let open Data_encoding in
  def &quot;contract.big_map_diff&quot; @@ list big_map_diff_item_encoding

let big_map_key_cost = 65

let big_map_cost = 33

let update_script_big_map c = function
  | None -&gt;
      return (c, Z.zero)
  | Some diff -&gt;
      fold_left_s
        (fun (c, total) -&gt; function Clear id -&gt;
              Storage.Big_map.Total_bytes.get c id
              &gt;&gt;=? fun size -&gt;
              Storage.Big_map.remove_rec c id
              &gt;&gt;= fun c -&gt;
              if Compare.Z.(id &lt; Z.zero) then return (c, total)
              else return (c, Z.sub (Z.sub total size) (Z.of_int big_map_cost))
          | Copy (from, to_) -&gt;
              Storage.Big_map.copy c ~from ~to_
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(to_ &lt; Z.zero) then return (c, total)
              else
                Storage.Big_map.Total_bytes.get c from
                &gt;&gt;=? fun size -&gt;
                return (c, Z.add (Z.add total size) (Z.of_int big_map_cost))
          | Alloc {big_map; key_type; value_type} -&gt;
              Storage.Big_map.Total_bytes.init c big_map Z.zero
              &gt;&gt;=? fun c -&gt;
              (* Annotations are erased to allow sharing on
                 [Copy]. The types from the contract code are used,
                 these ones are only used to make sure they are
                 compatible during transmissions between contracts,
                 and only need to be compatible, annotations
                 nonwhistanding. *)
              let key_type =
                Micheline.strip_locations
                  (Script_repr.strip_annotations (Micheline.root key_type))
              in
              let value_type =
                Micheline.strip_locations
                  (Script_repr.strip_annotations (Micheline.root value_type))
              in
              Storage.Big_map.Key_type.init c big_map key_type
              &gt;&gt;=? fun c -&gt;
              Storage.Big_map.Value_type.init c big_map value_type
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(big_map &lt; Z.zero) then return (c, total)
              else return (c, Z.add total (Z.of_int big_map_cost))
          | Update {big_map; diff_key_hash; diff_value = None} -&gt;
              Storage.Big_map.Contents.remove (c, big_map) diff_key_hash
              &gt;&gt;=? fun (c, freed, existed) -&gt;
              let freed =
                if existed then freed + big_map_key_cost else freed
              in
              Storage.Big_map.Total_bytes.get c big_map
              &gt;&gt;=? fun size -&gt;
              Storage.Big_map.Total_bytes.set
                c
                big_map
                (Z.sub size (Z.of_int freed))
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(big_map &lt; Z.zero) then return (c, total)
              else return (c, Z.sub total (Z.of_int freed))
          | Update {big_map; diff_key_hash; diff_value = Some v} -&gt;
              Storage.Big_map.Contents.init_set (c, big_map) diff_key_hash v
              &gt;&gt;=? fun (c, size_diff, existed) -&gt;
              let size_diff =
                if existed then size_diff else size_diff + big_map_key_cost
              in
              Storage.Big_map.Total_bytes.get c big_map
              &gt;&gt;=? fun size -&gt;
              Storage.Big_map.Total_bytes.set
                c
                big_map
                (Z.add size (Z.of_int size_diff))
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(big_map &lt; Z.zero) then return (c, total)
              else return (c, Z.add total (Z.of_int size_diff)))
        (c, Z.zero)
        diff

let create_base c ?(prepaid_bootstrap_storage = false)
    (* Free space for bootstrap contracts *)
    contract ~balance ~manager ~delegate ?script () =
  ( match Contract_repr.is_implicit contract with
  | None -&gt;
      return c
  | Some _ -&gt;
      Storage.Contract.Global_counter.get c
      &gt;&gt;=? fun counter -&gt; Storage.Contract.Counter.init c contract counter )
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Balance.init c contract balance
  &gt;&gt;=? fun c -&gt;
  ( match manager with
  | Some manager -&gt;
      Storage.Contract.Manager.init c contract (Manager_repr.Hash manager)
  | None -&gt;
      return c )
  &gt;&gt;=? fun c -&gt;
  ( match delegate with
  | None -&gt;
      return c
  | Some delegate -&gt;
      Delegate_storage.init c contract delegate )
  &gt;&gt;=? fun c -&gt;
  match script with
  | Some ({Script_repr.code; storage}, big_map_diff) -&gt;
      Storage.Contract.Code.init c contract code
      &gt;&gt;=? fun (c, code_size) -&gt;
      Storage.Contract.Storage.init c contract storage
      &gt;&gt;=? fun (c, storage_size) -&gt;
      update_script_big_map c big_map_diff
      &gt;&gt;=? fun (c, big_map_size) -&gt;
      let total_size =
        Z.add (Z.add (Z.of_int code_size) (Z.of_int storage_size)) big_map_size
      in
      <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.Z.(total_size &gt;= Z.zero)) ;
      let prepaid_bootstrap_storage =
        if prepaid_bootstrap_storage then total_size else Z.zero
      in
      Storage.Contract.Paid_storage_space.init
        c
        contract
        prepaid_bootstrap_storage
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Used_storage_space.init c contract total_size</abbr>
  | None -&gt;
      return c

let originate c ?prepaid_bootstrap_storage contract ~balance ~script ~delegate
    =
  create_base
    c
    ?prepaid_bootstrap_storage
    contract
    ~balance
    ~manager:None
    ~delegate
    ~script
    ()

let create_implicit c manager ~balance =
  create_base
    c
    (Contract_repr.implicit_contract manager)
    ~balance
    ~manager:(Some manager)
    ?script:None
    ~delegate:None
    ()

let delete c contract =
  match Contract_repr.is_implicit contract with
  | None -&gt;
      (* For non implicit contract Big_map should be cleared *)
      failwith &quot;Non implicit contracts cannot be removed&quot;
  | Some _ -&gt;
      Delegate_storage.remove c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Balance.delete c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Manager.delete c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Counter.delete c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Code.remove c contract
      &gt;&gt;=? fun (c, _, _) -&gt;
      Storage.Contract.Storage.remove c contract
      &gt;&gt;=? fun (c, _, _) -&gt;
      Storage.Contract.Paid_storage_space.remove c contract
      &gt;&gt;= fun c -&gt;
      Storage.Contract.Used_storage_space.remove c contract
      &gt;&gt;= fun c -&gt; return c

let allocated c contract =
  Storage.Contract.Balance.get_option c contract
  &gt;&gt;=? function None -&gt; return_false | Some _ -&gt; return_true

let exists c contract =
  match Contract_repr.is_implicit contract with
  | Some _ -&gt;
      return_true
  | None -&gt;
      allocated c contract

let must_exist c contract =
  exists c contract
  &gt;&gt;=? function
  | true -&gt; return_unit | false -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Non_existing_contract contract)</abbr>

let must_be_allocated c contract =
  allocated c contract
  &gt;&gt;=? function
  | true -&gt;
      return_unit
  | false -&gt; (
    match Contract_repr.is_implicit contract with
    | Some pkh -&gt;
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Empty_implicit_contract pkh)</abbr>
    | None -&gt;
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Non_existing_contract contract)</abbr> )

let list c = Storage.Contract.list c

let fresh_contract_from_current_nonce c =
  Lwt.return (Raw_context.increment_origination_nonce c)
  &gt;&gt;=? fun (c, nonce) -&gt; return (c, Contract_repr.originated_contract nonce)

let originated_from_current_nonce ~since:ctxt_since ~until:ctxt_until =
  Lwt.return (Raw_context.origination_nonce ctxt_since)
  &gt;&gt;=? fun since -&gt;
  Lwt.return (Raw_context.origination_nonce ctxt_until)
  &gt;&gt;=? fun until -&gt;
  filter_map_s
    (fun contract -&gt;
      exists ctxt_until contract
      &gt;&gt;=? function true -&gt; return_some contract | false -&gt; return_none)
    (Contract_repr.originated_contracts ~since ~until)

let check_counter_increment c manager counter =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Counter.get c contract
  &gt;&gt;=? fun contract_counter -&gt;
  let expected = Z.succ contract_counter in
  if Compare.Z.(expected = counter) then return_unit
  else if Compare.Z.(expected &gt; counter) then
    fail <abbr class="mark-error" title="Values of extensible types are not handled">(Counter_in_the_past (contract, expected, counter))</abbr>
  else fail <abbr class="mark-error" title="Values of extensible types are not handled">(Counter_in_the_future (contract, expected, counter))</abbr>

let increment_counter c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Global_counter.get c
  &gt;&gt;=? fun global_counter -&gt;
  Storage.Contract.Global_counter.set c (Z.succ global_counter)
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Counter.get c contract
  &gt;&gt;=? fun contract_counter -&gt;
  Storage.Contract.Counter.set c contract (Z.succ contract_counter)

let get_script_code c contract = Storage.Contract.Code.get_option c contract

let get_script c contract =
  Storage.Contract.Code.get_option c contract
  &gt;&gt;=? fun (c, code) -&gt;
  Storage.Contract.Storage.get_option c contract
  &gt;&gt;=? fun (c, storage) -&gt;
  match (code, storage) with
  | (None, None) -&gt;
      return (c, None)
  | (Some code, Some storage) -&gt;
      return (c, Some {Script_repr.code; storage})
  | (None, Some _) | (Some _, None) -&gt;
      failwith &quot;get_script&quot;

let get_storage ctxt contract =
  Storage.Contract.Storage.get_option ctxt contract
  &gt;&gt;=? function
  | (ctxt, None) -&gt;
      return (ctxt, None)
  | (ctxt, Some storage) -&gt;
      Lwt.return (Script_repr.force_decode storage)
      &gt;&gt;=? fun (storage, cost) -&gt;
      Lwt.return (Raw_context.consume_gas ctxt cost)
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, Some storage)

let get_counter c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Counter.get_option c contract
  &gt;&gt;=? function
  | None -&gt; (
    match Contract_repr.is_implicit contract with
    | Some _ -&gt;
        Storage.Contract.Global_counter.get c
    | None -&gt;
        failwith &quot;get_counter&quot; )
  | Some v -&gt;
      return v

let get_manager_key c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Manager.get_option c contract
  &gt;&gt;=? function
  | None -&gt;
      failwith &quot;get_manager_key&quot;
  | Some (Manager_repr.Hash _) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unrevealed_manager_key contract)</abbr>
  | Some (Manager_repr.Public_key v) -&gt;
      return v

let is_manager_key_revealed c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Manager.get_option c contract
  &gt;&gt;=? function
  | None -&gt;
      return_false
  | Some (Manager_repr.Hash _) -&gt;
      return_false
  | Some (Manager_repr.Public_key _) -&gt;
      return_true

let reveal_manager_key c manager public_key =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Manager.get c contract
  &gt;&gt;=? function
  | Public_key _ -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Previously_revealed_key contract)</abbr>
  | Hash v -&gt;
      let actual_hash = Signature.Public_key.hash public_key in
      if Signature.Public_key_hash.equal actual_hash v then
        let v = Manager_repr.Public_key public_key in
        Storage.Contract.Manager.set c contract v &gt;&gt;=? fun c -&gt; return c
      else fail <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_hash (public_key, v, actual_hash))</abbr>

let get_balance c contract =
  Storage.Contract.Balance.get_option c contract
  &gt;&gt;=? function
  | None -&gt; (
    match Contract_repr.is_implicit contract with
    | Some _ -&gt;
        return Tez_repr.zero
    | None -&gt;
        failwith &quot;get_balance&quot; )
  | Some v -&gt;
      return v

let update_script_storage c contract storage big_map_diff =
  let storage = Script_repr.lazy_expr storage in
  update_script_big_map c big_map_diff
  &gt;&gt;=? fun (c, big_map_size_diff) -&gt;
  Storage.Contract.Storage.set c contract storage
  &gt;&gt;=? fun (c, size_diff) -&gt;
  Storage.Contract.Used_storage_space.get c contract
  &gt;&gt;=? fun previous_size -&gt;
  let new_size =
    Z.add previous_size (Z.add big_map_size_diff (Z.of_int size_diff))
  in
  Storage.Contract.Used_storage_space.set c contract new_size

let spend c contract amount =
  Storage.Contract.Balance.get c contract
  &gt;&gt;=? fun balance -&gt;
  match Tez_repr.(balance -? amount) with
  | Error _ -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Balance_too_low (contract, balance, amount))</abbr>
  | Ok new_balance -&gt; (
      Storage.Contract.Balance.set c contract new_balance
      &gt;&gt;=? fun c -&gt;
      Roll_storage.Contract.remove_amount c contract amount
      &gt;&gt;=? fun c -&gt;
      if Tez_repr.(new_balance &gt; Tez_repr.zero) then return c
      else
        match Contract_repr.is_implicit contract with
        | None -&gt;
            return c (* Never delete originated contracts *)
        | Some pkh -&gt; (
            Delegate_storage.get c contract
            &gt;&gt;=? function
            | Some pkh' -&gt;
                (* Don't delete &quot;delegate&quot; contract *)
                <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Signature.Public_key_hash.equal pkh pkh') ;
                return c</abbr>
            | None -&gt;
                (* Delete empty implicit contract *)
                delete c contract ) )

let credit c contract amount =
  ( if Tez_repr.(amount &lt;&gt; Tez_repr.zero) then return c
  else
    Storage.Contract.Code.mem c contract
    &gt;&gt;=? fun (c, target_has_code) -&gt;
    fail_unless target_has_code <abbr class="mark-error" title="Values of extensible types are not handled">(Empty_transaction contract)</abbr>
    &gt;&gt;=? fun () -&gt; return c )
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Balance.get_option c contract
  &gt;&gt;=? function
  | None -&gt; (
    match Contract_repr.is_implicit contract with
    | None -&gt;
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Non_existing_contract contract)</abbr>
    | Some manager -&gt;
        create_implicit c manager ~balance:amount )
  | Some balance -&gt;
      Lwt.return Tez_repr.(amount +? balance)
      &gt;&gt;=? fun balance -&gt;
      Storage.Contract.Balance.set c contract balance
      &gt;&gt;=? fun c -&gt; Roll_storage.Contract.add_amount c contract amount

let init c = Storage.Contract.Global_counter.init c Z.zero

let used_storage_space c contract =
  Storage.Contract.Used_storage_space.get_option c contract
  &gt;&gt;=? function None -&gt; return Z.zero | Some fees -&gt; return fees

let paid_storage_space c contract =
  Storage.Contract.Paid_storage_space.get_option c contract
  &gt;&gt;=? function None -&gt; return Z.zero | Some paid_space -&gt; return paid_space

let set_paid_storage_space_and_return_fees_to_pay c contract new_storage_space
    =
  Storage.Contract.Paid_storage_space.get c contract
  &gt;&gt;=? fun already_paid_space -&gt;
  if Compare.Z.(already_paid_space &gt;= new_storage_space) then return (Z.zero, c)
  else
    let to_pay = Z.sub new_storage_space already_paid_space in
    Storage.Contract.Paid_storage_space.set c contract new_storage_space
    &gt;&gt;=? fun c -&gt; return (to_pay, c)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_storage.ml"><code>Contract_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_repr.
Require Tezos.Delegate_storage.
Require Tezos.Manager_repr.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Storage.
Require Tezos.Tez_repr.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition failwith {A : Set} (msg : string) : Lwt.t (Error_monad.tzresult A) :=
  Error_monad.fail extensible_type_value.

Module big_map_diff_item.
  Module Update.
    Record record {big_map diff_key diff_key_hash diff_value : Set} := {
      big_map : big_map;
      diff_key : diff_key;
      diff_key_hash : diff_key_hash;
      diff_value : diff_value }.
    Arguments record : clear implicits.
  End Update.
  Definition Update := Update.record.
  
  Module Alloc.
    Record record {big_map key_type value_type : Set} := {
      big_map : big_map;
      key_type : key_type;
      value_type : value_type }.
    Arguments record : clear implicits.
  End Alloc.
  Definition Alloc := Alloc.record.
End big_map_diff_item.

Inductive big_map_diff_item : Set :=
| Update :
  big_map_diff_item.Update Z.t Script_repr.expr Script_expr_hash.t
    (option Script_repr.expr) -&gt; big_map_diff_item
| Clear : Z.t -&gt; big_map_diff_item
| Copy : Z.t -&gt; Z.t -&gt; big_map_diff_item
| Alloc :
  big_map_diff_item.Alloc Z.t Script_repr.expr Script_repr.expr -&gt;
  big_map_diff_item.

Definition big_map_diff := list big_map_diff_item.

Definition big_map_diff_item_encoding
  : Data_encoding.encoding big_map_diff_item :=
  Data_encoding.union None
    (cons
      (Data_encoding.__case_value &quot;update&quot; % string None (Data_encoding.Tag 0)
        (Data_encoding.obj5
          (Data_encoding.req None None &quot;action&quot; % string
            (Data_encoding.constant &quot;update&quot; % string))
          (Data_encoding.req None None &quot;big_map&quot; % string Data_encoding.z)
          (Data_encoding.req None None &quot;key_hash&quot; % string
            Script_expr_hash.encoding)
          (Data_encoding.req None None &quot;key&quot; % string Script_repr.expr_encoding)
          (Data_encoding.opt None None &quot;value&quot; % string
            Script_repr.expr_encoding))
        (fun function_parameter =&gt;
          match function_parameter with
          |
            Update {|
              big_map_diff_item.Update.big_map := big_map;
                big_map_diff_item.Update.diff_key := diff_key;
                big_map_diff_item.Update.diff_key_hash := diff_key_hash;
                big_map_diff_item.Update.diff_value := diff_value
                |} =&gt; Some (tt, big_map, diff_key_hash, diff_key, diff_value)
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(tt, big_map, diff_key_hash, diff_key, diff_value) :=
            function_parameter in
          Update
            {| big_map_diff_item.Update.big_map := big_map;
              big_map_diff_item.Update.diff_key := diff_key;
              big_map_diff_item.Update.diff_key_hash := diff_key_hash;
              big_map_diff_item.Update.diff_value := diff_value |}))
      (cons
        (Data_encoding.__case_value &quot;remove&quot; % string None (Data_encoding.Tag 1)
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;action&quot; % string
              (Data_encoding.constant &quot;remove&quot; % string))
            (Data_encoding.req None None &quot;big_map&quot; % string Data_encoding.z))
          (fun function_parameter =&gt;
            match function_parameter with
            | Clear big_map =&gt; Some (tt, big_map)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(tt, big_map) := function_parameter in
            Clear big_map))
        (cons
          (Data_encoding.__case_value &quot;copy&quot; % string None (Data_encoding.Tag 2)
            (Data_encoding.obj3
              (Data_encoding.req None None &quot;action&quot; % string
                (Data_encoding.constant &quot;copy&quot; % string))
              (Data_encoding.req None None &quot;source_big_map&quot; % string
                Data_encoding.z)
              (Data_encoding.req None None &quot;destination_big_map&quot; % string
                Data_encoding.z))
            (fun function_parameter =&gt;
              match function_parameter with
              | Copy src dst =&gt; Some (tt, src, dst)
              | _ =&gt; None
              end)
            (fun function_parameter =&gt;
              let '(tt, src, dst) := function_parameter in
              Copy src dst))
          (cons
            (Data_encoding.__case_value &quot;alloc&quot; % string None
              (Data_encoding.Tag 3)
              (Data_encoding.obj4
                (Data_encoding.req None None &quot;action&quot; % string
                  (Data_encoding.constant &quot;alloc&quot; % string))
                (Data_encoding.req None None &quot;big_map&quot; % string Data_encoding.z)
                (Data_encoding.req None None &quot;key_type&quot; % string
                  Script_repr.expr_encoding)
                (Data_encoding.req None None &quot;value_type&quot; % string
                  Script_repr.expr_encoding))
              (fun function_parameter =&gt;
                match function_parameter with
                |
                  Alloc {|
                    big_map_diff_item.Alloc.big_map := big_map;
                      big_map_diff_item.Alloc.key_type := key_type;
                      big_map_diff_item.Alloc.value_type := value_type
                      |} =&gt; Some (tt, big_map, key_type, value_type)
                | _ =&gt; None
                end)
              (fun function_parameter =&gt;
                let '(tt, big_map, key_type, value_type) := function_parameter
                  in
                Alloc
                  {| big_map_diff_item.Alloc.big_map := big_map;
                    big_map_diff_item.Alloc.key_type := key_type;
                    big_map_diff_item.Alloc.value_type := value_type |})) [])))).

Definition big_map_diff_encoding
  : Data_encoding.encoding (list big_map_diff_item) :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;contract.big_map_diff&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.__list_value None big_map_diff_item_encoding).

Definition big_map_key_cost : Z := 65.

Definition big_map_cost : Z := 33.

Definition update_script_big_map
  (c : Storage.Big_map.Total_bytes.context)
  (function_parameter : option (list big_map_diff_item))
  : Lwt.t (Error_monad.tzresult (Storage.Big_map.Total_bytes.context * Z.t)) :=
  match function_parameter with
  | None =&gt; Error_monad.__return (c, Z.zero)
  | Some diff =&gt;
    Error_monad.fold_left_s
      (fun function_parameter =&gt;
        let '(c, total) := function_parameter in
        fun function_parameter =&gt;
          match function_parameter with
          | Clear id =&gt;
            Error_monad.op_gtgteqquestion (Storage.Big_map.Total_bytes.get c id)
              (fun size =&gt;
                Error_monad.op_gtgteq (Storage.Big_map.remove_rec c id)
                  (fun c =&gt;
                    if Compare.Z.[Compare.S.op_lt] id Z.zero then
                      Error_monad.__return (c, total)
                    else
                      Error_monad.__return
                        (c, (Z.sub (Z.sub total size) (Z.of_int big_map_cost)))))
          | Copy from to_ =&gt;
            Error_monad.op_gtgteqquestion (Storage.Big_map.copy c from to_)
              (fun c =&gt;
                if Compare.Z.[Compare.S.op_lt] to_ Z.zero then
                  Error_monad.__return (c, total)
                else
                  Error_monad.op_gtgteqquestion
                    (Storage.Big_map.Total_bytes.get c from)
                    (fun size =&gt;
                      Error_monad.__return
                        (c, (Z.add (Z.add total size) (Z.of_int big_map_cost)))))
          |
            Alloc {|
              big_map_diff_item.Alloc.big_map := big_map;
                big_map_diff_item.Alloc.key_type := key_type;
                big_map_diff_item.Alloc.value_type := value_type
                |} =&gt;
            Error_monad.op_gtgteqquestion
              (Storage.Big_map.Total_bytes.init c big_map Z.zero)
              (fun c =&gt;
                let key_type :=
                  Micheline.strip_locations
                    (Script_repr.strip_annotations (Micheline.root key_type)) in
                let value_type :=
                  Micheline.strip_locations
                    (Script_repr.strip_annotations (Micheline.root value_type))
                  in
                Error_monad.op_gtgteqquestion
                  (Storage.Big_map.Key_type.init c big_map key_type)
                  (fun c =&gt;
                    Error_monad.op_gtgteqquestion
                      (Storage.Big_map.Value_type.init c big_map value_type)
                      (fun c =&gt;
                        if Compare.Z.[Compare.S.op_lt] big_map Z.zero then
                          Error_monad.__return (c, total)
                        else
                          Error_monad.__return
                            (c, (Z.add total (Z.of_int big_map_cost))))))
          |
            Update {|
              big_map_diff_item.Update.big_map := big_map;
                big_map_diff_item.Update.diff_key_hash := diff_key_hash;
                big_map_diff_item.Update.diff_value := None
                |} =&gt;
            Error_monad.op_gtgteqquestion
              (Storage.Big_map.Contents.remove (c, big_map) diff_key_hash)
              (fun function_parameter =&gt;
                let '(c, freed, existed) := function_parameter in
                let freed :=
                  if existed then
                    Pervasives.op_plus freed big_map_key_cost
                  else
                    freed in
                Error_monad.op_gtgteqquestion
                  (Storage.Big_map.Total_bytes.get c big_map)
                  (fun size =&gt;
                    Error_monad.op_gtgteqquestion
                      (Storage.Big_map.Total_bytes.set c big_map
                        (Z.sub size (Z.of_int freed)))
                      (fun c =&gt;
                        if Compare.Z.[Compare.S.op_lt] big_map Z.zero then
                          Error_monad.__return (c, total)
                        else
                          Error_monad.__return
                            (c, (Z.sub total (Z.of_int freed))))))
          |
            Update {|
              big_map_diff_item.Update.big_map := big_map;
                big_map_diff_item.Update.diff_key_hash := diff_key_hash;
                big_map_diff_item.Update.diff_value := Some v
                |} =&gt;
            Error_monad.op_gtgteqquestion
              (Storage.Big_map.Contents.init_set (c, big_map) diff_key_hash v)
              (fun function_parameter =&gt;
                let '(c, size_diff, existed) := function_parameter in
                let size_diff :=
                  if existed then
                    size_diff
                  else
                    Pervasives.op_plus size_diff big_map_key_cost in
                Error_monad.op_gtgteqquestion
                  (Storage.Big_map.Total_bytes.get c big_map)
                  (fun size =&gt;
                    Error_monad.op_gtgteqquestion
                      (Storage.Big_map.Total_bytes.set c big_map
                        (Z.add size (Z.of_int size_diff)))
                      (fun c =&gt;
                        if Compare.Z.[Compare.S.op_lt] big_map Z.zero then
                          Error_monad.__return (c, total)
                        else
                          Error_monad.__return
                            (c, (Z.add total (Z.of_int size_diff))))))
          end) (c, Z.zero) diff
  end.

Definition create_base (c : Raw_context.t) (op_staroptstar : option bool)
  : Contract_repr.contract -&gt; Storage.Contract.Balance.value -&gt;
  option Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  option Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  option (Script_repr.t * option (list big_map_diff_item)) -&gt; unit -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let prepaid_bootstrap_storage :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun contract =&gt;
    fun balance =&gt;
      fun manager =&gt;
        fun delegate =&gt;
          fun script =&gt;
            fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion
                match Contract_repr.is_implicit contract with
                | None =&gt; Error_monad.__return c
                | Some _ =&gt;
                  Error_monad.op_gtgteqquestion
                    (Storage.Contract.Global_counter.get c)
                    (fun counter =&gt;
                      Storage.Contract.Counter.init c contract counter)
                end
                (fun c =&gt;
                  Error_monad.op_gtgteqquestion
                    (Storage.Contract.Balance.init c contract balance)
                    (fun c =&gt;
                      Error_monad.op_gtgteqquestion
                        match manager with
                        | Some manager =&gt;
                          Storage.Contract.Manager.init c contract
                            (Manager_repr.Hash manager)
                        | None =&gt; Error_monad.__return c
                        end
                        (fun c =&gt;
                          Error_monad.op_gtgteqquestion
                            match delegate with
                            | None =&gt; Error_monad.__return c
                            | Some delegate =&gt;
                              Delegate_storage.init c contract delegate
                            end
                            (fun c =&gt;
                              match script with
                              |
                                Some
                                  ({|
                                    Script_repr.t.code := code;
                                      Script_repr.t.storage := storage
                                      |}, big_map_diff) =&gt;
                                Error_monad.op_gtgteqquestion
                                  (Storage.Contract.Code.init c contract code)
                                  (fun function_parameter =&gt;
                                    let '(c, code_size) := function_parameter in
                                    Error_monad.op_gtgteqquestion
                                      (Storage.Contract.Storage.init c contract
                                        storage)
                                      (fun function_parameter =&gt;
                                        let '(c, storage_size) :=
                                          function_parameter in
                                        Error_monad.op_gtgteqquestion
                                          (update_script_big_map c big_map_diff)
                                          (fun function_parameter =&gt;
                                            let '(c, big_map_size) :=
                                              function_parameter in
                                            let total_size :=
                                              Z.add
                                                (Z.add (Z.of_int code_size)
                                                  (Z.of_int storage_size))
                                                big_map_size in
                                            (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
                                            (* ‚ùå instruction_sequence &quot;;&quot; *)
                                            let prepaid_bootstrap_storage :=
                                              if prepaid_bootstrap_storage then
                                                total_size
                                              else
                                                Z.zero in
                                            Error_monad.op_gtgteqquestion
                                              (Storage.Contract.Paid_storage_space.init
                                                c contract
                                                prepaid_bootstrap_storage)
                                              (fun c =&gt;
                                                Storage.Contract.Used_storage_space.init
                                                  c contract total_size))))
                              | None =&gt; Error_monad.__return c
                              end)))).

Definition originate
  (c : Raw_context.t) (prepaid_bootstrap_storage : option bool)
  (contract : Contract_repr.contract) (balance : Storage.Contract.Balance.value)
  (script : Script_repr.t * option (list big_map_diff_item))
  (delegate : option Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  create_base c prepaid_bootstrap_storage contract balance None delegate
    (Some script) tt.

Definition create_implicit
  (c : Raw_context.t)
  (manager : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (balance : Storage.Contract.Balance.value)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  create_base c None (Contract_repr.implicit_contract manager) balance
    (Some manager) None None tt.

Definition delete (c : Raw_context.t) (contract : Contract_repr.contract)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  match Contract_repr.is_implicit contract with
  | None =&gt; failwith &quot;Non implicit contracts cannot be removed&quot; % string
  | Some _ =&gt;
    Error_monad.op_gtgteqquestion (Delegate_storage.remove c contract)
      (fun c =&gt;
        Error_monad.op_gtgteqquestion
          (Storage.Contract.Balance.delete c contract)
          (fun c =&gt;
            Error_monad.op_gtgteqquestion
              (Storage.Contract.Manager.delete c contract)
              (fun c =&gt;
                Error_monad.op_gtgteqquestion
                  (Storage.Contract.Counter.delete c contract)
                  (fun c =&gt;
                    Error_monad.op_gtgteqquestion
                      (Storage.Contract.Code.remove c contract)
                      (fun function_parameter =&gt;
                        let '(c, _, _) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (Storage.Contract.Storage.remove c contract)
                          (fun function_parameter =&gt;
                            let '(c, _, _) := function_parameter in
                            Error_monad.op_gtgteq
                              (Storage.Contract.Paid_storage_space.remove c
                                contract)
                              (fun c =&gt;
                                Error_monad.op_gtgteq
                                  (Storage.Contract.Used_storage_space.remove c
                                    contract) (fun c =&gt; Error_monad.__return c))))))))
  end.

Definition allocated
  (c : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key)
  : Lwt.t (Error_monad.tzresult bool) :=
  Error_monad.op_gtgteqquestion (Storage.Contract.Balance.get_option c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.return_false
      | Some _ =&gt; Error_monad.return_true
      end).

Definition __exists
  (c : Storage.Contract.Balance.context) (contract : Contract_repr.contract)
  : Lwt.t (Error_monad.tzresult bool) :=
  match Contract_repr.is_implicit contract with
  | Some _ =&gt; Error_monad.return_true
  | None =&gt; allocated c contract
  end.

Definition must_exist
  (c : Storage.Contract.Balance.context) (contract : Contract_repr.contract)
  : Lwt.t (Error_monad.tzresult unit) :=
  Error_monad.op_gtgteqquestion (__exists c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | true =&gt; Error_monad.return_unit
      | false =&gt; Error_monad.fail extensible_type_value
      end).

Definition must_be_allocated
  (c : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key)
  : Lwt.t (Error_monad.tzresult unit) :=
  Error_monad.op_gtgteqquestion (allocated c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | true =&gt; Error_monad.return_unit
      | false =&gt;
        match Contract_repr.is_implicit contract with
        | Some pkh =&gt; Error_monad.fail extensible_type_value
        | None =&gt; Error_monad.fail extensible_type_value
        end
      end).

Definition __list_value (c : Raw_context.t) : Lwt.t (list Contract_repr.t) :=
  Storage.Contract.__list_value c.

Definition fresh_contract_from_current_nonce (c : Raw_context.t)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * Contract_repr.contract)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Raw_context.increment_origination_nonce c))
    (fun function_parameter =&gt;
      let '(c, nonce) := function_parameter in
      Error_monad.__return (c, (Contract_repr.originated_contract nonce))).

Definition originated_from_current_nonce
  (ctxt_since : Raw_context.t) (ctxt_until : Raw_context.t)
  : Lwt.t (Error_monad.tzresult (list Contract_repr.contract)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Raw_context.origination_nonce ctxt_since))
    (fun since =&gt;
      Error_monad.op_gtgteqquestion
        (Lwt.__return (Raw_context.origination_nonce ctxt_until))
        (fun until =&gt;
          Error_monad.filter_map_s
            (fun contract =&gt;
              Error_monad.op_gtgteqquestion (__exists ctxt_until contract)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | true =&gt; Error_monad.return_some contract
                  | false =&gt; Error_monad.return_none
                  end)) (Contract_repr.originated_contracts since until))).

Definition check_counter_increment
  (c : Storage.Contract.Counter.context)
  (manager : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (counter : Compare.Z.[Compare.S.t]) : Lwt.t (Error_monad.tzresult unit) :=
  let contract := Contract_repr.implicit_contract manager in
  Error_monad.op_gtgteqquestion (Storage.Contract.Counter.get c contract)
    (fun contract_counter =&gt;
      let expected := Z.succ contract_counter in
      if Compare.Z.[Compare.S.op_eq] expected counter then
        Error_monad.return_unit
      else
        if Compare.Z.[Compare.S.op_gt] expected counter then
          Error_monad.fail extensible_type_value
        else
          Error_monad.fail extensible_type_value).

Definition increment_counter
  (c : Raw_context.t)
  (manager : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract manager in
  Error_monad.op_gtgteqquestion (Storage.Contract.Global_counter.get c)
    (fun global_counter =&gt;
      Error_monad.op_gtgteqquestion
        (Storage.Contract.Global_counter.set c (Z.succ global_counter))
        (fun c =&gt;
          Error_monad.op_gtgteqquestion
            (Storage.Contract.Counter.get c contract)
            (fun contract_counter =&gt;
              Storage.Contract.Counter.set c contract (Z.succ contract_counter)))).

Definition get_script_code
  (c : Storage.Contract.Code.context) (contract : Storage.Contract.Code.key)
  : Lwt.t
    (Error_monad.tzresult (Raw_context.t * option Storage.Contract.Code.value)) :=
  Storage.Contract.Code.get_option c contract.

Definition get_script
  (c : Storage.Contract.Code.context) (contract : Storage.Contract.Code.key)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.t)) :=
  Error_monad.op_gtgteqquestion (Storage.Contract.Code.get_option c contract)
    (fun function_parameter =&gt;
      let '(c, code) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Storage.Contract.Storage.get_option c contract)
        (fun function_parameter =&gt;
          let '(c, storage) := function_parameter in
          match (code, storage) with
          | (None, None) =&gt; Error_monad.__return (c, None)
          | (Some code, Some storage) =&gt;
            Error_monad.__return
              (c,
                (Some
                  {| Script_repr.t.code := code;
                    Script_repr.t.storage := storage |}))
          | (None, Some _) | (Some _, None) =&gt; failwith &quot;get_script&quot; % string
          end)).

Definition get_storage
  (ctxt : Storage.Contract.Storage.context)
  (contract : Storage.Contract.Storage.key)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.expr)) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Storage.get_option ctxt contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | (ctxt, None) =&gt; Error_monad.__return (ctxt, None)
      | (ctxt, Some storage) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Script_repr.force_decode storage))
          (fun function_parameter =&gt;
            let '(storage, cost) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return (Raw_context.consume_gas ctxt cost))
              (fun ctxt =&gt; Error_monad.__return (ctxt, (Some storage))))
      end).

Definition get_counter
  (c : Storage.Contract.Counter.context)
  (manager : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Z.t) :=
  let contract := Contract_repr.implicit_contract manager in
  Error_monad.op_gtgteqquestion (Storage.Contract.Counter.get_option c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt;
        match Contract_repr.is_implicit contract with
        | Some _ =&gt; Storage.Contract.Global_counter.get c
        | None =&gt; failwith &quot;get_counter&quot; % string
        end
      | Some v =&gt; Error_monad.__return v
      end).

Definition get_manager_key
  (c : Storage.Contract.Manager.context)
  (manager : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Signature.Public_key.[S.SPublic_key.t]) :=
  let contract := Contract_repr.implicit_contract manager in
  Error_monad.op_gtgteqquestion (Storage.Contract.Manager.get_option c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; failwith &quot;get_manager_key&quot; % string
      | Some (Manager_repr.Hash _) =&gt; Error_monad.fail extensible_type_value
      | Some (Manager_repr.Public_key v) =&gt; Error_monad.__return v
      end).

Definition is_manager_key_revealed
  (c : Storage.Contract.Manager.context)
  (manager : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult bool) :=
  let contract := Contract_repr.implicit_contract manager in
  Error_monad.op_gtgteqquestion (Storage.Contract.Manager.get_option c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.return_false
      | Some (Manager_repr.Hash _) =&gt; Error_monad.return_false
      | Some (Manager_repr.Public_key _) =&gt; Error_monad.return_true
      end).

Definition reveal_manager_key
  (c : Storage.Contract.Manager.context)
  (manager : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (public_key : Signature.Public_key.[S.SPublic_key.t])
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract manager in
  Error_monad.op_gtgteqquestion (Storage.Contract.Manager.get c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | Manager_repr.Public_key _ =&gt; Error_monad.fail extensible_type_value
      | Manager_repr.Hash v =&gt;
        let actual_hash :=
          Signature.Public_key.[S.SPublic_key.__hash_value] public_key in
        if Signature.Public_key_hash.[S.SPublic_key_hash.equal] actual_hash v
          then
          let v := Manager_repr.Public_key public_key in
          Error_monad.op_gtgteqquestion
            (Storage.Contract.Manager.set c contract v)
            (fun c =&gt; Error_monad.__return c)
        else
          Error_monad.fail extensible_type_value
      end).

Definition get_balance
  (c : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key)
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  Error_monad.op_gtgteqquestion (Storage.Contract.Balance.get_option c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt;
        match Contract_repr.is_implicit contract with
        | Some _ =&gt; Error_monad.__return Tez_repr.zero
        | None =&gt; failwith &quot;get_balance&quot; % string
        end
      | Some v =&gt; Error_monad.__return v
      end).

Definition update_script_storage
  (c : Storage.Big_map.Total_bytes.context)
  (contract : Storage.Contract.Storage.key) (storage : Script_repr.expr)
  (big_map_diff : option (list big_map_diff_item))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let storage := Script_repr.lazy_expr storage in
  Error_monad.op_gtgteqquestion (update_script_big_map c big_map_diff)
    (fun function_parameter =&gt;
      let '(c, big_map_size_diff) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Storage.Contract.Storage.set c contract storage)
        (fun function_parameter =&gt;
          let '(c, size_diff) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Storage.Contract.Used_storage_space.get c contract)
            (fun previous_size =&gt;
              let new_size :=
                Z.add previous_size
                  (Z.add big_map_size_diff (Z.of_int size_diff)) in
              Storage.Contract.Used_storage_space.set c contract new_size))).

Definition spend
  (c : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key) (amount : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion (Storage.Contract.Balance.get c contract)
    (fun balance =&gt;
      match Tez_repr.op_minusquestion balance amount with
      | Pervasives.Error _ =&gt; Error_monad.fail extensible_type_value
      | Pervasives.Ok new_balance =&gt;
        Error_monad.op_gtgteqquestion
          (Storage.Contract.Balance.set c contract new_balance)
          (fun c =&gt;
            Error_monad.op_gtgteqquestion
              (Roll_storage.Contract.remove_amount c contract amount)
              (fun c =&gt;
                if Tez_repr.op_gt new_balance Tez_repr.zero then
                  Error_monad.__return c
                else
                  match Contract_repr.is_implicit contract with
                  | None =&gt; Error_monad.__return c
                  | Some pkh =&gt;
                    Error_monad.op_gtgteqquestion
                      (Delegate_storage.get c contract)
                      (fun function_parameter =&gt;
                        match function_parameter with
                        | Some pkh' =&gt;
                          (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
                          (* ‚ùå instruction_sequence &quot;;&quot; *)
                          Error_monad.__return c
                        | None =&gt; delete c contract
                        end)
                  end))
      end).

Definition credit
  (c : Storage.Contract.Code.context) (contract : Storage.Contract.Code.key)
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion
    (if Tez_repr.op_ltgt amount Tez_repr.zero then
      Error_monad.__return c
    else
      Error_monad.op_gtgteqquestion (Storage.Contract.Code.mem c contract)
        (fun function_parameter =&gt;
          let '(c, target_has_code) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Error_monad.fail_unless target_has_code extensible_type_value)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.__return c)))
    (fun c =&gt;
      Error_monad.op_gtgteqquestion
        (Storage.Contract.Balance.get_option c contract)
        (fun function_parameter =&gt;
          match function_parameter with
          | None =&gt;
            match Contract_repr.is_implicit contract with
            | None =&gt; Error_monad.fail extensible_type_value
            | Some manager =&gt; create_implicit c manager amount
            end
          | Some balance =&gt;
            Error_monad.op_gtgteqquestion
              (Lwt.__return (Tez_repr.op_plusquestion amount balance))
              (fun balance =&gt;
                Error_monad.op_gtgteqquestion
                  (Storage.Contract.Balance.set c contract balance)
                  (fun c =&gt; Roll_storage.Contract.add_amount c contract amount))
          end)).

Definition init (c : Raw_context.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Contract.Global_counter.init c Z.zero.

Definition used_storage_space
  (c : Storage.Contract.Used_storage_space.context)
  (contract : Storage.Contract.Used_storage_space.key)
  : Lwt.t (Error_monad.tzresult Z.t) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Used_storage_space.get_option c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return Z.zero
      | Some fees =&gt; Error_monad.__return fees
      end).

Definition paid_storage_space
  (c : Storage.Contract.Paid_storage_space.context)
  (contract : Storage.Contract.Paid_storage_space.key)
  : Lwt.t (Error_monad.tzresult Z.t) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Paid_storage_space.get_option c contract)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return Z.zero
      | Some paid_space =&gt; Error_monad.__return paid_space
      end).

Definition set_paid_storage_space_and_return_fees_to_pay
  (c : Storage.Contract.Paid_storage_space.context)
  (contract : Storage.Contract.Paid_storage_space.key)
  (new_storage_space : Compare.Z.[Compare.S.t])
  : Lwt.t
    (Error_monad.tzresult (Z.t * Storage.Contract.Paid_storage_space.context)) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Paid_storage_space.get c contract)
    (fun already_paid_space =&gt;
      if Compare.Z.[Compare.S.op_gteq] already_paid_space new_storage_space then
        Error_monad.__return (Z.zero, c)
      else
        let to_pay := Z.sub new_storage_space already_paid_space in
        Error_monad.op_gtgteqquestion
          (Storage.Contract.Paid_storage_space.set c contract new_storage_space)
          (fun c =&gt; Error_monad.__return (to_pay, c))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_storage.mli">
  <div class="col-md-6">
    <a href="#contract_storage.mli"><code>contract_storage.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Balance_too_low of Contract_repr.contract * Tez_repr.t * Tez_repr.t
  | (* `Temporary *)
      Counter_in_the_past of Contract_repr.contract * Z.t * Z.t
  | (* `Branch *)
      Counter_in_the_future of Contract_repr.contract * Z.t * Z.t
  | (* `Temporary *)
      Unspendable_contract of Contract_repr.contract
  | (* `Permanent *)
      Non_existing_contract of Contract_repr.contract
  | (* `Temporary *)
      Empty_implicit_contract of Signature.Public_key_hash.t
  | (* `Temporary *)
      Empty_transaction of Contract_repr.t (* `Temporary *)
  | Inconsistent_hash of
      Signature.Public_key.t
      * Signature.Public_key_hash.t
      * Signature.Public_key_hash.t
  | (* `Permanent *)
      Inconsistent_public_key of
      Signature.Public_key.t * Signature.Public_key.t
  | (* `Permanent *)
      Failure of string (* `Permanent *)
  | Previously_revealed_key of Contract_repr.t (* `Permanent *)
  | Unrevealed_manager_key of Contract_repr.t</abbr>

(* `Permanent *)

val exists : Raw_context.t -&gt; Contract_repr.t -&gt; bool tzresult Lwt.t

val must_exist : Raw_context.t -&gt; Contract_repr.t -&gt; unit tzresult Lwt.t

val allocated : Raw_context.t -&gt; Contract_repr.t -&gt; bool tzresult Lwt.t

val must_be_allocated : Raw_context.t -&gt; Contract_repr.t -&gt; unit tzresult Lwt.t

val list : Raw_context.t -&gt; Contract_repr.t list Lwt.t

val check_counter_increment :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Z.t -&gt; unit tzresult Lwt.t

val increment_counter :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Raw_context.t tzresult Lwt.t

val get_manager_key :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Signature.Public_key.t tzresult Lwt.t

val is_manager_key_revealed :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

val reveal_manager_key :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Signature.Public_key.t -&gt;
  Raw_context.t tzresult Lwt.t

val get_balance : Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t tzresult Lwt.t

val get_counter :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Z.t tzresult Lwt.t

val get_script_code :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Script_repr.lazy_expr option) tzresult Lwt.t

val get_script :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Script_repr.t option) tzresult Lwt.t

val get_storage :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Script_repr.expr option) tzresult Lwt.t

type big_map_diff_item =
  | Update of {
      big_map : Z.t;
      diff_key : Script_repr.expr;
      diff_key_hash : Script_expr_hash.t;
      diff_value : Script_repr.expr option;
    }
  | Clear of Z.t
  | Copy of Z.t * Z.t
  | Alloc of {
      big_map : Z.t;
      key_type : Script_repr.expr;
      value_type : Script_repr.expr;
    }

type big_map_diff = big_map_diff_item list

val big_map_diff_encoding : big_map_diff Data_encoding.t

val update_script_storage :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Script_repr.expr -&gt;
  big_map_diff option -&gt;
  Raw_context.t tzresult Lwt.t

val credit :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val spend :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val originate :
  Raw_context.t -&gt;
  ?prepaid_bootstrap_storage:bool -&gt;
  Contract_repr.t -&gt;
  balance:Tez_repr.t -&gt;
  script:Script_repr.t * big_map_diff option -&gt;
  delegate:Signature.Public_key_hash.t option -&gt;
  Raw_context.t tzresult Lwt.t

val fresh_contract_from_current_nonce :
  Raw_context.t -&gt; (Raw_context.t * Contract_repr.t) tzresult Lwt.t

val originated_from_current_nonce :
  since:Raw_context.t -&gt;
  until:Raw_context.t -&gt;
  Contract_repr.t list tzresult Lwt.t

val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val used_storage_space : Raw_context.t -&gt; Contract_repr.t -&gt; Z.t tzresult Lwt.t

val paid_storage_space : Raw_context.t -&gt; Contract_repr.t -&gt; Z.t tzresult Lwt.t

val set_paid_storage_space_and_return_fees_to_pay :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Z.t -&gt;
  (Z.t * Raw_context.t) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_storage.mli"><code>Contract_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_repr.
Require Tezos.Raw_context.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Tez_repr.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter __exists :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult bool).

Parameter must_exist :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter allocated :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult bool).

Parameter must_be_allocated :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter __list_value : Raw_context.t -&gt; Lwt.t (list Contract_repr.t).

Parameter check_counter_increment :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Z.t -&gt;
  Lwt.t (Error_monad.tzresult unit).

Parameter increment_counter :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_manager_key :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Signature.Public_key.[S.SPublic_key.t]).

Parameter is_manager_key_revealed :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult bool).

Parameter reveal_manager_key :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Signature.Public_key.[S.SPublic_key.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_balance :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter get_counter :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Z.t).

Parameter get_script_code :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.lazy_expr)).

Parameter get_script :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.t)).

Parameter get_storage :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.expr)).

Module big_map_diff_item.
  Module Update.
    Record record {big_map diff_key diff_key_hash diff_value : Set} := {
      big_map : big_map;
      diff_key : diff_key;
      diff_key_hash : diff_key_hash;
      diff_value : diff_value }.
    Arguments record : clear implicits.
  End Update.
  Definition Update := Update.record.
  
  Module Alloc.
    Record record {big_map key_type value_type : Set} := {
      big_map : big_map;
      key_type : key_type;
      value_type : value_type }.
    Arguments record : clear implicits.
  End Alloc.
  Definition Alloc := Alloc.record.
End big_map_diff_item.

Inductive big_map_diff_item : Set :=
| Update :
  big_map_diff_item.Update Z.t Script_repr.expr Script_expr_hash.t
    (option Script_repr.expr) -&gt; big_map_diff_item
| Clear : Z.t -&gt; big_map_diff_item
| Copy : Z.t -&gt; Z.t -&gt; big_map_diff_item
| Alloc :
  big_map_diff_item.Alloc Z.t Script_repr.expr Script_repr.expr -&gt;
  big_map_diff_item.

Definition big_map_diff := list big_map_diff_item.

Parameter big_map_diff_encoding : Data_encoding.t big_map_diff.

Parameter update_script_storage :
  Raw_context.t -&gt; Contract_repr.t -&gt; Script_repr.expr -&gt; option big_map_diff -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter credit :
  Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter spend :
  Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter originate :
  Raw_context.t -&gt; option bool -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
  Script_repr.t * option big_map_diff -&gt;
  option Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter fresh_contract_from_current_nonce :
  Raw_context.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * Contract_repr.t)).

Parameter originated_from_current_nonce :
  Raw_context.t -&gt; Raw_context.t -&gt;
  Lwt.t (Error_monad.tzresult (list Contract_repr.t)).

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter used_storage_space :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Z.t).

Parameter paid_storage_space :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Z.t).

Parameter set_paid_storage_space_and_return_fees_to_pay :
  Raw_context.t -&gt; Contract_repr.t -&gt; Z.t -&gt;
  Lwt.t (Error_monad.tzresult (Z.t * Raw_context.t)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cycle_repr.ml">
  <div class="col-md-6">
    <a href="#cycle_repr.ml"><code>cycle_repr.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = int32

type cycle = t

let encoding = Data_encoding.int32

let rpc_arg =
  let construct = Int32.to_string in
  let destruct str =
    match Int32.of_string str with
    | exception <abbr class="mark-error" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">_</abbr> -&gt;
        Error &quot;Cannot parse cycle&quot;
    | cycle -&gt;
        Ok cycle
  in
  RPC_arg.make
    ~descr:&quot;A cycle integer&quot;
    ~name:&quot;block_cycle&quot;
    ~construct
    ~destruct
    ()

let pp ppf cycle = Format.fprintf ppf &quot;%ld&quot; cycle

include (Compare.Int32 : Compare.S with type t := t)

module Map = Map.Make (Compare.Int32)

let root = 0l

let succ = Int32.succ

let pred = function 0l -&gt; None | i -&gt; Some (Int32.pred i)

let add c i =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.Int.(i &gt; 0)) ;
  Int32.add c (Int32.of_int i)</abbr>

let sub c i =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.Int.(i &gt; 0)) ;
  let r = Int32.sub c (Int32.of_int i) in
  if Compare.Int32.(r &lt; 0l) then None else Some r</abbr>

let to_int32 i = i

let of_int32_exn l =
  if Compare.Int32.(l &gt;= 0l) then l
  else invalid_arg &quot;Level_repr.Cycle.of_int32&quot;

module Index = struct
  type t = cycle

  let path_length = 1

  let to_path c l = Int32.to_string (to_int32 c) :: l

  let of_path = function
    | [s] -&gt; <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try Some (Int32.of_string s) with _ -&gt; None )</abbr>
    | _ -&gt;
        None

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cycle_repr.ml"><code>Cycle_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition t := int32.

Definition cycle := t.

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition rpc_arg : RPC_arg.arg int32 :=
  let construct := Int32.to_string in
  let destruct (str : string) : Pervasives.result int32 string :=
    let 'cycle := Int32.of_string str in
    Pervasives.Ok cycle in
  RPC_arg.make (Some &quot;A cycle integer&quot; % string) &quot;block_cycle&quot; % string destruct
    construct tt.

Definition pp (ppf : Format.formatter) (cycle : int32) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%ld&quot; % string) cycle.

Definition op_eq := Compare.Int32.[Compare.S.op_eq].

Definition op_ltgt := Compare.Int32.[Compare.S.op_ltgt].

Definition op_lt := Compare.Int32.[Compare.S.op_lt].

Definition op_lteq := Compare.Int32.[Compare.S.op_lteq].

Definition op_gteq := Compare.Int32.[Compare.S.op_gteq].

Definition op_gt := Compare.Int32.[Compare.S.op_gt].

Definition compare := Compare.Int32.[Compare.S.compare].

Definition equal := Compare.Int32.[Compare.S.equal].

Definition max := Compare.Int32.[Compare.S.max].

Definition min := Compare.Int32.[Compare.S.min].

Definition Map :=
  Map.Make
    (existT _ _
      {|
        Compare.COMPARABLE.compare := Compare.Int32.[Compare.S.compare]
        |}).

Definition root : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ : int32 -&gt; int32 := Int32.succ.

Definition pred (function_parameter : int32) : option int32 :=
  match function_parameter with
  |
    (* ‚ùå Constant of type int32 is converted to int *)
    0 =&gt; None
  | i =&gt; Some (Int32.pred i)
  end.

Definition add (c : int32) (i : Compare.Int.[Compare.S.t]) : int32 :=
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Int32.add c (Int32.of_int i).

Definition sub (c : int32) (i : Compare.Int.[Compare.S.t]) : option int32 :=
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  let r := Int32.sub c (Int32.of_int i) in
  if
    Compare.Int32.[Compare.S.op_lt] r
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    None
  else
    Some r.

Definition to_int32 {A : Set} (i : A) : A := i.

Definition of_int32_exn (l : Compare.Int32.[Compare.S.t])
  : Compare.Int32.[Compare.S.t] :=
  if
    Compare.Int32.[Compare.S.op_gteq] l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    l
  else
    Pervasives.invalid_arg &quot;Level_repr.Cycle.of_int32&quot; % string.

Module Index.
  Definition t := cycle.
  
  Definition path_length : Z := 1.
  
  Definition to_path (c : int32) (l : list string) : list string :=
    cons (Int32.to_string (to_int32 c)) l.
  
  Definition of_path (function_parameter : list string) : option int32 :=
    match function_parameter with
    | cons s [] =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Some (Int32.of_string s))
    | _ =&gt; None
    end.
  
  Definition rpc_arg : RPC_arg.arg int32 := rpc_arg.
  
  Definition encoding : Data_encoding.encoding int32 := encoding.
  
  Definition compare : t -&gt; t -&gt; Z := compare.
End Index.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cycle_repr.mli">
  <div class="col-md-6">
    <a href="#cycle_repr.mli"><code>cycle_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

type cycle = t

include Compare.S with type t := t

val encoding : cycle Data_encoding.t

val rpc_arg : cycle RPC_arg.arg

val pp : Format.formatter -&gt; cycle -&gt; unit

val root : cycle

val pred : cycle -&gt; cycle option

val add : cycle -&gt; int -&gt; cycle

val sub : cycle -&gt; int -&gt; cycle option

val succ : cycle -&gt; cycle

val to_int32 : cycle -&gt; int32

val of_int32_exn : int32 -&gt; cycle

module Map : S.MAP with type key = cycle

module Index : Storage_description.INDEX with type t = cycle
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cycle_repr.mli"><code>Cycle_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Storage_description.

Parameter t : Set.

Definition cycle := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature t}.

Definition op_eq := Included_S.[Compare.S.op_eq].

Definition op_ltgt := Included_S.[Compare.S.op_ltgt].

Definition op_lt := Included_S.[Compare.S.op_lt].

Definition op_lteq := Included_S.[Compare.S.op_lteq].

Definition op_gteq := Included_S.[Compare.S.op_gteq].

Definition op_gt := Included_S.[Compare.S.op_gt].

Definition compare := Included_S.[Compare.S.compare].

Definition equal := Included_S.[Compare.S.equal].

Definition max := Included_S.[Compare.S.max].

Definition min := Included_S.[Compare.S.min].

Parameter encoding : Data_encoding.t cycle.

Parameter rpc_arg : RPC_arg.arg cycle.

Parameter pp : Format.formatter -&gt; cycle -&gt; unit.

Parameter root : cycle.

Parameter pred : cycle -&gt; option cycle.

Parameter add : cycle -&gt; Z -&gt; cycle.

Parameter sub : cycle -&gt; Z -&gt; option cycle.

Parameter succ : cycle -&gt; cycle.

Parameter to_int32 : cycle -&gt; int32.

Parameter of_int32_exn : int32 -&gt; cycle.

Parameter Map : {t : _ &amp; S.MAP.signature cycle t}.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature cycle}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_services.ml">
  <div class="col-md-6">
    <a href="#delegate_services.ml"><code>delegate_services.ml</code></a>&nbsp;<span class="label label-danger">224 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

type info = {
  balance : Tez.t;
  frozen_balance : Tez.t;
  frozen_balance_by_cycle : Delegate.frozen_balance Cycle.Map.t;
  staking_balance : Tez.t;
  delegated_contracts : Contract_repr.t list;
  delegated_balance : Tez.t;
  deactivated : bool;
  grace_period : Cycle.t;
}

let info_encoding =
  let open Data_encoding in
  conv
    (fun { balance;
           frozen_balance;
           frozen_balance_by_cycle;
           staking_balance;
           delegated_contracts;
           delegated_balance;
           deactivated;
           grace_period } -&gt;
      ( balance,
        frozen_balance,
        frozen_balance_by_cycle,
        staking_balance,
        delegated_contracts,
        delegated_balance,
        deactivated,
        grace_period ))
    (fun ( balance,
           frozen_balance,
           frozen_balance_by_cycle,
           staking_balance,
           delegated_contracts,
           delegated_balance,
           deactivated,
           grace_period ) -&gt;
      {
        balance;
        frozen_balance;
        frozen_balance_by_cycle;
        staking_balance;
        delegated_contracts;
        delegated_balance;
        deactivated;
        grace_period;
      })
    (obj8
       (req &quot;balance&quot; Tez.encoding)
       (req &quot;frozen_balance&quot; Tez.encoding)
       (req &quot;frozen_balance_by_cycle&quot; Delegate.frozen_balance_by_cycle_encoding)
       (req &quot;staking_balance&quot; Tez.encoding)
       (req &quot;delegated_contracts&quot; (list Contract_repr.encoding))
       (req &quot;delegated_balance&quot; Tez.encoding)
       (req &quot;deactivated&quot; bool)
       (req &quot;grace_period&quot; Cycle.encoding))

module S = struct
  let path = RPC_path.(open_root / &quot;context&quot; / &quot;delegates&quot;)

  open Data_encoding

  type list_query = {active : bool; inactive : bool}

  let list_query : list_query RPC_query.t =
    let open RPC_query in
    query (fun active inactive -&gt; {active; inactive})
    |+ flag &quot;active&quot; (fun t -&gt; t.active)
    |+ flag &quot;inactive&quot; (fun t -&gt; t.inactive)
    |&gt; seal

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">list_delegate</abbr> =
    RPC_service.get_service
      ~description:&quot;Lists all registered delegates.&quot;
      ~query:list_query
      ~output:(list Signature.Public_key_hash.encoding)
      path

  let path = RPC_path.(path /: Signature.Public_key_hash.rpc_arg)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">info</abbr> =
    RPC_service.get_service
      ~description:&quot;Everything about a delegate.&quot;
      ~query:RPC_query.empty
      ~output:info_encoding
      path

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">balance</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the full balance of a given delegate, including the frozen \
         balances.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;balance&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">frozen_balance</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the total frozen balances of a given delegate, this includes \
         the frozen deposits, rewards and fees.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;frozen_balance&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">frozen_balance_by_cycle</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the frozen balances of a given delegate, indexed by the \
         cycle by which it will be unfrozen&quot;
      ~query:RPC_query.empty
      ~output:Delegate.frozen_balance_by_cycle_encoding
      RPC_path.(path / &quot;frozen_balance_by_cycle&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">staking_balance</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the total amount of tokens delegated to a given delegate. \
         This includes the balances of all the contracts that delegate to it, \
         but also the balance of the delegate itself and its frozen fees and \
         deposits. The rewards do not count in the delegated balance until \
         they are unfrozen.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;staking_balance&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">delegated_contracts</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the list of contracts that delegate to a given delegate.&quot;
      ~query:RPC_query.empty
      ~output:(list Contract_repr.encoding)
      RPC_path.(path / &quot;delegated_contracts&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">delegated_balance</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the balances of all the contracts that delegate to a given \
         delegate. This excludes the delegate's own balance and its frozen \
         balances.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;delegated_balance&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">deactivated</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Tells whether the delegate is currently tagged as deactivated or not.&quot;
      ~query:RPC_query.empty
      ~output:bool
      RPC_path.(path / &quot;deactivated&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">grace_period</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the cycle by the end of which the delegate might be \
         deactivated if she fails to execute any delegate action. A \
         deactivated delegate might be reactivated (without loosing any \
         rolls) by simply re-registering as a delegate. For deactivated \
         delegates, this value contains the cycle by which they were \
         deactivated.&quot;
      ~query:RPC_query.empty
      ~output:Cycle.encoding
      RPC_path.(path / &quot;grace_period&quot;)
end

let register () =
  let open Services_registration in
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.list_delegate (fun ctxt q () -&gt;
      Delegate.list ctxt
      &gt;&gt;= fun delegates -&gt;
      if q.active &amp;&amp; q.inactive then return delegates
      else if q.active then
        filter_map_s
          (fun pkh -&gt;
            Delegate.deactivated ctxt pkh
            &gt;&gt;=? function true -&gt; return_none | false -&gt; return_some pkh)
          delegates
      else if q.inactive then
        filter_map_s
          (fun pkh -&gt;
            Delegate.deactivated ctxt pkh
            &gt;&gt;=? function false -&gt; return_none | true -&gt; return_some pkh)
          delegates
      else return_nil) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.info (fun ctxt pkh () () -&gt;
      Delegate.full_balance ctxt pkh
      &gt;&gt;=? fun balance -&gt;
      Delegate.frozen_balance ctxt pkh
      &gt;&gt;=? fun frozen_balance -&gt;
      Delegate.frozen_balance_by_cycle ctxt pkh
      &gt;&gt;= fun frozen_balance_by_cycle -&gt;
      Delegate.staking_balance ctxt pkh
      &gt;&gt;=? fun staking_balance -&gt;
      Delegate.delegated_contracts ctxt pkh
      &gt;&gt;= fun delegated_contracts -&gt;
      Delegate.delegated_balance ctxt pkh
      &gt;&gt;=? fun delegated_balance -&gt;
      Delegate.deactivated ctxt pkh
      &gt;&gt;=? fun deactivated -&gt;
      Delegate.grace_period ctxt pkh
      &gt;&gt;=? fun grace_period -&gt;
      return
        {
          balance;
          frozen_balance;
          frozen_balance_by_cycle;
          staking_balance;
          delegated_contracts;
          delegated_balance;
          deactivated;
          grace_period;
        }) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.balance (fun ctxt pkh () () -&gt; Delegate.full_balance ctxt pkh) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.frozen_balance (fun ctxt pkh () () -&gt;
      Delegate.frozen_balance ctxt pkh) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.frozen_balance_by_cycle (fun ctxt pkh () () -&gt;
      Delegate.frozen_balance_by_cycle ctxt pkh &gt;&gt;= return) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.staking_balance (fun ctxt pkh () () -&gt;
      Delegate.staking_balance ctxt pkh) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.delegated_contracts (fun ctxt pkh () () -&gt;
      Delegate.delegated_contracts ctxt pkh &gt;&gt;= return) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.delegated_balance (fun ctxt pkh () () -&gt;
      Delegate.delegated_balance ctxt pkh) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.deactivated (fun ctxt pkh () () -&gt; Delegate.deactivated ctxt pkh) ;
  register1 S.grace_period (fun ctxt pkh () () -&gt;
      Delegate.grace_period ctxt pkh)</abbr>

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">list</abbr> ctxt block ?(active = true) ?(inactive = false) () =
  RPC_context.make_call0 S.list_delegate ctxt block {active; inactive} ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">info</abbr> ctxt block pkh = RPC_context.make_call1 S.info ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">balance</abbr> ctxt block pkh =
  RPC_context.make_call1 S.balance ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">frozen_balance</abbr> ctxt block pkh =
  RPC_context.make_call1 S.frozen_balance ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">frozen_balance_by_cycle</abbr> ctxt block pkh =
  RPC_context.make_call1 S.frozen_balance_by_cycle ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">staking_balance</abbr> ctxt block pkh =
  RPC_context.make_call1 S.staking_balance ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">delegated_contracts</abbr> ctxt block pkh =
  RPC_context.make_call1 S.delegated_contracts ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">delegated_balance</abbr> ctxt block pkh =
  RPC_context.make_call1 S.delegated_balance ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">deactivated</abbr> ctxt block pkh =
  RPC_context.make_call1 S.deactivated ctxt block pkh () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">grace_period</abbr> ctxt block pkh =
  RPC_context.make_call1 S.grace_period ctxt block pkh () ()

let requested_levels ~default ctxt cycles levels =
  match (levels, cycles) with
  | ([], []) -&gt;
      return [default]
  | (levels, cycles) -&gt;
      (* explicitly fail when requested levels or cycle are in the past...
         or too far in the future... *)
      let levels =
        List.sort_uniq
          Level.compare
          (List.concat
             ( List.map (Level.from_raw ctxt) levels
             :: List.map (Level.levels_in_cycle ctxt) cycles ))
      in
      map_s
        (fun level -&gt;
          let current_level = Level.current ctxt in
          if Level.(level &lt;= current_level) then return (level, None)
          else
            Baking.earlier_predecessor_timestamp ctxt level
            &gt;&gt;=? fun timestamp -&gt; return (level, Some timestamp))
        levels

module Baking_rights = struct
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    priority : int;
    timestamp : Timestamp.t option;
  }

  let encoding =
    let open Data_encoding in
    conv
      (fun {level; delegate; priority; timestamp} -&gt;
        (level, delegate, priority, timestamp))
      (fun (level, delegate, priority, timestamp) -&gt;
        {level; delegate; priority; timestamp})
      (obj4
         (req &quot;level&quot; Raw_level.encoding)
         (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
         (req &quot;priority&quot; uint16)
         (opt &quot;estimated_time&quot; Timestamp.encoding))

  module S = struct
    open Data_encoding

    let custom_root = RPC_path.(open_root / &quot;helpers&quot; / &quot;baking_rights&quot;)

    type baking_rights_query = {
      levels : Raw_level.t list;
      cycles : Cycle.t list;
      delegates : Signature.Public_key_hash.t list;
      max_priority : int option;
      all : bool;
    }

    let baking_rights_query =
      let open RPC_query in
      query (fun levels cycles delegates max_priority all -&gt;
          {levels; cycles; delegates; max_priority; all})
      |+ multi_field &quot;level&quot; Raw_level.rpc_arg (fun t -&gt; t.levels)
      |+ multi_field &quot;cycle&quot; Cycle.rpc_arg (fun t -&gt; t.cycles)
      |+ multi_field &quot;delegate&quot; Signature.Public_key_hash.rpc_arg (fun t -&gt;
             t.delegates)
      |+ opt_field &quot;max_priority&quot; RPC_arg.int (fun t -&gt; t.max_priority)
      |+ flag &quot;all&quot; (fun t -&gt; t.all)
      |&gt; seal

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">baking_rights</abbr> =
      RPC_service.get_service
        ~description:
          &quot;Retrieves the list of delegates allowed to bake a block.\n\
           By default, it gives the best baking priorities for bakers that \
           have at least one opportunity below the 64th priority for the next \
           block.\n\
           Parameters `level` and `cycle` can be used to specify the (valid) \
           level(s) in the past or future at which the baking rights have to \
           be returned. Parameter `delegate` can be used to restrict the \
           results to the given delegates. If parameter `all` is set, all the \
           baking opportunities for each baker at each level are returned, \
           instead of just the first one.\n\
           Returns the list of baking slots. Also returns the minimal \
           timestamps that correspond to these slots. The timestamps are \
           omitted for levels in the past, and are only estimates for levels \
           later that the next block, based on the hypothesis that all \
           predecessor blocks were baked at the first priority.&quot;
        ~query:baking_rights_query
        ~output:(list encoding)
        custom_root
  end

  let baking_priorities ctxt max_prio (level, pred_timestamp) =
    Baking.baking_priorities ctxt level
    &gt;&gt;=? fun contract_list -&gt;
    let rec loop l acc priority =
      if Compare.Int.(priority &gt;= max_prio) then return (List.rev acc)
      else
        let (Misc.LCons (pk, next)) = l in
        let delegate = Signature.Public_key.hash pk in
        ( match pred_timestamp with
        | None -&gt;
            return_none
        | Some pred_timestamp -&gt;
            Baking.minimal_time ctxt priority pred_timestamp
            &gt;&gt;=? fun t -&gt; return_some t )
        &gt;&gt;=? fun timestamp -&gt;
        let acc =
          {level = level.level; delegate; priority; timestamp} :: acc
        in
        next () &gt;&gt;=? fun l -&gt; loop l acc (priority + 1)
    in
    loop contract_list [] 0

  let remove_duplicated_delegates rights =
    List.rev @@ fst
    @@ List.fold_left
         (fun (acc, previous) r -&gt;
           if Signature.Public_key_hash.Set.mem r.delegate previous then
             (acc, previous)
           else
             (r :: acc, Signature.Public_key_hash.Set.add r.delegate previous))
         ([], Signature.Public_key_hash.Set.empty)
         rights

  let register () =
    let open Services_registration in
    register0 S.baking_rights (fun ctxt q () -&gt;
        requested_levels
          ~default:
            ( Level.succ ctxt (Level.current ctxt),
              Some (Timestamp.current ctxt) )
          ctxt
          q.cycles
          q.levels
        &gt;&gt;=? fun levels -&gt;
        let max_priority =
          match q.max_priority with None -&gt; 64 | Some max -&gt; max
        in
        map_s (baking_priorities ctxt max_priority) levels
        &gt;&gt;=? fun rights -&gt;
        let rights =
          if q.all then rights else List.map remove_duplicated_delegates rights
        in
        let rights = List.concat rights in
        match q.delegates with
        | [] -&gt;
            return rights
        | _ :: _ as delegates -&gt;
            let is_requested p =
              List.exists
                (Signature.Public_key_hash.equal p.delegate)
                delegates
            in
            return (List.filter is_requested rights))

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">get</abbr> ctxt ?(levels = []) ?(cycles = []) ?(delegates = []) ?(all = false)
      ?max_priority block =
    RPC_context.make_call0
      S.baking_rights
      ctxt
      block
      {levels; cycles; delegates; max_priority; all}
      ()
end

module Endorsing_rights = struct
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    slots : int list;
    estimated_time : Time.t option;
  }

  let encoding =
    let open Data_encoding in
    conv
      (fun {level; delegate; slots; estimated_time} -&gt;
        (level, delegate, slots, estimated_time))
      (fun (level, delegate, slots, estimated_time) -&gt;
        {level; delegate; slots; estimated_time})
      (obj4
         (req &quot;level&quot; Raw_level.encoding)
         (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
         (req &quot;slots&quot; (list uint16))
         (opt &quot;estimated_time&quot; Timestamp.encoding))

  module S = struct
    open Data_encoding

    let custom_root = RPC_path.(open_root / &quot;helpers&quot; / &quot;endorsing_rights&quot;)

    type endorsing_rights_query = {
      levels : Raw_level.t list;
      cycles : Cycle.t list;
      delegates : Signature.Public_key_hash.t list;
    }

    let endorsing_rights_query =
      let open RPC_query in
      query (fun levels cycles delegates -&gt; {levels; cycles; delegates})
      |+ multi_field &quot;level&quot; Raw_level.rpc_arg (fun t -&gt; t.levels)
      |+ multi_field &quot;cycle&quot; Cycle.rpc_arg (fun t -&gt; t.cycles)
      |+ multi_field &quot;delegate&quot; Signature.Public_key_hash.rpc_arg (fun t -&gt;
             t.delegates)
      |&gt; seal

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">endorsing_rights</abbr> =
      RPC_service.get_service
        ~description:
          &quot;Retrieves the delegates allowed to endorse a block.\n\
           By default, it gives the endorsement slots for delegates that have \
           at least one in the next block.\n\
           Parameters `level` and `cycle` can be used to specify the (valid) \
           level(s) in the past or future at which the endorsement rights \
           have to be returned. Parameter `delegate` can be used to restrict \
           the results to the given delegates.\n\
           Returns the list of endorsement slots. Also returns the minimal \
           timestamps that correspond to these slots. The timestamps are \
           omitted for levels in the past, and are only estimates for levels \
           later that the next block, based on the hypothesis that all \
           predecessor blocks were baked at the first priority.&quot;
        ~query:endorsing_rights_query
        ~output:(list encoding)
        custom_root
  end

  let endorsement_slots ctxt (level, estimated_time) =
    Baking.endorsement_rights ctxt level
    &gt;&gt;=? fun rights -&gt;
    return
      (Signature.Public_key_hash.Map.fold
         (fun delegate (_, slots, _) acc -&gt;
           {level = level.level; delegate; slots; estimated_time} :: acc)
         rights
         [])

  let register () =
    let open Services_registration in
    register0 S.endorsing_rights (fun ctxt q () -&gt;
        requested_levels
          ~default:(Level.current ctxt, Some (Timestamp.current ctxt))
          ctxt
          q.cycles
          q.levels
        &gt;&gt;=? fun levels -&gt;
        map_s (endorsement_slots ctxt) levels
        &gt;&gt;=? fun rights -&gt;
        let rights = List.concat rights in
        match q.delegates with
        | [] -&gt;
            return rights
        | _ :: _ as delegates -&gt;
            let is_requested p =
              List.exists
                (Signature.Public_key_hash.equal p.delegate)
                delegates
            in
            return (List.filter is_requested rights))

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">get</abbr> ctxt ?(levels = []) ?(cycles = []) ?(delegates = []) block =
    RPC_context.make_call0
      S.endorsing_rights
      ctxt
      block
      {levels; cycles; delegates}
      ()
end

module Endorsing_power = struct
  let endorsing_power ctxt (operation, chain_id) =
    let (Operation_data data) = operation.protocol_data in
    match data.contents with
    | Single (Endorsement _) -&gt;
        Baking.check_endorsement_rights
          ctxt
          chain_id
          {shell = operation.shell; protocol_data = data}
        &gt;&gt;=? fun (_, slots, _) -&gt; return (List.length slots)
    | _ -&gt;
        failwith &quot;Operation is not an endorsement&quot;

  module S = struct
    let <abbr class="mark-error" title="Polymorphic variant types are not handled">endorsing_power</abbr> =
      let open Data_encoding in
      RPC_service.post_service
        ~description:
          &quot;Get the endorsing power of an endorsement, that is, the number of \
           slots that the endorser has&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;endorsement_operation&quot; Operation.encoding)
             (req &quot;chain_id&quot; Chain_id.encoding))
        ~output:int31
        RPC_path.(open_root / &quot;endorsing_power&quot;)
  end

  let register () =
    let open Services_registration in
    register0 S.endorsing_power (fun ctxt () (op, chain_id) -&gt;
        endorsing_power ctxt (op, chain_id))

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">get</abbr> ctxt block op chain_id =
    RPC_context.make_call0 S.endorsing_power ctxt block () (op, chain_id)
end

module Required_endorsements = struct
  let required_endorsements ctxt block_delay =
    return (Baking.minimum_allowed_endorsements ctxt ~block_delay)

  module S = struct
    type t = {block_delay : Period.t}

    let required_endorsements_query =
      let open RPC_query in
      query (fun block_delay -&gt; {block_delay})
      |+ field &quot;block_delay&quot; Period.rpc_arg Period.zero (fun t -&gt;
             t.block_delay)
      |&gt; seal

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">required_endorsements</abbr> =
      let open Data_encoding in
      RPC_service.get_service
        ~description:
          &quot;Minimum number of endorsements for a block to be valid, given a \
           delay of the block's timestamp with respect to the minimum time to \
           bake at the block's priority&quot;
        ~query:required_endorsements_query
        ~output:int31
        RPC_path.(open_root / &quot;required_endorsements&quot;)
  end

  let register () =
    let open Services_registration in
    register0 S.required_endorsements (fun ctxt {block_delay} () -&gt;
        required_endorsements ctxt block_delay)

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">get</abbr> ctxt block block_delay =
    RPC_context.make_call0 S.required_endorsements ctxt block {block_delay} ()
end

module Minimal_valid_time = struct
  let minimal_valid_time ctxt ~priority ~endorsing_power =
    Baking.minimal_valid_time ctxt ~priority ~endorsing_power

  module S = struct
    type t = {priority : int; endorsing_power : int}

    let minimal_valid_time_query =
      let open RPC_query in
      query (fun priority endorsing_power -&gt; {priority; endorsing_power})
      |+ field &quot;priority&quot; RPC_arg.int 0 (fun t -&gt; t.priority)
      |+ field &quot;endorsing_power&quot; RPC_arg.int 0 (fun t -&gt; t.endorsing_power)
      |&gt; seal

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">minimal_valid_time</abbr> =
      RPC_service.get_service
        ~description:
          &quot;Minimal valid time for a block given a priority and an endorsing \
           power.&quot;
        ~query:minimal_valid_time_query
        ~output:Time.encoding
        RPC_path.(open_root / &quot;minimal_valid_time&quot;)
  end

  let register () =
    let open Services_registration in
    register0 S.minimal_valid_time (fun ctxt {priority; endorsing_power} () -&gt;
        minimal_valid_time ctxt ~priority ~endorsing_power)

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">get</abbr> ctxt block priority endorsing_power =
    RPC_context.make_call0
      S.minimal_valid_time
      ctxt
      block
      {priority; endorsing_power}
      ()
end

let register () =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Baking_rights.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Endorsing_rights.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Endorsing_power.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Required_endorsements.register () ;
  Minimal_valid_time.register ()</abbr>

let endorsement_rights ctxt level =
  Endorsing_rights.endorsement_slots ctxt (level, None)
  &gt;&gt;=? fun l -&gt;
  return (List.map (fun {Endorsing_rights.delegate; _} -&gt; delegate) l)

let baking_rights ctxt max_priority =
  let max = match max_priority with None -&gt; 64 | Some m -&gt; m in
  let level = Level.current ctxt in
  Baking_rights.baking_priorities ctxt max (level, None)
  &gt;&gt;=? fun l -&gt;
  return
    ( level.level,
      List.map
        (fun {Baking_rights.delegate; timestamp; _} -&gt; (delegate, timestamp))
        l )

let endorsing_power ctxt operation =
  Endorsing_power.endorsing_power ctxt operation

let required_endorsements ctxt delay =
  Required_endorsements.required_endorsements ctxt delay

let minimal_valid_time ctxt priority endorsing_power =
  Minimal_valid_time.minimal_valid_time ctxt priority endorsing_power
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_services.ml"><code>Delegate_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Baking.
Require Tezos.Contract_repr.
Require Tezos.Misc.
Require Tezos.Services_registration.

Import Alpha_context.

Module info.
  Record record := {
    balance : Alpha_context.Tez.t;
    frozen_balance : Alpha_context.Tez.t;
    frozen_balance_by_cycle :
      Alpha_context.Cycle.Map.[S.MAP.t] Alpha_context.Delegate.frozen_balance;
    staking_balance : Alpha_context.Tez.t;
    delegated_contracts : list Contract_repr.t;
    delegated_balance : Alpha_context.Tez.t;
    deactivated : bool;
    grace_period : Alpha_context.Cycle.t }.
End info.
Definition info := info.record.

Definition info_encoding : Data_encoding.encoding info :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        info.balance := balance;
          info.frozen_balance := frozen_balance;
          info.frozen_balance_by_cycle := frozen_balance_by_cycle;
          info.staking_balance := staking_balance;
          info.delegated_contracts := delegated_contracts;
          info.delegated_balance := delegated_balance;
          info.deactivated := deactivated;
          info.grace_period := grace_period
          |} := function_parameter in
      (balance, frozen_balance, frozen_balance_by_cycle, staking_balance,
        delegated_contracts, delegated_balance, deactivated, grace_period))
    (fun function_parameter =&gt;
      let
        '(balance, frozen_balance, frozen_balance_by_cycle, staking_balance,
          delegated_contracts, delegated_balance, deactivated, grace_period) :=
        function_parameter in
      {| info.balance := balance; info.frozen_balance := frozen_balance;
        info.frozen_balance_by_cycle := frozen_balance_by_cycle;
        info.staking_balance := staking_balance;
        info.delegated_contracts := delegated_contracts;
        info.delegated_balance := delegated_balance;
        info.deactivated := deactivated; info.grace_period := grace_period |})
    None
    (Data_encoding.obj8
      (Data_encoding.req None None &quot;balance&quot; % string Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;frozen_balance&quot; % string
        Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;frozen_balance_by_cycle&quot; % string
        Alpha_context.Delegate.frozen_balance_by_cycle_encoding)
      (Data_encoding.req None None &quot;staking_balance&quot; % string
        Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;delegated_contracts&quot; % string
        (Data_encoding.__list_value None Contract_repr.encoding))
      (Data_encoding.req None None &quot;delegated_balance&quot; % string
        Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;deactivated&quot; % string
        Data_encoding.__bool_value)
      (Data_encoding.req None None &quot;grace_period&quot; % string
        Alpha_context.Cycle.encoding)).

Module S.
  Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
    RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot; % string)
      &quot;delegates&quot; % string.
  
  Import Data_encoding.
  
  Module list_query.
    Record record := {
      active : bool;
      inactive : bool }.
  End list_query.
  Definition list_query := list_query.record.
  
  Definition list_query : RPC_query.t list_query :=
    Pervasives.op_pipegt
      (RPC_query.op_pipeplus
        (RPC_query.op_pipeplus
          (RPC_query.__query_value
            (fun active =&gt;
              fun inactive =&gt;
                {| list_query.active := active; list_query.inactive := inactive
                  |}))
          (RPC_query.flag None &quot;active&quot; % string (fun t =&gt; list_query.active t)))
        (RPC_query.flag None &quot;inactive&quot; % string
          (fun t =&gt; list_query.inactive t))) RPC_query.seal.
  
  Definition list_delegate
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context list_query unit
      (list Signature.Public_key_hash.[S.SPublic_key_hash.t]) :=
    RPC_service.get_service (Some &quot;Lists all registered delegates.&quot; % string)
      list_query
      (Data_encoding.__list_value None
        Signature.Public_key_hash.[S.SPublic_key_hash.encoding]) path.
  
  Definition path
    : RPC_path.path Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t]) :=
    RPC_path.op_divcolon path
      Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg].
  
  Definition info
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit info :=
    RPC_service.get_service (Some &quot;Everything about a delegate.&quot; % string)
      RPC_query.empty info_encoding path.
  
  Definition balance
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the full balance of a given delegate, including the frozen balances.&quot;
          % string) RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;balance&quot; % string).
  
  Definition frozen_balance
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the total frozen balances of a given delegate, this includes the frozen deposits, rewards and fees.&quot;
          % string) RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;frozen_balance&quot; % string).
  
  Definition frozen_balance_by_cycle
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit
      (Alpha_context.Cycle.Map.[S.MAP.t] Alpha_context.Delegate.frozen_balance) :=
    RPC_service.get_service
      (Some
        &quot;Returns the frozen balances of a given delegate, indexed by the cycle by which it will be unfrozen&quot;
          % string) RPC_query.empty
      Alpha_context.Delegate.frozen_balance_by_cycle_encoding
      (RPC_path.op_div path &quot;frozen_balance_by_cycle&quot; % string).
  
  Definition staking_balance
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the total amount of tokens delegated to a given delegate. This includes the balances of all the contracts that delegate to it, but also the balance of the delegate itself and its frozen fees and deposits. The rewards do not count in the delegated balance until they are unfrozen.&quot;
          % string) RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;staking_balance&quot; % string).
  
  Definition delegated_contracts
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit (list Contract_repr.contract) :=
    RPC_service.get_service
      (Some
        &quot;Returns the list of contracts that delegate to a given delegate.&quot; %
          string) RPC_query.empty
      (Data_encoding.__list_value None Contract_repr.encoding)
      (RPC_path.op_div path &quot;delegated_contracts&quot; % string).
  
  Definition delegated_balance
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the balances of all the contracts that delegate to a given delegate. This excludes the delegate's own balance and its frozen balances.&quot;
          % string) RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;delegated_balance&quot; % string).
  
  Definition deactivated
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit bool :=
    RPC_service.get_service
      (Some
        &quot;Tells whether the delegate is currently tagged as deactivated or not.&quot;
          % string) RPC_query.empty Data_encoding.__bool_value
      (RPC_path.op_div path &quot;deactivated&quot; % string).
  
  Definition grace_period
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      (Updater.rpc_context * Signature.Public_key_hash.[S.SPublic_key_hash.t])
      unit unit Alpha_context.Cycle.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the cycle by the end of which the delegate might be deactivated if she fails to execute any delegate action. A deactivated delegate might be reactivated (without loosing any rolls) by simply re-registering as a delegate. For deactivated delegates, this value contains the cycle by which they were deactivated.&quot;
          % string) RPC_query.empty Alpha_context.Cycle.encoding
      (RPC_path.op_div path &quot;grace_period&quot; % string).
End S.

Definition register (function_parameter : unit) : unit :=
  let 'tt := function_parameter in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register1 S.grace_period
    (fun ctxt =&gt;
      fun pkh =&gt;
        fun function_parameter =&gt;
          let 'tt := function_parameter in
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            Alpha_context.Delegate.grace_period ctxt pkh).

Definition __list_value {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (op_staroptstar : option bool)
  : option bool -&gt; unit -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list Signature.Public_key_hash.[S.SPublic_key_hash.t])) :=
  let active :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; true
    end in
  fun op_staroptstar =&gt;
    let inactive :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; false
      end in
    fun function_parameter =&gt;
      let 'tt := function_parameter in
      RPC_context.make_call0 S.list_delegate ctxt block
        {| S.list_query.active := active; S.list_query.inactive := inactive |}
        tt.

Definition info {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult info) :=
  RPC_context.make_call1 S.info ctxt block pkh tt tt.

Definition balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.balance ctxt block pkh tt tt.

Definition frozen_balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.frozen_balance ctxt block pkh tt tt.

Definition frozen_balance_by_cycle {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t
    (Error_monad.shell_tzresult
      (Alpha_context.Cycle.Map.[S.MAP.t] Alpha_context.Delegate.frozen_balance)) :=
  RPC_context.make_call1 S.frozen_balance_by_cycle ctxt block pkh tt tt.

Definition staking_balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.staking_balance ctxt block pkh tt tt.

Definition delegated_contracts {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult (list Contract_repr.contract)) :=
  RPC_context.make_call1 S.delegated_contracts ctxt block pkh tt tt.

Definition delegated_balance {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.delegated_balance ctxt block pkh tt tt.

Definition deactivated {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult bool) :=
  RPC_context.make_call1 S.deactivated ctxt block pkh tt tt.

Definition grace_period {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  (pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Cycle.t) :=
  RPC_context.make_call1 S.grace_period ctxt block pkh tt tt.

Definition requested_levels
  (default : Alpha_context.Level.t * option Alpha_context.Timestamp.t)
  (ctxt : Alpha_context.context) (cycles : list Alpha_context.Cycle.t)
  (levels : list Alpha_context.Raw_level.t)
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Level.t * option Alpha_context.Timestamp.t))) :=
  match (levels, cycles) with
  | ([], []) =&gt; Error_monad.__return (cons default [])
  | (levels, cycles) =&gt;
    let levels :=
      List.sort_uniq Alpha_context.Level.compare
        (List.concat
          (cons
            (List.map
              (let arg := Alpha_context.Level.from_raw ctxt in
              fun eta =&gt; arg None eta) levels)
            (List.map (Alpha_context.Level.levels_in_cycle ctxt) cycles))) in
    Error_monad.map_s
      (fun level =&gt;
        let current_level := Alpha_context.Level.current ctxt in
        if Alpha_context.Level.op_lteq level current_level then
          Error_monad.__return (level, None)
        else
          Error_monad.op_gtgteqquestion
            (Baking.earlier_predecessor_timestamp ctxt level)
            (fun timestamp =&gt; Error_monad.__return (level, (Some timestamp))))
      levels
  end.

Module Baking_rights.
  Module t.
    Record record := {
      level : Alpha_context.Raw_level.t;
      delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
      priority : Z;
      timestamp : option Alpha_context.Timestamp.t }.
  End t.
  Definition t := t.record.
  
  Definition encoding : Data_encoding.encoding t :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          t.level := level;
            t.delegate := delegate;
            t.priority := priority;
            t.timestamp := timestamp
            |} := function_parameter in
        (level, delegate, priority, timestamp))
      (fun function_parameter =&gt;
        let '(level, delegate, priority, timestamp) := function_parameter in
        {| t.level := level; t.delegate := delegate; t.priority := priority;
          t.timestamp := timestamp |}) None
      (Data_encoding.obj4
        (Data_encoding.req None None &quot;level&quot; % string
          Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None &quot;delegate&quot; % string
          Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
        (Data_encoding.req None None &quot;priority&quot; % string Data_encoding.uint16)
        (Data_encoding.opt None None &quot;estimated_time&quot; % string
          Alpha_context.Timestamp.encoding)).
  
  Module S.
    Import Data_encoding.
    
    Definition custom_root
      : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;helpers&quot; % string)
        &quot;baking_rights&quot; % string.
    
    Module baking_rights_query.
      Record record := {
        levels : list Alpha_context.Raw_level.t;
        cycles : list Alpha_context.Cycle.t;
        delegates : list Signature.Public_key_hash.[S.SPublic_key_hash.t];
        max_priority : option Z;
        all : bool }.
    End baking_rights_query.
    Definition baking_rights_query := baking_rights_query.record.
    
    Definition baking_rights_query : RPC_query.t baking_rights_query :=
      Pervasives.op_pipegt
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.op_pipeplus
              (RPC_query.op_pipeplus
                (RPC_query.op_pipeplus
                  (RPC_query.__query_value
                    (fun levels =&gt;
                      fun cycles =&gt;
                        fun delegates =&gt;
                          fun max_priority =&gt;
                            fun all =&gt;
                              {| baking_rights_query.levels := levels;
                                baking_rights_query.cycles := cycles;
                                baking_rights_query.delegates := delegates;
                                baking_rights_query.max_priority := max_priority;
                                baking_rights_query.all := all |}))
                  (RPC_query.multi_field None &quot;level&quot; % string
                    Alpha_context.Raw_level.rpc_arg
                    (fun t =&gt; baking_rights_query.levels t)))
                (RPC_query.multi_field None &quot;cycle&quot; % string
                  Alpha_context.Cycle.rpc_arg
                  (fun t =&gt; baking_rights_query.cycles t)))
              (RPC_query.multi_field None &quot;delegate&quot; % string
                Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg]
                (fun t =&gt; baking_rights_query.delegates t)))
            (RPC_query.opt_field None &quot;max_priority&quot; % string RPC_arg.int
              (fun t =&gt; baking_rights_query.max_priority t)))
          (RPC_query.flag None &quot;all&quot; % string
            (fun t =&gt; baking_rights_query.all t))) RPC_query.seal.
    
    Definition baking_rights
      : RPC_service.service (* `GET *) unit Updater.rpc_context
        Updater.rpc_context baking_rights_query unit (list t) :=
      RPC_service.get_service
        (Some
          &quot;Retrieves the list of delegates allowed to bake a block.\nBy default, it gives the best baking priorities for bakers that have at least one opportunity below the 64th priority for the next block.\nParameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the baking rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates. If parameter `all` is set, all the baking opportunities for each baker at each level are returned, instead of just the first one.\nReturns the list of baking slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.&quot;
            % string) baking_rights_query
        (Data_encoding.__list_value None encoding) custom_root.
  End S.
  
  Definition baking_priorities
    (ctxt : Alpha_context.context) (max_prio : Compare.Int.[Compare.S.t])
    (function_parameter : Alpha_context.Level.t * option Time.t)
    : Lwt.t (Error_monad.tzresult (list t)) :=
    let '(level, pred_timestamp) := function_parameter in
    Error_monad.op_gtgteqquestion (Baking.baking_priorities ctxt level)
      (fun contract_list =&gt;
        let fix loop
          (l : Misc.lazy_list_t Signature.Public_key.[S.SPublic_key.t])
          (acc : list t) (priority : Compare.Int.[Compare.S.t]) {struct l}
          : Lwt.t (Error_monad.tzresult (list t)) :=
          if Compare.Int.[Compare.S.op_gteq] priority max_prio then
            Error_monad.__return (List.rev acc)
          else
            let 'Misc.LCons pk next := l in
            let delegate := Signature.Public_key.[S.SPublic_key.__hash_value] pk
              in
            Error_monad.op_gtgteqquestion
              match pred_timestamp with
              | None =&gt; Error_monad.return_none
              | Some pred_timestamp =&gt;
                Error_monad.op_gtgteqquestion
                  (Baking.minimal_time ctxt priority pred_timestamp)
                  (fun t =&gt; Error_monad.return_some t)
              end
              (fun timestamp =&gt;
                let acc :=
                  cons
                    {| t.level := Alpha_context.Level.t.level level;
                      t.delegate := delegate; t.priority := priority;
                      t.timestamp := timestamp |} acc in
                Error_monad.op_gtgteqquestion (next tt)
                  (fun l =&gt; loop l acc (Pervasives.op_plus priority 1))) in
        loop contract_list [] 0).
  
  Definition remove_duplicated_delegates (rights : list t) : list t :=
    Pervasives.op_atat List.rev
      (Pervasives.op_atat Pervasives.fst
        (List.fold_left
          (fun function_parameter =&gt;
            let '(acc, previous) := function_parameter in
            fun r =&gt;
              if
                Signature.Public_key_hash.[S.SPublic_key_hash.__Set].(S.INDEXES_Set.mem)
                  (t.delegate r) previous then
                (acc, previous)
              else
                ((cons r acc),
                  (Signature.Public_key_hash.[S.SPublic_key_hash.__Set].(S.INDEXES_Set.add)
                    (t.delegate r) previous)))
          ([],
            Signature.Public_key_hash.[S.SPublic_key_hash.__Set].(S.INDEXES_Set.empty))
          rights)).
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    Services_registration.register0 S.baking_rights
      (fun ctxt =&gt;
        fun q =&gt;
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (requested_levels
                ((Alpha_context.Level.succ ctxt
                  (Alpha_context.Level.current ctxt)),
                  (Some (Alpha_context.Timestamp.current ctxt))) ctxt
                (S.baking_rights_query.cycles q)
                (S.baking_rights_query.levels q))
              (fun levels =&gt;
                let max_priority :=
                  match S.baking_rights_query.max_priority q with
                  | None =&gt; 64
                  | Some max =&gt; max
                  end in
                Error_monad.op_gtgteqquestion
                  (Error_monad.map_s (baking_priorities ctxt max_priority)
                    levels)
                  (fun rights =&gt;
                    let rights :=
                      if S.baking_rights_query.all q then
                        rights
                      else
                        List.map remove_duplicated_delegates rights in
                    let rights := List.concat rights in
                    match S.baking_rights_query.delegates q with
                    | [] =&gt; Error_monad.__return rights
                    | (cons _ _) as delegates =&gt;
                      let is_requested (p : t) : bool :=
                        List.__exists
                          (Signature.Public_key_hash.[S.SPublic_key_hash.equal]
                            (t.delegate p)) delegates in
                      Error_monad.__return (List.filter is_requested rights)
                    end))).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D)
    (op_staroptstar : option (list Alpha_context.Raw_level.t))
    : option (list Alpha_context.Cycle.t) -&gt;
    option (list Signature.Public_key_hash.[S.SPublic_key_hash.t]) -&gt;
    option bool -&gt; option Z -&gt; D -&gt; Lwt.t (Error_monad.shell_tzresult (list t)) :=
    let levels :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; []
      end in
    fun op_staroptstar =&gt;
      let cycles :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; []
        end in
      fun op_staroptstar =&gt;
        let delegates :=
          match op_staroptstar with
          | Some op_starsthstar =&gt; op_starsthstar
          | None =&gt; []
          end in
        fun op_staroptstar =&gt;
          let all :=
            match op_staroptstar with
            | Some op_starsthstar =&gt; op_starsthstar
            | None =&gt; false
            end in
          fun max_priority =&gt;
            fun block =&gt;
              RPC_context.make_call0 S.baking_rights ctxt block
                {| S.baking_rights_query.levels := levels;
                  S.baking_rights_query.cycles := cycles;
                  S.baking_rights_query.delegates := delegates;
                  S.baking_rights_query.max_priority := max_priority;
                  S.baking_rights_query.all := all |} tt.
End Baking_rights.

Module Endorsing_rights.
  Module t.
    Record record := {
      level : Alpha_context.Raw_level.t;
      delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
      slots : list Z;
      estimated_time : option Time.t }.
  End t.
  Definition t := t.record.
  
  Definition encoding : Data_encoding.encoding t :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          t.level := level;
            t.delegate := delegate;
            t.slots := slots;
            t.estimated_time := estimated_time
            |} := function_parameter in
        (level, delegate, slots, estimated_time))
      (fun function_parameter =&gt;
        let '(level, delegate, slots, estimated_time) := function_parameter in
        {| t.level := level; t.delegate := delegate; t.slots := slots;
          t.estimated_time := estimated_time |}) None
      (Data_encoding.obj4
        (Data_encoding.req None None &quot;level&quot; % string
          Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None &quot;delegate&quot; % string
          Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
        (Data_encoding.req None None &quot;slots&quot; % string
          (Data_encoding.__list_value None Data_encoding.uint16))
        (Data_encoding.opt None None &quot;estimated_time&quot; % string
          Alpha_context.Timestamp.encoding)).
  
  Module S.
    Import Data_encoding.
    
    Definition custom_root
      : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;helpers&quot; % string)
        &quot;endorsing_rights&quot; % string.
    
    Module endorsing_rights_query.
      Record record := {
        levels : list Alpha_context.Raw_level.t;
        cycles : list Alpha_context.Cycle.t;
        delegates : list Signature.Public_key_hash.[S.SPublic_key_hash.t] }.
    End endorsing_rights_query.
    Definition endorsing_rights_query := endorsing_rights_query.record.
    
    Definition endorsing_rights_query : RPC_query.t endorsing_rights_query :=
      Pervasives.op_pipegt
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.op_pipeplus
              (RPC_query.__query_value
                (fun levels =&gt;
                  fun cycles =&gt;
                    fun delegates =&gt;
                      {| endorsing_rights_query.levels := levels;
                        endorsing_rights_query.cycles := cycles;
                        endorsing_rights_query.delegates := delegates |}))
              (RPC_query.multi_field None &quot;level&quot; % string
                Alpha_context.Raw_level.rpc_arg
                (fun t =&gt; endorsing_rights_query.levels t)))
            (RPC_query.multi_field None &quot;cycle&quot; % string
              Alpha_context.Cycle.rpc_arg
              (fun t =&gt; endorsing_rights_query.cycles t)))
          (RPC_query.multi_field None &quot;delegate&quot; % string
            Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg]
            (fun t =&gt; endorsing_rights_query.delegates t))) RPC_query.seal.
    
    Definition endorsing_rights
      : RPC_service.service (* `GET *) unit Updater.rpc_context
        Updater.rpc_context endorsing_rights_query unit (list t) :=
      RPC_service.get_service
        (Some
          &quot;Retrieves the delegates allowed to endorse a block.\nBy default, it gives the endorsement slots for delegates that have at least one in the next block.\nParameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the endorsement rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates.\nReturns the list of endorsement slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.&quot;
            % string) endorsing_rights_query
        (Data_encoding.__list_value None encoding) custom_root.
  End S.
  
  Definition endorsement_slots
    (ctxt : Alpha_context.context)
    (function_parameter : Alpha_context.Level.t * option Time.t)
    : Lwt.t (Error_monad.tzresult (list t)) :=
    let '(level, estimated_time) := function_parameter in
    Error_monad.op_gtgteqquestion (Baking.endorsement_rights ctxt level)
      (fun rights =&gt;
        Error_monad.__return
          (Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.fold)
            (fun delegate =&gt;
              fun function_parameter =&gt;
                let '(_, slots, _) := function_parameter in
                fun acc =&gt;
                  cons
                    {| t.level := Alpha_context.Level.t.level level;
                      t.delegate := delegate; t.slots := slots;
                      t.estimated_time := estimated_time |} acc) rights [])).
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    Services_registration.register0 S.endorsing_rights
      (fun ctxt =&gt;
        fun q =&gt;
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (requested_levels
                ((Alpha_context.Level.current ctxt),
                  (Some (Alpha_context.Timestamp.current ctxt))) ctxt
                (S.endorsing_rights_query.cycles q)
                (S.endorsing_rights_query.levels q))
              (fun levels =&gt;
                Error_monad.op_gtgteqquestion
                  (Error_monad.map_s (endorsement_slots ctxt) levels)
                  (fun rights =&gt;
                    let rights := List.concat rights in
                    match S.endorsing_rights_query.delegates q with
                    | [] =&gt; Error_monad.__return rights
                    | (cons _ _) as delegates =&gt;
                      let is_requested (p : t) : bool :=
                        List.__exists
                          (Signature.Public_key_hash.[S.SPublic_key_hash.equal]
                            (t.delegate p)) delegates in
                      Error_monad.__return (List.filter is_requested rights)
                    end))).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D)
    (op_staroptstar : option (list Alpha_context.Raw_level.t))
    : option (list Alpha_context.Cycle.t) -&gt;
    option (list Signature.Public_key_hash.[S.SPublic_key_hash.t]) -&gt; D -&gt;
    Lwt.t (Error_monad.shell_tzresult (list t)) :=
    let levels :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; []
      end in
    fun op_staroptstar =&gt;
      let cycles :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; []
        end in
      fun op_staroptstar =&gt;
        let delegates :=
          match op_staroptstar with
          | Some op_starsthstar =&gt; op_starsthstar
          | None =&gt; []
          end in
        fun block =&gt;
          RPC_context.make_call0 S.endorsing_rights ctxt block
            {| S.endorsing_rights_query.levels := levels;
              S.endorsing_rights_query.cycles := cycles;
              S.endorsing_rights_query.delegates := delegates |} tt.
End Endorsing_rights.

Module Endorsing_power.
  Definition endorsing_power
    (ctxt : Alpha_context.context)
    (function_parameter : Alpha_context.packed_operation * Chain_id.[S.HASH.t])
    : Lwt.t (Error_monad.tzresult Z) :=
    let '(operation, chain_id) := function_parameter in
    let 'Alpha_context.Operation_data data :=
      Alpha_context.packed_operation.protocol_data operation in
    match Alpha_context.protocol_data.contents data with
    | Alpha_context.Single (Alpha_context.Endorsement _) =&gt;
      Error_monad.op_gtgteqquestion
        (Baking.check_endorsement_rights ctxt chain_id
          {|
            Alpha_context.operation.shell :=
              Alpha_context.packed_operation.shell operation;
            Alpha_context.operation.protocol_data := data |})
        (fun function_parameter =&gt;
          let '(_, slots, _) := function_parameter in
          Error_monad.__return (List.length slots))
    | _ =&gt; Pervasives.failwith &quot;Operation is not an endorsement&quot; % string
    end.
  
  Module S.
    Definition endorsing_power
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (Alpha_context.Operation.packed * Chain_id.[S.HASH.t]) Z :=
      RPC_service.post_service
        (Some
          &quot;Get the endorsing power of an endorsement, that is, the number of slots that the endorser has&quot;
            % string) RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;endorsement_operation&quot; % string
            Alpha_context.Operation.encoding)
          (Data_encoding.req None None &quot;chain_id&quot; % string
            Chain_id.[S.HASH.encoding])) Data_encoding.int31
        (RPC_path.op_div RPC_path.open_root &quot;endorsing_power&quot; % string).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    Services_registration.register0 S.endorsing_power
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let 'tt := function_parameter in
          fun function_parameter =&gt;
            let '(op, chain_id) := function_parameter in
            endorsing_power ctxt (op, chain_id)).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (op : Alpha_context.Operation.packed) (chain_id : Chain_id.[S.HASH.t])
    : Lwt.t (Error_monad.shell_tzresult Z) :=
    RPC_context.make_call0 S.endorsing_power ctxt block tt (op, chain_id).
End Endorsing_power.

Module Required_endorsements.
  Definition required_endorsements
    (ctxt : Alpha_context.context) (block_delay : Alpha_context.Period.t)
    : Lwt.t (Error_monad.tzresult Z) :=
    Error_monad.__return (Baking.minimum_allowed_endorsements ctxt block_delay).
  
  Module S.
    Module t.
      Record record := {
        block_delay : Alpha_context.Period.t }.
    End t.
    Definition t := t.record.
    
    Definition required_endorsements_query : RPC_query.t t :=
      Pervasives.op_pipegt
        (RPC_query.op_pipeplus
          (RPC_query.__query_value
            (fun block_delay =&gt; {| t.block_delay := block_delay |}))
          (RPC_query.__field_value None &quot;block_delay&quot; % string
            Alpha_context.Period.rpc_arg Alpha_context.Period.zero
            (fun t =&gt; t.block_delay t))) RPC_query.seal.
    
    Definition required_endorsements
      : RPC_service.service (* `GET *) unit Updater.rpc_context
        Updater.rpc_context t unit Z :=
      RPC_service.get_service
        (Some
          &quot;Minimum number of endorsements for a block to be valid, given a delay of the block's timestamp with respect to the minimum time to bake at the block's priority&quot;
            % string) required_endorsements_query Data_encoding.int31
        (RPC_path.op_div RPC_path.open_root &quot;required_endorsements&quot; % string).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    Services_registration.register0 S.required_endorsements
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let '{| S.t.block_delay := block_delay |} := function_parameter in
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            required_endorsements ctxt block_delay).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (block_delay : Alpha_context.Period.t)
    : Lwt.t (Error_monad.shell_tzresult Z) :=
    RPC_context.make_call0 S.required_endorsements ctxt block
      {| S.t.block_delay := block_delay |} tt.
End Required_endorsements.

Module Minimal_valid_time.
  Definition minimal_valid_time
    (ctxt : Alpha_context.context) (priority : Z) (endorsing_power : Z)
    : Lwt.t (Error_monad.tzresult Time.t) :=
    Baking.minimal_valid_time ctxt priority endorsing_power.
  
  Module S.
    Module t.
      Record record := {
        priority : Z;
        endorsing_power : Z }.
    End t.
    Definition t := t.record.
    
    Definition minimal_valid_time_query : RPC_query.t t :=
      Pervasives.op_pipegt
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.__query_value
              (fun priority =&gt;
                fun endorsing_power =&gt;
                  {| t.priority := priority;
                    t.endorsing_power := endorsing_power |}))
            (RPC_query.__field_value None &quot;priority&quot; % string RPC_arg.int 0
              (fun t =&gt; t.priority t)))
          (RPC_query.__field_value None &quot;endorsing_power&quot; % string RPC_arg.int 0
            (fun t =&gt; t.endorsing_power t))) RPC_query.seal.
    
    Definition minimal_valid_time
      : RPC_service.service (* `GET *) unit Updater.rpc_context
        Updater.rpc_context t unit Time.t :=
      RPC_service.get_service
        (Some
          &quot;Minimal valid time for a block given a priority and an endorsing power.&quot;
            % string) minimal_valid_time_query Time.encoding
        (RPC_path.op_div RPC_path.open_root &quot;minimal_valid_time&quot; % string).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    Services_registration.register0 S.minimal_valid_time
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let '{|
            S.t.priority := priority;
              S.t.endorsing_power := endorsing_power
              |} := function_parameter in
          fun function_parameter =&gt;
            let 'tt := function_parameter in
            minimal_valid_time ctxt priority endorsing_power).
  
  Definition get {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (priority : Z) (endorsing_power : Z)
    : Lwt.t (Error_monad.shell_tzresult Time.t) :=
    RPC_context.make_call0 S.minimal_valid_time ctxt block
      {| S.t.priority := priority; S.t.endorsing_power := endorsing_power |} tt.
End Minimal_valid_time.

Definition register (function_parameter : unit) : unit :=
  let 'tt := function_parameter in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Minimal_valid_time.register tt.

Definition endorsement_rights
  (ctxt : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t
    (Error_monad.tzresult
      (list Signature.Public_key_hash.[S.SPublic_key_hash.t])) :=
  Error_monad.op_gtgteqquestion
    (Endorsing_rights.endorsement_slots ctxt (level, None))
    (fun l =&gt;
      Error_monad.__return
        (List.map
          (fun function_parameter =&gt;
            let '{| Endorsing_rights.t.delegate := delegate |} :=
              function_parameter in
            delegate) l)).

Definition baking_rights
  (ctxt : Alpha_context.context)
  (max_priority : option Compare.Int.[Compare.S.t])
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.Raw_level.t *
        list
          (Signature.Public_key_hash.[S.SPublic_key_hash.t] *
            option Alpha_context.Timestamp.t))) :=
  let max :=
    match max_priority with
    | None =&gt; 64
    | Some m =&gt; m
    end in
  let level := Alpha_context.Level.current ctxt in
  Error_monad.op_gtgteqquestion
    (Baking_rights.baking_priorities ctxt max (level, None))
    (fun l =&gt;
      Error_monad.__return
        ((Alpha_context.Level.t.level level),
          (List.map
            (fun function_parameter =&gt;
              let '{|
                Baking_rights.t.delegate := delegate;
                  Baking_rights.t.timestamp := timestamp
                  |} := function_parameter in
              (delegate, timestamp)) l))).

Definition endorsing_power
  (ctxt : Alpha_context.context)
  (operation : Alpha_context.packed_operation * Chain_id.[S.HASH.t])
  : Lwt.t (Error_monad.tzresult Z) :=
  Endorsing_power.endorsing_power ctxt operation.

Definition required_endorsements
  (ctxt : Alpha_context.context) (delay : Alpha_context.Period.t)
  : Lwt.t (Error_monad.tzresult Z) :=
  Required_endorsements.required_endorsements ctxt delay.

Definition minimal_valid_time
  (ctxt : Alpha_context.context) (priority : Z) (endorsing_power : Z)
  : Lwt.t (Error_monad.tzresult Time.t) :=
  Minimal_valid_time.minimal_valid_time ctxt priority endorsing_power.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_services.mli">
  <div class="col-md-6">
    <a href="#delegate_services.mli"><code>delegate_services.mli</code></a>&nbsp;<span class="label label-danger">195 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val list :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  ?active:bool -&gt;
  ?inactive:bool -&gt;
  unit -&gt;
  Signature.Public_key_hash.t list shell_tzresult Lwt.t</abbr>

type info = {
  balance : Tez.t;
  frozen_balance : Tez.t;
  frozen_balance_by_cycle : Delegate.frozen_balance Cycle.Map.t;
  staking_balance : Tez.t;
  delegated_contracts : Contract_repr.t list;
  delegated_balance : Tez.t;
  deactivated : bool;
  grace_period : Cycle.t;
}

val info_encoding : info Data_encoding.t

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val info :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  info shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val frozen_balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val frozen_balance_by_cycle :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Delegate.frozen_balance Cycle.Map.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val staking_balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val delegated_contracts :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Contract_repr.t list shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val delegated_balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val deactivated :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  bool shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val grace_period :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Cycle.t shell_tzresult Lwt.t</abbr>

module Baking_rights : sig
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    priority : int;
    timestamp : Timestamp.t option;
  }

  (** Retrieves the list of delegates allowed to bake a block.

      By default, it gives the best baking priorities for bakers
      that have at least one opportunity below the 64th priority for
      the next block.

      Parameters [levels] and [cycles] can be used to specify the
      (valid) level(s) in the past or future at which the baking rights
      have to be returned. Parameter [delegates] can be used to
      restrict the results to the given delegates. If parameter [all]
      is [true], all the baking opportunities for each baker at each level
      are returned, instead of just the first one.

      Returns the list of baking slots. Also returns the minimal
      timestamps that correspond to these slots. The timestamps are
      omitted for levels in the past, and are only estimates for levels
      later that the next block, based on the hypothesis that all
      predecessor blocks were baked at the first priority. *)
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val get :
    'a #RPC_context.simple -&gt;
    ?levels:Raw_level.t list -&gt;
    ?cycles:Cycle.t list -&gt;
    ?delegates:Signature.public_key_hash list -&gt;
    ?all:bool -&gt;
    ?max_priority:int -&gt;
    'a -&gt;
    t list shell_tzresult Lwt.t</abbr>
end

module Endorsing_rights : sig
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    slots : int list;
    estimated_time : Timestamp.t option;
  }

  (** Retrieves the delegates allowed to endorse a block.

      By default, it gives the endorsement slots for bakers that have
      at least one in the next block.

      Parameters [levels] and [cycles] can be used to specify the
      (valid) level(s) in the past or future at which the endorsement
      rights have to be returned. Parameter [delegates] can be used to
      restrict the results to the given delegates.  Returns the list of
      endorsement slots. Also returns the minimal timestamps that
      correspond to these slots.

      Timestamps are omitted for levels in the past, and are only
      estimates for levels later that the next block, based on the
      hypothesis that all predecessor blocks were baked at the first
      priority. *)
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val get :
    'a #RPC_context.simple -&gt;
    ?levels:Raw_level.t list -&gt;
    ?cycles:Cycle.t list -&gt;
    ?delegates:Signature.public_key_hash list -&gt;
    'a -&gt;
    t list shell_tzresult Lwt.t</abbr>
end

module Endorsing_power : sig
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val get :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Alpha_context.packed_operation -&gt;
    Chain_id.t -&gt;
    int shell_tzresult Lwt.t</abbr>
end

module Required_endorsements : sig
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val get :
    'a #RPC_context.simple -&gt; 'a -&gt; Period.t -&gt; int shell_tzresult Lwt.t</abbr>
end

module Minimal_valid_time : sig
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val get :
    'a #RPC_context.simple -&gt; 'a -&gt; int -&gt; int -&gt; Time.t shell_tzresult Lwt.t</abbr>
end

(* temporary export for deprecated unit test *)
val endorsement_rights :
  Alpha_context.t -&gt; Level.t -&gt; public_key_hash list tzresult Lwt.t

val baking_rights :
  Alpha_context.t -&gt;
  int option -&gt;
  (Raw_level.t * (public_key_hash * Time.t option) list) tzresult Lwt.t

val endorsing_power :
  Alpha_context.t -&gt;
  Alpha_context.packed_operation * Chain_id.t -&gt;
  int tzresult Lwt.t

val required_endorsements :
  Alpha_context.t -&gt; Alpha_context.Period.t -&gt; int tzresult Lwt.t

val minimal_valid_time : Alpha_context.t -&gt; int -&gt; int -&gt; Time.t tzresult Lwt.t

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_services.mli"><code>Delegate_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Contract_repr.

Parameter __list_value : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; option bool -&gt; option bool -&gt; unit -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list Signature.Public_key_hash.[S.SPublic_key_hash.t])).

Module info.
  Record record := {
    balance : Alpha_context.Tez.t;
    frozen_balance : Alpha_context.Tez.t;
    frozen_balance_by_cycle :
      Alpha_context.Cycle.Map.[S.MAP.t] Alpha_context.Delegate.frozen_balance;
    staking_balance : Alpha_context.Tez.t;
    delegated_contracts : list Contract_repr.t;
    delegated_balance : Alpha_context.Tez.t;
    deactivated : bool;
    grace_period : Alpha_context.Cycle.t }.
End info.
Definition info := info.record.

Parameter info_encoding : Data_encoding.t info.

Parameter info : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult info).

Parameter balance : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter frozen_balance : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter frozen_balance_by_cycle : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (Alpha_context.Cycle.Map.[S.MAP.t] Alpha_context.Delegate.frozen_balance)).

Parameter staking_balance : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter delegated_contracts : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult (list Contract_repr.t)).

Parameter delegated_balance : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter deactivated : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult bool).

Parameter grace_period : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Cycle.t).

Module Baking_rights.
  Module t.
    Record record := {
      level : Alpha_context.Raw_level.t;
      delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
      priority : Z;
      timestamp : option Alpha_context.Timestamp.t }.
  End t.
  Definition t := t.record.
  
  Parameter get : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt;
    option (list Alpha_context.Raw_level.t) -&gt;
    option (list Alpha_context.Cycle.t) -&gt;
    option (list Signature.public_key_hash) -&gt; option bool -&gt; option Z -&gt; a -&gt;
    Lwt.t (Error_monad.shell_tzresult (list t)).
End Baking_rights.

Module Endorsing_rights.
  Module t.
    Record record := {
      level : Alpha_context.Raw_level.t;
      delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
      slots : list Z;
      estimated_time : option Alpha_context.Timestamp.t }.
  End t.
  Definition t := t.record.
  
  Parameter get : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt;
    option (list Alpha_context.Raw_level.t) -&gt;
    option (list Alpha_context.Cycle.t) -&gt;
    option (list Signature.public_key_hash) -&gt; a -&gt;
    Lwt.t (Error_monad.shell_tzresult (list t)).
End Endorsing_rights.

Module Endorsing_power.
  Parameter get : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.packed_operation -&gt; Chain_id.[S.HASH.t] -&gt;
    Lwt.t (Error_monad.shell_tzresult Z).
End Endorsing_power.

Module Required_endorsements.
  Parameter get : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Period.t -&gt; Lwt.t (Error_monad.shell_tzresult Z).
End Required_endorsements.

Module Minimal_valid_time.
  Parameter get : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt; Z -&gt; Z -&gt;
    Lwt.t (Error_monad.shell_tzresult Time.t).
End Minimal_valid_time.

Parameter endorsement_rights :
  Alpha_context.t -&gt; Alpha_context.Level.t -&gt;
  Lwt.t (Error_monad.tzresult (list Alpha_context.public_key_hash)).

Parameter baking_rights :
  Alpha_context.t -&gt; option Z -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Alpha_context.Raw_level.t *
        list (Alpha_context.public_key_hash * option Time.t))).

Parameter endorsing_power :
  Alpha_context.t -&gt; Alpha_context.packed_operation * Chain_id.[S.HASH.t] -&gt;
  Lwt.t (Error_monad.tzresult Z).

Parameter required_endorsements :
  Alpha_context.t -&gt; Alpha_context.Period.t -&gt; Lwt.t (Error_monad.tzresult Z).

Parameter minimal_valid_time :
  Alpha_context.t -&gt; Z -&gt; Z -&gt; Lwt.t (Error_monad.tzresult Time.t).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_storage.ml">
  <div class="col-md-6">
    <a href="#delegate_storage.ml"><code>delegate_storage.ml</code></a>&nbsp;<span class="label label-danger">14 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type balance =
  | Contract of Contract_repr.t
  | Rewards of Signature.Public_key_hash.t * Cycle_repr.t
  | Fees of Signature.Public_key_hash.t * Cycle_repr.t
  | Deposits of Signature.Public_key_hash.t * Cycle_repr.t

let balance_encoding =
  let open Data_encoding in
  def &quot;operation_metadata.alpha.balance&quot;
  @@ union
       [ case
           (Tag 0)
           ~title:&quot;Contract&quot;
           (obj2
              (req &quot;kind&quot; (constant &quot;contract&quot;))
              (req &quot;contract&quot; Contract_repr.encoding))
           (function Contract c -&gt; Some ((), c) | _ -&gt; None)
           (fun ((), c) -&gt; Contract c);
         case
           (Tag 1)
           ~title:&quot;Rewards&quot;
           (obj4
              (req &quot;kind&quot; (constant &quot;freezer&quot;))
              (req &quot;category&quot; (constant &quot;rewards&quot;))
              (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;cycle&quot; Cycle_repr.encoding))
           (function Rewards (d, l) -&gt; Some ((), (), d, l) | _ -&gt; None)
           (fun ((), (), d, l) -&gt; Rewards (d, l));
         case
           (Tag 2)
           ~title:&quot;Fees&quot;
           (obj4
              (req &quot;kind&quot; (constant &quot;freezer&quot;))
              (req &quot;category&quot; (constant &quot;fees&quot;))
              (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;cycle&quot; Cycle_repr.encoding))
           (function Fees (d, l) -&gt; Some ((), (), d, l) | _ -&gt; None)
           (fun ((), (), d, l) -&gt; Fees (d, l));
         case
           (Tag 3)
           ~title:&quot;Deposits&quot;
           (obj4
              (req &quot;kind&quot; (constant &quot;freezer&quot;))
              (req &quot;category&quot; (constant &quot;deposits&quot;))
              (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;cycle&quot; Cycle_repr.encoding))
           (function Deposits (d, l) -&gt; Some ((), (), d, l) | _ -&gt; None)
           (fun ((), (), d, l) -&gt; Deposits (d, l)) ]

type balance_update = Debited of Tez_repr.t | Credited of Tez_repr.t

let balance_update_encoding =
  let open Data_encoding in
  def &quot;operation_metadata.alpha.balance_update&quot;
  @@ obj1
       (req
          &quot;change&quot;
          (conv
             (function
               | Credited v -&gt;
                   Tez_repr.to_mutez v
               | Debited v -&gt;
                   Int64.neg (Tez_repr.to_mutez v))
             ( Json.wrap_error
             @@ fun v -&gt;
             if Compare.Int64.(v &lt; 0L) then
               match Tez_repr.of_mutez (Int64.neg v) with
               | Some v -&gt;
                   Debited v
               | None -&gt;
                   failwith &quot;Qty.of_mutez&quot;
             else
               match Tez_repr.of_mutez v with
               | Some v -&gt;
                   Credited v
               | None -&gt;
                   failwith &quot;Qty.of_mutez&quot; )
             int64))

type balance_updates = (balance * balance_update) list

let balance_updates_encoding =
  let open Data_encoding in
  def &quot;operation_metadata.alpha.balance_updates&quot;
  @@ list (merge_objs balance_encoding balance_update_encoding)

let cleanup_balance_updates balance_updates =
  List.filter
    (fun (_, (Credited update | Debited update)) -&gt;
      not (Tez_repr.equal update Tez_repr.zero))
    balance_updates

type frozen_balance = {
  deposit : Tez_repr.t;
  fees : Tez_repr.t;
  rewards : Tez_repr.t;
}

let frozen_balance_encoding =
  let open Data_encoding in
  conv
    (fun {deposit; fees; rewards} -&gt; (deposit, fees, rewards))
    (fun (deposit, fees, rewards) -&gt; {deposit; fees; rewards})
    (obj3
       (req &quot;deposit&quot; Tez_repr.encoding)
       (req &quot;fees&quot; Tez_repr.encoding)
       (req &quot;rewards&quot; Tez_repr.encoding))

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | No_deletion of Signature.Public_key_hash.t (* `Permanent *)
  | Active_delegate (* `Temporary *)
  | Current_delegate (* `Temporary *)
  | Empty_delegate_account of Signature.Public_key_hash.t (* `Temporary *)
  | Balance_too_low_for_deposit of {
      delegate : Signature.Public_key_hash.t;
      deposit : Tez_repr.t;
      balance : Tez_repr.t;
    }</abbr>

(* `Temporary *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;delegate.no_deletion&quot;
    ~title:&quot;Forbidden delegate deletion&quot;
    ~description:&quot;Tried to unregister a delegate&quot;
    ~pp:(fun ppf delegate -&gt;
      Format.fprintf
        ppf
        &quot;Delegate deletion is forbidden (%a)&quot;
        Signature.Public_key_hash.pp
        delegate)
    Data_encoding.(obj1 (req &quot;delegate&quot; Signature.Public_key_hash.encoding))
    (function No_deletion c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; No_deletion c) ;
  register_error_kind
    `Temporary
    ~id:&quot;delegate.already_active&quot;
    ~title:&quot;Delegate already active&quot;
    ~description:&quot;Useless delegate reactivation&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;The delegate is still active, no need to refresh it&quot;)
    Data_encoding.empty
    (function Active_delegate -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Active_delegate) ;
  register_error_kind
    `Temporary
    ~id:&quot;delegate.unchanged&quot;
    ~title:&quot;Unchanged delegated&quot;
    ~description:&quot;Contract already delegated to the given delegate&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;The contract is already delegated to the same delegate&quot;)
    Data_encoding.empty
    (function Current_delegate -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Current_delegate) ;
  register_error_kind
    `Permanent
    ~id:&quot;delegate.empty_delegate_account&quot;
    ~title:&quot;Empty delegate account&quot;
    ~description:
      &quot;Cannot register a delegate when its implicit account is empty&quot;
    ~pp:(fun ppf delegate -&gt;
      Format.fprintf
        ppf
        &quot;Delegate registration is forbidden when the delegate\n\
        \           implicit account is empty (%a)&quot;
        Signature.Public_key_hash.pp
        delegate)
    Data_encoding.(obj1 (req &quot;delegate&quot; Signature.Public_key_hash.encoding))
    (function Empty_delegate_account c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Empty_delegate_account c) ;
  register_error_kind
    `Temporary
    ~id:&quot;delegate.balance_too_low_for_deposit&quot;
    ~title:&quot;Balance too low for deposit&quot;
    ~description:&quot;Cannot freeze deposit when the balance is too low&quot;
    ~pp:(fun ppf (delegate, balance, deposit) -&gt;
      Format.fprintf
        ppf
        &quot;Delegate %a has a too low balance (%a) to deposit %a&quot;
        Signature.Public_key_hash.pp
        delegate
        Tez_repr.pp
        balance
        Tez_repr.pp
        deposit)
    Data_encoding.(
      obj3
        (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
        (req &quot;balance&quot; Tez_repr.encoding)
        (req &quot;deposit&quot; Tez_repr.encoding))
    (function
      | Balance_too_low_for_deposit {delegate; balance; deposit} -&gt;
          Some (delegate, balance, deposit)
      | _ -&gt;
          None)
    (fun (delegate, balance, deposit) -&gt;
      Balance_too_low_for_deposit {delegate; balance; deposit})</abbr>

let link c contract delegate =
  Storage.Contract.Balance.get c contract
  &gt;&gt;=? fun balance -&gt;
  Roll_storage.Delegate.add_amount c delegate balance
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Delegated.add
    (c, Contract_repr.implicit_contract delegate)
    contract
  &gt;&gt;= fun c -&gt; return c

let unlink c contract =
  Storage.Contract.Balance.get c contract
  &gt;&gt;=? fun balance -&gt;
  Storage.Contract.Delegate.get_option c contract
  &gt;&gt;=? function
  | None -&gt;
      return c
  | Some delegate -&gt;
      (* Removes the balance of the contract from the delegate *)
      Roll_storage.Delegate.remove_amount c delegate balance
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Delegated.del
        (c, Contract_repr.implicit_contract delegate)
        contract
      &gt;&gt;= fun c -&gt; return c

let known c delegate =
  Storage.Contract.Manager.get_option
    c
    (Contract_repr.implicit_contract delegate)
  &gt;&gt;=? function
  | None | Some (Manager_repr.Hash _) -&gt;
      return_false
  | Some (Manager_repr.Public_key _) -&gt;
      return_true

(* A delegate is registered if its &quot;implicit account&quot; delegates to itself. *)
let registered c delegate =
  Storage.Contract.Delegate.get_option
    c
    (Contract_repr.implicit_contract delegate)
  &gt;&gt;=? function
  | Some current_delegate -&gt;
      return @@ Signature.Public_key_hash.equal delegate current_delegate
  | None -&gt;
      return_false

let init ctxt contract delegate =
  known ctxt delegate
  &gt;&gt;=? fun known_delegate -&gt;
  fail_unless known_delegate <abbr class="mark-error" title="Values of extensible types are not handled">(Roll_storage.Unregistered_delegate delegate)</abbr>
  &gt;&gt;=? fun () -&gt;
  registered ctxt delegate
  &gt;&gt;=? fun is_registered -&gt;
  fail_unless is_registered <abbr class="mark-error" title="Values of extensible types are not handled">(Roll_storage.Unregistered_delegate delegate)</abbr>
  &gt;&gt;=? fun () -&gt;
  Storage.Contract.Delegate.init ctxt contract delegate
  &gt;&gt;=? fun ctxt -&gt; link ctxt contract delegate

let get = Roll_storage.get_contract_delegate

let set c contract delegate =
  match delegate with
  | None -&gt; (
      let delete () =
        unlink c contract
        &gt;&gt;=? fun c -&gt;
        Storage.Contract.Delegate.remove c contract &gt;&gt;= fun c -&gt; return c
      in
      match Contract_repr.is_implicit contract with
      | Some pkh -&gt;
          (* check if contract is a registered delegate *)
          registered c pkh
          &gt;&gt;=? fun is_registered -&gt;
          if is_registered then fail <abbr class="mark-error" title="Values of extensible types are not handled">(No_deletion pkh)</abbr> else delete ()
      | None -&gt;
          delete () )
  | Some delegate -&gt;
      known c delegate
      &gt;&gt;=? fun known_delegate -&gt;
      registered c delegate
      &gt;&gt;=? fun registered_delegate -&gt;
      let self_delegation =
        match Contract_repr.is_implicit contract with
        | Some pkh -&gt;
            Signature.Public_key_hash.equal pkh delegate
        | None -&gt;
            false
      in
      if (not known_delegate) || not (registered_delegate || self_delegation)
      then fail <abbr class="mark-error" title="Values of extensible types are not handled">(Roll_storage.Unregistered_delegate delegate)</abbr>
      else
        Storage.Contract.Delegate.get_option c contract
        &gt;&gt;=? (function
               | Some current_delegate
                 when Signature.Public_key_hash.equal delegate current_delegate
                 -&gt;
                   if self_delegation then
                     Roll_storage.Delegate.is_inactive c delegate
                     &gt;&gt;=? function
                     | true -&gt; return_unit | false -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">Active_delegate</abbr>
                   else fail <abbr class="mark-error" title="Values of extensible types are not handled">Current_delegate</abbr>
               | None | Some _ -&gt;
                   return_unit)
        &gt;&gt;=? fun () -&gt;
        (* check if contract is a registered delegate *)
        ( match Contract_repr.is_implicit contract with
        | Some pkh -&gt;
            registered c pkh
            &gt;&gt;=? fun is_registered -&gt;
            (* allow self-delegation to re-activate *)
            if (not self_delegation) &amp;&amp; is_registered then
              fail <abbr class="mark-error" title="Values of extensible types are not handled">(No_deletion pkh)</abbr>
            else return_unit
        | None -&gt;
            return_unit )
        &gt;&gt;=? fun () -&gt;
        Storage.Contract.Balance.mem c contract
        &gt;&gt;= fun exists -&gt;
        fail_when
          (self_delegation &amp;&amp; not exists)
          <abbr class="mark-error" title="Values of extensible types are not handled">(Empty_delegate_account delegate)</abbr>
        &gt;&gt;=? fun () -&gt;
        unlink c contract
        &gt;&gt;=? fun c -&gt;
        Storage.Contract.Delegate.init_set c contract delegate
        &gt;&gt;= fun c -&gt;
        link c contract delegate
        &gt;&gt;=? fun c -&gt;
        ( if self_delegation then
          Storage.Delegates.add c delegate
          &gt;&gt;= fun c -&gt;
          Roll_storage.Delegate.set_active c delegate &gt;&gt;=? fun c -&gt; return c
        else return c )
        &gt;&gt;=? fun c -&gt; return c

let remove ctxt contract = unlink ctxt contract

let delegated_contracts ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  Storage.Contract.Delegated.elements (ctxt, contract)

let get_frozen_deposit ctxt contract cycle =
  Storage.Contract.Frozen_deposits.get_option (ctxt, contract) cycle
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some frozen -&gt; return frozen

let credit_frozen_deposit ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  Lwt.return Tez_repr.(old_amount +? amount)
  &gt;&gt;=? fun new_amount -&gt;
  Storage.Contract.Frozen_deposits.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt;
  Storage.Delegates_with_frozen_balance.add (ctxt, cycle) delegate
  &gt;&gt;= fun ctxt -&gt; return ctxt

let freeze_deposit ctxt delegate amount =
  let {Level_repr.cycle; _} = Level_storage.current ctxt in
  Roll_storage.Delegate.set_active ctxt delegate
  &gt;&gt;=? fun ctxt -&gt;
  let contract = Contract_repr.implicit_contract delegate in
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;=? fun balance -&gt;
  Lwt.return
    (record_trace
       <abbr class="mark-error" title="Values of extensible types are not handled">(Balance_too_low_for_deposit {delegate; deposit = amount; balance})</abbr>
       Tez_repr.(balance -? amount))
  &gt;&gt;=? fun new_balance -&gt;
  Storage.Contract.Balance.set ctxt contract new_balance
  &gt;&gt;=? fun ctxt -&gt; credit_frozen_deposit ctxt delegate cycle amount

let get_frozen_fees ctxt contract cycle =
  Storage.Contract.Frozen_fees.get_option (ctxt, contract) cycle
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some frozen -&gt; return frozen

let credit_frozen_fees ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  Lwt.return Tez_repr.(old_amount +? amount)
  &gt;&gt;=? fun new_amount -&gt;
  Storage.Contract.Frozen_fees.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt;
  Storage.Delegates_with_frozen_balance.add (ctxt, cycle) delegate
  &gt;&gt;= fun ctxt -&gt; return ctxt

let freeze_fees ctxt delegate amount =
  let {Level_repr.cycle; _} = Level_storage.current ctxt in
  Roll_storage.Delegate.add_amount ctxt delegate amount
  &gt;&gt;=? fun ctxt -&gt; credit_frozen_fees ctxt delegate cycle amount

let burn_fees ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  ( match Tez_repr.(old_amount -? amount) with
  | Ok new_amount -&gt;
      Roll_storage.Delegate.remove_amount ctxt delegate amount
      &gt;&gt;=? fun ctxt -&gt; return (new_amount, ctxt)
  | Error _ -&gt;
      Roll_storage.Delegate.remove_amount ctxt delegate old_amount
      &gt;&gt;=? fun ctxt -&gt; return (Tez_repr.zero, ctxt) )
  &gt;&gt;=? fun (new_amount, ctxt) -&gt;
  Storage.Contract.Frozen_fees.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt; return ctxt

let get_frozen_rewards ctxt contract cycle =
  Storage.Contract.Frozen_rewards.get_option (ctxt, contract) cycle
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some frozen -&gt; return frozen

let credit_frozen_rewards ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  Lwt.return Tez_repr.(old_amount +? amount)
  &gt;&gt;=? fun new_amount -&gt;
  Storage.Contract.Frozen_rewards.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt;
  Storage.Delegates_with_frozen_balance.add (ctxt, cycle) delegate
  &gt;&gt;= fun ctxt -&gt; return ctxt

let freeze_rewards ctxt delegate amount =
  let {Level_repr.cycle; _} = Level_storage.current ctxt in
  credit_frozen_rewards ctxt delegate cycle amount

let burn_rewards ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  let new_amount =
    match Tez_repr.(old_amount -? amount) with
    | Error _ -&gt;
        Tez_repr.zero
    | Ok new_amount -&gt;
        new_amount
  in
  Storage.Contract.Frozen_rewards.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt; return ctxt

let unfreeze ctxt delegate cycle =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun deposit -&gt;
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun fees -&gt;
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun rewards -&gt;
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;=? fun balance -&gt;
  Lwt.return Tez_repr.(deposit +? fees)
  &gt;&gt;=? fun unfrozen_amount -&gt;
  Lwt.return Tez_repr.(unfrozen_amount +? rewards)
  &gt;&gt;=? fun unfrozen_amount -&gt;
  Lwt.return Tez_repr.(balance +? unfrozen_amount)
  &gt;&gt;=? fun balance -&gt;
  Storage.Contract.Balance.set ctxt contract balance
  &gt;&gt;=? fun ctxt -&gt;
  Roll_storage.Delegate.add_amount ctxt delegate rewards
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Contract.Frozen_deposits.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_fees.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_rewards.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  return
    ( ctxt,
      cleanup_balance_updates
        [ (Deposits (delegate, cycle), Debited deposit);
          (Fees (delegate, cycle), Debited fees);
          (Rewards (delegate, cycle), Debited rewards);
          ( Contract (Contract_repr.implicit_contract delegate),
            Credited unfrozen_amount ) ] )

let cycle_end ctxt last_cycle unrevealed =
  let preserved = Constants_storage.preserved_cycles ctxt in
  ( match Cycle_repr.pred last_cycle with
  | None -&gt;
      return (ctxt, [])
  | Some revealed_cycle -&gt;
      List.fold_left
        (fun acc (u : Nonce_storage.unrevealed) -&gt;
          acc
          &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
          burn_fees ctxt u.delegate revealed_cycle u.fees
          &gt;&gt;=? fun ctxt -&gt;
          burn_rewards ctxt u.delegate revealed_cycle u.rewards
          &gt;&gt;=? fun ctxt -&gt;
          let bus =
            [ (Fees (u.delegate, revealed_cycle), Debited u.fees);
              (Rewards (u.delegate, revealed_cycle), Debited u.rewards) ]
          in
          return (ctxt, bus @ balance_updates))
        (return (ctxt, []))
        unrevealed )
  &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
  match Cycle_repr.sub last_cycle preserved with
  | None -&gt;
      return (ctxt, balance_updates, [])
  | Some unfrozen_cycle -&gt;
      Storage.Delegates_with_frozen_balance.fold
        (ctxt, unfrozen_cycle)
        ~init:(Ok (ctxt, balance_updates))
        ~f:(fun delegate acc -&gt;
          Lwt.return acc
          &gt;&gt;=? fun (ctxt, bus) -&gt;
          unfreeze ctxt delegate unfrozen_cycle
          &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
          return (ctxt, balance_updates @ bus))
      &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
      Storage.Delegates_with_frozen_balance.clear (ctxt, unfrozen_cycle)
      &gt;&gt;= fun ctxt -&gt;
      Storage.Active_delegates_with_rolls.fold
        ctxt
        ~init:(Ok (ctxt, []))
        ~f:(fun delegate acc -&gt;
          Lwt.return acc
          &gt;&gt;=? fun (ctxt, deactivated) -&gt;
          Storage.Contract.Delegate_desactivation.get
            ctxt
            (Contract_repr.implicit_contract delegate)
          &gt;&gt;=? fun cycle -&gt;
          if Cycle_repr.(cycle &lt;= last_cycle) then
            Roll_storage.Delegate.set_inactive ctxt delegate
            &gt;&gt;=? fun ctxt -&gt; return (ctxt, delegate :: deactivated)
          else return (ctxt, deactivated))
      &gt;&gt;=? fun (ctxt, deactivated) -&gt;
      return (ctxt, balance_updates, deactivated)

let punish ctxt delegate cycle =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun deposit -&gt;
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun fees -&gt;
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun rewards -&gt;
  Roll_storage.Delegate.remove_amount ctxt delegate deposit
  &gt;&gt;=? fun ctxt -&gt;
  Roll_storage.Delegate.remove_amount ctxt delegate fees
  &gt;&gt;=? fun ctxt -&gt;
  (* Rewards are not accounted in the delegate's rolls yet... *)
  Storage.Contract.Frozen_deposits.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_fees.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_rewards.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt; return (ctxt, {deposit; fees; rewards})

let has_frozen_balance ctxt delegate cycle =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun deposit -&gt;
  if Tez_repr.(deposit &lt;&gt; zero) then return_true
  else
    get_frozen_fees ctxt contract cycle
    &gt;&gt;=? fun fees -&gt;
    if Tez_repr.(fees &lt;&gt; zero) then return_true
    else
      get_frozen_rewards ctxt contract cycle
      &gt;&gt;=? fun rewards -&gt; return Tez_repr.(rewards &lt;&gt; zero)

let frozen_balance_by_cycle_encoding =
  let open Data_encoding in
  conv
    Cycle_repr.Map.bindings
    (List.fold_left
       (fun m (c, b) -&gt; Cycle_repr.Map.add c b m)
       Cycle_repr.Map.empty)
    (list
       (merge_objs
          (obj1 (req &quot;cycle&quot; Cycle_repr.encoding))
          frozen_balance_encoding))

let empty_frozen_balance =
  {deposit = Tez_repr.zero; fees = Tez_repr.zero; rewards = Tez_repr.zero}

let frozen_balance_by_cycle ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  let map = Cycle_repr.Map.empty in
  Storage.Contract.Frozen_deposits.fold
    (ctxt, contract)
    ~init:map
    ~f:(fun cycle amount map -&gt;
      Lwt.return
        (Cycle_repr.Map.add
           cycle
           <abbr class="mark-error" title="Record substitution not handled">{empty_frozen_balance with deposit = amount}</abbr>
           map))
  &gt;&gt;= fun map -&gt;
  Storage.Contract.Frozen_fees.fold
    (ctxt, contract)
    ~init:map
    ~f:(fun cycle amount map -&gt;
      let balance =
        match Cycle_repr.Map.find_opt cycle map with
        | None -&gt;
            empty_frozen_balance
        | Some balance -&gt;
            balance
      in
      Lwt.return (Cycle_repr.Map.add cycle <abbr class="mark-error" title="Record substitution not handled">{balance with fees = amount}</abbr> map))
  &gt;&gt;= fun map -&gt;
  Storage.Contract.Frozen_rewards.fold
    (ctxt, contract)
    ~init:map
    ~f:(fun cycle amount map -&gt;
      let balance =
        match Cycle_repr.Map.find_opt cycle map with
        | None -&gt;
            empty_frozen_balance
        | Some balance -&gt;
            balance
      in
      Lwt.return (Cycle_repr.Map.add cycle <abbr class="mark-error" title="Record substitution not handled">{balance with rewards = amount}</abbr> map))
  &gt;&gt;= fun map -&gt; Lwt.return map

let frozen_balance ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  let balance = Ok Tez_repr.zero in
  Storage.Contract.Frozen_deposits.fold
    (ctxt, contract)
    ~init:balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun balance -&gt;
  Storage.Contract.Frozen_fees.fold
    (ctxt, contract)
    ~init:balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun balance -&gt;
  Storage.Contract.Frozen_rewards.fold
    (ctxt, contract)
    ~init:balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun balance -&gt; Lwt.return balance

let full_balance ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  frozen_balance ctxt delegate
  &gt;&gt;=? fun frozen_balance -&gt;
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;=? fun balance -&gt; Lwt.return Tez_repr.(frozen_balance +? balance)

let deactivated = Roll_storage.Delegate.is_inactive

let grace_period ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  Storage.Contract.Delegate_desactivation.get ctxt contract

let staking_balance ctxt delegate =
  let token_per_rolls = Constants_storage.tokens_per_roll ctxt in
  Roll_storage.get_rolls ctxt delegate
  &gt;&gt;=? fun rolls -&gt;
  Roll_storage.get_change ctxt delegate
  &gt;&gt;=? fun change -&gt;
  let rolls = Int64.of_int (List.length rolls) in
  Lwt.return Tez_repr.(token_per_rolls *? rolls)
  &gt;&gt;=? fun balance -&gt; Lwt.return Tez_repr.(balance +? change)

let delegated_balance ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  staking_balance ctxt delegate
  &gt;&gt;=? fun staking_balance -&gt;
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;= fun self_staking_balance -&gt;
  Storage.Contract.Frozen_deposits.fold
    (ctxt, contract)
    ~init:self_staking_balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun self_staking_balance -&gt;
  Storage.Contract.Frozen_fees.fold
    (ctxt, contract)
    ~init:self_staking_balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;=? fun self_staking_balance -&gt;
  Lwt.return Tez_repr.(staking_balance -? self_staking_balance)

let fold = Storage.Delegates.fold

let list = Storage.Delegates.elements
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_storage.ml"><code>Delegate_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Manager_repr.
Require Tezos.Nonce_storage.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Storage.
Require Tezos.Tez_repr.

Inductive balance : Set :=
| Contract : Contract_repr.t -&gt; balance
| Rewards :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle_repr.t -&gt; balance
| Fees :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle_repr.t -&gt; balance
| Deposits :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle_repr.t -&gt; balance.

Definition balance_encoding : Data_encoding.encoding balance :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;operation_metadata.alpha.balance&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      (cons
        (Data_encoding.__case_value &quot;Contract&quot; % string None
          (Data_encoding.Tag 0)
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;kind&quot; % string
              (Data_encoding.constant &quot;contract&quot; % string))
            (Data_encoding.req None None &quot;contract&quot; % string
              Contract_repr.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Contract c =&gt; Some (tt, c)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(tt, c) := function_parameter in
            Contract c))
        (cons
          (Data_encoding.__case_value &quot;Rewards&quot; % string None
            (Data_encoding.Tag 1)
            (Data_encoding.obj4
              (Data_encoding.req None None &quot;kind&quot; % string
                (Data_encoding.constant &quot;freezer&quot; % string))
              (Data_encoding.req None None &quot;category&quot; % string
                (Data_encoding.constant &quot;rewards&quot; % string))
              (Data_encoding.req None None &quot;delegate&quot; % string
                Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
              (Data_encoding.req None None &quot;cycle&quot; % string Cycle_repr.encoding))
            (fun function_parameter =&gt;
              match function_parameter with
              | Rewards d l =&gt; Some (tt, tt, d, l)
              | _ =&gt; None
              end)
            (fun function_parameter =&gt;
              let '(tt, tt, d, l) := function_parameter in
              Rewards d l))
          (cons
            (Data_encoding.__case_value &quot;Fees&quot; % string None
              (Data_encoding.Tag 2)
              (Data_encoding.obj4
                (Data_encoding.req None None &quot;kind&quot; % string
                  (Data_encoding.constant &quot;freezer&quot; % string))
                (Data_encoding.req None None &quot;category&quot; % string
                  (Data_encoding.constant &quot;fees&quot; % string))
                (Data_encoding.req None None &quot;delegate&quot; % string
                  Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
                (Data_encoding.req None None &quot;cycle&quot; % string
                  Cycle_repr.encoding))
              (fun function_parameter =&gt;
                match function_parameter with
                | Fees d l =&gt; Some (tt, tt, d, l)
                | _ =&gt; None
                end)
              (fun function_parameter =&gt;
                let '(tt, tt, d, l) := function_parameter in
                Fees d l))
            (cons
              (Data_encoding.__case_value &quot;Deposits&quot; % string None
                (Data_encoding.Tag 3)
                (Data_encoding.obj4
                  (Data_encoding.req None None &quot;kind&quot; % string
                    (Data_encoding.constant &quot;freezer&quot; % string))
                  (Data_encoding.req None None &quot;category&quot; % string
                    (Data_encoding.constant &quot;deposits&quot; % string))
                  (Data_encoding.req None None &quot;delegate&quot; % string
                    Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
                  (Data_encoding.req None None &quot;cycle&quot; % string
                    Cycle_repr.encoding))
                (fun function_parameter =&gt;
                  match function_parameter with
                  | Deposits d l =&gt; Some (tt, tt, d, l)
                  | _ =&gt; None
                  end)
                (fun function_parameter =&gt;
                  let '(tt, tt, d, l) := function_parameter in
                  Deposits d l)) []))))).

Inductive balance_update : Set :=
| Debited : Tez_repr.t -&gt; balance_update
| Credited : Tez_repr.t -&gt; balance_update.

Definition balance_update_encoding : Data_encoding.encoding balance_update :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;operation_metadata.alpha.balance_update&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.obj1
      (Data_encoding.req None None &quot;change&quot; % string
        (Data_encoding.conv
          (fun function_parameter =&gt;
            match function_parameter with
            | Credited v =&gt; Tez_repr.to_mutez v
            | Debited v =&gt; Int64.neg (Tez_repr.to_mutez v)
            end)
          (Pervasives.op_atat Data_encoding.Json.wrap_error
            (fun v =&gt;
              if
                Compare.Int64.[Compare.S.op_lt] v
                  (* ‚ùå Constant of type int64 is converted to int *)
                  0 then
                match Tez_repr.of_mutez (Int64.neg v) with
                | Some v =&gt; Debited v
                | None =&gt; Pervasives.failwith &quot;Qty.of_mutez&quot; % string
                end
              else
                match Tez_repr.of_mutez v with
                | Some v =&gt; Credited v
                | None =&gt; Pervasives.failwith &quot;Qty.of_mutez&quot; % string
                end)) None Data_encoding.__int64_value))).

Definition balance_updates := list (balance * balance_update).

Definition balance_updates_encoding
  : Data_encoding.encoding (list (balance * balance_update)) :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.def &quot;operation_metadata.alpha.balance_updates&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.__list_value None
      (Data_encoding.merge_objs balance_encoding balance_update_encoding)).

Definition cleanup_balance_updates {A : Set}
  (balance_updates : list (A * balance_update)) : list (A * balance_update) :=
  List.filter
    (fun function_parameter =&gt;
      let '(_, Credited update | Debited update) := function_parameter in
      Pervasives.not (Tez_repr.equal update Tez_repr.zero)) balance_updates.

Module frozen_balance.
  Record record := {
    deposit : Tez_repr.t;
    fees : Tez_repr.t;
    rewards : Tez_repr.t }.
End frozen_balance.
Definition frozen_balance := frozen_balance.record.

Definition frozen_balance_encoding : Data_encoding.encoding frozen_balance :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        frozen_balance.deposit := deposit;
          frozen_balance.fees := fees;
          frozen_balance.rewards := rewards
          |} := function_parameter in
      (deposit, fees, rewards))
    (fun function_parameter =&gt;
      let '(deposit, fees, rewards) := function_parameter in
      {| frozen_balance.deposit := deposit; frozen_balance.fees := fees;
        frozen_balance.rewards := rewards |}) None
    (Data_encoding.obj3
      (Data_encoding.req None None &quot;deposit&quot; % string Tez_repr.encoding)
      (Data_encoding.req None None &quot;fees&quot; % string Tez_repr.encoding)
      (Data_encoding.req None None &quot;rewards&quot; % string Tez_repr.encoding)).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition link
  (c : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion (Storage.Contract.Balance.get c contract)
    (fun balance =&gt;
      Error_monad.op_gtgteqquestion
        (Roll_storage.Delegate.add_amount c delegate balance)
        (fun c =&gt;
          Error_monad.op_gtgteq
            (Storage.Contract.Delegated.add
              (c, (Contract_repr.implicit_contract delegate)) contract)
            (fun c =&gt; Error_monad.__return c))).

Definition unlink
  (c : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key)
  : Lwt.t (Error_monad.tzresult Storage.Contract.Balance.context) :=
  Error_monad.op_gtgteqquestion (Storage.Contract.Balance.get c contract)
    (fun balance =&gt;
      Error_monad.op_gtgteqquestion
        (Storage.Contract.Delegate.get_option c contract)
        (fun function_parameter =&gt;
          match function_parameter with
          | None =&gt; Error_monad.__return c
          | Some delegate =&gt;
            Error_monad.op_gtgteqquestion
              (Roll_storage.Delegate.remove_amount c delegate balance)
              (fun c =&gt;
                Error_monad.op_gtgteq
                  (Storage.Contract.Delegated.del
                    (c, (Contract_repr.implicit_contract delegate)) contract)
                  (fun c =&gt; Error_monad.__return c))
          end)).

Definition known
  (c : Storage.Contract.Manager.context)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult bool) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Manager.get_option c
      (Contract_repr.implicit_contract delegate))
    (fun function_parameter =&gt;
      match function_parameter with
      | None | Some (Manager_repr.Hash _) =&gt; Error_monad.return_false
      | Some (Manager_repr.Public_key _) =&gt; Error_monad.return_true
      end).

Definition registered
  (c : Storage.Contract.Delegate.context)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult bool) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Delegate.get_option c
      (Contract_repr.implicit_contract delegate))
    (fun function_parameter =&gt;
      match function_parameter with
      | Some current_delegate =&gt;
        Pervasives.op_atat Error_monad.__return
          (Signature.Public_key_hash.[S.SPublic_key_hash.equal] delegate
            current_delegate)
      | None =&gt; Error_monad.return_false
      end).

Definition init
  (ctxt : Storage.Contract.Manager.context)
  (contract : Storage.Contract.Delegate.key)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion (known ctxt delegate)
    (fun known_delegate =&gt;
      Error_monad.op_gtgteqquestion
        (Error_monad.fail_unless known_delegate extensible_type_value)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgteqquestion (registered ctxt delegate)
            (fun is_registered =&gt;
              Error_monad.op_gtgteqquestion
                (Error_monad.fail_unless is_registered extensible_type_value)
                (fun function_parameter =&gt;
                  let 'tt := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Storage.Contract.Delegate.init ctxt contract delegate)
                    (fun ctxt =&gt; link ctxt contract delegate))))).

Definition get
  : Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      (option Signature.Public_key_hash.[S.SPublic_key_hash.t])) :=
  Roll_storage.get_contract_delegate.

Definition set
  (c : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key)
  (delegate : option Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  match delegate with
  | None =&gt;
    let delete (function_parameter : unit)
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      let 'tt := function_parameter in
      Error_monad.op_gtgteqquestion (unlink c contract)
        (fun c =&gt;
          Error_monad.op_gtgteq (Storage.Contract.Delegate.remove c contract)
            (fun c =&gt; Error_monad.__return c)) in
    match Contract_repr.is_implicit contract with
    | Some pkh =&gt;
      Error_monad.op_gtgteqquestion (registered c pkh)
        (fun is_registered =&gt;
          if is_registered then
            Error_monad.fail extensible_type_value
          else
            delete tt)
    | None =&gt; delete tt
    end
  | Some delegate =&gt;
    Error_monad.op_gtgteqquestion (known c delegate)
      (fun known_delegate =&gt;
        Error_monad.op_gtgteqquestion (registered c delegate)
          (fun registered_delegate =&gt;
            let self_delegation :=
              match Contract_repr.is_implicit contract with
              | Some pkh =&gt;
                Signature.Public_key_hash.[S.SPublic_key_hash.equal] pkh
                  delegate
              | None =&gt; false
              end in
            if
              Pervasives.op_pipepipe (Pervasives.not known_delegate)
                (Pervasives.not
                  (Pervasives.op_pipepipe registered_delegate self_delegation))
              then
              Error_monad.fail extensible_type_value
            else
              Error_monad.op_gtgteqquestion
                (Error_monad.op_gtgteqquestion
                  (Storage.Contract.Delegate.get_option c contract)
                  (fun function_parameter =&gt;
                    match
                      (function_parameter,
                        match function_parameter with
                        | Some current_delegate =&gt;
                          Signature.Public_key_hash.[S.SPublic_key_hash.equal]
                            delegate current_delegate
                        | _ =&gt; false
                        end) with
                    | (Some current_delegate, true) =&gt;
                      if self_delegation then
                        Error_monad.op_gtgteqquestion
                          (Roll_storage.Delegate.is_inactive c delegate)
                          (fun function_parameter =&gt;
                            match function_parameter with
                            | true =&gt; Error_monad.return_unit
                            | false =&gt; Error_monad.fail extensible_type_value
                            end)
                      else
                        Error_monad.fail extensible_type_value
                    | (None | Some _, _) =&gt; Error_monad.return_unit
                    end))
                (fun function_parameter =&gt;
                  let 'tt := function_parameter in
                  Error_monad.op_gtgteqquestion
                    match Contract_repr.is_implicit contract with
                    | Some pkh =&gt;
                      Error_monad.op_gtgteqquestion (registered c pkh)
                        (fun is_registered =&gt;
                          if
                            Pervasives.op_andand
                              (Pervasives.not self_delegation) is_registered
                            then
                            Error_monad.fail extensible_type_value
                          else
                            Error_monad.return_unit)
                    | None =&gt; Error_monad.return_unit
                    end
                    (fun function_parameter =&gt;
                      let 'tt := function_parameter in
                      Error_monad.op_gtgteq
                        (Storage.Contract.Balance.mem c contract)
                        (fun __exists =&gt;
                          Error_monad.op_gtgteqquestion
                            (Error_monad.fail_when
                              (Pervasives.op_andand self_delegation
                                (Pervasives.not __exists)) extensible_type_value)
                            (fun function_parameter =&gt;
                              let 'tt := function_parameter in
                              Error_monad.op_gtgteqquestion (unlink c contract)
                                (fun c =&gt;
                                  Error_monad.op_gtgteq
                                    (Storage.Contract.Delegate.init_set c
                                      contract delegate)
                                    (fun c =&gt;
                                      Error_monad.op_gtgteqquestion
                                        (link c contract delegate)
                                        (fun c =&gt;
                                          Error_monad.op_gtgteqquestion
                                            (if self_delegation then
                                              Error_monad.op_gtgteq
                                                (Storage.Delegates.add c
                                                  delegate)
                                                (fun c =&gt;
                                                  Error_monad.op_gtgteqquestion
                                                    (Roll_storage.Delegate.set_active
                                                      c delegate)
                                                    (fun c =&gt;
                                                      Error_monad.__return c))
                                            else
                                              Error_monad.__return c)
                                            (fun c =&gt; Error_monad.__return c))))))))))
  end.

Definition remove
  (ctxt : Storage.Contract.Balance.context)
  (contract : Storage.Contract.Balance.key)
  : Lwt.t (Error_monad.tzresult Storage.Contract.Balance.context) :=
  unlink ctxt contract.

Definition delegated_contracts
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (list Storage.Contract.Delegated.elt) :=
  let contract := Contract_repr.implicit_contract delegate in
  Storage.Contract.Delegated.elements (ctxt, contract).

Definition get_frozen_deposit
  (ctxt : Raw_context.t) (contract : Contract_repr.t)
  (cycle : Storage.Contract.Frozen_deposits.key)
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Frozen_deposits.get_option (ctxt, contract) cycle)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return Tez_repr.zero
      | Some frozen =&gt; Error_monad.__return frozen
      end).

Definition credit_frozen_deposit
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_deposits.key) (amount : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_deposit ctxt contract cycle)
    (fun old_amount =&gt;
      Error_monad.op_gtgteqquestion
        (Lwt.__return (Tez_repr.op_plusquestion old_amount amount))
        (fun new_amount =&gt;
          Error_monad.op_gtgteq
            (Storage.Contract.Frozen_deposits.init_set (ctxt, contract) cycle
              new_amount)
            (fun ctxt =&gt;
              Error_monad.op_gtgteq
                (Storage.Delegates_with_frozen_balance.add (ctxt, cycle)
                  delegate) (fun ctxt =&gt; Error_monad.__return ctxt)))).

Definition freeze_deposit
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{| Level_repr.t.cycle := cycle |} := Level_storage.current ctxt in
  Error_monad.op_gtgteqquestion (Roll_storage.Delegate.set_active ctxt delegate)
    (fun ctxt =&gt;
      let contract := Contract_repr.implicit_contract delegate in
      Error_monad.op_gtgteqquestion (Storage.Contract.Balance.get ctxt contract)
        (fun balance =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Error_monad.record_trace extensible_type_value
                (Tez_repr.op_minusquestion balance amount)))
            (fun new_balance =&gt;
              Error_monad.op_gtgteqquestion
                (Storage.Contract.Balance.set ctxt contract new_balance)
                (fun ctxt =&gt; credit_frozen_deposit ctxt delegate cycle amount)))).

Definition get_frozen_fees
  (ctxt : Raw_context.t) (contract : Contract_repr.t)
  (cycle : Storage.Contract.Frozen_fees.key)
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Frozen_fees.get_option (ctxt, contract) cycle)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return Tez_repr.zero
      | Some frozen =&gt; Error_monad.__return frozen
      end).

Definition credit_frozen_fees
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_fees.key) (amount : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_fees ctxt contract cycle)
    (fun old_amount =&gt;
      Error_monad.op_gtgteqquestion
        (Lwt.__return (Tez_repr.op_plusquestion old_amount amount))
        (fun new_amount =&gt;
          Error_monad.op_gtgteq
            (Storage.Contract.Frozen_fees.init_set (ctxt, contract) cycle
              new_amount)
            (fun ctxt =&gt;
              Error_monad.op_gtgteq
                (Storage.Delegates_with_frozen_balance.add (ctxt, cycle)
                  delegate) (fun ctxt =&gt; Error_monad.__return ctxt)))).

Definition freeze_fees
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{| Level_repr.t.cycle := cycle |} := Level_storage.current ctxt in
  Error_monad.op_gtgteqquestion
    (Roll_storage.Delegate.add_amount ctxt delegate amount)
    (fun ctxt =&gt; credit_frozen_fees ctxt delegate cycle amount).

Definition burn_fees
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_fees.key) (amount : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_fees ctxt contract cycle)
    (fun old_amount =&gt;
      Error_monad.op_gtgteqquestion
        match Tez_repr.op_minusquestion old_amount amount with
        | Pervasives.Ok new_amount =&gt;
          Error_monad.op_gtgteqquestion
            (Roll_storage.Delegate.remove_amount ctxt delegate amount)
            (fun ctxt =&gt; Error_monad.__return (new_amount, ctxt))
        | Pervasives.Error _ =&gt;
          Error_monad.op_gtgteqquestion
            (Roll_storage.Delegate.remove_amount ctxt delegate old_amount)
            (fun ctxt =&gt; Error_monad.__return (Tez_repr.zero, ctxt))
        end
        (fun function_parameter =&gt;
          let '(new_amount, ctxt) := function_parameter in
          Error_monad.op_gtgteq
            (Storage.Contract.Frozen_fees.init_set (ctxt, contract) cycle
              new_amount) (fun ctxt =&gt; Error_monad.__return ctxt))).

Definition get_frozen_rewards
  (ctxt : Raw_context.t) (contract : Contract_repr.t)
  (cycle : Storage.Contract.Frozen_rewards.key)
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Frozen_rewards.get_option (ctxt, contract) cycle)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return Tez_repr.zero
      | Some frozen =&gt; Error_monad.__return frozen
      end).

Definition credit_frozen_rewards
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_rewards.key) (amount : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_rewards ctxt contract cycle)
    (fun old_amount =&gt;
      Error_monad.op_gtgteqquestion
        (Lwt.__return (Tez_repr.op_plusquestion old_amount amount))
        (fun new_amount =&gt;
          Error_monad.op_gtgteq
            (Storage.Contract.Frozen_rewards.init_set (ctxt, contract) cycle
              new_amount)
            (fun ctxt =&gt;
              Error_monad.op_gtgteq
                (Storage.Delegates_with_frozen_balance.add (ctxt, cycle)
                  delegate) (fun ctxt =&gt; Error_monad.__return ctxt)))).

Definition freeze_rewards
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{| Level_repr.t.cycle := cycle |} := Level_storage.current ctxt in
  credit_frozen_rewards ctxt delegate cycle amount.

Definition burn_rewards
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_rewards.key) (amount : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_rewards ctxt contract cycle)
    (fun old_amount =&gt;
      let new_amount :=
        match Tez_repr.op_minusquestion old_amount amount with
        | Pervasives.Error _ =&gt; Tez_repr.zero
        | Pervasives.Ok new_amount =&gt; new_amount
        end in
      Error_monad.op_gtgteq
        (Storage.Contract.Frozen_rewards.init_set (ctxt, contract) cycle
          new_amount) (fun ctxt =&gt; Error_monad.__return ctxt)).

Definition unfreeze
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_deposits.key)
  : Lwt.t
    (Error_monad.tzresult (Raw_context.t * list (balance * balance_update))) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_deposit ctxt contract cycle)
    (fun deposit =&gt;
      Error_monad.op_gtgteqquestion (get_frozen_fees ctxt contract cycle)
        (fun fees =&gt;
          Error_monad.op_gtgteqquestion (get_frozen_rewards ctxt contract cycle)
            (fun rewards =&gt;
              Error_monad.op_gtgteqquestion
                (Storage.Contract.Balance.get ctxt contract)
                (fun balance =&gt;
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return (Tez_repr.op_plusquestion deposit fees))
                    (fun unfrozen_amount =&gt;
                      Error_monad.op_gtgteqquestion
                        (Lwt.__return
                          (Tez_repr.op_plusquestion unfrozen_amount rewards))
                        (fun unfrozen_amount =&gt;
                          Error_monad.op_gtgteqquestion
                            (Lwt.__return
                              (Tez_repr.op_plusquestion balance unfrozen_amount))
                            (fun balance =&gt;
                              Error_monad.op_gtgteqquestion
                                (Storage.Contract.Balance.set ctxt contract
                                  balance)
                                (fun ctxt =&gt;
                                  Error_monad.op_gtgteqquestion
                                    (Roll_storage.Delegate.add_amount ctxt
                                      delegate rewards)
                                    (fun ctxt =&gt;
                                      Error_monad.op_gtgteq
                                        (Storage.Contract.Frozen_deposits.remove
                                          (ctxt, contract) cycle)
                                        (fun ctxt =&gt;
                                          Error_monad.op_gtgteq
                                            (Storage.Contract.Frozen_fees.remove
                                              (ctxt, contract) cycle)
                                            (fun ctxt =&gt;
                                              Error_monad.op_gtgteq
                                                (Storage.Contract.Frozen_rewards.remove
                                                  (ctxt, contract) cycle)
                                                (fun ctxt =&gt;
                                                  Error_monad.__return
                                                    (ctxt,
                                                      (cleanup_balance_updates
                                                        (cons
                                                          ((Deposits delegate
                                                            cycle),
                                                            (Debited deposit))
                                                          (cons
                                                            ((Fees delegate
                                                              cycle),
                                                              (Debited fees))
                                                            (cons
                                                              ((Rewards delegate
                                                                cycle),
                                                                (Debited rewards))
                                                              (cons
                                                                ((Contract
                                                                  (Contract_repr.implicit_contract
                                                                    delegate)),
                                                                  (Credited
                                                                    unfrozen_amount))
                                                                [])))))))))))))))))).

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  (unrevealed : list Nonce_storage.unrevealed)
  : Lwt.t
    (Error_monad.tzresult
      (Raw_context.context * list (balance * balance_update) *
        list Storage.Active_delegates_with_rolls.elt)) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  Error_monad.op_gtgteqquestion
    match Cycle_repr.pred last_cycle with
    | None =&gt; Error_monad.__return (ctxt, [])
    | Some revealed_cycle =&gt;
      List.fold_left
        (fun acc =&gt;
          fun u =&gt;
            Error_monad.op_gtgteqquestion acc
              (fun function_parameter =&gt;
                let '(ctxt, balance_updates) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (burn_fees ctxt (Nonce_storage.unrevealed.delegate u)
                    revealed_cycle (Nonce_storage.unrevealed.fees u))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion
                      (burn_rewards ctxt (Nonce_storage.unrevealed.delegate u)
                        revealed_cycle (Nonce_storage.unrevealed.rewards u))
                      (fun ctxt =&gt;
                        let bus :=
                          cons
                            ((Fees (Nonce_storage.unrevealed.delegate u)
                              revealed_cycle),
                              (Debited (Nonce_storage.unrevealed.fees u)))
                            (cons
                              ((Rewards (Nonce_storage.unrevealed.delegate u)
                                revealed_cycle),
                                (Debited (Nonce_storage.unrevealed.rewards u)))
                              []) in
                        Error_monad.__return
                          (ctxt, (Pervasives.op_at bus balance_updates))))))
        (Error_monad.__return (ctxt, [])) unrevealed
    end
    (fun function_parameter =&gt;
      let '(ctxt, balance_updates) := function_parameter in
      match Cycle_repr.sub last_cycle preserved with
      | None =&gt; Error_monad.__return (ctxt, balance_updates, [])
      | Some unfrozen_cycle =&gt;
        Error_monad.op_gtgteqquestion
          (Storage.Delegates_with_frozen_balance.fold (ctxt, unfrozen_cycle)
            (Pervasives.Ok (ctxt, balance_updates))
            (fun delegate =&gt;
              fun acc =&gt;
                Error_monad.op_gtgteqquestion (Lwt.__return acc)
                  (fun function_parameter =&gt;
                    let '(ctxt, bus) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (unfreeze ctxt delegate unfrozen_cycle)
                      (fun function_parameter =&gt;
                        let '(ctxt, balance_updates) := function_parameter in
                        Error_monad.__return
                          (ctxt, (Pervasives.op_at balance_updates bus))))))
          (fun function_parameter =&gt;
            let '(ctxt, balance_updates) := function_parameter in
            Error_monad.op_gtgteq
              (Storage.Delegates_with_frozen_balance.clear
                (ctxt, unfrozen_cycle))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Storage.Active_delegates_with_rolls.fold ctxt
                    (Pervasives.Ok (ctxt, []))
                    (fun delegate =&gt;
                      fun acc =&gt;
                        Error_monad.op_gtgteqquestion (Lwt.__return acc)
                          (fun function_parameter =&gt;
                            let '(ctxt, deactivated) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Storage.Contract.Delegate_desactivation.get ctxt
                                (Contract_repr.implicit_contract delegate))
                              (fun cycle =&gt;
                                if Cycle_repr.op_lteq cycle last_cycle then
                                  Error_monad.op_gtgteqquestion
                                    (Roll_storage.Delegate.set_inactive ctxt
                                      delegate)
                                    (fun ctxt =&gt;
                                      Error_monad.__return
                                        (ctxt, (cons delegate deactivated)))
                                else
                                  Error_monad.__return (ctxt, deactivated)))))
                  (fun function_parameter =&gt;
                    let '(ctxt, deactivated) := function_parameter in
                    Error_monad.__return (ctxt, balance_updates, deactivated))))
      end).

Definition punish
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_deposits.key)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * frozen_balance)) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_deposit ctxt contract cycle)
    (fun deposit =&gt;
      Error_monad.op_gtgteqquestion (get_frozen_fees ctxt contract cycle)
        (fun fees =&gt;
          Error_monad.op_gtgteqquestion (get_frozen_rewards ctxt contract cycle)
            (fun rewards =&gt;
              Error_monad.op_gtgteqquestion
                (Roll_storage.Delegate.remove_amount ctxt delegate deposit)
                (fun ctxt =&gt;
                  Error_monad.op_gtgteqquestion
                    (Roll_storage.Delegate.remove_amount ctxt delegate fees)
                    (fun ctxt =&gt;
                      Error_monad.op_gtgteq
                        (Storage.Contract.Frozen_deposits.remove
                          (ctxt, contract) cycle)
                        (fun ctxt =&gt;
                          Error_monad.op_gtgteq
                            (Storage.Contract.Frozen_fees.remove
                              (ctxt, contract) cycle)
                            (fun ctxt =&gt;
                              Error_monad.op_gtgteq
                                (Storage.Contract.Frozen_rewards.remove
                                  (ctxt, contract) cycle)
                                (fun ctxt =&gt;
                                  Error_monad.__return
                                    (ctxt,
                                      {| frozen_balance.deposit := deposit;
                                        frozen_balance.fees := fees;
                                        frozen_balance.rewards := rewards |}))))))))).

Definition has_frozen_balance
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (cycle : Storage.Contract.Frozen_deposits.key)
  : Lwt.t (Error_monad.tzresult bool) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (get_frozen_deposit ctxt contract cycle)
    (fun deposit =&gt;
      if Tez_repr.op_ltgt deposit Tez_repr.zero then
        Error_monad.return_true
      else
        Error_monad.op_gtgteqquestion (get_frozen_fees ctxt contract cycle)
          (fun fees =&gt;
            if Tez_repr.op_ltgt fees Tez_repr.zero then
              Error_monad.return_true
            else
              Error_monad.op_gtgteqquestion
                (get_frozen_rewards ctxt contract cycle)
                (fun rewards =&gt;
                  Error_monad.__return (Tez_repr.op_ltgt rewards Tez_repr.zero)))).

Definition frozen_balance_by_cycle_encoding
  : Data_encoding.encoding (Cycle_repr.Map.[S.MAP.t] frozen_balance) :=
  Data_encoding.conv Cycle_repr.Map.[S.MAP.bindings]
    (List.fold_left
      (fun m =&gt;
        fun function_parameter =&gt;
          let '(c, b) := function_parameter in
          Cycle_repr.Map.[S.MAP.add] c b m) Cycle_repr.Map.[S.MAP.empty]) None
    (Data_encoding.__list_value None
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;cycle&quot; % string Cycle_repr.encoding))
        frozen_balance_encoding)).

Definition empty_frozen_balance : frozen_balance :=
  {| frozen_balance.deposit := Tez_repr.zero;
    frozen_balance.fees := Tez_repr.zero;
    frozen_balance.rewards := Tez_repr.zero |}.

Definition frozen_balance_by_cycle
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Cycle_repr.Map.[S.MAP.t] frozen_balance) :=
  let contract := Contract_repr.implicit_contract delegate in
  let map := Cycle_repr.Map.[S.MAP.empty] in
  Error_monad.op_gtgteq
    (Storage.Contract.Frozen_deposits.fold (ctxt, contract) map
      (fun cycle =&gt;
        fun amount =&gt;
          fun map =&gt;
            Lwt.__return
              (Cycle_repr.Map.[S.MAP.add] cycle
                (* ‚ùå Record substitution not handled *)
                record_substitution map)))
    (fun map =&gt;
      Error_monad.op_gtgteq
        (Storage.Contract.Frozen_fees.fold (ctxt, contract) map
          (fun cycle =&gt;
            fun amount =&gt;
              fun map =&gt;
                let balance :=
                  match Cycle_repr.Map.[S.MAP.find_opt] cycle map with
                  | None =&gt; empty_frozen_balance
                  | Some balance =&gt; balance
                  end in
                Lwt.__return
                  (Cycle_repr.Map.[S.MAP.add] cycle
                    (* ‚ùå Record substitution not handled *)
                    record_substitution map)))
        (fun map =&gt;
          Error_monad.op_gtgteq
            (Storage.Contract.Frozen_rewards.fold (ctxt, contract) map
              (fun cycle =&gt;
                fun amount =&gt;
                  fun map =&gt;
                    let balance :=
                      match Cycle_repr.Map.[S.MAP.find_opt] cycle map with
                      | None =&gt; empty_frozen_balance
                      | Some balance =&gt; balance
                      end in
                    Lwt.__return
                      (Cycle_repr.Map.[S.MAP.add] cycle
                        (* ‚ùå Record substitution not handled *)
                        record_substitution map))) (fun map =&gt; Lwt.__return map))).

Definition frozen_balance
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Pervasives.result Tez_repr.t (list Error_monad.__error)) :=
  let contract := Contract_repr.implicit_contract delegate in
  let balance := Pervasives.Ok Tez_repr.zero in
  Error_monad.op_gtgteq
    (Storage.Contract.Frozen_deposits.fold (ctxt, contract) balance
      (fun _cycle =&gt;
        fun amount =&gt;
          fun acc =&gt;
            Error_monad.op_gtgteqquestion (Lwt.__return acc)
              (fun acc =&gt; Lwt.__return (Tez_repr.op_plusquestion acc amount))))
    (fun balance =&gt;
      Error_monad.op_gtgteq
        (Storage.Contract.Frozen_fees.fold (ctxt, contract) balance
          (fun _cycle =&gt;
            fun amount =&gt;
              fun acc =&gt;
                Error_monad.op_gtgteqquestion (Lwt.__return acc)
                  (fun acc =&gt; Lwt.__return (Tez_repr.op_plusquestion acc amount))))
        (fun balance =&gt;
          Error_monad.op_gtgteq
            (Storage.Contract.Frozen_rewards.fold (ctxt, contract) balance
              (fun _cycle =&gt;
                fun amount =&gt;
                  fun acc =&gt;
                    Error_monad.op_gtgteqquestion (Lwt.__return acc)
                      (fun acc =&gt;
                        Lwt.__return (Tez_repr.op_plusquestion acc amount))))
            (fun balance =&gt; Lwt.__return balance))).

Definition full_balance
  (ctxt : Raw_context.t)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (frozen_balance ctxt delegate)
    (fun frozen_balance =&gt;
      Error_monad.op_gtgteqquestion (Storage.Contract.Balance.get ctxt contract)
        (fun balance =&gt;
          Lwt.__return (Tez_repr.op_plusquestion frozen_balance balance))).

Definition deactivated
  : Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult bool) := Roll_storage.Delegate.is_inactive.

Definition grace_period
  (ctxt : Storage.Contract.Delegate_desactivation.context)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Storage.Contract.Delegate_desactivation.value) :=
  let contract := Contract_repr.implicit_contract delegate in
  Storage.Contract.Delegate_desactivation.get ctxt contract.

Definition staking_balance
  (ctxt : Raw_context.context)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let token_per_rolls := Constants_storage.tokens_per_roll ctxt in
  Error_monad.op_gtgteqquestion (Roll_storage.get_rolls ctxt delegate)
    (fun rolls =&gt;
      Error_monad.op_gtgteqquestion (Roll_storage.get_change ctxt delegate)
        (fun change =&gt;
          let rolls := Int64.of_int (List.length rolls) in
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Tez_repr.op_starquestion token_per_rolls rolls))
            (fun balance =&gt;
              Lwt.__return (Tez_repr.op_plusquestion balance change)))).

Definition delegated_balance
  (ctxt : Raw_context.context)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  Error_monad.op_gtgteqquestion (staking_balance ctxt delegate)
    (fun staking_balance =&gt;
      Error_monad.op_gtgteq (Storage.Contract.Balance.get ctxt contract)
        (fun self_staking_balance =&gt;
          Error_monad.op_gtgteq
            (Storage.Contract.Frozen_deposits.fold (ctxt, contract)
              self_staking_balance
              (fun _cycle =&gt;
                fun amount =&gt;
                  fun acc =&gt;
                    Error_monad.op_gtgteqquestion (Lwt.__return acc)
                      (fun acc =&gt;
                        Lwt.__return (Tez_repr.op_plusquestion acc amount))))
            (fun self_staking_balance =&gt;
              Error_monad.op_gtgteqquestion
                (Storage.Contract.Frozen_fees.fold (ctxt, contract)
                  self_staking_balance
                  (fun _cycle =&gt;
                    fun amount =&gt;
                      fun acc =&gt;
                        Error_monad.op_gtgteqquestion (Lwt.__return acc)
                          (fun acc =&gt;
                            Lwt.__return (Tez_repr.op_plusquestion acc amount))))
                (fun self_staking_balance =&gt;
                  Lwt.__return
                    (Tez_repr.op_minusquestion staking_balance
                      self_staking_balance))))).

Definition fold {A : Set}
  : Storage.Delegates.context -&gt; A -&gt; (Storage.Delegates.elt -&gt; A -&gt; Lwt.t A) -&gt;
  Lwt.t A := Storage.Delegates.fold.

Definition __list_value
  : Storage.Delegates.context -&gt; Lwt.t (list Storage.Delegates.elt) :=
  Storage.Delegates.elements.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_storage.mli">
  <div class="col-md-6">
    <a href="#delegate_storage.mli"><code>delegate_storage.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Places where tezzies can be found in the ledger's state. *)
type balance =
  | Contract of Contract_repr.t
  | Rewards of Signature.Public_key_hash.t * Cycle_repr.t
  | Fees of Signature.Public_key_hash.t * Cycle_repr.t
  | Deposits of Signature.Public_key_hash.t * Cycle_repr.t

(** A credit or debit of tezzies to a balance. *)
type balance_update = Debited of Tez_repr.t | Credited of Tez_repr.t

(** A list of balance updates. Duplicates may happen. *)
type balance_updates = (balance * balance_update) list

val balance_updates_encoding : balance_updates Data_encoding.t

(** Remove zero-valued balances from a list of updates. *)
val cleanup_balance_updates : balance_updates -&gt; balance_updates

type frozen_balance = {
  deposit : Tez_repr.t;
  fees : Tez_repr.t;
  rewards : Tez_repr.t;
}

(** Allow to register a delegate when creating an account. *)
val init :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Raw_context.t tzresult Lwt.t

(** Cleanup delegation when deleting a contract. *)
val remove : Raw_context.t -&gt; Contract_repr.t -&gt; Raw_context.t tzresult Lwt.t

(** Reading the current delegate of a contract. *)
val get :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t option tzresult Lwt.t

val registered :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

(** Updating the delegate of a contract.

    When calling this function on an &quot;implicit contract&quot; and setting
    the delegate to the contract manager registers it as a delegate. One
    cannot unregister a delegate for now. The associate contract is now
    'undeletable'. *)
val set :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t option -&gt;
  Raw_context.t tzresult Lwt.t

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | No_deletion of Signature.Public_key_hash.t (* `Permanent *)
  | Active_delegate (* `Temporary *)
  | Current_delegate (* `Temporary *)
  | Empty_delegate_account of Signature.Public_key_hash.t (* `Temporary *)
  | Balance_too_low_for_deposit of {
      delegate : Signature.Public_key_hash.t;
      deposit : Tez_repr.t;
      balance : Tez_repr.t;
    }</abbr>

(* `Temporary *)

(** Iterate on all registered delegates. *)
val fold :
  Raw_context.t -&gt;
  init:'a -&gt;
  f:(Signature.Public_key_hash.t -&gt; 'a -&gt; 'a Lwt.t) -&gt;
  'a Lwt.t

(** List all registered delegates. *)
val list : Raw_context.t -&gt; Signature.Public_key_hash.t list Lwt.t

(** Various functions to 'freeze' tokens.  A frozen 'deposit' keeps its
    associated rolls. When frozen, 'fees' may trigger new rolls
    allocation. Rewards won't trigger new rolls allocation until
    unfrozen. *)
val freeze_deposit :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val freeze_fees :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val freeze_rewards :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

(** Trigger the context maintenance at the end of cycle 'n', i.e.:
    unfreeze deposit/fees/rewards from 'n - preserved_cycle' ; punish the
    provided unrevealed seeds (tipically seed from cycle 'n - 1').
    Returns a list of account with the amount that was unfrozen for each
    and the list of deactivated delegates. *)
val cycle_end :
  Raw_context.t -&gt;
  Cycle_repr.t -&gt;
  Nonce_storage.unrevealed list -&gt;
  (Raw_context.t * balance_updates * Signature.Public_key_hash.t list) tzresult
  Lwt.t

(** Burn all then frozen deposit/fees/rewards for a delegate at a given
    cycle. Returns the burned amounts. *)
val punish :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Cycle_repr.t -&gt;
  (Raw_context.t * frozen_balance) tzresult Lwt.t

(** Has the given key some frozen tokens in its implicit contract? *)
val has_frozen_balance :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Cycle_repr.t -&gt;
  bool tzresult Lwt.t

(** Returns the amount of frozen deposit, fees and rewards associated
    to a given delegate. *)
val frozen_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val frozen_balance_encoding : frozen_balance Data_encoding.t

val frozen_balance_by_cycle_encoding :
  frozen_balance Cycle_repr.Map.t Data_encoding.t

(** Returns the amount of frozen deposit, fees and rewards associated
    to a given delegate, indexed by the cycle by which at the end the
    balance will be unfrozen. *)
val frozen_balance_by_cycle :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  frozen_balance Cycle_repr.Map.t Lwt.t

(** Returns the full 'balance' of the implicit contract associated to
    a given key, i.e. the sum of the spendable balance and of the
    frozen balance. *)
val full_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val staking_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

(** Returns the list of contracts (implicit or originated) that delegated towards a given delegate *)
val delegated_contracts :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Contract_repr.t list Lwt.t

val delegated_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val deactivated :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

val grace_period :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Cycle_repr.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_storage.mli"><code>Delegate_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Nonce_storage.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

Inductive balance : Set :=
| Contract : Contract_repr.t -&gt; balance
| Rewards :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle_repr.t -&gt; balance
| Fees :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle_repr.t -&gt; balance
| Deposits :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Cycle_repr.t -&gt; balance.

Inductive balance_update : Set :=
| Debited : Tez_repr.t -&gt; balance_update
| Credited : Tez_repr.t -&gt; balance_update.

Definition balance_updates := list (balance * balance_update).

Parameter balance_updates_encoding : Data_encoding.t balance_updates.

Parameter cleanup_balance_updates : balance_updates -&gt; balance_updates.

Module frozen_balance.
  Record record := {
    deposit : Tez_repr.t;
    fees : Tez_repr.t;
    rewards : Tez_repr.t }.
End frozen_balance.
Definition frozen_balance := frozen_balance.record.

Parameter init :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter remove :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      (option Signature.Public_key_hash.[S.SPublic_key_hash.t])).

Parameter registered :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult bool).

Parameter set :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  option Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter fold : forall {a : Set},
  Raw_context.t -&gt; a -&gt;
  (Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.

Parameter __list_value :
  Raw_context.t -&gt; Lwt.t (list Signature.Public_key_hash.[S.SPublic_key_hash.t]).

Parameter freeze_deposit :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter freeze_fees :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter freeze_rewards :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt; list Nonce_storage.unrevealed -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Raw_context.t * balance_updates *
        list Signature.Public_key_hash.[S.SPublic_key_hash.t])).

Parameter punish :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * frozen_balance)).

Parameter has_frozen_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult bool).

Parameter frozen_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter frozen_balance_encoding : Data_encoding.t frozen_balance.

Parameter frozen_balance_by_cycle_encoding :
  Data_encoding.t (Cycle_repr.Map.[S.MAP.t] frozen_balance).

Parameter frozen_balance_by_cycle :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Cycle_repr.Map.[S.MAP.t] frozen_balance).

Parameter full_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter staking_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter delegated_contracts :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (list Contract_repr.t).

Parameter delegated_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter deactivated :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult bool).

Parameter grace_period :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Cycle_repr.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fees_storage.ml">
  <div class="col-md-6">
    <a href="#fees_storage.ml"><code>fees_storage.ml</code></a>&nbsp;<span class="label label-danger">7 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Cannot_pay_storage_fee</abbr> (* `Temporary *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Storage_limit_too_high</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  register_error_kind
    `Temporary
    ~id:&quot;contract.cannot_pay_storage_fee&quot;
    ~title:&quot;Cannot pay storage fee&quot;
    ~description:&quot;The storage fee is higher than the contract balance&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Cannot pay storage storage fee&quot;)
    Data_encoding.empty
    (function Cannot_pay_storage_fee -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_pay_storage_fee) ;
  register_error_kind
    `Temporary
    ~id:&quot;storage_exhausted.operation&quot;
    ~title:&quot;Storage quota exceeded for the operation&quot;
    ~description:
      &quot;A script or one of its callee wrote more bytes than the operation said \
       it would&quot;
    Data_encoding.empty
    (function Operation_quota_exceeded -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Operation_quota_exceeded) ;
  register_error_kind
    `Permanent
    ~id:&quot;storage_limit_too_high&quot;
    ~title:&quot;Storage limit out of protocol hard bounds&quot;
    ~description:&quot;A transaction tried to exceed the hard limit on storage&quot;
    empty
    (function Storage_limit_too_high -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Storage_limit_too_high)</abbr>

let origination_burn c =
  let origination_size = Constants_storage.origination_size c in
  let cost_per_byte = Constants_storage.cost_per_byte c in
  (* the origination burn, measured in bytes *)
  Lwt.return Tez_repr.(cost_per_byte *? Int64.of_int origination_size)
  &gt;&gt;=? fun to_be_paid -&gt;
  return (Raw_context.update_allocated_contracts_count c, to_be_paid)

let record_paid_storage_space c contract =
  Contract_storage.used_storage_space c contract
  &gt;&gt;=? fun size -&gt;
  Contract_storage.set_paid_storage_space_and_return_fees_to_pay
    c
    contract
    size
  &gt;&gt;=? fun (to_be_paid, c) -&gt;
  let c = Raw_context.update_storage_space_to_pay c to_be_paid in
  let cost_per_byte = Constants_storage.cost_per_byte c in
  Lwt.return Tez_repr.(cost_per_byte *? Z.to_int64 to_be_paid)
  &gt;&gt;=? fun to_burn -&gt; return (c, size, to_be_paid, to_burn)

let burn_storage_fees c ~storage_limit ~payer =
  let origination_size = Constants_storage.origination_size c in
  let (c, storage_space_to_pay, allocated_contracts) =
    Raw_context.clear_storage_space_to_pay c
  in
  let storage_space_for_allocated_contracts =
    Z.mul (Z.of_int allocated_contracts) (Z.of_int origination_size)
  in
  let consumed =
    Z.add storage_space_to_pay storage_space_for_allocated_contracts
  in
  let remaining = Z.sub storage_limit consumed in
  if Compare.Z.(remaining &lt; Z.zero) then fail <abbr class="mark-error" title="Values of extensible types are not handled">Operation_quota_exceeded</abbr>
  else
    let cost_per_byte = Constants_storage.cost_per_byte c in
    Lwt.return Tez_repr.(cost_per_byte *? Z.to_int64 consumed)
    &gt;&gt;=? fun to_burn -&gt;
    (* Burning the fees... *)
    if Tez_repr.(to_burn = Tez_repr.zero) then
      (* If the payer was was deleted by transfering all its balance, and no space was used,
         burning zero would fail *)
      return c
    else
      trace
        <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_pay_storage_fee</abbr>
        ( Contract_storage.must_exist c payer
        &gt;&gt;=? fun () -&gt; Contract_storage.spend c payer to_burn )
      &gt;&gt;=? fun c -&gt; return c

let check_storage_limit c ~storage_limit =
  if
    Compare.Z.(
      storage_limit
      &gt; (Raw_context.constants c).hard_storage_limit_per_operation)
    || Compare.Z.(storage_limit &lt; Z.zero)
  then error <abbr class="mark-error" title="Values of extensible types are not handled">Storage_limit_too_high</abbr>
  else ok ()

let start_counting_storage_fees c = Raw_context.init_storage_space_to_pay c
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fees_storage.ml"><code>Fees_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Contract_storage.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition origination_burn (c : Raw_context.context)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * Tez_repr.t)) :=
  let origination_size := Constants_storage.origination_size c in
  let cost_per_byte := Constants_storage.cost_per_byte c in
  Error_monad.op_gtgteqquestion
    (Lwt.__return
      (Tez_repr.op_starquestion cost_per_byte (Int64.of_int origination_size)))
    (fun to_be_paid =&gt;
      Error_monad.__return
        ((Raw_context.update_allocated_contracts_count c), to_be_paid)).

Definition record_paid_storage_space
  (c : Raw_context.t) (contract : Contract_repr.t)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t * Z.t * Tez_repr.t)) :=
  Error_monad.op_gtgteqquestion (Contract_storage.used_storage_space c contract)
    (fun size =&gt;
      Error_monad.op_gtgteqquestion
        (Contract_storage.set_paid_storage_space_and_return_fees_to_pay c
          contract size)
        (fun function_parameter =&gt;
          let '(to_be_paid, c) := function_parameter in
          let c := Raw_context.update_storage_space_to_pay c to_be_paid in
          let cost_per_byte := Constants_storage.cost_per_byte c in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Tez_repr.op_starquestion cost_per_byte (Z.to_int64 to_be_paid)))
            (fun to_burn =&gt; Error_monad.__return (c, size, to_be_paid, to_burn)))).

Definition burn_storage_fees
  (c : Raw_context.context) (storage_limit : Z.t) (payer : Contract_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let origination_size := Constants_storage.origination_size c in
  let '(c, storage_space_to_pay, allocated_contracts) :=
    Raw_context.clear_storage_space_to_pay c in
  let storage_space_for_allocated_contracts :=
    Z.mul (Z.of_int allocated_contracts) (Z.of_int origination_size) in
  let consumed :=
    Z.add storage_space_to_pay storage_space_for_allocated_contracts in
  let remaining := Z.sub storage_limit consumed in
  if Compare.Z.[Compare.S.op_lt] remaining Z.zero then
    Error_monad.fail extensible_type_value
  else
    let cost_per_byte := Constants_storage.cost_per_byte c in
    Error_monad.op_gtgteqquestion
      (Lwt.__return
        (Tez_repr.op_starquestion cost_per_byte (Z.to_int64 consumed)))
      (fun to_burn =&gt;
        if Tez_repr.op_eq to_burn Tez_repr.zero then
          Error_monad.__return c
        else
          Error_monad.op_gtgteqquestion
            (Error_monad.trace extensible_type_value
              (Error_monad.op_gtgteqquestion
                (Contract_storage.must_exist c payer)
                (fun function_parameter =&gt;
                  let 'tt := function_parameter in
                  Contract_storage.spend c payer to_burn)))
            (fun c =&gt; Error_monad.__return c)).

Definition check_storage_limit
  (c : Raw_context.context) (storage_limit : Compare.Z.[Compare.S.t])
  : Error_monad.tzresult unit :=
  if
    Pervasives.op_pipepipe
      (Compare.Z.[Compare.S.op_gt] storage_limit
        (Constants_repr.parametric.hard_storage_limit_per_operation
          (Raw_context.constants c)))
      (Compare.Z.[Compare.S.op_lt] storage_limit Z.zero) then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok tt.

Definition start_counting_storage_fees (c : Raw_context.t) : Raw_context.t :=
  Raw_context.init_storage_space_to_pay c.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fees_storage.mli">
  <div class="col-md-6">
    <a href="#fees_storage.mli"><code>fees_storage.mli</code></a>&nbsp;<span class="label label-danger">3 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Cannot_pay_storage_fee</abbr> (* `Temporary *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Storage_limit_too_high</abbr> (* `Permanent *)

(** Does not burn, only adds the burn to storage space to be paid *)
val origination_burn :
  Raw_context.t -&gt; (Raw_context.t * Tez_repr.t) tzresult Lwt.t

(** The returned Tez quantity is for logging purpose only *)
val record_paid_storage_space :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Z.t * Z.t * Tez_repr.t) tzresult Lwt.t

val check_storage_limit : Raw_context.t -&gt; storage_limit:Z.t -&gt; unit tzresult

val start_counting_storage_fees : Raw_context.t -&gt; Raw_context.t

val burn_storage_fees :
  Raw_context.t -&gt;
  storage_limit:Z.t -&gt;
  payer:Contract_repr.t -&gt;
  Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fees_storage.mli"><code>Fees_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_repr.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter origination_burn :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Tez_repr.t)).

Parameter record_paid_storage_space :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t * Z.t * Tez_repr.t)).

Parameter check_storage_limit :
  Raw_context.t -&gt; Z.t -&gt; Error_monad.tzresult unit.

Parameter start_counting_storage_fees : Raw_context.t -&gt; Raw_context.t.

Parameter burn_storage_fees :
  Raw_context.t -&gt; Z.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fitness_repr.ml">
  <div class="col-md-6">
    <a href="#fitness_repr.ml"><code>fitness_repr.ml</code></a>&nbsp;<span class="label label-danger">5 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_fitness</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;invalid_fitness&quot;
    ~title:&quot;Invalid fitness&quot;
    ~description:&quot;Fitness representation should be exactly 8 bytes long.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid fitness&quot;)
    Data_encoding.empty
    (function Invalid_fitness -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_fitness)</abbr>

let int64_to_bytes i =
  let b = MBytes.create 8 in
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">MBytes.set_int64 b 0 i ; b</abbr>

let int64_of_bytes b =
  if Compare.Int.(MBytes.length b &lt;&gt; 8) then error <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_fitness</abbr>
  else ok (MBytes.get_int64 b 0)

let from_int64 fitness =
  [MBytes.of_string Constants_repr.version_number; int64_to_bytes fitness]

let to_int64 = function
  | [version; fitness]
    when Compare.String.(
           MBytes.to_string version = Constants_repr.version_number) -&gt;
      int64_of_bytes fitness
  | [version; _fitness (* ignored since higher version takes priority *)]
    when Compare.String.(
           MBytes.to_string version = Constants_repr.version_number_004) -&gt;
      ok 0L
  | [] -&gt;
      ok 0L
  | _ -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_fitness</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fitness_repr.ml"><code>Fitness_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition int64_to_bytes (i : int64) : MBytes.t :=
  let b := MBytes.create 8 in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  b.

Definition int64_of_bytes (b : MBytes.t) : Error_monad.tzresult int64 :=
  if Compare.Int.[Compare.S.op_ltgt] (MBytes.length b) 8 then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok (MBytes.get_int64 b 0).

Definition from_int64 (fitness : int64) : list MBytes.t :=
  cons (MBytes.of_string Constants_repr.version_number)
    (cons (int64_to_bytes fitness) []).

Definition to_int64 (function_parameter : list MBytes.t)
  : Error_monad.tzresult int64 :=
  match
    (function_parameter,
      match function_parameter with
      | cons version (cons fitness []) =&gt;
        Compare.String.[Compare.S.op_eq] (MBytes.to_string version)
          Constants_repr.version_number
      | _ =&gt; false
      end,
      match function_parameter with
      | cons version (cons _fitness []) =&gt;
        Compare.String.[Compare.S.op_eq] (MBytes.to_string version)
          Constants_repr.version_number_004
      | _ =&gt; false
      end) with
  | (cons version (cons fitness []), true, _) =&gt; int64_of_bytes fitness
  | (cons version (cons _fitness []), _, true) =&gt;
    Error_monad.ok
      (* ‚ùå Constant of type int64 is converted to int *)
      0
  | ([], _, _) =&gt;
    Error_monad.ok
      (* ‚ùå Constant of type int64 is converted to int *)
      0
  | (_, _, _) =&gt; Error_monad.__error_value extensible_type_value
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fitness_storage.ml">
  <div class="col-md-6">
    <a href="#fitness_storage.ml"><code>fitness_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let current = Raw_context.current_fitness

let increase ?(gap = 1) ctxt =
  let fitness = current ctxt in
  Raw_context.set_current_fitness ctxt (Int64.add (Int64.of_int gap) fitness)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fitness_storage.ml"><code>Fitness_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Raw_context.

Definition current : Raw_context.context -&gt; Int64.t :=
  Raw_context.current_fitness.

Definition increase (op_staroptstar : option Z)
  : Raw_context.context -&gt; Raw_context.t :=
  let gap :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; 1
    end in
  fun ctxt =&gt;
    let fitness := current ctxt in
    Raw_context.set_current_fitness ctxt (Int64.add (Int64.of_int gap) fitness).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="gas_limit_repr.ml">
  <div class="col-md-6">
    <a href="#gas_limit_repr.ml"><code>gas_limit_repr.ml</code></a>&nbsp;<span class="label label-danger">5 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Unaccounted | Limited of {remaining : Z.t}

type internal_gas = Z.t

type cost = {
  allocations : Z.t;
  steps : Z.t;
  reads : Z.t;
  writes : Z.t;
  bytes_read : Z.t;
  bytes_written : Z.t;
}

let encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;Limited&quot;
        z
        (function Limited {remaining} -&gt; Some remaining | _ -&gt; None)
        (fun remaining -&gt; Limited {remaining});
      case
        (Tag 1)
        ~title:&quot;Unaccounted&quot;
        (constant &quot;unaccounted&quot;)
        (function Unaccounted -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Unaccounted) ]

let pp ppf = function
  | Unaccounted -&gt;
      Format.fprintf ppf &quot;unaccounted&quot;
  | Limited {remaining} -&gt;
      Format.fprintf ppf &quot;%s units remaining&quot; (Z.to_string remaining)

let cost_encoding =
  let open Data_encoding in
  conv
    (fun {allocations; steps; reads; writes; bytes_read; bytes_written} -&gt;
      (allocations, steps, reads, writes, bytes_read, bytes_written))
    (fun (allocations, steps, reads, writes, bytes_read, bytes_written) -&gt;
      {allocations; steps; reads; writes; bytes_read; bytes_written})
    (obj6
       (req &quot;allocations&quot; z)
       (req &quot;steps&quot; z)
       (req &quot;reads&quot; z)
       (req &quot;writes&quot; z)
       (req &quot;bytes_read&quot; z)
       (req &quot;bytes_written&quot; z))

let pp_cost ppf {allocations; steps; reads; writes; bytes_read; bytes_written}
    =
  Format.fprintf
    ppf
    &quot;(steps: %s, allocs: %s, reads: %s (%s bytes), writes: %s (%s bytes))&quot;
    (Z.to_string steps)
    (Z.to_string allocations)
    (Z.to_string reads)
    (Z.to_string bytes_read)
    (Z.to_string writes)
    (Z.to_string bytes_written)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Block_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

let allocation_weight = Z.of_int 2

let step_weight = Z.of_int 1

let read_base_weight = Z.of_int 100

let write_base_weight = Z.of_int 160

let byte_read_weight = Z.of_int 10

let byte_written_weight = Z.of_int 15

let rescaling_bits = 7

let rescaling_mask = Z.sub (Z.shift_left Z.one rescaling_bits) Z.one

let scale (z : Z.t) = Z.shift_left z rescaling_bits

let rescale (z : Z.t) = Z.shift_right z rescaling_bits

let cost_to_internal_gas (cost : cost) : internal_gas =
  Z.add
    (Z.add
       (Z.mul cost.allocations allocation_weight)
       (Z.mul cost.steps step_weight))
    (Z.add
       (Z.add
          (Z.mul cost.reads read_base_weight)
          (Z.mul cost.writes write_base_weight))
       (Z.add
          (Z.mul cost.bytes_read byte_read_weight)
          (Z.mul cost.bytes_written byte_written_weight)))

let internal_gas_to_gas internal_gas : Z.t * internal_gas =
  let gas = rescale internal_gas in
  let rest = Z.logand internal_gas rescaling_mask in
  (gas, rest)

let consume block_gas operation_gas internal_gas cost =
  match operation_gas with
  | Unaccounted -&gt;
      ok (block_gas, Unaccounted, internal_gas)
  | Limited {remaining} -&gt;
      let cost_internal_gas = cost_to_internal_gas cost in
      let total_internal_gas = Z.add cost_internal_gas internal_gas in
      let (gas, rest) = internal_gas_to_gas total_internal_gas in
      if Compare.Z.(gas &gt; Z.zero) then
        let remaining = Z.sub remaining gas in
        let block_remaining = Z.sub block_gas gas in
        if Compare.Z.(remaining &lt; Z.zero) then error <abbr class="mark-error" title="Values of extensible types are not handled">Operation_quota_exceeded</abbr>
        else if Compare.Z.(block_remaining &lt; Z.zero) then
          error <abbr class="mark-error" title="Values of extensible types are not handled">Block_quota_exceeded</abbr>
        else ok (block_remaining, Limited {remaining}, rest)
      else ok (block_gas, operation_gas, total_internal_gas)

let check_enough block_gas operation_gas internal_gas cost =
  consume block_gas operation_gas internal_gas cost
  &gt;|? fun (_block_remainig, _remaining, _internal_gas) -&gt; ()

let internal_gas_zero : internal_gas = Z.zero

let alloc_cost n =
  {
    allocations = scale (Z.of_int (n + 1));
    steps = Z.zero;
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let alloc_bytes_cost n = alloc_cost ((n + 7) / 8)

let alloc_bits_cost n = alloc_cost ((n + 63) / 64)

let atomic_step_cost n =
  {
    allocations = Z.zero;
    steps = Z.of_int (2 * n);
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let step_cost n =
  {
    allocations = Z.zero;
    steps = scale (Z.of_int n);
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let free =
  {
    allocations = Z.zero;
    steps = Z.zero;
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let read_bytes_cost n =
  {
    allocations = Z.zero;
    steps = Z.zero;
    reads = scale Z.one;
    writes = Z.zero;
    bytes_read = scale n;
    bytes_written = Z.zero;
  }

let write_bytes_cost n =
  {
    allocations = Z.zero;
    steps = Z.zero;
    reads = Z.zero;
    writes = Z.one;
    bytes_read = Z.zero;
    bytes_written = scale n;
  }

let ( +@ ) x y =
  {
    allocations = Z.add x.allocations y.allocations;
    steps = Z.add x.steps y.steps;
    reads = Z.add x.reads y.reads;
    writes = Z.add x.writes y.writes;
    bytes_read = Z.add x.bytes_read y.bytes_read;
    bytes_written = Z.add x.bytes_written y.bytes_written;
  }

let ( *@ ) x y =
  {
    allocations = Z.mul (Z.of_int x) y.allocations;
    steps = Z.mul (Z.of_int x) y.steps;
    reads = Z.mul (Z.of_int x) y.reads;
    writes = Z.mul (Z.of_int x) y.writes;
    bytes_read = Z.mul (Z.of_int x) y.bytes_read;
    bytes_written = Z.mul (Z.of_int x) y.bytes_written;
  }

let alloc_mbytes_cost n = alloc_cost 12 +@ alloc_bytes_cost n

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  register_error_kind
    `Temporary
    ~id:&quot;gas_exhausted.operation&quot;
    ~title:&quot;Gas quota exceeded for the operation&quot;
    ~description:
      &quot;A script or one of its callee took more time than the operation said \
       it would&quot;
    empty
    (function Operation_quota_exceeded -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Operation_quota_exceeded) ;
  register_error_kind
    `Temporary
    ~id:&quot;gas_exhausted.block&quot;
    ~title:&quot;Gas quota exceeded for the block&quot;
    ~description:
      &quot;The sum of gas consumed by all the operations in the block exceeds the \
       hard gas limit per block&quot;
    empty
    (function Block_quota_exceeded -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Block_quota_exceeded)</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#gas_limit_repr.ml"><code>Gas_limit_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Module t.
  Module Limited.
    Record record {remaining : Set} := {
      remaining : remaining }.
    Arguments record : clear implicits.
  End Limited.
  Definition Limited := Limited.record.
End t.

Inductive t : Set :=
| Unaccounted : t
| Limited : t.Limited Z.t -&gt; t.

Definition internal_gas := Z.t.

Module cost.
  Record record := {
    allocations : Z.t;
    steps : Z.t;
    reads : Z.t;
    writes : Z.t;
    bytes_read : Z.t;
    bytes_written : Z.t }.
End cost.
Definition cost := cost.record.

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.union None
    (cons
      (Data_encoding.__case_value &quot;Limited&quot; % string None (Data_encoding.Tag 0)
        Data_encoding.z
        (fun function_parameter =&gt;
          match function_parameter with
          | Limited {| t.Limited.remaining := remaining |} =&gt; Some remaining
          | _ =&gt; None
          end) (fun remaining =&gt; Limited {| t.Limited.remaining := remaining |}))
      (cons
        (Data_encoding.__case_value &quot;Unaccounted&quot; % string None
          (Data_encoding.Tag 1) (Data_encoding.constant &quot;unaccounted&quot; % string)
          (fun function_parameter =&gt;
            match function_parameter with
            | Unaccounted =&gt; Some tt
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Unaccounted)) [])).

Definition pp (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Unaccounted =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;unaccounted&quot; % string
          CamlinternalFormatBasics.End_of_format) &quot;unaccounted&quot; % string)
  | Limited {| t.Limited.remaining := remaining |} =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot; units remaining&quot; % string
            CamlinternalFormatBasics.End_of_format))
        &quot;%s units remaining&quot; % string) (Z.to_string remaining)
  end.

Definition cost_encoding : Data_encoding.encoding cost :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        cost.allocations := allocations;
          cost.steps := steps;
          cost.reads := reads;
          cost.writes := writes;
          cost.bytes_read := bytes_read;
          cost.bytes_written := bytes_written
          |} := function_parameter in
      (allocations, steps, reads, writes, bytes_read, bytes_written))
    (fun function_parameter =&gt;
      let '(allocations, steps, reads, writes, bytes_read, bytes_written) :=
        function_parameter in
      {| cost.allocations := allocations; cost.steps := steps;
        cost.reads := reads; cost.writes := writes;
        cost.bytes_read := bytes_read; cost.bytes_written := bytes_written |})
    None
    (Data_encoding.obj6
      (Data_encoding.req None None &quot;allocations&quot; % string Data_encoding.z)
      (Data_encoding.req None None &quot;steps&quot; % string Data_encoding.z)
      (Data_encoding.req None None &quot;reads&quot; % string Data_encoding.z)
      (Data_encoding.req None None &quot;writes&quot; % string Data_encoding.z)
      (Data_encoding.req None None &quot;bytes_read&quot; % string Data_encoding.z)
      (Data_encoding.req None None &quot;bytes_written&quot; % string Data_encoding.z)).

Definition pp_cost (ppf : Format.formatter) (function_parameter : cost)
  : unit :=
  let '{|
    cost.allocations := allocations;
      cost.steps := steps;
      cost.reads := reads;
      cost.writes := writes;
      cost.bytes_read := bytes_read;
      cost.bytes_written := bytes_written
      |} := function_parameter in
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;(steps: &quot; % string
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;, allocs: &quot; % string
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot;, reads: &quot; % string
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.String_literal &quot; (&quot; % string
                    (CamlinternalFormatBasics.String
                      CamlinternalFormatBasics.No_padding
                      (CamlinternalFormatBasics.String_literal
                        &quot; bytes), writes: &quot; % string
                        (CamlinternalFormatBasics.String
                          CamlinternalFormatBasics.No_padding
                          (CamlinternalFormatBasics.String_literal &quot; (&quot; % string
                            (CamlinternalFormatBasics.String
                              CamlinternalFormatBasics.No_padding
                              (CamlinternalFormatBasics.String_literal
                                &quot; bytes))&quot; % string
                                CamlinternalFormatBasics.End_of_format)))))))))))))
      &quot;(steps: %s, allocs: %s, reads: %s (%s bytes), writes: %s (%s bytes))&quot; %
        string) (Z.to_string steps) (Z.to_string allocations)
    (Z.to_string reads) (Z.to_string bytes_read) (Z.to_string writes)
    (Z.to_string bytes_written).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

Definition allocation_weight : Z.t := Z.of_int 2.

Definition step_weight : Z.t := Z.of_int 1.

Definition read_base_weight : Z.t := Z.of_int 100.

Definition write_base_weight : Z.t := Z.of_int 160.

Definition byte_read_weight : Z.t := Z.of_int 10.

Definition byte_written_weight : Z.t := Z.of_int 15.

Definition rescaling_bits : Z := 7.

Definition rescaling_mask : Z.t :=
  Z.sub (Z.shift_left Z.one rescaling_bits) Z.one.

Definition scale (z : Z.t) : Z.t := Z.shift_left z rescaling_bits.

Definition rescale (z : Z.t) : Z.t := Z.shift_right z rescaling_bits.

Definition cost_to_internal_gas (cost : cost) : internal_gas :=
  Z.add
    (Z.add (Z.mul (cost.allocations cost) allocation_weight)
      (Z.mul (cost.steps cost) step_weight))
    (Z.add
      (Z.add (Z.mul (cost.reads cost) read_base_weight)
        (Z.mul (cost.writes cost) write_base_weight))
      (Z.add (Z.mul (cost.bytes_read cost) byte_read_weight)
        (Z.mul (cost.bytes_written cost) byte_written_weight))).

Definition internal_gas_to_gas (__internal_gas_value : Z.t)
  : Z.t * internal_gas :=
  let gas := rescale __internal_gas_value in
  let rest := Z.logand __internal_gas_value rescaling_mask in
  (gas, rest).

Definition consume
  (block_gas : Z.t) (operation_gas : t) (__internal_gas_value : Z.t)
  (cost : cost) : Error_monad.tzresult (Z.t * t * Z.t) :=
  match operation_gas with
  | Unaccounted =&gt; Error_monad.ok (block_gas, Unaccounted, __internal_gas_value)
  | Limited {| t.Limited.remaining := remaining |} =&gt;
    let cost_internal_gas := cost_to_internal_gas cost in
    let total_internal_gas := Z.add cost_internal_gas __internal_gas_value in
    let '(gas, rest) := internal_gas_to_gas total_internal_gas in
    if Compare.Z.[Compare.S.op_gt] gas Z.zero then
      let remaining := Z.sub remaining gas in
      let block_remaining := Z.sub block_gas gas in
      if Compare.Z.[Compare.S.op_lt] remaining Z.zero then
        Error_monad.__error_value extensible_type_value
      else
        if Compare.Z.[Compare.S.op_lt] block_remaining Z.zero then
          Error_monad.__error_value extensible_type_value
        else
          Error_monad.ok
            (block_remaining, (Limited {| t.Limited.remaining := remaining |}),
              rest)
    else
      Error_monad.ok (block_gas, operation_gas, total_internal_gas)
  end.

Definition check_enough
  (block_gas : Z.t) (operation_gas : t) (__internal_gas_value : Z.t)
  (cost : cost) : Error_monad.tzresult unit :=
  Error_monad.op_gtpipequestion
    (consume block_gas operation_gas __internal_gas_value cost)
    (fun function_parameter =&gt;
      let '(_block_remainig, _remaining, _internal_gas) := function_parameter in
      tt).

Definition internal_gas_zero : internal_gas := Z.zero.

Definition alloc_cost (n : Z) : cost :=
  {| cost.allocations := scale (Z.of_int (Pervasives.op_plus n 1));
    cost.steps := Z.zero; cost.reads := Z.zero; cost.writes := Z.zero;
    cost.bytes_read := Z.zero; cost.bytes_written := Z.zero |}.

Definition alloc_bytes_cost (n : Z) : cost :=
  alloc_cost (Pervasives.op_div (Pervasives.op_plus n 7) 8).

Definition alloc_bits_cost (n : Z) : cost :=
  alloc_cost (Pervasives.op_div (Pervasives.op_plus n 63) 64).

Definition atomic_step_cost (n : Z) : cost :=
  {| cost.allocations := Z.zero;
    cost.steps := Z.of_int (Pervasives.op_star 2 n); cost.reads := Z.zero;
    cost.writes := Z.zero; cost.bytes_read := Z.zero;
    cost.bytes_written := Z.zero |}.

Definition step_cost (n : Z) : cost :=
  {| cost.allocations := Z.zero; cost.steps := scale (Z.of_int n);
    cost.reads := Z.zero; cost.writes := Z.zero; cost.bytes_read := Z.zero;
    cost.bytes_written := Z.zero |}.

Definition free : cost :=
  {| cost.allocations := Z.zero; cost.steps := Z.zero; cost.reads := Z.zero;
    cost.writes := Z.zero; cost.bytes_read := Z.zero;
    cost.bytes_written := Z.zero |}.

Definition read_bytes_cost (n : Z.t) : cost :=
  {| cost.allocations := Z.zero; cost.steps := Z.zero;
    cost.reads := scale Z.one; cost.writes := Z.zero;
    cost.bytes_read := scale n; cost.bytes_written := Z.zero |}.

Definition write_bytes_cost (n : Z.t) : cost :=
  {| cost.allocations := Z.zero; cost.steps := Z.zero; cost.reads := Z.zero;
    cost.writes := Z.one; cost.bytes_read := Z.zero;
    cost.bytes_written := scale n |}.

Definition op_plusat (x : cost) (y : cost) : cost :=
  {| cost.allocations := Z.add (cost.allocations x) (cost.allocations y);
    cost.steps := Z.add (cost.steps x) (cost.steps y);
    cost.reads := Z.add (cost.reads x) (cost.reads y);
    cost.writes := Z.add (cost.writes x) (cost.writes y);
    cost.bytes_read := Z.add (cost.bytes_read x) (cost.bytes_read y);
    cost.bytes_written := Z.add (cost.bytes_written x) (cost.bytes_written y) |}.

Definition op_starat (x : Z) (y : cost) : cost :=
  {| cost.allocations := Z.mul (Z.of_int x) (cost.allocations y);
    cost.steps := Z.mul (Z.of_int x) (cost.steps y);
    cost.reads := Z.mul (Z.of_int x) (cost.reads y);
    cost.writes := Z.mul (Z.of_int x) (cost.writes y);
    cost.bytes_read := Z.mul (Z.of_int x) (cost.bytes_read y);
    cost.bytes_written := Z.mul (Z.of_int x) (cost.bytes_written y) |}.

Definition alloc_mbytes_cost (n : Z) : cost :=
  op_plusat (alloc_cost 12) (alloc_bytes_cost n).

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="gas_limit_repr.mli">
  <div class="col-md-6">
    <a href="#gas_limit_repr.mli"><code>gas_limit_repr.mli</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Unaccounted | Limited of {remaining : Z.t}

type internal_gas

val encoding : t Data_encoding.encoding

val pp : Format.formatter -&gt; t -&gt; unit

type cost

val cost_encoding : cost Data_encoding.encoding

val pp_cost : Format.formatter -&gt; cost -&gt; unit

<abbr class="mark-error" title="Extensible types are not handled.">type error += Block_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

val consume :
  Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt; (Z.t * t * internal_gas) tzresult

val check_enough : Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt; unit tzresult

val internal_gas_zero : internal_gas

val free : cost

val atomic_step_cost : int -&gt; cost

val step_cost : int -&gt; cost

val alloc_cost : int -&gt; cost

val alloc_bytes_cost : int -&gt; cost

val alloc_mbytes_cost : int -&gt; cost

val alloc_bits_cost : int -&gt; cost

val read_bytes_cost : Z.t -&gt; cost

val write_bytes_cost : Z.t -&gt; cost

val ( *@ ) : int -&gt; cost -&gt; cost

val ( +@ ) : cost -&gt; cost -&gt; cost
</pre>
  </div>
  <div class="col-md-6">
    <a href="#gas_limit_repr.mli"><code>Gas_limit_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Module t.
  Module Limited.
    Record record {remaining : Set} := {
      remaining : remaining }.
    Arguments record : clear implicits.
  End Limited.
  Definition Limited := Limited.record.
End t.

Inductive t : Set :=
| Unaccounted : t
| Limited : t.Limited Z.t -&gt; t.

Parameter internal_gas : Set.

Parameter encoding : Data_encoding.encoding t.

Parameter pp : Format.formatter -&gt; t -&gt; unit.

Parameter cost : Set.

Parameter cost_encoding : Data_encoding.encoding cost.

Parameter pp_cost : Format.formatter -&gt; cost -&gt; unit.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter consume :
  Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt;
  Error_monad.tzresult (Z.t * t * internal_gas).

Parameter check_enough :
  Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt; Error_monad.tzresult unit.

Parameter internal_gas_zero : internal_gas.

Parameter free : cost.

Parameter atomic_step_cost : Z -&gt; cost.

Parameter step_cost : Z -&gt; cost.

Parameter alloc_cost : Z -&gt; cost.

Parameter alloc_bytes_cost : Z -&gt; cost.

Parameter alloc_mbytes_cost : Z -&gt; cost.

Parameter alloc_bits_cost : Z -&gt; cost.

Parameter read_bytes_cost : Z.t -&gt; cost.

Parameter write_bytes_cost : Z.t -&gt; cost.

Parameter op_starat : Z -&gt; cost -&gt; cost.

Parameter op_plusat : cost -&gt; cost -&gt; cost.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="helpers_services.ml">
  <div class="col-md-6">
    <a href="#helpers_services.ml"><code>helpers_services.ml</code></a>&nbsp;<span class="label label-danger">357 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Cannot_parse_operation</abbr> (* `Branch *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Branch
    ~id:&quot;operation.cannot_parse&quot;
    ~title:&quot;Cannot parse operation&quot;
    ~description:&quot;The operation is ill-formed or for another protocol version&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;The operation cannot be parsed&quot;)
    Data_encoding.unit
    (function Cannot_parse_operation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_parse_operation)</abbr>

let parse_operation (op : Operation.raw) =
  match
    Data_encoding.Binary.of_bytes Operation.protocol_data_encoding op.proto
  with
  | Some protocol_data -&gt;
      ok {shell = op.shell; protocol_data}
  | None -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_parse_operation</abbr>

let path = RPC_path.(open_root / &quot;helpers&quot;)

module Scripts = struct
  module S = struct
    open Data_encoding

    let path = RPC_path.(path / &quot;scripts&quot;)

    let run_code_input_encoding =
      obj9
        (req &quot;script&quot; Script.expr_encoding)
        (req &quot;storage&quot; Script.expr_encoding)
        (req &quot;input&quot; Script.expr_encoding)
        (req &quot;amount&quot; Tez.encoding)
        (req &quot;chain_id&quot; Chain_id.encoding)
        (opt &quot;source&quot; Contract.encoding)
        (opt &quot;payer&quot; Contract.encoding)
        (opt &quot;gas&quot; z)
        (dft &quot;entrypoint&quot; string &quot;default&quot;)

    let trace_encoding =
      def &quot;scripted.trace&quot; @@ list
      @@ obj3
           (req &quot;location&quot; Script.location_encoding)
           (req &quot;gas&quot; Gas.encoding)
           (req
              &quot;stack&quot;
              (list
                 (obj2 (req &quot;item&quot; Script.expr_encoding) (opt &quot;annot&quot; string))))

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">run_code</abbr> =
      RPC_service.post_service
        ~description:&quot;Run a piece of code in the current context&quot;
        ~query:RPC_query.empty
        ~input:run_code_input_encoding
        ~output:
          (obj3
             (req &quot;storage&quot; Script.expr_encoding)
             (req &quot;operations&quot; (list Operation.internal_operation_encoding))
             (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding))
        RPC_path.(path / &quot;run_code&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">trace_code</abbr> =
      RPC_service.post_service
        ~description:
          &quot;Run a piece of code in the current context, keeping a trace&quot;
        ~query:RPC_query.empty
        ~input:run_code_input_encoding
        ~output:
          (obj4
             (req &quot;storage&quot; Script.expr_encoding)
             (req &quot;operations&quot; (list Operation.internal_operation_encoding))
             (req &quot;trace&quot; trace_encoding)
             (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding))
        RPC_path.(path / &quot;trace_code&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">typecheck_code</abbr> =
      RPC_service.post_service
        ~description:&quot;Typecheck a piece of code in the current context&quot;
        ~query:RPC_query.empty
        ~input:(obj2 (req &quot;program&quot; Script.expr_encoding) (opt &quot;gas&quot; z))
        ~output:
          (obj2
             (req &quot;type_map&quot; Script_tc_errors_registration.type_map_enc)
             (req &quot;gas&quot; Gas.encoding))
        RPC_path.(path / &quot;typecheck_code&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">typecheck_data</abbr> =
      RPC_service.post_service
        ~description:
          &quot;Check that some data expression is well formed and of a given type \
           in the current context&quot;
        ~query:RPC_query.empty
        ~input:
          (obj3
             (req &quot;data&quot; Script.expr_encoding)
             (req &quot;type&quot; Script.expr_encoding)
             (opt &quot;gas&quot; z))
        ~output:(obj1 (req &quot;gas&quot; Gas.encoding))
        RPC_path.(path / &quot;typecheck_data&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">pack_data</abbr> =
      RPC_service.post_service
        ~description:
          &quot;Computes the serialized version of some data expression using the \
           same algorithm as script instruction PACK&quot;
        ~input:
          (obj3
             (req &quot;data&quot; Script.expr_encoding)
             (req &quot;type&quot; Script.expr_encoding)
             (opt &quot;gas&quot; z))
        ~output:(obj2 (req &quot;packed&quot; bytes) (req &quot;gas&quot; Gas.encoding))
        ~query:RPC_query.empty
        RPC_path.(path / &quot;pack_data&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">run_operation</abbr> =
      RPC_service.post_service
        ~description:&quot;Run an operation without signature checks&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;operation&quot; Operation.encoding)
             (req &quot;chain_id&quot; Chain_id.encoding))
        ~output:Apply_results.operation_data_and_metadata_encoding
        RPC_path.(path / &quot;run_operation&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">entrypoint_type</abbr> =
      RPC_service.post_service
        ~description:&quot;Return the type of the given entrypoint&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;script&quot; Script.expr_encoding)
             (dft &quot;entrypoint&quot; string &quot;default&quot;))
        ~output:(obj1 (req &quot;entrypoint_type&quot; Script.expr_encoding))
        RPC_path.(path / &quot;entrypoint&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">list_entrypoints</abbr> =
      RPC_service.post_service
        ~description:&quot;Return the list of entrypoints of the given script&quot;
        ~query:RPC_query.empty
        ~input:(obj1 (req &quot;script&quot; Script.expr_encoding))
        ~output:
          (obj2
             (dft
                &quot;unreachable&quot;
                (Data_encoding.list
                   (obj1
                      (req
                         &quot;path&quot;
                         (Data_encoding.list
                            Michelson_v1_primitives.prim_encoding))))
                [])
             (req &quot;entrypoints&quot; (assoc Script.expr_encoding)))
        RPC_path.(path / &quot;entrypoints&quot;)
  end

  let register () =
    let open Services_registration in
    let originate_dummy_contract ctxt script =
      let ctxt = Contract.init_origination_nonce ctxt Operation_hash.zero in
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, dummy_contract) -&gt;
      let balance =
        match Tez.of_mutez 4_000_000_000_000L with
        | Some balance -&gt;
            balance
        | None -&gt;
            <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
      in
      Contract.originate
        ctxt
        dummy_contract
        ~balance
        ~delegate:None
        ~script:(script, None)
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, dummy_contract)
    in
    <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0
      S.run_code
      (fun ctxt
           ()
           ( code,
             storage,
             parameter,
             amount,
             chain_id,
             source,
             payer,
             gas,
             entrypoint )
           -&gt;
        let storage = Script.lazy_expr storage in
        let code = Script.lazy_expr code in
        originate_dummy_contract ctxt {storage; code}
        &gt;&gt;=? fun (ctxt, dummy_contract) -&gt;
        let (source, payer) =
          match (source, payer) with
          | (Some source, Some payer) -&gt;
              (source, payer)
          | (Some source, None) -&gt;
              (source, source)
          | (None, Some payer) -&gt;
              (payer, payer)
          | (None, None) -&gt;
              (dummy_contract, dummy_contract)
        in
        let gas =
          match gas with
          | Some gas -&gt;
              gas
          | None -&gt;
              Constants.hard_gas_limit_per_operation ctxt
        in
        let ctxt = Gas.set_limit ctxt gas in
        let step_constants =
          let open Script_interpreter in
          {source; payer; self = dummy_contract; amount; chain_id}
        in
        Script_interpreter.execute
          ctxt
          Readable
          step_constants
          ~script:{storage; code}
          ~entrypoint
          ~parameter
        &gt;&gt;=? fun {Script_interpreter.storage; operations; big_map_diff; _} -&gt;
        return (storage, operations, big_map_diff)) ;
    </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0
      S.trace_code
      (fun ctxt
           ()
           ( code,
             storage,
             parameter,
             amount,
             chain_id,
             source,
             payer,
             gas,
             entrypoint )
           -&gt;
        let storage = Script.lazy_expr storage in
        let code = Script.lazy_expr code in
        originate_dummy_contract ctxt {storage; code}
        &gt;&gt;=? fun (ctxt, dummy_contract) -&gt;
        let (source, payer) =
          match (source, payer) with
          | (Some source, Some payer) -&gt;
              (source, payer)
          | (Some source, None) -&gt;
              (source, source)
          | (None, Some payer) -&gt;
              (payer, payer)
          | (None, None) -&gt;
              (dummy_contract, dummy_contract)
        in
        let gas =
          match gas with
          | Some gas -&gt;
              gas
          | None -&gt;
              Constants.hard_gas_limit_per_operation ctxt
        in
        let ctxt = Gas.set_limit ctxt gas in
        let step_constants =
          let open Script_interpreter in
          {source; payer; self = dummy_contract; amount; chain_id}
        in
        Script_interpreter.trace
          ctxt
          Readable
          step_constants
          ~script:{storage; code}
          ~entrypoint
          ~parameter
        &gt;&gt;=? fun ( {Script_interpreter.storage; operations; big_map_diff; _},
                   trace ) -&gt;
        return (storage, operations, trace, big_map_diff)) ;
    </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.typecheck_code (fun ctxt () (expr, maybe_gas) -&gt;
        let ctxt =
          match maybe_gas with
          | None -&gt;
              Gas.set_unlimited ctxt
          | Some gas -&gt;
              Gas.set_limit ctxt gas
        in
        Script_ir_translator.typecheck_code ctxt expr
        &gt;&gt;=? fun (res, ctxt) -&gt; return (res, Gas.level ctxt)) ;
    </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.typecheck_data (fun ctxt () (data, ty, maybe_gas) -&gt;
        let ctxt =
          match maybe_gas with
          | None -&gt;
              Gas.set_unlimited ctxt
          | Some gas -&gt;
              Gas.set_limit ctxt gas
        in
        Script_ir_translator.typecheck_data ctxt (data, ty)
        &gt;&gt;=? fun ctxt -&gt; return (Gas.level ctxt)) ;
    </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.pack_data (fun ctxt () (expr, typ, maybe_gas) -&gt;
        let open Script_ir_translator in
        let ctxt =
          match maybe_gas with
          | None -&gt;
              Gas.set_unlimited ctxt
          | Some gas -&gt;
              Gas.set_limit ctxt gas
        in
        Lwt.return (parse_packable_ty ctxt ~legacy:true (Micheline.root typ))
        &gt;&gt;=? fun (Ex_ty typ, ctxt) -&gt;
        parse_data ctxt ~legacy:true typ (Micheline.root expr)
        &gt;&gt;=? fun (data, ctxt) -&gt;
        Script_ir_translator.pack_data ctxt typ data
        &gt;&gt;=? fun (bytes, ctxt) -&gt; return (bytes, Gas.level ctxt)) ;
    </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0
      S.run_operation
      (fun ctxt
           ()
           ({shell; protocol_data = Operation_data protocol_data}, chain_id)
           -&gt;
        (* this code is a duplicate of Apply without signature check *)
        let partial_precheck_manager_contents (type kind) ctxt
            (op : kind Kind.manager contents) : context tzresult Lwt.t =
          let (Manager_operation
                {source; fee; counter; operation; gas_limit; storage_limit}) =
            op
          in
          Lwt.return (Gas.check_limit ctxt gas_limit)
          &gt;&gt;=? fun () -&gt;
          let ctxt = Gas.set_limit ctxt gas_limit in
          Lwt.return (Fees.check_storage_limit ctxt storage_limit)
          &gt;&gt;=? fun () -&gt;
          Contract.must_be_allocated ctxt (Contract.implicit_contract source)
          &gt;&gt;=? fun () -&gt;
          Contract.check_counter_increment ctxt source counter
          &gt;&gt;=? fun () -&gt;
          ( match operation with
          | Reveal pk -&gt;
              Contract.reveal_manager_key ctxt source pk
          | Transaction {parameters; _} -&gt;
              (* Here the data comes already deserialized, so we need to fake the deserialization to mimic apply *)
              let arg_bytes =
                Data_encoding.Binary.to_bytes_exn
                  Script.lazy_expr_encoding
                  parameters
              in
              let arg =
                match
                  Data_encoding.Binary.of_bytes
                    Script.lazy_expr_encoding
                    arg_bytes
                with
                | Some arg -&gt;
                    arg
                | None -&gt;
                    assert false
              in
              (* Fail quickly if not enough gas for minimal deserialization cost *)
              Lwt.return
              @@ record_trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Gas.check_enough ctxt (Script.minimal_deserialize_cost arg)
              &gt;&gt;=? fun () -&gt;
              (* Fail if not enough gas for complete deserialization cost *)
              trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Script.force_decode ctxt arg
              &gt;&gt;|? fun (_arg, ctxt) -&gt; ctxt
          | Origination {script; _} -&gt;
              (* Here the data comes already deserialized, so we need to fake the deserialization to mimic apply *)
              let script_bytes =
                Data_encoding.Binary.to_bytes_exn Script.encoding script
              in
              let script =
                match
                  Data_encoding.Binary.of_bytes Script.encoding script_bytes
                with
                | Some script -&gt;
                    script
                | None -&gt;
                    assert false
              in
              (* Fail quickly if not enough gas for minimal deserialization cost *)
              Lwt.return
              @@ record_trace Apply.Gas_quota_exceeded_init_deserialize
              @@ ( Gas.consume
                     ctxt
                     (Script.minimal_deserialize_cost script.code)
                 &gt;&gt;? fun ctxt -&gt;
                 Gas.check_enough
                   ctxt
                   (Script.minimal_deserialize_cost script.storage) )
              &gt;&gt;=? fun () -&gt;
              (* Fail if not enough gas for complete deserialization cost *)
              trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Script.force_decode ctxt script.code
              &gt;&gt;=? fun (_code, ctxt) -&gt;
              trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Script.force_decode ctxt script.storage
              &gt;&gt;|? fun (_storage, ctxt) -&gt; ctxt
          | _ -&gt;
              return ctxt )
          &gt;&gt;=? fun ctxt -&gt;
          Contract.get_manager_key ctxt source
          &gt;&gt;=? fun _public_key -&gt;
          (* signature check unplugged from here *)
          Contract.increment_counter ctxt source
          &gt;&gt;=? fun ctxt -&gt;
          Contract.spend ctxt (Contract.implicit_contract source) fee
          &gt;&gt;=? fun ctxt -&gt; return ctxt
        in
        let rec partial_precheck_manager_contents_list :
            type kind.
            Alpha_context.t -&gt;
            kind Kind.manager contents_list -&gt;
            context tzresult Lwt.t =
         fun ctxt contents_list -&gt;
          match contents_list with
          | Single (Manager_operation _ as op) -&gt;
              partial_precheck_manager_contents ctxt op
          | Cons ((Manager_operation _ as op), rest) -&gt;
              partial_precheck_manager_contents ctxt op
              &gt;&gt;=? fun ctxt -&gt; partial_precheck_manager_contents_list ctxt rest
        in
        let return contents =
          return
            ( Operation_data protocol_data,
              Apply_results.Operation_metadata {contents} )
        in
        let operation : _ operation = {shell; protocol_data} in
        let hash = Operation.hash {shell; protocol_data} in
        let ctxt = Contract.init_origination_nonce ctxt hash in
        let baker = Signature.Public_key_hash.zero in
        match protocol_data.contents with
        | Single (Manager_operation _) as op -&gt;
            partial_precheck_manager_contents_list ctxt op
            &gt;&gt;=? fun ctxt -&gt;
            Apply.apply_manager_contents_list ctxt Optimized baker chain_id op
            &gt;&gt;= fun (_ctxt, result) -&gt; return result
        | Cons (Manager_operation _, _) as op -&gt;
            partial_precheck_manager_contents_list ctxt op
            &gt;&gt;=? fun ctxt -&gt;
            Apply.apply_manager_contents_list ctxt Optimized baker chain_id op
            &gt;&gt;= fun (_ctxt, result) -&gt; return result
        | _ -&gt;
            Apply.apply_contents_list
              ctxt
              chain_id
              Optimized
              shell.branch
              baker
              operation
              operation.protocol_data.contents
            &gt;&gt;=? fun (_ctxt, result) -&gt; return result) ;
    </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.entrypoint_type (fun ctxt () (expr, entrypoint) -&gt;
        let ctxt = Gas.set_unlimited ctxt in
        let legacy = false in
        let open Script_ir_translator in
        Lwt.return
          ( parse_toplevel ~legacy expr
          &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
          parse_ty
            ctxt
            ~legacy
            ~allow_big_map:true
            ~allow_operation:false
            ~allow_contract:true
            arg_type
          &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
          Script_ir_translator.find_entrypoint ~root_name arg_type entrypoint
          )
        &gt;&gt;=? fun (_f, Ex_ty ty) -&gt;
        unparse_ty ctxt ty
        &gt;&gt;=? fun (ty_node, _) -&gt; return (Micheline.strip_locations ty_node)) ;
    register0 S.list_entrypoints (fun ctxt () expr -&gt;
        let ctxt = Gas.set_unlimited ctxt in
        let legacy = false in
        let open Script_ir_translator in
        Lwt.return
          ( parse_toplevel ~legacy expr
          &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
          parse_ty
            ctxt
            ~legacy
            ~allow_big_map:true
            ~allow_operation:false
            ~allow_contract:true
            arg_type
          &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
          Script_ir_translator.list_entrypoints ~root_name arg_type ctxt )
        &gt;&gt;=? fun (unreachable_entrypoint, map) -&gt;
        return
          ( unreachable_entrypoint,
            Entrypoints_map.fold
              (fun entry (_, ty) acc -&gt;
                (entry, Micheline.strip_locations ty) :: acc)
              map
              [] ))</abbr>

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">run_code</abbr> ctxt block code
      (storage, input, amount, chain_id, source, payer, gas, entrypoint) =
    RPC_context.make_call0
      S.run_code
      ctxt
      block
      ()
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint)

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">trace_code</abbr> ctxt block code
      (storage, input, amount, chain_id, source, payer, gas, entrypoint) =
    RPC_context.make_call0
      S.trace_code
      ctxt
      block
      ()
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint)

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">typecheck_code</abbr> ctxt block =
    RPC_context.make_call0 S.typecheck_code ctxt block ()

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">typecheck_data</abbr> ctxt block =
    RPC_context.make_call0 S.typecheck_data ctxt block ()

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">pack_data</abbr> ctxt block = RPC_context.make_call0 S.pack_data ctxt block ()

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">run_operation</abbr> ctxt block =
    RPC_context.make_call0 S.run_operation ctxt block ()

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">entrypoint_type</abbr> ctxt block =
    RPC_context.make_call0 S.entrypoint_type ctxt block ()

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">list_entrypoints</abbr> ctxt block =
    RPC_context.make_call0 S.list_entrypoints ctxt block ()
end

module Forge = struct
  module S = struct
    open Data_encoding

    let path = RPC_path.(path / &quot;forge&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">operations</abbr> =
      RPC_service.post_service
        ~description:&quot;Forge an operation&quot;
        ~query:RPC_query.empty
        ~input:Operation.unsigned_encoding
        ~output:bytes
        RPC_path.(path / &quot;operations&quot;)

    let empty_proof_of_work_nonce =
      MBytes.of_string
        (String.make Constants_repr.proof_of_work_nonce_size '\000')

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">protocol_data</abbr> =
      RPC_service.post_service
        ~description:&quot;Forge the protocol-specific part of a block header&quot;
        ~query:RPC_query.empty
        ~input:
          (obj3
             (req &quot;priority&quot; uint16)
             (opt &quot;nonce_hash&quot; Nonce_hash.encoding)
             (dft
                &quot;proof_of_work_nonce&quot;
                (Fixed.bytes Alpha_context.Constants.proof_of_work_nonce_size)
                empty_proof_of_work_nonce))
        ~output:(obj1 (req &quot;protocol_data&quot; bytes))
        RPC_path.(path / &quot;protocol_data&quot;)
  end

  let register () =
    let open Services_registration in
    <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0_noctxt S.operations (fun () (shell, proto) -&gt;
        return
          (Data_encoding.Binary.to_bytes_exn
             Operation.unsigned_encoding
             (shell, proto))) ;
    register0_noctxt
      S.protocol_data
      (fun () (priority, seed_nonce_hash, proof_of_work_nonce) -&gt;
        return
          (Data_encoding.Binary.to_bytes_exn
             Block_header.contents_encoding
             {priority; seed_nonce_hash; proof_of_work_nonce}))</abbr>

  module Manager = struct
    let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">operations</abbr> ctxt block ~branch ~source ?sourcePubKey ~counter ~fee
        ~gas_limit ~storage_limit operations =
      Contract_services.manager_key ctxt block source
      &gt;&gt;= function
      | Error _ as e -&gt;
          Lwt.return e
      | Ok revealed -&gt;
          let ops =
            List.map
              (fun (Manager operation) -&gt;
                Contents
                  (Manager_operation
                     {
                       source;
                       counter;
                       operation;
                       fee;
                       gas_limit;
                       storage_limit;
                     }))
              operations
          in
          let ops =
            match (sourcePubKey, revealed) with
            | (None, _) | (_, Some _) -&gt;
                ops
            | (Some pk, None) -&gt;
                let operation = Reveal pk in
                Contents
                  (Manager_operation
                     {
                       source;
                       counter;
                       operation;
                       fee;
                       gas_limit;
                       storage_limit;
                     })
                :: ops
          in
          RPC_context.make_call0
            S.operations
            ctxt
            block
            ()
            ({branch}, Operation.of_list ops)

    let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">reveal</abbr> ctxt block ~branch ~source ~sourcePubKey ~counter ~fee () =
      operations
        ctxt
        block
        ~branch
        ~source
        ~sourcePubKey
        ~counter
        ~fee
        ~gas_limit:Z.zero
        ~storage_limit:Z.zero
        []

    let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">transaction</abbr> ctxt block ~branch ~source ?sourcePubKey ~counter ~amount
        ~destination ?(entrypoint = &quot;default&quot;) ?parameters ~gas_limit
        ~storage_limit ~fee () =
      let parameters =
        Option.unopt_map
          ~f:Script.lazy_expr
          ~default:Script.unit_parameter
          parameters
      in
      operations
        ctxt
        block
        ~branch
        ~source
        ?sourcePubKey
        ~counter
        ~fee
        ~gas_limit
        ~storage_limit
        [Manager (Transaction {amount; parameters; destination; entrypoint})]

    let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">origination</abbr> ctxt block ~branch ~source ?sourcePubKey ~counter ~balance
        ?delegatePubKey ~script ~gas_limit ~storage_limit ~fee () =
      operations
        ctxt
        block
        ~branch
        ~source
        ?sourcePubKey
        ~counter
        ~fee
        ~gas_limit
        ~storage_limit
        [ Manager
            (Origination
               {
                 delegate = delegatePubKey;
                 script;
                 credit = balance;
                 preorigination = None;
               }) ]

    let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">delegation</abbr> ctxt block ~branch ~source ?sourcePubKey ~counter ~fee
        delegate =
      operations
        ctxt
        block
        ~branch
        ~source
        ?sourcePubKey
        ~counter
        ~fee
        ~gas_limit:Z.zero
        ~storage_limit:Z.zero
        [Manager (Delegation delegate)]
  end

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">operation</abbr> ctxt block ~branch operation =
    RPC_context.make_call0
      S.operations
      ctxt
      block
      ()
      ({branch}, Contents_list (Single operation))

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">endorsement</abbr> ctxt b ~branch ~level () =
    operation ctxt b ~branch (Endorsement {level})

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">proposals</abbr> ctxt b ~branch ~source ~period ~proposals () =
    operation ctxt b ~branch (Proposals {source; period; proposals})

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">ballot</abbr> ctxt b ~branch ~source ~period ~proposal ~ballot () =
    operation ctxt b ~branch (Ballot {source; period; proposal; ballot})

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">seed_nonce_revelation</abbr> ctxt block ~branch ~level ~nonce () =
    operation ctxt block ~branch (Seed_nonce_revelation {level; nonce})

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">double_baking_evidence</abbr> ctxt block ~branch ~bh1 ~bh2 () =
    operation ctxt block ~branch (Double_baking_evidence {bh1; bh2})

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">double_endorsement_evidence</abbr> ctxt block ~branch ~op1 ~op2 () =
    operation ctxt block ~branch (Double_endorsement_evidence {op1; op2})

  let empty_proof_of_work_nonce =
    MBytes.of_string
      (String.make Constants_repr.proof_of_work_nonce_size '\000')

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">protocol_data</abbr> ctxt block ~priority ?seed_nonce_hash
      ?(proof_of_work_nonce = empty_proof_of_work_nonce) () =
    RPC_context.make_call0
      S.protocol_data
      ctxt
      block
      ()
      (priority, seed_nonce_hash, proof_of_work_nonce)
end

module Parse = struct
  module S = struct
    open Data_encoding

    let path = RPC_path.(path / &quot;parse&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">operations</abbr> =
      RPC_service.post_service
        ~description:&quot;Parse operations&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;operations&quot; (list (dynamic_size Operation.raw_encoding)))
             (opt &quot;check_signature&quot; bool))
        ~output:(list (dynamic_size Operation.encoding))
        RPC_path.(path / &quot;operations&quot;)

    let <abbr class="mark-error" title="Polymorphic variant types are not handled">block</abbr> =
      RPC_service.post_service
        ~description:&quot;Parse a block&quot;
        ~query:RPC_query.empty
        ~input:Block_header.raw_encoding
        ~output:Block_header.protocol_data_encoding
        RPC_path.(path / &quot;block&quot;)
  end

  let parse_protocol_data protocol_data =
    match
      Data_encoding.Binary.of_bytes
        Block_header.protocol_data_encoding
        protocol_data
    with
    | None -&gt;
        failwith &quot;Cant_parse_protocol_data&quot;
    | Some protocol_data -&gt;
        return protocol_data

  let register () =
    let open Services_registration in
    <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.operations (fun _ctxt () (operations, check) -&gt;
        map_s
          (fun raw -&gt;
            Lwt.return (parse_operation raw)
            &gt;&gt;=? fun op -&gt;
            ( match check with
            | Some true -&gt;
                return_unit (* FIXME *)
            (* I.check_signature ctxt *)
            (* op.protocol_data.signature op.shell op.protocol_data.contents *)
            | Some false | None -&gt;
                return_unit )
            &gt;&gt;|? fun () -&gt; op)
          operations) ;
    register0_noctxt S.block (fun () raw_block -&gt;
        parse_protocol_data raw_block.protocol_data)</abbr>

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">operations</abbr> ctxt block ?check operations =
    RPC_context.make_call0 S.operations ctxt block () (operations, check)

  let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">block</abbr> ctxt block shell protocol_data =
    RPC_context.make_call0
      S.block
      ctxt
      block
      ()
      ({shell; protocol_data} : Block_header.raw)
end

module S = struct
  open Data_encoding

  type level_query = {offset : int32}

  let level_query : level_query RPC_query.t =
    let open RPC_query in
    query (fun offset -&gt; {offset})
    |+ field &quot;offset&quot; RPC_arg.int32 0l (fun t -&gt; t.offset)
    |&gt; seal

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">current_level</abbr> =
    RPC_service.get_service
      ~description:
        &quot;Returns the level of the interrogated block, or the one of a block \
         located `offset` blocks after in the chain (or before when \
         negative). For instance, the next block if `offset` is 1.&quot;
      ~query:level_query
      ~output:Level.encoding
      RPC_path.(path / &quot;current_level&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">levels_in_current_cycle</abbr> =
    RPC_service.get_service
      ~description:&quot;Levels of a cycle&quot;
      ~query:level_query
      ~output:
        (obj2 (req &quot;first&quot; Raw_level.encoding) (req &quot;last&quot; Raw_level.encoding))
      RPC_path.(path / &quot;levels_in_current_cycle&quot;)
end

let register () =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Scripts.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Forge.register () ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Parse.register () ;
  let open Services_registration in
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.current_level (fun ctxt q () -&gt;
      let level = Level.current ctxt in
      return (Level.from_raw ctxt ~offset:q.offset level.level)) ;
  register0 S.levels_in_current_cycle (fun ctxt q () -&gt;
      let levels = Level.levels_in_current_cycle ctxt ~offset:q.offset () in
      match levels with
      | [] -&gt;
          raise </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">Not_found</abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
      | _ -&gt;
          let first = List.hd (List.rev levels) in
          let last = List.hd levels in
          return (first.level, last.level))</abbr>

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">current_level</abbr> ctxt ?(offset = 0l) block =
  RPC_context.make_call0 S.current_level ctxt block {offset} ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">levels_in_current_cycle</abbr> ctxt ?(offset = 0l) block =
  RPC_context.make_call0 S.levels_in_current_cycle ctxt block {offset} ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#helpers_services.ml"><code>Helpers_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Apply_results.
Require Tezos.Constants_repr.
Require Tezos.Contract_services.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Nonce_hash.
Require Tezos.Script_ir_translator.
Require Tezos.Script_tc_errors_registration.
Require Tezos.Services_registration.

Import Alpha_context.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition parse_operation (op : Alpha_context.Operation.raw)
  : Error_monad.tzresult Alpha_context.packed_operation :=
  match
    Data_encoding.Binary.of_bytes Alpha_context.Operation.protocol_data_encoding
      (Alpha_context.Operation.raw.proto op) with
  | Some protocol_data =&gt;
    Error_monad.ok
      {|
        Alpha_context.packed_operation.shell :=
          Alpha_context.Operation.raw.shell op;
        Alpha_context.packed_operation.protocol_data := protocol_data |}
  | None =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
  RPC_path.op_div RPC_path.open_root &quot;helpers&quot; % string.

Module Scripts.
  Module S.
    Import Data_encoding.
    
    Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div path &quot;scripts&quot; % string.
    
    Definition run_code_input_encoding
      : Data_encoding.encoding
        (Alpha_context.Script.expr * Alpha_context.Script.expr *
          Alpha_context.Script.expr * Alpha_context.Tez.t * Chain_id.[S.HASH.t]
          * option Alpha_context.Contract.t * option Alpha_context.Contract.t *
          option Z.t * string) :=
      Data_encoding.obj9
        (Data_encoding.req None None &quot;script&quot; % string
          Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;storage&quot; % string
          Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;input&quot; % string
          Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;amount&quot; % string
          Alpha_context.Tez.encoding)
        (Data_encoding.req None None &quot;chain_id&quot; % string
          Chain_id.[S.HASH.encoding])
        (Data_encoding.opt None None &quot;source&quot; % string
          Alpha_context.Contract.encoding)
        (Data_encoding.opt None None &quot;payer&quot; % string
          Alpha_context.Contract.encoding)
        (Data_encoding.opt None None &quot;gas&quot; % string Data_encoding.z)
        (Data_encoding.dft None None &quot;entrypoint&quot; % string
          Data_encoding.__string_value &quot;default&quot; % string).
    
    Definition trace_encoding
      : Data_encoding.encoding
        (list
          (Alpha_context.Script.location * Alpha_context.Gas.t *
            list (Alpha_context.Script.expr * option string))) :=
      Pervasives.op_atat
        (let arg := Data_encoding.def &quot;scripted.trace&quot; % string in
        fun eta =&gt; arg None None eta)
        (Pervasives.op_atat
          (let arg := Data_encoding.__list_value in
          fun eta =&gt; arg None eta)
          (Data_encoding.obj3
            (Data_encoding.req None None &quot;location&quot; % string
              Alpha_context.Script.location_encoding)
            (Data_encoding.req None None &quot;gas&quot; % string
              Alpha_context.Gas.encoding)
            (Data_encoding.req None None &quot;stack&quot; % string
              (Data_encoding.__list_value None
                (Data_encoding.obj2
                  (Data_encoding.req None None &quot;item&quot; % string
                    Alpha_context.Script.expr_encoding)
                  (Data_encoding.opt None None &quot;annot&quot; % string
                    Data_encoding.__string_value)))))).
    
    Definition run_code
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr *
          Alpha_context.Script.expr * Alpha_context.Tez.t * Chain_id.[S.HASH.t]
          * option Alpha_context.Contract.t * option Alpha_context.Contract.t *
          option Z.t * string)
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          option Alpha_context.Contract.big_map_diff) :=
      RPC_service.post_service
        (Some &quot;Run a piece of code in the current context&quot; % string)
        RPC_query.empty run_code_input_encoding
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;storage&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;operations&quot; % string
            (Data_encoding.__list_value None
              Alpha_context.Operation.internal_operation_encoding))
          (Data_encoding.opt None None &quot;big_map_diff&quot; % string
            Alpha_context.Contract.big_map_diff_encoding))
        (RPC_path.op_div path &quot;run_code&quot; % string).
    
    Definition trace_code
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr *
          Alpha_context.Script.expr * Alpha_context.Tez.t * Chain_id.[S.HASH.t]
          * option Alpha_context.Contract.t * option Alpha_context.Contract.t *
          option Z.t * string)
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          list
            (Alpha_context.Script.location * Alpha_context.Gas.t *
              list (Alpha_context.Script.expr * option string)) *
          option Alpha_context.Contract.big_map_diff) :=
      RPC_service.post_service
        (Some
          &quot;Run a piece of code in the current context, keeping a trace&quot; % string)
        RPC_query.empty run_code_input_encoding
        (Data_encoding.obj4
          (Data_encoding.req None None &quot;storage&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;operations&quot; % string
            (Data_encoding.__list_value None
              Alpha_context.Operation.internal_operation_encoding))
          (Data_encoding.req None None &quot;trace&quot; % string trace_encoding)
          (Data_encoding.opt None None &quot;big_map_diff&quot; % string
            Alpha_context.Contract.big_map_diff_encoding))
        (RPC_path.op_div path &quot;trace_code&quot; % string).
    
    Definition typecheck_code
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit (Alpha_context.Script.expr * option Z.t)
        (list
          (Alpha_context.Script.location *
            (list (Alpha_context.Script.expr * list string) *
              list (Alpha_context.Script.expr * list string))) *
          Alpha_context.Gas.t) :=
      RPC_service.post_service
        (Some &quot;Typecheck a piece of code in the current context&quot; % string)
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;program&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.opt None None &quot;gas&quot; % string Data_encoding.z))
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;type_map&quot; % string
            Script_tc_errors_registration.type_map_enc)
          (Data_encoding.req None None &quot;gas&quot; % string Alpha_context.Gas.encoding))
        (RPC_path.op_div path &quot;typecheck_code&quot; % string).
    
    Definition typecheck_data
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t)
        Alpha_context.Gas.t :=
      RPC_service.post_service
        (Some
          &quot;Check that some data expression is well formed and of a given type in the current context&quot;
            % string) RPC_query.empty
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;data&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;type&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.opt None None &quot;gas&quot; % string Data_encoding.z))
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;gas&quot; % string Alpha_context.Gas.encoding))
        (RPC_path.op_div path &quot;typecheck_data&quot; % string).
    
    Definition pack_data
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t)
        (MBytes.t * Alpha_context.Gas.t) :=
      RPC_service.post_service
        (Some
          &quot;Computes the serialized version of some data expression using the same algorithm as script instruction PACK&quot;
            % string) RPC_query.empty
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;data&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;type&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.opt None None &quot;gas&quot; % string Data_encoding.z))
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;packed&quot; % string
            Data_encoding.__bytes_value)
          (Data_encoding.req None None &quot;gas&quot; % string Alpha_context.Gas.encoding))
        (RPC_path.op_div path &quot;pack_data&quot; % string).
    
    Definition run_operation
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (Alpha_context.Operation.packed * Chain_id.[S.HASH.t])
        (Alpha_context.Operation.packed_protocol_data *
          Apply_results.packed_operation_metadata) :=
      RPC_service.post_service
        (Some &quot;Run an operation without signature checks&quot; % string)
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;operation&quot; % string
            Alpha_context.Operation.encoding)
          (Data_encoding.req None None &quot;chain_id&quot; % string
            Chain_id.[S.HASH.encoding]))
        Apply_results.operation_data_and_metadata_encoding
        (RPC_path.op_div path &quot;run_operation&quot; % string).
    
    Definition entrypoint_type
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit (Alpha_context.Script.expr * string)
        Alpha_context.Script.expr :=
      RPC_service.post_service
        (Some &quot;Return the type of the given entrypoint&quot; % string)
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;script&quot; % string
            Alpha_context.Script.expr_encoding)
          (Data_encoding.dft None None &quot;entrypoint&quot; % string
            Data_encoding.__string_value &quot;default&quot; % string))
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;entrypoint_type&quot; % string
            Alpha_context.Script.expr_encoding))
        (RPC_path.op_div path &quot;entrypoint&quot; % string).
    
    Definition list_entrypoints
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit Alpha_context.Script.expr
        (list (list Michelson_v1_primitives.prim) *
          list (string * Alpha_context.Script.expr)) :=
      RPC_service.post_service
        (Some &quot;Return the list of entrypoints of the given script&quot; % string)
        RPC_query.empty
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;script&quot; % string
            Alpha_context.Script.expr_encoding))
        (Data_encoding.obj2
          (Data_encoding.dft None None &quot;unreachable&quot; % string
            (Data_encoding.__list_value None
              (Data_encoding.obj1
                (Data_encoding.req None None &quot;path&quot; % string
                  (Data_encoding.__list_value None
                    Michelson_v1_primitives.prim_encoding)))) [])
          (Data_encoding.req None None &quot;entrypoints&quot; % string
            (Data_encoding.assoc Alpha_context.Script.expr_encoding)))
        (RPC_path.op_div path &quot;entrypoints&quot; % string).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    let originate_dummy_contract
      (ctxt : Alpha_context.context) (script : Alpha_context.Script.t)
      : Lwt.t
        (Error_monad.tzresult (Alpha_context.context * Alpha_context.Contract.t)) :=
      let ctxt :=
        Alpha_context.Contract.init_origination_nonce ctxt
          Operation_hash.[S.HASH.zero] in
      Error_monad.op_gtgteqquestion
        (Alpha_context.Contract.fresh_contract_from_current_nonce ctxt)
        (fun function_parameter =&gt;
          let '(ctxt, dummy_contract) := function_parameter in
          let balance :=
            match
              Alpha_context.Tez.of_mutez
                (* ‚ùå Constant of type int64 is converted to int *)
                4000000000000 with
            | Some balance =&gt; balance
            | None =&gt;
              (* ‚ùå Assert instruction is not handled. *)
              assert false
            end in
          Error_monad.op_gtgteqquestion
            (Alpha_context.Contract.originate ctxt dummy_contract balance
              (script, None) None)
            (fun ctxt =&gt; Error_monad.__return (ctxt, dummy_contract))) in
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    Services_registration.register0 S.list_entrypoints
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let 'tt := function_parameter in
          fun expr =&gt;
            let ctxt := Alpha_context.Gas.set_unlimited ctxt in
            let legacy := false in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Error_monad.op_gtgtquestion
                  (Script_ir_translator.parse_toplevel legacy expr)
                  (fun function_parameter =&gt;
                    let '(arg_type, _, _, root_name) := function_parameter in
                    Error_monad.op_gtgtquestion
                      (Script_ir_translator.parse_ty ctxt legacy true false true
                        arg_type)
                      (fun function_parameter =&gt;
                        let '(Script_ir_translator.Ex_ty arg_type, _) :=
                          function_parameter in
                        Script_ir_translator.list_entrypoints arg_type ctxt
                          root_name))))
              (fun function_parameter =&gt;
                let '(unreachable_entrypoint, map) := function_parameter in
                Error_monad.__return
                  (unreachable_entrypoint,
                    (Script_ir_translator.Entrypoints_map.[S.MAP.fold]
                      (fun entry =&gt;
                        fun function_parameter =&gt;
                          let '(_, ty) := function_parameter in
                          fun acc =&gt;
                            cons (entry, (Micheline.strip_locations ty)) acc)
                      map [])))).
  
  Definition run_code {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (code : Alpha_context.Script.expr)
    (function_parameter :
      Alpha_context.Script.expr * Alpha_context.Script.expr *
        Alpha_context.Tez.t * Chain_id.[S.HASH.t] *
        option Alpha_context.Contract.t * option Alpha_context.Contract.t *
        option Z.t * string)
    : Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          option Alpha_context.Contract.big_map_diff)) :=
    let '(storage, input, amount, chain_id, source, payer, gas, entrypoint) :=
      function_parameter in
    RPC_context.make_call0 S.run_code ctxt block tt
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint).
  
  Definition trace_code {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (code : Alpha_context.Script.expr)
    (function_parameter :
      Alpha_context.Script.expr * Alpha_context.Script.expr *
        Alpha_context.Tez.t * Chain_id.[S.HASH.t] *
        option Alpha_context.Contract.t * option Alpha_context.Contract.t *
        option Z.t * string)
    : Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          list
            (Alpha_context.Script.location * Alpha_context.Gas.t *
              list (Alpha_context.Script.expr * option string)) *
          option Alpha_context.Contract.big_map_diff)) :=
    let '(storage, input, amount, chain_id, source, payer, gas, entrypoint) :=
      function_parameter in
    RPC_context.make_call0 S.trace_code ctxt block tt
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint).
  
  Definition typecheck_code {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    : Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (list
          (Alpha_context.Script.location *
            (list (Alpha_context.Script.expr * list string) *
              list (Alpha_context.Script.expr * list string))) *
          Alpha_context.Gas.t)) :=
    RPC_context.make_call0 S.typecheck_code ctxt block tt.
  
  Definition typecheck_data {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    : Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Gas.t) :=
    RPC_context.make_call0 S.typecheck_data ctxt block tt.
  
  Definition pack_data {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    : Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult (MBytes.t * Alpha_context.Gas.t)) :=
    RPC_context.make_call0 S.pack_data ctxt block tt.
  
  Definition run_operation {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    : Alpha_context.Operation.packed * Chain_id.[S.HASH.t] -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Operation.packed_protocol_data *
          Apply_results.packed_operation_metadata)) :=
    RPC_context.make_call0 S.run_operation ctxt block tt.
  
  Definition entrypoint_type {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    : Alpha_context.Script.expr * string -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
    RPC_context.make_call0 S.entrypoint_type ctxt block tt.
  
  Definition list_entrypoints {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    : Alpha_context.Script.expr -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (list (list Michelson_v1_primitives.prim) *
          list (string * Alpha_context.Script.expr))) :=
    RPC_context.make_call0 S.list_entrypoints ctxt block tt.
End Scripts.

Module Forge.
  Module S.
    Import Data_encoding.
    
    Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div path &quot;forge&quot; % string.
    
    Definition operations
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (Operation.shell_header * Alpha_context.packed_contents_list) MBytes.t :=
      RPC_service.post_service (Some &quot;Forge an operation&quot; % string)
        RPC_query.empty Alpha_context.Operation.unsigned_encoding
        Data_encoding.__bytes_value (RPC_path.op_div path &quot;operations&quot; % string).
    
    Definition empty_proof_of_work_nonce : MBytes.t :=
      MBytes.of_string
        (String.make Constants_repr.proof_of_work_nonce_size &quot;000&quot; % char).
    
    Definition protocol_data
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit (Z * option Nonce_hash.t * MBytes.t) MBytes.t :=
      RPC_service.post_service
        (Some &quot;Forge the protocol-specific part of a block header&quot; % string)
        RPC_query.empty
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;priority&quot; % string Data_encoding.uint16)
          (Data_encoding.opt None None &quot;nonce_hash&quot; % string Nonce_hash.encoding)
          (Data_encoding.dft None None &quot;proof_of_work_nonce&quot; % string
            (Data_encoding.Fixed.__bytes_value
              Alpha_context.Constants.proof_of_work_nonce_size)
            empty_proof_of_work_nonce))
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;protocol_data&quot; % string
            Data_encoding.__bytes_value))
        (RPC_path.op_div path &quot;protocol_data&quot; % string).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    Services_registration.register0_noctxt S.protocol_data
      (fun function_parameter =&gt;
        let 'tt := function_parameter in
        fun function_parameter =&gt;
          let '(priority, seed_nonce_hash, proof_of_work_nonce) :=
            function_parameter in
          Error_monad.__return
            (Data_encoding.Binary.to_bytes_exn
              Alpha_context.Block_header.contents_encoding
              {| Alpha_context.Block_header.contents.priority := priority;
                Alpha_context.Block_header.contents.seed_nonce_hash :=
                  seed_nonce_hash;
                Alpha_context.Block_header.contents.proof_of_work_nonce :=
                  proof_of_work_nonce |})).
  
  Module Manager.
    Definition operations {D E G I K L a b c i o q : Set}
      (ctxt :
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q
          i o -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
          (E * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
            Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
              (((RPC_service.t
                ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                  (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
                (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt;
              q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
                (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
      (branch : Block_hash.[S.HASH.t]) (source : Alpha_context.public_key_hash)
      (sourcePubKey : option Signature.Public_key.[S.SPublic_key.t])
      (counter : Alpha_context.counter) (fee : Alpha_context.Tez.tez)
      (gas_limit : Z.t) (storage_limit : Z.t)
      (operations : list Alpha_context.packed_manager_operation)
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      Error_monad.op_gtgteq (Contract_services.manager_key ctxt block source)
        (fun function_parameter =&gt;
          match function_parameter with
          | (Pervasives.Error _) as e =&gt; Lwt.__return e
          | Pervasives.Ok revealed =&gt;
            let ops :=
              List.map
                (fun function_parameter =&gt;
                  let 'Alpha_context.Manager operation := function_parameter in
                  Alpha_context.Contents
                    (Alpha_context.Manager_operation
                      {|
                        Alpha_context.contents.Manager_operation.source :=
                          source;
                        Alpha_context.contents.Manager_operation.fee := fee;
                        Alpha_context.contents.Manager_operation.counter :=
                          counter;
                        Alpha_context.contents.Manager_operation.operation :=
                          operation;
                        Alpha_context.contents.Manager_operation.gas_limit :=
                          gas_limit;
                        Alpha_context.contents.Manager_operation.storage_limit :=
                          storage_limit |})) operations in
            let ops :=
              match (sourcePubKey, revealed) with
              | (None, _) | (_, Some _) =&gt; ops
              | (Some pk, None) =&gt;
                let operation := Alpha_context.Reveal pk in
                cons
                  (Alpha_context.Contents
                    (Alpha_context.Manager_operation
                      {|
                        Alpha_context.contents.Manager_operation.source :=
                          source;
                        Alpha_context.contents.Manager_operation.fee := fee;
                        Alpha_context.contents.Manager_operation.counter :=
                          counter;
                        Alpha_context.contents.Manager_operation.operation :=
                          operation;
                        Alpha_context.contents.Manager_operation.gas_limit :=
                          gas_limit;
                        Alpha_context.contents.Manager_operation.storage_limit :=
                          storage_limit |})) ops
              end in
            RPC_context.make_call0 S.operations ctxt block tt
              ({| Operation.shell_header.branch := branch |},
                (Alpha_context.Operation.of_list ops))
          end).
    
    Definition reveal {D E G I K L a b c i o q : Set}
      (ctxt :
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q
          i o -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
          (E * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
            Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
              (((RPC_service.t
                ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                  (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
                (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt;
              q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
                (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
      (branch : Block_hash.[S.HASH.t]) (source : Alpha_context.public_key_hash)
      (sourcePubKey : Signature.Public_key.[S.SPublic_key.t])
      (counter : Alpha_context.counter) (fee : Alpha_context.Tez.tez)
      (function_parameter : unit)
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      let 'tt := function_parameter in
      operations ctxt block branch source (Some sourcePubKey) counter fee Z.zero
        Z.zero [].
    
    Definition transaction {D E G I K L a b c i o q : Set}
      (ctxt :
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q
          i o -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
          (E * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
            Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
              (((RPC_service.t
                ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                  (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
                (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt;
              q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
                (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
      (branch : Block_hash.[S.HASH.t]) (source : Alpha_context.public_key_hash)
      (sourcePubKey : option Signature.Public_key.[S.SPublic_key.t])
      (counter : Alpha_context.counter) (amount : Alpha_context.Tez.tez)
      (destination : Alpha_context.Contract.contract)
      (op_staroptstar : option string)
      : option Alpha_context.Script.expr -&gt; Z.t -&gt; Z.t -&gt;
      Alpha_context.Tez.tez -&gt; unit -&gt;
      Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      let entrypoint :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; &quot;default&quot; % string
        end in
      fun parameters =&gt;
        fun gas_limit =&gt;
          fun storage_limit =&gt;
            fun fee =&gt;
              fun function_parameter =&gt;
                let 'tt := function_parameter in
                let parameters :=
                  Option.unopt_map Alpha_context.Script.lazy_expr
                    Alpha_context.Script.unit_parameter parameters in
                operations ctxt block branch source sourcePubKey counter fee
                  gas_limit storage_limit
                  (cons
                    (Alpha_context.Manager
                      (Alpha_context.Transaction
                        {|
                          Alpha_context.manager_operation.Transaction.amount :=
                            amount;
                          Alpha_context.manager_operation.Transaction.parameters :=
                            parameters;
                          Alpha_context.manager_operation.Transaction.entrypoint :=
                            entrypoint;
                          Alpha_context.manager_operation.Transaction.destination :=
                            destination |})) []).
    
    Definition origination {D E G I K L a b c i o q : Set}
      (ctxt :
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q
          i o -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
          (E * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
            Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
              (((RPC_service.t
                ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                  (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
                (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt;
              q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
                (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
      (branch : Block_hash.[S.HASH.t]) (source : Alpha_context.public_key_hash)
      (sourcePubKey : option Signature.Public_key.[S.SPublic_key.t])
      (counter : Alpha_context.counter) (balance : Alpha_context.Tez.tez)
      (delegatePubKey : option Signature.Public_key_hash.[S.SPublic_key_hash.t])
      (script : Alpha_context.Script.t) (gas_limit : Z.t) (storage_limit : Z.t)
      (fee : Alpha_context.Tez.tez) (function_parameter : unit)
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      let 'tt := function_parameter in
      operations ctxt block branch source sourcePubKey counter fee gas_limit
        storage_limit
        (cons
          (Alpha_context.Manager
            (Alpha_context.Origination
              {|
                Alpha_context.manager_operation.Origination.delegate :=
                  delegatePubKey;
                Alpha_context.manager_operation.Origination.script := script;
                Alpha_context.manager_operation.Origination.credit := balance;
                Alpha_context.manager_operation.Origination.preorigination :=
                  None |})) []).
    
    Definition delegation {D E G I K L a b c i o q : Set}
      (ctxt :
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q
          i o -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
          (E * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
            Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
              (((RPC_service.t
                ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                  (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
                (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt;
              q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
                (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
      (branch : Block_hash.[S.HASH.t]) (source : Alpha_context.public_key_hash)
      (sourcePubKey : option Signature.Public_key.[S.SPublic_key.t])
      (counter : Alpha_context.counter) (fee : Alpha_context.Tez.tez)
      (delegate : option Signature.Public_key_hash.[S.SPublic_key_hash.t])
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      operations ctxt block branch source sourcePubKey counter fee Z.zero Z.zero
        (cons (Alpha_context.Manager (Alpha_context.Delegation delegate)) []).
  End Manager.
  
  Definition operation {D E G I K L M a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (branch : Block_hash.[S.HASH.t]) (operation : Alpha_context.contents M)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    RPC_context.make_call0 S.operations ctxt block tt
      ({| Operation.shell_header.branch := branch |},
        (Alpha_context.Contents_list (Alpha_context.Single operation))).
  
  Definition endorsement {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (b : D)
    (branch : Block_hash.[S.HASH.t]) (level : Alpha_context.Raw_level.t)
    (function_parameter : unit) : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let 'tt := function_parameter in
    operation ctxt b branch
      (Alpha_context.Endorsement
        {| Alpha_context.contents.Endorsement.level := level |}).
  
  Definition proposals {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (b : D)
    (branch : Block_hash.[S.HASH.t])
    (source : Signature.Public_key_hash.[S.SPublic_key_hash.t])
    (period : Alpha_context.Voting_period.t)
    (proposals : list Protocol_hash.[S.HASH.t]) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let 'tt := function_parameter in
    operation ctxt b branch
      (Alpha_context.Proposals
        {| Alpha_context.contents.Proposals.source := source;
          Alpha_context.contents.Proposals.period := period;
          Alpha_context.contents.Proposals.proposals := proposals |}).
  
  Definition ballot {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (b : D)
    (branch : Block_hash.[S.HASH.t])
    (source : Signature.Public_key_hash.[S.SPublic_key_hash.t])
    (period : Alpha_context.Voting_period.t)
    (proposal : Protocol_hash.[S.HASH.t]) (ballot : Alpha_context.Vote.ballot)
    (function_parameter : unit) : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let 'tt := function_parameter in
    operation ctxt b branch
      (Alpha_context.Ballot
        {| Alpha_context.contents.Ballot.source := source;
          Alpha_context.contents.Ballot.period := period;
          Alpha_context.contents.Ballot.proposal := proposal;
          Alpha_context.contents.Ballot.ballot := ballot |}).
  
  Definition seed_nonce_revelation {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (branch : Block_hash.[S.HASH.t]) (level : Alpha_context.Raw_level.t)
    (nonce : Alpha_context.Nonce.t) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let 'tt := function_parameter in
    operation ctxt block branch
      (Alpha_context.Seed_nonce_revelation
        {| Alpha_context.contents.Seed_nonce_revelation.level := level;
          Alpha_context.contents.Seed_nonce_revelation.nonce := nonce |}).
  
  Definition double_baking_evidence {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (branch : Block_hash.[S.HASH.t]) (bh1 : Alpha_context.Block_header.t)
    (bh2 : Alpha_context.Block_header.t) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let 'tt := function_parameter in
    operation ctxt block branch
      (Alpha_context.Double_baking_evidence
        {| Alpha_context.contents.Double_baking_evidence.bh1 := bh1;
          Alpha_context.contents.Double_baking_evidence.bh2 := bh2 |}).
  
  Definition double_endorsement_evidence {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (branch : Block_hash.[S.HASH.t])
    (op1 : Alpha_context.operation Alpha_context.Kind.endorsement)
    (op2 : Alpha_context.operation Alpha_context.Kind.endorsement)
    (function_parameter : unit) : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let 'tt := function_parameter in
    operation ctxt block branch
      (Alpha_context.Double_endorsement_evidence
        {| Alpha_context.contents.Double_endorsement_evidence.op1 := op1;
          Alpha_context.contents.Double_endorsement_evidence.op2 := op2 |}).
  
  Definition empty_proof_of_work_nonce : MBytes.t :=
    MBytes.of_string
      (String.make Constants_repr.proof_of_work_nonce_size &quot;000&quot; % char).
  
  Definition protocol_data {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (priority : Z) (seed_nonce_hash : option Nonce_hash.t)
    (op_staroptstar : option MBytes.t)
    : unit -&gt; Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let proof_of_work_nonce :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; empty_proof_of_work_nonce
      end in
    fun function_parameter =&gt;
      let 'tt := function_parameter in
      RPC_context.make_call0 S.protocol_data ctxt block tt
        (priority, seed_nonce_hash, proof_of_work_nonce).
End Forge.

Module Parse.
  Module S.
    Import Data_encoding.
    
    Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div path &quot;parse&quot; % string.
    
    Definition operations
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit
        (list Alpha_context.Operation.raw * option bool)
        (list Alpha_context.Operation.packed) :=
      RPC_service.post_service (Some &quot;Parse operations&quot; % string)
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;operations&quot; % string
            (Data_encoding.__list_value None
              (Data_encoding.dynamic_size None
                Alpha_context.Operation.raw_encoding)))
          (Data_encoding.opt None None &quot;check_signature&quot; % string
            Data_encoding.__bool_value))
        (Data_encoding.__list_value None
          (Data_encoding.dynamic_size None Alpha_context.Operation.encoding))
        (RPC_path.op_div path &quot;operations&quot; % string).
    
    Definition block
      : RPC_service.service (* `POST *) unit Updater.rpc_context
        Updater.rpc_context unit Alpha_context.Block_header.raw
        Alpha_context.Block_header.protocol_data :=
      RPC_service.post_service (Some &quot;Parse a block&quot; % string) RPC_query.empty
        Alpha_context.Block_header.raw_encoding
        Alpha_context.Block_header.protocol_data_encoding
        (RPC_path.op_div path &quot;block&quot; % string).
  End S.
  
  Definition parse_protocol_data (protocol_data : MBytes.t)
    : Lwt.t (Error_monad.tzresult Alpha_context.Block_header.protocol_data) :=
    match
      Data_encoding.Binary.of_bytes
        Alpha_context.Block_header.protocol_data_encoding protocol_data with
    | None =&gt; Pervasives.failwith &quot;Cant_parse_protocol_data&quot; % string
    | Some protocol_data =&gt; Error_monad.__return protocol_data
    end.
  
  Definition register (function_parameter : unit) : unit :=
    let 'tt := function_parameter in
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    Services_registration.register0_noctxt S.block
      (fun function_parameter =&gt;
        let 'tt := function_parameter in
        fun raw_block =&gt;
          parse_protocol_data (Block_header.t.protocol_data raw_block)).
  
  Definition operations {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (check : option bool) (operations : list Alpha_context.Operation.raw)
    : Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Operation.packed)) :=
    RPC_context.make_call0 S.operations ctxt block tt (operations, check).
  
  Definition block {D E G I K L a b c i o q : Set}
    (ctxt :
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o
      -&gt; D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o))
        *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (G * a * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
                (* `POST *) unit + (* `PUT *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
    (shell : Block_header.shell_header) (protocol_data : MBytes.t)
    : Lwt.t
      (Error_monad.shell_tzresult Alpha_context.Block_header.protocol_data) :=
    RPC_context.make_call0 S.block ctxt block tt
      {| Block_header.t.shell := shell;
        Block_header.t.protocol_data := protocol_data |}.
End Parse.

Module S.
  Import Data_encoding.
  
  Module level_query.
    Record record := {
      offset : int32 }.
  End level_query.
  Definition level_query := level_query.record.
  
  Definition level_query : RPC_query.t level_query :=
    Pervasives.op_pipegt
      (RPC_query.op_pipeplus
        (RPC_query.__query_value
          (fun offset =&gt; {| level_query.offset := offset |}))
        (RPC_query.__field_value None &quot;offset&quot; % string RPC_arg.__int32_value
          (* ‚ùå Constant of type int32 is converted to int *)
          0 (fun t =&gt; level_query.offset t))) RPC_query.seal.
  
  Definition current_level
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context level_query unit Alpha_context.Level.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the level of the interrogated block, or the one of a block located `offset` blocks after in the chain (or before when negative). For instance, the next block if `offset` is 1.&quot;
          % string) level_query Alpha_context.Level.encoding
      (RPC_path.op_div path &quot;current_level&quot; % string).
  
  Definition levels_in_current_cycle
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context level_query unit
      (Alpha_context.Raw_level.t * Alpha_context.Raw_level.t) :=
    RPC_service.get_service (Some &quot;Levels of a cycle&quot; % string) level_query
      (Data_encoding.obj2
        (Data_encoding.req None None &quot;first&quot; % string
          Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None &quot;last&quot; % string
          Alpha_context.Raw_level.encoding))
      (RPC_path.op_div path &quot;levels_in_current_cycle&quot; % string).
End S.

Definition register (function_parameter : unit) : unit :=
  let 'tt := function_parameter in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register0 S.levels_in_current_cycle
    (fun ctxt =&gt;
      fun q =&gt;
        fun function_parameter =&gt;
          let 'tt := function_parameter in
          let levels :=
            Alpha_context.Level.levels_in_current_cycle ctxt
              (Some (S.level_query.offset q)) tt in
          match levels with
          | [] =&gt; Pervasives.raise extensible_type_value
          | _ =&gt;
            let first := List.hd (List.rev levels) in
            let last := List.hd levels in
            Error_monad.__return
              ((Alpha_context.Level.t.level first),
                (Alpha_context.Level.t.level last))
          end).

Definition current_level {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D)
  (op_staroptstar : option int32)
  : D -&gt; Lwt.t (Error_monad.shell_tzresult Alpha_context.Level.t) :=
  let offset :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt;
      (* ‚ùå Constant of type int32 is converted to int *)
      0
    end in
  fun block =&gt;
    RPC_context.make_call0 S.current_level ctxt block
      {| S.level_query.offset := offset |} tt.

Definition levels_in_current_cycle {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D)
  (op_staroptstar : option int32)
  : D -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (Alpha_context.Raw_level.t * Alpha_context.Raw_level.t)) :=
  let offset :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt;
      (* ‚ùå Constant of type int32 is converted to int *)
      0
    end in
  fun block =&gt;
    RPC_context.make_call0 S.levels_in_current_cycle ctxt block
      {| S.level_query.offset := offset |} tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="helpers_services.mli">
  <div class="col-md-6">
    <a href="#helpers_services.mli"><code>helpers_services.mli</code></a>&nbsp;<span class="label label-danger">313 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-error" title="Extensible types are not handled.">type error += Cannot_parse_operation</abbr> (* `Branch *)

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val current_level :
  'a #RPC_context.simple -&gt; ?offset:int32 -&gt; 'a -&gt; Level.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val levels_in_current_cycle :
  'a #RPC_context.simple -&gt;
  ?offset:int32 -&gt;
  'a -&gt;
  (Raw_level.t * Raw_level.t) shell_tzresult Lwt.t</abbr>

module Scripts : sig
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val run_code :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr -&gt;
    Script.expr
    * Script.expr
    * Tez.t
    * Chain_id.t
    * Contract.t option
    * Contract.t option
    * Z.t option
    * string -&gt;
    ( Script.expr
    * packed_internal_operation list
    * Contract.big_map_diff option )
    shell_tzresult
    Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val trace_code :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr -&gt;
    Script.expr
    * Script.expr
    * Tez.t
    * Chain_id.t
    * Contract.t option
    * Contract.t option
    * Z.t option
    * string -&gt;
    ( Script.expr
    * packed_internal_operation list
    * Script_interpreter.execution_trace
    * Contract.big_map_diff option )
    shell_tzresult
    Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val typecheck_code :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * Z.t option -&gt;
    (Script_tc_errors.type_map * Gas.t) shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val typecheck_data :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * Script.expr * Z.t option -&gt;
    Gas.t shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val pack_data :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * Script.expr * Z.t option -&gt;
    (MBytes.t * Gas.t) shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val run_operation :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    packed_operation * Chain_id.t -&gt;
    (packed_protocol_data * Apply_results.packed_operation_metadata)
    shell_tzresult
    Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val entrypoint_type :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * string -&gt;
    Script.expr shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val list_entrypoints :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr -&gt;
    (Michelson_v1_primitives.prim list list * (string * Script.expr) list)
    shell_tzresult
    Lwt.t</abbr>
end

module Forge : sig
  module Manager : sig
    <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val operations :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      fee:Tez.t -&gt;
      gas_limit:Z.t -&gt;
      storage_limit:Z.t -&gt;
      packed_manager_operation list -&gt;
      MBytes.t shell_tzresult Lwt.t</abbr>

    <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val reveal :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      fee:Tez.t -&gt;
      unit -&gt;
      MBytes.t shell_tzresult Lwt.t</abbr>

    <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val transaction :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      amount:Tez.t -&gt;
      destination:Contract.t -&gt;
      ?entrypoint:string -&gt;
      ?parameters:Script.expr -&gt;
      gas_limit:Z.t -&gt;
      storage_limit:Z.t -&gt;
      fee:Tez.t -&gt;
      unit -&gt;
      MBytes.t shell_tzresult Lwt.t</abbr>

    <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val origination :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      balance:Tez.t -&gt;
      ?delegatePubKey:public_key_hash -&gt;
      script:Script.t -&gt;
      gas_limit:Z.t -&gt;
      storage_limit:Z.t -&gt;
      fee:Tez.t -&gt;
      unit -&gt;
      MBytes.t shell_tzresult Lwt.t</abbr>

    <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val delegation :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      fee:Tez.t -&gt;
      public_key_hash option -&gt;
      MBytes.t shell_tzresult Lwt.t</abbr>
  end

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val endorsement :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    level:Raw_level.t -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val proposals :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    source:public_key_hash -&gt;
    period:Voting_period.t -&gt;
    proposals:Protocol_hash.t list -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val ballot :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    source:public_key_hash -&gt;
    period:Voting_period.t -&gt;
    proposal:Protocol_hash.t -&gt;
    ballot:Vote.ballot -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val seed_nonce_revelation :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    level:Raw_level.t -&gt;
    nonce:Nonce.t -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val double_baking_evidence :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    bh1:Block_header.t -&gt;
    bh2:Block_header.t -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val double_endorsement_evidence :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    op1:Kind.endorsement operation -&gt;
    op2:Kind.endorsement operation -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val protocol_data :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    priority:int -&gt;
    ?seed_nonce_hash:Nonce_hash.t -&gt;
    ?proof_of_work_nonce:MBytes.t -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t</abbr>
end

module Parse : sig
  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val operations :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    ?check:bool -&gt;
    Operation.raw list -&gt;
    Operation.packed list shell_tzresult Lwt.t</abbr>

  <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val block :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Block_header.shell_header -&gt;
    MBytes.t -&gt;
    Block_header.protocol_data shell_tzresult Lwt.t</abbr>
end

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#helpers_services.mli"><code>Helpers_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Apply_results.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Nonce_hash.
Require Tezos.Script_interpreter.
Require Tezos.Script_tc_errors.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter current_level : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; option int32 -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Level.t).

Parameter levels_in_current_cycle : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; option int32 -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (Alpha_context.Raw_level.t * Alpha_context.Raw_level.t)).

Module Scripts.
  Parameter run_code : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Script.expr -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * Alpha_context.Tez.t
      * Chain_id.[S.HASH.t] * option Alpha_context.Contract.t *
      option Alpha_context.Contract.t * option Z.t * string -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          option Alpha_context.Contract.big_map_diff)).
  
  Parameter trace_code : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Script.expr -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * Alpha_context.Tez.t
      * Chain_id.[S.HASH.t] * option Alpha_context.Contract.t *
      option Alpha_context.Contract.t * option Z.t * string -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          Script_interpreter.execution_trace *
          option Alpha_context.Contract.big_map_diff)).
  
  Parameter typecheck_code : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Script_tc_errors.type_map * Alpha_context.Gas.t)).
  
  Parameter typecheck_data : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Gas.t).
  
  Parameter pack_data : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult (MBytes.t * Alpha_context.Gas.t)).
  
  Parameter run_operation : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.packed_operation * Chain_id.[S.HASH.t] -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.packed_protocol_data *
          Apply_results.packed_operation_metadata)).
  
  Parameter entrypoint_type : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Script.expr * string -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).
  
  Parameter list_entrypoints : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Script.expr -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (list (list Michelson_v1_primitives.prim) *
          list (string * Alpha_context.Script.expr))).
End Scripts.

Module Forge.
  Module Manager.
    Parameter operations : forall {E F H J K a b c i o q : Set},
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q i
        o -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (E * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
      Block_hash.[S.HASH.t] -&gt; Alpha_context.public_key_hash -&gt;
      option Alpha_context.public_key -&gt; Alpha_context.counter -&gt;
      Alpha_context.Tez.t -&gt; Z.t -&gt; Z.t -&gt;
      list Alpha_context.packed_manager_operation -&gt;
      Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter reveal : forall {E F H J K a b c i o q : Set},
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q i
        o -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (E * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
      Block_hash.[S.HASH.t] -&gt; Alpha_context.public_key_hash -&gt;
      Alpha_context.public_key -&gt; Alpha_context.counter -&gt;
      Alpha_context.Tez.t -&gt; unit -&gt; Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter transaction : forall {E F H J K a b c i o q : Set},
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q i
        o -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (E * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
      Block_hash.[S.HASH.t] -&gt; Alpha_context.public_key_hash -&gt;
      option Alpha_context.public_key -&gt; Alpha_context.counter -&gt;
      Alpha_context.Tez.t -&gt; Alpha_context.Contract.t -&gt; option string -&gt;
      option Alpha_context.Script.expr -&gt; Z.t -&gt; Z.t -&gt; Alpha_context.Tez.t -&gt;
      unit -&gt; Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter origination : forall {E F H J K a b c i o q : Set},
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q i
        o -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (E * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
      Block_hash.[S.HASH.t] -&gt; Alpha_context.public_key_hash -&gt;
      option Alpha_context.public_key -&gt; Alpha_context.counter -&gt;
      Alpha_context.Tez.t -&gt; option Alpha_context.public_key_hash -&gt;
      Alpha_context.Script.t -&gt; Z.t -&gt; Z.t -&gt; Alpha_context.Tez.t -&gt; unit -&gt;
      Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter delegation : forall {E F H J K a b c i o q : Set},
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t RPC_context.t q i
        o -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (E * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
            (((RPC_service.t
              ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
                (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
              (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
            i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
              (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
      Block_hash.[S.HASH.t] -&gt; Alpha_context.public_key_hash -&gt;
      option Alpha_context.public_key -&gt; Alpha_context.counter -&gt;
      Alpha_context.Tez.t -&gt; option Alpha_context.public_key_hash -&gt;
      Lwt.t (Error_monad.shell_tzresult MBytes.t).
  End Manager.
  
  Parameter endorsement : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Block_hash.[S.HASH.t] -&gt; Alpha_context.Raw_level.t -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter proposals : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Block_hash.[S.HASH.t] -&gt; Alpha_context.public_key_hash -&gt;
    Alpha_context.Voting_period.t -&gt; list Protocol_hash.[S.HASH.t] -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter ballot : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Block_hash.[S.HASH.t] -&gt; Alpha_context.public_key_hash -&gt;
    Alpha_context.Voting_period.t -&gt; Protocol_hash.[S.HASH.t] -&gt;
    Alpha_context.Vote.ballot -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter seed_nonce_revelation : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Block_hash.[S.HASH.t] -&gt; Alpha_context.Raw_level.t -&gt;
    Alpha_context.Nonce.t -&gt; unit -&gt; Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter double_baking_evidence : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Block_hash.[S.HASH.t] -&gt; Alpha_context.Block_header.t -&gt;
    Alpha_context.Block_header.t -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter double_endorsement_evidence : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Block_hash.[S.HASH.t] -&gt;
    Alpha_context.operation Alpha_context.Kind.endorsement -&gt;
    Alpha_context.operation Alpha_context.Kind.endorsement -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter protocol_data : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt; Z -&gt;
    option Nonce_hash.t -&gt; option MBytes.t -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
End Forge.

Module Parse.
  Parameter operations : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt; option bool -&gt;
    list Alpha_context.Operation.raw -&gt;
    Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Operation.packed)).
  
  Parameter block : forall {E F H J K a b c i o q : Set},
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        (RPC_context.t * a) q i o -&gt; a -&gt; a -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
              (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (J * a * b * c * q * i * o)) * K)))) * K * a -&gt; a -&gt;
    Alpha_context.Block_header.shell_header -&gt; MBytes.t -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Block_header.protocol_data).
End Parse.

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="init_storage.ml">
  <div class="col-md-6">
    <a href="#init_storage.ml"><code>init_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* This is the genesis protocol: initialise the state *)
let prepare_first_block ctxt ~typecheck ~level ~timestamp ~fitness =
  Raw_context.prepare_first_block ~level ~timestamp ~fitness ctxt
  &gt;&gt;=? fun (previous_protocol, ctxt) -&gt;
  Storage.Big_map.Next.init ctxt
  &gt;&gt;=? fun ctxt -&gt;
  match previous_protocol with
  | Genesis param -&gt;
      Commitment_storage.init ctxt param.commitments
      &gt;&gt;=? fun ctxt -&gt;
      Roll_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Seed_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Contract_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Bootstrap_storage.init
        ctxt
        ~typecheck
        ?ramp_up_cycles:param.security_deposit_ramp_up_cycles
        ?no_reward_cycles:param.no_reward_cycles
        param.bootstrap_accounts
        param.bootstrap_contracts
      &gt;&gt;=? fun ctxt -&gt;
      Roll_storage.init_first_cycles ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Storage.Block_priority.init ctxt 0
      &gt;&gt;=? fun ctxt -&gt;
      Vote_storage.freeze_listings ctxt &gt;&gt;=? fun ctxt -&gt; return ctxt
  | Alpha_previous -&gt;
      return ctxt

let prepare ctxt ~level ~predecessor_timestamp ~timestamp ~fitness =
  Raw_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#init_storage.ml"><code>Init_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Bootstrap_storage.
Require Tezos.Commitment_storage.
Require Tezos.Contract_storage.
Require Tezos.Parameters_repr.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Script_repr.
Require Tezos.Seed_storage.
Require Tezos.Storage.
Require Tezos.Vote_storage.

Definition prepare_first_block
  (ctxt : Context.t)
  (typecheck :
    Raw_context.t -&gt; Script_repr.t -&gt;
    Lwt.t
      (Error_monad.tzresult
        ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  (level : int32) (timestamp : Time.t) (fitness : Fitness.[S.T.t])
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion
    (Raw_context.prepare_first_block level timestamp fitness ctxt)
    (fun function_parameter =&gt;
      let '(previous_protocol, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion (Storage.Big_map.Next.init ctxt)
        (fun ctxt =&gt;
          match previous_protocol with
          | Raw_context.Genesis param =&gt;
            Error_monad.op_gtgteqquestion
              (Commitment_storage.init ctxt
                (Parameters_repr.t.commitments param))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion (Roll_storage.init ctxt)
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion (Seed_storage.init ctxt)
                      (fun ctxt =&gt;
                        Error_monad.op_gtgteqquestion
                          (Contract_storage.init ctxt)
                          (fun ctxt =&gt;
                            Error_monad.op_gtgteqquestion
                              (Bootstrap_storage.init ctxt typecheck
                                (Parameters_repr.t.security_deposit_ramp_up_cycles
                                  param)
                                (Parameters_repr.t.no_reward_cycles param)
                                (Parameters_repr.t.bootstrap_accounts param)
                                (Parameters_repr.t.bootstrap_contracts param))
                              (fun ctxt =&gt;
                                Error_monad.op_gtgteqquestion
                                  (Roll_storage.init_first_cycles ctxt)
                                  (fun ctxt =&gt;
                                    Error_monad.op_gtgteqquestion
                                      (Vote_storage.init ctxt)
                                      (fun ctxt =&gt;
                                        Error_monad.op_gtgteqquestion
                                          (Storage.Block_priority.init ctxt 0)
                                          (fun ctxt =&gt;
                                            Error_monad.op_gtgteqquestion
                                              (Vote_storage.freeze_listings ctxt)
                                              (fun ctxt =&gt;
                                                Error_monad.__return ctxt)))))))))
          | Raw_context.Alpha_previous =&gt; Error_monad.__return ctxt
          end)).

Definition prepare
  (ctxt : Context.t) (level : Int32.t) (predecessor_timestamp : Time.t)
  (timestamp : Time.t) (fitness : Fitness.[S.T.t])
  : Lwt.t (Error_monad.tzresult Raw_context.context) :=
  Raw_context.prepare level predecessor_timestamp timestamp fitness ctxt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="legacy_script_support_repr.ml">
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.ml"><code>legacy_script_support_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(* Copyright (c) 2019 Nomadic Labs &lt;contact@nomadic-labs.com&gt;                *)
(* Copyright (c) 2019 Cryptium Labs &lt;contact@cryptium-labs.com&gt;              *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let manager_script_code : Script_repr.lazy_expr =
  let open Micheline in
  let open Michelson_v1_primitives in
  Script_repr.lazy_expr @@ strip_locations
  @@ Seq
       ( 0,
         [ Prim
             ( 0,
               K_parameter,
               [ Prim
                   ( 0,
                     T_or,
                     [ Prim
                         ( 0,
                           T_lambda,
                           [ Prim (0, T_unit, [], []);
                             Prim
                               (0, T_list, [Prim (0, T_operation, [], [])], [])
                           ],
                           [&quot;%do&quot;] );
                       Prim (0, T_unit, [], [&quot;%default&quot;]) ],
                     [] ) ],
               [] );
           Prim (0, K_storage, [Prim (0, T_key_hash, [], [])], []);
           Prim
             ( 0,
               K_code,
               [ Seq
                   ( 0,
                     [ Seq
                         ( 0,
                           [ Seq
                               ( 0,
                                 [ Prim (0, I_DUP, [], []);
                                   Prim (0, I_CAR, [], []);
                                   Prim
                                     ( 0,
                                       I_DIP,
                                       [Seq (0, [Prim (0, I_CDR, [], [])])],
                                       [] ) ] ) ] );
                       Prim
                         ( 0,
                           I_IF_LEFT,
                           [ Seq
                               ( 0,
                                 [ Prim
                                     ( 0,
                                       I_PUSH,
                                       [ Prim (0, T_mutez, [], []);
                                         Int (0, Z.zero) ],
                                       [] );
                                   Prim (0, I_AMOUNT, [], []);
                                   Seq
                                     ( 0,
                                       [ Seq
                                           ( 0,
                                             [ Prim (0, I_COMPARE, [], []);
                                               Prim (0, I_EQ, [], []) ] );
                                         Prim
                                           ( 0,
                                             I_IF,
                                             [ Seq (0, []);
                                               Seq
                                                 ( 0,
                                                   [ Seq
                                                       ( 0,
                                                         [ Prim
                                                             (0, I_UNIT, [], []);
                                                           Prim
                                                             ( 0,
                                                               I_FAILWITH,
                                                               [],
                                                               [] ) ] ) ] ) ],
                                             [] ) ] );
                                   Seq
                                     ( 0,
                                       [ Prim
                                           ( 0,
                                             I_DIP,
                                             [ Seq
                                                 (0, [Prim (0, I_DUP, [], [])])
                                             ],
                                             [] );
                                         Prim (0, I_SWAP, [], []) ] );
                                   Prim (0, I_IMPLICIT_ACCOUNT, [], []);
                                   Prim (0, I_ADDRESS, [], []);
                                   Prim (0, I_SENDER, [], []);
                                   Seq
                                     ( 0,
                                       [ Seq
                                           ( 0,
                                             [ Prim (0, I_COMPARE, [], []);
                                               Prim (0, I_EQ, [], []) ] );
                                         Prim
                                           ( 0,
                                             I_IF,
                                             [ Seq (0, []);
                                               Seq
                                                 ( 0,
                                                   [ Seq
                                                       ( 0,
                                                         [ Prim
                                                             (0, I_UNIT, [], []);
                                                           Prim
                                                             ( 0,
                                                               I_FAILWITH,
                                                               [],
                                                               [] ) ] ) ] ) ],
                                             [] ) ] );
                                   Prim (0, I_UNIT, [], []);
                                   Prim (0, I_EXEC, [], []);
                                   Prim (0, I_PAIR, [], []) ] );
                             Seq
                               ( 0,
                                 [ Prim (0, I_DROP, [], []);
                                   Prim
                                     ( 0,
                                       I_NIL,
                                       [Prim (0, T_operation, [], [])],
                                       [] );
                                   Prim (0, I_PAIR, [], []) ] ) ],
                           [] ) ] ) ],
               [] ) ] )

(* Find the toplevel expression with a given prim type from list,
   because they can be in arbitrary order. *)
let find_toplevel toplevel exprs =
  let open Micheline in
  let rec iter toplevel = function
    | (Prim (_, prim, _, _) as found) :: _
      when String.equal toplevel (Michelson_v1_primitives.string_of_prim prim)
      -&gt;
        Some found
    | _ :: rest -&gt;
        iter toplevel rest
    | [] -&gt;
        None
  in
  iter (Michelson_v1_primitives.string_of_prim toplevel) exprs

let add_do :
    manager_pkh:Signature.Public_key_hash.t -&gt;
    script_code:Script_repr.lazy_expr -&gt;
    script_storage:Script_repr.lazy_expr -&gt;
    (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t =
 fun ~manager_pkh ~script_code ~script_storage -&gt;
  let open Micheline in
  let open Michelson_v1_primitives in
  Lwt.return (Script_repr.force_decode script_code)
  &gt;&gt;=? fun (script_code_expr, _gas_cost) -&gt;
  Lwt.return (Script_repr.force_decode script_storage)
  &gt;&gt;|? fun (script_storage_expr, _gas_cost) -&gt;
  let storage_expr = root script_storage_expr in
  match root script_code_expr with
  | Seq (_, toplevel) -&gt; (
    match
      ( find_toplevel K_parameter toplevel,
        find_toplevel K_storage toplevel,
        find_toplevel K_code toplevel )
    with
    | ( Some
          (Prim
            ( _,
              K_parameter,
              [Prim (_, parameter_type, parameter_expr, parameter_annot)],
              prim_param_annot )),
        Some
          (Prim
            ( _,
              K_storage,
              [ Prim
                  (_, code_storage_type, code_storage_expr, code_storage_annot)
              ],
              k_storage_annot )),
        Some (Prim (_, K_code, [code_expr], code_annot)) ) -&gt;
        (* Note that we intentionally don't deal with potential duplicate entrypoints in this migration as there already might be some in contracts that we don't touch. *)
        let migrated_code =
          Seq
            ( 0,
              [ Prim
                  ( 0,
                    K_parameter,
                    [ Prim
                        ( 0,
                          T_or,
                          [ Prim
                              ( 0,
                                T_lambda,
                                [ Prim (0, T_unit, [], []);
                                  Prim
                                    ( 0,
                                      T_list,
                                      [Prim (0, T_operation, [], [])],
                                      [] ) ],
                                [&quot;%do&quot;] );
                            Prim
                              ( 0,
                                parameter_type,
                                parameter_expr,
                                &quot;%default&quot; :: parameter_annot ) ],
                          [] ) ],
                    prim_param_annot );
                Prim
                  ( 0,
                    K_storage,
                    [ Prim
                        ( 0,
                          T_pair,
                          [ Prim (0, T_key_hash, [], []);
                            Prim
                              ( 0,
                                code_storage_type,
                                code_storage_expr,
                                code_storage_annot ) ],
                          [] ) ],
                    k_storage_annot );
                Prim
                  ( 0,
                    K_code,
                    [ Seq
                        ( 0,
                          [ Prim (0, I_DUP, [], []);
                            Prim (0, I_CAR, [], []);
                            Prim
                              ( 0,
                                I_IF_LEFT,
                                [ Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_PUSH,
                                            [ Prim (0, T_mutez, [], []);
                                              Int (0, Z.zero) ],
                                            [] );
                                        Prim (0, I_AMOUNT, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_COMPARE, [], []);
                                                    Prim (0, I_EQ, [], []) ] );
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq (0, []);
                                                    Seq
                                                      ( 0,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_UNIT,
                                                                    [],
                                                                    [] );
                                                                Prim
                                                                  ( 0,
                                                                    I_FAILWITH,
                                                                    [],
                                                                    [] ) ] ) ]
                                                      ) ],
                                                  [] ) ] );
                                        Seq
                                          ( 0,
                                            [ Prim
                                                ( 0,
                                                  I_DIP,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            (0, I_DUP, [], [])
                                                        ] ) ],
                                                  [] );
                                              Prim (0, I_SWAP, [], []) ] );
                                        Prim (0, I_CDR, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_IMPLICIT_ACCOUNT, [], []);
                                        Prim (0, I_ADDRESS, [], []);
                                        Prim (0, I_SENDER, [], []);
                                        Seq
                                          ( 0,
                                            [ Prim (0, I_COMPARE, [], []);
                                              Prim (0, I_NEQ, [], []);
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            ( 0,
                                                              I_SENDER,
                                                              [],
                                                              [] );
                                                          Prim
                                                            ( 0,
                                                              I_PUSH,
                                                              [ Prim
                                                                  ( 0,
                                                                    T_string,
                                                                    [],
                                                                    [] );
                                                                String
                                                                  ( 0,
                                                                    &quot;Only the \
                                                                     owner \
                                                                     can \
                                                                     operate.&quot;
                                                                  ) ],
                                                              [] );
                                                          Prim
                                                            (0, I_PAIR, [], []);
                                                          Prim
                                                            ( 0,
                                                              I_FAILWITH,
                                                              [],
                                                              [] ) ] );
                                                    Seq
                                                      ( 0,
                                                        [ Prim
                                                            (0, I_UNIT, [], []);
                                                          Prim
                                                            (0, I_EXEC, [], []);
                                                          Prim
                                                            ( 0,
                                                              I_DIP,
                                                              [ Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_CDR,
                                                                          [],
                                                                          [] )
                                                                    ] ) ],
                                                              [] );
                                                          Prim
                                                            (0, I_PAIR, [], [])
                                                        ] ) ],
                                                  [] ) ] ) ] );
                                  Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_CDR, [], []);
                                                    Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CDR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []);
                                        code_expr;
                                        Prim (0, I_SWAP, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_SWAP, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CAR, [], []);
                                                    Prim
                                                      ( 0,
                                                        I_DIP,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_CDR,
                                                                    [],
                                                                    [] ) ] ) ],
                                                        [] ) ] ) ] );
                                        Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_SWAP, [], []);
                                                    Prim (0, I_PAIR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []) ] ) ],
                                [] ) ] ) ],
                    code_annot ) ] )
        in
        let migrated_storage =
          Prim
            ( 0,
              D_Pair,
              [ (* Instead of
                   `String (0, Signature.Public_key_hash.to_b58check manager_pkh)`
                   the storage is written as unparsed with [Optimized] *)
                Bytes
                  ( 0,
                    Data_encoding.Binary.to_bytes_exn
                      Signature.Public_key_hash.encoding
                      manager_pkh );
                storage_expr ],
              [] )
        in
        ( Script_repr.lazy_expr @@ strip_locations migrated_code,
          Script_repr.lazy_expr @@ strip_locations migrated_storage )
    | _ -&gt;
        (script_code, script_storage) )
  | _ -&gt;
      (script_code, script_storage)

let add_set_delegate :
    manager_pkh:Signature.Public_key_hash.t -&gt;
    script_code:Script_repr.lazy_expr -&gt;
    script_storage:Script_repr.lazy_expr -&gt;
    (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t =
 fun ~manager_pkh ~script_code ~script_storage -&gt;
  let open Micheline in
  let open Michelson_v1_primitives in
  Lwt.return (Script_repr.force_decode script_code)
  &gt;&gt;=? fun (script_code_expr, _gas_cost) -&gt;
  Lwt.return (Script_repr.force_decode script_storage)
  &gt;&gt;|? fun (script_storage_expr, _gas_cost) -&gt;
  let storage_expr = root script_storage_expr in
  match root script_code_expr with
  | Seq (_, toplevel) -&gt; (
    match
      ( find_toplevel K_parameter toplevel,
        find_toplevel K_storage toplevel,
        find_toplevel K_code toplevel )
    with
    | ( Some
          (Prim
            ( _,
              K_parameter,
              [Prim (_, parameter_type, parameter_expr, parameter_annot)],
              prim_param_annot )),
        Some
          (Prim
            ( _,
              K_storage,
              [ Prim
                  (_, code_storage_type, code_storage_expr, code_storage_annot)
              ],
              k_storage_annot )),
        Some (Prim (_, K_code, [code_expr], code_annot)) ) -&gt;
        (* Note that we intentionally don't deal with potential duplicate entrypoints in this migration as there already might be some in contracts that we don't touch. *)
        let migrated_code =
          Seq
            ( 0,
              [ Prim
                  ( 0,
                    K_parameter,
                    [ Prim
                        ( 0,
                          T_or,
                          [ Prim
                              ( 0,
                                T_or,
                                [ Prim (0, T_key_hash, [], [&quot;%set_delegate&quot;]);
                                  Prim (0, T_unit, [], [&quot;%remove_delegate&quot;]) ],
                                [] );
                            Prim
                              ( 0,
                                parameter_type,
                                parameter_expr,
                                &quot;%default&quot; :: parameter_annot ) ],
                          [] ) ],
                    prim_param_annot );
                Prim
                  ( 0,
                    K_storage,
                    [ Prim
                        ( 0,
                          T_pair,
                          [ Prim (0, T_key_hash, [], []);
                            Prim
                              ( 0,
                                code_storage_type,
                                code_storage_expr,
                                code_storage_annot ) ],
                          [] ) ],
                    k_storage_annot );
                Prim
                  ( 0,
                    K_code,
                    [ Seq
                        ( 0,
                          [ Prim (0, I_DUP, [], []);
                            Prim (0, I_CAR, [], []);
                            Prim
                              ( 0,
                                I_IF_LEFT,
                                [ Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_PUSH,
                                            [ Prim (0, T_mutez, [], []);
                                              Int (0, Z.zero) ],
                                            [] );
                                        Prim (0, I_AMOUNT, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_COMPARE, [], []);
                                                    Prim (0, I_EQ, [], []) ] );
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq (0, []);
                                                    Seq
                                                      ( 0,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_UNIT,
                                                                    [],
                                                                    [] );
                                                                Prim
                                                                  ( 0,
                                                                    I_FAILWITH,
                                                                    [],
                                                                    [] ) ] ) ]
                                                      ) ],
                                                  [] ) ] );
                                        Seq
                                          ( 0,
                                            [ Prim
                                                ( 0,
                                                  I_DIP,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            (0, I_DUP, [], [])
                                                        ] ) ],
                                                  [] );
                                              Prim (0, I_SWAP, [], []) ] );
                                        Prim (0, I_CDR, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_IMPLICIT_ACCOUNT, [], []);
                                        Prim (0, I_ADDRESS, [], []);
                                        Prim (0, I_SENDER, [], []);
                                        Seq
                                          ( 0,
                                            [ Prim (0, I_COMPARE, [], []);
                                              Prim (0, I_NEQ, [], []);
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            ( 0,
                                                              I_SENDER,
                                                              [],
                                                              [] );
                                                          Prim
                                                            ( 0,
                                                              I_PUSH,
                                                              [ Prim
                                                                  ( 0,
                                                                    T_string,
                                                                    [],
                                                                    [] );
                                                                String
                                                                  ( 0,
                                                                    &quot;Only the \
                                                                     owner \
                                                                     can \
                                                                     operate.&quot;
                                                                  ) ],
                                                              [] );
                                                          Prim
                                                            (0, I_PAIR, [], []);
                                                          Prim
                                                            ( 0,
                                                              I_FAILWITH,
                                                              [],
                                                              [] ) ] );
                                                    Seq
                                                      ( 0,
                                                        [ Prim
                                                            ( 0,
                                                              I_DIP,
                                                              [ Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_CDR,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_NIL,
                                                                          [ Prim
                                                                              ( 
                                                                              0,
                                                                               T_operation,
                                                                               [],
                                                                               []
                                                                              )
                                                                          ],
                                                                          [] )
                                                                    ] ) ],
                                                              [] );
                                                          Prim
                                                            ( 0,
                                                              I_IF_LEFT,
                                                              [ Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_SOME,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_SET_DELEGATE,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_CONS,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_PAIR,
                                                                          [],
                                                                          [] )
                                                                    ] );
                                                                Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_DROP,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_NONE,
                                                                          [ Prim
                                                                              ( 
                                                                              0,
                                                                               T_key_hash,
                                                                               [],
                                                                               []
                                                                              )
                                                                          ],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_SET_DELEGATE,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_CONS,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_PAIR,
                                                                          [],
                                                                          [] )
                                                                    ] ) ],
                                                              [] ) ] ) ],
                                                  [] ) ] ) ] );
                                  Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_CDR, [], []);
                                                    Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CDR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []);
                                        code_expr;
                                        Prim (0, I_SWAP, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_SWAP, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CAR, [], []);
                                                    Prim
                                                      ( 0,
                                                        I_DIP,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_CDR,
                                                                    [],
                                                                    [] ) ] ) ],
                                                        [] ) ] ) ] );
                                        Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_SWAP, [], []);
                                                    Prim (0, I_PAIR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []) ] ) ],
                                [] ) ] ) ],
                    code_annot ) ] )
        in
        let migrated_storage =
          Prim
            ( 0,
              D_Pair,
              [ (* Instead of
                   `String (0, Signature.Public_key_hash.to_b58check manager_pkh)`
                   the storage is written as unparsed with [Optimized] *)
                Bytes
                  ( 0,
                    Data_encoding.Binary.to_bytes_exn
                      Signature.Public_key_hash.encoding
                      manager_pkh );
                storage_expr ],
              [] )
        in
        ( Script_repr.lazy_expr @@ strip_locations migrated_code,
          Script_repr.lazy_expr @@ strip_locations migrated_storage )
    | _ -&gt;
        (script_code, script_storage) )
  | _ -&gt;
      (script_code, script_storage)

let has_default_entrypoint expr =
  let open Micheline in
  let open Michelson_v1_primitives in
  match Script_repr.force_decode expr with
  | Error _ -&gt;
      false
  | Ok (expr, _) -&gt; (
    match root expr with
    | Seq (_, toplevel) -&gt; (
      match find_toplevel K_parameter toplevel with
      | Some (Prim (_, K_parameter, [_], [&quot;%default&quot;])) -&gt;
          false
      | Some (Prim (_, K_parameter, [parameter_expr], _)) -&gt;
          let rec has_default = function
            | Prim (_, T_or, [l; r], annots) -&gt;
                List.exists (String.equal &quot;%default&quot;) annots
                || has_default l || has_default r
            | Prim (_, _, _, annots) -&gt;
                List.exists (String.equal &quot;%default&quot;) annots
            | _ -&gt;
                false
          in
          has_default parameter_expr
      | Some _ | None -&gt;
          false )
    | _ -&gt;
        false )

let add_root_entrypoint :
    script_code:Script_repr.lazy_expr -&gt; Script_repr.lazy_expr tzresult Lwt.t =
 fun ~script_code -&gt;
  let open Micheline in
  let open Michelson_v1_primitives in
  Lwt.return (Script_repr.force_decode script_code)
  &gt;&gt;|? fun (script_code_expr, _gas_cost) -&gt;
  match root script_code_expr with
  | Seq (_, toplevel) -&gt;
      let migrated_code =
        Seq
          ( 0,
            List.map
              (function
                | Prim (_, K_parameter, [parameter_expr], _) -&gt;
                    Prim (0, K_parameter, [parameter_expr], [&quot;%root&quot;])
                | Prim (_, K_code, exprs, annots) -&gt;
                    let rec rewrite_self = function
                      | ( Int _
                        | String _
                        | Bytes _
                        | Prim (_, I_CREATE_CONTRACT, _, _) ) as leaf -&gt;
                          leaf
                      | Prim (_, I_SELF, [], annots) -&gt;
                          Prim (0, I_SELF, [], &quot;%root&quot; :: annots)
                      | Prim (_, name, args, annots) -&gt;
                          Prim (0, name, List.map rewrite_self args, annots)
                      | Seq (_, args) -&gt;
                          Seq (0, List.map rewrite_self args)
                    in
                    Prim (0, K_code, List.map rewrite_self exprs, annots)
                | other -&gt;
                    other)
              toplevel )
      in
      Script_repr.lazy_expr @@ strip_locations migrated_code
  | _ -&gt;
      script_code
</pre>
  </div>
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.ml"><code>Legacy_script_support_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_repr.

Definition manager_script_code : Script_repr.lazy_expr :=
  Pervasives.op_atat Script_repr.lazy_expr
    (Pervasives.op_atat Micheline.strip_locations
      (Micheline.Seq 0
        (cons
          (Micheline.Prim 0 Michelson_v1_primitives.K_parameter
            (cons
              (Micheline.Prim 0 Michelson_v1_primitives.T_or
                (cons
                  (Micheline.Prim 0 Michelson_v1_primitives.T_lambda
                    (cons
                      (Micheline.Prim 0 Michelson_v1_primitives.T_unit [] [])
                      (cons
                        (Micheline.Prim 0 Michelson_v1_primitives.T_list
                          (cons
                            (Micheline.Prim 0
                              Michelson_v1_primitives.T_operation [] []) []) [])
                        [])) (cons &quot;%do&quot; % string []))
                  (cons
                    (Micheline.Prim 0 Michelson_v1_primitives.T_unit []
                      (cons &quot;%default&quot; % string [])) [])) []) []) [])
          (cons
            (Micheline.Prim 0 Michelson_v1_primitives.K_storage
              (cons (Micheline.Prim 0 Michelson_v1_primitives.T_key_hash [] [])
                []) [])
            (cons
              (Micheline.Prim 0 Michelson_v1_primitives.K_code
                (cons
                  (Micheline.Seq 0
                    (cons
                      (Micheline.Seq 0
                        (cons
                          (Micheline.Seq 0
                            (cons
                              (Micheline.Prim 0 Michelson_v1_primitives.I_DUP []
                                [])
                              (cons
                                (Micheline.Prim 0 Michelson_v1_primitives.I_CAR
                                  [] [])
                                (cons
                                  (Micheline.Prim 0
                                    Michelson_v1_primitives.I_DIP
                                    (cons
                                      (Micheline.Seq 0
                                        (cons
                                          (Micheline.Prim 0
                                            Michelson_v1_primitives.I_CDR [] [])
                                          [])) []) []) [])))) []))
                      (cons
                        (Micheline.Prim 0 Michelson_v1_primitives.I_IF_LEFT
                          (cons
                            (Micheline.Seq 0
                              (cons
                                (Micheline.Prim 0 Michelson_v1_primitives.I_PUSH
                                  (cons
                                    (Micheline.Prim 0
                                      Michelson_v1_primitives.T_mutez [] [])
                                    (cons (Micheline.Int 0 Z.zero) [])) [])
                                (cons
                                  (Micheline.Prim 0
                                    Michelson_v1_primitives.I_AMOUNT [] [])
                                  (cons
                                    (Micheline.Seq 0
                                      (cons
                                        (Micheline.Seq 0
                                          (cons
                                            (Micheline.Prim 0
                                              Michelson_v1_primitives.I_COMPARE
                                              [] [])
                                            (cons
                                              (Micheline.Prim 0
                                                Michelson_v1_primitives.I_EQ []
                                                []) [])))
                                        (cons
                                          (Micheline.Prim 0
                                            Michelson_v1_primitives.I_IF
                                            (cons (Micheline.Seq 0 [])
                                              (cons
                                                (Micheline.Seq 0
                                                  (cons
                                                    (Micheline.Seq 0
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_UNIT
                                                          [] [])
                                                        (cons
                                                          (Micheline.Prim 0
                                                            Michelson_v1_primitives.I_FAILWITH
                                                            [] []) []))) [])) []))
                                            []) [])))
                                    (cons
                                      (Micheline.Seq 0
                                        (cons
                                          (Micheline.Prim 0
                                            Michelson_v1_primitives.I_DIP
                                            (cons
                                              (Micheline.Seq 0
                                                (cons
                                                  (Micheline.Prim 0
                                                    Michelson_v1_primitives.I_DUP
                                                    [] []) [])) []) [])
                                          (cons
                                            (Micheline.Prim 0
                                              Michelson_v1_primitives.I_SWAP []
                                              []) [])))
                                      (cons
                                        (Micheline.Prim 0
                                          Michelson_v1_primitives.I_IMPLICIT_ACCOUNT
                                          [] [])
                                        (cons
                                          (Micheline.Prim 0
                                            Michelson_v1_primitives.I_ADDRESS []
                                            [])
                                          (cons
                                            (Micheline.Prim 0
                                              Michelson_v1_primitives.I_SENDER
                                              [] [])
                                            (cons
                                              (Micheline.Seq 0
                                                (cons
                                                  (Micheline.Seq 0
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_COMPARE
                                                        [] [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_EQ
                                                          [] []) [])))
                                                  (cons
                                                    (Micheline.Prim 0
                                                      Michelson_v1_primitives.I_IF
                                                      (cons (Micheline.Seq 0 [])
                                                        (cons
                                                          (Micheline.Seq 0
                                                            (cons
                                                              (Micheline.Seq 0
                                                                (cons
                                                                  (Micheline.Prim
                                                                    0
                                                                    Michelson_v1_primitives.I_UNIT
                                                                    [] [])
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_FAILWITH
                                                                      [] []) [])))
                                                              [])) [])) []) [])))
                                              (cons
                                                (Micheline.Prim 0
                                                  Michelson_v1_primitives.I_UNIT
                                                  [] [])
                                                (cons
                                                  (Micheline.Prim 0
                                                    Michelson_v1_primitives.I_EXEC
                                                    [] [])
                                                  (cons
                                                    (Micheline.Prim 0
                                                      Michelson_v1_primitives.I_PAIR
                                                      [] []) []))))))))))))
                            (cons
                              (Micheline.Seq 0
                                (cons
                                  (Micheline.Prim 0
                                    Michelson_v1_primitives.I_DROP [] [])
                                  (cons
                                    (Micheline.Prim 0
                                      Michelson_v1_primitives.I_NIL
                                      (cons
                                        (Micheline.Prim 0
                                          Michelson_v1_primitives.T_operation []
                                          []) []) [])
                                    (cons
                                      (Micheline.Prim 0
                                        Michelson_v1_primitives.I_PAIR [] []) []))))
                              [])) []) []))) []) []) []))))).

Definition find_toplevel {A : Set}
  (toplevel : Michelson_v1_primitives.prim)
  (exprs : list (Micheline.node A Michelson_v1_primitives.prim))
  : option (Micheline.node A Michelson_v1_primitives.prim) :=
  let fix iter {B : Set}
    (toplevel : String.t)
    (function_parameter : list (Micheline.node B Michelson_v1_primitives.prim))
    {struct toplevel}
    : option (Micheline.node B Michelson_v1_primitives.prim) :=
    match
      (function_parameter,
        match function_parameter with
        | cons ((Micheline.Prim _ prim _ _) as found) _ =&gt;
          String.equal toplevel (Michelson_v1_primitives.string_of_prim prim)
        | _ =&gt; false
        end) with
    | (cons ((Micheline.Prim _ prim _ _) as found) _, true) =&gt; Some found
    | (cons _ rest, _) =&gt; iter toplevel rest
    | ([], _) =&gt; None
    end in
  iter (Michelson_v1_primitives.string_of_prim toplevel) exprs.

Definition add_do
  (manager_pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (script_code : Script_repr.lazy_expr) (script_storage : Script_repr.lazy_expr)
  : Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Script_repr.force_decode script_code))
    (fun function_parameter =&gt;
      let '(script_code_expr, _gas_cost) := function_parameter in
      Error_monad.op_gtgtpipequestion
        (Lwt.__return (Script_repr.force_decode script_storage))
        (fun function_parameter =&gt;
          let '(script_storage_expr, _gas_cost) := function_parameter in
          let storage_expr := Micheline.root script_storage_expr in
          match Micheline.root script_code_expr with
          | Micheline.Seq _ toplevel =&gt;
            match
              ((find_toplevel Michelson_v1_primitives.K_parameter toplevel),
                (find_toplevel Michelson_v1_primitives.K_storage toplevel),
                (find_toplevel Michelson_v1_primitives.K_code toplevel)) with
            |
              (Some
                (Micheline.Prim _ Michelson_v1_primitives.K_parameter
                  (cons
                    (Micheline.Prim _ parameter_type parameter_expr
                      parameter_annot) []) prim_param_annot),
                Some
                  (Micheline.Prim _ Michelson_v1_primitives.K_storage
                    (cons
                      (Micheline.Prim _ code_storage_type code_storage_expr
                        code_storage_annot) []) k_storage_annot),
                Some
                  (Micheline.Prim _ Michelson_v1_primitives.K_code
                    (cons code_expr []) code_annot)) =&gt;
              let migrated_code :=
                Micheline.Seq 0
                  (cons
                    (Micheline.Prim 0 Michelson_v1_primitives.K_parameter
                      (cons
                        (Micheline.Prim 0 Michelson_v1_primitives.T_or
                          (cons
                            (Micheline.Prim 0 Michelson_v1_primitives.T_lambda
                              (cons
                                (Micheline.Prim 0 Michelson_v1_primitives.T_unit
                                  [] [])
                                (cons
                                  (Micheline.Prim 0
                                    Michelson_v1_primitives.T_list
                                    (cons
                                      (Micheline.Prim 0
                                        Michelson_v1_primitives.T_operation []
                                        []) []) []) []))
                              (cons &quot;%do&quot; % string []))
                            (cons
                              (Micheline.Prim 0 parameter_type parameter_expr
                                (cons &quot;%default&quot; % string parameter_annot)) []))
                          []) []) prim_param_annot)
                    (cons
                      (Micheline.Prim 0 Michelson_v1_primitives.K_storage
                        (cons
                          (Micheline.Prim 0 Michelson_v1_primitives.T_pair
                            (cons
                              (Micheline.Prim 0
                                Michelson_v1_primitives.T_key_hash [] [])
                              (cons
                                (Micheline.Prim 0 code_storage_type
                                  code_storage_expr code_storage_annot) [])) [])
                          []) k_storage_annot)
                      (cons
                        (Micheline.Prim 0 Michelson_v1_primitives.K_code
                          (cons
                            (Micheline.Seq 0
                              (cons
                                (Micheline.Prim 0 Michelson_v1_primitives.I_DUP
                                  [] [])
                                (cons
                                  (Micheline.Prim 0
                                    Michelson_v1_primitives.I_CAR [] [])
                                  (cons
                                    (Micheline.Prim 0
                                      Michelson_v1_primitives.I_IF_LEFT
                                      (cons
                                        (Micheline.Seq 0
                                          (cons
                                            (Micheline.Prim 0
                                              Michelson_v1_primitives.I_PUSH
                                              (cons
                                                (Micheline.Prim 0
                                                  Michelson_v1_primitives.T_mutez
                                                  [] [])
                                                (cons (Micheline.Int 0 Z.zero)
                                                  [])) [])
                                            (cons
                                              (Micheline.Prim 0
                                                Michelson_v1_primitives.I_AMOUNT
                                                [] [])
                                              (cons
                                                (Micheline.Seq 0
                                                  (cons
                                                    (Micheline.Seq 0
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_COMPARE
                                                          [] [])
                                                        (cons
                                                          (Micheline.Prim 0
                                                            Michelson_v1_primitives.I_EQ
                                                            [] []) [])))
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_IF
                                                        (cons
                                                          (Micheline.Seq 0 [])
                                                          (cons
                                                            (Micheline.Seq 0
                                                              (cons
                                                                (Micheline.Seq 0
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_UNIT
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_FAILWITH
                                                                        [] [])
                                                                      []))) []))
                                                            [])) []) [])))
                                                (cons
                                                  (Micheline.Seq 0
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_DIP
                                                        (cons
                                                          (Micheline.Seq 0
                                                            (cons
                                                              (Micheline.Prim 0
                                                                Michelson_v1_primitives.I_DUP
                                                                [] []) [])) [])
                                                        [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_SWAP
                                                          [] []) [])))
                                                  (cons
                                                    (Micheline.Prim 0
                                                      Michelson_v1_primitives.I_CDR
                                                      [] [])
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_CAR
                                                        [] [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_IMPLICIT_ACCOUNT
                                                          [] [])
                                                        (cons
                                                          (Micheline.Prim 0
                                                            Michelson_v1_primitives.I_ADDRESS
                                                            [] [])
                                                          (cons
                                                            (Micheline.Prim 0
                                                              Michelson_v1_primitives.I_SENDER
                                                              [] [])
                                                            (cons
                                                              (Micheline.Seq 0
                                                                (cons
                                                                  (Micheline.Prim
                                                                    0
                                                                    Michelson_v1_primitives.I_COMPARE
                                                                    [] [])
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_NEQ
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_IF
                                                                        (cons
                                                                          (Micheline.Seq
                                                                            0
                                                                            (cons
                                                                              (Micheline.Prim
                                                                                0
                                                                                Michelson_v1_primitives.I_SENDER
                                                                                []
                                                                                [])
                                                                              (cons
                                                                                (Micheline.Prim
                                                                                  0
                                                                                  Michelson_v1_primitives.I_PUSH
                                                                                  (cons
                                                                                    (Micheline.Prim
                                                                                      0
                                                                                      Michelson_v1_primitives.T_string
                                                                                      []
                                                                                      [])
                                                                                    (cons
                                                                                      (Micheline.String
                                                                                        0
                                                                                        &quot;Only the owner can operate.&quot;
                                                                                          %
                                                                                          string)
                                                                                      []))
                                                                                  [])
                                                                                (cons
                                                                                  (Micheline.Prim
                                                                                    0
                                                                                    Michelson_v1_primitives.I_PAIR
                                                                                    []
                                                                                    [])
                                                                                  (cons
                                                                                    (Micheline.Prim
                                                                                      0
                                                                                      Michelson_v1_primitives.I_FAILWITH
                                                                                      []
                                                                                      [])
                                                                                    [])))))
                                                                          (cons
                                                                            (Micheline.Seq
                                                                              0
                                                                              (cons
                                                                                (Micheline.Prim
                                                                                  0
                                                                                  Michelson_v1_primitives.I_UNIT
                                                                                  []
                                                                                  [])
                                                                                (cons
                                                                                  (Micheline.Prim
                                                                                    0
                                                                                    Michelson_v1_primitives.I_EXEC
                                                                                    []
                                                                                    [])
                                                                                  (cons
                                                                                    (Micheline.Prim
                                                                                      0
                                                                                      Michelson_v1_primitives.I_DIP
                                                                                      (cons
                                                                                        (Micheline.Seq
                                                                                          0
                                                                                          (cons
                                                                                            (Micheline.Prim
                                                                                              0
                                                                                              Michelson_v1_primitives.I_CDR
                                                                                              []
                                                                                              [])
                                                                                            []))
                                                                                        [])
                                                                                      [])
                                                                                    (cons
                                                                                      (Micheline.Prim
                                                                                        0
                                                                                        Michelson_v1_primitives.I_PAIR
                                                                                        []
                                                                                        [])
                                                                                      [])))))
                                                                            []))
                                                                        []) []))))
                                                              [])))))))))))
                                        (cons
                                          (Micheline.Seq 0
                                            (cons
                                              (Micheline.Prim 0
                                                Michelson_v1_primitives.I_DIP
                                                (cons
                                                  (Micheline.Seq 0
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_CDR
                                                        [] [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_DUP
                                                          [] [])
                                                        (cons
                                                          (Micheline.Prim 0
                                                            Michelson_v1_primitives.I_CDR
                                                            [] []) [])))) []) [])
                                              (cons
                                                (Micheline.Prim 0
                                                  Michelson_v1_primitives.I_PAIR
                                                  [] [])
                                                (cons code_expr
                                                  (cons
                                                    (Micheline.Prim 0
                                                      Michelson_v1_primitives.I_SWAP
                                                      [] [])
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_CAR
                                                        [] [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_SWAP
                                                          [] [])
                                                        (cons
                                                          (Micheline.Seq 0
                                                            (cons
                                                              (Micheline.Seq 0
                                                                (cons
                                                                  (Micheline.Prim
                                                                    0
                                                                    Michelson_v1_primitives.I_DUP
                                                                    [] [])
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_CAR
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_DIP
                                                                        (cons
                                                                          (Micheline.Seq
                                                                            0
                                                                            (cons
                                                                              (Micheline.Prim
                                                                                0
                                                                                Michelson_v1_primitives.I_CDR
                                                                                []
                                                                                [])
                                                                              []))
                                                                          []) [])
                                                                      [])))) []))
                                                          (cons
                                                            (Micheline.Prim 0
                                                              Michelson_v1_primitives.I_DIP
                                                              (cons
                                                                (Micheline.Seq 0
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_SWAP
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_PAIR
                                                                        [] [])
                                                                      []))) [])
                                                              [])
                                                            (cons
                                                              (Micheline.Prim 0
                                                                Michelson_v1_primitives.I_PAIR
                                                                [] []) []))))))))))
                                          [])) []) [])))) []) code_annot) [])))
                in
              let migrated_storage :=
                Micheline.Prim 0 Michelson_v1_primitives.D_Pair
                  (cons
                    (Micheline.Bytes 0
                      (Data_encoding.Binary.to_bytes_exn
                        Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
                        manager_pkh)) (cons storage_expr [])) [] in
              ((Pervasives.op_atat Script_repr.lazy_expr
                (Micheline.strip_locations migrated_code)),
                (Pervasives.op_atat Script_repr.lazy_expr
                  (Micheline.strip_locations migrated_storage)))
            | _ =&gt; (script_code, script_storage)
            end
          | _ =&gt; (script_code, script_storage)
          end)).

Definition add_set_delegate
  (manager_pkh : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  (script_code : Script_repr.lazy_expr) (script_storage : Script_repr.lazy_expr)
  : Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Script_repr.force_decode script_code))
    (fun function_parameter =&gt;
      let '(script_code_expr, _gas_cost) := function_parameter in
      Error_monad.op_gtgtpipequestion
        (Lwt.__return (Script_repr.force_decode script_storage))
        (fun function_parameter =&gt;
          let '(script_storage_expr, _gas_cost) := function_parameter in
          let storage_expr := Micheline.root script_storage_expr in
          match Micheline.root script_code_expr with
          | Micheline.Seq _ toplevel =&gt;
            match
              ((find_toplevel Michelson_v1_primitives.K_parameter toplevel),
                (find_toplevel Michelson_v1_primitives.K_storage toplevel),
                (find_toplevel Michelson_v1_primitives.K_code toplevel)) with
            |
              (Some
                (Micheline.Prim _ Michelson_v1_primitives.K_parameter
                  (cons
                    (Micheline.Prim _ parameter_type parameter_expr
                      parameter_annot) []) prim_param_annot),
                Some
                  (Micheline.Prim _ Michelson_v1_primitives.K_storage
                    (cons
                      (Micheline.Prim _ code_storage_type code_storage_expr
                        code_storage_annot) []) k_storage_annot),
                Some
                  (Micheline.Prim _ Michelson_v1_primitives.K_code
                    (cons code_expr []) code_annot)) =&gt;
              let migrated_code :=
                Micheline.Seq 0
                  (cons
                    (Micheline.Prim 0 Michelson_v1_primitives.K_parameter
                      (cons
                        (Micheline.Prim 0 Michelson_v1_primitives.T_or
                          (cons
                            (Micheline.Prim 0 Michelson_v1_primitives.T_or
                              (cons
                                (Micheline.Prim 0
                                  Michelson_v1_primitives.T_key_hash []
                                  (cons &quot;%set_delegate&quot; % string []))
                                (cons
                                  (Micheline.Prim 0
                                    Michelson_v1_primitives.T_unit []
                                    (cons &quot;%remove_delegate&quot; % string [])) []))
                              [])
                            (cons
                              (Micheline.Prim 0 parameter_type parameter_expr
                                (cons &quot;%default&quot; % string parameter_annot)) []))
                          []) []) prim_param_annot)
                    (cons
                      (Micheline.Prim 0 Michelson_v1_primitives.K_storage
                        (cons
                          (Micheline.Prim 0 Michelson_v1_primitives.T_pair
                            (cons
                              (Micheline.Prim 0
                                Michelson_v1_primitives.T_key_hash [] [])
                              (cons
                                (Micheline.Prim 0 code_storage_type
                                  code_storage_expr code_storage_annot) [])) [])
                          []) k_storage_annot)
                      (cons
                        (Micheline.Prim 0 Michelson_v1_primitives.K_code
                          (cons
                            (Micheline.Seq 0
                              (cons
                                (Micheline.Prim 0 Michelson_v1_primitives.I_DUP
                                  [] [])
                                (cons
                                  (Micheline.Prim 0
                                    Michelson_v1_primitives.I_CAR [] [])
                                  (cons
                                    (Micheline.Prim 0
                                      Michelson_v1_primitives.I_IF_LEFT
                                      (cons
                                        (Micheline.Seq 0
                                          (cons
                                            (Micheline.Prim 0
                                              Michelson_v1_primitives.I_PUSH
                                              (cons
                                                (Micheline.Prim 0
                                                  Michelson_v1_primitives.T_mutez
                                                  [] [])
                                                (cons (Micheline.Int 0 Z.zero)
                                                  [])) [])
                                            (cons
                                              (Micheline.Prim 0
                                                Michelson_v1_primitives.I_AMOUNT
                                                [] [])
                                              (cons
                                                (Micheline.Seq 0
                                                  (cons
                                                    (Micheline.Seq 0
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_COMPARE
                                                          [] [])
                                                        (cons
                                                          (Micheline.Prim 0
                                                            Michelson_v1_primitives.I_EQ
                                                            [] []) [])))
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_IF
                                                        (cons
                                                          (Micheline.Seq 0 [])
                                                          (cons
                                                            (Micheline.Seq 0
                                                              (cons
                                                                (Micheline.Seq 0
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_UNIT
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_FAILWITH
                                                                        [] [])
                                                                      []))) []))
                                                            [])) []) [])))
                                                (cons
                                                  (Micheline.Seq 0
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_DIP
                                                        (cons
                                                          (Micheline.Seq 0
                                                            (cons
                                                              (Micheline.Prim 0
                                                                Michelson_v1_primitives.I_DUP
                                                                [] []) [])) [])
                                                        [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_SWAP
                                                          [] []) [])))
                                                  (cons
                                                    (Micheline.Prim 0
                                                      Michelson_v1_primitives.I_CDR
                                                      [] [])
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_CAR
                                                        [] [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_IMPLICIT_ACCOUNT
                                                          [] [])
                                                        (cons
                                                          (Micheline.Prim 0
                                                            Michelson_v1_primitives.I_ADDRESS
                                                            [] [])
                                                          (cons
                                                            (Micheline.Prim 0
                                                              Michelson_v1_primitives.I_SENDER
                                                              [] [])
                                                            (cons
                                                              (Micheline.Seq 0
                                                                (cons
                                                                  (Micheline.Prim
                                                                    0
                                                                    Michelson_v1_primitives.I_COMPARE
                                                                    [] [])
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_NEQ
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_IF
                                                                        (cons
                                                                          (Micheline.Seq
                                                                            0
                                                                            (cons
                                                                              (Micheline.Prim
                                                                                0
                                                                                Michelson_v1_primitives.I_SENDER
                                                                                []
                                                                                [])
                                                                              (cons
                                                                                (Micheline.Prim
                                                                                  0
                                                                                  Michelson_v1_primitives.I_PUSH
                                                                                  (cons
                                                                                    (Micheline.Prim
                                                                                      0
                                                                                      Michelson_v1_primitives.T_string
                                                                                      []
                                                                                      [])
                                                                                    (cons
                                                                                      (Micheline.String
                                                                                        0
                                                                                        &quot;Only the owner can operate.&quot;
                                                                                          %
                                                                                          string)
                                                                                      []))
                                                                                  [])
                                                                                (cons
                                                                                  (Micheline.Prim
                                                                                    0
                                                                                    Michelson_v1_primitives.I_PAIR
                                                                                    []
                                                                                    [])
                                                                                  (cons
                                                                                    (Micheline.Prim
                                                                                      0
                                                                                      Michelson_v1_primitives.I_FAILWITH
                                                                                      []
                                                                                      [])
                                                                                    [])))))
                                                                          (cons
                                                                            (Micheline.Seq
                                                                              0
                                                                              (cons
                                                                                (Micheline.Prim
                                                                                  0
                                                                                  Michelson_v1_primitives.I_DIP
                                                                                  (cons
                                                                                    (Micheline.Seq
                                                                                      0
                                                                                      (cons
                                                                                        (Micheline.Prim
                                                                                          0
                                                                                          Michelson_v1_primitives.I_CDR
                                                                                          []
                                                                                          [])
                                                                                        (cons
                                                                                          (Micheline.Prim
                                                                                            0
                                                                                            Michelson_v1_primitives.I_NIL
                                                                                            (cons
                                                                                              (Micheline.Prim
                                                                                                0
                                                                                                Michelson_v1_primitives.T_operation
                                                                                                []
                                                                                                [])
                                                                                              [])
                                                                                            [])
                                                                                          [])))
                                                                                    [])
                                                                                  [])
                                                                                (cons
                                                                                  (Micheline.Prim
                                                                                    0
                                                                                    Michelson_v1_primitives.I_IF_LEFT
                                                                                    (cons
                                                                                      (Micheline.Seq
                                                                                        0
                                                                                        (cons
                                                                                          (Micheline.Prim
                                                                                            0
                                                                                            Michelson_v1_primitives.I_SOME
                                                                                            []
                                                                                            [])
                                                                                          (cons
                                                                                            (Micheline.Prim
                                                                                              0
                                                                                              Michelson_v1_primitives.I_SET_DELEGATE
                                                                                              []
                                                                                              [])
                                                                                            (cons
                                                                                              (Micheline.Prim
                                                                                                0
                                                                                                Michelson_v1_primitives.I_CONS
                                                                                                []
                                                                                                [])
                                                                                              (cons
                                                                                                (Micheline.Prim
                                                                                                  0
                                                                                                  Michelson_v1_primitives.I_PAIR
                                                                                                  []
                                                                                                  [])
                                                                                                [])))))
                                                                                      (cons
                                                                                        (Micheline.Seq
                                                                                          0
                                                                                          (cons
                                                                                            (Micheline.Prim
                                                                                              0
                                                                                              Michelson_v1_primitives.I_DROP
                                                                                              []
                                                                                              [])
                                                                                            (cons
                                                                                              (Micheline.Prim
                                                                                                0
                                                                                                Michelson_v1_primitives.I_NONE
                                                                                                (cons
                                                                                                  (Micheline.Prim
                                                                                                    0
                                                                                                    Michelson_v1_primitives.T_key_hash
                                                                                                    []
                                                                                                    [])
                                                                                                  [])
                                                                                                [])
                                                                                              (cons
                                                                                                (Micheline.Prim
                                                                                                  0
                                                                                                  Michelson_v1_primitives.I_SET_DELEGATE
                                                                                                  []
                                                                                                  [])
                                                                                                (cons
                                                                                                  (Micheline.Prim
                                                                                                    0
                                                                                                    Michelson_v1_primitives.I_CONS
                                                                                                    []
                                                                                                    [])
                                                                                                  (cons
                                                                                                    (Micheline.Prim
                                                                                                      0
                                                                                                      Michelson_v1_primitives.I_PAIR
                                                                                                      []
                                                                                                      [])
                                                                                                    []))))))
                                                                                        []))
                                                                                    [])
                                                                                  [])))
                                                                            []))
                                                                        []) []))))
                                                              [])))))))))))
                                        (cons
                                          (Micheline.Seq 0
                                            (cons
                                              (Micheline.Prim 0
                                                Michelson_v1_primitives.I_DIP
                                                (cons
                                                  (Micheline.Seq 0
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_CDR
                                                        [] [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_DUP
                                                          [] [])
                                                        (cons
                                                          (Micheline.Prim 0
                                                            Michelson_v1_primitives.I_CDR
                                                            [] []) [])))) []) [])
                                              (cons
                                                (Micheline.Prim 0
                                                  Michelson_v1_primitives.I_PAIR
                                                  [] [])
                                                (cons code_expr
                                                  (cons
                                                    (Micheline.Prim 0
                                                      Michelson_v1_primitives.I_SWAP
                                                      [] [])
                                                    (cons
                                                      (Micheline.Prim 0
                                                        Michelson_v1_primitives.I_CAR
                                                        [] [])
                                                      (cons
                                                        (Micheline.Prim 0
                                                          Michelson_v1_primitives.I_SWAP
                                                          [] [])
                                                        (cons
                                                          (Micheline.Seq 0
                                                            (cons
                                                              (Micheline.Seq 0
                                                                (cons
                                                                  (Micheline.Prim
                                                                    0
                                                                    Michelson_v1_primitives.I_DUP
                                                                    [] [])
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_CAR
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_DIP
                                                                        (cons
                                                                          (Micheline.Seq
                                                                            0
                                                                            (cons
                                                                              (Micheline.Prim
                                                                                0
                                                                                Michelson_v1_primitives.I_CDR
                                                                                []
                                                                                [])
                                                                              []))
                                                                          []) [])
                                                                      [])))) []))
                                                          (cons
                                                            (Micheline.Prim 0
                                                              Michelson_v1_primitives.I_DIP
                                                              (cons
                                                                (Micheline.Seq 0
                                                                  (cons
                                                                    (Micheline.Prim
                                                                      0
                                                                      Michelson_v1_primitives.I_SWAP
                                                                      [] [])
                                                                    (cons
                                                                      (Micheline.Prim
                                                                        0
                                                                        Michelson_v1_primitives.I_PAIR
                                                                        [] [])
                                                                      []))) [])
                                                              [])
                                                            (cons
                                                              (Micheline.Prim 0
                                                                Michelson_v1_primitives.I_PAIR
                                                                [] []) []))))))))))
                                          [])) []) [])))) []) code_annot) [])))
                in
              let migrated_storage :=
                Micheline.Prim 0 Michelson_v1_primitives.D_Pair
                  (cons
                    (Micheline.Bytes 0
                      (Data_encoding.Binary.to_bytes_exn
                        Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
                        manager_pkh)) (cons storage_expr [])) [] in
              ((Pervasives.op_atat Script_repr.lazy_expr
                (Micheline.strip_locations migrated_code)),
                (Pervasives.op_atat Script_repr.lazy_expr
                  (Micheline.strip_locations migrated_storage)))
            | _ =&gt; (script_code, script_storage)
            end
          | _ =&gt; (script_code, script_storage)
          end)).

Definition has_default_entrypoint (expr : Script_repr.lazy_expr) : bool :=
  match Script_repr.force_decode expr with
  | Pervasives.Error _ =&gt; false
  | Pervasives.Ok (expr, _) =&gt;
    match Micheline.root expr with
    | Micheline.Seq _ toplevel =&gt;
      match find_toplevel Michelson_v1_primitives.K_parameter toplevel with
      |
        Some
          (Micheline.Prim _ Michelson_v1_primitives.K_parameter (cons _ [])
            (cons &quot;%default&quot; % string [])) =&gt; false
      |
        Some
          (Micheline.Prim _ Michelson_v1_primitives.K_parameter
            (cons parameter_expr []) _) =&gt;
        let fix has_default {A : Set}
          (function_parameter : Micheline.node A Michelson_v1_primitives.prim)
          {struct function_parameter} : bool :=
          match function_parameter with
          |
            Micheline.Prim _ Michelson_v1_primitives.T_or (cons l (cons r []))
              annots =&gt;
            Pervasives.op_pipepipe
              (List.__exists (String.equal &quot;%default&quot; % string) annots)
              (Pervasives.op_pipepipe (has_default l) (has_default r))
          | Micheline.Prim _ _ _ annots =&gt;
            List.__exists (String.equal &quot;%default&quot; % string) annots
          | _ =&gt; false
          end in
        has_default parameter_expr
      | Some _ | None =&gt; false
      end
    | _ =&gt; false
    end
  end.

Definition add_root_entrypoint (script_code : Script_repr.lazy_expr)
  : Lwt.t (Error_monad.tzresult Script_repr.lazy_expr) :=
  Error_monad.op_gtgtpipequestion
    (Lwt.__return (Script_repr.force_decode script_code))
    (fun function_parameter =&gt;
      let '(script_code_expr, _gas_cost) := function_parameter in
      match Micheline.root script_code_expr with
      | Micheline.Seq _ toplevel =&gt;
        let migrated_code :=
          Micheline.Seq 0
            (List.map
              (fun function_parameter =&gt;
                match function_parameter with
                |
                  Micheline.Prim _ Michelson_v1_primitives.K_parameter
                    (cons parameter_expr []) _ =&gt;
                  Micheline.Prim 0 Michelson_v1_primitives.K_parameter
                    (cons parameter_expr []) (cons &quot;%root&quot; % string [])
                | Micheline.Prim _ Michelson_v1_primitives.K_code exprs annots
                  =&gt;
                  let fix rewrite_self
                    (function_parameter :
                      Micheline.node Z Michelson_v1_primitives.prim)
                    {struct function_parameter}
                    : Micheline.node Z Michelson_v1_primitives.prim :=
                    match function_parameter with
                    |
                      (Micheline.Int _ _ | Micheline.String _ _ |
                      Micheline.Bytes _ _ |
                      Micheline.Prim _ Michelson_v1_primitives.I_CREATE_CONTRACT
                        _ _) as leaf =&gt; leaf
                    | Micheline.Prim _ Michelson_v1_primitives.I_SELF [] annots
                      =&gt;
                      Micheline.Prim 0 Michelson_v1_primitives.I_SELF []
                        (cons &quot;%root&quot; % string annots)
                    | Micheline.Prim _ name args annots =&gt;
                      Micheline.Prim 0 name (List.map rewrite_self args) annots
                    | Micheline.Seq _ args =&gt;
                      Micheline.Seq 0 (List.map rewrite_self args)
                    end in
                  Micheline.Prim 0 Michelson_v1_primitives.K_code
                    (List.map rewrite_self exprs) annots
                | other =&gt; other
                end) toplevel) in
        Pervasives.op_atat Script_repr.lazy_expr
          (Micheline.strip_locations migrated_code)
      | _ =&gt; script_code
      end).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="legacy_script_support_repr.mli">
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.mli"><code>legacy_script_support_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(* Copyright (c) 2019 Nomadic Labs &lt;contact@nomadic-labs.com&gt;                *)
(* Copyright (c) 2019 Cryptium Labs &lt;contact@cryptium-labs.com&gt;              *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** This code mimics the now defunct scriptless KT1s.

    The manager contract is from:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/7b42f2e970e1541af54f8a9b6820b4f18e847575/src/contracts/manager.tz
    The formal proof is at:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/a7603e12021166e15890f6d504feebec2f945502/src/contracts_coq/manager.v *)
val manager_script_code : Script_repr.lazy_expr

(** This code mimics the now defunct &quot;spendable&quot; flags of KT1s by
    adding a [do] entrypoint, preserving the original script's at
    'default' entrypoint.

    The pseudo-code for the applied transformations is from:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/7b42f2e970e1541af54f8a9b6820b4f18e847575/src/contracts/transform/add_do.tz *)
val add_do :
  manager_pkh:Signature.Public_key_hash.t -&gt;
  script_code:Script_repr.lazy_expr -&gt;
  script_storage:Script_repr.lazy_expr -&gt;
  (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t

(** This code mimics the now defunct &quot;spendable&quot; flags of KT1s by
    adding a [do] entrypoint, preserving the original script's at
    'default' entrypoint.

    The pseudo-code for the applied transformations is from:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/7b42f2e970e1541af54f8a9b6820b4f18e847575/src/contracts/transform/add_set_delegate.tz *)
val add_set_delegate :
  manager_pkh:Signature.Public_key_hash.t -&gt;
  script_code:Script_repr.lazy_expr -&gt;
  script_storage:Script_repr.lazy_expr -&gt;
  (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t

(** Checks if a contract was declaring a default entrypoint somewhere
   else than at the root, in which case its type changes when
   entrypoints are activated. *)
val has_default_entrypoint : Script_repr.lazy_expr -&gt; bool

(** Adds a [%root] annotation on the toplevel parameter construct. *)
val add_root_entrypoint :
  script_code:Script_repr.lazy_expr -&gt; Script_repr.lazy_expr tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.mli"><code>Legacy_script_support_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Script_repr.

Parameter manager_script_code : Script_repr.lazy_expr.

Parameter add_do :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Script_repr.lazy_expr -&gt;
  Script_repr.lazy_expr -&gt;
  Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)).

Parameter add_set_delegate :
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Script_repr.lazy_expr -&gt;
  Script_repr.lazy_expr -&gt;
  Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)).

Parameter has_default_entrypoint : Script_repr.lazy_expr -&gt; bool.

Parameter add_root_entrypoint :
  Script_repr.lazy_expr -&gt; Lwt.t (Error_monad.tzresult Script_repr.lazy_expr).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_repr.ml">
  <div class="col-md-6">
    <a href="#level_repr.ml"><code>level_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = {
  level : Raw_level_repr.t;
  level_position : int32;
  cycle : Cycle_repr.t;
  cycle_position : int32;
  voting_period : Voting_period_repr.t;
  voting_period_position : int32;
  expected_commitment : bool;
}

module CompareModule = Compare.Make (struct
  type nonrec t = t

  let compare {level = l1} {level = l2} = Raw_level_repr.compare l1 l2
end)

include CompareModule

type level = t

let pp ppf {level} = Raw_level_repr.pp ppf level

let pp_full ppf l =
  Format.fprintf
    ppf
    &quot;%a.%ld (cycle %a.%ld) (vote %a.%ld)&quot;
    Raw_level_repr.pp
    l.level
    l.level_position
    Cycle_repr.pp
    l.cycle
    l.cycle_position
    Voting_period_repr.pp
    l.voting_period
    l.voting_period_position

let encoding =
  let open Data_encoding in
  conv
    (fun { level;
           level_position;
           cycle;
           cycle_position;
           voting_period;
           voting_period_position;
           expected_commitment } -&gt;
      ( level,
        level_position,
        cycle,
        cycle_position,
        voting_period,
        voting_period_position,
        expected_commitment ))
    (fun ( level,
           level_position,
           cycle,
           cycle_position,
           voting_period,
           voting_period_position,
           expected_commitment ) -&gt;
      {
        level;
        level_position;
        cycle;
        cycle_position;
        voting_period;
        voting_period_position;
        expected_commitment;
      })
    (obj7
       (req
          &quot;level&quot;
          ~description:
            &quot;The level of the block relative to genesis. This is also the \
             Shell's notion of level&quot;
          Raw_level_repr.encoding)
       (req
          &quot;level_position&quot;
          ~description:
            &quot;The level of the block relative to the block that starts \
             protocol alpha. This is specific to the protocol alpha. Other \
             protocols might or might not include a similar notion.&quot;
          int32)
       (req
          &quot;cycle&quot;
          ~description:
            &quot;The current cycle's number. Note that cycles are a \
             protocol-specific notion. As a result, the cycle number starts \
             at 0 with the first block of protocol alpha.&quot;
          Cycle_repr.encoding)
       (req
          &quot;cycle_position&quot;
          ~description:
            &quot;The current level of the block relative to the first block of \
             the current cycle.&quot;
          int32)
       (req
          &quot;voting_period&quot;
          ~description:
            &quot;The current voting period's index. Note that cycles are a \
             protocol-specific notion. As a result, the voting period index \
             starts at 0 with the first block of protocol alpha.&quot;
          Voting_period_repr.encoding)
       (req
          &quot;voting_period_position&quot;
          ~description:
            &quot;The current level of the block relative to the first block of \
             the current voting period.&quot;
          int32)
       (req
          &quot;expected_commitment&quot;
          ~description:
            &quot;Tells wether the baker of this block has to commit a seed nonce \
             hash.&quot;
          bool))

let root first_level =
  {
    level = first_level;
    level_position = 0l;
    cycle = Cycle_repr.root;
    cycle_position = 0l;
    voting_period = Voting_period_repr.root;
    voting_period_position = 0l;
    expected_commitment = false;
  }

let from_raw ~first_level ~blocks_per_cycle ~blocks_per_voting_period
    ~blocks_per_commitment level =
  let raw_level = Raw_level_repr.to_int32 level in
  let first_level = Raw_level_repr.to_int32 first_level in
  let level_position =
    Compare.Int32.max 0l (Int32.sub raw_level first_level)
  in
  let cycle =
    Cycle_repr.of_int32_exn (Int32.div level_position blocks_per_cycle)
  in
  let cycle_position = Int32.rem level_position blocks_per_cycle in
  let voting_period =
    Voting_period_repr.of_int32_exn
      (Int32.div level_position blocks_per_voting_period)
  in
  let voting_period_position =
    Int32.rem level_position blocks_per_voting_period
  in
  let expected_commitment =
    Compare.Int32.(
      Int32.rem cycle_position blocks_per_commitment
      = Int32.pred blocks_per_commitment)
  in
  {
    level;
    level_position;
    cycle;
    cycle_position;
    voting_period;
    voting_period_position;
    expected_commitment;
  }

let diff {level = l1; _} {level = l2; _} =
  Int32.sub (Raw_level_repr.to_int32 l1) (Raw_level_repr.to_int32 l2)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_repr.ml"><code>Level_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Cycle_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Voting_period_repr.

Module t.
  Record record := {
    level : Raw_level_repr.t;
    level_position : int32;
    cycle : Cycle_repr.t;
    cycle_position : int32;
    voting_period : Voting_period_repr.t;
    voting_period_position : int32;
    expected_commitment : bool }.
End t.
Definition t := t.record.

Definition CompareModule :=
  Compare.Make
    (let compare (function_parameter : t) : t -&gt; Z :=
      let '{| t.level := l1 |} := function_parameter in
      fun function_parameter =&gt;
        let '{| t.level := l2 |} := function_parameter in
        Raw_level_repr.compare l1 l2 in
    existT _ _
      {|
        Compare.COMPARABLE.compare := compare
        |}).

Definition op_eq := CompareModule.[Compare.S.op_eq].

Definition op_ltgt := CompareModule.[Compare.S.op_ltgt].

Definition op_lt := CompareModule.[Compare.S.op_lt].

Definition op_lteq := CompareModule.[Compare.S.op_lteq].

Definition op_gteq := CompareModule.[Compare.S.op_gteq].

Definition op_gt := CompareModule.[Compare.S.op_gt].

Definition compare := CompareModule.[Compare.S.compare].

Definition equal := CompareModule.[Compare.S.equal].

Definition max := CompareModule.[Compare.S.max].

Definition min := CompareModule.[Compare.S.min].

Definition level := t.

Definition pp (ppf : Format.formatter) (function_parameter : t) : unit :=
  let '{| t.level := level |} := function_parameter in
  Raw_level_repr.pp ppf level.

Definition pp_full (ppf : Format.formatter) (l : t) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Alpha
        (CamlinternalFormatBasics.Char_literal &quot;.&quot; % char
          (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
            CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.No_precision
            (CamlinternalFormatBasics.String_literal &quot; (cycle &quot; % string
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Char_literal &quot;.&quot; % char
                  (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.No_precision
                    (CamlinternalFormatBasics.String_literal &quot;) (vote &quot; % string
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Char_literal &quot;.&quot; % char
                          (CamlinternalFormatBasics.Int32
                            CamlinternalFormatBasics.Int_d
                            CamlinternalFormatBasics.No_padding
                            CamlinternalFormatBasics.No_precision
                            (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                              CamlinternalFormatBasics.End_of_format))))))))))))
      &quot;%a.%ld (cycle %a.%ld) (vote %a.%ld)&quot; % string) Raw_level_repr.pp
    (t.level l) (t.level_position l) Cycle_repr.pp (t.cycle l)
    (t.cycle_position l) Voting_period_repr.pp (t.voting_period l)
    (t.voting_period_position l).

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        t.level := level;
          t.level_position := level_position;
          t.cycle := cycle;
          t.cycle_position := cycle_position;
          t.voting_period := voting_period;
          t.voting_period_position := voting_period_position;
          t.expected_commitment := expected_commitment
          |} := function_parameter in
      (level, level_position, cycle, cycle_position, voting_period,
        voting_period_position, expected_commitment))
    (fun function_parameter =&gt;
      let
        '(level, level_position, cycle, cycle_position, voting_period,
          voting_period_position, expected_commitment) := function_parameter in
      {| t.level := level; t.level_position := level_position; t.cycle := cycle;
        t.cycle_position := cycle_position; t.voting_period := voting_period;
        t.voting_period_position := voting_period_position;
        t.expected_commitment := expected_commitment |}) None
    (Data_encoding.obj7
      (Data_encoding.req None
        (Some
          &quot;The level of the block relative to genesis. This is also the Shell's notion of level&quot;
            % string) &quot;level&quot; % string Raw_level_repr.encoding)
      (Data_encoding.req None
        (Some
          &quot;The level of the block relative to the block that starts protocol alpha. This is specific to the protocol alpha. Other protocols might or might not include a similar notion.&quot;
            % string) &quot;level_position&quot; % string Data_encoding.__int32_value)
      (Data_encoding.req None
        (Some
          &quot;The current cycle's number. Note that cycles are a protocol-specific notion. As a result, the cycle number starts at 0 with the first block of protocol alpha.&quot;
            % string) &quot;cycle&quot; % string Cycle_repr.encoding)
      (Data_encoding.req None
        (Some
          &quot;The current level of the block relative to the first block of the current cycle.&quot;
            % string) &quot;cycle_position&quot; % string Data_encoding.__int32_value)
      (Data_encoding.req None
        (Some
          &quot;The current voting period's index. Note that cycles are a protocol-specific notion. As a result, the voting period index starts at 0 with the first block of protocol alpha.&quot;
            % string) &quot;voting_period&quot; % string Voting_period_repr.encoding)
      (Data_encoding.req None
        (Some
          &quot;The current level of the block relative to the first block of the current voting period.&quot;
            % string) &quot;voting_period_position&quot; % string
        Data_encoding.__int32_value)
      (Data_encoding.req None
        (Some
          &quot;Tells wether the baker of this block has to commit a seed nonce hash.&quot;
            % string) &quot;expected_commitment&quot; % string Data_encoding.__bool_value)).

Definition root (first_level : Raw_level_repr.t) : t :=
  {| t.level := first_level;
    t.level_position :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0; t.cycle := Cycle_repr.root;
    t.cycle_position :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0; t.voting_period := Voting_period_repr.root;
    t.voting_period_position :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0; t.expected_commitment := false |}.

Definition from_raw
  (first_level : Raw_level_repr.raw_level) (blocks_per_cycle : int32)
  (blocks_per_voting_period : int32) (blocks_per_commitment : int32)
  (level : Raw_level_repr.raw_level) : t :=
  let raw_level := Raw_level_repr.to_int32 level in
  let first_level := Raw_level_repr.to_int32 first_level in
  let level_position :=
    Compare.Int32.[Compare.S.max]
      (* ‚ùå Constant of type int32 is converted to int *)
      0 (Int32.sub raw_level first_level) in
  let cycle :=
    Cycle_repr.of_int32_exn (Int32.div level_position blocks_per_cycle) in
  let cycle_position := Int32.rem level_position blocks_per_cycle in
  let voting_period :=
    Voting_period_repr.of_int32_exn
      (Int32.div level_position blocks_per_voting_period) in
  let voting_period_position :=
    Int32.rem level_position blocks_per_voting_period in
  let expected_commitment :=
    Compare.Int32.[Compare.S.op_eq]
      (Int32.rem cycle_position blocks_per_commitment)
      (Int32.pred blocks_per_commitment) in
  {| t.level := level; t.level_position := level_position; t.cycle := cycle;
    t.cycle_position := cycle_position; t.voting_period := voting_period;
    t.voting_period_position := voting_period_position;
    t.expected_commitment := expected_commitment |}.

Definition diff (function_parameter : t) : t -&gt; int32 :=
  let '{| t.level := l1 |} := function_parameter in
  fun function_parameter =&gt;
    let '{| t.level := l2 |} := function_parameter in
    Int32.sub (Raw_level_repr.to_int32 l1) (Raw_level_repr.to_int32 l2).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_repr.mli">
  <div class="col-md-6">
    <a href="#level_repr.mli"><code>level_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = private {
  level : Raw_level_repr.t;
      (** The level of the block relative to genesis. This
                              is also the Shell's notion of level. *)
  level_position : int32;
      (** The level of the block relative to the block that
                            starts protocol alpha. This is specific to the
                            protocol alpha. Other protocols might or might not
                            include a similar notion. *)
  cycle : Cycle_repr.t;
      (** The current cycle's number. Note that cycles are a
                          protocol-specific notion. As a result, the cycle
                          number starts at 0 with the first block of protocol
                          alpha. *)
  cycle_position : int32;
      (** The current level of the block relative to the first
                            block of the current cycle. *)
  voting_period : Voting_period_repr.t;
  voting_period_position : int32;
  expected_commitment : bool;
}

(* Note that, the type `t` above must respect some invariants (hence the
   `private` annotation). Notably:

   level_position = cycle * blocks_per_cycle + cycle_position
*)

type level = t

include Compare.S with type t := level

val encoding : level Data_encoding.t

val pp : Format.formatter -&gt; level -&gt; unit

val pp_full : Format.formatter -&gt; level -&gt; unit

val root : Raw_level_repr.t -&gt; level

val from_raw :
  first_level:Raw_level_repr.t -&gt;
  blocks_per_cycle:int32 -&gt;
  blocks_per_voting_period:int32 -&gt;
  blocks_per_commitment:int32 -&gt;
  Raw_level_repr.t -&gt;
  level

val diff : level -&gt; level -&gt; int32
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_repr.mli"><code>Level_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Cycle_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Voting_period_repr.

Module t.
  Record record := {
    level : Raw_level_repr.t;
    level_position : int32;
    cycle : Cycle_repr.t;
    cycle_position : int32;
    voting_period : Voting_period_repr.t;
    voting_period_position : int32;
    expected_commitment : bool }.
End t.
Definition t := t.record.

Definition level := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature level}.

Definition op_eq := Included_S.[Compare.S.op_eq].

Definition op_ltgt := Included_S.[Compare.S.op_ltgt].

Definition op_lt := Included_S.[Compare.S.op_lt].

Definition op_lteq := Included_S.[Compare.S.op_lteq].

Definition op_gteq := Included_S.[Compare.S.op_gteq].

Definition op_gt := Included_S.[Compare.S.op_gt].

Definition compare := Included_S.[Compare.S.compare].

Definition equal := Included_S.[Compare.S.equal].

Definition max := Included_S.[Compare.S.max].

Definition min := Included_S.[Compare.S.min].

Parameter encoding : Data_encoding.t level.

Parameter pp : Format.formatter -&gt; level -&gt; unit.

Parameter pp_full : Format.formatter -&gt; level -&gt; unit.

Parameter root : Raw_level_repr.t -&gt; level.

Parameter from_raw :
  Raw_level_repr.t -&gt; int32 -&gt; int32 -&gt; int32 -&gt; Raw_level_repr.t -&gt; level.

Parameter diff : level -&gt; level -&gt; int32.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_storage.ml">
  <div class="col-md-6">
    <a href="#level_storage.ml"><code>level_storage.ml</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Level_repr

let from_raw c ?offset l =
  let l =
    match offset with
    | None -&gt;
        l
    | Some o -&gt;
        Raw_level_repr.(of_int32_exn (Int32.add (to_int32 l) o))
  in
  let constants = Raw_context.constants c in
  let first_level = Raw_context.first_level c in
  Level_repr.from_raw
    ~first_level
    ~blocks_per_cycle:constants.Constants_repr.blocks_per_cycle
    ~blocks_per_voting_period:constants.Constants_repr.blocks_per_voting_period
    ~blocks_per_commitment:constants.Constants_repr.blocks_per_commitment
    l

let root c = Level_repr.root (Raw_context.first_level c)

let succ c l = from_raw c (Raw_level_repr.succ l.level)

let pred c l =
  match Raw_level_repr.pred l.Level_repr.level with
  | None -&gt;
      None
  | Some l -&gt;
      Some (from_raw c l)

let current ctxt = Raw_context.current_level ctxt

let previous ctxt =
  let l = current ctxt in
  match pred ctxt l with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* We never validate the Genesis... *)
  | Some p -&gt;
      p

let first_level_in_cycle ctxt c =
  let constants = Raw_context.constants ctxt in
  let first_level = Raw_context.first_level ctxt in
  from_raw
    ctxt
    (Raw_level_repr.of_int32_exn
       (Int32.add
          (Raw_level_repr.to_int32 first_level)
          (Int32.mul
             constants.Constants_repr.blocks_per_cycle
             (Cycle_repr.to_int32 c))))

let last_level_in_cycle ctxt c =
  match pred ctxt (first_level_in_cycle ctxt (Cycle_repr.succ c)) with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | Some x -&gt;
      x

let levels_in_cycle ctxt cycle =
  let first = first_level_in_cycle ctxt cycle in
  let rec loop n acc =
    if Cycle_repr.(n.cycle = first.cycle) then loop (succ ctxt n) (n :: acc)
    else acc
  in
  loop first []

let levels_in_current_cycle ctxt ?(offset = 0l) () =
  let current_cycle = Cycle_repr.to_int32 (current ctxt).cycle in
  let cycle = Int32.add current_cycle offset in
  if Compare.Int32.(cycle &lt; 0l) then []
  else
    let cycle = Cycle_repr.of_int32_exn cycle in
    levels_in_cycle ctxt cycle

let levels_with_commitments_in_cycle ctxt c =
  let first = first_level_in_cycle ctxt c in
  let rec loop n acc =
    if Cycle_repr.(n.cycle = first.cycle) then
      if n.expected_commitment then loop (succ ctxt n) (n :: acc)
      else loop (succ ctxt n) acc
    else acc
  in
  loop first []

let last_allowed_fork_level c =
  let level = Raw_context.current_level c in
  let preserved_cycles = Constants_storage.preserved_cycles c in
  match Cycle_repr.sub level.cycle preserved_cycles with
  | None -&gt;
      Raw_level_repr.root
  | Some cycle -&gt;
      (first_level_in_cycle c cycle).level
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_storage.ml"><code>Level_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.

Import Level_repr.

Definition from_raw
  (c : Raw_context.context) (offset : option int32)
  (l : Raw_level_repr.raw_level) : Level_repr.level :=
  let l :=
    match offset with
    | None =&gt; l
    | Some o =&gt;
      Raw_level_repr.of_int32_exn (Int32.add (Raw_level_repr.to_int32 l) o)
    end in
  let constants := Raw_context.constants c in
  let first_level := Raw_context.first_level c in
  Level_repr.from_raw first_level
    (Constants_repr.parametric.blocks_per_cycle constants)
    (Constants_repr.parametric.blocks_per_voting_period constants)
    (Constants_repr.parametric.blocks_per_commitment constants) l.

Definition root (c : Raw_context.context) : Level_repr.level :=
  Level_repr.root (Raw_context.first_level c).

Definition succ (c : Raw_context.context) (l : Level_repr.t)
  : Level_repr.level :=
  from_raw c None (Raw_level_repr.succ (Level_repr.t.level l)).

Definition pred (c : Raw_context.context) (l : Level_repr.t)
  : option Level_repr.level :=
  match Raw_level_repr.pred (Level_repr.t.level l) with
  | None =&gt; None
  | Some l =&gt; Some (from_raw c None l)
  end.

Definition current (ctxt : Raw_context.context) : Level_repr.t :=
  Raw_context.current_level ctxt.

Definition previous (ctxt : Raw_context.context) : Level_repr.level :=
  let l := current ctxt in
  match pred ctxt l with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some p =&gt; p
  end.

Definition first_level_in_cycle
  (ctxt : Raw_context.context) (c : Cycle_repr.cycle) : Level_repr.level :=
  let constants := Raw_context.constants ctxt in
  let first_level := Raw_context.first_level ctxt in
  from_raw ctxt None
    (Raw_level_repr.of_int32_exn
      (Int32.add (Raw_level_repr.to_int32 first_level)
        (Int32.mul (Constants_repr.parametric.blocks_per_cycle constants)
          (Cycle_repr.to_int32 c)))).

Definition last_level_in_cycle
  (ctxt : Raw_context.context) (c : Cycle_repr.cycle) : Level_repr.level :=
  match pred ctxt (first_level_in_cycle ctxt (Cycle_repr.succ c)) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some x =&gt; x
  end.

Definition levels_in_cycle
  (ctxt : Raw_context.context) (cycle : Cycle_repr.cycle) : list Level_repr.t :=
  let first := first_level_in_cycle ctxt cycle in
  let fix loop (n : Level_repr.t) (acc : list Level_repr.t) {struct n}
    : list Level_repr.t :=
    if Cycle_repr.op_eq (Level_repr.t.cycle n) (Level_repr.t.cycle first) then
      loop (succ ctxt n) (cons n acc)
    else
      acc in
  loop first [].

Definition levels_in_current_cycle
  (ctxt : Raw_context.context) (op_staroptstar : option int32)
  : unit -&gt; list Level_repr.t :=
  let offset :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt;
      (* ‚ùå Constant of type int32 is converted to int *)
      0
    end in
  fun function_parameter =&gt;
    let 'tt := function_parameter in
    let current_cycle := Cycle_repr.to_int32 (Level_repr.t.cycle (current ctxt))
      in
    let cycle := Int32.add current_cycle offset in
    if
      Compare.Int32.[Compare.S.op_lt] cycle
        (* ‚ùå Constant of type int32 is converted to int *)
        0 then
      []
    else
      let cycle := Cycle_repr.of_int32_exn cycle in
      levels_in_cycle ctxt cycle.

Definition levels_with_commitments_in_cycle
  (ctxt : Raw_context.context) (c : Cycle_repr.cycle) : list Level_repr.t :=
  let first := first_level_in_cycle ctxt c in
  let fix loop (n : Level_repr.t) (acc : list Level_repr.t) {struct n}
    : list Level_repr.t :=
    if Cycle_repr.op_eq (Level_repr.t.cycle n) (Level_repr.t.cycle first) then
      if Level_repr.t.expected_commitment n then
        loop (succ ctxt n) (cons n acc)
      else
        loop (succ ctxt n) acc
    else
      acc in
  loop first [].

Definition last_allowed_fork_level (c : Raw_context.context)
  : Raw_level_repr.raw_level :=
  let level := Raw_context.current_level c in
  let preserved_cycles := Constants_storage.preserved_cycles c in
  match Cycle_repr.sub (Level_repr.t.cycle level) preserved_cycles with
  | None =&gt; Raw_level_repr.root
  | Some cycle =&gt; Level_repr.t.level (first_level_in_cycle c cycle)
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_storage.mli">
  <div class="col-md-6">
    <a href="#level_storage.mli"><code>level_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val current : Raw_context.t -&gt; Level_repr.t

val previous : Raw_context.t -&gt; Level_repr.t

val root : Raw_context.t -&gt; Level_repr.t

val from_raw :
  Raw_context.t -&gt; ?offset:int32 -&gt; Raw_level_repr.t -&gt; Level_repr.t

val pred : Raw_context.t -&gt; Level_repr.t -&gt; Level_repr.t option

val succ : Raw_context.t -&gt; Level_repr.t -&gt; Level_repr.t

val first_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t

val last_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t

val levels_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t list

val levels_in_current_cycle :
  Raw_context.t -&gt; ?offset:int32 -&gt; unit -&gt; Level_repr.t list

val levels_with_commitments_in_cycle :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t list

val last_allowed_fork_level : Raw_context.t -&gt; Raw_level_repr.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_storage.mli"><code>Level_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.

Parameter current : Raw_context.t -&gt; Level_repr.t.

Parameter previous : Raw_context.t -&gt; Level_repr.t.

Parameter root : Raw_context.t -&gt; Level_repr.t.

Parameter from_raw :
  Raw_context.t -&gt; option int32 -&gt; Raw_level_repr.t -&gt; Level_repr.t.

Parameter pred : Raw_context.t -&gt; Level_repr.t -&gt; option Level_repr.t.

Parameter succ : Raw_context.t -&gt; Level_repr.t -&gt; Level_repr.t.

Parameter first_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t.

Parameter last_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t.

Parameter levels_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; list Level_repr.t.

Parameter levels_in_current_cycle :
  Raw_context.t -&gt; option int32 -&gt; unit -&gt; list Level_repr.t.

Parameter levels_with_commitments_in_cycle :
  Raw_context.t -&gt; Cycle_repr.t -&gt; list Level_repr.t.

Parameter last_allowed_fork_level : Raw_context.t -&gt; Raw_level_repr.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="main.ml">
  <div class="col-md-6">
    <a href="#main.ml"><code>main.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Protocol Signature Instance *)

type block_header_data = Alpha_context.Block_header.protocol_data

type block_header = Alpha_context.Block_header.t = {
  shell : Block_header.shell_header;
  protocol_data : block_header_data;
}

let block_header_data_encoding =
  Alpha_context.Block_header.protocol_data_encoding

type block_header_metadata = Apply_results.block_metadata

let block_header_metadata_encoding = Apply_results.block_metadata_encoding

type operation_data = Alpha_context.packed_protocol_data =
  | Operation_data :
      'kind Alpha_context.Operation.protocol_data
      -&gt; operation_data

let operation_data_encoding = Alpha_context.Operation.protocol_data_encoding

type operation_receipt = Apply_results.packed_operation_metadata =
  | Operation_metadata :
      'kind Apply_results.operation_metadata
      -&gt; operation_receipt
  | No_operation_metadata : operation_receipt

let operation_receipt_encoding = Apply_results.operation_metadata_encoding

let operation_data_and_receipt_encoding =
  Apply_results.operation_data_and_metadata_encoding

type operation = Alpha_context.packed_operation = {
  shell : Operation.shell_header;
  protocol_data : operation_data;
}

let acceptable_passes = Alpha_context.Operation.acceptable_passes

let max_block_length = Alpha_context.Block_header.max_header_length

let max_operation_data_length =
  Alpha_context.Constants.max_operation_data_length

let validation_passes =
  let max_anonymous_operations =
    Alpha_context.Constants.max_revelations_per_block
    + (* allow 100 wallet activations or denunciations per block *) 100
  in
  Updater.
    [ {max_size = 32 * 1024; max_op = Some 32};
      (* 32 endorsements *)
      {max_size = 32 * 1024; max_op = None};
      (* 32k of voting operations *)
      {
        max_size = max_anonymous_operations * 1024;
        max_op = Some max_anonymous_operations;
      };
      {max_size = 512 * 1024; max_op = None} ]

(* 512kB *)

let rpc_services =
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Alpha_services.register () ;
  Services_registration.get_rpc_services ()</abbr>

type validation_mode =
  | Application of {
      block_header : Alpha_context.Block_header.t;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_application of {
      block_header : Alpha_context.Block_header.t;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_construction of {predecessor : Block_hash.t}
  | Full_construction of {
      predecessor : Block_hash.t;
      protocol_data : Alpha_context.Block_header.contents;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }

type validation_state = {
  mode : validation_mode;
  chain_id : Chain_id.t;
  ctxt : Alpha_context.t;
  op_count : int;
}

let current_context {ctxt; _} = return (Alpha_context.finalize ctxt).context

let begin_partial_application ~chain_id ~ancestor_context:ctxt
    ~predecessor_timestamp ~predecessor_fitness
    (block_header : Alpha_context.Block_header.t) =
  let level = block_header.shell.level in
  let fitness = predecessor_fitness in
  let timestamp = block_header.shell.timestamp in
  Alpha_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt;
  Apply.begin_application ctxt chain_id block_header predecessor_timestamp
  &gt;&gt;=? fun (ctxt, baker, block_delay) -&gt;
  let mode =
    Partial_application
      {block_header; baker = Signature.Public_key.hash baker; block_delay}
  in
  return {mode; chain_id; ctxt; op_count = 0}

let begin_application ~chain_id ~predecessor_context:ctxt
    ~predecessor_timestamp ~predecessor_fitness
    (block_header : Alpha_context.Block_header.t) =
  let level = block_header.shell.level in
  let fitness = predecessor_fitness in
  let timestamp = block_header.shell.timestamp in
  Alpha_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt;
  Apply.begin_application ctxt chain_id block_header predecessor_timestamp
  &gt;&gt;=? fun (ctxt, baker, block_delay) -&gt;
  let mode =
    Application
      {block_header; baker = Signature.Public_key.hash baker; block_delay}
  in
  return {mode; chain_id; ctxt; op_count = 0}

let begin_construction ~chain_id ~predecessor_context:ctxt
    ~predecessor_timestamp ~predecessor_level:pred_level
    ~predecessor_fitness:pred_fitness ~predecessor ~timestamp
    ?(protocol_data : block_header_data option) () =
  let level = Int32.succ pred_level in
  let fitness = pred_fitness in
  Alpha_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt;
  ( match protocol_data with
  | None -&gt;
      Apply.begin_partial_construction ctxt
      &gt;&gt;=? fun ctxt -&gt;
      let mode = Partial_construction {predecessor} in
      return (mode, ctxt)
  | Some proto_header -&gt;
      Apply.begin_full_construction
        ctxt
        predecessor_timestamp
        proto_header.contents
      &gt;&gt;=? fun (ctxt, protocol_data, baker, block_delay) -&gt;
      let mode =
        let baker = Signature.Public_key.hash baker in
        Full_construction {predecessor; baker; protocol_data; block_delay}
      in
      return (mode, ctxt) )
  &gt;&gt;=? fun (mode, ctxt) -&gt; return {mode; chain_id; ctxt; op_count = 0}

let apply_operation ({mode; chain_id; ctxt; op_count; _} as data)
    (operation : Alpha_context.packed_operation) =
  match mode with
  | Partial_application _
    when not
           (List.exists
              (Compare.Int.equal 0)
              (Alpha_context.Operation.acceptable_passes operation)) -&gt;
      (* Multipass validation only considers operations in pass 0. *)
      let op_count = op_count + 1 in
      return (<abbr class="mark-error" title="Record substitution not handled">{data with ctxt; op_count}</abbr>, No_operation_metadata)
  | _ -&gt;
      let {shell; protocol_data = Operation_data protocol_data} = operation in
      let operation : _ Alpha_context.operation = {shell; protocol_data} in
      let (predecessor, baker) =
        match mode with
        | Partial_application
            {block_header = {shell = {predecessor; _}; _}; baker}
        | Application {block_header = {shell = {predecessor; _}; _}; baker}
        | Full_construction {predecessor; baker; _} -&gt;
            (predecessor, baker)
        | Partial_construction {predecessor} -&gt;
            (predecessor, Signature.Public_key_hash.zero)
      in
      Apply.apply_operation
        ctxt
        chain_id
        Optimized
        predecessor
        baker
        (Alpha_context.Operation.hash operation)
        operation
      &gt;&gt;=? fun (ctxt, result) -&gt;
      let op_count = op_count + 1 in
      return (<abbr class="mark-error" title="Record substitution not handled">{data with ctxt; op_count}</abbr>, Operation_metadata result)

let finalize_block {mode; ctxt; op_count} =
  match mode with
  | Partial_construction _ -&gt;
      let level = Alpha_context.Level.current ctxt in
      Alpha_context.Vote.get_current_period_kind ctxt
      &gt;&gt;=? fun voting_period_kind -&gt;
      let baker = Signature.Public_key_hash.zero in
      Signature.Public_key_hash.Map.fold
        (fun delegate deposit ctxt -&gt;
          ctxt
          &gt;&gt;=? fun ctxt -&gt;
          Alpha_context.Delegate.freeze_deposit ctxt delegate deposit)
        (Alpha_context.get_deposits ctxt)
        (return ctxt)
      &gt;&gt;=? fun ctxt -&gt;
      let ctxt = Alpha_context.finalize ctxt in
      return
        ( ctxt,
          Apply_results.
            {
              baker;
              level;
              voting_period_kind;
              nonce_hash = None;
              consumed_gas = Z.zero;
              deactivated = [];
              balance_updates = [];
            } )
  | Partial_application {block_header; baker; block_delay} -&gt;
      let level = Alpha_context.Level.current ctxt in
      let included_endorsements = Alpha_context.included_endorsements ctxt in
      Apply.check_minimum_endorsements
        ctxt
        block_header.protocol_data.contents
        block_delay
        included_endorsements
      &gt;&gt;=? fun () -&gt;
      Alpha_context.Vote.get_current_period_kind ctxt
      &gt;&gt;=? fun voting_period_kind -&gt;
      let ctxt = Alpha_context.finalize ctxt in
      return
        ( ctxt,
          Apply_results.
            {
              baker;
              level;
              voting_period_kind;
              nonce_hash = None;
              consumed_gas = Z.zero;
              deactivated = [];
              balance_updates = [];
            } )
  | Application
      { baker;
        block_delay;
        block_header = {protocol_data = {contents = protocol_data; _}; _} }
  | Full_construction {protocol_data; baker; block_delay; _} -&gt;
      Apply.finalize_application ctxt protocol_data baker ~block_delay
      &gt;&gt;=? fun (ctxt, receipt) -&gt;
      let level = Alpha_context.Level.current ctxt in
      let priority = protocol_data.priority in
      let raw_level = Alpha_context.Raw_level.to_int32 level.level in
      let fitness = Alpha_context.Fitness.current ctxt in
      let commit_message =
        Format.asprintf
          &quot;lvl %ld, fit 1:%Ld, prio %d, %d ops&quot;
          raw_level
          fitness
          priority
          op_count
      in
      let ctxt = Alpha_context.finalize ~commit_message ctxt in
      return (ctxt, receipt)

let compare_operations op1 op2 =
  let open Alpha_context in
  let (Operation_data op1) = op1.protocol_data in
  let (Operation_data op2) = op2.protocol_data in
  match (op1.contents, op2.contents) with
  | (Single (Endorsement _), Single (Endorsement _)) -&gt;
      0
  | (_, Single (Endorsement _)) -&gt;
      1
  | (Single (Endorsement _), _) -&gt;
      -1
  | (Single (Seed_nonce_revelation _), Single (Seed_nonce_revelation _)) -&gt;
      0
  | (_, Single (Seed_nonce_revelation _)) -&gt;
      1
  | (Single (Seed_nonce_revelation _), _) -&gt;
      -1
  | ( Single (Double_endorsement_evidence _),
      Single (Double_endorsement_evidence _) ) -&gt;
      0
  | (_, Single (Double_endorsement_evidence _)) -&gt;
      1
  | (Single (Double_endorsement_evidence _), _) -&gt;
      -1
  | (Single (Double_baking_evidence _), Single (Double_baking_evidence _)) -&gt;
      0
  | (_, Single (Double_baking_evidence _)) -&gt;
      1
  | (Single (Double_baking_evidence _), _) -&gt;
      -1
  | (Single (Activate_account _), Single (Activate_account _)) -&gt;
      0
  | (_, Single (Activate_account _)) -&gt;
      1
  | (Single (Activate_account _), _) -&gt;
      -1
  | (Single (Proposals _), Single (Proposals _)) -&gt;
      0
  | (_, Single (Proposals _)) -&gt;
      1
  | (Single (Proposals _), _) -&gt;
      -1
  | (Single (Ballot _), Single (Ballot _)) -&gt;
      0
  | (_, Single (Ballot _)) -&gt;
      1
  | (Single (Ballot _), _) -&gt;
      -1
  (* Manager operations with smaller counter are pre-validated first. *)
  | (Single (Manager_operation op1), Single (Manager_operation op2)) -&gt;
      Z.compare op1.counter op2.counter
  | (Cons (Manager_operation op1, _), Single (Manager_operation op2)) -&gt;
      Z.compare op1.counter op2.counter
  | (Single (Manager_operation op1), Cons (Manager_operation op2, _)) -&gt;
      Z.compare op1.counter op2.counter
  | (Cons (Manager_operation op1, _), Cons (Manager_operation op2, _)) -&gt;
      Z.compare op1.counter op2.counter

let init ctxt block_header =
  let level = block_header.Block_header.level in
  let fitness = block_header.fitness in
  let timestamp = block_header.timestamp in
  let typecheck (ctxt : Alpha_context.context)
      (script : Alpha_context.Script.t) =
    Script_ir_translator.parse_script ctxt ~legacy:false script
    &gt;&gt;=? fun (Ex_script parsed_script, ctxt) -&gt;
    Script_ir_translator.extract_big_map_diff
      ctxt
      Optimized
      parsed_script.storage_type
      parsed_script.storage
      ~to_duplicate:Script_ir_translator.no_big_map_id
      ~to_update:Script_ir_translator.no_big_map_id
      ~temporary:false
    &gt;&gt;=? fun (storage, big_map_diff, ctxt) -&gt;
    Script_ir_translator.unparse_data
      ctxt
      Optimized
      parsed_script.storage_type
      storage
    &gt;&gt;=? fun (storage, ctxt) -&gt;
    let storage =
      Alpha_context.Script.lazy_expr (Micheline.strip_locations storage)
    in
    return ((<abbr class="mark-error" title="Record substitution not handled">{script with storage}</abbr>, big_map_diff), ctxt)
  in
  Alpha_context.prepare_first_block ~typecheck ~level ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt; return (Alpha_context.finalize ctxt)

(* Vanity nonce: 313282890 *)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#main.ml"><code>Main.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Apply.
Require Tezos.Apply_results.
Require Tezos.Script_ir_translator.
Require Tezos.Script_typed_ir.
Require Tezos.Services_registration.

Definition block_header_data := Alpha_context.Block_header.protocol_data.

Module block_header.
  Record record := {
    shell : Block_header.shell_header;
    protocol_data : block_header_data }.
End block_header.
Definition block_header := block_header.record.

Definition block_header_data_encoding
  : Data_encoding.encoding Alpha_context.Block_header.protocol_data :=
  Alpha_context.Block_header.protocol_data_encoding.

Definition block_header_metadata := Apply_results.block_metadata.

Definition block_header_metadata_encoding
  : Data_encoding.encoding Apply_results.block_metadata :=
  Apply_results.block_metadata_encoding.

Reserved Notation &quot;'operation_data&quot;.

Inductive operation_data_gadt : Set :=
| Operation_data : forall {kind : Set},
  Alpha_context.Operation.protocol_data kind -&gt; operation_data_gadt

where &quot;'operation_data&quot; := (operation_data_gadt).

Definition operation_data := 'operation_data.

Definition operation_data_encoding
  : Data_encoding.t Alpha_context.Operation.packed_protocol_data :=
  Alpha_context.Operation.protocol_data_encoding.

Reserved Notation &quot;'operation_receipt&quot;.

Inductive operation_receipt_gadt : Set :=
| Operation_metadata : forall {kind : Set},
  Apply_results.operation_metadata kind -&gt; operation_receipt_gadt
| No_operation_metadata : operation_receipt_gadt

where &quot;'operation_receipt&quot; := (operation_receipt_gadt).

Definition operation_receipt := 'operation_receipt.

Definition operation_receipt_encoding
  : Data_encoding.t Apply_results.packed_operation_metadata :=
  Apply_results.operation_metadata_encoding.

Definition operation_data_and_receipt_encoding
  : Data_encoding.t
    (Alpha_context.Operation.packed_protocol_data *
      Apply_results.packed_operation_metadata) :=
  Apply_results.operation_data_and_metadata_encoding.

Module operation.
  Record record := {
    shell : Operation.shell_header;
    protocol_data : operation_data }.
End operation.
Definition operation := operation.record.

Definition acceptable_passes : Alpha_context.packed_operation -&gt; list Z :=
  Alpha_context.Operation.acceptable_passes.

Definition max_block_length : Z := Alpha_context.Block_header.max_header_length.

Definition max_operation_data_length : Z :=
  Alpha_context.Constants.max_operation_data_length.

Definition validation_passes : list Updater.quota :=
  let max_anonymous_operations :=
    Pervasives.op_plus Alpha_context.Constants.max_revelations_per_block 100 in
  cons
    {| Updater.quota.max_size := Pervasives.op_star 32 1024;
      Updater.quota.max_op := Some 32 |}
    (cons
      {| Updater.quota.max_size := Pervasives.op_star 32 1024;
        Updater.quota.max_op := None |}
      (cons
        {|
          Updater.quota.max_size :=
            Pervasives.op_star max_anonymous_operations 1024;
          Updater.quota.max_op := Some max_anonymous_operations |}
        (cons
          {| Updater.quota.max_size := Pervasives.op_star 512 1024;
            Updater.quota.max_op := None |} []))).

Definition rpc_services : RPC_directory.directory Updater.rpc_context :=
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.get_rpc_services tt.

Module validation_mode.
  Module Application.
    Record record {block_header baker block_delay : Set} := {
      block_header : block_header;
      baker : baker;
      block_delay : block_delay }.
    Arguments record : clear implicits.
  End Application.
  Definition Application := Application.record.
  
  Module Partial_application.
    Record record {block_header baker block_delay : Set} := {
      block_header : block_header;
      baker : baker;
      block_delay : block_delay }.
    Arguments record : clear implicits.
  End Partial_application.
  Definition Partial_application := Partial_application.record.
  
  Module Partial_construction.
    Record record {predecessor : Set} := {
      predecessor : predecessor }.
    Arguments record : clear implicits.
  End Partial_construction.
  Definition Partial_construction := Partial_construction.record.
  
  Module Full_construction.
    Record record {predecessor protocol_data baker block_delay : Set} := {
      predecessor : predecessor;
      protocol_data : protocol_data;
      baker : baker;
      block_delay : block_delay }.
    Arguments record : clear implicits.
  End Full_construction.
  Definition Full_construction := Full_construction.record.
End validation_mode.

Inductive validation_mode : Set :=
| Application :
  validation_mode.Application Alpha_context.Block_header.t
    Alpha_context.public_key_hash Alpha_context.Period.t -&gt; validation_mode
| Partial_application :
  validation_mode.Partial_application Alpha_context.Block_header.t
    Alpha_context.public_key_hash Alpha_context.Period.t -&gt; validation_mode
| Partial_construction :
  validation_mode.Partial_construction Block_hash.[S.HASH.t] -&gt; validation_mode
| Full_construction :
  validation_mode.Full_construction Block_hash.[S.HASH.t]
    Alpha_context.Block_header.contents Alpha_context.public_key_hash
    Alpha_context.Period.t -&gt; validation_mode.

Module validation_state.
  Record record := {
    mode : validation_mode;
    chain_id : Chain_id.[S.HASH.t];
    ctxt : Alpha_context.t;
    op_count : Z }.
End validation_state.
Definition validation_state := validation_state.record.

Definition current_context (function_parameter : validation_state)
  : Lwt.t (Error_monad.tzresult Context.t) :=
  let '{| validation_state.ctxt := ctxt |} := function_parameter in
  Error_monad.__return
    (Updater.validation_result.context (Alpha_context.finalize None ctxt)).

Definition begin_partial_application
  (chain_id : Chain_id.[S.HASH.t]) (ctxt : Context.t)
  (predecessor_timestamp : Time.t)
  (predecessor_fitness : Alpha_context.Fitness.t)
  (block_header : Alpha_context.Block_header.t)
  : Lwt.t (Error_monad.tzresult validation_state) :=
  let level := Block_header.shell_header.level (block_header.shell block_header)
    in
  let fitness := predecessor_fitness in
  let timestamp :=
    Block_header.shell_header.timestamp (block_header.shell block_header) in
  Error_monad.op_gtgteqquestion
    (Alpha_context.prepare ctxt level predecessor_timestamp timestamp fitness)
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Apply.begin_application ctxt chain_id block_header
          predecessor_timestamp)
        (fun function_parameter =&gt;
          let '(ctxt, baker, block_delay) := function_parameter in
          let mode :=
            Partial_application
              {|
                validation_mode.Partial_application.block_header := block_header;
                validation_mode.Partial_application.baker :=
                  Signature.Public_key.[S.SPublic_key.__hash_value] baker;
                validation_mode.Partial_application.block_delay := block_delay
                |} in
          Error_monad.__return
            {| validation_state.mode := mode;
              validation_state.chain_id := chain_id;
              validation_state.ctxt := ctxt; validation_state.op_count := 0 |})).

Definition begin_application
  (chain_id : Chain_id.[S.HASH.t]) (ctxt : Context.t)
  (predecessor_timestamp : Time.t)
  (predecessor_fitness : Alpha_context.Fitness.t)
  (block_header : Alpha_context.Block_header.t)
  : Lwt.t (Error_monad.tzresult validation_state) :=
  let level := Block_header.shell_header.level (block_header.shell block_header)
    in
  let fitness := predecessor_fitness in
  let timestamp :=
    Block_header.shell_header.timestamp (block_header.shell block_header) in
  Error_monad.op_gtgteqquestion
    (Alpha_context.prepare ctxt level predecessor_timestamp timestamp fitness)
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Apply.begin_application ctxt chain_id block_header
          predecessor_timestamp)
        (fun function_parameter =&gt;
          let '(ctxt, baker, block_delay) := function_parameter in
          let mode :=
            Application
              {| validation_mode.Application.block_header := block_header;
                validation_mode.Application.baker :=
                  Signature.Public_key.[S.SPublic_key.__hash_value] baker;
                validation_mode.Application.block_delay := block_delay |} in
          Error_monad.__return
            {| validation_state.mode := mode;
              validation_state.chain_id := chain_id;
              validation_state.ctxt := ctxt; validation_state.op_count := 0 |})).

Definition begin_construction
  (chain_id : Chain_id.[S.HASH.t]) (ctxt : Context.t)
  (predecessor_timestamp : Time.t) (pred_level : int32)
  (pred_fitness : Alpha_context.Fitness.t) (predecessor : Block_hash.[S.HASH.t])
  (timestamp : Time.t) (protocol_data : option block_header_data)
  (function_parameter : unit) : Lwt.t (Error_monad.tzresult validation_state) :=
  let 'tt := function_parameter in
  let level := Int32.succ pred_level in
  let fitness := pred_fitness in
  Error_monad.op_gtgteqquestion
    (Alpha_context.prepare ctxt level predecessor_timestamp timestamp fitness)
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        match protocol_data with
        | None =&gt;
          Error_monad.op_gtgteqquestion (Apply.begin_partial_construction ctxt)
            (fun ctxt =&gt;
              let mode :=
                Partial_construction
                  {|
                    validation_mode.Partial_construction.predecessor :=
                      predecessor |} in
              Error_monad.__return (mode, ctxt))
        | Some proto_header =&gt;
          Error_monad.op_gtgteqquestion
            (Apply.begin_full_construction ctxt predecessor_timestamp
              (Alpha_context.Block_header.protocol_data.contents proto_header))
            (fun function_parameter =&gt;
              let '(ctxt, protocol_data, baker, block_delay) :=
                function_parameter in
              let mode :=
                let baker :=
                  Signature.Public_key.[S.SPublic_key.__hash_value] baker in
                Full_construction
                  {|
                    validation_mode.Full_construction.predecessor := predecessor;
                    validation_mode.Full_construction.protocol_data :=
                      protocol_data;
                    validation_mode.Full_construction.baker := baker;
                    validation_mode.Full_construction.block_delay := block_delay
                    |} in
              Error_monad.__return (mode, ctxt))
        end
        (fun function_parameter =&gt;
          let '(mode, ctxt) := function_parameter in
          Error_monad.__return
            {| validation_state.mode := mode;
              validation_state.chain_id := chain_id;
              validation_state.ctxt := ctxt; validation_state.op_count := 0 |})).

Definition apply_operation (function_parameter : validation_state)
  : Alpha_context.packed_operation -&gt;
  Lwt.t (Error_monad.tzresult (validation_state * operation_receipt)) :=
  let
    '{|
      validation_state.mode := mode;
        validation_state.chain_id := chain_id;
        validation_state.ctxt := ctxt;
        validation_state.op_count := op_count
        |} as data := function_parameter in
  fun operation =&gt;
    match
      (mode,
        match mode with
        | Partial_application _ =&gt;
          Pervasives.not
            (List.__exists (Compare.Int.[Compare.S.equal] 0)
              (Alpha_context.Operation.acceptable_passes operation))
        | _ =&gt; false
        end) with
    | (Partial_application _, true) =&gt;
      let op_count := Pervasives.op_plus op_count 1 in
      Error_monad.__return
        ((* ‚ùå Record substitution not handled *)
        record_substitution, No_operation_metadata)
    | (_, _) =&gt;
      let '{|
        operation.shell := shell;
          operation.protocol_data := Operation_data protocol_data
          |} := operation in
      let operation :=
        {| Alpha_context.operation.shell := shell;
          Alpha_context.operation.protocol_data := protocol_data |} in
      let '(predecessor, baker) :=
        match mode with
        |
          Partial_application {|
            validation_mode.Partial_application.block_header := {|
              block_header.shell := {|
                Block_header.shell_header.predecessor := predecessor
                  |}
                |};
              validation_mode.Partial_application.baker := baker
              |} |
          Application {|
            validation_mode.Application.block_header := {|
              block_header.shell := {|
                Block_header.shell_header.predecessor := predecessor
                  |}
                |};
              validation_mode.Application.baker := baker
              |} |
          Full_construction {|
            validation_mode.Full_construction.predecessor := predecessor;
              validation_mode.Full_construction.baker := baker
              |} =&gt; (predecessor, baker)
        |
          Partial_construction {|
            validation_mode.Partial_construction.predecessor := predecessor
              |} =&gt;
          (predecessor, Signature.Public_key_hash.[S.SPublic_key_hash.zero])
        end in
      Error_monad.op_gtgteqquestion
        (Apply.apply_operation ctxt chain_id Script_ir_translator.Optimized
          predecessor baker (Alpha_context.Operation.__hash_value operation)
          operation)
        (fun function_parameter =&gt;
          let '(ctxt, __result_value) := function_parameter in
          let op_count := Pervasives.op_plus op_count 1 in
          Error_monad.__return
            ((* ‚ùå Record substitution not handled *)
            record_substitution, (Operation_metadata __result_value)))
    end.

Definition finalize_block (function_parameter : validation_state)
  : Lwt.t
    (Error_monad.tzresult
      (Updater.validation_result * Apply_results.block_metadata)) :=
  let '{|
    validation_state.mode := mode;
      validation_state.ctxt := ctxt;
      validation_state.op_count := op_count
      |} := function_parameter in
  match mode with
  | Partial_construction _ =&gt;
    let level := Alpha_context.Level.current ctxt in
    Error_monad.op_gtgteqquestion
      (Alpha_context.Vote.get_current_period_kind ctxt)
      (fun voting_period_kind =&gt;
        let baker := Signature.Public_key_hash.[S.SPublic_key_hash.zero] in
        Error_monad.op_gtgteqquestion
          (Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.fold)
            (fun delegate =&gt;
              fun deposit =&gt;
                fun ctxt =&gt;
                  Error_monad.op_gtgteqquestion ctxt
                    (fun ctxt =&gt;
                      Alpha_context.Delegate.freeze_deposit ctxt delegate
                        deposit)) (Alpha_context.get_deposits ctxt)
            (Error_monad.__return ctxt))
          (fun ctxt =&gt;
            let ctxt := Alpha_context.finalize None ctxt in
            Error_monad.__return
              (ctxt,
                {| Apply_results.block_metadata.baker := baker;
                  Apply_results.block_metadata.level := level;
                  Apply_results.block_metadata.voting_period_kind :=
                    voting_period_kind;
                  Apply_results.block_metadata.nonce_hash := None;
                  Apply_results.block_metadata.consumed_gas := Z.zero;
                  Apply_results.block_metadata.deactivated := [];
                  Apply_results.block_metadata.balance_updates := [] |})))
  |
    Partial_application {|
      validation_mode.Partial_application.block_header := block_header;
        validation_mode.Partial_application.baker := baker;
        validation_mode.Partial_application.block_delay := block_delay
        |} =&gt;
    let level := Alpha_context.Level.current ctxt in
    let included_endorsements := Alpha_context.included_endorsements ctxt in
    Error_monad.op_gtgteqquestion
      (Apply.check_minimum_endorsements ctxt
        (Alpha_context.Block_header.protocol_data.contents
          (block_header.protocol_data block_header)) block_delay
        included_endorsements)
      (fun function_parameter =&gt;
        let 'tt := function_parameter in
        Error_monad.op_gtgteqquestion
          (Alpha_context.Vote.get_current_period_kind ctxt)
          (fun voting_period_kind =&gt;
            let ctxt := Alpha_context.finalize None ctxt in
            Error_monad.__return
              (ctxt,
                {| Apply_results.block_metadata.baker := baker;
                  Apply_results.block_metadata.level := level;
                  Apply_results.block_metadata.voting_period_kind :=
                    voting_period_kind;
                  Apply_results.block_metadata.nonce_hash := None;
                  Apply_results.block_metadata.consumed_gas := Z.zero;
                  Apply_results.block_metadata.deactivated := [];
                  Apply_results.block_metadata.balance_updates := [] |})))
  |
    Application {|
      validation_mode.Application.block_header := {|
        block_header.protocol_data := {|
          Alpha_context.Block_header.protocol_data.contents := protocol_data
            |}
          |};
        validation_mode.Application.baker := baker;
        validation_mode.Application.block_delay := block_delay
        |} |
    Full_construction {|
      validation_mode.Full_construction.protocol_data := protocol_data;
        validation_mode.Full_construction.baker := baker;
        validation_mode.Full_construction.block_delay := block_delay
        |} =&gt;
    Error_monad.op_gtgteqquestion
      (Apply.finalize_application ctxt protocol_data baker block_delay)
      (fun function_parameter =&gt;
        let '(ctxt, receipt) := function_parameter in
        let level := Alpha_context.Level.current ctxt in
        let priority :=
          Alpha_context.Block_header.contents.priority protocol_data in
        let raw_level :=
          Alpha_context.Raw_level.to_int32 (Alpha_context.Level.t.level level)
          in
        let fitness := Alpha_context.Fitness.current ctxt in
        let commit_message :=
          Format.asprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal &quot;lvl &quot; % string
                (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.String_literal &quot;, fit 1:&quot; % string
                    (CamlinternalFormatBasics.Int64
                      CamlinternalFormatBasics.Int_d
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      (CamlinternalFormatBasics.String_literal
                        &quot;, prio &quot; % string
                        (CamlinternalFormatBasics.Int
                          CamlinternalFormatBasics.Int_d
                          CamlinternalFormatBasics.No_padding
                          CamlinternalFormatBasics.No_precision
                          (CamlinternalFormatBasics.String_literal &quot;, &quot; % string
                            (CamlinternalFormatBasics.Int
                              CamlinternalFormatBasics.Int_d
                              CamlinternalFormatBasics.No_padding
                              CamlinternalFormatBasics.No_precision
                              (CamlinternalFormatBasics.String_literal
                                &quot; ops&quot; % string
                                CamlinternalFormatBasics.End_of_format)))))))))
              &quot;lvl %ld, fit 1:%Ld, prio %d, %d ops&quot; % string) raw_level fitness
            priority op_count in
        let ctxt := Alpha_context.finalize (Some commit_message) ctxt in
        Error_monad.__return (ctxt, receipt))
  end.

Definition compare_operations
  (op1 : Alpha_context.packed_operation) (op2 : Alpha_context.packed_operation)
  : Z :=
  let 'Alpha_context.Operation_data op1 :=
    Alpha_context.packed_operation.protocol_data op1 in
  let 'Alpha_context.Operation_data op2 :=
    Alpha_context.packed_operation.protocol_data op2 in
  match
    ((Alpha_context.protocol_data.contents op1),
      (Alpha_context.protocol_data.contents op2)) with
  |
    (Alpha_context.Single (Alpha_context.Endorsement _),
      Alpha_context.Single (Alpha_context.Endorsement _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Endorsement _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Endorsement _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Seed_nonce_revelation _),
      Alpha_context.Single (Alpha_context.Seed_nonce_revelation _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Seed_nonce_revelation _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Seed_nonce_revelation _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Double_endorsement_evidence _),
      Alpha_context.Single (Alpha_context.Double_endorsement_evidence _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Double_endorsement_evidence _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Double_endorsement_evidence _), _) =&gt;
    (-1)
  |
    (Alpha_context.Single (Alpha_context.Double_baking_evidence _),
      Alpha_context.Single (Alpha_context.Double_baking_evidence _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Double_baking_evidence _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Double_baking_evidence _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Activate_account _),
      Alpha_context.Single (Alpha_context.Activate_account _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Activate_account _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Activate_account _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Proposals _),
      Alpha_context.Single (Alpha_context.Proposals _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Proposals _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Proposals _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Ballot _),
      Alpha_context.Single (Alpha_context.Ballot _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Ballot _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Ballot _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Manager_operation op1),
      Alpha_context.Single (Alpha_context.Manager_operation op2)) =&gt;
    Z.compare (Alpha_context.contents.Manager_operation.counter op1)
      (Alpha_context.contents.Manager_operation.counter op2)
  |
    (Alpha_context.Cons (Alpha_context.Manager_operation op1) _,
      Alpha_context.Single (Alpha_context.Manager_operation op2)) =&gt;
    Z.compare (Alpha_context.contents.Manager_operation.counter op1)
      (Alpha_context.contents.Manager_operation.counter op2)
  |
    (Alpha_context.Single (Alpha_context.Manager_operation op1),
      Alpha_context.Cons (Alpha_context.Manager_operation op2) _) =&gt;
    Z.compare (Alpha_context.contents.Manager_operation.counter op1)
      (Alpha_context.contents.Manager_operation.counter op2)
  |
    (Alpha_context.Cons (Alpha_context.Manager_operation op1) _,
      Alpha_context.Cons (Alpha_context.Manager_operation op2) _) =&gt;
    Z.compare (Alpha_context.contents.Manager_operation.counter op1)
      (Alpha_context.contents.Manager_operation.counter op2)
  end.

Definition init (ctxt : Context.t) (block_header : Block_header.shell_header)
  : Lwt.t (Error_monad.tzresult Updater.validation_result) :=
  let level := Block_header.shell_header.level block_header in
  let fitness := Block_header.shell_header.fitness block_header in
  let timestamp := Block_header.shell_header.timestamp block_header in
  let typecheck (ctxt : Alpha_context.context) (script : Alpha_context.Script.t)
    : Lwt.t
      (Error_monad.tzresult
        ((Alpha_context.Script.t * option Alpha_context.Contract.big_map_diff) *
          Alpha_context.context)) :=
    Error_monad.op_gtgteqquestion
      (Script_ir_translator.parse_script None ctxt false script)
      (fun function_parameter =&gt;
        let '(Script_ir_translator.Ex_script parsed_script, ctxt) :=
          function_parameter in
        Error_monad.op_gtgteqquestion
          (Script_ir_translator.extract_big_map_diff ctxt
            Script_ir_translator.Optimized false
            Script_ir_translator.no_big_map_id
            Script_ir_translator.no_big_map_id
            (Script_typed_ir.script.storage_type parsed_script)
            (Script_typed_ir.script.storage parsed_script))
          (fun function_parameter =&gt;
            let '(storage, big_map_diff, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_translator.unparse_data ctxt
                Script_ir_translator.Optimized
                (Script_typed_ir.script.storage_type parsed_script) storage)
              (fun function_parameter =&gt;
                let '(storage, ctxt) := function_parameter in
                let storage :=
                  Alpha_context.Script.lazy_expr
                    (Micheline.strip_locations storage) in
                Error_monad.__return
                  (((* ‚ùå Record substitution not handled *)
                  record_substitution, big_map_diff), ctxt)))) in
  Error_monad.op_gtgteqquestion
    (Alpha_context.prepare_first_block ctxt typecheck level timestamp fitness)
    (fun ctxt =&gt; Error_monad.__return (Alpha_context.finalize None ctxt)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="main.mli">
  <div class="col-md-6">
    <a href="#main.mli"><code>main.mli</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Protocol Signature Instance *)

type validation_mode =
  | Application of {
      block_header : Alpha_context.Block_header.t;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_application of {
      block_header : Alpha_context.Block_header.t;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_construction of {predecessor : Block_hash.t}
  | Full_construction of {
      predecessor : Block_hash.t;
      protocol_data : Alpha_context.Block_header.contents;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }

type validation_state = {
  mode : validation_mode;
  chain_id : Chain_id.t;
  ctxt : Alpha_context.t;
  op_count : int;
}

type operation_data = Alpha_context.packed_protocol_data

type operation = Alpha_context.packed_operation = {
  shell : Operation.shell_header;
  protocol_data : operation_data;
}

include
  <abbr class="mark-error" title="Can only do `with` on types in module types using type expressions rather than type definitions

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Can only do `with` on types in module types using type expressions rather than type definitions">Updater.PROTOCOL
    with type block_header_data = Alpha_context.Block_header.protocol_data
     and type block_header_metadata = Apply_results.block_metadata
     and type block_header = Alpha_context.Block_header.t
     and type operation_data := operation_data
     and type operation_receipt = Apply_results.packed_operation_metadata
     and type operation := operation
     and type validation_state := validation_state</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#main.mli"><code>Main_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Apply_results.

Module validation_mode.
  Module Application.
    Record record {block_header baker block_delay : Set} := {
      block_header : block_header;
      baker : baker;
      block_delay : block_delay }.
    Arguments record : clear implicits.
  End Application.
  Definition Application := Application.record.
  
  Module Partial_application.
    Record record {block_header baker block_delay : Set} := {
      block_header : block_header;
      baker : baker;
      block_delay : block_delay }.
    Arguments record : clear implicits.
  End Partial_application.
  Definition Partial_application := Partial_application.record.
  
  Module Partial_construction.
    Record record {predecessor : Set} := {
      predecessor : predecessor }.
    Arguments record : clear implicits.
  End Partial_construction.
  Definition Partial_construction := Partial_construction.record.
  
  Module Full_construction.
    Record record {predecessor protocol_data baker block_delay : Set} := {
      predecessor : predecessor;
      protocol_data : protocol_data;
      baker : baker;
      block_delay : block_delay }.
    Arguments record : clear implicits.
  End Full_construction.
  Definition Full_construction := Full_construction.record.
End validation_mode.

Inductive validation_mode : Set :=
| Application :
  validation_mode.Application Alpha_context.Block_header.t
    Alpha_context.public_key_hash Alpha_context.Period.t -&gt; validation_mode
| Partial_application :
  validation_mode.Partial_application Alpha_context.Block_header.t
    Alpha_context.public_key_hash Alpha_context.Period.t -&gt; validation_mode
| Partial_construction :
  validation_mode.Partial_construction Block_hash.[S.HASH.t] -&gt; validation_mode
| Full_construction :
  validation_mode.Full_construction Block_hash.[S.HASH.t]
    Alpha_context.Block_header.contents Alpha_context.public_key_hash
    Alpha_context.Period.t -&gt; validation_mode.

Module validation_state.
  Record record := {
    mode : validation_mode;
    chain_id : Chain_id.[S.HASH.t];
    ctxt : Alpha_context.t;
    op_count : Z }.
End validation_state.
Definition validation_state := validation_state.record.

Definition operation_data := Alpha_context.packed_protocol_data.

Module operation.
  Record record := {
    shell : Operation.shell_header;
    protocol_data : operation_data }.
End operation.
Definition operation := operation.record.

Parameter Included_PROTOCOL :
  {'[block_header, operation] : _ &amp;
    Updater.PROTOCOL.signature Alpha_context.Block_header.protocol_data
      block_header Apply_results.block_metadata operation_data
      Apply_results.packed_operation_metadata operation validation_state}.

Definition max_block_length :=
Included_PROTOCOL.[Updater.PROTOCOL.max_block_length].

Definition max_operation_data_length :=
Included_PROTOCOL.[Updater.PROTOCOL.max_operation_data_length].

Definition validation_passes :=
Included_PROTOCOL.[Updater.PROTOCOL.validation_passes].

Definition block_header_data :=
Included_PROTOCOL.[Updater.PROTOCOL.block_header_data].

Definition block_header_data_encoding :=
Included_PROTOCOL.[Updater.PROTOCOL.block_header_data_encoding].

Definition block_header := Included_PROTOCOL.[Updater.PROTOCOL.block_header].

Definition block_header_metadata :=
Included_PROTOCOL.[Updater.PROTOCOL.block_header_metadata].

Definition block_header_metadata_encoding :=
Included_PROTOCOL.[Updater.PROTOCOL.block_header_metadata_encoding].

Definition operation_receipt :=
Included_PROTOCOL.[Updater.PROTOCOL.operation_receipt].

Definition operation_data_encoding :=
Included_PROTOCOL.[Updater.PROTOCOL.operation_data_encoding].

Definition operation_receipt_encoding :=
Included_PROTOCOL.[Updater.PROTOCOL.operation_receipt_encoding].

Definition operation_data_and_receipt_encoding :=
Included_PROTOCOL.[Updater.PROTOCOL.operation_data_and_receipt_encoding].

Definition acceptable_passes :=
Included_PROTOCOL.[Updater.PROTOCOL.acceptable_passes].

Definition compare_operations :=
Included_PROTOCOL.[Updater.PROTOCOL.compare_operations].

Definition current_context :=
Included_PROTOCOL.[Updater.PROTOCOL.current_context].

Definition begin_partial_application :=
Included_PROTOCOL.[Updater.PROTOCOL.begin_partial_application].

Definition begin_application :=
Included_PROTOCOL.[Updater.PROTOCOL.begin_application].

Definition begin_construction :=
Included_PROTOCOL.[Updater.PROTOCOL.begin_construction].

Definition apply_operation :=
Included_PROTOCOL.[Updater.PROTOCOL.apply_operation].

Definition finalize_block :=
Included_PROTOCOL.[Updater.PROTOCOL.finalize_block].

Definition rpc_services := Included_PROTOCOL.[Updater.PROTOCOL.rpc_services].

Definition init := Included_PROTOCOL.[Updater.PROTOCOL.init].
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="manager_repr.ml">
  <div class="col-md-6">
    <a href="#manager_repr.ml"><code>manager_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Managers' keys *)

type manager_key =
  | Hash of Signature.Public_key_hash.t
  | Public_key of Signature.Public_key.t

type t = manager_key

open Data_encoding

let hash_case tag =
  case
    tag
    ~title:&quot;Public_key_hash&quot;
    Signature.Public_key_hash.encoding
    (function Hash hash -&gt; Some hash | _ -&gt; None)
    (fun hash -&gt; Hash hash)

let pubkey_case tag =
  case
    tag
    ~title:&quot;Public_key&quot;
    Signature.Public_key.encoding
    (function Public_key hash -&gt; Some hash | _ -&gt; None)
    (fun hash -&gt; Public_key hash)

let encoding = union [hash_case (Tag 0); pubkey_case (Tag 1)]
</pre>
  </div>
  <div class="col-md-6">
    <a href="#manager_repr.ml"><code>Manager_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Inductive manager_key : Set :=
| Hash : Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; manager_key
| Public_key : Signature.Public_key.[S.SPublic_key.t] -&gt; manager_key.

Definition t := manager_key.

Import Data_encoding.

Definition hash_case (tag : Data_encoding.case_tag)
  : Data_encoding.case manager_key :=
  Data_encoding.__case_value &quot;Public_key_hash&quot; % string None tag
    Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
    (fun function_parameter =&gt;
      match function_parameter with
      | Hash __hash_value =&gt; Some __hash_value
      | _ =&gt; None
      end) (fun __hash_value =&gt; Hash __hash_value).

Definition pubkey_case (tag : Data_encoding.case_tag)
  : Data_encoding.case manager_key :=
  Data_encoding.__case_value &quot;Public_key&quot; % string None tag
    Signature.Public_key.[S.SPublic_key.encoding]
    (fun function_parameter =&gt;
      match function_parameter with
      | Public_key __hash_value =&gt; Some __hash_value
      | _ =&gt; None
      end) (fun __hash_value =&gt; Public_key __hash_value).

Definition encoding : Data_encoding.encoding manager_key :=
  Data_encoding.union None
    (cons (hash_case (Data_encoding.Tag 0))
      (cons (pubkey_case (Data_encoding.Tag 1)) [])).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="manager_repr.mli">
  <div class="col-md-6">
    <a href="#manager_repr.mli"><code>manager_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Managers' keys *)

(** The public key of the manager of a contract is reveled only after the
    first operation. At Origination time, the manager provides only the hash
    of its public key that is stored in the contract. When the public key
    is actually reveeld, the public key instead of the hash of the key *)
type manager_key =
  | Hash of Signature.Public_key_hash.t
  | Public_key of Signature.Public_key.t

type t = manager_key

val encoding : t Data_encoding.encoding
</pre>
  </div>
  <div class="col-md-6">
    <a href="#manager_repr.mli"><code>Manager_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Inductive manager_key : Set :=
| Hash : Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; manager_key
| Public_key : Signature.Public_key.[S.SPublic_key.t] -&gt; manager_key.

Definition t := manager_key.

Parameter encoding : Data_encoding.encoding t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_gas.ml">
  <div class="col-md-6">
    <a href="#michelson_v1_gas.ml"><code>michelson_v1_gas.ml</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Gas

module Cost_of = struct
  let log2 =
    let rec help acc = function 0 -&gt; acc | n -&gt; help (acc + 1) (n / 2) in
    help 1

  let z_bytes (z : Z.t) =
    let bits = Z.numbits z in
    (7 + bits) / 8

  let int_bytes (z : 'a Script_int.num) = z_bytes (Script_int.to_zint z)

  let timestamp_bytes (t : Script_timestamp.t) =
    let z = Script_timestamp.to_zint t in
    z_bytes z

  (* For now, returns size in bytes, but this could get more complicated... *)
  let rec size_of_comparable :
      type a b. (a, b) Script_typed_ir.comparable_struct -&gt; a -&gt; int =
   fun wit v -&gt;
    match wit with
    | Int_key _ -&gt;
        int_bytes v
    | Nat_key _ -&gt;
        int_bytes v
    | String_key _ -&gt;
        String.length v
    | Bytes_key _ -&gt;
        MBytes.length v
    | Bool_key _ -&gt;
        8
    | Key_hash_key _ -&gt;
        Signature.Public_key_hash.size
    | Timestamp_key _ -&gt;
        timestamp_bytes v
    | Address_key _ -&gt;
        Signature.Public_key_hash.size
    | Mutez_key _ -&gt;
        8
    | Pair_key ((l, _), (r, _), _) -&gt;
        let (lval, rval) = v in
        size_of_comparable l lval + size_of_comparable r rval

  let string length = alloc_bytes_cost length

  let bytes length = alloc_mbytes_cost length

  let manager_operation = step_cost 10_000

  module Legacy = struct
    let zint z = alloc_bits_cost (Z.numbits z)

    let set_to_list : type item. item Script_typed_ir.set -&gt; cost =
     fun (module Box) -&gt; alloc_cost @@ Pervasives.(Box.size * 2)

    let map_to_list : type key value. (key, value) Script_typed_ir.map -&gt; cost
        =
     fun (module Box) -&gt;
      let size = snd Box.boxed in
      3 *@ alloc_cost size

    let z_to_int64 = step_cost 2 +@ alloc_cost 1

    let hash data len = (10 *@ step_cost (MBytes.length data)) +@ bytes len

    let set_access : type elt. elt -&gt; elt Script_typed_ir.set -&gt; int =
     fun _key (module Box) -&gt; log2 @@ Box.size

    let set_update key _presence set = set_access key set *@ alloc_cost 3
  end

  module Interpreter = struct
    let cycle = atomic_step_cost 10

    let nop = free

    let stack_op = atomic_step_cost 10

    let push = atomic_step_cost 10

    let wrap = atomic_step_cost 10

    let variant_no_data = atomic_step_cost 10

    let branch = atomic_step_cost 10

    let pair = atomic_step_cost 10

    let pair_access = atomic_step_cost 10

    let cons = atomic_step_cost 10

    let loop_size = atomic_step_cost 5

    let loop_cycle = atomic_step_cost 10

    let loop_iter = atomic_step_cost 20

    let loop_map = atomic_step_cost 30

    let empty_set = atomic_step_cost 10

    let set_to_list : type elt. elt Script_typed_ir.set -&gt; cost =
     fun (module Box) -&gt; atomic_step_cost (Box.size * 20)

    let set_mem : type elt. elt -&gt; elt Script_typed_ir.set -&gt; cost =
     fun elt (module Box) -&gt;
      let elt_bytes = size_of_comparable Box.elt_ty elt in
      atomic_step_cost ((1 + (elt_bytes / 82)) * log2 Box.size)

    let set_update : type elt. elt -&gt; bool -&gt; elt Script_typed_ir.set -&gt; cost =
     fun elt _ (module Box) -&gt;
      let elt_bytes = size_of_comparable Box.elt_ty elt in
      atomic_step_cost ((1 + (elt_bytes / 82)) * log2 Box.size)

    let set_size = atomic_step_cost 10

    let empty_map = atomic_step_cost 10

    let map_to_list : type key value. (key, value) Script_typed_ir.map -&gt; cost
        =
     fun (module Box) -&gt;
      let size = snd Box.boxed in
      atomic_step_cost (size * 20)

    let map_access :
        type key value. key -&gt; (key, value) Script_typed_ir.map -&gt; cost =
     fun key (module Box) -&gt;
      let map_card = snd Box.boxed in
      let key_bytes = size_of_comparable Box.key_ty key in
      atomic_step_cost ((1 + (key_bytes / 70)) * log2 map_card)

    let map_mem = map_access

    let map_get = map_access

    let map_update :
        type key value.
        key -&gt; value option -&gt; (key, value) Script_typed_ir.map -&gt; cost =
     fun key _value (module Box) -&gt;
      let map_card = snd Box.boxed in
      let key_bytes = size_of_comparable Box.key_ty key in
      atomic_step_cost ((1 + (key_bytes / 38)) * log2 map_card)

    let map_size = atomic_step_cost 10

    let add_timestamp (t1 : Script_timestamp.t) (t2 : 'a Script_int.num) =
      let bytes1 = timestamp_bytes t1 in
      let bytes2 = int_bytes t2 in
      atomic_step_cost (51 + (Compare.Int.max bytes1 bytes2 / 62))

    let sub_timestamp = add_timestamp

    let diff_timestamps (t1 : Script_timestamp.t) (t2 : Script_timestamp.t) =
      let bytes1 = timestamp_bytes t1 in
      let bytes2 = timestamp_bytes t2 in
      atomic_step_cost (51 + (Compare.Int.max bytes1 bytes2 / 62))

    let rec concat_loop l acc =
      match l with [] -&gt; 30 | _ :: tl -&gt; concat_loop tl (acc + 30)

    let concat_string string_list =
      atomic_step_cost (concat_loop string_list 0)

    let slice_string string_length =
      atomic_step_cost (40 + (string_length / 70))

    let concat_bytes bytes_list = atomic_step_cost (concat_loop bytes_list 0)

    let int64_op = atomic_step_cost 61

    let z_to_int64 = atomic_step_cost 20

    let int64_to_z = atomic_step_cost 20

    let bool_binop _ _ = atomic_step_cost 10

    let bool_unop _ = atomic_step_cost 10

    let abs int = atomic_step_cost (61 + (int_bytes int / 70))

    let int _int = free

    let neg = abs

    let add i1 i2 =
      atomic_step_cost
        (51 + (Compare.Int.max (int_bytes i1) (int_bytes i2) / 62))

    let sub = add

    let mul i1 i2 =
      let bytes = Compare.Int.max (int_bytes i1) (int_bytes i2) in
      atomic_step_cost (51 + (bytes / 6 * log2 bytes))

    let indic_lt x y = if Compare.Int.(x &lt; y) then 1 else 0

    let div i1 i2 =
      let bytes1 = int_bytes i1 in
      let bytes2 = int_bytes i2 in
      let cost = indic_lt bytes2 bytes1 * (bytes1 - bytes2) * bytes2 in
      atomic_step_cost (51 + (cost / 3151))

    let shift_left _i _shift_bits = atomic_step_cost 30

    let shift_right _i _shift_bits = atomic_step_cost 30

    let logor i1 i2 =
      let bytes1 = int_bytes i1 in
      let bytes2 = int_bytes i2 in
      atomic_step_cost (51 + (Compare.Int.max bytes1 bytes2 / 70))

    let logand i1 i2 =
      let bytes1 = int_bytes i1 in
      let bytes2 = int_bytes i2 in
      atomic_step_cost (51 + (Compare.Int.min bytes1 bytes2 / 70))

    let logxor = logor

    let lognot i = atomic_step_cost (51 + (int_bytes i / 20))

    let exec = atomic_step_cost 10

    let compare_bool _ _ = atomic_step_cost 30

    let compare_string s1 s2 =
      let bytes1 = String.length s1 in
      let bytes2 = String.length s2 in
      atomic_step_cost (30 + (Compare.Int.min bytes1 bytes2 / 123))

    let compare_bytes b1 b2 =
      let bytes1 = MBytes.length b1 in
      let bytes2 = MBytes.length b2 in
      atomic_step_cost (30 + (Compare.Int.min bytes1 bytes2 / 123))

    let compare_tez _ _ = atomic_step_cost 30

    let compare_zint i1 i2 =
      atomic_step_cost
        (51 + (Compare.Int.min (int_bytes i1) (int_bytes i2) / 82))

    let compare_key_hash _ _ = atomic_step_cost 92

    let compare_timestamp t1 t2 =
      let bytes1 = timestamp_bytes t1 in
      let bytes2 = timestamp_bytes t2 in
      atomic_step_cost (51 + (Compare.Int.min bytes1 bytes2 / 82))

    let compare_address _ _ = atomic_step_cost 92

    let compare_res = atomic_step_cost 30

    let unpack_failed bytes =
      (* We cannot instrument failed deserialization,
         so we take worst case fees: a set of size 1 bytes values. *)
      let len = MBytes.length bytes in
      (len *@ alloc_mbytes_cost 1)
      +@ (len *@ (log2 len *@ (alloc_cost 3 +@ step_cost 1)))

    let address = atomic_step_cost 10

    let contract = step_cost 10000

    let transfer = step_cost 10

    let create_account = step_cost 10

    let create_contract = step_cost 10

    let implicit_account = step_cost 10

    let set_delegate = step_cost 10 +@ write_bytes_cost (Z.of_int 32)

    let balance = atomic_step_cost 10

    let now = atomic_step_cost 10

    let check_signature_secp256k1 bytes = atomic_step_cost (10342 + (bytes / 5))

    let check_signature_ed25519 bytes = atomic_step_cost (36864 + (bytes / 5))

    let check_signature_p256 bytes = atomic_step_cost (36864 + (bytes / 5))

    let check_signature (pkey : Signature.public_key) bytes =
      match pkey with
      | Ed25519 _ -&gt;
          check_signature_ed25519 (MBytes.length bytes)
      | Secp256k1 _ -&gt;
          check_signature_secp256k1 (MBytes.length bytes)
      | P256 _ -&gt;
          check_signature_p256 (MBytes.length bytes)

    let hash_key = atomic_step_cost 30

    let hash_blake2b b = atomic_step_cost (102 + (MBytes.length b / 5))

    let hash_sha256 b = atomic_step_cost (409 + MBytes.length b)

    let hash_sha512 b =
      let bytes = MBytes.length b in
      atomic_step_cost (409 + ((bytes lsr 1) + (bytes lsr 4)))

    let steps_to_quota = atomic_step_cost 10

    let source = atomic_step_cost 10

    let self = atomic_step_cost 10

    let amount = atomic_step_cost 10

    let chain_id = step_cost 1

    let stack_n_op n =
      atomic_step_cost (20 + ((n lsr 1) + (n lsr 2) + (n lsr 4)))

    let apply = alloc_cost 8 +@ step_cost 1

    let rec compare :
        type a s. (a, s) Script_typed_ir.comparable_struct -&gt; a -&gt; a -&gt; cost =
     fun ty x y -&gt;
      match ty with
      | Bool_key _ -&gt;
          compare_bool x y
      | String_key _ -&gt;
          compare_string x y
      | Bytes_key _ -&gt;
          compare_bytes x y
      | Mutez_key _ -&gt;
          compare_tez x y
      | Int_key _ -&gt;
          compare_zint x y
      | Nat_key _ -&gt;
          compare_zint x y
      | Key_hash_key _ -&gt;
          compare_key_hash x y
      | Timestamp_key _ -&gt;
          compare_timestamp x y
      | Address_key _ -&gt;
          compare_address x y
      | Pair_key ((tl, _), (tr, _), _) -&gt;
          (* Reasonable over-approximation of the cost of lexicographic comparison. *)
          let <abbr class="mark-error" title="A variable name instead of a pattern was expected.">(xl, xr)</abbr> = x and <abbr class="mark-error" title="A variable name instead of a pattern was expected.">(yl, yr)</abbr> = y in
          compare tl xl yl +@ compare tr xr yr
  end

  module Typechecking = struct
    let cycle = step_cost 1

    let bool = free

    let unit = free

    let string = string

    let bytes = bytes

    let z = Legacy.zint

    let int_of_string str =
      alloc_cost @@ Pervasives.( / ) (String.length str) 5

    let tez = step_cost 1 +@ alloc_cost 1

    let string_timestamp = step_cost 3 +@ alloc_cost 3

    let key = step_cost 3 +@ alloc_cost 3

    let key_hash = step_cost 1 +@ alloc_cost 1

    let signature = step_cost 1 +@ alloc_cost 1

    let chain_id = step_cost 1 +@ alloc_cost 1

    let contract = step_cost 5

    let get_script = step_cost 20 +@ alloc_cost 5

    let contract_exists = step_cost 15 +@ alloc_cost 5

    let pair = alloc_cost 2

    let union = alloc_cost 1

    let lambda = alloc_cost 5 +@ step_cost 3

    let some = alloc_cost 1

    let none = alloc_cost 0

    let list_element = alloc_cost 2 +@ step_cost 1

    let set_element size = log2 size *@ (alloc_cost 3 +@ step_cost 2)

    let map_element size = log2 size *@ (alloc_cost 4 +@ step_cost 2)

    let primitive_type = alloc_cost 1

    let one_arg_type = alloc_cost 2

    let two_arg_type = alloc_cost 3

    let operation b = bytes b

    let type_ nb_args = alloc_cost (nb_args + 1)

    (* Cost of parsing instruction, is cost of allocation of
       constructor + cost of contructor parameters + cost of
       allocation on the stack type *)
    let instr : type b a. (b, a) Script_typed_ir.instr -&gt; cost =
     fun i -&gt;
      let open Script_typed_ir in
      alloc_cost 1
      +@
      (* cost of allocation of constructor *)
      match i with
      | Drop -&gt;
          alloc_cost 0
      | Dup -&gt;
          alloc_cost 1
      | Swap -&gt;
          alloc_cost 0
      | Const _ -&gt;
          alloc_cost 1
      | Cons_pair -&gt;
          alloc_cost 2
      | Car -&gt;
          alloc_cost 1
      | Cdr -&gt;
          alloc_cost 1
      | Cons_some -&gt;
          alloc_cost 2
      | Cons_none _ -&gt;
          alloc_cost 3
      | If_none _ -&gt;
          alloc_cost 2
      | Left -&gt;
          alloc_cost 3
      | Right -&gt;
          alloc_cost 3
      | If_left _ -&gt;
          alloc_cost 2
      | Cons_list -&gt;
          alloc_cost 1
      | Nil -&gt;
          alloc_cost 1
      | If_cons _ -&gt;
          alloc_cost 2
      | List_map _ -&gt;
          alloc_cost 5
      | List_iter _ -&gt;
          alloc_cost 4
      | List_size -&gt;
          alloc_cost 1
      | Empty_set _ -&gt;
          alloc_cost 1
      | Set_iter _ -&gt;
          alloc_cost 4
      | Set_mem -&gt;
          alloc_cost 1
      | Set_update -&gt;
          alloc_cost 1
      | Set_size -&gt;
          alloc_cost 1
      | Empty_map _ -&gt;
          alloc_cost 2
      | Map_map _ -&gt;
          alloc_cost 5
      | Map_iter _ -&gt;
          alloc_cost 4
      | Map_mem -&gt;
          alloc_cost 1
      | Map_get -&gt;
          alloc_cost 1
      | Map_update -&gt;
          alloc_cost 1
      | Map_size -&gt;
          alloc_cost 1
      | Empty_big_map _ -&gt;
          alloc_cost 2
      | Big_map_mem -&gt;
          alloc_cost 1
      | Big_map_get -&gt;
          alloc_cost 1
      | Big_map_update -&gt;
          alloc_cost 1
      | Concat_string -&gt;
          alloc_cost 1
      | Concat_string_pair -&gt;
          alloc_cost 1
      | Concat_bytes -&gt;
          alloc_cost 1
      | Concat_bytes_pair -&gt;
          alloc_cost 1
      | Slice_string -&gt;
          alloc_cost 1
      | Slice_bytes -&gt;
          alloc_cost 1
      | String_size -&gt;
          alloc_cost 1
      | Bytes_size -&gt;
          alloc_cost 1
      | Add_seconds_to_timestamp -&gt;
          alloc_cost 1
      | Add_timestamp_to_seconds -&gt;
          alloc_cost 1
      | Sub_timestamp_seconds -&gt;
          alloc_cost 1
      | Diff_timestamps -&gt;
          alloc_cost 1
      | Add_tez -&gt;
          alloc_cost 1
      | Sub_tez -&gt;
          alloc_cost 1
      | Mul_teznat -&gt;
          alloc_cost 1
      | Mul_nattez -&gt;
          alloc_cost 1
      | Ediv_teznat -&gt;
          alloc_cost 1
      | Ediv_tez -&gt;
          alloc_cost 1
      | Or -&gt;
          alloc_cost 1
      | And -&gt;
          alloc_cost 1
      | Xor -&gt;
          alloc_cost 1
      | Not -&gt;
          alloc_cost 1
      | Is_nat -&gt;
          alloc_cost 1
      | Neg_nat -&gt;
          alloc_cost 1
      | Neg_int -&gt;
          alloc_cost 1
      | Abs_int -&gt;
          alloc_cost 1
      | Int_nat -&gt;
          alloc_cost 1
      | Add_intint -&gt;
          alloc_cost 1
      | Add_intnat -&gt;
          alloc_cost 1
      | Add_natint -&gt;
          alloc_cost 1
      | Add_natnat -&gt;
          alloc_cost 1
      | Sub_int -&gt;
          alloc_cost 1
      | Mul_intint -&gt;
          alloc_cost 1
      | Mul_intnat -&gt;
          alloc_cost 1
      | Mul_natint -&gt;
          alloc_cost 1
      | Mul_natnat -&gt;
          alloc_cost 1
      | Ediv_intint -&gt;
          alloc_cost 1
      | Ediv_intnat -&gt;
          alloc_cost 1
      | Ediv_natint -&gt;
          alloc_cost 1
      | Ediv_natnat -&gt;
          alloc_cost 1
      | Lsl_nat -&gt;
          alloc_cost 1
      | Lsr_nat -&gt;
          alloc_cost 1
      | Or_nat -&gt;
          alloc_cost 1
      | And_nat -&gt;
          alloc_cost 1
      | And_int_nat -&gt;
          alloc_cost 1
      | Xor_nat -&gt;
          alloc_cost 1
      | Not_nat -&gt;
          alloc_cost 1
      | Not_int -&gt;
          alloc_cost 1
      | Seq _ -&gt;
          alloc_cost 8
      | If _ -&gt;
          alloc_cost 8
      | Loop _ -&gt;
          alloc_cost 4
      | Loop_left _ -&gt;
          alloc_cost 5
      | Dip _ -&gt;
          alloc_cost 4
      | Exec -&gt;
          alloc_cost 1
      | Apply _ -&gt;
          alloc_cost 1
      | Lambda _ -&gt;
          alloc_cost 2
      | Failwith _ -&gt;
          alloc_cost 1
      | Nop -&gt;
          alloc_cost 0
      | Compare _ -&gt;
          alloc_cost 1
      | Eq -&gt;
          alloc_cost 1
      | Neq -&gt;
          alloc_cost 1
      | Lt -&gt;
          alloc_cost 1
      | Gt -&gt;
          alloc_cost 1
      | Le -&gt;
          alloc_cost 1
      | Ge -&gt;
          alloc_cost 1
      | Address -&gt;
          alloc_cost 1
      | Contract _ -&gt;
          alloc_cost 2
      | Transfer_tokens -&gt;
          alloc_cost 1
      | Create_account -&gt;
          alloc_cost 2
      | Implicit_account -&gt;
          alloc_cost 1
      | Create_contract _ -&gt;
          alloc_cost 8
      (* Deducted the cost of removed arguments manager, spendable and delegatable:
           - manager: key_hash = 1
           - spendable: bool = 0
           - delegatable: bool = 0
        *)
      | Create_contract_2 _ -&gt;
          alloc_cost 7
      | Set_delegate -&gt;
          alloc_cost 1
      | Now -&gt;
          alloc_cost 1
      | Balance -&gt;
          alloc_cost 1
      | Check_signature -&gt;
          alloc_cost 1
      | Hash_key -&gt;
          alloc_cost 1
      | Pack _ -&gt;
          alloc_cost 2
      | Unpack _ -&gt;
          alloc_cost 2
      | Blake2b -&gt;
          alloc_cost 1
      | Sha256 -&gt;
          alloc_cost 1
      | Sha512 -&gt;
          alloc_cost 1
      | Steps_to_quota -&gt;
          alloc_cost 1
      | Source -&gt;
          alloc_cost 1
      | Sender -&gt;
          alloc_cost 1
      | Self _ -&gt;
          alloc_cost 2
      | Amount -&gt;
          alloc_cost 1
      | Dig (n, _) -&gt;
          n *@ alloc_cost 1 (* _ is a unary development of n *)
      | Dug (n, _) -&gt;
          n *@ alloc_cost 1
      | Dipn (n, _, _) -&gt;
          n *@ alloc_cost 1
      | Dropn (n, _) -&gt;
          n *@ alloc_cost 1
      | ChainId -&gt;
          alloc_cost 1
  end

  module Unparse = struct
    let prim_cost l annot = Script.prim_node_cost_nonrec_of_length l annot

    let seq_cost = Script.seq_node_cost_nonrec_of_length

    let string_cost length = Script.string_node_cost_of_length length

    let cycle = step_cost 1

    let bool = prim_cost 0 []

    let unit = prim_cost 0 []

    (* We count the length of strings and bytes to prevent hidden
       miscalculations due to non detectable expansion of sharing. *)
    let string s = Script.string_node_cost s

    let bytes s = Script.bytes_node_cost s

    let z i = Script.int_node_cost i

    let int i = Script.int_node_cost (Script_int.to_zint i)

    let tez = Script.int_node_cost_of_numbits 60 (* int64 bound *)

    let timestamp x = Script_timestamp.to_zint x |&gt; Script_int.of_zint |&gt; int

    let operation bytes = Script.bytes_node_cost bytes

    let chain_id bytes = Script.bytes_node_cost bytes

    let key = string_cost 54

    let key_hash = string_cost 36

    let signature = string_cost 128

    let contract = string_cost 36

    let pair = prim_cost 2 []

    let union = prim_cost 1 []

    let some = prim_cost 1 []

    let none = prim_cost 0 []

    let list_element = alloc_cost 2

    let set_element = alloc_cost 2

    let map_element = alloc_cost 2

    let one_arg_type = prim_cost 1

    let two_arg_type = prim_cost 2

    let set_to_list = Legacy.set_to_list

    let map_to_list = Legacy.map_to_list
  end
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_gas.ml"><code>Michelson_v1_gas.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Gas.

Module Cost_of.
  Definition log2 : Z -&gt; Z :=
    let fix help (acc : Z) (function_parameter : Z) {struct acc} : Z :=
      match function_parameter with
      | 0 =&gt; acc
      | n =&gt; help (Pervasives.op_plus acc 1) (Pervasives.op_div n 2)
      end in
    help 1.
  
  Definition z_bytes (z : Z.t) : Z :=
    let bits := Z.numbits z in
    Pervasives.op_div (Pervasives.op_plus 7 bits) 8.
  
  Definition int_bytes {a : Set} (z : Alpha_context.Script_int.num a) : Z :=
    z_bytes (Alpha_context.Script_int.to_zint z).
  
  Definition timestamp_bytes (t : Alpha_context.Script_timestamp.t) : Z :=
    let z := Alpha_context.Script_timestamp.to_zint t in
    z_bytes z.
  
  Fixpoint size_of_comparable {a b : Set}
    (wit : Script_typed_ir.comparable_struct a b) (v : a) {struct wit} : Z :=
    match wit with
    | Script_typed_ir.Int_key _ =&gt; int_bytes v
    | Script_typed_ir.Nat_key _ =&gt; int_bytes v
    | Script_typed_ir.String_key _ =&gt; String.length v
    | Script_typed_ir.Bytes_key _ =&gt; MBytes.length v
    | Script_typed_ir.Bool_key _ =&gt; 8
    | Script_typed_ir.Key_hash_key _ =&gt;
      Signature.Public_key_hash.[S.SPublic_key_hash.size]
    | Script_typed_ir.Timestamp_key _ =&gt; timestamp_bytes v
    | Script_typed_ir.Address_key _ =&gt;
      Signature.Public_key_hash.[S.SPublic_key_hash.size]
    | Script_typed_ir.Mutez_key _ =&gt; 8
    | Script_typed_ir.Pair_key (l, _) (r, _) _ =&gt;
      let '(lval, rval) := v in
      Pervasives.op_plus (size_of_comparable l lval) (size_of_comparable r rval)
    end.
  
  Definition __string_value (length : Z) : Alpha_context.Gas.cost :=
    Alpha_context.Gas.alloc_bytes_cost length.
  
  Definition __bytes_value (length : Z) : Alpha_context.Gas.cost :=
    Alpha_context.Gas.alloc_mbytes_cost length.
  
  Definition manager_operation : Alpha_context.Gas.cost :=
    Alpha_context.Gas.step_cost 10000.
  
  Module Legacy.
    Definition zint (z : Z.t) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_bits_cost (Z.numbits z).
    
    Definition set_to_list {item : Set} (Box : Script_typed_ir.set item)
      : Alpha_context.Gas.cost :=
      Pervasives.op_atat Alpha_context.Gas.alloc_cost
        (Pervasives.op_star Box.[Script_typed_ir.Boxed_set.size] 2).
    
    Definition map_to_list {key value : Set}
      (Box : Script_typed_ir.map key value) : Alpha_context.Gas.cost :=
      let size := Pervasives.snd Box.[Script_typed_ir.Boxed_map.boxed] in
      Alpha_context.Gas.op_starat 3 (Alpha_context.Gas.alloc_cost size).
    
    Definition z_to_int64 : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 2)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition __hash_value (data : MBytes.t) (len : Z)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat
        (Alpha_context.Gas.op_starat 10
          (Alpha_context.Gas.step_cost (MBytes.length data)))
        (__bytes_value len).
    
    Definition set_access {elt : Set}
      (_key : elt) (Box : Script_typed_ir.set elt) : Z :=
      Pervasives.op_atat log2 Box.[Script_typed_ir.Boxed_set.size].
    
    Definition set_update {A B : Set}
      (key : A) (_presence : B) (set : Script_typed_ir.set A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_starat (set_access key set)
        (Alpha_context.Gas.alloc_cost 3).
  End Legacy.
  
  Module Interpreter.
    Definition cycle : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition nop : Alpha_context.Gas.cost := Alpha_context.Gas.free.
    
    Definition stack_op : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition push : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition wrap : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition variant_no_data : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition branch : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition pair : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition pair_access : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition cons : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition loop_size : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 5.
    
    Definition loop_cycle : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition loop_iter : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 20.
    
    Definition loop_map : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 30.
    
    Definition empty_set : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition set_to_list {elt : Set} (Box : Script_typed_ir.set elt)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star Box.[Script_typed_ir.Boxed_set.size] 20).
    
    Definition set_mem {elt : Set} (elt : elt) (Box : Script_typed_ir.set elt)
      : Alpha_context.Gas.cost :=
      let elt_bytes :=
        size_of_comparable Box.[Script_typed_ir.Boxed_set.elt_ty] elt in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star
          (Pervasives.op_plus 1 (Pervasives.op_div elt_bytes 82))
          (log2 Box.[Script_typed_ir.Boxed_set.size])).
    
    Definition set_update {elt : Set} (elt : elt) (function_parameter : bool)
      : Script_typed_ir.set elt -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun Box =&gt;
        let elt_bytes :=
          size_of_comparable Box.[Script_typed_ir.Boxed_set.elt_ty] elt in
        Alpha_context.Gas.atomic_step_cost
          (Pervasives.op_star
            (Pervasives.op_plus 1 (Pervasives.op_div elt_bytes 82))
            (log2 Box.[Script_typed_ir.Boxed_set.size])).
    
    Definition set_size : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition empty_map : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition map_to_list {key value : Set}
      (Box : Script_typed_ir.map key value) : Alpha_context.Gas.cost :=
      let size := Pervasives.snd Box.[Script_typed_ir.Boxed_map.boxed] in
      Alpha_context.Gas.atomic_step_cost (Pervasives.op_star size 20).
    
    Definition map_access {key value : Set}
      (key : key) (Box : Script_typed_ir.map key value)
      : Alpha_context.Gas.cost :=
      let map_card := Pervasives.snd Box.[Script_typed_ir.Boxed_map.boxed] in
      let key_bytes :=
        size_of_comparable Box.[Script_typed_ir.Boxed_map.key_ty] key in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star
          (Pervasives.op_plus 1 (Pervasives.op_div key_bytes 70))
          (log2 map_card)).
    
    Definition map_mem {A B : Set}
      : A -&gt; Script_typed_ir.map A B -&gt; Alpha_context.Gas.cost := map_access.
    
    Definition map_get {A B : Set}
      : A -&gt; Script_typed_ir.map A B -&gt; Alpha_context.Gas.cost := map_access.
    
    Definition map_update {key value : Set}
      (key : key) (_value : option value) (Box : Script_typed_ir.map key value)
      : Alpha_context.Gas.cost :=
      let map_card := Pervasives.snd Box.[Script_typed_ir.Boxed_map.boxed] in
      let key_bytes :=
        size_of_comparable Box.[Script_typed_ir.Boxed_map.key_ty] key in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star
          (Pervasives.op_plus 1 (Pervasives.op_div key_bytes 38))
          (log2 map_card)).
    
    Definition map_size : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition add_timestamp {a : Set}
      (t1 : Alpha_context.Script_timestamp.t)
      (t2 : Alpha_context.Script_int.num a) : Alpha_context.Gas.cost :=
      let bytes1 := timestamp_bytes t1 in
      let bytes2 := int_bytes t2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div (Compare.Int.[Compare.S.max] bytes1 bytes2) 62)).
    
    Definition sub_timestamp {A : Set}
      : Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_int.num A -&gt;
      Alpha_context.Gas.cost := add_timestamp.
    
    Definition diff_timestamps
      (t1 : Alpha_context.Script_timestamp.t)
      (t2 : Alpha_context.Script_timestamp.t) : Alpha_context.Gas.cost :=
      let bytes1 := timestamp_bytes t1 in
      let bytes2 := timestamp_bytes t2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div (Compare.Int.[Compare.S.max] bytes1 bytes2) 62)).
    
    Fixpoint concat_loop {A : Set} (l : list A) (acc : Z) {struct l} : Z :=
      match l with
      | [] =&gt; 30
      | cons _ tl =&gt; concat_loop tl (Pervasives.op_plus acc 30)
      end.
    
    Definition concat_string {A : Set} (string_list : list A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost (concat_loop string_list 0).
    
    Definition slice_string (string_length : Z) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 40 (Pervasives.op_div string_length 70)).
    
    Definition concat_bytes {A : Set} (bytes_list : list A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost (concat_loop bytes_list 0).
    
    Definition int64_op : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 61.
    
    Definition z_to_int64 : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 20.
    
    Definition int64_to_z : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 20.
    
    Definition bool_binop {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 10.
    
    Definition bool_unop {A : Set} (function_parameter : A)
      : Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition abs {A : Set} (int : Alpha_context.Script_int.num A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 61 (Pervasives.op_div (int_bytes Z) 70)).
    
    Definition int {A : Set} (_int : A) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.free.
    
    Definition neg {A : Set}
      : Alpha_context.Script_int.num A -&gt; Alpha_context.Gas.cost := abs.
    
    Definition add {A B : Set}
      (i1 : Alpha_context.Script_int.num A)
      (i2 : Alpha_context.Script_int.num B) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div
            (Compare.Int.[Compare.S.max] (int_bytes i1) (int_bytes i2)) 62)).
    
    Definition sub {A B : Set}
      : Alpha_context.Script_int.num A -&gt; Alpha_context.Script_int.num B -&gt;
      Alpha_context.Gas.cost := add.
    
    Definition mul {A B : Set}
      (i1 : Alpha_context.Script_int.num A)
      (i2 : Alpha_context.Script_int.num B) : Alpha_context.Gas.cost :=
      let __bytes_value :=
        Compare.Int.[Compare.S.max] (int_bytes i1) (int_bytes i2) in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_star (Pervasives.op_div __bytes_value 6)
            (log2 __bytes_value))).
    
    Definition indic_lt
      (x : Compare.Int.[Compare.S.t]) (y : Compare.Int.[Compare.S.t]) : Z :=
      if Compare.Int.[Compare.S.op_lt] x y then
        1
      else
        0.
    
    Definition div {A B : Set}
      (i1 : Alpha_context.Script_int.num A)
      (i2 : Alpha_context.Script_int.num B) : Alpha_context.Gas.cost :=
      let bytes1 := int_bytes i1 in
      let bytes2 := int_bytes i2 in
      let cost :=
        Pervasives.op_star
          (Pervasives.op_star (indic_lt bytes2 bytes1)
            (Pervasives.op_minus bytes1 bytes2)) bytes2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51 (Pervasives.op_div cost 3151)).
    
    Definition shift_left {A B : Set} (_i : A) (_shift_bits : B)
      : Alpha_context.Gas.cost := Alpha_context.Gas.atomic_step_cost 30.
    
    Definition shift_right {A B : Set} (_i : A) (_shift_bits : B)
      : Alpha_context.Gas.cost := Alpha_context.Gas.atomic_step_cost 30.
    
    Definition logor {A B : Set}
      (i1 : Alpha_context.Script_int.num A)
      (i2 : Alpha_context.Script_int.num B) : Alpha_context.Gas.cost :=
      let bytes1 := int_bytes i1 in
      let bytes2 := int_bytes i2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div (Compare.Int.[Compare.S.max] bytes1 bytes2) 70)).
    
    Definition logand {A B : Set}
      (i1 : Alpha_context.Script_int.num A)
      (i2 : Alpha_context.Script_int.num B) : Alpha_context.Gas.cost :=
      let bytes1 := int_bytes i1 in
      let bytes2 := int_bytes i2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div (Compare.Int.[Compare.S.min] bytes1 bytes2) 70)).
    
    Definition logxor {A B : Set}
      : Alpha_context.Script_int.num A -&gt; Alpha_context.Script_int.num B -&gt;
      Alpha_context.Gas.cost := logor.
    
    Definition lognot {A : Set} (i : Alpha_context.Script_int.num A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51 (Pervasives.op_div (int_bytes i) 20)).
    
    Definition exec : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition compare_bool {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 30.
    
    Definition compare_string (s1 : string) (s2 : string)
      : Alpha_context.Gas.cost :=
      let bytes1 := String.length s1 in
      let bytes2 := String.length s2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 30
          (Pervasives.op_div (Compare.Int.[Compare.S.min] bytes1 bytes2) 123)).
    
    Definition compare_bytes (b1 : MBytes.t) (b2 : MBytes.t)
      : Alpha_context.Gas.cost :=
      let bytes1 := MBytes.length b1 in
      let bytes2 := MBytes.length b2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 30
          (Pervasives.op_div (Compare.Int.[Compare.S.min] bytes1 bytes2) 123)).
    
    Definition compare_tez {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 30.
    
    Definition compare_zint {A B : Set}
      (i1 : Alpha_context.Script_int.num A)
      (i2 : Alpha_context.Script_int.num B) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div
            (Compare.Int.[Compare.S.min] (int_bytes i1) (int_bytes i2)) 82)).
    
    Definition compare_key_hash {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 92.
    
    Definition compare_timestamp
      (t1 : Alpha_context.Script_timestamp.t)
      (t2 : Alpha_context.Script_timestamp.t) : Alpha_context.Gas.cost :=
      let bytes1 := timestamp_bytes t1 in
      let bytes2 := timestamp_bytes t2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div (Compare.Int.[Compare.S.min] bytes1 bytes2) 82)).
    
    Definition compare_address {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 92.
    
    Definition compare_res : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 30.
    
    Definition unpack_failed (__bytes_value : MBytes.t)
      : Alpha_context.Gas.cost :=
      let len := MBytes.length __bytes_value in
      Alpha_context.Gas.op_plusat
        (Alpha_context.Gas.op_starat len (Alpha_context.Gas.alloc_mbytes_cost 1))
        (Alpha_context.Gas.op_starat len
          (Alpha_context.Gas.op_starat (log2 len)
            (Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 3)
              (Alpha_context.Gas.step_cost 1)))).
    
    Definition address : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition contract : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10000.
    
    Definition transfer : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition create_account : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition create_contract : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition implicit_account : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition set_delegate : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 10)
        (Alpha_context.Gas.write_bytes_cost (Z.of_int 32)).
    
    Definition balance : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition now : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition check_signature_secp256k1 (__bytes_value : Z)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 10342 (Pervasives.op_div __bytes_value 5)).
    
    Definition check_signature_ed25519 (__bytes_value : Z)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 36864 (Pervasives.op_div __bytes_value 5)).
    
    Definition check_signature_p256 (__bytes_value : Z)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 36864 (Pervasives.op_div __bytes_value 5)).
    
    Definition check_signature
      (pkey : Signature.public_key) (__bytes_value : MBytes.t)
      : Alpha_context.Gas.cost :=
      match pkey with
      | Signature.Ed25519 _ =&gt;
        check_signature_ed25519 (MBytes.length __bytes_value)
      | Signature.Secp256k1 _ =&gt;
        check_signature_secp256k1 (MBytes.length __bytes_value)
      | Signature.P256 _ =&gt; check_signature_p256 (MBytes.length __bytes_value)
      end.
    
    Definition hash_key : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 30.
    
    Definition hash_blake2b (b : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 102 (Pervasives.op_div (MBytes.length b) 5)).
    
    Definition hash_sha256 (b : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 409 (MBytes.length b)).
    
    Definition hash_sha512 (b : MBytes.t) : Alpha_context.Gas.cost :=
      let __bytes_value := MBytes.length b in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 409
          (Pervasives.op_plus (Pervasives.lsr __bytes_value 1)
            (Pervasives.lsr __bytes_value 4))).
    
    Definition steps_to_quota : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition source : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition self : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition amount : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition chain_id : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 1.
    
    Definition stack_n_op (n : Z) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 20
          (Pervasives.op_plus
            (Pervasives.op_plus (Pervasives.lsr n 1) (Pervasives.lsr n 2))
            (Pervasives.lsr n 4))).
    
    Definition apply : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 8)
        (Alpha_context.Gas.step_cost 1).
    
    Fixpoint compare {a s : Set}
      (ty : Script_typed_ir.comparable_struct a s) (x : a) (y : a) {struct ty}
      : Alpha_context.Gas.cost :=
      match ty with
      | Script_typed_ir.Bool_key _ =&gt; compare_bool x y
      | Script_typed_ir.String_key _ =&gt; compare_string x y
      | Script_typed_ir.Bytes_key _ =&gt; compare_bytes x y
      | Script_typed_ir.Mutez_key _ =&gt; compare_tez x y
      | Script_typed_ir.Int_key _ =&gt; compare_zint x y
      | Script_typed_ir.Nat_key _ =&gt; compare_zint x y
      | Script_typed_ir.Key_hash_key _ =&gt; compare_key_hash x y
      | Script_typed_ir.Timestamp_key _ =&gt; compare_timestamp x y
      | Script_typed_ir.Address_key _ =&gt; compare_address x y
      | Script_typed_ir.Pair_key (tl, _) (tr, _) _ =&gt;
        in
        Alpha_context.Gas.op_plusat (compare tl xl yl) (compare tr xr yr)
      end.
  End Interpreter.
  
  Module Typechecking.
    Definition cycle : Alpha_context.Gas.cost := Alpha_context.Gas.step_cost 1.
    
    Definition __bool_value : Alpha_context.Gas.cost := Alpha_context.Gas.free.
    
    Definition __unit_value : Alpha_context.Gas.cost := Alpha_context.Gas.free.
    
    Definition __string_value : Z -&gt; Alpha_context.Gas.cost := __string_value.
    
    Definition __bytes_value : Z -&gt; Alpha_context.Gas.cost := __bytes_value.
    
    Definition z : Z.t -&gt; Alpha_context.Gas.cost := Legacy.zint.
    
    Definition int_of_string (str : string) : Alpha_context.Gas.cost :=
      Pervasives.op_atat Alpha_context.Gas.alloc_cost
        (Pervasives.op_div (String.length str) 5).
    
    Definition tez : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition string_timestamp : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 3)
        (Alpha_context.Gas.alloc_cost 3).
    
    Definition key : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 3)
        (Alpha_context.Gas.alloc_cost 3).
    
    Definition key_hash : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition signature : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition chain_id : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition contract : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 5.
    
    Definition get_script : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 20)
        (Alpha_context.Gas.alloc_cost 5).
    
    Definition contract_exists : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 15)
        (Alpha_context.Gas.alloc_cost 5).
    
    Definition pair : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 2.
    
    Definition union : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 1.
    
    Definition lambda : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 5)
        (Alpha_context.Gas.step_cost 3).
    
    Definition some : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 1.
    
    Definition none : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 0.
    
    Definition list_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 2)
        (Alpha_context.Gas.step_cost 1).
    
    Definition set_element (size : Z) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_starat (log2 size)
        (Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 3)
          (Alpha_context.Gas.step_cost 2)).
    
    Definition map_element (size : Z) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_starat (log2 size)
        (Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 4)
          (Alpha_context.Gas.step_cost 2)).
    
    Definition primitive_type : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 1.
    
    Definition one_arg_type : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition two_arg_type : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 3.
    
    Definition operation (b : Z) : Alpha_context.Gas.cost := __bytes_value b.
    
    Definition type_ (nb_args : Z) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost (Pervasives.op_plus nb_args 1).
    
    Definition instr {a b : Set} (i : Script_typed_ir.instr b a)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 1)
        match i with
        | Script_typed_ir.Drop =&gt; Alpha_context.Gas.alloc_cost 0
        | Script_typed_ir.Dup =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Swap =&gt; Alpha_context.Gas.alloc_cost 0
        | Script_typed_ir.Const _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Cons_pair =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Car =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Cdr =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Cons_some =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Cons_none _ =&gt; Alpha_context.Gas.alloc_cost 3
        | Script_typed_ir.If_none _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Left =&gt; Alpha_context.Gas.alloc_cost 3
        | Script_typed_ir.Right =&gt; Alpha_context.Gas.alloc_cost 3
        | Script_typed_ir.If_left _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Cons_list =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Nil =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.If_cons _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.List_map _ =&gt; Alpha_context.Gas.alloc_cost 5
        | Script_typed_ir.List_iter _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.List_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Empty_set _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Set_iter _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Set_mem =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Set_update =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Set_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Empty_map _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Map_map _ =&gt; Alpha_context.Gas.alloc_cost 5
        | Script_typed_ir.Map_iter _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Map_mem =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Map_get =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Map_update =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Map_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Empty_big_map _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Big_map_mem =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Big_map_get =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Big_map_update =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_string =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_string_pair =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_bytes =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_bytes_pair =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Slice_string =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Slice_bytes =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.String_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Bytes_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_seconds_to_timestamp =&gt;
          Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_timestamp_to_seconds =&gt;
          Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sub_timestamp_seconds =&gt;
          Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Diff_timestamps =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_tez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sub_tez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_teznat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_nattez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_teznat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_tez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Or =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.And =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Xor =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Not =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Is_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Neg_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Neg_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Abs_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Int_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_intint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_intnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_natint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_natnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sub_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_intint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_intnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_natint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_natnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_intint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_intnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_natint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_natnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lsl_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lsr_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Or_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.And_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.And_int_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Xor_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Not_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Not_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Seq _ _ =&gt; Alpha_context.Gas.alloc_cost 8
        | Script_typed_ir.If _ _ =&gt; Alpha_context.Gas.alloc_cost 8
        | Script_typed_ir.Loop _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Loop_left _ =&gt; Alpha_context.Gas.alloc_cost 5
        | Script_typed_ir.Dip _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Exec =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Apply _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lambda _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Failwith _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Nop =&gt; Alpha_context.Gas.alloc_cost 0
        | Script_typed_ir.Compare _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Eq =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Neq =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lt =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Gt =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Le =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ge =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Address =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Contract _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Transfer_tokens =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Create_account =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Implicit_account =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Create_contract _ _ _ _ =&gt;
          Alpha_context.Gas.alloc_cost 8
        | Script_typed_ir.Create_contract_2 _ _ _ _ =&gt;
          Alpha_context.Gas.alloc_cost 7
        | Script_typed_ir.Set_delegate =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Now =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Balance =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Check_signature =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Hash_key =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Pack _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Unpack _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Blake2b =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sha256 =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sha512 =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Steps_to_quota =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Source =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sender =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Self _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Amount =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Dig n _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.Dug n _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.Dipn n _ _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.Dropn n _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.ChainId =&gt; Alpha_context.Gas.alloc_cost 1
        end.
  End Typechecking.
  
  Module Unparse.
    Definition prim_cost (l : Z) (annot : Alpha_context.Script.annot)
      : Alpha_context.Gas.cost :=
      Alpha_context.Script.prim_node_cost_nonrec_of_length l annot.
    
    Definition seq_cost : Z -&gt; Alpha_context.Gas.cost :=
      Alpha_context.Script.seq_node_cost_nonrec_of_length.
    
    Definition string_cost (length : Z) : Alpha_context.Gas.cost :=
      Alpha_context.Script.string_node_cost_of_length length.
    
    Definition cycle : Alpha_context.Gas.cost := Alpha_context.Gas.step_cost 1.
    
    Definition __bool_value : Alpha_context.Gas.cost := prim_cost 0 [].
    
    Definition __unit_value : Alpha_context.Gas.cost := prim_cost 0 [].
    
    Definition __string_value (s : string) : Alpha_context.Gas.cost :=
      Alpha_context.Script.string_node_cost s.
    
    Definition __bytes_value (s : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.bytes_node_cost s.
    
    Definition z (i : Z.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.int_node_cost i.
    
    Definition int {A : Set} (i : Alpha_context.Script_int.num A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Script.int_node_cost (Alpha_context.Script_int.to_zint i).
    
    Definition tez : Alpha_context.Gas.cost :=
      Alpha_context.Script.int_node_cost_of_numbits 60.
    
    Definition timestamp (x : Alpha_context.Script_timestamp.t)
      : Alpha_context.Gas.cost :=
      Pervasives.op_pipegt
        (Pervasives.op_pipegt (Alpha_context.Script_timestamp.to_zint x)
          Alpha_context.Script_int.of_zint) Z.
    
    Definition operation (__bytes_value : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.bytes_node_cost __bytes_value.
    
    Definition chain_id (__bytes_value : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.bytes_node_cost __bytes_value.
    
    Definition key : Alpha_context.Gas.cost := string_cost 54.
    
    Definition key_hash : Alpha_context.Gas.cost := string_cost 36.
    
    Definition signature : Alpha_context.Gas.cost := string_cost 128.
    
    Definition contract : Alpha_context.Gas.cost := string_cost 36.
    
    Definition pair : Alpha_context.Gas.cost := prim_cost 2 [].
    
    Definition union : Alpha_context.Gas.cost := prim_cost 1 [].
    
    Definition some : Alpha_context.Gas.cost := prim_cost 1 [].
    
    Definition none : Alpha_context.Gas.cost := prim_cost 0 [].
    
    Definition list_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition set_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition map_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition one_arg_type
      : Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost := prim_cost 1.
    
    Definition two_arg_type
      : Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost := prim_cost 2.
    
    Definition set_to_list {A : Set}
      : Script_typed_ir.set A -&gt; Alpha_context.Gas.cost := Legacy.set_to_list.
    
    Definition map_to_list {A B : Set}
      : Script_typed_ir.map A B -&gt; Alpha_context.Gas.cost := Legacy.map_to_list.
  End Unparse.
End Cost_of.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_gas.mli">
  <div class="col-md-6">
    <a href="#michelson_v1_gas.mli"><code>michelson_v1_gas.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

module Cost_of : sig
  val manager_operation : Gas.cost

  module Legacy : sig
    val z_to_int64 : Gas.cost

    val hash : MBytes.t -&gt; int -&gt; Gas.cost

    val map_to_list : ('b, 'c) Script_typed_ir.map -&gt; Gas.cost

    val set_update : 'a -&gt; bool -&gt; 'a Script_typed_ir.set -&gt; Gas.cost
  end

  module Interpreter : sig
    val cycle : Gas.cost

    val loop_cycle : Gas.cost

    val loop_size : Gas.cost

    val loop_iter : Gas.cost

    val loop_map : Gas.cost

    val nop : Gas.cost

    val stack_op : Gas.cost

    val stack_n_op : int -&gt; Gas.cost

    val bool_binop : 'a -&gt; 'b -&gt; Gas.cost

    val bool_unop : 'a -&gt; Gas.cost

    val pair : Gas.cost

    val pair_access : Gas.cost

    val cons : Gas.cost

    val variant_no_data : Gas.cost

    val branch : Gas.cost

    val concat_string : string list -&gt; Gas.cost

    val concat_bytes : MBytes.t list -&gt; Gas.cost

    val slice_string : int -&gt; Gas.cost

    val map_mem : 'a -&gt; ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_to_list : ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_get : 'a -&gt; ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_update :
      'a -&gt; 'b option -&gt; ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_size : Gas.cost

    val set_to_list : 'a Script_typed_ir.set -&gt; Gas.cost

    val set_update : 'a -&gt; bool -&gt; 'a Script_typed_ir.set -&gt; Gas.cost

    val set_mem : 'a -&gt; 'a Script_typed_ir.set -&gt; Gas.cost

    val mul : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val div : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val add : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val sub : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val abs : 'a Script_int.num -&gt; Gas.cost

    val neg : 'a Script_int.num -&gt; Gas.cost

    val int : 'a -&gt; Gas.cost

    val add_timestamp : Script_timestamp.t -&gt; 'a Script_int.num -&gt; Gas.cost

    val sub_timestamp : Script_timestamp.t -&gt; 'a Script_int.num -&gt; Gas.cost

    val diff_timestamps : Script_timestamp.t -&gt; Script_timestamp.t -&gt; Gas.cost

    val empty_set : Gas.cost

    val set_size : Gas.cost

    val empty_map : Gas.cost

    val int64_op : Gas.cost

    val z_to_int64 : Gas.cost

    val int64_to_z : Gas.cost

    val logor : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val logand : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val logxor : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val lognot : 'a Script_int.num -&gt; Gas.cost

    val shift_left : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val shift_right : 'a Script_int.num -&gt; 'b Script_int.num -&gt; Gas.cost

    val exec : Gas.cost

    val push : Gas.cost

    val compare_res : Gas.cost

    val unpack_failed : MBytes.t -&gt; Gas.cost

    val address : Gas.cost

    val contract : Gas.cost

    val transfer : Gas.cost

    val create_account : Gas.cost

    val create_contract : Gas.cost

    val implicit_account : Gas.cost

    val set_delegate : Gas.cost

    val balance : Gas.cost

    val now : Gas.cost

    val check_signature : public_key -&gt; MBytes.t -&gt; Gas.cost

    val hash_key : Gas.cost

    val hash_blake2b : MBytes.t -&gt; Gas.cost

    val hash_sha256 : MBytes.t -&gt; Gas.cost

    val hash_sha512 : MBytes.t -&gt; Gas.cost

    val steps_to_quota : Gas.cost

    val source : Gas.cost

    val self : Gas.cost

    val amount : Gas.cost

    val chain_id : Gas.cost

    val wrap : Gas.cost

    val compare : 'a Script_typed_ir.comparable_ty -&gt; 'a -&gt; 'a -&gt; Gas.cost

    val apply : Gas.cost
  end

  module Typechecking : sig
    val cycle : Gas.cost

    val unit : Gas.cost

    val bool : Gas.cost

    val tez : Gas.cost

    val z : Z.t -&gt; Gas.cost

    val string : int -&gt; Gas.cost

    val bytes : int -&gt; Gas.cost

    val int_of_string : string -&gt; Gas.cost

    val string_timestamp : Gas.cost

    val key : Gas.cost

    val key_hash : Gas.cost

    val signature : Gas.cost

    val chain_id : Gas.cost

    val contract : Gas.cost

    (** Gas.Cost of getting the code for a contract *)
    val get_script : Gas.cost

    val contract_exists : Gas.cost

    (** Additional Gas.cost of parsing a pair over the Gas.cost of parsing each type  *)
    val pair : Gas.cost

    val union : Gas.cost

    val lambda : Gas.cost

    val some : Gas.cost

    val none : Gas.cost

    val list_element : Gas.cost

    val set_element : int -&gt; Gas.cost

    val map_element : int -&gt; Gas.cost

    val primitive_type : Gas.cost

    val one_arg_type : Gas.cost

    val two_arg_type : Gas.cost

    val operation : int -&gt; Gas.cost

    (** Cost of parsing a type *)
    val type_ : int -&gt; Gas.cost

    (** Cost of parsing an instruction *)
    val instr : ('a, 'b) Script_typed_ir.instr -&gt; Gas.cost
  end

  module Unparse : sig
    val prim_cost : int -&gt; Script.annot -&gt; Gas.cost

    val seq_cost : int -&gt; Gas.cost

    val cycle : Gas.cost

    val unit : Gas.cost

    val bool : Gas.cost

    val z : Z.t -&gt; Gas.cost

    val int : 'a Script_int.num -&gt; Gas.cost

    val tez : Gas.cost

    val string : string -&gt; Gas.cost

    val bytes : MBytes.t -&gt; Gas.cost

    val timestamp : Script_timestamp.t -&gt; Gas.cost

    val key : Gas.cost

    val key_hash : Gas.cost

    val signature : Gas.cost

    val operation : MBytes.t -&gt; Gas.cost

    val chain_id : MBytes.t -&gt; Gas.cost

    val contract : Gas.cost

    (** Additional Gas.cost of parsing a pair over the Gas.cost of parsing each type  *)
    val pair : Gas.cost

    val union : Gas.cost

    val some : Gas.cost

    val none : Gas.cost

    val list_element : Gas.cost

    val set_element : Gas.cost

    val map_element : Gas.cost

    val one_arg_type : Script.annot -&gt; Gas.cost

    val two_arg_type : Script.annot -&gt; Gas.cost

    val set_to_list : 'a Script_typed_ir.set -&gt; Gas.cost

    val map_to_list : ('a, 'b) Script_typed_ir.map -&gt; Gas.cost
  end
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_gas.mli"><code>Michelson_v1_gas_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Script_typed_ir.

Module Cost_of.
  Parameter manager_operation : Alpha_context.Gas.cost.
  
  Module Legacy.
    Parameter z_to_int64 : Alpha_context.Gas.cost.
    
    Parameter __hash_value : MBytes.t -&gt; Z -&gt; Alpha_context.Gas.cost.
    
    Parameter map_to_list : forall {b c : Set},
      Script_typed_ir.map b c -&gt; Alpha_context.Gas.cost.
    
    Parameter set_update : forall {a : Set},
      a -&gt; bool -&gt; Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
  End Legacy.
  
  Module Interpreter.
    Parameter cycle : Alpha_context.Gas.cost.
    
    Parameter loop_cycle : Alpha_context.Gas.cost.
    
    Parameter loop_size : Alpha_context.Gas.cost.
    
    Parameter loop_iter : Alpha_context.Gas.cost.
    
    Parameter loop_map : Alpha_context.Gas.cost.
    
    Parameter nop : Alpha_context.Gas.cost.
    
    Parameter stack_op : Alpha_context.Gas.cost.
    
    Parameter stack_n_op : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter bool_binop : forall {a b : Set}, a -&gt; b -&gt; Alpha_context.Gas.cost.
    
    Parameter bool_unop : forall {a : Set}, a -&gt; Alpha_context.Gas.cost.
    
    Parameter pair : Alpha_context.Gas.cost.
    
    Parameter pair_access : Alpha_context.Gas.cost.
    
    Parameter cons : Alpha_context.Gas.cost.
    
    Parameter variant_no_data : Alpha_context.Gas.cost.
    
    Parameter branch : Alpha_context.Gas.cost.
    
    Parameter concat_string : list string -&gt; Alpha_context.Gas.cost.
    
    Parameter concat_bytes : list MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter slice_string : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter map_mem : forall {a b : Set},
      a -&gt; Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_to_list : forall {a b : Set},
      Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_get : forall {a b : Set},
      a -&gt; Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_update : forall {a b : Set},
      a -&gt; option b -&gt; Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_size : Alpha_context.Gas.cost.
    
    Parameter set_to_list : forall {a : Set},
      Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter set_update : forall {a : Set},
      a -&gt; bool -&gt; Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter set_mem : forall {a : Set},
      a -&gt; Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter mul : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter div : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter add : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter sub : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter abs : forall {a : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Gas.cost.
    
    Parameter neg : forall {a : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Gas.cost.
    
    Parameter int : forall {a : Set}, a -&gt; Alpha_context.Gas.cost.
    
    Parameter add_timestamp : forall {a : Set},
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_int.num a -&gt;
      Alpha_context.Gas.cost.
    
    Parameter sub_timestamp : forall {a : Set},
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_int.num a -&gt;
      Alpha_context.Gas.cost.
    
    Parameter diff_timestamps :
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_timestamp.t -&gt;
      Alpha_context.Gas.cost.
    
    Parameter empty_set : Alpha_context.Gas.cost.
    
    Parameter set_size : Alpha_context.Gas.cost.
    
    Parameter empty_map : Alpha_context.Gas.cost.
    
    Parameter int64_op : Alpha_context.Gas.cost.
    
    Parameter z_to_int64 : Alpha_context.Gas.cost.
    
    Parameter int64_to_z : Alpha_context.Gas.cost.
    
    Parameter logor : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter logand : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter logxor : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter lognot : forall {a : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Gas.cost.
    
    Parameter shift_left : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter shift_right : forall {a b : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Script_int.num b -&gt;
      Alpha_context.Gas.cost.
    
    Parameter exec : Alpha_context.Gas.cost.
    
    Parameter push : Alpha_context.Gas.cost.
    
    Parameter compare_res : Alpha_context.Gas.cost.
    
    Parameter unpack_failed : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter address : Alpha_context.Gas.cost.
    
    Parameter contract : Alpha_context.Gas.cost.
    
    Parameter transfer : Alpha_context.Gas.cost.
    
    Parameter create_account : Alpha_context.Gas.cost.
    
    Parameter create_contract : Alpha_context.Gas.cost.
    
    Parameter implicit_account : Alpha_context.Gas.cost.
    
    Parameter set_delegate : Alpha_context.Gas.cost.
    
    Parameter balance : Alpha_context.Gas.cost.
    
    Parameter now : Alpha_context.Gas.cost.
    
    Parameter check_signature :
      Alpha_context.public_key -&gt; MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter hash_key : Alpha_context.Gas.cost.
    
    Parameter hash_blake2b : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter hash_sha256 : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter hash_sha512 : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter steps_to_quota : Alpha_context.Gas.cost.
    
    Parameter source : Alpha_context.Gas.cost.
    
    Parameter self : Alpha_context.Gas.cost.
    
    Parameter amount : Alpha_context.Gas.cost.
    
    Parameter chain_id : Alpha_context.Gas.cost.
    
    Parameter wrap : Alpha_context.Gas.cost.
    
    Parameter compare : forall {a : Set},
      Script_typed_ir.comparable_ty a -&gt; a -&gt; a -&gt; Alpha_context.Gas.cost.
    
    Parameter apply : Alpha_context.Gas.cost.
  End Interpreter.
  
  Module Typechecking.
    Parameter cycle : Alpha_context.Gas.cost.
    
    Parameter __unit_value : Alpha_context.Gas.cost.
    
    Parameter __bool_value : Alpha_context.Gas.cost.
    
    Parameter tez : Alpha_context.Gas.cost.
    
    Parameter z : Z.t -&gt; Alpha_context.Gas.cost.
    
    Parameter __string_value : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter __bytes_value : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter int_of_string : string -&gt; Alpha_context.Gas.cost.
    
    Parameter string_timestamp : Alpha_context.Gas.cost.
    
    Parameter key : Alpha_context.Gas.cost.
    
    Parameter key_hash : Alpha_context.Gas.cost.
    
    Parameter signature : Alpha_context.Gas.cost.
    
    Parameter chain_id : Alpha_context.Gas.cost.
    
    Parameter contract : Alpha_context.Gas.cost.
    
    Parameter get_script : Alpha_context.Gas.cost.
    
    Parameter contract_exists : Alpha_context.Gas.cost.
    
    Parameter pair : Alpha_context.Gas.cost.
    
    Parameter union : Alpha_context.Gas.cost.
    
    Parameter lambda : Alpha_context.Gas.cost.
    
    Parameter some : Alpha_context.Gas.cost.
    
    Parameter none : Alpha_context.Gas.cost.
    
    Parameter list_element : Alpha_context.Gas.cost.
    
    Parameter set_element : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter map_element : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter primitive_type : Alpha_context.Gas.cost.
    
    Parameter one_arg_type : Alpha_context.Gas.cost.
    
    Parameter two_arg_type : Alpha_context.Gas.cost.
    
    Parameter operation : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter type_ : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter instr : forall {a b : Set},
      Script_typed_ir.instr a b -&gt; Alpha_context.Gas.cost.
  End Typechecking.
  
  Module Unparse.
    Parameter prim_cost :
      Z -&gt; Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost.
    
    Parameter seq_cost : Z -&gt; Alpha_context.Gas.cost.
    
    Parameter cycle : Alpha_context.Gas.cost.
    
    Parameter __unit_value : Alpha_context.Gas.cost.
    
    Parameter __bool_value : Alpha_context.Gas.cost.
    
    Parameter z : Z.t -&gt; Alpha_context.Gas.cost.
    
    Parameter int : forall {a : Set},
      Alpha_context.Script_int.num a -&gt; Alpha_context.Gas.cost.
    
    Parameter tez : Alpha_context.Gas.cost.
    
    Parameter __string_value : string -&gt; Alpha_context.Gas.cost.
    
    Parameter __bytes_value : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter timestamp :
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Gas.cost.
    
    Parameter key : Alpha_context.Gas.cost.
    
    Parameter key_hash : Alpha_context.Gas.cost.
    
    Parameter signature : Alpha_context.Gas.cost.
    
    Parameter operation : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter chain_id : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter contract : Alpha_context.Gas.cost.
    
    Parameter pair : Alpha_context.Gas.cost.
    
    Parameter union : Alpha_context.Gas.cost.
    
    Parameter some : Alpha_context.Gas.cost.
    
    Parameter none : Alpha_context.Gas.cost.
    
    Parameter list_element : Alpha_context.Gas.cost.
    
    Parameter set_element : Alpha_context.Gas.cost.
    
    Parameter map_element : Alpha_context.Gas.cost.
    
    Parameter one_arg_type :
      Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost.
    
    Parameter two_arg_type :
      Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost.
    
    Parameter set_to_list : forall {a : Set},
      Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter map_to_list : forall {a b : Set},
      Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
  End Unparse.
End Cost_of.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_primitives.ml">
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.ml"><code>michelson_v1_primitives.ml</code></a>&nbsp;<span class="label label-danger">7 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Micheline

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unknown_primitive_name of string</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_case of string</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Invalid_primitive_name of
      string Micheline.canonical * Micheline.canonical_location</abbr>

type prim =
  | K_parameter
  | K_storage
  | K_code
  | D_False
  | D_Elt
  | D_Left
  | D_None
  | D_Pair
  | D_Right
  | D_Some
  | D_True
  | D_Unit
  | I_PACK
  | I_UNPACK
  | I_BLAKE2B
  | I_SHA256
  | I_SHA512
  | I_ABS
  | I_ADD
  | I_AMOUNT
  | I_AND
  | I_BALANCE
  | I_CAR
  | I_CDR
  | I_CHAIN_ID
  | I_CHECK_SIGNATURE
  | I_COMPARE
  | I_CONCAT
  | I_CONS
  | I_CREATE_ACCOUNT
  | I_CREATE_CONTRACT
  | I_IMPLICIT_ACCOUNT
  | I_DIP
  | I_DROP
  | I_DUP
  | I_EDIV
  | I_EMPTY_BIG_MAP
  | I_EMPTY_MAP
  | I_EMPTY_SET
  | I_EQ
  | I_EXEC
  | I_APPLY
  | I_FAILWITH
  | I_GE
  | I_GET
  | I_GT
  | I_HASH_KEY
  | I_IF
  | I_IF_CONS
  | I_IF_LEFT
  | I_IF_NONE
  | I_INT
  | I_LAMBDA
  | I_LE
  | I_LEFT
  | I_LOOP
  | I_LSL
  | I_LSR
  | I_LT
  | I_MAP
  | I_MEM
  | I_MUL
  | I_NEG
  | I_NEQ
  | I_NIL
  | I_NONE
  | I_NOT
  | I_NOW
  | I_OR
  | I_PAIR
  | I_PUSH
  | I_RIGHT
  | I_SIZE
  | I_SOME
  | I_SOURCE
  | I_SENDER
  | I_SELF
  | I_SLICE
  | I_STEPS_TO_QUOTA
  | I_SUB
  | I_SWAP
  | I_TRANSFER_TOKENS
  | I_SET_DELEGATE
  | I_UNIT
  | I_UPDATE
  | I_XOR
  | I_ITER
  | I_LOOP_LEFT
  | I_ADDRESS
  | I_CONTRACT
  | I_ISNAT
  | I_CAST
  | I_RENAME
  | I_DIG
  | I_DUG
  | T_bool
  | T_contract
  | T_int
  | T_key
  | T_key_hash
  | T_lambda
  | T_list
  | T_map
  | T_big_map
  | T_nat
  | T_option
  | T_or
  | T_pair
  | T_set
  | T_signature
  | T_string
  | T_bytes
  | T_mutez
  | T_timestamp
  | T_unit
  | T_operation
  | T_address
  | T_chain_id

let valid_case name =
  let is_lower = function '_' | 'a' .. 'z' -&gt; true | _ -&gt; false in
  let is_upper = function '_' | 'A' .. 'Z' -&gt; true | _ -&gt; false in
  let rec for_all a b f =
    Compare.Int.(a &gt; b) || (f a &amp;&amp; for_all (a + 1) b f)
  in
  let len = String.length name in
  Compare.Int.(len &lt;&gt; 0)
  &amp;&amp; Compare.Char.(name.[0] &lt;&gt; '_')
  &amp;&amp; ( (is_upper name.[0] &amp;&amp; for_all 1 (len - 1) (fun i -&gt; is_upper name.[i]))
     || (is_upper name.[0] &amp;&amp; for_all 1 (len - 1) (fun i -&gt; is_lower name.[i]))
     || (is_lower name.[0] &amp;&amp; for_all 1 (len - 1) (fun i -&gt; is_lower name.[i]))
     )

let string_of_prim = function
  | K_parameter -&gt;
      &quot;parameter&quot;
  | K_storage -&gt;
      &quot;storage&quot;
  | K_code -&gt;
      &quot;code&quot;
  | D_False -&gt;
      &quot;False&quot;
  | D_Elt -&gt;
      &quot;Elt&quot;
  | D_Left -&gt;
      &quot;Left&quot;
  | D_None -&gt;
      &quot;None&quot;
  | D_Pair -&gt;
      &quot;Pair&quot;
  | D_Right -&gt;
      &quot;Right&quot;
  | D_Some -&gt;
      &quot;Some&quot;
  | D_True -&gt;
      &quot;True&quot;
  | D_Unit -&gt;
      &quot;Unit&quot;
  | I_PACK -&gt;
      &quot;PACK&quot;
  | I_UNPACK -&gt;
      &quot;UNPACK&quot;
  | I_BLAKE2B -&gt;
      &quot;BLAKE2B&quot;
  | I_SHA256 -&gt;
      &quot;SHA256&quot;
  | I_SHA512 -&gt;
      &quot;SHA512&quot;
  | I_ABS -&gt;
      &quot;ABS&quot;
  | I_ADD -&gt;
      &quot;ADD&quot;
  | I_AMOUNT -&gt;
      &quot;AMOUNT&quot;
  | I_AND -&gt;
      &quot;AND&quot;
  | I_BALANCE -&gt;
      &quot;BALANCE&quot;
  | I_CAR -&gt;
      &quot;CAR&quot;
  | I_CDR -&gt;
      &quot;CDR&quot;
  | I_CHAIN_ID -&gt;
      &quot;CHAIN_ID&quot;
  | I_CHECK_SIGNATURE -&gt;
      &quot;CHECK_SIGNATURE&quot;
  | I_COMPARE -&gt;
      &quot;COMPARE&quot;
  | I_CONCAT -&gt;
      &quot;CONCAT&quot;
  | I_CONS -&gt;
      &quot;CONS&quot;
  | I_CREATE_ACCOUNT -&gt;
      &quot;CREATE_ACCOUNT&quot;
  | I_CREATE_CONTRACT -&gt;
      &quot;CREATE_CONTRACT&quot;
  | I_IMPLICIT_ACCOUNT -&gt;
      &quot;IMPLICIT_ACCOUNT&quot;
  | I_DIP -&gt;
      &quot;DIP&quot;
  | I_DROP -&gt;
      &quot;DROP&quot;
  | I_DUP -&gt;
      &quot;DUP&quot;
  | I_EDIV -&gt;
      &quot;EDIV&quot;
  | I_EMPTY_BIG_MAP -&gt;
      &quot;EMPTY_BIG_MAP&quot;
  | I_EMPTY_MAP -&gt;
      &quot;EMPTY_MAP&quot;
  | I_EMPTY_SET -&gt;
      &quot;EMPTY_SET&quot;
  | I_EQ -&gt;
      &quot;EQ&quot;
  | I_EXEC -&gt;
      &quot;EXEC&quot;
  | I_APPLY -&gt;
      &quot;APPLY&quot;
  | I_FAILWITH -&gt;
      &quot;FAILWITH&quot;
  | I_GE -&gt;
      &quot;GE&quot;
  | I_GET -&gt;
      &quot;GET&quot;
  | I_GT -&gt;
      &quot;GT&quot;
  | I_HASH_KEY -&gt;
      &quot;HASH_KEY&quot;
  | I_IF -&gt;
      &quot;IF&quot;
  | I_IF_CONS -&gt;
      &quot;IF_CONS&quot;
  | I_IF_LEFT -&gt;
      &quot;IF_LEFT&quot;
  | I_IF_NONE -&gt;
      &quot;IF_NONE&quot;
  | I_INT -&gt;
      &quot;INT&quot;
  | I_LAMBDA -&gt;
      &quot;LAMBDA&quot;
  | I_LE -&gt;
      &quot;LE&quot;
  | I_LEFT -&gt;
      &quot;LEFT&quot;
  | I_LOOP -&gt;
      &quot;LOOP&quot;
  | I_LSL -&gt;
      &quot;LSL&quot;
  | I_LSR -&gt;
      &quot;LSR&quot;
  | I_LT -&gt;
      &quot;LT&quot;
  | I_MAP -&gt;
      &quot;MAP&quot;
  | I_MEM -&gt;
      &quot;MEM&quot;
  | I_MUL -&gt;
      &quot;MUL&quot;
  | I_NEG -&gt;
      &quot;NEG&quot;
  | I_NEQ -&gt;
      &quot;NEQ&quot;
  | I_NIL -&gt;
      &quot;NIL&quot;
  | I_NONE -&gt;
      &quot;NONE&quot;
  | I_NOT -&gt;
      &quot;NOT&quot;
  | I_NOW -&gt;
      &quot;NOW&quot;
  | I_OR -&gt;
      &quot;OR&quot;
  | I_PAIR -&gt;
      &quot;PAIR&quot;
  | I_PUSH -&gt;
      &quot;PUSH&quot;
  | I_RIGHT -&gt;
      &quot;RIGHT&quot;
  | I_SIZE -&gt;
      &quot;SIZE&quot;
  | I_SOME -&gt;
      &quot;SOME&quot;
  | I_SOURCE -&gt;
      &quot;SOURCE&quot;
  | I_SENDER -&gt;
      &quot;SENDER&quot;
  | I_SELF -&gt;
      &quot;SELF&quot;
  | I_SLICE -&gt;
      &quot;SLICE&quot;
  | I_STEPS_TO_QUOTA -&gt;
      &quot;STEPS_TO_QUOTA&quot;
  | I_SUB -&gt;
      &quot;SUB&quot;
  | I_SWAP -&gt;
      &quot;SWAP&quot;
  | I_TRANSFER_TOKENS -&gt;
      &quot;TRANSFER_TOKENS&quot;
  | I_SET_DELEGATE -&gt;
      &quot;SET_DELEGATE&quot;
  | I_UNIT -&gt;
      &quot;UNIT&quot;
  | I_UPDATE -&gt;
      &quot;UPDATE&quot;
  | I_XOR -&gt;
      &quot;XOR&quot;
  | I_ITER -&gt;
      &quot;ITER&quot;
  | I_LOOP_LEFT -&gt;
      &quot;LOOP_LEFT&quot;
  | I_ADDRESS -&gt;
      &quot;ADDRESS&quot;
  | I_CONTRACT -&gt;
      &quot;CONTRACT&quot;
  | I_ISNAT -&gt;
      &quot;ISNAT&quot;
  | I_CAST -&gt;
      &quot;CAST&quot;
  | I_RENAME -&gt;
      &quot;RENAME&quot;
  | I_DIG -&gt;
      &quot;DIG&quot;
  | I_DUG -&gt;
      &quot;DUG&quot;
  | T_bool -&gt;
      &quot;bool&quot;
  | T_contract -&gt;
      &quot;contract&quot;
  | T_int -&gt;
      &quot;int&quot;
  | T_key -&gt;
      &quot;key&quot;
  | T_key_hash -&gt;
      &quot;key_hash&quot;
  | T_lambda -&gt;
      &quot;lambda&quot;
  | T_list -&gt;
      &quot;list&quot;
  | T_map -&gt;
      &quot;map&quot;
  | T_big_map -&gt;
      &quot;big_map&quot;
  | T_nat -&gt;
      &quot;nat&quot;
  | T_option -&gt;
      &quot;option&quot;
  | T_or -&gt;
      &quot;or&quot;
  | T_pair -&gt;
      &quot;pair&quot;
  | T_set -&gt;
      &quot;set&quot;
  | T_signature -&gt;
      &quot;signature&quot;
  | T_string -&gt;
      &quot;string&quot;
  | T_bytes -&gt;
      &quot;bytes&quot;
  | T_mutez -&gt;
      &quot;mutez&quot;
  | T_timestamp -&gt;
      &quot;timestamp&quot;
  | T_unit -&gt;
      &quot;unit&quot;
  | T_operation -&gt;
      &quot;operation&quot;
  | T_address -&gt;
      &quot;address&quot;
  | T_chain_id -&gt;
      &quot;chain_id&quot;

let prim_of_string = function
  | &quot;parameter&quot; -&gt;
      ok K_parameter
  | &quot;storage&quot; -&gt;
      ok K_storage
  | &quot;code&quot; -&gt;
      ok K_code
  | &quot;False&quot; -&gt;
      ok D_False
  | &quot;Elt&quot; -&gt;
      ok D_Elt
  | &quot;Left&quot; -&gt;
      ok D_Left
  | &quot;None&quot; -&gt;
      ok D_None
  | &quot;Pair&quot; -&gt;
      ok D_Pair
  | &quot;Right&quot; -&gt;
      ok D_Right
  | &quot;Some&quot; -&gt;
      ok D_Some
  | &quot;True&quot; -&gt;
      ok D_True
  | &quot;Unit&quot; -&gt;
      ok D_Unit
  | &quot;PACK&quot; -&gt;
      ok I_PACK
  | &quot;UNPACK&quot; -&gt;
      ok I_UNPACK
  | &quot;BLAKE2B&quot; -&gt;
      ok I_BLAKE2B
  | &quot;SHA256&quot; -&gt;
      ok I_SHA256
  | &quot;SHA512&quot; -&gt;
      ok I_SHA512
  | &quot;ABS&quot; -&gt;
      ok I_ABS
  | &quot;ADD&quot; -&gt;
      ok I_ADD
  | &quot;AMOUNT&quot; -&gt;
      ok I_AMOUNT
  | &quot;AND&quot; -&gt;
      ok I_AND
  | &quot;BALANCE&quot; -&gt;
      ok I_BALANCE
  | &quot;CAR&quot; -&gt;
      ok I_CAR
  | &quot;CDR&quot; -&gt;
      ok I_CDR
  | &quot;CHAIN_ID&quot; -&gt;
      ok I_CHAIN_ID
  | &quot;CHECK_SIGNATURE&quot; -&gt;
      ok I_CHECK_SIGNATURE
  | &quot;COMPARE&quot; -&gt;
      ok I_COMPARE
  | &quot;CONCAT&quot; -&gt;
      ok I_CONCAT
  | &quot;CONS&quot; -&gt;
      ok I_CONS
  | &quot;CREATE_ACCOUNT&quot; -&gt;
      ok I_CREATE_ACCOUNT
  | &quot;CREATE_CONTRACT&quot; -&gt;
      ok I_CREATE_CONTRACT
  | &quot;IMPLICIT_ACCOUNT&quot; -&gt;
      ok I_IMPLICIT_ACCOUNT
  | &quot;DIP&quot; -&gt;
      ok I_DIP
  | &quot;DROP&quot; -&gt;
      ok I_DROP
  | &quot;DUP&quot; -&gt;
      ok I_DUP
  | &quot;EDIV&quot; -&gt;
      ok I_EDIV
  | &quot;EMPTY_BIG_MAP&quot; -&gt;
      ok I_EMPTY_BIG_MAP
  | &quot;EMPTY_MAP&quot; -&gt;
      ok I_EMPTY_MAP
  | &quot;EMPTY_SET&quot; -&gt;
      ok I_EMPTY_SET
  | &quot;EQ&quot; -&gt;
      ok I_EQ
  | &quot;EXEC&quot; -&gt;
      ok I_EXEC
  | &quot;APPLY&quot; -&gt;
      ok I_APPLY
  | &quot;FAILWITH&quot; -&gt;
      ok I_FAILWITH
  | &quot;GE&quot; -&gt;
      ok I_GE
  | &quot;GET&quot; -&gt;
      ok I_GET
  | &quot;GT&quot; -&gt;
      ok I_GT
  | &quot;HASH_KEY&quot; -&gt;
      ok I_HASH_KEY
  | &quot;IF&quot; -&gt;
      ok I_IF
  | &quot;IF_CONS&quot; -&gt;
      ok I_IF_CONS
  | &quot;IF_LEFT&quot; -&gt;
      ok I_IF_LEFT
  | &quot;IF_NONE&quot; -&gt;
      ok I_IF_NONE
  | &quot;INT&quot; -&gt;
      ok I_INT
  | &quot;LAMBDA&quot; -&gt;
      ok I_LAMBDA
  | &quot;LE&quot; -&gt;
      ok I_LE
  | &quot;LEFT&quot; -&gt;
      ok I_LEFT
  | &quot;LOOP&quot; -&gt;
      ok I_LOOP
  | &quot;LSL&quot; -&gt;
      ok I_LSL
  | &quot;LSR&quot; -&gt;
      ok I_LSR
  | &quot;LT&quot; -&gt;
      ok I_LT
  | &quot;MAP&quot; -&gt;
      ok I_MAP
  | &quot;MEM&quot; -&gt;
      ok I_MEM
  | &quot;MUL&quot; -&gt;
      ok I_MUL
  | &quot;NEG&quot; -&gt;
      ok I_NEG
  | &quot;NEQ&quot; -&gt;
      ok I_NEQ
  | &quot;NIL&quot; -&gt;
      ok I_NIL
  | &quot;NONE&quot; -&gt;
      ok I_NONE
  | &quot;NOT&quot; -&gt;
      ok I_NOT
  | &quot;NOW&quot; -&gt;
      ok I_NOW
  | &quot;OR&quot; -&gt;
      ok I_OR
  | &quot;PAIR&quot; -&gt;
      ok I_PAIR
  | &quot;PUSH&quot; -&gt;
      ok I_PUSH
  | &quot;RIGHT&quot; -&gt;
      ok I_RIGHT
  | &quot;SIZE&quot; -&gt;
      ok I_SIZE
  | &quot;SOME&quot; -&gt;
      ok I_SOME
  | &quot;SOURCE&quot; -&gt;
      ok I_SOURCE
  | &quot;SENDER&quot; -&gt;
      ok I_SENDER
  | &quot;SELF&quot; -&gt;
      ok I_SELF
  | &quot;SLICE&quot; -&gt;
      ok I_SLICE
  | &quot;STEPS_TO_QUOTA&quot; -&gt;
      ok I_STEPS_TO_QUOTA
  | &quot;SUB&quot; -&gt;
      ok I_SUB
  | &quot;SWAP&quot; -&gt;
      ok I_SWAP
  | &quot;TRANSFER_TOKENS&quot; -&gt;
      ok I_TRANSFER_TOKENS
  | &quot;SET_DELEGATE&quot; -&gt;
      ok I_SET_DELEGATE
  | &quot;UNIT&quot; -&gt;
      ok I_UNIT
  | &quot;UPDATE&quot; -&gt;
      ok I_UPDATE
  | &quot;XOR&quot; -&gt;
      ok I_XOR
  | &quot;ITER&quot; -&gt;
      ok I_ITER
  | &quot;LOOP_LEFT&quot; -&gt;
      ok I_LOOP_LEFT
  | &quot;ADDRESS&quot; -&gt;
      ok I_ADDRESS
  | &quot;CONTRACT&quot; -&gt;
      ok I_CONTRACT
  | &quot;ISNAT&quot; -&gt;
      ok I_ISNAT
  | &quot;CAST&quot; -&gt;
      ok I_CAST
  | &quot;RENAME&quot; -&gt;
      ok I_RENAME
  | &quot;DIG&quot; -&gt;
      ok I_DIG
  | &quot;DUG&quot; -&gt;
      ok I_DUG
  | &quot;bool&quot; -&gt;
      ok T_bool
  | &quot;contract&quot; -&gt;
      ok T_contract
  | &quot;int&quot; -&gt;
      ok T_int
  | &quot;key&quot; -&gt;
      ok T_key
  | &quot;key_hash&quot; -&gt;
      ok T_key_hash
  | &quot;lambda&quot; -&gt;
      ok T_lambda
  | &quot;list&quot; -&gt;
      ok T_list
  | &quot;map&quot; -&gt;
      ok T_map
  | &quot;big_map&quot; -&gt;
      ok T_big_map
  | &quot;nat&quot; -&gt;
      ok T_nat
  | &quot;option&quot; -&gt;
      ok T_option
  | &quot;or&quot; -&gt;
      ok T_or
  | &quot;pair&quot; -&gt;
      ok T_pair
  | &quot;set&quot; -&gt;
      ok T_set
  | &quot;signature&quot; -&gt;
      ok T_signature
  | &quot;string&quot; -&gt;
      ok T_string
  | &quot;bytes&quot; -&gt;
      ok T_bytes
  | &quot;mutez&quot; -&gt;
      ok T_mutez
  | &quot;timestamp&quot; -&gt;
      ok T_timestamp
  | &quot;unit&quot; -&gt;
      ok T_unit
  | &quot;operation&quot; -&gt;
      ok T_operation
  | &quot;address&quot; -&gt;
      ok T_address
  | &quot;chain_id&quot; -&gt;
      ok T_chain_id
  | n -&gt;
      if valid_case n then error <abbr class="mark-error" title="Values of extensible types are not handled">(Unknown_primitive_name n)</abbr>
      else error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_case n)</abbr>

let prims_of_strings expr =
  let rec convert = function
    | Int (l, x) -&gt;
        ok (Int (l, x))
    | String (l, x) -&gt;
        ok (String (l, x))
    | Bytes (l, x) -&gt;
        ok (Bytes (l, x))
    | Prim (loc, prim, args, annot) -&gt;
        Error_monad.record_trace
          <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_primitive_name (expr, loc))</abbr>
          (prim_of_string prim)
        &gt;&gt;? fun prim -&gt;
        List.fold_left
          (fun acc arg -&gt;
            acc &gt;&gt;? fun args -&gt; convert arg &gt;&gt;? fun arg -&gt; ok (arg :: args))
          (ok [])
          args
        &gt;&gt;? fun args -&gt; ok (Prim (0, prim, List.rev args, annot))
    | Seq (_, args) -&gt;
        List.fold_left
          (fun acc arg -&gt;
            acc &gt;&gt;? fun args -&gt; convert arg &gt;&gt;? fun arg -&gt; ok (arg :: args))
          (ok [])
          args
        &gt;&gt;? fun args -&gt; ok (Seq (0, List.rev args))
  in
  convert (root expr) &gt;&gt;? fun expr -&gt; ok (strip_locations expr)

let strings_of_prims expr =
  let rec convert = function
    | Int (l, x) -&gt;
        Int (l, x)
    | String (l, x) -&gt;
        String (l, x)
    | Bytes (l, x) -&gt;
        Bytes (l, x)
    | Prim (_, prim, args, annot) -&gt;
        let prim = string_of_prim prim in
        let args = List.map convert args in
        Prim (0, prim, args, annot)
    | Seq (_, args) -&gt;
        let args = List.map convert args in
        Seq (0, args)
  in
  strip_locations (convert (root expr))

let prim_encoding =
  let open Data_encoding in
  def &quot;michelson.v1.primitives&quot;
  @@ string_enum
       [ (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;parameter&quot;, K_parameter);
         (&quot;storage&quot;, K_storage);
         (&quot;code&quot;, K_code);
         (&quot;False&quot;, D_False);
         (&quot;Elt&quot;, D_Elt);
         (&quot;Left&quot;, D_Left);
         (&quot;None&quot;, D_None);
         (&quot;Pair&quot;, D_Pair);
         (&quot;Right&quot;, D_Right);
         (&quot;Some&quot;, D_Some);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;True&quot;, D_True);
         (&quot;Unit&quot;, D_Unit);
         (&quot;PACK&quot;, I_PACK);
         (&quot;UNPACK&quot;, I_UNPACK);
         (&quot;BLAKE2B&quot;, I_BLAKE2B);
         (&quot;SHA256&quot;, I_SHA256);
         (&quot;SHA512&quot;, I_SHA512);
         (&quot;ABS&quot;, I_ABS);
         (&quot;ADD&quot;, I_ADD);
         (&quot;AMOUNT&quot;, I_AMOUNT);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;AND&quot;, I_AND);
         (&quot;BALANCE&quot;, I_BALANCE);
         (&quot;CAR&quot;, I_CAR);
         (&quot;CDR&quot;, I_CDR);
         (&quot;CHECK_SIGNATURE&quot;, I_CHECK_SIGNATURE);
         (&quot;COMPARE&quot;, I_COMPARE);
         (&quot;CONCAT&quot;, I_CONCAT);
         (&quot;CONS&quot;, I_CONS);
         (&quot;CREATE_ACCOUNT&quot;, I_CREATE_ACCOUNT);
         (&quot;CREATE_CONTRACT&quot;, I_CREATE_CONTRACT);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;IMPLICIT_ACCOUNT&quot;, I_IMPLICIT_ACCOUNT);
         (&quot;DIP&quot;, I_DIP);
         (&quot;DROP&quot;, I_DROP);
         (&quot;DUP&quot;, I_DUP);
         (&quot;EDIV&quot;, I_EDIV);
         (&quot;EMPTY_MAP&quot;, I_EMPTY_MAP);
         (&quot;EMPTY_SET&quot;, I_EMPTY_SET);
         (&quot;EQ&quot;, I_EQ);
         (&quot;EXEC&quot;, I_EXEC);
         (&quot;FAILWITH&quot;, I_FAILWITH);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;GE&quot;, I_GE);
         (&quot;GET&quot;, I_GET);
         (&quot;GT&quot;, I_GT);
         (&quot;HASH_KEY&quot;, I_HASH_KEY);
         (&quot;IF&quot;, I_IF);
         (&quot;IF_CONS&quot;, I_IF_CONS);
         (&quot;IF_LEFT&quot;, I_IF_LEFT);
         (&quot;IF_NONE&quot;, I_IF_NONE);
         (&quot;INT&quot;, I_INT);
         (&quot;LAMBDA&quot;, I_LAMBDA);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;LE&quot;, I_LE);
         (&quot;LEFT&quot;, I_LEFT);
         (&quot;LOOP&quot;, I_LOOP);
         (&quot;LSL&quot;, I_LSL);
         (&quot;LSR&quot;, I_LSR);
         (&quot;LT&quot;, I_LT);
         (&quot;MAP&quot;, I_MAP);
         (&quot;MEM&quot;, I_MEM);
         (&quot;MUL&quot;, I_MUL);
         (&quot;NEG&quot;, I_NEG);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;NEQ&quot;, I_NEQ);
         (&quot;NIL&quot;, I_NIL);
         (&quot;NONE&quot;, I_NONE);
         (&quot;NOT&quot;, I_NOT);
         (&quot;NOW&quot;, I_NOW);
         (&quot;OR&quot;, I_OR);
         (&quot;PAIR&quot;, I_PAIR);
         (&quot;PUSH&quot;, I_PUSH);
         (&quot;RIGHT&quot;, I_RIGHT);
         (&quot;SIZE&quot;, I_SIZE);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;SOME&quot;, I_SOME);
         (&quot;SOURCE&quot;, I_SOURCE);
         (&quot;SENDER&quot;, I_SENDER);
         (&quot;SELF&quot;, I_SELF);
         (&quot;STEPS_TO_QUOTA&quot;, I_STEPS_TO_QUOTA);
         (&quot;SUB&quot;, I_SUB);
         (&quot;SWAP&quot;, I_SWAP);
         (&quot;TRANSFER_TOKENS&quot;, I_TRANSFER_TOKENS);
         (&quot;SET_DELEGATE&quot;, I_SET_DELEGATE);
         (&quot;UNIT&quot;, I_UNIT);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;UPDATE&quot;, I_UPDATE);
         (&quot;XOR&quot;, I_XOR);
         (&quot;ITER&quot;, I_ITER);
         (&quot;LOOP_LEFT&quot;, I_LOOP_LEFT);
         (&quot;ADDRESS&quot;, I_ADDRESS);
         (&quot;CONTRACT&quot;, I_CONTRACT);
         (&quot;ISNAT&quot;, I_ISNAT);
         (&quot;CAST&quot;, I_CAST);
         (&quot;RENAME&quot;, I_RENAME);
         (&quot;bool&quot;, T_bool);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;contract&quot;, T_contract);
         (&quot;int&quot;, T_int);
         (&quot;key&quot;, T_key);
         (&quot;key_hash&quot;, T_key_hash);
         (&quot;lambda&quot;, T_lambda);
         (&quot;list&quot;, T_list);
         (&quot;map&quot;, T_map);
         (&quot;big_map&quot;, T_big_map);
         (&quot;nat&quot;, T_nat);
         (&quot;option&quot;, T_option);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;or&quot;, T_or);
         (&quot;pair&quot;, T_pair);
         (&quot;set&quot;, T_set);
         (&quot;signature&quot;, T_signature);
         (&quot;string&quot;, T_string);
         (&quot;bytes&quot;, T_bytes);
         (&quot;mutez&quot;, T_mutez);
         (&quot;timestamp&quot;, T_timestamp);
         (&quot;unit&quot;, T_unit);
         (&quot;operation&quot;, T_operation);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;address&quot;, T_address);
         (* Alpha_002 addition *)
         (&quot;SLICE&quot;, I_SLICE);
         (* Alpha_005 addition *)
         (&quot;DIG&quot;, I_DIG);
         (&quot;DUG&quot;, I_DUG);
         (&quot;EMPTY_BIG_MAP&quot;, I_EMPTY_BIG_MAP);
         (&quot;APPLY&quot;, I_APPLY);
         (&quot;chain_id&quot;, T_chain_id);
         (&quot;CHAIN_ID&quot;, I_CHAIN_ID)
         (* New instructions must be added here, for backward compatibility of the encoding. *)
        ]

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unknown_primitive_name&quot;
    ~title:&quot;Unknown primitive name&quot;
    ~description:&quot;In a script or data expression, a primitive was unknown.&quot;
    ~pp:(fun ppf n -&gt; Format.fprintf ppf &quot;Unknown primitive %s.&quot; n)
    Data_encoding.(obj1 (req &quot;wrong_primitive_name&quot; string))
    (function Unknown_primitive_name got -&gt; Some got | _ -&gt; None)
    (fun got -&gt; Unknown_primitive_name got) ;
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive_name_case&quot;
    ~title:&quot;Invalid primitive name case&quot;
    ~description:
      &quot;In a script or data expression, a primitive name is neither uppercase, \
       lowercase or capitalized.&quot;
    ~pp:(fun ppf n -&gt; Format.fprintf ppf &quot;Primitive %s has invalid case.&quot; n)
    Data_encoding.(obj1 (req &quot;wrong_primitive_name&quot; string))
    (function Invalid_case name -&gt; Some name | _ -&gt; None)
    (fun name -&gt; Invalid_case name) ;
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive_name&quot;
    ~title:&quot;Invalid primitive name&quot;
    ~description:
      &quot;In a script or data expression, a primitive name is unknown or has a \
       wrong case.&quot;
    ~pp:(fun ppf _ -&gt; Format.fprintf ppf &quot;Invalid primitive.&quot;)
    Data_encoding.(
      obj2
        (req
           &quot;expression&quot;
           (Micheline.canonical_encoding ~variant:&quot;generic&quot; string))
        (req &quot;location&quot; Micheline.canonical_location_encoding))
    (function
      | Invalid_primitive_name (expr, loc) -&gt; Some (expr, loc) | _ -&gt; None)
    (fun (expr, loc) -&gt; Invalid_primitive_name (expr, loc))</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.ml"><code>Michelson_v1_primitives.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Import Micheline.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

Inductive prim : Set :=
| K_parameter : prim
| K_storage : prim
| K_code : prim
| D_False : prim
| D_Elt : prim
| D_Left : prim
| D_None : prim
| D_Pair : prim
| D_Right : prim
| D_Some : prim
| D_True : prim
| D_Unit : prim
| I_PACK : prim
| I_UNPACK : prim
| I_BLAKE2B : prim
| I_SHA256 : prim
| I_SHA512 : prim
| I_ABS : prim
| I_ADD : prim
| I_AMOUNT : prim
| I_AND : prim
| I_BALANCE : prim
| I_CAR : prim
| I_CDR : prim
| I_CHAIN_ID : prim
| I_CHECK_SIGNATURE : prim
| I_COMPARE : prim
| I_CONCAT : prim
| I_CONS : prim
| I_CREATE_ACCOUNT : prim
| I_CREATE_CONTRACT : prim
| I_IMPLICIT_ACCOUNT : prim
| I_DIP : prim
| I_DROP : prim
| I_DUP : prim
| I_EDIV : prim
| I_EMPTY_BIG_MAP : prim
| I_EMPTY_MAP : prim
| I_EMPTY_SET : prim
| I_EQ : prim
| I_EXEC : prim
| I_APPLY : prim
| I_FAILWITH : prim
| I_GE : prim
| I_GET : prim
| I_GT : prim
| I_HASH_KEY : prim
| I_IF : prim
| I_IF_CONS : prim
| I_IF_LEFT : prim
| I_IF_NONE : prim
| I_INT : prim
| I_LAMBDA : prim
| I_LE : prim
| I_LEFT : prim
| I_LOOP : prim
| I_LSL : prim
| I_LSR : prim
| I_LT : prim
| I_MAP : prim
| I_MEM : prim
| I_MUL : prim
| I_NEG : prim
| I_NEQ : prim
| I_NIL : prim
| I_NONE : prim
| I_NOT : prim
| I_NOW : prim
| I_OR : prim
| I_PAIR : prim
| I_PUSH : prim
| I_RIGHT : prim
| I_SIZE : prim
| I_SOME : prim
| I_SOURCE : prim
| I_SENDER : prim
| I_SELF : prim
| I_SLICE : prim
| I_STEPS_TO_QUOTA : prim
| I_SUB : prim
| I_SWAP : prim
| I_TRANSFER_TOKENS : prim
| I_SET_DELEGATE : prim
| I_UNIT : prim
| I_UPDATE : prim
| I_XOR : prim
| I_ITER : prim
| I_LOOP_LEFT : prim
| I_ADDRESS : prim
| I_CONTRACT : prim
| I_ISNAT : prim
| I_CAST : prim
| I_RENAME : prim
| I_DIG : prim
| I_DUG : prim
| T_bool : prim
| T_contract : prim
| T_int : prim
| T_key : prim
| T_key_hash : prim
| T_lambda : prim
| T_list : prim
| T_map : prim
| T_big_map : prim
| T_nat : prim
| T_option : prim
| T_or : prim
| T_pair : prim
| T_set : prim
| T_signature : prim
| T_string : prim
| T_bytes : prim
| T_mutez : prim
| T_timestamp : prim
| T_unit : prim
| T_operation : prim
| T_address : prim
| T_chain_id : prim.

Definition valid_case (name : string) : bool :=
  let is_lower (function_parameter : ascii) : bool :=
    match function_parameter with
    |
      &quot;_&quot; % char | &quot;a&quot; % char | &quot;b&quot; % char | &quot;c&quot; % char | &quot;d&quot; % char |
      &quot;e&quot; % char | &quot;f&quot; % char | &quot;g&quot; % char | &quot;h&quot; % char | &quot;i&quot; % char |
      &quot;j&quot; % char | &quot;k&quot; % char | &quot;l&quot; % char | &quot;m&quot; % char | &quot;n&quot; % char |
      &quot;o&quot; % char | &quot;p&quot; % char | &quot;q&quot; % char | &quot;r&quot; % char | &quot;s&quot; % char |
      &quot;t&quot; % char | &quot;u&quot; % char | &quot;v&quot; % char | &quot;w&quot; % char | &quot;x&quot; % char |
      &quot;y&quot; % char | &quot;z&quot; % char =&gt; true
    | _ =&gt; false
    end in
  let is_upper (function_parameter : ascii) : bool :=
    match function_parameter with
    |
      &quot;_&quot; % char | &quot;A&quot; % char | &quot;B&quot; % char | &quot;C&quot; % char | &quot;D&quot; % char |
      &quot;E&quot; % char | &quot;F&quot; % char | &quot;G&quot; % char | &quot;H&quot; % char | &quot;I&quot; % char |
      &quot;J&quot; % char | &quot;K&quot; % char | &quot;L&quot; % char | &quot;M&quot; % char | &quot;N&quot; % char |
      &quot;O&quot; % char | &quot;P&quot; % char | &quot;Q&quot; % char | &quot;R&quot; % char | &quot;S&quot; % char |
      &quot;T&quot; % char | &quot;U&quot; % char | &quot;V&quot; % char | &quot;W&quot; % char | &quot;X&quot; % char |
      &quot;Y&quot; % char | &quot;Z&quot; % char =&gt; true
    | _ =&gt; false
    end in
  let fix for_all
    (a : Compare.Int.[Compare.S.t]) (b : Compare.Int.[Compare.S.t])
    (f : Compare.Int.[Compare.S.t] -&gt; bool) {struct a} : bool :=
    Pervasives.op_pipepipe (Compare.Int.[Compare.S.op_gt] a b)
      (Pervasives.op_andand (f a) (for_all (Pervasives.op_plus a 1) b f)) in
  let len := String.length name in
  Pervasives.op_andand (Compare.Int.[Compare.S.op_ltgt] len 0)
    (Pervasives.op_andand
      (Compare.Char.[Compare.S.op_ltgt] (String.get name 0) &quot;_&quot; % char)
      (Pervasives.op_pipepipe
        (Pervasives.op_andand (is_upper (String.get name 0))
          (for_all 1 (Pervasives.op_minus len 1)
            (fun i =&gt; is_upper (String.get name i))))
        (Pervasives.op_pipepipe
          (Pervasives.op_andand (is_upper (String.get name 0))
            (for_all 1 (Pervasives.op_minus len 1)
              (fun i =&gt; is_lower (String.get name i))))
          (Pervasives.op_andand (is_lower (String.get name 0))
            (for_all 1 (Pervasives.op_minus len 1)
              (fun i =&gt; is_lower (String.get name i))))))).

Definition string_of_prim (function_parameter : prim) : string :=
  match function_parameter with
  | K_parameter =&gt; &quot;parameter&quot; % string
  | K_storage =&gt; &quot;storage&quot; % string
  | K_code =&gt; &quot;code&quot; % string
  | D_False =&gt; &quot;False&quot; % string
  | D_Elt =&gt; &quot;Elt&quot; % string
  | D_Left =&gt; &quot;Left&quot; % string
  | D_None =&gt; &quot;None&quot; % string
  | D_Pair =&gt; &quot;Pair&quot; % string
  | D_Right =&gt; &quot;Right&quot; % string
  | D_Some =&gt; &quot;Some&quot; % string
  | D_True =&gt; &quot;True&quot; % string
  | D_Unit =&gt; &quot;Unit&quot; % string
  | I_PACK =&gt; &quot;PACK&quot; % string
  | I_UNPACK =&gt; &quot;UNPACK&quot; % string
  | I_BLAKE2B =&gt; &quot;BLAKE2B&quot; % string
  | I_SHA256 =&gt; &quot;SHA256&quot; % string
  | I_SHA512 =&gt; &quot;SHA512&quot; % string
  | I_ABS =&gt; &quot;ABS&quot; % string
  | I_ADD =&gt; &quot;ADD&quot; % string
  | I_AMOUNT =&gt; &quot;AMOUNT&quot; % string
  | I_AND =&gt; &quot;AND&quot; % string
  | I_BALANCE =&gt; &quot;BALANCE&quot; % string
  | I_CAR =&gt; &quot;CAR&quot; % string
  | I_CDR =&gt; &quot;CDR&quot; % string
  | I_CHAIN_ID =&gt; &quot;CHAIN_ID&quot; % string
  | I_CHECK_SIGNATURE =&gt; &quot;CHECK_SIGNATURE&quot; % string
  | I_COMPARE =&gt; &quot;COMPARE&quot; % string
  | I_CONCAT =&gt; &quot;CONCAT&quot; % string
  | I_CONS =&gt; &quot;CONS&quot; % string
  | I_CREATE_ACCOUNT =&gt; &quot;CREATE_ACCOUNT&quot; % string
  | I_CREATE_CONTRACT =&gt; &quot;CREATE_CONTRACT&quot; % string
  | I_IMPLICIT_ACCOUNT =&gt; &quot;IMPLICIT_ACCOUNT&quot; % string
  | I_DIP =&gt; &quot;DIP&quot; % string
  | I_DROP =&gt; &quot;DROP&quot; % string
  | I_DUP =&gt; &quot;DUP&quot; % string
  | I_EDIV =&gt; &quot;EDIV&quot; % string
  | I_EMPTY_BIG_MAP =&gt; &quot;EMPTY_BIG_MAP&quot; % string
  | I_EMPTY_MAP =&gt; &quot;EMPTY_MAP&quot; % string
  | I_EMPTY_SET =&gt; &quot;EMPTY_SET&quot; % string
  | I_EQ =&gt; &quot;EQ&quot; % string
  | I_EXEC =&gt; &quot;EXEC&quot; % string
  | I_APPLY =&gt; &quot;APPLY&quot; % string
  | I_FAILWITH =&gt; &quot;FAILWITH&quot; % string
  | I_GE =&gt; &quot;GE&quot; % string
  | I_GET =&gt; &quot;GET&quot; % string
  | I_GT =&gt; &quot;GT&quot; % string
  | I_HASH_KEY =&gt; &quot;HASH_KEY&quot; % string
  | I_IF =&gt; &quot;IF&quot; % string
  | I_IF_CONS =&gt; &quot;IF_CONS&quot; % string
  | I_IF_LEFT =&gt; &quot;IF_LEFT&quot; % string
  | I_IF_NONE =&gt; &quot;IF_NONE&quot; % string
  | I_INT =&gt; &quot;INT&quot; % string
  | I_LAMBDA =&gt; &quot;LAMBDA&quot; % string
  | I_LE =&gt; &quot;LE&quot; % string
  | I_LEFT =&gt; &quot;LEFT&quot; % string
  | I_LOOP =&gt; &quot;LOOP&quot; % string
  | I_LSL =&gt; &quot;LSL&quot; % string
  | I_LSR =&gt; &quot;LSR&quot; % string
  | I_LT =&gt; &quot;LT&quot; % string
  | I_MAP =&gt; &quot;MAP&quot; % string
  | I_MEM =&gt; &quot;MEM&quot; % string
  | I_MUL =&gt; &quot;MUL&quot; % string
  | I_NEG =&gt; &quot;NEG&quot; % string
  | I_NEQ =&gt; &quot;NEQ&quot; % string
  | I_NIL =&gt; &quot;NIL&quot; % string
  | I_NONE =&gt; &quot;NONE&quot; % string
  | I_NOT =&gt; &quot;NOT&quot; % string
  | I_NOW =&gt; &quot;NOW&quot; % string
  | I_OR =&gt; &quot;OR&quot; % string
  | I_PAIR =&gt; &quot;PAIR&quot; % string
  | I_PUSH =&gt; &quot;PUSH&quot; % string
  | I_RIGHT =&gt; &quot;RIGHT&quot; % string
  | I_SIZE =&gt; &quot;SIZE&quot; % string
  | I_SOME =&gt; &quot;SOME&quot; % string
  | I_SOURCE =&gt; &quot;SOURCE&quot; % string
  | I_SENDER =&gt; &quot;SENDER&quot; % string
  | I_SELF =&gt; &quot;SELF&quot; % string
  | I_SLICE =&gt; &quot;SLICE&quot; % string
  | I_STEPS_TO_QUOTA =&gt; &quot;STEPS_TO_QUOTA&quot; % string
  | I_SUB =&gt; &quot;SUB&quot; % string
  | I_SWAP =&gt; &quot;SWAP&quot; % string
  | I_TRANSFER_TOKENS =&gt; &quot;TRANSFER_TOKENS&quot; % string
  | I_SET_DELEGATE =&gt; &quot;SET_DELEGATE&quot; % string
  | I_UNIT =&gt; &quot;UNIT&quot; % string
  | I_UPDATE =&gt; &quot;UPDATE&quot; % string
  | I_XOR =&gt; &quot;XOR&quot; % string
  | I_ITER =&gt; &quot;ITER&quot; % string
  | I_LOOP_LEFT =&gt; &quot;LOOP_LEFT&quot; % string
  | I_ADDRESS =&gt; &quot;ADDRESS&quot; % string
  | I_CONTRACT =&gt; &quot;CONTRACT&quot; % string
  | I_ISNAT =&gt; &quot;ISNAT&quot; % string
  | I_CAST =&gt; &quot;CAST&quot; % string
  | I_RENAME =&gt; &quot;RENAME&quot; % string
  | I_DIG =&gt; &quot;DIG&quot; % string
  | I_DUG =&gt; &quot;DUG&quot; % string
  | T_bool =&gt; &quot;bool&quot; % string
  | T_contract =&gt; &quot;contract&quot; % string
  | T_int =&gt; &quot;int&quot; % string
  | T_key =&gt; &quot;key&quot; % string
  | T_key_hash =&gt; &quot;key_hash&quot; % string
  | T_lambda =&gt; &quot;lambda&quot; % string
  | T_list =&gt; &quot;list&quot; % string
  | T_map =&gt; &quot;map&quot; % string
  | T_big_map =&gt; &quot;big_map&quot; % string
  | T_nat =&gt; &quot;nat&quot; % string
  | T_option =&gt; &quot;option&quot; % string
  | T_or =&gt; &quot;or&quot; % string
  | T_pair =&gt; &quot;pair&quot; % string
  | T_set =&gt; &quot;set&quot; % string
  | T_signature =&gt; &quot;signature&quot; % string
  | T_string =&gt; &quot;string&quot; % string
  | T_bytes =&gt; &quot;bytes&quot; % string
  | T_mutez =&gt; &quot;mutez&quot; % string
  | T_timestamp =&gt; &quot;timestamp&quot; % string
  | T_unit =&gt; &quot;unit&quot; % string
  | T_operation =&gt; &quot;operation&quot; % string
  | T_address =&gt; &quot;address&quot; % string
  | T_chain_id =&gt; &quot;chain_id&quot; % string
  end.

Definition prim_of_string (function_parameter : string)
  : Error_monad.tzresult prim :=
  match function_parameter with
  | &quot;parameter&quot; % string =&gt; Error_monad.ok K_parameter
  | &quot;storage&quot; % string =&gt; Error_monad.ok K_storage
  | &quot;code&quot; % string =&gt; Error_monad.ok K_code
  | &quot;False&quot; % string =&gt; Error_monad.ok D_False
  | &quot;Elt&quot; % string =&gt; Error_monad.ok D_Elt
  | &quot;Left&quot; % string =&gt; Error_monad.ok D_Left
  | &quot;None&quot; % string =&gt; Error_monad.ok D_None
  | &quot;Pair&quot; % string =&gt; Error_monad.ok D_Pair
  | &quot;Right&quot; % string =&gt; Error_monad.ok D_Right
  | &quot;Some&quot; % string =&gt; Error_monad.ok D_Some
  | &quot;True&quot; % string =&gt; Error_monad.ok D_True
  | &quot;Unit&quot; % string =&gt; Error_monad.ok D_Unit
  | &quot;PACK&quot; % string =&gt; Error_monad.ok I_PACK
  | &quot;UNPACK&quot; % string =&gt; Error_monad.ok I_UNPACK
  | &quot;BLAKE2B&quot; % string =&gt; Error_monad.ok I_BLAKE2B
  | &quot;SHA256&quot; % string =&gt; Error_monad.ok I_SHA256
  | &quot;SHA512&quot; % string =&gt; Error_monad.ok I_SHA512
  | &quot;ABS&quot; % string =&gt; Error_monad.ok I_ABS
  | &quot;ADD&quot; % string =&gt; Error_monad.ok I_ADD
  | &quot;AMOUNT&quot; % string =&gt; Error_monad.ok I_AMOUNT
  | &quot;AND&quot; % string =&gt; Error_monad.ok I_AND
  | &quot;BALANCE&quot; % string =&gt; Error_monad.ok I_BALANCE
  | &quot;CAR&quot; % string =&gt; Error_monad.ok I_CAR
  | &quot;CDR&quot; % string =&gt; Error_monad.ok I_CDR
  | &quot;CHAIN_ID&quot; % string =&gt; Error_monad.ok I_CHAIN_ID
  | &quot;CHECK_SIGNATURE&quot; % string =&gt; Error_monad.ok I_CHECK_SIGNATURE
  | &quot;COMPARE&quot; % string =&gt; Error_monad.ok I_COMPARE
  | &quot;CONCAT&quot; % string =&gt; Error_monad.ok I_CONCAT
  | &quot;CONS&quot; % string =&gt; Error_monad.ok I_CONS
  | &quot;CREATE_ACCOUNT&quot; % string =&gt; Error_monad.ok I_CREATE_ACCOUNT
  | &quot;CREATE_CONTRACT&quot; % string =&gt; Error_monad.ok I_CREATE_CONTRACT
  | &quot;IMPLICIT_ACCOUNT&quot; % string =&gt; Error_monad.ok I_IMPLICIT_ACCOUNT
  | &quot;DIP&quot; % string =&gt; Error_monad.ok I_DIP
  | &quot;DROP&quot; % string =&gt; Error_monad.ok I_DROP
  | &quot;DUP&quot; % string =&gt; Error_monad.ok I_DUP
  | &quot;EDIV&quot; % string =&gt; Error_monad.ok I_EDIV
  | &quot;EMPTY_BIG_MAP&quot; % string =&gt; Error_monad.ok I_EMPTY_BIG_MAP
  | &quot;EMPTY_MAP&quot; % string =&gt; Error_monad.ok I_EMPTY_MAP
  | &quot;EMPTY_SET&quot; % string =&gt; Error_monad.ok I_EMPTY_SET
  | &quot;EQ&quot; % string =&gt; Error_monad.ok I_EQ
  | &quot;EXEC&quot; % string =&gt; Error_monad.ok I_EXEC
  | &quot;APPLY&quot; % string =&gt; Error_monad.ok I_APPLY
  | &quot;FAILWITH&quot; % string =&gt; Error_monad.ok I_FAILWITH
  | &quot;GE&quot; % string =&gt; Error_monad.ok I_GE
  | &quot;GET&quot; % string =&gt; Error_monad.ok I_GET
  | &quot;GT&quot; % string =&gt; Error_monad.ok I_GT
  | &quot;HASH_KEY&quot; % string =&gt; Error_monad.ok I_HASH_KEY
  | &quot;IF&quot; % string =&gt; Error_monad.ok I_IF
  | &quot;IF_CONS&quot; % string =&gt; Error_monad.ok I_IF_CONS
  | &quot;IF_LEFT&quot; % string =&gt; Error_monad.ok I_IF_LEFT
  | &quot;IF_NONE&quot; % string =&gt; Error_monad.ok I_IF_NONE
  | &quot;INT&quot; % string =&gt; Error_monad.ok I_INT
  | &quot;LAMBDA&quot; % string =&gt; Error_monad.ok I_LAMBDA
  | &quot;LE&quot; % string =&gt; Error_monad.ok I_LE
  | &quot;LEFT&quot; % string =&gt; Error_monad.ok I_LEFT
  | &quot;LOOP&quot; % string =&gt; Error_monad.ok I_LOOP
  | &quot;LSL&quot; % string =&gt; Error_monad.ok I_LSL
  | &quot;LSR&quot; % string =&gt; Error_monad.ok I_LSR
  | &quot;LT&quot; % string =&gt; Error_monad.ok I_LT
  | &quot;MAP&quot; % string =&gt; Error_monad.ok I_MAP
  | &quot;MEM&quot; % string =&gt; Error_monad.ok I_MEM
  | &quot;MUL&quot; % string =&gt; Error_monad.ok I_MUL
  | &quot;NEG&quot; % string =&gt; Error_monad.ok I_NEG
  | &quot;NEQ&quot; % string =&gt; Error_monad.ok I_NEQ
  | &quot;NIL&quot; % string =&gt; Error_monad.ok I_NIL
  | &quot;NONE&quot; % string =&gt; Error_monad.ok I_NONE
  | &quot;NOT&quot; % string =&gt; Error_monad.ok I_NOT
  | &quot;NOW&quot; % string =&gt; Error_monad.ok I_NOW
  | &quot;OR&quot; % string =&gt; Error_monad.ok I_OR
  | &quot;PAIR&quot; % string =&gt; Error_monad.ok I_PAIR
  | &quot;PUSH&quot; % string =&gt; Error_monad.ok I_PUSH
  | &quot;RIGHT&quot; % string =&gt; Error_monad.ok I_RIGHT
  | &quot;SIZE&quot; % string =&gt; Error_monad.ok I_SIZE
  | &quot;SOME&quot; % string =&gt; Error_monad.ok I_SOME
  | &quot;SOURCE&quot; % string =&gt; Error_monad.ok I_SOURCE
  | &quot;SENDER&quot; % string =&gt; Error_monad.ok I_SENDER
  | &quot;SELF&quot; % string =&gt; Error_monad.ok I_SELF
  | &quot;SLICE&quot; % string =&gt; Error_monad.ok I_SLICE
  | &quot;STEPS_TO_QUOTA&quot; % string =&gt; Error_monad.ok I_STEPS_TO_QUOTA
  | &quot;SUB&quot; % string =&gt; Error_monad.ok I_SUB
  | &quot;SWAP&quot; % string =&gt; Error_monad.ok I_SWAP
  | &quot;TRANSFER_TOKENS&quot; % string =&gt; Error_monad.ok I_TRANSFER_TOKENS
  | &quot;SET_DELEGATE&quot; % string =&gt; Error_monad.ok I_SET_DELEGATE
  | &quot;UNIT&quot; % string =&gt; Error_monad.ok I_UNIT
  | &quot;UPDATE&quot; % string =&gt; Error_monad.ok I_UPDATE
  | &quot;XOR&quot; % string =&gt; Error_monad.ok I_XOR
  | &quot;ITER&quot; % string =&gt; Error_monad.ok I_ITER
  | &quot;LOOP_LEFT&quot; % string =&gt; Error_monad.ok I_LOOP_LEFT
  | &quot;ADDRESS&quot; % string =&gt; Error_monad.ok I_ADDRESS
  | &quot;CONTRACT&quot; % string =&gt; Error_monad.ok I_CONTRACT
  | &quot;ISNAT&quot; % string =&gt; Error_monad.ok I_ISNAT
  | &quot;CAST&quot; % string =&gt; Error_monad.ok I_CAST
  | &quot;RENAME&quot; % string =&gt; Error_monad.ok I_RENAME
  | &quot;DIG&quot; % string =&gt; Error_monad.ok I_DIG
  | &quot;DUG&quot; % string =&gt; Error_monad.ok I_DUG
  | &quot;bool&quot; % string =&gt; Error_monad.ok T_bool
  | &quot;contract&quot; % string =&gt; Error_monad.ok T_contract
  | &quot;int&quot; % string =&gt; Error_monad.ok T_int
  | &quot;key&quot; % string =&gt; Error_monad.ok T_key
  | &quot;key_hash&quot; % string =&gt; Error_monad.ok T_key_hash
  | &quot;lambda&quot; % string =&gt; Error_monad.ok T_lambda
  | &quot;list&quot; % string =&gt; Error_monad.ok T_list
  | &quot;map&quot; % string =&gt; Error_monad.ok T_map
  | &quot;big_map&quot; % string =&gt; Error_monad.ok T_big_map
  | &quot;nat&quot; % string =&gt; Error_monad.ok T_nat
  | &quot;option&quot; % string =&gt; Error_monad.ok T_option
  | &quot;or&quot; % string =&gt; Error_monad.ok T_or
  | &quot;pair&quot; % string =&gt; Error_monad.ok T_pair
  | &quot;set&quot; % string =&gt; Error_monad.ok T_set
  | &quot;signature&quot; % string =&gt; Error_monad.ok T_signature
  | &quot;string&quot; % string =&gt; Error_monad.ok T_string
  | &quot;bytes&quot; % string =&gt; Error_monad.ok T_bytes
  | &quot;mutez&quot; % string =&gt; Error_monad.ok T_mutez
  | &quot;timestamp&quot; % string =&gt; Error_monad.ok T_timestamp
  | &quot;unit&quot; % string =&gt; Error_monad.ok T_unit
  | &quot;operation&quot; % string =&gt; Error_monad.ok T_operation
  | &quot;address&quot; % string =&gt; Error_monad.ok T_address
  | &quot;chain_id&quot; % string =&gt; Error_monad.ok T_chain_id
  | n =&gt;
    if valid_case n then
      Error_monad.__error_value extensible_type_value
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition prims_of_strings (expr : Micheline.canonical string)
  : Error_monad.tzresult (Micheline.canonical prim) :=
  let fix convert
    (function_parameter : Micheline.node Micheline.canonical_location string)
    {struct function_parameter}
    : Error_monad.tzresult (Micheline.node Micheline.canonical_location prim) :=
    match function_parameter with
    | Micheline.Int l x =&gt; Error_monad.ok (Micheline.Int l x)
    | Micheline.String l x =&gt; Error_monad.ok (Micheline.String l x)
    | Micheline.Bytes l x =&gt; Error_monad.ok (Micheline.Bytes l x)
    | Micheline.Prim loc prim args annot =&gt;
      Error_monad.op_gtgtquestion
        (Error_monad.record_trace extensible_type_value (prim_of_string prim))
        (fun prim =&gt;
          Error_monad.op_gtgtquestion
            (List.fold_left
              (fun acc =&gt;
                fun arg =&gt;
                  Error_monad.op_gtgtquestion acc
                    (fun args =&gt;
                      Error_monad.op_gtgtquestion (convert arg)
                        (fun arg =&gt; Error_monad.ok (cons arg args))))
              (Error_monad.ok []) args)
            (fun args =&gt;
              Error_monad.ok (Micheline.Prim 0 prim (List.rev args) annot)))
    | Micheline.Seq _ args =&gt;
      Error_monad.op_gtgtquestion
        (List.fold_left
          (fun acc =&gt;
            fun arg =&gt;
              Error_monad.op_gtgtquestion acc
                (fun args =&gt;
                  Error_monad.op_gtgtquestion (convert arg)
                    (fun arg =&gt; Error_monad.ok (cons arg args))))
          (Error_monad.ok []) args)
        (fun args =&gt; Error_monad.ok (Micheline.Seq 0 (List.rev args)))
    end in
  Error_monad.op_gtgtquestion (convert (Micheline.root expr))
    (fun expr =&gt; Error_monad.ok (Micheline.strip_locations expr)).

Definition strings_of_prims (expr : Micheline.canonical prim)
  : Micheline.canonical string :=
  let fix convert (function_parameter : Micheline.node Z prim)
    {struct function_parameter} : Micheline.node Z string :=
    match function_parameter with
    | Micheline.Int l x =&gt; Micheline.Int l x
    | Micheline.String l x =&gt; Micheline.String l x
    | Micheline.Bytes l x =&gt; Micheline.Bytes l x
    | Micheline.Prim _ prim args annot =&gt;
      let prim := string_of_prim prim in
      let args := List.map convert args in
      Micheline.Prim 0 prim args annot
    | Micheline.Seq _ args =&gt;
      let args := List.map convert args in
      Micheline.Seq 0 args
    end in
  Micheline.strip_locations (convert (Micheline.root expr)).

Definition prim_encoding : Data_encoding.encoding prim :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;michelson.v1.primitives&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.string_enum
      (cons (&quot;parameter&quot; % string, K_parameter)
        (cons (&quot;storage&quot; % string, K_storage)
          (cons (&quot;code&quot; % string, K_code)
            (cons (&quot;False&quot; % string, D_False)
              (cons (&quot;Elt&quot; % string, D_Elt)
                (cons (&quot;Left&quot; % string, D_Left)
                  (cons (&quot;None&quot; % string, D_None)
                    (cons (&quot;Pair&quot; % string, D_Pair)
                      (cons (&quot;Right&quot; % string, D_Right)
                        (cons (&quot;Some&quot; % string, D_Some)
                          (cons (&quot;True&quot; % string, D_True)
                            (cons (&quot;Unit&quot; % string, D_Unit)
                              (cons (&quot;PACK&quot; % string, I_PACK)
                                (cons (&quot;UNPACK&quot; % string, I_UNPACK)
                                  (cons (&quot;BLAKE2B&quot; % string, I_BLAKE2B)
                                    (cons (&quot;SHA256&quot; % string, I_SHA256)
                                      (cons (&quot;SHA512&quot; % string, I_SHA512)
                                        (cons (&quot;ABS&quot; % string, I_ABS)
                                          (cons (&quot;ADD&quot; % string, I_ADD)
                                            (cons (&quot;AMOUNT&quot; % string, I_AMOUNT)
                                              (cons (&quot;AND&quot; % string, I_AND)
                                                (cons
                                                  (&quot;BALANCE&quot; % string, I_BALANCE)
                                                  (cons (&quot;CAR&quot; % string, I_CAR)
                                                    (cons
                                                      (&quot;CDR&quot; % string, I_CDR)
                                                      (cons
                                                        (&quot;CHECK_SIGNATURE&quot; %
                                                          string,
                                                          I_CHECK_SIGNATURE)
                                                        (cons
                                                          (&quot;COMPARE&quot; % string,
                                                            I_COMPARE)
                                                          (cons
                                                            (&quot;CONCAT&quot; % string,
                                                              I_CONCAT)
                                                            (cons
                                                              (&quot;CONS&quot; % string,
                                                                I_CONS)
                                                              (cons
                                                                (&quot;CREATE_ACCOUNT&quot;
                                                                  % string,
                                                                  I_CREATE_ACCOUNT)
                                                                (cons
                                                                  (&quot;CREATE_CONTRACT&quot;
                                                                    % string,
                                                                    I_CREATE_CONTRACT)
                                                                  (cons
                                                                    (&quot;IMPLICIT_ACCOUNT&quot;
                                                                      % string,
                                                                      I_IMPLICIT_ACCOUNT)
                                                                    (cons
                                                                      (&quot;DIP&quot; %
                                                                        string,
                                                                        I_DIP)
                                                                      (cons
                                                                        (&quot;DROP&quot;
                                                                          %
                                                                          string,
                                                                          I_DROP)
                                                                        (cons
                                                                          (&quot;DUP&quot;
                                                                            %
                                                                            string,
                                                                            I_DUP)
                                                                          (cons
                                                                            (&quot;EDIV&quot;
                                                                              %
                                                                              string,
                                                                              I_EDIV)
                                                                            (cons
                                                                              (&quot;EMPTY_MAP&quot;
                                                                                %
                                                                                string,
                                                                                I_EMPTY_MAP)
                                                                              (cons
                                                                                (&quot;EMPTY_SET&quot;
                                                                                  %
                                                                                  string,
                                                                                  I_EMPTY_SET)
                                                                                (cons
                                                                                  (&quot;EQ&quot;
                                                                                    %
                                                                                    string,
                                                                                    I_EQ)
                                                                                  (cons
                                                                                    (&quot;EXEC&quot;
                                                                                      %
                                                                                      string,
                                                                                      I_EXEC)
                                                                                    (cons
                                                                                      (&quot;FAILWITH&quot;
                                                                                        %
                                                                                        string,
                                                                                        I_FAILWITH)
                                                                                      (cons
                                                                                        (&quot;GE&quot;
                                                                                          %
                                                                                          string,
                                                                                          I_GE)
                                                                                        (cons
                                                                                          (&quot;GET&quot;
                                                                                            %
                                                                                            string,
                                                                                            I_GET)
                                                                                          (cons
                                                                                            (&quot;GT&quot;
                                                                                              %
                                                                                              string,
                                                                                              I_GT)
                                                                                            (cons
                                                                                              (&quot;HASH_KEY&quot;
                                                                                                %
                                                                                                string,
                                                                                                I_HASH_KEY)
                                                                                              (cons
                                                                                                (&quot;IF&quot;
                                                                                                  %
                                                                                                  string,
                                                                                                  I_IF)
                                                                                                (cons
                                                                                                  (&quot;IF_CONS&quot;
                                                                                                    %
                                                                                                    string,
                                                                                                    I_IF_CONS)
                                                                                                  (cons
                                                                                                    (&quot;IF_LEFT&quot;
                                                                                                      %
                                                                                                      string,
                                                                                                      I_IF_LEFT)
                                                                                                    (cons
                                                                                                      (&quot;IF_NONE&quot;
                                                                                                        %
                                                                                                        string,
                                                                                                        I_IF_NONE)
                                                                                                      (cons
                                                                                                        (&quot;INT&quot;
                                                                                                          %
                                                                                                          string,
                                                                                                          I_INT)
                                                                                                        (cons
                                                                                                          (&quot;LAMBDA&quot;
                                                                                                            %
                                                                                                            string,
                                                                                                            I_LAMBDA)
                                                                                                          (cons
                                                                                                            (&quot;LE&quot;
                                                                                                              %
                                                                                                              string,
                                                                                                              I_LE)
                                                                                                            (cons
                                                                                                              (&quot;LEFT&quot;
                                                                                                                %
                                                                                                                string,
                                                                                                                I_LEFT)
                                                                                                              (cons
                                                                                                                (&quot;LOOP&quot;
                                                                                                                  %
                                                                                                                  string,
                                                                                                                  I_LOOP)
                                                                                                                (cons
                                                                                                                  (&quot;LSL&quot;
                                                                                                                    %
                                                                                                                    string,
                                                                                                                    I_LSL)
                                                                                                                  (cons
                                                                                                                    (&quot;LSR&quot;
                                                                                                                      %
                                                                                                                      string,
                                                                                                                      I_LSR)
                                                                                                                    (cons
                                                                                                                      (&quot;LT&quot;
                                                                                                                        %
                                                                                                                        string,
                                                                                                                        I_LT)
                                                                                                                      (cons
                                                                                                                        (&quot;MAP&quot;
                                                                                                                          %
                                                                                                                          string,
                                                                                                                          I_MAP)
                                                                                                                        (cons
                                                                                                                          (&quot;MEM&quot;
                                                                                                                            %
                                                                                                                            string,
                                                                                                                            I_MEM)
                                                                                                                          (cons
                                                                                                                            (&quot;MUL&quot;
                                                                                                                              %
                                                                                                                              string,
                                                                                                                              I_MUL)
                                                                                                                            (cons
                                                                                                                              (&quot;NEG&quot;
                                                                                                                                %
                                                                                                                                string,
                                                                                                                                I_NEG)
                                                                                                                              (cons
                                                                                                                                (&quot;NEQ&quot;
                                                                                                                                  %
                                                                                                                                  string,
                                                                                                                                  I_NEQ)
                                                                                                                                (cons
                                                                                                                                  (&quot;NIL&quot;
                                                                                                                                    %
                                                                                                                                    string,
                                                                                                                                    I_NIL)
                                                                                                                                  (cons
                                                                                                                                    (&quot;NONE&quot;
                                                                                                                                      %
                                                                                                                                      string,
                                                                                                                                      I_NONE)
                                                                                                                                    (cons
                                                                                                                                      (&quot;NOT&quot;
                                                                                                                                        %
                                                                                                                                        string,
                                                                                                                                        I_NOT)
                                                                                                                                      (cons
                                                                                                                                        (&quot;NOW&quot;
                                                                                                                                          %
                                                                                                                                          string,
                                                                                                                                          I_NOW)
                                                                                                                                        (cons
                                                                                                                                          (&quot;OR&quot;
                                                                                                                                            %
                                                                                                                                            string,
                                                                                                                                            I_OR)
                                                                                                                                          (cons
                                                                                                                                            (&quot;PAIR&quot;
                                                                                                                                              %
                                                                                                                                              string,
                                                                                                                                              I_PAIR)
                                                                                                                                            (cons
                                                                                                                                              (&quot;PUSH&quot;
                                                                                                                                                %
                                                                                                                                                string,
                                                                                                                                                I_PUSH)
                                                                                                                                              (cons
                                                                                                                                                (&quot;RIGHT&quot;
                                                                                                                                                  %
                                                                                                                                                  string,
                                                                                                                                                  I_RIGHT)
                                                                                                                                                (cons
                                                                                                                                                  (&quot;SIZE&quot;
                                                                                                                                                    %
                                                                                                                                                    string,
                                                                                                                                                    I_SIZE)
                                                                                                                                                  (cons
                                                                                                                                                    (&quot;SOME&quot;
                                                                                                                                                      %
                                                                                                                                                      string,
                                                                                                                                                      I_SOME)
                                                                                                                                                    (cons
                                                                                                                                                      (&quot;SOURCE&quot;
                                                                                                                                                        %
                                                                                                                                                        string,
                                                                                                                                                        I_SOURCE)
                                                                                                                                                      (cons
                                                                                                                                                        (&quot;SENDER&quot;
                                                                                                                                                          %
                                                                                                                                                          string,
                                                                                                                                                          I_SENDER)
                                                                                                                                                        (cons
                                                                                                                                                          (&quot;SELF&quot;
                                                                                                                                                            %
                                                                                                                                                            string,
                                                                                                                                                            I_SELF)
                                                                                                                                                          (cons
                                                                                                                                                            (&quot;STEPS_TO_QUOTA&quot;
                                                                                                                                                              %
                                                                                                                                                              string,
                                                                                                                                                              I_STEPS_TO_QUOTA)
                                                                                                                                                            (cons
                                                                                                                                                              (&quot;SUB&quot;
                                                                                                                                                                %
                                                                                                                                                                string,
                                                                                                                                                                I_SUB)
                                                                                                                                                              (cons
                                                                                                                                                                (&quot;SWAP&quot;
                                                                                                                                                                  %
                                                                                                                                                                  string,
                                                                                                                                                                  I_SWAP)
                                                                                                                                                                (cons
                                                                                                                                                                  (&quot;TRANSFER_TOKENS&quot;
                                                                                                                                                                    %
                                                                                                                                                                    string,
                                                                                                                                                                    I_TRANSFER_TOKENS)
                                                                                                                                                                  (cons
                                                                                                                                                                    (&quot;SET_DELEGATE&quot;
                                                                                                                                                                      %
                                                                                                                                                                      string,
                                                                                                                                                                      I_SET_DELEGATE)
                                                                                                                                                                    (cons
                                                                                                                                                                      (&quot;UNIT&quot;
                                                                                                                                                                        %
                                                                                                                                                                        string,
                                                                                                                                                                        I_UNIT)
                                                                                                                                                                      (cons
                                                                                                                                                                        (&quot;UPDATE&quot;
                                                                                                                                                                          %
                                                                                                                                                                          string,
                                                                                                                                                                          I_UPDATE)
                                                                                                                                                                        (cons
                                                                                                                                                                          (&quot;XOR&quot;
                                                                                                                                                                            %
                                                                                                                                                                            string,
                                                                                                                                                                            I_XOR)
                                                                                                                                                                          (cons
                                                                                                                                                                            (&quot;ITER&quot;
                                                                                                                                                                              %
                                                                                                                                                                              string,
                                                                                                                                                                              I_ITER)
                                                                                                                                                                            (cons
                                                                                                                                                                              (&quot;LOOP_LEFT&quot;
                                                                                                                                                                                %
                                                                                                                                                                                string,
                                                                                                                                                                                I_LOOP_LEFT)
                                                                                                                                                                              (cons
                                                                                                                                                                                (&quot;ADDRESS&quot;
                                                                                                                                                                                  %
                                                                                                                                                                                  string,
                                                                                                                                                                                  I_ADDRESS)
                                                                                                                                                                                (cons
                                                                                                                                                                                  (&quot;CONTRACT&quot;
                                                                                                                                                                                    %
                                                                                                                                                                                    string,
                                                                                                                                                                                    I_CONTRACT)
                                                                                                                                                                                  (cons
                                                                                                                                                                                    (&quot;ISNAT&quot;
                                                                                                                                                                                      %
                                                                                                                                                                                      string,
                                                                                                                                                                                      I_ISNAT)
                                                                                                                                                                                    (cons
                                                                                                                                                                                      (&quot;CAST&quot;
                                                                                                                                                                                        %
                                                                                                                                                                                        string,
                                                                                                                                                                                        I_CAST)
                                                                                                                                                                                      (cons
                                                                                                                                                                                        (&quot;RENAME&quot;
                                                                                                                                                                                          %
                                                                                                                                                                                          string,
                                                                                                                                                                                          I_RENAME)
                                                                                                                                                                                        (cons
                                                                                                                                                                                          (&quot;bool&quot;
                                                                                                                                                                                            %
                                                                                                                                                                                            string,
                                                                                                                                                                                            T_bool)
                                                                                                                                                                                          (cons
                                                                                                                                                                                            (&quot;contract&quot;
                                                                                                                                                                                              %
                                                                                                                                                                                              string,
                                                                                                                                                                                              T_contract)
                                                                                                                                                                                            (cons
                                                                                                                                                                                              (&quot;int&quot;
                                                                                                                                                                                                %
                                                                                                                                                                                                string,
                                                                                                                                                                                                T_int)
                                                                                                                                                                                              (cons
                                                                                                                                                                                                (&quot;key&quot;
                                                                                                                                                                                                  %
                                                                                                                                                                                                  string,
                                                                                                                                                                                                  T_key)
                                                                                                                                                                                                (cons
                                                                                                                                                                                                  (&quot;key_hash&quot;
                                                                                                                                                                                                    %
                                                                                                                                                                                                    string,
                                                                                                                                                                                                    T_key_hash)
                                                                                                                                                                                                  (cons
                                                                                                                                                                                                    (&quot;lambda&quot;
                                                                                                                                                                                                      %
                                                                                                                                                                                                      string,
                                                                                                                                                                                                      T_lambda)
                                                                                                                                                                                                    (cons
                                                                                                                                                                                                      (&quot;list&quot;
                                                                                                                                                                                                        %
                                                                                                                                                                                                        string,
                                                                                                                                                                                                        T_list)
                                                                                                                                                                                                      (cons
                                                                                                                                                                                                        (&quot;map&quot;
                                                                                                                                                                                                          %
                                                                                                                                                                                                          string,
                                                                                                                                                                                                          T_map)
                                                                                                                                                                                                        (cons
                                                                                                                                                                                                          (&quot;big_map&quot;
                                                                                                                                                                                                            %
                                                                                                                                                                                                            string,
                                                                                                                                                                                                            T_big_map)
                                                                                                                                                                                                          (cons
                                                                                                                                                                                                            (&quot;nat&quot;
                                                                                                                                                                                                              %
                                                                                                                                                                                                              string,
                                                                                                                                                                                                              T_nat)
                                                                                                                                                                                                            (cons
                                                                                                                                                                                                              (&quot;option&quot;
                                                                                                                                                                                                                %
                                                                                                                                                                                                                string,
                                                                                                                                                                                                                T_option)
                                                                                                                                                                                                              (cons
                                                                                                                                                                                                                (&quot;or&quot;
                                                                                                                                                                                                                  %
                                                                                                                                                                                                                  string,
                                                                                                                                                                                                                  T_or)
                                                                                                                                                                                                                (cons
                                                                                                                                                                                                                  (&quot;pair&quot;
                                                                                                                                                                                                                    %
                                                                                                                                                                                                                    string,
                                                                                                                                                                                                                    T_pair)
                                                                                                                                                                                                                  (cons
                                                                                                                                                                                                                    (&quot;set&quot;
                                                                                                                                                                                                                      %
                                                                                                                                                                                                                      string,
                                                                                                                                                                                                                      T_set)
                                                                                                                                                                                                                    (cons
                                                                                                                                                                                                                      (&quot;signature&quot;
                                                                                                                                                                                                                        %
                                                                                                                                                                                                                        string,
                                                                                                                                                                                                                        T_signature)
                                                                                                                                                                                                                      (cons
                                                                                                                                                                                                                        (&quot;string&quot;
                                                                                                                                                                                                                          %
                                                                                                                                                                                                                          string,
                                                                                                                                                                                                                          T_string)
                                                                                                                                                                                                                        (cons
                                                                                                                                                                                                                          (&quot;bytes&quot;
                                                                                                                                                                                                                            %
                                                                                                                                                                                                                            string,
                                                                                                                                                                                                                            T_bytes)
                                                                                                                                                                                                                          (cons
                                                                                                                                                                                                                            (&quot;mutez&quot;
                                                                                                                                                                                                                              %
                                                                                                                                                                                                                              string,
                                                                                                                                                                                                                              T_mutez)
                                                                                                                                                                                                                            (cons
                                                                                                                                                                                                                              (&quot;timestamp&quot;
                                                                                                                                                                                                                                %
                                                                                                                                                                                                                                string,
                                                                                                                                                                                                                                T_timestamp)
                                                                                                                                                                                                                              (cons
                                                                                                                                                                                                                                (&quot;unit&quot;
                                                                                                                                                                                                                                  %
                                                                                                                                                                                                                                  string,
                                                                                                                                                                                                                                  T_unit)
                                                                                                                                                                                                                                (cons
                                                                                                                                                                                                                                  (&quot;operation&quot;
                                                                                                                                                                                                                                    %
                                                                                                                                                                                                                                    string,
                                                                                                                                                                                                                                    T_operation)
                                                                                                                                                                                                                                  (cons
                                                                                                                                                                                                                                    (&quot;address&quot;
                                                                                                                                                                                                                                      %
                                                                                                                                                                                                                                      string,
                                                                                                                                                                                                                                      T_address)
                                                                                                                                                                                                                                    (cons
                                                                                                                                                                                                                                      (&quot;SLICE&quot;
                                                                                                                                                                                                                                        %
                                                                                                                                                                                                                                        string,
                                                                                                                                                                                                                                        I_SLICE)
                                                                                                                                                                                                                                      (cons
                                                                                                                                                                                                                                        (&quot;DIG&quot;
                                                                                                                                                                                                                                          %
                                                                                                                                                                                                                                          string,
                                                                                                                                                                                                                                          I_DIG)
                                                                                                                                                                                                                                        (cons
                                                                                                                                                                                                                                          (&quot;DUG&quot;
                                                                                                                                                                                                                                            %
                                                                                                                                                                                                                                            string,
                                                                                                                                                                                                                                            I_DUG)
                                                                                                                                                                                                                                          (cons
                                                                                                                                                                                                                                            (&quot;EMPTY_BIG_MAP&quot;
                                                                                                                                                                                                                                              %
                                                                                                                                                                                                                                              string,
                                                                                                                                                                                                                                              I_EMPTY_BIG_MAP)
                                                                                                                                                                                                                                            (cons
                                                                                                                                                                                                                                              (&quot;APPLY&quot;
                                                                                                                                                                                                                                                %
                                                                                                                                                                                                                                                string,
                                                                                                                                                                                                                                                I_APPLY)
                                                                                                                                                                                                                                              (cons
                                                                                                                                                                                                                                                (&quot;chain_id&quot;
                                                                                                                                                                                                                                                  %
                                                                                                                                                                                                                                                  string,
                                                                                                                                                                                                                                                  T_chain_id)
                                                                                                                                                                                                                                                (cons
                                                                                                                                                                                                                                                  (&quot;CHAIN_ID&quot;
                                                                                                                                                                                                                                                    %
                                                                                                                                                                                                                                                    string,
                                                                                                                                                                                                                                                    I_CHAIN_ID)
                                                                                                                                                                                                                                                  []))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))).

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_primitives.mli">
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.mli"><code>michelson_v1_primitives.mli</code></a>&nbsp;<span class="label label-danger">3 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Unknown_primitive_name of string</abbr> (* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_case of string</abbr> (* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Invalid_primitive_name of
      string Micheline.canonical * Micheline.canonical_location</abbr>

(* `Permanent *)

type prim =
  | K_parameter
  | K_storage
  | K_code
  | D_False
  | D_Elt
  | D_Left
  | D_None
  | D_Pair
  | D_Right
  | D_Some
  | D_True
  | D_Unit
  | I_PACK
  | I_UNPACK
  | I_BLAKE2B
  | I_SHA256
  | I_SHA512
  | I_ABS
  | I_ADD
  | I_AMOUNT
  | I_AND
  | I_BALANCE
  | I_CAR
  | I_CDR
  | I_CHAIN_ID
  | I_CHECK_SIGNATURE
  | I_COMPARE
  | I_CONCAT
  | I_CONS
  | I_CREATE_ACCOUNT
  | I_CREATE_CONTRACT
  | I_IMPLICIT_ACCOUNT
  | I_DIP
  | I_DROP
  | I_DUP
  | I_EDIV
  | I_EMPTY_BIG_MAP
  | I_EMPTY_MAP
  | I_EMPTY_SET
  | I_EQ
  | I_EXEC
  | I_APPLY
  | I_FAILWITH
  | I_GE
  | I_GET
  | I_GT
  | I_HASH_KEY
  | I_IF
  | I_IF_CONS
  | I_IF_LEFT
  | I_IF_NONE
  | I_INT
  | I_LAMBDA
  | I_LE
  | I_LEFT
  | I_LOOP
  | I_LSL
  | I_LSR
  | I_LT
  | I_MAP
  | I_MEM
  | I_MUL
  | I_NEG
  | I_NEQ
  | I_NIL
  | I_NONE
  | I_NOT
  | I_NOW
  | I_OR
  | I_PAIR
  | I_PUSH
  | I_RIGHT
  | I_SIZE
  | I_SOME
  | I_SOURCE
  | I_SENDER
  | I_SELF
  | I_SLICE
  | I_STEPS_TO_QUOTA
  | I_SUB
  | I_SWAP
  | I_TRANSFER_TOKENS
  | I_SET_DELEGATE
  | I_UNIT
  | I_UPDATE
  | I_XOR
  | I_ITER
  | I_LOOP_LEFT
  | I_ADDRESS
  | I_CONTRACT
  | I_ISNAT
  | I_CAST
  | I_RENAME
  | I_DIG
  | I_DUG
  | T_bool
  | T_contract
  | T_int
  | T_key
  | T_key_hash
  | T_lambda
  | T_list
  | T_map
  | T_big_map
  | T_nat
  | T_option
  | T_or
  | T_pair
  | T_set
  | T_signature
  | T_string
  | T_bytes
  | T_mutez
  | T_timestamp
  | T_unit
  | T_operation
  | T_address
  | T_chain_id

val prim_encoding : prim Data_encoding.encoding

val string_of_prim : prim -&gt; string

val prim_of_string : string -&gt; prim tzresult

val prims_of_strings :
  string Micheline.canonical -&gt; prim Micheline.canonical tzresult

val strings_of_prims : prim Micheline.canonical -&gt; string Micheline.canonical
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.mli"><code>Michelson_v1_primitives_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Inductive prim : Set :=
| K_parameter : prim
| K_storage : prim
| K_code : prim
| D_False : prim
| D_Elt : prim
| D_Left : prim
| D_None : prim
| D_Pair : prim
| D_Right : prim
| D_Some : prim
| D_True : prim
| D_Unit : prim
| I_PACK : prim
| I_UNPACK : prim
| I_BLAKE2B : prim
| I_SHA256 : prim
| I_SHA512 : prim
| I_ABS : prim
| I_ADD : prim
| I_AMOUNT : prim
| I_AND : prim
| I_BALANCE : prim
| I_CAR : prim
| I_CDR : prim
| I_CHAIN_ID : prim
| I_CHECK_SIGNATURE : prim
| I_COMPARE : prim
| I_CONCAT : prim
| I_CONS : prim
| I_CREATE_ACCOUNT : prim
| I_CREATE_CONTRACT : prim
| I_IMPLICIT_ACCOUNT : prim
| I_DIP : prim
| I_DROP : prim
| I_DUP : prim
| I_EDIV : prim
| I_EMPTY_BIG_MAP : prim
| I_EMPTY_MAP : prim
| I_EMPTY_SET : prim
| I_EQ : prim
| I_EXEC : prim
| I_APPLY : prim
| I_FAILWITH : prim
| I_GE : prim
| I_GET : prim
| I_GT : prim
| I_HASH_KEY : prim
| I_IF : prim
| I_IF_CONS : prim
| I_IF_LEFT : prim
| I_IF_NONE : prim
| I_INT : prim
| I_LAMBDA : prim
| I_LE : prim
| I_LEFT : prim
| I_LOOP : prim
| I_LSL : prim
| I_LSR : prim
| I_LT : prim
| I_MAP : prim
| I_MEM : prim
| I_MUL : prim
| I_NEG : prim
| I_NEQ : prim
| I_NIL : prim
| I_NONE : prim
| I_NOT : prim
| I_NOW : prim
| I_OR : prim
| I_PAIR : prim
| I_PUSH : prim
| I_RIGHT : prim
| I_SIZE : prim
| I_SOME : prim
| I_SOURCE : prim
| I_SENDER : prim
| I_SELF : prim
| I_SLICE : prim
| I_STEPS_TO_QUOTA : prim
| I_SUB : prim
| I_SWAP : prim
| I_TRANSFER_TOKENS : prim
| I_SET_DELEGATE : prim
| I_UNIT : prim
| I_UPDATE : prim
| I_XOR : prim
| I_ITER : prim
| I_LOOP_LEFT : prim
| I_ADDRESS : prim
| I_CONTRACT : prim
| I_ISNAT : prim
| I_CAST : prim
| I_RENAME : prim
| I_DIG : prim
| I_DUG : prim
| T_bool : prim
| T_contract : prim
| T_int : prim
| T_key : prim
| T_key_hash : prim
| T_lambda : prim
| T_list : prim
| T_map : prim
| T_big_map : prim
| T_nat : prim
| T_option : prim
| T_or : prim
| T_pair : prim
| T_set : prim
| T_signature : prim
| T_string : prim
| T_bytes : prim
| T_mutez : prim
| T_timestamp : prim
| T_unit : prim
| T_operation : prim
| T_address : prim
| T_chain_id : prim.

Parameter prim_encoding : Data_encoding.encoding prim.

Parameter string_of_prim : prim -&gt; string.

Parameter prim_of_string : string -&gt; Error_monad.tzresult prim.

Parameter prims_of_strings :
  Micheline.canonical string -&gt; Error_monad.tzresult (Micheline.canonical prim).

Parameter strings_of_prims :
  Micheline.canonical prim -&gt; Micheline.canonical string.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="misc.ml">
  <div class="col-md-6">
    <a href="#misc.ml"><code>misc.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type 'a lazyt = unit -&gt; 'a

type 'a lazy_list_t = LCons of 'a * 'a lazy_list_t tzresult Lwt.t lazyt

type 'a lazy_list = 'a lazy_list_t tzresult Lwt.t

let rec ( --&gt; ) i j =
  (* [i; i+1; ...; j] *)
  if Compare.Int.(i &gt; j) then [] else i :: (succ i --&gt; j)

let rec ( ---&gt; ) i j =
  (* [i; i+1; ...; j] *)
  if Compare.Int32.(i &gt; j) then [] else i :: (Int32.succ i ---&gt; j)

let rec do_slashes delim path l acc limit i =
  if Compare.Int.(i &gt;= l) then List.rev acc
  else if Compare.Char.(path.[i] = delim) then
    do_slashes delim path l acc limit (i + 1)
  else do_split delim path l acc limit i

and do_split delim path l acc limit i =
  if Compare.Int.(limit &lt;= 0) then
    if Compare.Int.(i = l) then List.rev acc
    else List.rev (String.sub path i (l - i) :: acc)
  else do_component delim path l acc (pred limit) i i

and do_component delim path l acc limit i j =
  if Compare.Int.(j &gt;= l) then
    if Compare.Int.(i = j) then List.rev acc
    else List.rev (String.sub path i (j - i) :: acc)
  else if Compare.Char.(path.[j] = delim) then
    do_slashes delim path l (String.sub path i (j - i) :: acc) limit j
  else do_component delim path l acc limit i (j + 1)

let split delim ?(limit = max_int) path =
  let l = String.length path in
  if Compare.Int.(limit &gt; 0) then do_slashes delim path l [] limit 0 else [path]

let pp_print_paragraph ppf description =
  Format.fprintf
    ppf
    &quot;@[%a@]&quot;
    Format.(pp_print_list ~pp_sep:pp_print_space pp_print_string)
    (split ' ' description)

let take n l =
  let rec loop acc n xs =
    if Compare.Int.(n &lt;= 0) then
      Some (List.rev acc, xs)
    else
      match xs with
      | [] -&gt;
          None
      | x :: xs -&gt;
          loop (x :: acc) (n - 1) xs
  in
  loop [] n l

let remove_prefix ~prefix s =
  let x = String.length prefix in
  let n = String.length s in
  if Compare.Int.(n &gt;= x) &amp;&amp; Compare.String.(String.sub s 0 x = prefix) then
    Some (String.sub s x (n - x))
  else None

let rec remove_elem_from_list nb = function
  | [] -&gt;
      []
  | (_ :: _) as l when Compare.Int.(nb &lt;= 0) -&gt;
      l
  | _ :: tl -&gt;
      remove_elem_from_list (nb - 1) tl
</pre>
  </div>
  <div class="col-md-6">
    <a href="#misc.ml"><code>Misc.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition lazyt (a : Set) := unit -&gt; a.

Inductive lazy_list_t (a : Set) : Set :=
| LCons :
  a -&gt; lazyt (Lwt.t (Error_monad.tzresult (lazy_list_t a))) -&gt; lazy_list_t a.

Arguments LCons {_}.

Definition lazy_list (a : Set) := Lwt.t (Error_monad.tzresult (lazy_list_t a)).

Fixpoint op_minusminusgt
  (i : Compare.Int.[Compare.S.t]) (j : Compare.Int.[Compare.S.t]) {struct i}
  : list Compare.Int.[Compare.S.t] :=
  if Compare.Int.[Compare.S.op_gt] i j then
    []
  else
    cons i (op_minusminusgt (Pervasives.succ i) j).

Fixpoint op_minusminusminusgt
  (i : Compare.Int32.[Compare.S.t]) (j : Compare.Int32.[Compare.S.t]) {struct i}
  : list Compare.Int32.[Compare.S.t] :=
  if Compare.Int32.[Compare.S.op_gt] i j then
    []
  else
    cons i (op_minusminusminusgt (Int32.succ i) j).

Fixpoint do_slashes
  (delim : Compare.Char.[Compare.S.t]) (path : string)
  (l : Compare.Int.[Compare.S.t]) (acc : list string)
  (limit : Compare.Int.[Compare.S.t]) (i : Compare.Int.[Compare.S.t])
  {struct delim} : list string :=
  if Compare.Int.[Compare.S.op_gteq] i l then
    List.rev acc
  else
    if Compare.Char.[Compare.S.op_eq] (String.get path i) delim then
      do_slashes delim path l acc limit (Pervasives.op_plus i 1)
    else
      do_split delim path l acc limit i

with do_split
  (delim : Compare.Char.[Compare.S.t]) (path : string)
  (l : Compare.Int.[Compare.S.t]) (acc : list string)
  (limit : Compare.Int.[Compare.S.t]) (i : Compare.Int.[Compare.S.t])
  {struct delim} : list string :=
  if Compare.Int.[Compare.S.op_lteq] limit 0 then
    if Compare.Int.[Compare.S.op_eq] i l then
      List.rev acc
    else
      List.rev (cons (String.sub path i (Pervasives.op_minus l i)) acc)
  else
    do_component delim path l acc (Pervasives.pred limit) i i

with do_component
  (delim : Compare.Char.[Compare.S.t]) (path : string)
  (l : Compare.Int.[Compare.S.t]) (acc : list string)
  (limit : Compare.Int.[Compare.S.t]) (i : Compare.Int.[Compare.S.t])
  (j : Compare.Int.[Compare.S.t]) {struct delim} : list string :=
  if Compare.Int.[Compare.S.op_gteq] j l then
    if Compare.Int.[Compare.S.op_eq] i j then
      List.rev acc
    else
      List.rev (cons (String.sub path i (Pervasives.op_minus j i)) acc)
  else
    if Compare.Char.[Compare.S.op_eq] (String.get path j) delim then
      do_slashes delim path l
        (cons (String.sub path i (Pervasives.op_minus j i)) acc) limit j
    else
      do_component delim path l acc limit i (Pervasives.op_plus j 1).

Definition split
  (delim : Compare.Char.[Compare.S.t])
  (op_staroptstar : option Compare.Int.[Compare.S.t]) : string -&gt; list string :=
  let limit :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; Pervasives.max_int
    end in
  fun path =&gt;
    let l := String.length path in
    if Compare.Int.[Compare.S.op_gt] limit 0 then
      do_slashes delim path l [] limit 0
    else
      cons path [].

Definition pp_print_paragraph (ppf : Format.formatter) (description : string)
  : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Formatting_gen
        (CamlinternalFormatBasics.Open_box
          (CamlinternalFormatBasics.Format
            CamlinternalFormatBasics.End_of_format &quot;&quot; % string))
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.Formatting_lit
            CamlinternalFormatBasics.Close_box
            CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot; % string)
    (Format.pp_print_list (Some Format.pp_print_space) Format.pp_print_string)
    (split &quot; &quot; % char None description).

Definition take {A : Set} (n : Compare.Int.[Compare.S.t]) (l : list A)
  : option (list A * list A) :=
  let fix loop {B : Set}
    (acc : list B) (n : Compare.Int.[Compare.S.t]) (xs : list B) {struct acc}
    : option (list B * list B) :=
    if Compare.Int.[Compare.S.op_lteq] n 0 then
      Some ((List.rev acc), xs)
    else
      match xs with
      | [] =&gt; None
      | cons x xs =&gt; loop (cons x acc) (Pervasives.op_minus n 1) xs
      end in
  loop [] n l.

Definition remove_prefix (prefix : Compare.String.[Compare.S.t]) (s : string)
  : option string :=
  let x := String.length prefix in
  let n := String.length s in
  if
    Pervasives.op_andand (Compare.Int.[Compare.S.op_gteq] n x)
      (Compare.String.[Compare.S.op_eq] (String.sub s 0 x) prefix) then
    Some (String.sub s x (Pervasives.op_minus n x))
  else
    None.

Fixpoint remove_elem_from_list {A : Set}
  (nb : Compare.Int.[Compare.S.t]) (function_parameter : list A) {struct nb}
  : list A :=
  match
    (function_parameter,
      match function_parameter with
      | (cons _ _) as l =&gt; Compare.Int.[Compare.S.op_lteq] nb 0
      | _ =&gt; false
      end) with
  | ([], _) =&gt; []
  | ((cons _ _) as l, true) =&gt; l
  | (cons _ tl, _) =&gt; remove_elem_from_list (Pervasives.op_minus nb 1) tl
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="misc.mli">
  <div class="col-md-6">
    <a href="#misc.mli"><code>misc.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** {2 Helper functions} *)

type 'a lazyt = unit -&gt; 'a

type 'a lazy_list_t = LCons of 'a * 'a lazy_list_t tzresult Lwt.t lazyt

type 'a lazy_list = 'a lazy_list_t tzresult Lwt.t

(** Include bounds *)
val ( --&gt; ) : int -&gt; int -&gt; int list

val ( ---&gt; ) : Int32.t -&gt; Int32.t -&gt; Int32.t list

val pp_print_paragraph : Format.formatter -&gt; string -&gt; unit

val take : int -&gt; 'a list -&gt; ('a list * 'a list) option

(** Some (input with [prefix] removed), if string has [prefix], else [None] *)
val remove_prefix : prefix:string -&gt; string -&gt; string option

(** [remove nb list] remove the first [nb] elements from the list [list]. *)
val remove_elem_from_list : int -&gt; 'a list -&gt; 'a list
</pre>
  </div>
  <div class="col-md-6">
    <a href="#misc.mli"><code>Misc_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition lazyt (a : Set) := unit -&gt; a.

Inductive lazy_list_t (a : Set) : Set :=
| LCons :
  a -&gt; lazyt (Lwt.t (Error_monad.tzresult (lazy_list_t a))) -&gt; lazy_list_t a.

Arguments LCons {_}.

Definition lazy_list (a : Set) := Lwt.t (Error_monad.tzresult (lazy_list_t a)).

Parameter op_minusminusgt : Z -&gt; Z -&gt; list Z.

Parameter op_minusminusminusgt : Int32.t -&gt; Int32.t -&gt; list Int32.t.

Parameter pp_print_paragraph : Format.formatter -&gt; string -&gt; unit.

Parameter take : forall {a : Set}, Z -&gt; list a -&gt; option (list a * list a).

Parameter remove_prefix : string -&gt; string -&gt; option string.

Parameter remove_elem_from_list : forall {a : Set}, Z -&gt; list a -&gt; list a.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nonce_hash.ml">
  <div class="col-md-6">
    <a href="#nonce_hash.ml"><code>nonce_hash.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* 32 *)
let nonce_hash = &quot;\069\220\169&quot; (* nce(53) *)

module Blake2BModule = Blake2B.Make
          (Base58)
          (struct
            let name = &quot;cycle_nonce&quot;

            let title = &quot;A nonce hash&quot;

            let b58check_prefix = nonce_hash

            let size = None
          end)

include Blake2BModule

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () = Base58.check_encoded_prefix b58check_encoding &quot;nce&quot; 53</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nonce_hash.ml"><code>Nonce_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition nonce_hash : string := &quot;E\220\169&quot; % string.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT _ tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
        |}))
    (let name := &quot;cycle_nonce&quot; % string in
    let title := &quot;A nonce hash&quot; % string in
    let b58check_prefix := nonce_hash in
    let size := None in
    existT _ tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
        |}).

Definition t := Blake2BModule.[S.HASH.t].

Definition name := Blake2BModule.[S.HASH.name].

Definition title := Blake2BModule.[S.HASH.title].

Definition pp := Blake2BModule.[S.HASH.pp].

Definition pp_short := Blake2BModule.[S.HASH.pp_short].

Definition op_eq := Blake2BModule.[S.HASH.op_eq].

Definition op_ltgt := Blake2BModule.[S.HASH.op_ltgt].

Definition op_lt := Blake2BModule.[S.HASH.op_lt].

Definition op_lteq := Blake2BModule.[S.HASH.op_lteq].

Definition op_gteq := Blake2BModule.[S.HASH.op_gteq].

Definition op_gt := Blake2BModule.[S.HASH.op_gt].

Definition compare := Blake2BModule.[S.HASH.compare].

Definition equal := Blake2BModule.[S.HASH.equal].

Definition max := Blake2BModule.[S.HASH.max].

Definition min := Blake2BModule.[S.HASH.min].

Definition hash_bytes := Blake2BModule.[S.HASH.hash_bytes].

Definition hash_string := Blake2BModule.[S.HASH.hash_string].

Definition zero := Blake2BModule.[S.HASH.zero].

Definition size := Blake2BModule.[S.HASH.size].

Definition to_bytes := Blake2BModule.[S.HASH.to_bytes].

Definition of_bytes_opt := Blake2BModule.[S.HASH.of_bytes_opt].

Definition of_bytes_exn := Blake2BModule.[S.HASH.of_bytes_exn].

Definition to_b58check := Blake2BModule.[S.HASH.to_b58check].

Definition to_short_b58check := Blake2BModule.[S.HASH.to_short_b58check].

Definition of_b58check_exn := Blake2BModule.[S.HASH.of_b58check_exn].

Definition of_b58check_opt := Blake2BModule.[S.HASH.of_b58check_opt].

Definition b58check_encoding := Blake2BModule.[S.HASH.b58check_encoding].

Definition encoding := Blake2BModule.[S.HASH.encoding].

Definition rpc_arg := Blake2BModule.[S.HASH.rpc_arg].

Definition to_path := Blake2BModule.[S.HASH.to_path].

Definition of_path := Blake2BModule.[S.HASH.of_path].

Definition of_path_exn := Blake2BModule.[S.HASH.of_path_exn].

Definition prefix_path := Blake2BModule.[S.HASH.prefix_path].

Definition path_length := Blake2BModule.[S.HASH.path_length].

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nonce_storage.ml">
  <div class="col-md-6">
    <a href="#nonce_storage.ml"><code>nonce_storage.ml</code></a>&nbsp;<span class="label label-danger">7 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Seed_repr.nonce

type nonce = t

let encoding = Seed_repr.nonce_encoding

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Too_late_revelation
  | Too_early_revelation
  | Previously_revealed_nonce
  | Unexpected_nonce</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Branch
    ~id:&quot;nonce.too_late_revelation&quot;
    ~title:&quot;Too late nonce revelation&quot;
    ~description:&quot;Nonce revelation happens too late&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;This nonce cannot be revealed anymore.&quot;)
    Data_encoding.unit
    (function Too_late_revelation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_late_revelation) ;
  register_error_kind
    `Temporary
    ~id:&quot;nonce.too_early_revelation&quot;
    ~title:&quot;Too early nonce revelation&quot;
    ~description:&quot;Nonce revelation happens before cycle end&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;This nonce should not yet be revealed&quot;)
    Data_encoding.unit
    (function Too_early_revelation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_early_revelation) ;
  register_error_kind
    `Branch
    ~id:&quot;nonce.previously_revealed&quot;
    ~title:&quot;Previously revealed nonce&quot;
    ~description:&quot;Duplicated revelation for a nonce.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;This nonce was previously revealed&quot;)
    Data_encoding.unit
    (function Previously_revealed_nonce -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Previously_revealed_nonce) ;
  register_error_kind
    `Branch
    ~id:&quot;nonce.unexpected&quot;
    ~title:&quot;Unexpected nonce&quot;
    ~description:
      &quot;The provided nonce is inconsistent with the committed nonce hash.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;This nonce revelation is invalid (inconsistent with the committed \
         hash)&quot;)
    Data_encoding.unit
    (function Unexpected_nonce -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_nonce)</abbr>

(* checks that the level of a revelation is not too early or too late wrt to the
   current context and that a nonce has not been already revealed for that level *)
let get_unrevealed ctxt level =
  let cur_level = Level_storage.current ctxt in
  match Cycle_repr.pred cur_level.cycle with
  | None -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">Too_early_revelation</abbr> (* no revelations during cycle 0 *)
  | Some revealed_cycle -&gt; (
      if Cycle_repr.(revealed_cycle &lt; level.Level_repr.cycle) then
        fail <abbr class="mark-error" title="Values of extensible types are not handled">Too_early_revelation</abbr>
      else if Cycle_repr.(level.Level_repr.cycle &lt; revealed_cycle) then
        fail <abbr class="mark-error" title="Values of extensible types are not handled">Too_late_revelation</abbr>
      else
        Storage.Seed.Nonce.get ctxt level
        &gt;&gt;=? function
        | Revealed _ -&gt;
            fail <abbr class="mark-error" title="Values of extensible types are not handled">Previously_revealed_nonce</abbr>
        | Unrevealed status -&gt;
            return status )

let record_hash ctxt unrevealed =
  let level = Level_storage.current ctxt in
  Storage.Seed.Nonce.init ctxt level (Unrevealed unrevealed)

let reveal ctxt level nonce =
  get_unrevealed ctxt level
  &gt;&gt;=? fun unrevealed -&gt;
  fail_unless
    (Seed_repr.check_hash nonce unrevealed.nonce_hash)
    <abbr class="mark-error" title="Values of extensible types are not handled">Unexpected_nonce</abbr>
  &gt;&gt;=? fun () -&gt;
  Storage.Seed.Nonce.set ctxt level (Revealed nonce)
  &gt;&gt;=? fun ctxt -&gt; return ctxt

type unrevealed = Storage.Seed.unrevealed_nonce = {
  nonce_hash : Nonce_hash.t;
  delegate : Signature.Public_key_hash.t;
  rewards : Tez_repr.t;
  fees : Tez_repr.t;
}

type status = Storage.Seed.nonce_status =
  | Unrevealed of unrevealed
  | Revealed of Seed_repr.nonce

let get = Storage.Seed.Nonce.get

let of_bytes = Seed_repr.make_nonce

let hash = Seed_repr.hash

let check_hash = Seed_repr.check_hash
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nonce_storage.ml"><code>Nonce_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Storage.
Require Tezos.Tez_repr.

Definition t := Seed_repr.nonce.

Definition nonce := t.

Definition encoding : Data_encoding.t Seed_repr.nonce :=
  Seed_repr.nonce_encoding.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition get_unrevealed (ctxt : Raw_context.t) (level : Level_repr.t)
  : Lwt.t (Error_monad.tzresult Storage.Seed.unrevealed_nonce) :=
  let cur_level := Level_storage.current ctxt in
  match Cycle_repr.pred (Level_repr.t.cycle cur_level) with
  | None =&gt; Error_monad.fail extensible_type_value
  | Some revealed_cycle =&gt;
    if Cycle_repr.op_lt revealed_cycle (Level_repr.t.cycle level) then
      Error_monad.fail extensible_type_value
    else
      if Cycle_repr.op_lt (Level_repr.t.cycle level) revealed_cycle then
        Error_monad.fail extensible_type_value
      else
        Error_monad.op_gtgteqquestion (Storage.Seed.Nonce.get ctxt level)
          (fun function_parameter =&gt;
            match function_parameter with
            | Storage.Seed.Revealed _ =&gt; Error_monad.fail extensible_type_value
            | Storage.Seed.Unrevealed status =&gt; Error_monad.__return status
            end)
  end.

Definition record_hash
  (ctxt : Raw_context.t) (unrevealed : Storage.Seed.unrevealed_nonce)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let level := Level_storage.current ctxt in
  Storage.Seed.Nonce.init ctxt level (Storage.Seed.Unrevealed unrevealed).

Definition reveal
  (ctxt : Raw_context.t) (level : Level_repr.t) (nonce : Seed_repr.nonce)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion (get_unrevealed ctxt level)
    (fun unrevealed =&gt;
      Error_monad.op_gtgteqquestion
        (Error_monad.fail_unless
          (Seed_repr.check_hash nonce
            (Storage.Seed.unrevealed_nonce.nonce_hash unrevealed))
          extensible_type_value)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgteqquestion
            (Storage.Seed.Nonce.set ctxt level (Storage.Seed.Revealed nonce))
            (fun ctxt =&gt; Error_monad.__return ctxt))).

Module unrevealed.
  Record record := {
    nonce_hash : Nonce_hash.t;
    delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    rewards : Tez_repr.t;
    fees : Tez_repr.t }.
End unrevealed.
Definition unrevealed := unrevealed.record.

Inductive status : Set :=
| Unrevealed : unrevealed -&gt; status
| Revealed : Seed_repr.nonce -&gt; status.

Definition get
  : Storage.Seed.Nonce.context -&gt; Level_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Storage.Seed.nonce_status) :=
  Storage.Seed.Nonce.get.

Definition of_bytes : MBytes.t -&gt; Error_monad.tzresult Seed_repr.nonce :=
  Seed_repr.make_nonce.

Definition __hash_value : Seed_repr.nonce -&gt; Nonce_hash.t :=
  Seed_repr.__hash_value.

Definition check_hash : Seed_repr.nonce -&gt; Nonce_hash.t -&gt; bool :=
  Seed_repr.check_hash.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nonce_storage.mli">
  <div class="col-md-6">
    <a href="#nonce_storage.mli"><code>nonce_storage.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Too_late_revelation
  | Too_early_revelation
  | Previously_revealed_nonce
  | Unexpected_nonce</abbr>

type t = Seed_repr.nonce

type nonce = t

val encoding : nonce Data_encoding.t

type unrevealed = Storage.Seed.unrevealed_nonce = {
  nonce_hash : Nonce_hash.t;
  delegate : Signature.Public_key_hash.t;
  rewards : Tez_repr.t;
  fees : Tez_repr.t;
}

type status = Unrevealed of unrevealed | Revealed of Seed_repr.nonce

val get : Raw_context.t -&gt; Level_repr.t -&gt; status tzresult Lwt.t

val record_hash : Raw_context.t -&gt; unrevealed -&gt; Raw_context.t tzresult Lwt.t

val reveal :
  Raw_context.t -&gt; Level_repr.t -&gt; nonce -&gt; Raw_context.t tzresult Lwt.t

val of_bytes : MBytes.t -&gt; nonce tzresult

val hash : nonce -&gt; Nonce_hash.t

val check_hash : nonce -&gt; Nonce_hash.t -&gt; bool
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nonce_storage.mli"><code>Nonce_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Level_repr.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Tez_repr.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Definition t := Seed_repr.nonce.

Definition nonce := t.

Parameter encoding : Data_encoding.t nonce.

Module unrevealed.
  Record record := {
    nonce_hash : Nonce_hash.t;
    delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    rewards : Tez_repr.t;
    fees : Tez_repr.t }.
End unrevealed.
Definition unrevealed := unrevealed.record.

Inductive status : Set :=
| Unrevealed : unrevealed -&gt; status
| Revealed : Seed_repr.nonce -&gt; status.

Parameter get :
  Raw_context.t -&gt; Level_repr.t -&gt; Lwt.t (Error_monad.tzresult status).

Parameter record_hash :
  Raw_context.t -&gt; unrevealed -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter reveal :
  Raw_context.t -&gt; Level_repr.t -&gt; nonce -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter of_bytes : MBytes.t -&gt; Error_monad.tzresult nonce.

Parameter __hash_value : nonce -&gt; Nonce_hash.t.

Parameter check_hash : nonce -&gt; Nonce_hash.t -&gt; bool.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="operation_repr.ml">
  <div class="col-md-6">
    <a href="#operation_repr.ml"><code>operation_repr.ml</code></a>&nbsp;<span class="label label-danger">9 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Operations *)

module Kind = struct
  type seed_nonce_revelation = Seed_nonce_revelation_kind

  type double_endorsement_evidence = Double_endorsement_evidence_kind

  type double_baking_evidence = Double_baking_evidence_kind

  type activate_account = Activate_account_kind

  type endorsement = Endorsement_kind

  type proposals = Proposals_kind

  type ballot = Ballot_kind

  type reveal = Reveal_kind

  type transaction = Transaction_kind

  type origination = Origination_kind

  type delegation = Delegation_kind

  type 'a manager =
    | Reveal_manager_kind : reveal manager
    | Transaction_manager_kind : transaction manager
    | Origination_manager_kind : origination manager
    | Delegation_manager_kind : delegation manager
end

type raw = Operation.t = {shell : Operation.shell_header; proto : MBytes.t}

let raw_encoding = Operation.encoding

type 'kind operation = {
  shell : Operation.shell_header;
  protocol_data : 'kind protocol_data;
}

and 'kind protocol_data = {
  contents : 'kind contents_list;
  signature : Signature.t option;
}

and _ contents_list =
  | Single : 'kind contents -&gt; 'kind contents_list
  | Cons :
      'kind Kind.manager contents * 'rest Kind.manager contents_list
      -&gt; ('kind * 'rest) Kind.manager contents_list

and _ contents =
  | Endorsement : {level : Raw_level_repr.t} -&gt; Kind.endorsement contents
  | Seed_nonce_revelation : {
      level : Raw_level_repr.t;
      nonce : Seed_repr.nonce;
    }
      -&gt; Kind.seed_nonce_revelation contents
  | Double_endorsement_evidence : {
      op1 : Kind.endorsement operation;
      op2 : Kind.endorsement operation;
    }
      -&gt; Kind.double_endorsement_evidence contents
  | Double_baking_evidence : {
      bh1 : Block_header_repr.t;
      bh2 : Block_header_repr.t;
    }
      -&gt; Kind.double_baking_evidence contents
  | Activate_account : {
      id : Ed25519.Public_key_hash.t;
      activation_code : Blinded_public_key_hash.activation_code;
    }
      -&gt; Kind.activate_account contents
  | Proposals : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposals : Protocol_hash.t list;
    }
      -&gt; Kind.proposals contents
  | Ballot : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposal : Protocol_hash.t;
      ballot : Vote_repr.ballot;
    }
      -&gt; Kind.ballot contents
  | Manager_operation : {
      source : Signature.public_key_hash;
      fee : Tez_repr.tez;
      counter : counter;
      operation : 'kind manager_operation;
      gas_limit : Z.t;
      storage_limit : Z.t;
    }
      -&gt; 'kind Kind.manager contents

and _ manager_operation =
  | Reveal : Signature.Public_key.t -&gt; Kind.reveal manager_operation
  | Transaction : {
      amount : Tez_repr.tez;
      parameters : Script_repr.lazy_expr;
      entrypoint : string;
      destination : Contract_repr.contract;
    }
      -&gt; Kind.transaction manager_operation
  | Origination : {
      delegate : Signature.Public_key_hash.t option;
      script : Script_repr.t;
      credit : Tez_repr.tez;
      preorigination : Contract_repr.t option;
    }
      -&gt; Kind.origination manager_operation
  | Delegation :
      Signature.Public_key_hash.t option
      -&gt; Kind.delegation manager_operation

and counter = Z.t

let manager_kind : type kind. kind manager_operation -&gt; kind Kind.manager =
  function
  | Reveal _ -&gt;
      Kind.Reveal_manager_kind
  | Transaction _ -&gt;
      Kind.Transaction_manager_kind
  | Origination _ -&gt;
      Kind.Origination_manager_kind
  | Delegation _ -&gt;
      Kind.Delegation_manager_kind

type 'kind internal_operation = {
  source : Contract_repr.contract;
  operation : 'kind manager_operation;
  nonce : int;
}

type packed_manager_operation =
  | Manager : 'kind manager_operation -&gt; packed_manager_operation

type packed_contents = Contents : 'kind contents -&gt; packed_contents

type packed_contents_list =
  | Contents_list : 'kind contents_list -&gt; packed_contents_list

type packed_protocol_data =
  | Operation_data : 'kind protocol_data -&gt; packed_protocol_data

type packed_operation = {
  shell : Operation.shell_header;
  protocol_data : packed_protocol_data;
}

let pack ({shell; protocol_data} : _ operation) : packed_operation =
  {shell; protocol_data = Operation_data protocol_data}

type packed_internal_operation =
  | Internal_operation : 'kind internal_operation -&gt; packed_internal_operation

let rec to_list = function
  | Contents_list (Single o) -&gt;
      [Contents o]
  | Contents_list (Cons (o, os)) -&gt;
      Contents o :: to_list (Contents_list os)

let rec of_list = function
  | [] -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | [Contents o] -&gt;
      Contents_list (Single o)
  | Contents o :: os -&gt; (
      let (Contents_list os) = of_list os in
      match (o, os) with
      | (Manager_operation _, Single (Manager_operation _)) -&gt;
          Contents_list (Cons (o, os))
      | (Manager_operation _, Cons _) -&gt;
          Contents_list (Cons (o, os))
      | _ -&gt;
          Pervasives.failwith
            &quot;Operation list of length &gt; 1 should only contains manager \
             operations.&quot; )

module Encoding = struct
  open Data_encoding

  let case tag name args proj inj =
    let open Data_encoding in
    case
      tag
      ~title:(String.capitalize_ascii name)
      (merge_objs (obj1 (req &quot;kind&quot; (constant name))) args)
      (fun x -&gt; match proj x with None -&gt; None | Some x -&gt; Some ((), x))
      (fun ((), x) -&gt; inj x)

  module Manager_operations = struct
    type 'kind case =
      | MCase : {
          tag : int;
          name : string;
          encoding : 'a Data_encoding.t;
          select : packed_manager_operation -&gt; 'kind manager_operation option;
          proj : 'kind manager_operation -&gt; 'a;
          inj : 'a -&gt; 'kind manager_operation;
        }
          -&gt; 'kind case

    let reveal_case =
      MCase
        {
          tag = 0;
          name = &quot;reveal&quot;;
          encoding = obj1 (req &quot;public_key&quot; Signature.Public_key.encoding);
          select = (function Manager (Reveal _ as op) -&gt; Some op | _ -&gt; None);
          proj = (function Reveal pkh -&gt; pkh);
          inj = (fun pkh -&gt; Reveal pkh);
        }

    let entrypoint_encoding =
      def
        ~title:&quot;entrypoint&quot;
        ~description:&quot;Named entrypoint to a Michelson smart contract&quot;
        &quot;entrypoint&quot;
      @@
      let builtin_case tag name =
        Data_encoding.case
          (Tag tag)
          ~title:name
          (constant name)
          (fun n -&gt; if Compare.String.(n = name) then Some () else None)
          (fun () -&gt; name)
      in
      union
        [ builtin_case 0 &quot;default&quot;;
          builtin_case 1 &quot;root&quot;;
          builtin_case 2 &quot;do&quot;;
          builtin_case 3 &quot;set_delegate&quot;;
          builtin_case 4 &quot;remove_delegate&quot;;
          Data_encoding.case
            (Tag 255)
            ~title:&quot;named&quot;
            (Bounded.string 31)
            (fun s -&gt; Some s)
            (fun s -&gt; s) ]

    let transaction_case =
      MCase
        {
          tag = 1;
          name = &quot;transaction&quot;;
          encoding =
            obj3
              (req &quot;amount&quot; Tez_repr.encoding)
              (req &quot;destination&quot; Contract_repr.encoding)
              (opt
                 &quot;parameters&quot;
                 (obj2
                    (req &quot;entrypoint&quot; entrypoint_encoding)
                    (req &quot;value&quot; Script_repr.lazy_expr_encoding)));
          select =
            (function Manager (Transaction _ as op) -&gt; Some op | _ -&gt; None);
          proj =
            (function
            | Transaction {amount; destination; parameters; entrypoint} -&gt;
                let parameters =
                  if
                    Script_repr.is_unit_parameter parameters
                    &amp;&amp; Compare.String.(entrypoint = &quot;default&quot;)
                  then None
                  else Some (entrypoint, parameters)
                in
                (amount, destination, parameters));
          inj =
            (fun (amount, destination, parameters) -&gt;
              let (entrypoint, parameters) =
                match parameters with
                | None -&gt;
                    (&quot;default&quot;, Script_repr.unit_parameter)
                | Some (entrypoint, value) -&gt;
                    (entrypoint, value)
              in
              Transaction {amount; destination; parameters; entrypoint});
        }

    let origination_case =
      MCase
        {
          tag = 2;
          name = &quot;origination&quot;;
          encoding =
            obj3
              (req &quot;balance&quot; Tez_repr.encoding)
              (opt &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;script&quot; Script_repr.encoding);
          select =
            (function Manager (Origination _ as op) -&gt; Some op | _ -&gt; None);
          proj =
            (function
            | Origination
                { credit;
                  delegate;
                  script;
                  preorigination =
                    _
                    (* the hash is only used internally
                               when originating from smart
                               contracts, don't serialize it *)
                } -&gt;
                (credit, delegate, script));
          inj =
            (fun (credit, delegate, script) -&gt;
              Origination {credit; delegate; script; preorigination = None});
        }

    let delegation_case =
      MCase
        {
          tag = 3;
          name = &quot;delegation&quot;;
          encoding = obj1 (opt &quot;delegate&quot; Signature.Public_key_hash.encoding);
          select =
            (function Manager (Delegation _ as op) -&gt; Some op | _ -&gt; None);
          proj = (function Delegation key -&gt; key);
          inj = (fun key -&gt; Delegation key);
        }

    let encoding =
      let make (MCase {tag; name; encoding; select; proj; inj}) =
        case
          (Tag tag)
          name
          encoding
          (fun o -&gt;
            match select o with None -&gt; None | Some o -&gt; Some (proj o))
          (fun x -&gt; Manager (inj x))
      in
      union
        ~tag_size:<abbr class="mark-error" title="Variants not supported">`Uint8</abbr>
        [ make reveal_case;
          make transaction_case;
          make origination_case;
          make delegation_case ]
  end

  type 'b case =
    | Case : {
        tag : int;
        name : string;
        encoding : 'a Data_encoding.t;
        select : packed_contents -&gt; 'b contents option;
        proj : 'b contents -&gt; 'a;
        inj : 'a -&gt; 'b contents;
      }
        -&gt; 'b case

  let endorsement_encoding = obj1 (req &quot;level&quot; Raw_level_repr.encoding)

  let endorsement_case =
    Case
      {
        tag = 0;
        name = &quot;endorsement&quot;;
        encoding = endorsement_encoding;
        select =
          (function Contents (Endorsement _ as op) -&gt; Some op | _ -&gt; None);
        proj = (fun (Endorsement {level}) -&gt; level);
        inj = (fun level -&gt; Endorsement {level});
      }

  let endorsement_encoding =
    let make (Case {tag; name; encoding; select = _; proj; inj}) =
      case (Tag tag) name encoding (fun o -&gt; Some (proj o)) (fun x -&gt; inj x)
    in
    let to_list : Kind.endorsement contents_list -&gt; _ = function
      | Single o -&gt;
          o
    in
    let of_list : Kind.endorsement contents -&gt; _ = function o -&gt; Single o in
    def &quot;inlined.endorsement&quot;
    @@ conv
         (fun ({shell; protocol_data = {contents; signature}} : _ operation) -&gt;
           (shell, (contents, signature)))
         (fun (shell, (contents, signature)) -&gt;
           ({shell; protocol_data = {contents; signature}} : _ operation))
         (merge_objs
            Operation.shell_header_encoding
            (obj2
               (req
                  &quot;operations&quot;
                  ( conv to_list of_list
                  @@ def &quot;inlined.endorsement.contents&quot;
                  @@ union [make endorsement_case] ))
               (varopt &quot;signature&quot; Signature.encoding)))

  let seed_nonce_revelation_case =
    Case
      {
        tag = 1;
        name = &quot;seed_nonce_revelation&quot;;
        encoding =
          obj2
            (req &quot;level&quot; Raw_level_repr.encoding)
            (req &quot;nonce&quot; Seed_repr.nonce_encoding);
        select =
          (function
          | Contents (Seed_nonce_revelation _ as op) -&gt; Some op | _ -&gt; None);
        proj = (fun (Seed_nonce_revelation {level; nonce}) -&gt; (level, nonce));
        inj = (fun (level, nonce) -&gt; Seed_nonce_revelation {level; nonce});
      }

  let double_endorsement_evidence_case : Kind.double_endorsement_evidence case
      =
    Case
      {
        tag = 2;
        name = &quot;double_endorsement_evidence&quot;;
        encoding =
          obj2
            (req &quot;op1&quot; (dynamic_size endorsement_encoding))
            (req &quot;op2&quot; (dynamic_size endorsement_encoding));
        select =
          (function
          | Contents (Double_endorsement_evidence _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        proj = (fun (Double_endorsement_evidence {op1; op2}) -&gt; (op1, op2));
        inj = (fun (op1, op2) -&gt; Double_endorsement_evidence {op1; op2});
      }

  let double_baking_evidence_case =
    Case
      {
        tag = 3;
        name = &quot;double_baking_evidence&quot;;
        encoding =
          obj2
            (req &quot;bh1&quot; (dynamic_size Block_header_repr.encoding))
            (req &quot;bh2&quot; (dynamic_size Block_header_repr.encoding));
        select =
          (function
          | Contents (Double_baking_evidence _ as op) -&gt; Some op | _ -&gt; None);
        proj = (fun (Double_baking_evidence {bh1; bh2}) -&gt; (bh1, bh2));
        inj = (fun (bh1, bh2) -&gt; Double_baking_evidence {bh1; bh2});
      }

  let activate_account_case =
    Case
      {
        tag = 4;
        name = &quot;activate_account&quot;;
        encoding =
          obj2
            (req &quot;pkh&quot; Ed25519.Public_key_hash.encoding)
            (req &quot;secret&quot; Blinded_public_key_hash.activation_code_encoding);
        select =
          (function
          | Contents (Activate_account _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (fun (Activate_account {id; activation_code}) -&gt;
            (id, activation_code));
        inj =
          (fun (id, activation_code) -&gt; Activate_account {id; activation_code});
      }

  let proposals_case =
    Case
      {
        tag = 5;
        name = &quot;proposals&quot;;
        encoding =
          obj3
            (req &quot;source&quot; Signature.Public_key_hash.encoding)
            (req &quot;period&quot; Voting_period_repr.encoding)
            (req &quot;proposals&quot; (list Protocol_hash.encoding));
        select =
          (function Contents (Proposals _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (fun (Proposals {source; period; proposals}) -&gt;
            (source, period, proposals));
        inj =
          (fun (source, period, proposals) -&gt;
            Proposals {source; period; proposals});
      }

  let ballot_case =
    Case
      {
        tag = 6;
        name = &quot;ballot&quot;;
        encoding =
          obj4
            (req &quot;source&quot; Signature.Public_key_hash.encoding)
            (req &quot;period&quot; Voting_period_repr.encoding)
            (req &quot;proposal&quot; Protocol_hash.encoding)
            (req &quot;ballot&quot; Vote_repr.ballot_encoding);
        select = (function Contents (Ballot _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (function
          | Ballot {source; period; proposal; ballot} -&gt;
              (source, period, proposal, ballot));
        inj =
          (fun (source, period, proposal, ballot) -&gt;
            Ballot {source; period; proposal; ballot});
      }

  let manager_encoding =
    obj5
      (req &quot;source&quot; Signature.Public_key_hash.encoding)
      (req &quot;fee&quot; Tez_repr.encoding)
      (req &quot;counter&quot; (check_size 10 n))
      (req &quot;gas_limit&quot; (check_size 10 n))
      (req &quot;storage_limit&quot; (check_size 10 n))

  let extract (type kind)
      (Manager_operation
         {source; fee; counter; gas_limit; storage_limit; operation = _} :
        kind Kind.manager contents) =
    (source, fee, counter, gas_limit, storage_limit)

  let rebuild (source, fee, counter, gas_limit, storage_limit) operation =
    Manager_operation
      {source; fee; counter; gas_limit; storage_limit; operation}

  let make_manager_case tag (type kind)
      (Manager_operations.MCase mcase : kind Manager_operations.case) =
    Case
      {
        tag;
        name = mcase.name;
        encoding = merge_objs manager_encoding mcase.encoding;
        select =
          (function
          | Contents (Manager_operation ({operation; _} as op)) -&gt; (
            match mcase.select (Manager operation) with
            | None -&gt;
                None
            | Some operation -&gt;
                Some (Manager_operation <abbr class="mark-error" title="Record substitution not handled">{op with operation}</abbr>) )
          | _ -&gt;
              None);
        proj =
          (function
          | Manager_operation {operation; _} as op -&gt;
              (extract op, mcase.proj operation));
        inj = (fun (op, contents) -&gt; rebuild op (mcase.inj contents));
      }

  let reveal_case = make_manager_case 107 Manager_operations.reveal_case

  let transaction_case =
    make_manager_case 108 Manager_operations.transaction_case

  let origination_case =
    make_manager_case 109 Manager_operations.origination_case

  let delegation_case =
    make_manager_case 110 Manager_operations.delegation_case

  let contents_encoding =
    let make (Case {tag; name; encoding; select; proj; inj}) =
      case
        (Tag tag)
        name
        encoding
        (fun o -&gt; match select o with None -&gt; None | Some o -&gt; Some (proj o))
        (fun x -&gt; Contents (inj x))
    in
    def &quot;operation.alpha.contents&quot;
    @@ union
         [ make endorsement_case;
           make seed_nonce_revelation_case;
           make double_endorsement_evidence_case;
           make double_baking_evidence_case;
           make activate_account_case;
           make proposals_case;
           make ballot_case;
           make reveal_case;
           make transaction_case;
           make origination_case;
           make delegation_case ]

  let contents_list_encoding =
    conv to_list of_list (Variable.list contents_encoding)

  let optional_signature_encoding =
    conv
      (function Some s -&gt; s | None -&gt; Signature.zero)
      (fun s -&gt; if Signature.equal s Signature.zero then None else Some s)
      Signature.encoding

  let protocol_data_encoding =
    def &quot;operation.alpha.contents_and_signature&quot;
    @@ conv
         (fun (Operation_data {contents; signature}) -&gt;
           (Contents_list contents, signature))
         (fun (Contents_list contents, signature) -&gt;
           Operation_data {contents; signature})
         (obj2
            (req &quot;contents&quot; contents_list_encoding)
            (req &quot;signature&quot; optional_signature_encoding))

  let operation_encoding =
    conv
      (fun {shell; protocol_data} -&gt; (shell, protocol_data))
      (fun (shell, protocol_data) -&gt; {shell; protocol_data})
      (merge_objs Operation.shell_header_encoding protocol_data_encoding)

  let unsigned_operation_encoding =
    def &quot;operation.alpha.unsigned_operation&quot;
    @@ merge_objs
         Operation.shell_header_encoding
         (obj1 (req &quot;contents&quot; contents_list_encoding))

  let internal_operation_encoding =
    def &quot;operation.alpha.internal_operation&quot;
    @@ conv
         (fun (Internal_operation {source; operation; nonce}) -&gt;
           ((source, nonce), Manager operation))
         (fun ((source, nonce), Manager operation) -&gt;
           Internal_operation {source; operation; nonce})
         (merge_objs
            (obj2 (req &quot;source&quot; Contract_repr.encoding) (req &quot;nonce&quot; uint16))
            Manager_operations.encoding)
end

let encoding = Encoding.operation_encoding

let contents_encoding = Encoding.contents_encoding

let contents_list_encoding = Encoding.contents_list_encoding

let protocol_data_encoding = Encoding.protocol_data_encoding

let unsigned_operation_encoding = Encoding.unsigned_operation_encoding

let internal_operation_encoding = Encoding.internal_operation_encoding

let raw ({shell; protocol_data} : _ operation) =
  let proto =
    Data_encoding.Binary.to_bytes_exn
      protocol_data_encoding
      (Operation_data protocol_data)
  in
  {Operation.shell; proto}

let acceptable_passes (op : packed_operation) =
  let (Operation_data protocol_data) = op.protocol_data in
  match protocol_data.contents with
  | Single (Endorsement _) -&gt;
      [0]
  | Single (Proposals _) -&gt;
      [1]
  | Single (Ballot _) -&gt;
      [1]
  | Single (Seed_nonce_revelation _) -&gt;
      [2]
  | Single (Double_endorsement_evidence _) -&gt;
      [2]
  | Single (Double_baking_evidence _) -&gt;
      [2]
  | Single (Activate_account _) -&gt;
      [2]
  | Single (Manager_operation _) -&gt;
      [3]
  | Cons _ -&gt;
      [3]

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Missing_signature</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;operation.invalid_signature&quot;
    ~title:&quot;Invalid operation signature&quot;
    ~description:
      &quot;The operation signature is ill-formed or has been made with the wrong \
       public key&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;The operation signature is invalid&quot;)
    Data_encoding.unit
    (function Invalid_signature -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_signature) ;
  register_error_kind
    `Permanent
    ~id:&quot;operation.missing_signature&quot;
    ~title:&quot;Missing operation signature&quot;
    ~description:
      &quot;The operation is of a kind that must be signed, but the signature is \
       missing&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;The operation requires a signature&quot;)
    Data_encoding.unit
    (function Missing_signature -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Missing_signature)</abbr>

let check_signature_sync (type kind) key chain_id
    ({shell; protocol_data} : kind operation) =
  let check ~watermark contents signature =
    let unsigned_operation =
      Data_encoding.Binary.to_bytes_exn
        unsigned_operation_encoding
        (shell, contents)
    in
    if Signature.check ~watermark key signature unsigned_operation then Ok ()
    else error <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_signature</abbr>
  in
  match (protocol_data.contents, protocol_data.signature) with
  | (Single _, None) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Missing_signature</abbr>
  | (Cons _, None) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Missing_signature</abbr>
  | ((Single (Endorsement _) as contents), Some signature) -&gt;
      check
        ~watermark:(Endorsement chain_id)
        (Contents_list contents)
        signature
  | ((Single _ as contents), Some signature) -&gt;
      check ~watermark:Generic_operation (Contents_list contents) signature
  | ((Cons _ as contents), Some signature) -&gt;
      check ~watermark:Generic_operation (Contents_list contents) signature

let check_signature pk chain_id op =
  Lwt.return (check_signature_sync pk chain_id op)

let hash_raw = Operation.hash

let hash (o : _ operation) =
  let proto =
    Data_encoding.Binary.to_bytes_exn
      protocol_data_encoding
      (Operation_data o.protocol_data)
  in
  Operation.hash {shell = o.shell; proto}

let hash_packed (o : packed_operation) =
  let proto =
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding o.protocol_data
  in
  Operation.hash {shell = o.shell; proto}

type ('a, 'b) eq = Eq : ('a, 'a) eq

let equal_manager_operation_kind :
    type a b. a manager_operation -&gt; b manager_operation -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  match (op1, op2) with
  | (Reveal _, Reveal _) -&gt;
      Some Eq
  | (Reveal _, _) -&gt;
      None
  | (Transaction _, Transaction _) -&gt;
      Some Eq
  | (Transaction _, _) -&gt;
      None
  | (Origination _, Origination _) -&gt;
      Some Eq
  | (Origination _, _) -&gt;
      None
  | (Delegation _, Delegation _) -&gt;
      Some Eq
  | (Delegation _, _) -&gt;
      None

let equal_contents_kind :
    type a b. a contents -&gt; b contents -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  match (op1, op2) with
  | (Endorsement _, Endorsement _) -&gt;
      Some Eq
  | (Endorsement _, _) -&gt;
      None
  | (Seed_nonce_revelation _, Seed_nonce_revelation _) -&gt;
      Some Eq
  | (Seed_nonce_revelation _, _) -&gt;
      None
  | (Double_endorsement_evidence _, Double_endorsement_evidence _) -&gt;
      Some Eq
  | (Double_endorsement_evidence _, _) -&gt;
      None
  | (Double_baking_evidence _, Double_baking_evidence _) -&gt;
      Some Eq
  | (Double_baking_evidence _, _) -&gt;
      None
  | (Activate_account _, Activate_account _) -&gt;
      Some Eq
  | (Activate_account _, _) -&gt;
      None
  | (Proposals _, Proposals _) -&gt;
      Some Eq
  | (Proposals _, _) -&gt;
      None
  | (Ballot _, Ballot _) -&gt;
      Some Eq
  | (Ballot _, _) -&gt;
      None
  | (Manager_operation op1, Manager_operation op2) -&gt; (
    match equal_manager_operation_kind op1.operation op2.operation with
    | None -&gt;
        None
    | Some Eq -&gt;
        Some Eq )
  | (Manager_operation _, _) -&gt;
      None

let rec equal_contents_kind_list :
    type a b. a contents_list -&gt; b contents_list -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  match (op1, op2) with
  | (Single op1, Single op2) -&gt;
      equal_contents_kind op1 op2
  | (Single _, Cons _) -&gt;
      None
  | (Cons _, Single _) -&gt;
      None
  | (Cons (op1, ops1), Cons (op2, ops2)) -&gt; (
    match equal_contents_kind op1 op2 with
    | None -&gt;
        None
    | Some Eq -&gt; (
      match equal_contents_kind_list ops1 ops2 with
      | None -&gt;
          None
      | Some Eq -&gt;
          Some Eq ) )

let equal : type a b. a operation -&gt; b operation -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  if not (Operation_hash.equal (hash op1) (hash op2)) then None
  else
    equal_contents_kind_list
      op1.protocol_data.contents
      op2.protocol_data.contents
</pre>
  </div>
  <div class="col-md-6">
    <a href="#operation_repr.ml"><code>Operation_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Block_header_repr.
Require Tezos.Contract_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Reserved Notation &quot;'manager&quot;.
  
  Inductive manager_gadt : Set :=
  | Reveal_manager_kind : manager_gadt
  | Transaction_manager_kind : manager_gadt
  | Origination_manager_kind : manager_gadt
  | Delegation_manager_kind : manager_gadt
  
  where &quot;'manager&quot; := (fun (a : Set) =&gt; manager_gadt).
  
  Definition manager := 'manager.
End Kind.

Module raw.
  Record record := {
    shell : Operation.shell_header;
    proto : MBytes.t }.
End raw.
Definition raw := raw.record.

Definition raw_encoding : Data_encoding.t Operation.t := Operation.encoding.

Module contents.
  Module Endorsement.
    Record record {level : Set} := {
      level : level }.
    Arguments record : clear implicits.
  End Endorsement.
  Definition Endorsement := Endorsement.record.
  
  Module Seed_nonce_revelation.
    Record record {level nonce : Set} := {
      level : level;
      nonce : nonce }.
    Arguments record : clear implicits.
  End Seed_nonce_revelation.
  Definition Seed_nonce_revelation := Seed_nonce_revelation.record.
  
  Module Double_endorsement_evidence.
    Record record {op1 op2 : Set} := {
      op1 : op1;
      op2 : op2 }.
    Arguments record : clear implicits.
  End Double_endorsement_evidence.
  Definition Double_endorsement_evidence := Double_endorsement_evidence.record.
  
  Module Double_baking_evidence.
    Record record {bh1 bh2 : Set} := {
      bh1 : bh1;
      bh2 : bh2 }.
    Arguments record : clear implicits.
  End Double_baking_evidence.
  Definition Double_baking_evidence := Double_baking_evidence.record.
  
  Module Activate_account.
    Record record {id activation_code : Set} := {
      id : id;
      activation_code : activation_code }.
    Arguments record : clear implicits.
  End Activate_account.
  Definition Activate_account := Activate_account.record.
  
  Module Proposals.
    Record record {source period proposals : Set} := {
      source : source;
      period : period;
      proposals : proposals }.
    Arguments record : clear implicits.
  End Proposals.
  Definition Proposals := Proposals.record.
  
  Module Ballot.
    Record record {source period proposal ballot : Set} := {
      source : source;
      period : period;
      proposal : proposal;
      ballot : ballot }.
    Arguments record : clear implicits.
  End Ballot.
  Definition Ballot := Ballot.record.
  
  Module Manager_operation.
    Record record {source fee counter operation gas_limit storage_limit : Set} := {
      source : source;
      fee : fee;
      counter : counter;
      operation : operation;
      gas_limit : gas_limit;
      storage_limit : storage_limit }.
    Arguments record : clear implicits.
  End Manager_operation.
  Definition Manager_operation := Manager_operation.record.
End contents.

Module manager_operation.
  Module Transaction.
    Record record {amount parameters entrypoint destination : Set} := {
      amount : amount;
      parameters : parameters;
      entrypoint : entrypoint;
      destination : destination }.
    Arguments record : clear implicits.
  End Transaction.
  Definition Transaction := Transaction.record.
  
  Module Origination.
    Record record {delegate script credit preorigination : Set} := {
      delegate : delegate;
      script : script;
      credit : credit;
      preorigination : preorigination }.
    Arguments record : clear implicits.
  End Origination.
  Definition Origination := Origination.record.
End manager_operation.

Reserved Notation &quot;'operation&quot;.
Reserved Notation &quot;'protocol_data&quot;.
Reserved Notation &quot;'contents_list&quot;.
Reserved Notation &quot;'contents&quot;.
Reserved Notation &quot;'manager_operation&quot;.
Reserved Notation &quot;'counter&quot;.

Module protocol_data.
  Record record {contents signature : Set} := {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Module operation.
  Record record {shell protocol_data : Set} := {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
End operation.
Definition operation_skeleton := operation.record.

Inductive contents_list_gadt : Set :=
| Single : forall {kind : Set}, 'contents kind -&gt; contents_list_gadt
| Cons : forall {kind : Set},
  'contents (Kind.manager kind) -&gt; contents_list_gadt -&gt; contents_list_gadt

with contents_gadt : Set :=
| Endorsement : contents.Endorsement Raw_level_repr.t -&gt; contents_gadt
| Seed_nonce_revelation :
  contents.Seed_nonce_revelation Raw_level_repr.t Seed_repr.nonce -&gt;
  contents_gadt
| Double_endorsement_evidence :
  contents.Double_endorsement_evidence ('operation Kind.endorsement)
    ('operation Kind.endorsement) -&gt; contents_gadt
| Double_baking_evidence :
  contents.Double_baking_evidence Block_header_repr.t Block_header_repr.t -&gt;
  contents_gadt
| Activate_account :
  contents.Activate_account
    Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code -&gt; contents_gadt
| Proposals :
  contents.Proposals Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Voting_period_repr.t (list Protocol_hash.[S.HASH.t]) -&gt; contents_gadt
| Ballot :
  contents.Ballot Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Voting_period_repr.t Protocol_hash.[S.HASH.t] Vote_repr.ballot -&gt;
  contents_gadt
| Manager_operation : forall {kind : Set},
  contents.Manager_operation Signature.public_key_hash Tez_repr.tez 'counter
    ('manager_operation kind) Z.t Z.t -&gt; contents_gadt

with manager_operation_gadt : Set :=
| Reveal : Signature.Public_key.[S.SPublic_key.t] -&gt; manager_operation_gadt
| Transaction :
  manager_operation.Transaction Tez_repr.tez Script_repr.lazy_expr string
    Contract_repr.contract -&gt; manager_operation_gadt
| Origination :
  manager_operation.Origination
    (option Signature.Public_key_hash.[S.SPublic_key_hash.t]) Script_repr.t
    Tez_repr.tez (option Contract_repr.t) -&gt; manager_operation_gadt
| Delegation :
  option Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  manager_operation_gadt

where &quot;'operation&quot; := (fun (kind : Set) =&gt;
  operation_skeleton Operation.shell_header ('protocol_data kind))
and &quot;'protocol_data&quot; := (fun (kind : Set) =&gt;
  protocol_data_skeleton ('contents_list kind) (option Signature.t))
and &quot;'contents_list&quot; := (fun (_ : Set) =&gt; contents_list_gadt)
and &quot;'contents&quot; := (fun (_ : Set) =&gt; contents_gadt)
and &quot;'manager_operation&quot; := (fun (_ : Set) =&gt; manager_operation_gadt)
and &quot;'counter&quot; := (Z.t).

Definition operation := 'operation.
Definition protocol_data := 'protocol_data.
Definition contents_list := 'contents_list.
Definition contents := 'contents.
Definition manager_operation := 'manager_operation.
Definition counter := 'counter.

Definition manager_kind {kind : Set}
  (function_parameter : manager_operation kind) : Kind.manager kind :=
  match function_parameter with
  | Reveal _ =&gt; Kind.Reveal_manager_kind
  | Transaction _ =&gt; Kind.Transaction_manager_kind
  | Origination _ =&gt; Kind.Origination_manager_kind
  | Delegation _ =&gt; Kind.Delegation_manager_kind
  end.

Module internal_operation.
  Record record {kind : Set} := {
    source : Contract_repr.contract;
    operation : manager_operation kind;
    nonce : Z }.
  Arguments record : clear implicits.
End internal_operation.
Definition internal_operation := internal_operation.record.

Reserved Notation &quot;'packed_manager_operation&quot;.

Inductive packed_manager_operation_gadt : Set :=
| Manager : forall {kind : Set},
  manager_operation kind -&gt; packed_manager_operation_gadt

where &quot;'packed_manager_operation&quot; := (packed_manager_operation_gadt).

Definition packed_manager_operation := 'packed_manager_operation.

Reserved Notation &quot;'packed_contents&quot;.

Inductive packed_contents_gadt : Set :=
| Contents : forall {kind : Set}, contents kind -&gt; packed_contents_gadt

where &quot;'packed_contents&quot; := (packed_contents_gadt).

Definition packed_contents := 'packed_contents.

Reserved Notation &quot;'packed_contents_list&quot;.

Inductive packed_contents_list_gadt : Set :=
| Contents_list : forall {kind : Set},
  contents_list kind -&gt; packed_contents_list_gadt

where &quot;'packed_contents_list&quot; := (packed_contents_list_gadt).

Definition packed_contents_list := 'packed_contents_list.

Reserved Notation &quot;'packed_protocol_data&quot;.

Inductive packed_protocol_data_gadt : Set :=
| Operation_data : forall {kind : Set},
  protocol_data kind -&gt; packed_protocol_data_gadt

where &quot;'packed_protocol_data&quot; := (packed_protocol_data_gadt).

Definition packed_protocol_data := 'packed_protocol_data.

Module packed_operation.
  Record record := {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
End packed_operation.
Definition packed_operation := packed_operation.record.

Definition pack {A : Set} (function_parameter : operation A)
  : packed_operation :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  {| packed_operation.shell := shell;
    packed_operation.protocol_data := Operation_data protocol_data |}.

Reserved Notation &quot;'packed_internal_operation&quot;.

Inductive packed_internal_operation_gadt : Set :=
| Internal_operation : forall {kind : Set},
  internal_operation kind -&gt; packed_internal_operation_gadt

where &quot;'packed_internal_operation&quot; := (packed_internal_operation_gadt).

Definition packed_internal_operation := 'packed_internal_operation.

Fixpoint to_list (function_parameter : packed_contents_list)
  {struct function_parameter} : list packed_contents :=
  match function_parameter with
  | Contents_list (Single o) =&gt; cons (Contents o) []
  | Contents_list (Cons o os) =&gt; cons (Contents o) (to_list (Contents_list os))
  end.

Fixpoint of_list (function_parameter : list packed_contents)
  {struct function_parameter} : packed_contents_list :=
  match function_parameter with
  | [] =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | cons (Contents o) [] =&gt; Contents_list (Single o)
  | cons (Contents o) os =&gt;
    let 'Contents_list os := of_list os in
    match (o, os) with
    | (Manager_operation _, Single (Manager_operation _)) =&gt;
      Contents_list (Cons o os)
    | (Manager_operation _, Cons _ _) =&gt; Contents_list (Cons o os)
    | _ =&gt;
      Pervasives.failwith
        &quot;Operation list of length &gt; 1 should only contains manager operations.&quot;
          % string
    end
  end.

Module Encoding.
  Import Data_encoding.
  
  Definition __case_value {A B : Set}
    (tag : Data_encoding.case_tag) (name : string)
    (args : Data_encoding.encoding A) (proj : B -&gt; option A) (inj : A -&gt; B)
    : Data_encoding.case B :=
    Data_encoding.__case_value (String.capitalize_ascii name) None tag
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;kind&quot; % string
            (Data_encoding.constant name))) args)
      (fun x =&gt;
        match proj x with
        | None =&gt; None
        | Some x =&gt; Some (tt, x)
        end)
      (fun function_parameter =&gt;
        let '(tt, x) := function_parameter in
        inj x).
  
  Module Manager_operations.
    Module case.
      Module MCase.
        Record record {tag name encoding select proj inj : Set} := {
          tag : tag;
          name : name;
          encoding : encoding;
          select : select;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
      End MCase.
      Definition MCase := MCase.record.
    End case.
    
    Reserved Notation &quot;'case&quot;.
    
    Inductive case_gadt : Set :=
    | MCase : forall {a kind : Set},
      case.MCase Z string (Data_encoding.t a)
        (packed_manager_operation -&gt; option (manager_operation kind))
        (manager_operation kind -&gt; a) (a -&gt; manager_operation kind) -&gt; case_gadt
    
    where &quot;'case&quot; := (fun (kind : Set) =&gt; case_gadt).
    
    Definition case := 'case.
    
    Definition reveal_case : case Kind.reveal :=
      MCase
        {| case.MCase.tag := 0; case.MCase.name := &quot;reveal&quot; % string;
          case.MCase.encoding :=
            Data_encoding.obj1
              (Data_encoding.req None None &quot;public_key&quot; % string
                Signature.Public_key.[S.SPublic_key.encoding]);
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Reveal _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              let 'Reveal pkh := function_parameter in
              pkh; case.MCase.inj := fun pkh =&gt; Reveal pkh |}.
    
    Definition entrypoint_encoding
      : Data_encoding.encoding Compare.String.[Compare.S.t] :=
      Pervasives.op_atat
        (Data_encoding.def &quot;entrypoint&quot; % string (Some &quot;entrypoint&quot; % string)
          (Some &quot;Named entrypoint to a Michelson smart contract&quot; % string))
        (let builtin_case (tag : Z) (name : Compare.String.[Compare.S.t])
          : Data_encoding.case Compare.String.[Compare.S.t] :=
          Data_encoding.__case_value name None (Data_encoding.Tag tag)
            (Data_encoding.constant name)
            (fun n =&gt;
              if Compare.String.[Compare.S.op_eq] n name then
                Some tt
              else
                None)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              name) in
        Data_encoding.union None
          (cons (builtin_case 0 &quot;default&quot; % string)
            (cons (builtin_case 1 &quot;root&quot; % string)
              (cons (builtin_case 2 &quot;do&quot; % string)
                (cons (builtin_case 3 &quot;set_delegate&quot; % string)
                  (cons (builtin_case 4 &quot;remove_delegate&quot; % string)
                    (cons
                      (Data_encoding.__case_value &quot;named&quot; % string None
                        (Data_encoding.Tag 255)
                        (Data_encoding.Bounded.__string_value 31)
                        (fun s =&gt; Some s) (fun s =&gt; s)) []))))))).
    
    Definition transaction_case : case Kind.transaction :=
      MCase
        {| case.MCase.tag := 1; case.MCase.name := &quot;transaction&quot; % string;
          case.MCase.encoding :=
            Data_encoding.obj3
              (Data_encoding.req None None &quot;amount&quot; % string Tez_repr.encoding)
              (Data_encoding.req None None &quot;destination&quot; % string
                Contract_repr.encoding)
              (Data_encoding.opt None None &quot;parameters&quot; % string
                (Data_encoding.obj2
                  (Data_encoding.req None None &quot;entrypoint&quot; % string
                    entrypoint_encoding)
                  (Data_encoding.req None None &quot;value&quot; % string
                    Script_repr.lazy_expr_encoding)));
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Transaction _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              let
                'Transaction {|
                  manager_operation.Transaction.amount := amount;
                    manager_operation.Transaction.parameters := parameters;
                    manager_operation.Transaction.entrypoint := entrypoint;
                    manager_operation.Transaction.destination := destination
                    |} := function_parameter in
              let parameters :=
                if
                  Pervasives.op_andand
                    (Script_repr.is_unit_parameter parameters)
                    (Compare.String.[Compare.S.op_eq] entrypoint
                      &quot;default&quot; % string) then
                  None
                else
                  Some (entrypoint, parameters) in
              (amount, destination, parameters);
          case.MCase.inj :=
            fun function_parameter =&gt;
              let '(amount, destination, parameters) := function_parameter in
              let '(entrypoint, parameters) :=
                match parameters with
                | None =&gt; (&quot;default&quot; % string, Script_repr.unit_parameter)
                | Some (entrypoint, value) =&gt; (entrypoint, value)
                end in
              Transaction
                {| manager_operation.Transaction.amount := amount;
                  manager_operation.Transaction.parameters := parameters;
                  manager_operation.Transaction.entrypoint := entrypoint;
                  manager_operation.Transaction.destination := destination |} |}.
    
    Definition origination_case : case Kind.origination :=
      MCase
        {| case.MCase.tag := 2; case.MCase.name := &quot;origination&quot; % string;
          case.MCase.encoding :=
            Data_encoding.obj3
              (Data_encoding.req None None &quot;balance&quot; % string Tez_repr.encoding)
              (Data_encoding.opt None None &quot;delegate&quot; % string
                Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
              (Data_encoding.req None None &quot;script&quot; % string
                Script_repr.encoding);
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Origination _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              let
                'Origination {|
                  manager_operation.Origination.delegate := delegate;
                    manager_operation.Origination.script := script;
                    manager_operation.Origination.credit := credit;
                    manager_operation.Origination.preorigination := _
                    |} := function_parameter in
              (credit, delegate, script);
          case.MCase.inj :=
            fun function_parameter =&gt;
              let '(credit, delegate, script) := function_parameter in
              Origination
                {| manager_operation.Origination.delegate := delegate;
                  manager_operation.Origination.script := script;
                  manager_operation.Origination.credit := credit;
                  manager_operation.Origination.preorigination := None |} |}.
    
    Definition delegation_case : case Kind.delegation :=
      MCase
        {| case.MCase.tag := 3; case.MCase.name := &quot;delegation&quot; % string;
          case.MCase.encoding :=
            Data_encoding.obj1
              (Data_encoding.opt None None &quot;delegate&quot; % string
                Signature.Public_key_hash.[S.SPublic_key_hash.encoding]);
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Delegation _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              let 'Delegation key := function_parameter in
              key; case.MCase.inj := fun key =&gt; Delegation key |}.
    
    Definition encoding : Data_encoding.encoding packed_manager_operation :=
      let make {A : Set} (function_parameter : case A)
        : Data_encoding.case packed_manager_operation :=
        let
          'MCase {|
            case.MCase.tag := tag;
              case.MCase.name := name;
              case.MCase.encoding := encoding;
              case.MCase.select := select;
              case.MCase.proj := proj;
              case.MCase.inj := inj
              |} := function_parameter in
        __case_value (Data_encoding.Tag tag) name encoding
          (fun o =&gt;
            match select o with
            | None =&gt; None
            | Some o =&gt; Some (proj o)
            end) (fun x =&gt; Manager (inj x)) in
      Data_encoding.union
        (Some
          (* ‚ùå Variants not supported *)
          (* ‚ùå `Uint8 *)
          tt)
        (cons (make reveal_case)
          (cons (make transaction_case)
            (cons (make origination_case) (cons (make delegation_case) [])))).
  End Manager_operations.
  
  Module case.
    Module Case.
      Record record {tag name encoding select proj inj : Set} := {
        tag : tag;
        name : name;
        encoding : encoding;
        select : select;
        proj : proj;
        inj : inj }.
      Arguments record : clear implicits.
    End Case.
    Definition Case := Case.record.
  End case.
  
  Reserved Notation &quot;'case&quot;.
  
  Inductive case_gadt : Set :=
  | Case : forall {a b : Set},
    case.Case Z string (Data_encoding.t a)
      (packed_contents -&gt; option (contents b)) (contents b -&gt; a)
      (a -&gt; contents b) -&gt; case_gadt
  
  where &quot;'case&quot; := (fun (b : Set) =&gt; case_gadt).
  
  Definition case := 'case.
  
  Definition endorsement_encoding
    : Data_encoding.encoding Raw_level_repr.raw_level :=
    Data_encoding.obj1
      (Data_encoding.req None None &quot;level&quot; % string Raw_level_repr.encoding).
  
  Definition endorsement_case : case Kind.endorsement :=
    Case
      {| case.Case.tag := 0; case.Case.name := &quot;endorsement&quot; % string;
        case.Case.encoding := endorsement_encoding;
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Endorsement _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let 'Endorsement {| contents.Endorsement.level := level |} :=
              function_parameter in
            level;
        case.Case.inj :=
          fun level =&gt; Endorsement {| contents.Endorsement.level := level |} |}.
  
  Definition endorsement_encoding
    : Data_encoding.encoding (operation Kind.endorsement) :=
    let make {A : Set} (function_parameter : case A)
      : Data_encoding.case (contents A) :=
      let
        'Case {|
          case.Case.tag := tag;
            case.Case.name := name;
            case.Case.encoding := encoding;
            case.Case.select := _;
            case.Case.proj := proj;
            case.Case.inj := inj
            |} := function_parameter in
      __case_value (Data_encoding.Tag tag) name encoding
        (fun o =&gt; Some (proj o)) (fun x =&gt; inj x) in
    let to_list (function_parameter : contents_list Kind.endorsement)
      : contents Kind.endorsement :=
      let 'Single o := function_parameter in
      o in
    let of_list (o : contents Kind.endorsement)
      : contents_list Kind.endorsement :=
      Single o in
    Pervasives.op_atat
      (let arg := Data_encoding.def &quot;inlined.endorsement&quot; % string in
      fun eta =&gt; arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =&gt;
          let '{|
            operation.shell := shell;
              operation.protocol_data := {|
                protocol_data.contents := contents;
                  protocol_data.signature := signature
                  |}
              |} := function_parameter in
          (shell, (contents, signature)))
        (fun function_parameter =&gt;
          let '(shell, (contents, signature)) := function_parameter in
          {| operation.shell := shell;
            operation.protocol_data :=
              {| protocol_data.contents := contents;
                protocol_data.signature := signature |} |}) None
        (Data_encoding.merge_objs Operation.shell_header_encoding
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;operations&quot; % string
              (Pervasives.op_atat
                (let arg := Data_encoding.conv to_list of_list in
                fun eta =&gt; arg None eta)
                (Pervasives.op_atat
                  (let arg :=
                    Data_encoding.def &quot;inlined.endorsement.contents&quot; % string in
                  fun eta =&gt; arg None None eta)
                  (Data_encoding.union None (cons (make endorsement_case) [])))))
            (Data_encoding.varopt None None &quot;signature&quot; % string
              Signature.encoding)))).
  
  Definition seed_nonce_revelation_case : case Kind.seed_nonce_revelation :=
    Case
      {| case.Case.tag := 1; case.Case.name := &quot;seed_nonce_revelation&quot; % string;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;level&quot; % string
              Raw_level_repr.encoding)
            (Data_encoding.req None None &quot;nonce&quot; % string
              Seed_repr.nonce_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Seed_nonce_revelation _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              'Seed_nonce_revelation {|
                contents.Seed_nonce_revelation.level := level;
                  contents.Seed_nonce_revelation.nonce := nonce
                  |} := function_parameter in
            (level, nonce);
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(level, nonce) := function_parameter in
            Seed_nonce_revelation
              {| contents.Seed_nonce_revelation.level := level;
                contents.Seed_nonce_revelation.nonce := nonce |} |}.
  
  Definition double_endorsement_evidence_case
    : case Kind.double_endorsement_evidence :=
    Case
      {| case.Case.tag := 2;
        case.Case.name := &quot;double_endorsement_evidence&quot; % string;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;op1&quot; % string
              (Data_encoding.dynamic_size None endorsement_encoding))
            (Data_encoding.req None None &quot;op2&quot; % string
              (Data_encoding.dynamic_size None endorsement_encoding));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Double_endorsement_evidence _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              'Double_endorsement_evidence {|
                contents.Double_endorsement_evidence.op1 := op1;
                  contents.Double_endorsement_evidence.op2 := op2
                  |} := function_parameter in
            (op1, op2);
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(op1, op2) := function_parameter in
            Double_endorsement_evidence
              {| contents.Double_endorsement_evidence.op1 := op1;
                contents.Double_endorsement_evidence.op2 := op2 |} |}.
  
  Definition double_baking_evidence_case : case Kind.double_baking_evidence :=
    Case
      {| case.Case.tag := 3;
        case.Case.name := &quot;double_baking_evidence&quot; % string;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;bh1&quot; % string
              (Data_encoding.dynamic_size None Block_header_repr.encoding))
            (Data_encoding.req None None &quot;bh2&quot; % string
              (Data_encoding.dynamic_size None Block_header_repr.encoding));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Double_baking_evidence _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              'Double_baking_evidence {|
                contents.Double_baking_evidence.bh1 := bh1;
                  contents.Double_baking_evidence.bh2 := bh2
                  |} := function_parameter in
            (bh1, bh2);
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(bh1, bh2) := function_parameter in
            Double_baking_evidence
              {| contents.Double_baking_evidence.bh1 := bh1;
                contents.Double_baking_evidence.bh2 := bh2 |} |}.
  
  Definition activate_account_case : case Kind.activate_account :=
    Case
      {| case.Case.tag := 4; case.Case.name := &quot;activate_account&quot; % string;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;pkh&quot; % string
              Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;secret&quot; % string
              Blinded_public_key_hash.activation_code_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Activate_account _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              'Activate_account {|
                contents.Activate_account.id := id;
                  contents.Activate_account.activation_code := activation_code
                  |} := function_parameter in
            (id, activation_code);
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(id, activation_code) := function_parameter in
            Activate_account
              {| contents.Activate_account.id := id;
                contents.Activate_account.activation_code := activation_code |}
        |}.
  
  Definition proposals_case : case Kind.proposals :=
    Case
      {| case.Case.tag := 5; case.Case.name := &quot;proposals&quot; % string;
        case.Case.encoding :=
          Data_encoding.obj3
            (Data_encoding.req None None &quot;source&quot; % string
              Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
            (Data_encoding.req None None &quot;period&quot; % string
              Voting_period_repr.encoding)
            (Data_encoding.req None None &quot;proposals&quot; % string
              (Data_encoding.__list_value None Protocol_hash.[S.HASH.encoding]));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Proposals _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              'Proposals {|
                contents.Proposals.source := source;
                  contents.Proposals.period := period;
                  contents.Proposals.proposals := proposals
                  |} := function_parameter in
            (source, period, proposals);
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(source, period, proposals) := function_parameter in
            Proposals
              {| contents.Proposals.source := source;
                contents.Proposals.period := period;
                contents.Proposals.proposals := proposals |} |}.
  
  Definition ballot_case : case Kind.ballot :=
    Case
      {| case.Case.tag := 6; case.Case.name := &quot;ballot&quot; % string;
        case.Case.encoding :=
          Data_encoding.obj4
            (Data_encoding.req None None &quot;source&quot; % string
              Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
            (Data_encoding.req None None &quot;period&quot; % string
              Voting_period_repr.encoding)
            (Data_encoding.req None None &quot;proposal&quot; % string
              Protocol_hash.[S.HASH.encoding])
            (Data_encoding.req None None &quot;ballot&quot; % string
              Vote_repr.ballot_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Ballot _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              'Ballot {|
                contents.Ballot.source := source;
                  contents.Ballot.period := period;
                  contents.Ballot.proposal := proposal;
                  contents.Ballot.ballot := ballot
                  |} := function_parameter in
            (source, period, proposal, ballot);
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(source, period, proposal, ballot) := function_parameter in
            Ballot
              {| contents.Ballot.source := source;
                contents.Ballot.period := period;
                contents.Ballot.proposal := proposal;
                contents.Ballot.ballot := ballot |} |}.
  
  Definition manager_encoding
    : Data_encoding.encoding
      (Signature.Public_key_hash.[S.SPublic_key_hash.t] * Tez_repr.t * Z.t * Z.t
        * Z.t) :=
    Data_encoding.obj5
      (Data_encoding.req None None &quot;source&quot; % string
        Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
      (Data_encoding.req None None &quot;fee&quot; % string Tez_repr.encoding)
      (Data_encoding.req None None &quot;counter&quot; % string
        (Data_encoding.check_size 10 Data_encoding.n))
      (Data_encoding.req None None &quot;gas_limit&quot; % string
        (Data_encoding.check_size 10 Data_encoding.n))
      (Data_encoding.req None None &quot;storage_limit&quot; % string
        (Data_encoding.check_size 10 Data_encoding.n)).
  
  Definition extract {A : Set} (function_parameter : contents (Kind.manager A))
    : Signature.public_key_hash * Tez_repr.tez * counter * Z.t * Z.t :=
    let
      'Manager_operation {|
        contents.Manager_operation.source := source;
          contents.Manager_operation.fee := fee;
          contents.Manager_operation.counter := counter;
          contents.Manager_operation.operation := _;
          contents.Manager_operation.gas_limit := gas_limit;
          contents.Manager_operation.storage_limit := storage_limit
          |} := function_parameter in
    (source, fee, counter, gas_limit, storage_limit).
  
  Definition rebuild {A : Set}
    (function_parameter :
      Signature.public_key_hash * Tez_repr.tez * counter * Z.t * Z.t)
    : manager_operation A -&gt; contents (Kind.manager A) :=
    let '(source, fee, counter, gas_limit, storage_limit) := function_parameter
      in
    fun operation =&gt;
      Manager_operation
        {| contents.Manager_operation.source := source;
          contents.Manager_operation.fee := fee;
          contents.Manager_operation.counter := counter;
          contents.Manager_operation.operation := operation;
          contents.Manager_operation.gas_limit := gas_limit;
          contents.Manager_operation.storage_limit := storage_limit |}.
  
  Definition make_manager_case {A : Set}
    (tag : Z) (function_parameter : Manager_operations.case A)
    : case (Kind.manager A) :=
    let 'Manager_operations.MCase mcase := function_parameter in
    Case
      {| case.Case.tag := tag;
        case.Case.name := Manager_operations.case.MCase.name mcase;
        case.Case.encoding :=
          Data_encoding.merge_objs manager_encoding
            (Manager_operations.case.MCase.encoding mcase);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents
                (Manager_operation
                  ({| contents.Manager_operation.operation := operation |} as op))
              =&gt;
              match
                (Manager_operations.case.MCase.select mcase) (Manager operation)
                with
              | None =&gt; None
              | Some operation =&gt;
                Some
                  (Manager_operation
                    (* ‚ùå Record substitution not handled *)
                    record_substitution)
              end
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            let
              '(Manager_operation {|
                contents.Manager_operation.operation := operation |}) as op :=
              function_parameter in
            ((extract op),
              ((Manager_operations.case.MCase.proj mcase) operation));
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(op, contents) := function_parameter in
            rebuild op ((Manager_operations.case.MCase.inj mcase) contents) |}.
  
  Definition reveal_case : case (Kind.manager Kind.reveal) :=
    make_manager_case 107 Manager_operations.reveal_case.
  
  Definition transaction_case : case (Kind.manager Kind.transaction) :=
    make_manager_case 108 Manager_operations.transaction_case.
  
  Definition origination_case : case (Kind.manager Kind.origination) :=
    make_manager_case 109 Manager_operations.origination_case.
  
  Definition delegation_case : case (Kind.manager Kind.delegation) :=
    make_manager_case 110 Manager_operations.delegation_case.
  
  Definition contents_encoding : Data_encoding.encoding packed_contents :=
    let make {A : Set} (function_parameter : case A)
      : Data_encoding.case packed_contents :=
      let
        'Case {|
          case.Case.tag := tag;
            case.Case.name := name;
            case.Case.encoding := encoding;
            case.Case.select := select;
            case.Case.proj := proj;
            case.Case.inj := inj
            |} := function_parameter in
      __case_value (Data_encoding.Tag tag) name encoding
        (fun o =&gt;
          match select o with
          | None =&gt; None
          | Some o =&gt; Some (proj o)
          end) (fun x =&gt; Contents (inj x)) in
    Pervasives.op_atat
      (let arg := Data_encoding.def &quot;operation.alpha.contents&quot; % string in
      fun eta =&gt; arg None None eta)
      (Data_encoding.union None
        (cons (make endorsement_case)
          (cons (make seed_nonce_revelation_case)
            (cons (make double_endorsement_evidence_case)
              (cons (make double_baking_evidence_case)
                (cons (make activate_account_case)
                  (cons (make proposals_case)
                    (cons (make ballot_case)
                      (cons (make reveal_case)
                        (cons (make transaction_case)
                          (cons (make origination_case)
                            (cons (make delegation_case) [])))))))))))).
  
  Definition contents_list_encoding
    : Data_encoding.encoding packed_contents_list :=
    Data_encoding.conv to_list of_list None
      (Data_encoding.__Variable.__list_value None contents_encoding).
  
  Definition optional_signature_encoding
    : Data_encoding.encoding (option Signature.t) :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        match function_parameter with
        | Some s =&gt; s
        | None =&gt; Signature.zero
        end)
      (fun s =&gt;
        if Signature.equal s Signature.zero then
          None
        else
          Some s) None Signature.encoding.
  
  Definition protocol_data_encoding
    : Data_encoding.encoding packed_protocol_data :=
    Pervasives.op_atat
      (let arg :=
        Data_encoding.def &quot;operation.alpha.contents_and_signature&quot; % string in
      fun eta =&gt; arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =&gt;
          let
            'Operation_data {|
              protocol_data.contents := contents;
                protocol_data.signature := signature
                |} := function_parameter in
          ((Contents_list contents), signature))
        (fun function_parameter =&gt;
          let '(Contents_list contents, signature) := function_parameter in
          Operation_data
            {| protocol_data.contents := contents;
              protocol_data.signature := signature |}) None
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;contents&quot; % string
            contents_list_encoding)
          (Data_encoding.req None None &quot;signature&quot; % string
            optional_signature_encoding))).
  
  Definition operation_encoding : Data_encoding.encoding packed_operation :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          packed_operation.shell := shell;
            packed_operation.protocol_data := protocol_data
            |} := function_parameter in
        (shell, protocol_data))
      (fun function_parameter =&gt;
        let '(shell, protocol_data) := function_parameter in
        {| packed_operation.shell := shell;
          packed_operation.protocol_data := protocol_data |}) None
      (Data_encoding.merge_objs Operation.shell_header_encoding
        protocol_data_encoding).
  
  Definition unsigned_operation_encoding
    : Data_encoding.encoding (Operation.shell_header * packed_contents_list) :=
    Pervasives.op_atat
      (let arg :=
        Data_encoding.def &quot;operation.alpha.unsigned_operation&quot; % string in
      fun eta =&gt; arg None None eta)
      (Data_encoding.merge_objs Operation.shell_header_encoding
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;contents&quot; % string
            contents_list_encoding))).
  
  Definition internal_operation_encoding
    : Data_encoding.encoding packed_internal_operation :=
    Pervasives.op_atat
      (let arg :=
        Data_encoding.def &quot;operation.alpha.internal_operation&quot; % string in
      fun eta =&gt; arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =&gt;
          let
            'Internal_operation {|
              internal_operation.source := source;
                internal_operation.operation := operation;
                internal_operation.nonce := nonce
                |} := function_parameter in
          ((source, nonce), (Manager operation)))
        (fun function_parameter =&gt;
          let '((source, nonce), Manager operation) := function_parameter in
          Internal_operation
            {| internal_operation.source := source;
              internal_operation.operation := operation;
              internal_operation.nonce := nonce |}) None
        (Data_encoding.merge_objs
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;source&quot; % string
              Contract_repr.encoding)
            (Data_encoding.req None None &quot;nonce&quot; % string Data_encoding.uint16))
          Manager_operations.encoding)).
End Encoding.

Definition encoding : Data_encoding.encoding packed_operation :=
  Encoding.operation_encoding.

Definition contents_encoding : Data_encoding.encoding packed_contents :=
  Encoding.contents_encoding.

Definition contents_list_encoding
  : Data_encoding.encoding packed_contents_list :=
  Encoding.contents_list_encoding.

Definition protocol_data_encoding
  : Data_encoding.encoding packed_protocol_data :=
  Encoding.protocol_data_encoding.

Definition unsigned_operation_encoding
  : Data_encoding.encoding (Operation.shell_header * packed_contents_list) :=
  Encoding.unsigned_operation_encoding.

Definition internal_operation_encoding
  : Data_encoding.encoding packed_internal_operation :=
  Encoding.internal_operation_encoding.

Definition raw {A : Set} (function_parameter : operation A) : Operation.t :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      (Operation_data protocol_data) in
  {| Operation.t.shell := shell; Operation.t.proto := proto |}.

Definition acceptable_passes (op : packed_operation) : list Z :=
  let 'Operation_data protocol_data := packed_operation.protocol_data op in
  match protocol_data.contents protocol_data with
  | Single (Endorsement _) =&gt; cons 0 []
  | Single (Proposals _) =&gt; cons 1 []
  | Single (Ballot _) =&gt; cons 1 []
  | Single (Seed_nonce_revelation _) =&gt; cons 2 []
  | Single (Double_endorsement_evidence _) =&gt; cons 2 []
  | Single (Double_baking_evidence _) =&gt; cons 2 []
  | Single (Activate_account _) =&gt; cons 2 []
  | Single (Manager_operation _) =&gt; cons 3 []
  | Cons _ _ =&gt; cons 3 []
  end.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition check_signature_sync {A : Set}
  (key : Signature.Public_key.[S.SPublic_key.t])
  (chain_id : Chain_id.[S.HASH.t]) (function_parameter : operation A)
  : Error_monad.tzresult unit :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  let check
    (watermark : Signature.watermark) (contents : packed_contents_list)
    (signature : Signature.t)
    : Pervasives.result unit (list Error_monad.__error) :=
    let unsigned_operation :=
      Data_encoding.Binary.to_bytes_exn unsigned_operation_encoding
        (shell, contents) in
    if Signature.check (Some watermark) key signature unsigned_operation then
      Pervasives.Ok tt
    else
      Error_monad.__error_value extensible_type_value in
  match
    ((protocol_data.contents protocol_data),
      (protocol_data.signature protocol_data)) with
  | (Single _, None) =&gt; Error_monad.__error_value extensible_type_value
  | (Cons _ _, None) =&gt; Error_monad.__error_value extensible_type_value
  | ((Single (Endorsement _)) as contents, Some signature) =&gt;
    check (Signature.Endorsement chain_id) (Contents_list contents) signature
  | ((Single _) as contents, Some signature) =&gt;
    check Signature.Generic_operation (Contents_list contents) signature
  | ((Cons _ _) as contents, Some signature) =&gt;
    check Signature.Generic_operation (Contents_list contents) signature
  end.

Definition check_signature {A : Set}
  (pk : Signature.Public_key.[S.SPublic_key.t]) (chain_id : Chain_id.[S.HASH.t])
  (op : operation A) : Lwt.t (Error_monad.tzresult unit) :=
  Lwt.__return (check_signature_sync pk chain_id op).

Definition hash_raw : Operation.t -&gt; Operation_hash.[S.HASH.t] :=
  Operation.__hash_value.

Definition __hash_value {A : Set} (o : operation A)
  : Operation_hash.[S.HASH.t] :=
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      (Operation_data (operation.protocol_data o)) in
  Operation.__hash_value
    {| raw.shell := operation.shell o; raw.proto := proto |}.

Definition hash_packed (o : packed_operation) : Operation_hash.[S.HASH.t] :=
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      (packed_operation.protocol_data o) in
  Operation.__hash_value
    {| raw.shell := packed_operation.shell o; raw.proto := proto |}.

Reserved Notation &quot;'eq&quot;.

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where &quot;'eq&quot; := (fun (a b : Set) =&gt; eq_gadt).

Definition eq := 'eq.

Definition equal_manager_operation_kind {a b : Set}
  (op1 : manager_operation a) (op2 : manager_operation b) : option (eq a b) :=
  match (op1, op2) with
  | (Reveal _, Reveal _) =&gt; Some Eq
  | (Reveal _, _) =&gt; None
  | (Transaction _, Transaction _) =&gt; Some Eq
  | (Transaction _, _) =&gt; None
  | (Origination _, Origination _) =&gt; Some Eq
  | (Origination _, _) =&gt; None
  | (Delegation _, Delegation _) =&gt; Some Eq
  | (Delegation _, _) =&gt; None
  end.

Definition equal_contents_kind {a b : Set} (op1 : contents a) (op2 : contents b)
  : option (eq a b) :=
  match (op1, op2) with
  | (Endorsement _, Endorsement _) =&gt; Some Eq
  | (Endorsement _, _) =&gt; None
  | (Seed_nonce_revelation _, Seed_nonce_revelation _) =&gt; Some Eq
  | (Seed_nonce_revelation _, _) =&gt; None
  | (Double_endorsement_evidence _, Double_endorsement_evidence _) =&gt; Some Eq
  | (Double_endorsement_evidence _, _) =&gt; None
  | (Double_baking_evidence _, Double_baking_evidence _) =&gt; Some Eq
  | (Double_baking_evidence _, _) =&gt; None
  | (Activate_account _, Activate_account _) =&gt; Some Eq
  | (Activate_account _, _) =&gt; None
  | (Proposals _, Proposals _) =&gt; Some Eq
  | (Proposals _, _) =&gt; None
  | (Ballot _, Ballot _) =&gt; Some Eq
  | (Ballot _, _) =&gt; None
  | (Manager_operation op1, Manager_operation op2) =&gt;
    match
      equal_manager_operation_kind (contents.Manager_operation.operation op1)
        (contents.Manager_operation.operation op2) with
    | None =&gt; None
    | Some Eq =&gt; Some Eq
    end
  | (Manager_operation _, _) =&gt; None
  end.

Fixpoint equal_contents_kind_list {a b : Set}
  (op1 : contents_list a) (op2 : contents_list b) {struct op1}
  : option (eq a b) :=
  match (op1, op2) with
  | (Single op1, Single op2) =&gt; equal_contents_kind op1 op2
  | (Single _, Cons _ _) =&gt; None
  | (Cons _ _, Single _) =&gt; None
  | (Cons op1 ops1, Cons op2 ops2) =&gt;
    match equal_contents_kind op1 op2 with
    | None =&gt; None
    | Some Eq =&gt;
      match equal_contents_kind_list ops1 ops2 with
      | None =&gt; None
      | Some Eq =&gt; Some Eq
      end
    end
  end.

Definition equal {a b : Set} (op1 : operation a) (op2 : operation b)
  : option (eq a b) :=
  if
    Pervasives.not
      (Operation_hash.[S.HASH.equal] (__hash_value op1) (__hash_value op2)) then
    None
  else
    equal_contents_kind_list
      (protocol_data.contents (operation.protocol_data op1))
      (protocol_data.contents (operation.protocol_data op2)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="operation_repr.mli">
  <div class="col-md-6">
    <a href="#operation_repr.mli"><code>operation_repr.mli</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Operations *)

module Kind : sig
  type seed_nonce_revelation = Seed_nonce_revelation_kind

  type double_endorsement_evidence = Double_endorsement_evidence_kind

  type double_baking_evidence = Double_baking_evidence_kind

  type activate_account = Activate_account_kind

  type endorsement = Endorsement_kind

  type proposals = Proposals_kind

  type ballot = Ballot_kind

  type reveal = Reveal_kind

  type transaction = Transaction_kind

  type origination = Origination_kind

  type delegation = Delegation_kind

  type 'a manager =
    | Reveal_manager_kind : reveal manager
    | Transaction_manager_kind : transaction manager
    | Origination_manager_kind : origination manager
    | Delegation_manager_kind : delegation manager
end

type raw = Operation.t = {shell : Operation.shell_header; proto : MBytes.t}

val raw_encoding : raw Data_encoding.t

type 'kind operation = {
  shell : Operation.shell_header;
  protocol_data : 'kind protocol_data;
}

and 'kind protocol_data = {
  contents : 'kind contents_list;
  signature : Signature.t option;
}

and _ contents_list =
  | Single : 'kind contents -&gt; 'kind contents_list
  | Cons :
      'kind Kind.manager contents * 'rest Kind.manager contents_list
      -&gt; ('kind * 'rest) Kind.manager contents_list

and _ contents =
  | Endorsement : {level : Raw_level_repr.t} -&gt; Kind.endorsement contents
  | Seed_nonce_revelation : {
      level : Raw_level_repr.t;
      nonce : Seed_repr.nonce;
    }
      -&gt; Kind.seed_nonce_revelation contents
  | Double_endorsement_evidence : {
      op1 : Kind.endorsement operation;
      op2 : Kind.endorsement operation;
    }
      -&gt; Kind.double_endorsement_evidence contents
  | Double_baking_evidence : {
      bh1 : Block_header_repr.t;
      bh2 : Block_header_repr.t;
    }
      -&gt; Kind.double_baking_evidence contents
  | Activate_account : {
      id : Ed25519.Public_key_hash.t;
      activation_code : Blinded_public_key_hash.activation_code;
    }
      -&gt; Kind.activate_account contents
  | Proposals : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposals : Protocol_hash.t list;
    }
      -&gt; Kind.proposals contents
  | Ballot : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposal : Protocol_hash.t;
      ballot : Vote_repr.ballot;
    }
      -&gt; Kind.ballot contents
  | Manager_operation : {
      source : Signature.Public_key_hash.t;
      fee : Tez_repr.tez;
      counter : counter;
      operation : 'kind manager_operation;
      gas_limit : Z.t;
      storage_limit : Z.t;
    }
      -&gt; 'kind Kind.manager contents

and _ manager_operation =
  | Reveal : Signature.Public_key.t -&gt; Kind.reveal manager_operation
  | Transaction : {
      amount : Tez_repr.tez;
      parameters : Script_repr.lazy_expr;
      entrypoint : string;
      destination : Contract_repr.contract;
    }
      -&gt; Kind.transaction manager_operation
  | Origination : {
      delegate : Signature.Public_key_hash.t option;
      script : Script_repr.t;
      credit : Tez_repr.tez;
      preorigination : Contract_repr.t option;
    }
      -&gt; Kind.origination manager_operation
  | Delegation :
      Signature.Public_key_hash.t option
      -&gt; Kind.delegation manager_operation

and counter = Z.t

type 'kind internal_operation = {
  source : Contract_repr.contract;
  operation : 'kind manager_operation;
  nonce : int;
}

type packed_manager_operation =
  | Manager : 'kind manager_operation -&gt; packed_manager_operation

type packed_contents = Contents : 'kind contents -&gt; packed_contents

type packed_contents_list =
  | Contents_list : 'kind contents_list -&gt; packed_contents_list

val of_list : packed_contents list -&gt; packed_contents_list

val to_list : packed_contents_list -&gt; packed_contents list

type packed_protocol_data =
  | Operation_data : 'kind protocol_data -&gt; packed_protocol_data

type packed_operation = {
  shell : Operation.shell_header;
  protocol_data : packed_protocol_data;
}

val pack : 'kind operation -&gt; packed_operation

type packed_internal_operation =
  | Internal_operation : 'kind internal_operation -&gt; packed_internal_operation

val manager_kind : 'kind manager_operation -&gt; 'kind Kind.manager

val encoding : packed_operation Data_encoding.t

val contents_encoding : packed_contents Data_encoding.t

val contents_list_encoding : packed_contents_list Data_encoding.t

val protocol_data_encoding : packed_protocol_data Data_encoding.t

val unsigned_operation_encoding :
  (Operation.shell_header * packed_contents_list) Data_encoding.t

val raw : _ operation -&gt; raw

val hash_raw : raw -&gt; Operation_hash.t

val hash : _ operation -&gt; Operation_hash.t

val hash_packed : packed_operation -&gt; Operation_hash.t

val acceptable_passes : packed_operation -&gt; int list

<abbr class="mark-error" title="Extensible types are not handled.">type error += Missing_signature</abbr> (* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

val check_signature :
  Signature.Public_key.t -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult Lwt.t

val check_signature_sync :
  Signature.Public_key.t -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult

val internal_operation_encoding : packed_internal_operation Data_encoding.t

type ('a, 'b) eq = Eq : ('a, 'a) eq

val equal : 'a operation -&gt; 'b operation -&gt; ('a, 'b) eq option

module Encoding : sig
  type 'b case =
    | Case : {
        tag : int;
        name : string;
        encoding : 'a Data_encoding.t;
        select : packed_contents -&gt; 'b contents option;
        proj : 'b contents -&gt; 'a;
        inj : 'a -&gt; 'b contents;
      }
        -&gt; 'b case

  val endorsement_case : Kind.endorsement case

  val seed_nonce_revelation_case : Kind.seed_nonce_revelation case

  val double_endorsement_evidence_case : Kind.double_endorsement_evidence case

  val double_baking_evidence_case : Kind.double_baking_evidence case

  val activate_account_case : Kind.activate_account case

  val proposals_case : Kind.proposals case

  val ballot_case : Kind.ballot case

  val reveal_case : Kind.reveal Kind.manager case

  val transaction_case : Kind.transaction Kind.manager case

  val origination_case : Kind.origination Kind.manager case

  val delegation_case : Kind.delegation Kind.manager case

  module Manager_operations : sig
    type 'b case =
      | MCase : {
          tag : int;
          name : string;
          encoding : 'a Data_encoding.t;
          select : packed_manager_operation -&gt; 'kind manager_operation option;
          proj : 'kind manager_operation -&gt; 'a;
          inj : 'a -&gt; 'kind manager_operation;
        }
          -&gt; 'kind case

    val reveal_case : Kind.reveal case

    val transaction_case : Kind.transaction case

    val origination_case : Kind.origination case

    val delegation_case : Kind.delegation case
  end
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#operation_repr.mli"><code>Operation_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Block_header_repr.
Require Tezos.Contract_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Reserved Notation &quot;'manager&quot;.
  
  Inductive manager_gadt : Set :=
  | Reveal_manager_kind : manager_gadt
  | Transaction_manager_kind : manager_gadt
  | Origination_manager_kind : manager_gadt
  | Delegation_manager_kind : manager_gadt
  
  where &quot;'manager&quot; := (fun (a : Set) =&gt; manager_gadt).
  
  Definition manager := 'manager.
End Kind.

Module raw.
  Record record := {
    shell : Operation.shell_header;
    proto : MBytes.t }.
End raw.
Definition raw := raw.record.

Parameter raw_encoding : Data_encoding.t raw.

Module contents.
  Module Endorsement.
    Record record {level : Set} := {
      level : level }.
    Arguments record : clear implicits.
  End Endorsement.
  Definition Endorsement := Endorsement.record.
  
  Module Seed_nonce_revelation.
    Record record {level nonce : Set} := {
      level : level;
      nonce : nonce }.
    Arguments record : clear implicits.
  End Seed_nonce_revelation.
  Definition Seed_nonce_revelation := Seed_nonce_revelation.record.
  
  Module Double_endorsement_evidence.
    Record record {op1 op2 : Set} := {
      op1 : op1;
      op2 : op2 }.
    Arguments record : clear implicits.
  End Double_endorsement_evidence.
  Definition Double_endorsement_evidence := Double_endorsement_evidence.record.
  
  Module Double_baking_evidence.
    Record record {bh1 bh2 : Set} := {
      bh1 : bh1;
      bh2 : bh2 }.
    Arguments record : clear implicits.
  End Double_baking_evidence.
  Definition Double_baking_evidence := Double_baking_evidence.record.
  
  Module Activate_account.
    Record record {id activation_code : Set} := {
      id : id;
      activation_code : activation_code }.
    Arguments record : clear implicits.
  End Activate_account.
  Definition Activate_account := Activate_account.record.
  
  Module Proposals.
    Record record {source period proposals : Set} := {
      source : source;
      period : period;
      proposals : proposals }.
    Arguments record : clear implicits.
  End Proposals.
  Definition Proposals := Proposals.record.
  
  Module Ballot.
    Record record {source period proposal ballot : Set} := {
      source : source;
      period : period;
      proposal : proposal;
      ballot : ballot }.
    Arguments record : clear implicits.
  End Ballot.
  Definition Ballot := Ballot.record.
  
  Module Manager_operation.
    Record record {source fee counter operation gas_limit storage_limit : Set} := {
      source : source;
      fee : fee;
      counter : counter;
      operation : operation;
      gas_limit : gas_limit;
      storage_limit : storage_limit }.
    Arguments record : clear implicits.
  End Manager_operation.
  Definition Manager_operation := Manager_operation.record.
End contents.

Module manager_operation.
  Module Transaction.
    Record record {amount parameters entrypoint destination : Set} := {
      amount : amount;
      parameters : parameters;
      entrypoint : entrypoint;
      destination : destination }.
    Arguments record : clear implicits.
  End Transaction.
  Definition Transaction := Transaction.record.
  
  Module Origination.
    Record record {delegate script credit preorigination : Set} := {
      delegate : delegate;
      script : script;
      credit : credit;
      preorigination : preorigination }.
    Arguments record : clear implicits.
  End Origination.
  Definition Origination := Origination.record.
End manager_operation.

Reserved Notation &quot;'operation&quot;.
Reserved Notation &quot;'protocol_data&quot;.
Reserved Notation &quot;'contents_list&quot;.
Reserved Notation &quot;'contents&quot;.
Reserved Notation &quot;'manager_operation&quot;.
Reserved Notation &quot;'counter&quot;.

Module protocol_data.
  Record record {contents signature : Set} := {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Module operation.
  Record record {shell protocol_data : Set} := {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
End operation.
Definition operation_skeleton := operation.record.

Inductive contents_list_gadt : Set :=
| Single : forall {kind : Set}, 'contents kind -&gt; contents_list_gadt
| Cons : forall {kind : Set},
  'contents (Kind.manager kind) -&gt; contents_list_gadt -&gt; contents_list_gadt

with contents_gadt : Set :=
| Endorsement : contents.Endorsement Raw_level_repr.t -&gt; contents_gadt
| Seed_nonce_revelation :
  contents.Seed_nonce_revelation Raw_level_repr.t Seed_repr.nonce -&gt;
  contents_gadt
| Double_endorsement_evidence :
  contents.Double_endorsement_evidence ('operation Kind.endorsement)
    ('operation Kind.endorsement) -&gt; contents_gadt
| Double_baking_evidence :
  contents.Double_baking_evidence Block_header_repr.t Block_header_repr.t -&gt;
  contents_gadt
| Activate_account :
  contents.Activate_account
    Ed25519.[S.SIGNATURE.Public_key_hash].(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code -&gt; contents_gadt
| Proposals :
  contents.Proposals Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Voting_period_repr.t (list Protocol_hash.[S.HASH.t]) -&gt; contents_gadt
| Ballot :
  contents.Ballot Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Voting_period_repr.t Protocol_hash.[S.HASH.t] Vote_repr.ballot -&gt;
  contents_gadt
| Manager_operation : forall {kind : Set},
  contents.Manager_operation Signature.Public_key_hash.[S.SPublic_key_hash.t]
    Tez_repr.tez 'counter ('manager_operation kind) Z.t Z.t -&gt; contents_gadt

with manager_operation_gadt : Set :=
| Reveal : Signature.Public_key.[S.SPublic_key.t] -&gt; manager_operation_gadt
| Transaction :
  manager_operation.Transaction Tez_repr.tez Script_repr.lazy_expr string
    Contract_repr.contract -&gt; manager_operation_gadt
| Origination :
  manager_operation.Origination
    (option Signature.Public_key_hash.[S.SPublic_key_hash.t]) Script_repr.t
    Tez_repr.tez (option Contract_repr.t) -&gt; manager_operation_gadt
| Delegation :
  option Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  manager_operation_gadt

where &quot;'operation&quot; := (fun (kind : Set) =&gt;
  operation_skeleton Operation.shell_header ('protocol_data kind))
and &quot;'protocol_data&quot; := (fun (kind : Set) =&gt;
  protocol_data_skeleton ('contents_list kind) (option Signature.t))
and &quot;'contents_list&quot; := (fun (_ : Set) =&gt; contents_list_gadt)
and &quot;'contents&quot; := (fun (_ : Set) =&gt; contents_gadt)
and &quot;'manager_operation&quot; := (fun (_ : Set) =&gt; manager_operation_gadt)
and &quot;'counter&quot; := (Z.t).

Definition operation := 'operation.
Definition protocol_data := 'protocol_data.
Definition contents_list := 'contents_list.
Definition contents := 'contents.
Definition manager_operation := 'manager_operation.
Definition counter := 'counter.

Module internal_operation.
  Record record {kind : Set} := {
    source : Contract_repr.contract;
    operation : manager_operation kind;
    nonce : Z }.
  Arguments record : clear implicits.
End internal_operation.
Definition internal_operation := internal_operation.record.

Reserved Notation &quot;'packed_manager_operation&quot;.

Inductive packed_manager_operation_gadt : Set :=
| Manager : forall {kind : Set},
  manager_operation kind -&gt; packed_manager_operation_gadt

where &quot;'packed_manager_operation&quot; := (packed_manager_operation_gadt).

Definition packed_manager_operation := 'packed_manager_operation.

Reserved Notation &quot;'packed_contents&quot;.

Inductive packed_contents_gadt : Set :=
| Contents : forall {kind : Set}, contents kind -&gt; packed_contents_gadt

where &quot;'packed_contents&quot; := (packed_contents_gadt).

Definition packed_contents := 'packed_contents.

Reserved Notation &quot;'packed_contents_list&quot;.

Inductive packed_contents_list_gadt : Set :=
| Contents_list : forall {kind : Set},
  contents_list kind -&gt; packed_contents_list_gadt

where &quot;'packed_contents_list&quot; := (packed_contents_list_gadt).

Definition packed_contents_list := 'packed_contents_list.

Parameter of_list : list packed_contents -&gt; packed_contents_list.

Parameter to_list : packed_contents_list -&gt; list packed_contents.

Reserved Notation &quot;'packed_protocol_data&quot;.

Inductive packed_protocol_data_gadt : Set :=
| Operation_data : forall {kind : Set},
  protocol_data kind -&gt; packed_protocol_data_gadt

where &quot;'packed_protocol_data&quot; := (packed_protocol_data_gadt).

Definition packed_protocol_data := 'packed_protocol_data.

Module packed_operation.
  Record record := {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
End packed_operation.
Definition packed_operation := packed_operation.record.

Parameter pack : forall {kind : Set}, operation kind -&gt; packed_operation.

Reserved Notation &quot;'packed_internal_operation&quot;.

Inductive packed_internal_operation_gadt : Set :=
| Internal_operation : forall {kind : Set},
  internal_operation kind -&gt; packed_internal_operation_gadt

where &quot;'packed_internal_operation&quot; := (packed_internal_operation_gadt).

Definition packed_internal_operation := 'packed_internal_operation.

Parameter manager_kind : forall {kind : Set},
  manager_operation kind -&gt; Kind.manager kind.

Parameter encoding : Data_encoding.t packed_operation.

Parameter contents_encoding : Data_encoding.t packed_contents.

Parameter contents_list_encoding : Data_encoding.t packed_contents_list.

Parameter protocol_data_encoding : Data_encoding.t packed_protocol_data.

Parameter unsigned_operation_encoding :
  Data_encoding.t (Operation.shell_header * packed_contents_list).

Parameter raw : forall {A : Set}, operation A -&gt; raw.

Parameter hash_raw : raw -&gt; Operation_hash.[S.HASH.t].

Parameter __hash_value : forall {A : Set},
  operation A -&gt; Operation_hash.[S.HASH.t].

Parameter hash_packed : packed_operation -&gt; Operation_hash.[S.HASH.t].

Parameter acceptable_passes : packed_operation -&gt; list Z.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter check_signature : forall {A : Set},
  Signature.Public_key.[S.SPublic_key.t] -&gt; Chain_id.[S.HASH.t] -&gt;
  operation A -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter check_signature_sync : forall {A : Set},
  Signature.Public_key.[S.SPublic_key.t] -&gt; Chain_id.[S.HASH.t] -&gt;
  operation A -&gt; Error_monad.tzresult unit.

Parameter internal_operation_encoding :
  Data_encoding.t packed_internal_operation.

Reserved Notation &quot;'eq&quot;.

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where &quot;'eq&quot; := (fun (a b : Set) =&gt; eq_gadt).

Definition eq := 'eq.

Parameter equal : forall {a b : Set},
  operation a -&gt; operation b -&gt; option (eq a b).

Module Encoding.
  Module case.
    Module Case.
      Record record {tag name encoding select proj inj : Set} := {
        tag : tag;
        name : name;
        encoding : encoding;
        select : select;
        proj : proj;
        inj : inj }.
      Arguments record : clear implicits.
    End Case.
    Definition Case := Case.record.
  End case.
  
  Reserved Notation &quot;'case&quot;.
  
  Inductive case_gadt : Set :=
  | Case : forall {a b : Set},
    case.Case Z string (Data_encoding.t a)
      (packed_contents -&gt; option (contents b)) (contents b -&gt; a)
      (a -&gt; contents b) -&gt; case_gadt
  
  where &quot;'case&quot; := (fun (b : Set) =&gt; case_gadt).
  
  Definition case := 'case.
  
  Parameter endorsement_case : case Kind.endorsement.
  
  Parameter seed_nonce_revelation_case : case Kind.seed_nonce_revelation.
  
  Parameter double_endorsement_evidence_case :
    case Kind.double_endorsement_evidence.
  
  Parameter double_baking_evidence_case : case Kind.double_baking_evidence.
  
  Parameter activate_account_case : case Kind.activate_account.
  
  Parameter proposals_case : case Kind.proposals.
  
  Parameter ballot_case : case Kind.ballot.
  
  Parameter reveal_case : case (Kind.manager Kind.reveal).
  
  Parameter transaction_case : case (Kind.manager Kind.transaction).
  
  Parameter origination_case : case (Kind.manager Kind.origination).
  
  Parameter delegation_case : case (Kind.manager Kind.delegation).
  
  Module Manager_operations.
    Module case.
      Module MCase.
        Record record {tag name encoding select proj inj : Set} := {
          tag : tag;
          name : name;
          encoding : encoding;
          select : select;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
      End MCase.
      Definition MCase := MCase.record.
    End case.
    
    Reserved Notation &quot;'case&quot;.
    
    Inductive case_gadt : Set :=
    | MCase : forall {a kind : Set},
      case.MCase Z string (Data_encoding.t a)
        (packed_manager_operation -&gt; option (manager_operation kind))
        (manager_operation kind -&gt; a) (a -&gt; manager_operation kind) -&gt; case_gadt
    
    where &quot;'case&quot; := (fun (b : Set) =&gt; case_gadt).
    
    Definition case := 'case.
    
    Parameter reveal_case : case Kind.reveal.
    
    Parameter transaction_case : case Kind.transaction.
    
    Parameter origination_case : case Kind.origination.
    
    Parameter delegation_case : case Kind.delegation.
  End Manager_operations.
End Encoding.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="parameters_repr.ml">
  <div class="col-md-6">
    <a href="#parameters_repr.ml"><code>parameters_repr.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type bootstrap_account = {
  public_key_hash : Signature.Public_key_hash.t;
  public_key : Signature.Public_key.t option;
  amount : Tez_repr.t;
}

type bootstrap_contract = {
  delegate : Signature.Public_key_hash.t;
  amount : Tez_repr.t;
  script : Script_repr.t;
}

type t = {
  bootstrap_accounts : bootstrap_account list;
  bootstrap_contracts : bootstrap_contract list;
  commitments : Commitment_repr.t list;
  constants : Constants_repr.parametric;
  security_deposit_ramp_up_cycles : int option;
  no_reward_cycles : int option;
}

let bootstrap_account_encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;Public_key_known&quot;
        (tup2 Signature.Public_key.encoding Tez_repr.encoding)
        (function
          | {public_key_hash; public_key = Some public_key; amount} -&gt;
              <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (
                Signature.Public_key_hash.equal
                  (Signature.Public_key.hash public_key)
                  public_key_hash ) ;
              Some (public_key, amount)</abbr>
          | {public_key = None} -&gt;
              None)
        (fun (public_key, amount) -&gt;
          {
            public_key = Some public_key;
            public_key_hash = Signature.Public_key.hash public_key;
            amount;
          });
      case
        (Tag 1)
        ~title:&quot;Public_key_unknown&quot;
        (tup2 Signature.Public_key_hash.encoding Tez_repr.encoding)
        (function
          | {public_key_hash; public_key = None; amount} -&gt;
              Some (public_key_hash, amount)
          | {public_key = Some _} -&gt;
              None)
        (fun (public_key_hash, amount) -&gt;
          {public_key = None; public_key_hash; amount}) ]

let bootstrap_contract_encoding =
  let open Data_encoding in
  conv
    (fun {delegate; amount; script} -&gt; (delegate, amount, script))
    (fun (delegate, amount, script) -&gt; {delegate; amount; script})
    (obj3
       (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
       (req &quot;amount&quot; Tez_repr.encoding)
       (req &quot;script&quot; Script_repr.encoding))

let encoding =
  let open Data_encoding in
  conv
    (fun { bootstrap_accounts;
           bootstrap_contracts;
           commitments;
           constants;
           security_deposit_ramp_up_cycles;
           no_reward_cycles } -&gt;
      ( ( bootstrap_accounts,
          bootstrap_contracts,
          commitments,
          security_deposit_ramp_up_cycles,
          no_reward_cycles ),
        constants ))
    (fun ( ( bootstrap_accounts,
             bootstrap_contracts,
             commitments,
             security_deposit_ramp_up_cycles,
             no_reward_cycles ),
           constants ) -&gt;
      {
        bootstrap_accounts;
        bootstrap_contracts;
        commitments;
        constants;
        security_deposit_ramp_up_cycles;
        no_reward_cycles;
      })
    (merge_objs
       (obj5
          (req &quot;bootstrap_accounts&quot; (list bootstrap_account_encoding))
          (dft &quot;bootstrap_contracts&quot; (list bootstrap_contract_encoding) [])
          (dft &quot;commitments&quot; (list Commitment_repr.encoding) [])
          (opt &quot;security_deposit_ramp_up_cycles&quot; int31)
          (opt &quot;no_reward_cycles&quot; int31))
       Constants_repr.parametric_encoding)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#parameters_repr.ml"><code>Parameters_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Commitment_repr.
Require Tezos.Constants_repr.
Require Tezos.Script_repr.
Require Tezos.Tez_repr.

Module bootstrap_account.
  Record record := {
    public_key_hash : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    public_key : option Signature.Public_key.[S.SPublic_key.t];
    amount : Tez_repr.t }.
End bootstrap_account.
Definition bootstrap_account := bootstrap_account.record.

Module bootstrap_contract.
  Record record := {
    delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    amount : Tez_repr.t;
    script : Script_repr.t }.
End bootstrap_contract.
Definition bootstrap_contract := bootstrap_contract.record.

Module t.
  Record record := {
    bootstrap_accounts : list bootstrap_account;
    bootstrap_contracts : list bootstrap_contract;
    commitments : list Commitment_repr.t;
    constants : Constants_repr.parametric;
    security_deposit_ramp_up_cycles : option Z;
    no_reward_cycles : option Z }.
End t.
Definition t := t.record.

Definition bootstrap_account_encoding
  : Data_encoding.encoding bootstrap_account :=
  Data_encoding.union None
    (cons
      (Data_encoding.__case_value &quot;Public_key_known&quot; % string None
        (Data_encoding.Tag 0)
        (Data_encoding.tup2 Signature.Public_key.[S.SPublic_key.encoding]
          Tez_repr.encoding)
        (fun function_parameter =&gt;
          match function_parameter with
          | {|
            bootstrap_account.public_key_hash := public_key_hash;
              bootstrap_account.public_key := Some public_key;
              bootstrap_account.amount := amount
              |} =&gt;
            (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ‚ùå instruction_sequence &quot;;&quot; *)
            Some (public_key, amount)
          | {| bootstrap_account.public_key := None |} =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(public_key, amount) := function_parameter in
          {|
            bootstrap_account.public_key_hash :=
              Signature.Public_key.[S.SPublic_key.__hash_value] public_key;
            bootstrap_account.public_key := Some public_key;
            bootstrap_account.amount := amount |}))
      (cons
        (Data_encoding.__case_value &quot;Public_key_unknown&quot; % string None
          (Data_encoding.Tag 1)
          (Data_encoding.tup2
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
            Tez_repr.encoding)
          (fun function_parameter =&gt;
            match function_parameter with
            | {|
              bootstrap_account.public_key_hash := public_key_hash;
                bootstrap_account.public_key := None;
                bootstrap_account.amount := amount
                |} =&gt; Some (public_key_hash, amount)
            | {| bootstrap_account.public_key := Some _ |} =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(public_key_hash, amount) := function_parameter in
            {| bootstrap_account.public_key_hash := public_key_hash;
              bootstrap_account.public_key := None;
              bootstrap_account.amount := amount |})) [])).

Definition bootstrap_contract_encoding
  : Data_encoding.encoding bootstrap_contract :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        bootstrap_contract.delegate := delegate;
          bootstrap_contract.amount := amount;
          bootstrap_contract.script := script
          |} := function_parameter in
      (delegate, amount, script))
    (fun function_parameter =&gt;
      let '(delegate, amount, script) := function_parameter in
      {| bootstrap_contract.delegate := delegate;
        bootstrap_contract.amount := amount; bootstrap_contract.script := script
        |}) None
    (Data_encoding.obj3
      (Data_encoding.req None None &quot;delegate&quot; % string
        Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
      (Data_encoding.req None None &quot;amount&quot; % string Tez_repr.encoding)
      (Data_encoding.req None None &quot;script&quot; % string Script_repr.encoding)).

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        t.bootstrap_accounts := bootstrap_accounts;
          t.bootstrap_contracts := bootstrap_contracts;
          t.commitments := commitments;
          t.constants := constants;
          t.security_deposit_ramp_up_cycles := security_deposit_ramp_up_cycles;
          t.no_reward_cycles := no_reward_cycles
          |} := function_parameter in
      ((bootstrap_accounts, bootstrap_contracts, commitments,
        security_deposit_ramp_up_cycles, no_reward_cycles), constants))
    (fun function_parameter =&gt;
      let
        '((bootstrap_accounts, bootstrap_contracts, commitments,
          security_deposit_ramp_up_cycles, no_reward_cycles), constants) :=
        function_parameter in
      {| t.bootstrap_accounts := bootstrap_accounts;
        t.bootstrap_contracts := bootstrap_contracts;
        t.commitments := commitments; t.constants := constants;
        t.security_deposit_ramp_up_cycles := security_deposit_ramp_up_cycles;
        t.no_reward_cycles := no_reward_cycles |}) None
    (Data_encoding.merge_objs
      (Data_encoding.obj5
        (Data_encoding.req None None &quot;bootstrap_accounts&quot; % string
          (Data_encoding.__list_value None bootstrap_account_encoding))
        (Data_encoding.dft None None &quot;bootstrap_contracts&quot; % string
          (Data_encoding.__list_value None bootstrap_contract_encoding) [])
        (Data_encoding.dft None None &quot;commitments&quot; % string
          (Data_encoding.__list_value None Commitment_repr.encoding) [])
        (Data_encoding.opt None None &quot;security_deposit_ramp_up_cycles&quot; % string
          Data_encoding.int31)
        (Data_encoding.opt None None &quot;no_reward_cycles&quot; % string
          Data_encoding.int31)) Constants_repr.parametric_encoding).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="parameters_repr.mli">
  <div class="col-md-6">
    <a href="#parameters_repr.mli"><code>parameters_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type bootstrap_account = {
  public_key_hash : Signature.Public_key_hash.t;
  public_key : Signature.Public_key.t option;
  amount : Tez_repr.t;
}

type bootstrap_contract = {
  delegate : Signature.Public_key_hash.t;
  amount : Tez_repr.t;
  script : Script_repr.t;
}

type t = {
  bootstrap_accounts : bootstrap_account list;
  bootstrap_contracts : bootstrap_contract list;
  commitments : Commitment_repr.t list;
  constants : Constants_repr.parametric;
  security_deposit_ramp_up_cycles : int option;
  no_reward_cycles : int option;
}

val encoding : t Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#parameters_repr.mli"><code>Parameters_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Commitment_repr.
Require Tezos.Constants_repr.
Require Tezos.Script_repr.
Require Tezos.Tez_repr.

Module bootstrap_account.
  Record record := {
    public_key_hash : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    public_key : option Signature.Public_key.[S.SPublic_key.t];
    amount : Tez_repr.t }.
End bootstrap_account.
Definition bootstrap_account := bootstrap_account.record.

Module bootstrap_contract.
  Record record := {
    delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
    amount : Tez_repr.t;
    script : Script_repr.t }.
End bootstrap_contract.
Definition bootstrap_contract := bootstrap_contract.record.

Module t.
  Record record := {
    bootstrap_accounts : list bootstrap_account;
    bootstrap_contracts : list bootstrap_contract;
    commitments : list Commitment_repr.t;
    constants : Constants_repr.parametric;
    security_deposit_ramp_up_cycles : option Z;
    no_reward_cycles : option Z }.
End t.
Definition t := t.record.

Parameter encoding : Data_encoding.t t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="period_repr.ml">
  <div class="col-md-6">
    <a href="#period_repr.ml"><code>period_repr.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Int64.t

type period = t

include (Compare.Int64 : Compare.S with type t := t)

let encoding = Data_encoding.int64

let rpc_arg = RPC_arg.int64

let pp ppf v = Format.fprintf ppf &quot;%Ld&quot; v

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += (* `Permanent *)
                Malformed_period | Invalid_arg</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  (* Malformed period *)
  register_error_kind
    `Permanent
    ~id:&quot;malformed_period&quot;
    ~title:&quot;Malformed period&quot;
    ~description:&quot;Period is negative.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Malformed period&quot;)
    empty
    (function Malformed_period -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Malformed_period) ;
  (* Invalid arg *)
  register_error_kind
    `Permanent
    ~id:&quot;invalid_arg&quot;
    ~title:&quot;Invalid arg&quot;
    ~description:&quot;Negative multiple of periods are not allowed.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid arg&quot;)
    empty
    (function Invalid_arg -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_arg)</abbr>

let of_seconds t =
  if Compare.Int64.(t &gt;= 0L) then ok t else error <abbr class="mark-error" title="Values of extensible types are not handled">Malformed_period</abbr>

let to_seconds t = t

let of_seconds_exn t =
  match of_seconds t with
  | Ok t -&gt;
      t
  | _ -&gt;
      invalid_arg &quot;Period.of_seconds_exn&quot;

let mult i p =
  (* TODO check overflow *)
  if Compare.Int32.(i &lt; 0l) then error <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arg</abbr>
  else ok (Int64.mul (Int64.of_int32 i) p)

let zero = of_seconds_exn 0L

let one_second = of_seconds_exn 1L

let one_minute = of_seconds_exn 60L

let one_hour = of_seconds_exn 3600L
</pre>
  </div>
  <div class="col-md-6">
    <a href="#period_repr.ml"><code>Period_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition t := Int64.t.

Definition period := t.

Definition op_eq := Compare.Int64.[Compare.S.op_eq].

Definition op_ltgt := Compare.Int64.[Compare.S.op_ltgt].

Definition op_lt := Compare.Int64.[Compare.S.op_lt].

Definition op_lteq := Compare.Int64.[Compare.S.op_lteq].

Definition op_gteq := Compare.Int64.[Compare.S.op_gteq].

Definition op_gt := Compare.Int64.[Compare.S.op_gt].

Definition compare := Compare.Int64.[Compare.S.compare].

Definition equal := Compare.Int64.[Compare.S.equal].

Definition max := Compare.Int64.[Compare.S.max].

Definition min := Compare.Int64.[Compare.S.min].

Definition encoding : Data_encoding.encoding int64 :=
  Data_encoding.__int64_value.

Definition rpc_arg : RPC_arg.arg int64 := RPC_arg.__int64_value.

Definition pp (ppf : Format.formatter) (v : int64) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%Ld&quot; % string) v.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition of_seconds (t : Compare.Int64.[Compare.S.t])
  : Error_monad.tzresult Compare.Int64.[Compare.S.t] :=
  if
    Compare.Int64.[Compare.S.op_gteq] t
      (* ‚ùå Constant of type int64 is converted to int *)
      0 then
    Error_monad.ok t
  else
    Error_monad.__error_value extensible_type_value.

Definition to_seconds {A : Set} (t : A) : A := t.

Definition of_seconds_exn (t : Compare.Int64.[Compare.S.t])
  : Compare.Int64.[Compare.S.t] :=
  match of_seconds t with
  | Pervasives.Ok t =&gt; t
  | _ =&gt; Pervasives.invalid_arg &quot;Period.of_seconds_exn&quot; % string
  end.

Definition mult (i : Compare.Int32.[Compare.S.t]) (p : int64)
  : Error_monad.tzresult int64 :=
  if
    Compare.Int32.[Compare.S.op_lt] i
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok (Int64.mul (Int64.of_int32 i) p).

Definition zero : Compare.Int64.[Compare.S.t] :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    0.

Definition one_second : Compare.Int64.[Compare.S.t] :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    1.

Definition one_minute : Compare.Int64.[Compare.S.t] :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    60.

Definition one_hour : Compare.Int64.[Compare.S.t] :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    3600.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="period_repr.mli">
  <div class="col-md-6">
    <a href="#period_repr.mli"><code>period_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

type period = t

include Compare.S with type t := t

val encoding : period Data_encoding.t

val rpc_arg : period RPC_arg.t

val pp : Format.formatter -&gt; period -&gt; unit

val to_seconds : period -&gt; int64

(** [of_second period] fails if period is not positive *)
val of_seconds : int64 -&gt; period tzresult

(** [of_second period] fails if period is not positive.
    It should only be used at toplevel for constants. *)
val of_seconds_exn : int64 -&gt; period

val mult : int32 -&gt; period -&gt; period tzresult

val zero : period

val one_second : period

val one_minute : period

val one_hour : period
</pre>
  </div>
  <div class="col-md-6">
    <a href="#period_repr.mli"><code>Period_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Parameter t : Set.

Definition period := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature t}.

Definition op_eq := Included_S.[Compare.S.op_eq].

Definition op_ltgt := Included_S.[Compare.S.op_ltgt].

Definition op_lt := Included_S.[Compare.S.op_lt].

Definition op_lteq := Included_S.[Compare.S.op_lteq].

Definition op_gteq := Included_S.[Compare.S.op_gteq].

Definition op_gt := Included_S.[Compare.S.op_gt].

Definition compare := Included_S.[Compare.S.compare].

Definition equal := Included_S.[Compare.S.equal].

Definition max := Included_S.[Compare.S.max].

Definition min := Included_S.[Compare.S.min].

Parameter encoding : Data_encoding.t period.

Parameter rpc_arg : RPC_arg.t period.

Parameter pp : Format.formatter -&gt; period -&gt; unit.

Parameter to_seconds : period -&gt; int64.

Parameter of_seconds : int64 -&gt; Error_monad.tzresult period.

Parameter of_seconds_exn : int64 -&gt; period.

Parameter mult : int32 -&gt; period -&gt; Error_monad.tzresult period.

Parameter zero : period.

Parameter one_second : period.

Parameter one_minute : period.

Parameter one_hour : period.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="qty_repr.ml">
  <div class="col-md-6">
    <a href="#qty_repr.ml"><code>qty_repr.ml</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module type QTY = sig
  val id : string
end

module type S = sig
  type qty

  <abbr class="mark-error" title="Extensible types are not handled.">type error +=
    | Addition_overflow of qty * qty (* `Temporary *)
    | Subtraction_underflow of qty * qty (* `Temporary *)
    | Multiplication_overflow of qty * int64 (* `Temporary *)
    | Negative_multiplicator of qty * int64 (* `Temporary *)
    | Invalid_divisor of qty * int64</abbr>

  (* `Temporary *)

  val id : string

  val zero : qty

  val one_mutez : qty

  val one_cent : qty

  val fifty_cents : qty

  val one : qty

  val ( -? ) : qty -&gt; qty -&gt; qty tzresult

  val ( +? ) : qty -&gt; qty -&gt; qty tzresult

  val ( *? ) : qty -&gt; int64 -&gt; qty tzresult

  val ( /? ) : qty -&gt; int64 -&gt; qty tzresult

  val to_mutez : qty -&gt; int64

  (** [of_mutez n] (micro tez) is None if n is negative *)
  val of_mutez : int64 -&gt; qty option

  (** [of_mutez_exn n] fails if n is negative.
      It should only be used at toplevel for constants. *)
  val of_mutez_exn : int64 -&gt; qty

  (** It should only be used at toplevel for constants. *)
  val add_exn : qty -&gt; qty -&gt; qty

  (** It should only be used at toplevel for constants. *)
  val mul_exn : qty -&gt; int -&gt; qty

  val encoding : qty Data_encoding.t

  val to_int64 : qty -&gt; int64

  include Compare.S with type t := qty

  val pp : Format.formatter -&gt; qty -&gt; unit

  val of_string : string -&gt; qty option

  val to_string : qty -&gt; string
end

<abbr class="mark-error" title="Functors are not handled.">module Make (T : QTY) : S = struct
  type qty = int64 (* invariant: positive *)

  type error +=
    | Addition_overflow of qty * qty (* `Temporary *)
    | Subtraction_underflow of qty * qty (* `Temporary *)
    | Multiplication_overflow of qty * int64 (* `Temporary *)
    | Negative_multiplicator of qty * int64 (* `Temporary *)
    | Invalid_divisor of qty * int64

  (* `Temporary *)

  include Compare.Int64

  let zero = 0L

  (* all other constant are defined from the value of one micro tez *)
  let one_mutez = 1L

  let one_cent = Int64.mul one_mutez 10_000L

  let fifty_cents = Int64.mul one_cent 50L

  (* 1 tez = 100 cents = 1_000_000 mutez *)
  let one = Int64.mul one_cent 100L

  let id = T.id

  let of_string s =
    let triplets = function
      | hd :: tl -&gt;
          let len = String.length hd in
          Compare.Int.(
            len &lt;= 3 &amp;&amp; len &gt; 0
            &amp;&amp; List.for_all (fun s -&gt; String.length s = 3) tl)
      | [] -&gt;
          false
    in
    let integers s = triplets (String.split_on_char ',' s) in
    let decimals s =
      let l = String.split_on_char ',' s in
      if Compare.Int.(List.length l &gt; 2) then false else triplets (List.rev l)
    in
    let parse left right =
      let remove_commas s = String.concat &quot;&quot; (String.split_on_char ',' s) in
      let pad_to_six s =
        let len = String.length s in
        String.init 6 (fun i -&gt; if Compare.Int.(i &lt; len) then s.[i] else '0')
      in
      try
        Some
          (Int64.of_string
             (remove_commas left ^ pad_to_six (remove_commas right)))
      with _ -&gt; None
    in
    match String.split_on_char '.' s with
    | [left; right] -&gt;
        if String.contains s ',' then
          if integers left &amp;&amp; decimals right then parse left right else None
        else if
          Compare.Int.(String.length right &gt; 0)
          &amp;&amp; Compare.Int.(String.length right &lt;= 6)
        then parse left right
        else None
    | [left] -&gt;
        if (not (String.contains s ',')) || integers left then parse left &quot;&quot;
        else None
    | _ -&gt;
        None

  let pp ppf amount =
    let mult_int = 1_000_000L in
    let rec left ppf amount =
      let (d, r) = (Int64.(div amount 1000L), Int64.(rem amount 1000L)) in
      if d &gt; 0L then Format.fprintf ppf &quot;%a%03Ld&quot; left d r
      else Format.fprintf ppf &quot;%Ld&quot; r
    in
    let right ppf amount =
      let triplet ppf v =
        if Compare.Int.(v mod 10 &gt; 0) then Format.fprintf ppf &quot;%03d&quot; v
        else if Compare.Int.(v mod 100 &gt; 0) then
          Format.fprintf ppf &quot;%02d&quot; (v / 10)
        else Format.fprintf ppf &quot;%d&quot; (v / 100)
      in
      let (hi, lo) = (amount / 1000, amount mod 1000) in
      if Compare.Int.(lo = 0) then Format.fprintf ppf &quot;%a&quot; triplet hi
      else Format.fprintf ppf &quot;%03d%a&quot; hi triplet lo
    in
    let (ints, decs) =
      (Int64.(div amount mult_int), Int64.(to_int (rem amount mult_int)))
    in
    Format.fprintf ppf &quot;%a&quot; left ints ;
    if Compare.Int.(decs &gt; 0) then Format.fprintf ppf &quot;.%a&quot; right decs

  let to_string t = Format.asprintf &quot;%a&quot; pp t

  let ( - ) t1 t2 = if t2 &lt;= t1 then Some (Int64.sub t1 t2) else None

  let ( -? ) t1 t2 =
    match t1 - t2 with
    | None -&gt;
        error (Subtraction_underflow (t1, t2))
    | Some v -&gt;
        ok v

  let ( +? ) t1 t2 =
    let t = Int64.add t1 t2 in
    if t &lt; t1 then error (Addition_overflow (t1, t2)) else ok t

  let ( *? ) t m =
    let open Compare.Int64 in
    let open Int64 in
    let rec step cur pow acc =
      if cur = 0L then ok acc
      else
        pow +? pow
        &gt;&gt;? fun npow -&gt;
        if logand cur 1L = 1L then
          acc +? pow &gt;&gt;? fun nacc -&gt; step (shift_right_logical cur 1) npow nacc
        else step (shift_right_logical cur 1) npow acc
    in
    if m &lt; 0L then error (Negative_multiplicator (t, m))
    else
      match step m t 0L with
      | Ok res -&gt;
          Ok res
      | Error ([Addition_overflow _] as errs) -&gt;
          Error (Multiplication_overflow (t, m) :: errs)
      | Error errs -&gt;
          Error errs

  let ( /? ) t d =
    if d &lt;= 0L then error (Invalid_divisor (t, d)) else ok (Int64.div t d)

  let add_exn t1 t2 =
    let t = Int64.add t1 t2 in
    if t &lt;= 0L then invalid_arg &quot;add_exn&quot; else t

  let mul_exn t m =
    match t *? Int64.(of_int m) with
    | Ok v -&gt;
        v
    | Error _ -&gt;
        invalid_arg &quot;mul_exn&quot;

  let of_mutez t = if t &lt; 0L then None else Some t

  let of_mutez_exn x =
    match of_mutez x with None -&gt; invalid_arg &quot;Qty.of_mutez&quot; | Some v -&gt; v

  let to_int64 t = t

  let to_mutez t = t

  let encoding =
    let open Data_encoding in
    check_size 10 (conv Z.of_int64 (Json.wrap_error Z.to_int64) n)

  let () =
    let open Data_encoding in
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.addition_overflow&quot;)
      ~title:(&quot;Overflowing &quot; ^ T.id ^ &quot; addition&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Overflowing addition of %a %s and %a %s&quot;
          pp
          opa
          T.id
          pp
          opb
          T.id)
      ~description:(&quot;An addition of two &quot; ^ T.id ^ &quot; amounts overflowed&quot;)
      (obj1 (req &quot;amounts&quot; (tup2 encoding encoding)))
      (function Addition_overflow (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Addition_overflow (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.subtraction_underflow&quot;)
      ~title:(&quot;Underflowing &quot; ^ T.id ^ &quot; subtraction&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Underflowing subtraction of %a %s and %a %s&quot;
          pp
          opa
          T.id
          pp
          opb
          T.id)
      ~description:(&quot;An subtraction of two &quot; ^ T.id ^ &quot; amounts underflowed&quot;)
      (obj1 (req &quot;amounts&quot; (tup2 encoding encoding)))
      (function Subtraction_underflow (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Subtraction_underflow (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.multiplication_overflow&quot;)
      ~title:(&quot;Overflowing &quot; ^ T.id ^ &quot; multiplication&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Overflowing multiplication of %a %s and %Ld&quot;
          pp
          opa
          T.id
          opb)
      ~description:
        (&quot;A multiplication of a &quot; ^ T.id ^ &quot; amount by an integer overflowed&quot;)
      (obj2 (req &quot;amount&quot; encoding) (req &quot;multiplicator&quot; int64))
      (function Multiplication_overflow (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Multiplication_overflow (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.negative_multiplicator&quot;)
      ~title:(&quot;Negative &quot; ^ T.id ^ &quot; multiplicator&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Multiplication of %a %s by negative integer %Ld&quot;
          pp
          opa
          T.id
          opb)
      ~description:
        (&quot;Multiplication of a &quot; ^ T.id ^ &quot; amount by a negative integer&quot;)
      (obj2 (req &quot;amount&quot; encoding) (req &quot;multiplicator&quot; int64))
      (function Negative_multiplicator (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Negative_multiplicator (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.invalid_divisor&quot;)
      ~title:(&quot;Invalid &quot; ^ T.id ^ &quot; divisor&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Division of %a %s by non positive integer %Ld&quot;
          pp
          opa
          T.id
          opb)
      ~description:
        (&quot;Multiplication of a &quot; ^ T.id ^ &quot; amount by a non positive integer&quot;)
      (obj2 (req &quot;amount&quot; encoding) (req &quot;divisor&quot; int64))
      (function Invalid_divisor (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Invalid_divisor (a, b))
end</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#qty_repr.ml"><code>Qty_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Module QTY.
  Record signature := {
    id : string;
  }.
End QTY.

Module S.
  Record signature {qty : Set} := {
    qty := qty;
    (* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)
    id : string;
    zero : qty;
    one_mutez : qty;
    one_cent : qty;
    fifty_cents : qty;
    one : qty;
    op_minusquestion : qty -&gt; qty -&gt; Error_monad.tzresult qty;
    op_plusquestion : qty -&gt; qty -&gt; Error_monad.tzresult qty;
    op_starquestion : qty -&gt; int64 -&gt; Error_monad.tzresult qty;
    op_divquestion : qty -&gt; int64 -&gt; Error_monad.tzresult qty;
    to_mutez : qty -&gt; int64;
    of_mutez : int64 -&gt; option qty;
    of_mutez_exn : int64 -&gt; qty;
    add_exn : qty -&gt; qty -&gt; qty;
    mul_exn : qty -&gt; Z -&gt; qty;
    encoding : Data_encoding.t qty;
    to_int64 : qty -&gt; int64;
    op_eq : qty -&gt; qty -&gt; bool;
    op_ltgt : qty -&gt; qty -&gt; bool;
    op_lt : qty -&gt; qty -&gt; bool;
    op_lteq : qty -&gt; qty -&gt; bool;
    op_gteq : qty -&gt; qty -&gt; bool;
    op_gt : qty -&gt; qty -&gt; bool;
    compare : qty -&gt; qty -&gt; Z;
    equal : qty -&gt; qty -&gt; bool;
    max : qty -&gt; qty -&gt; qty;
    min : qty -&gt; qty -&gt; qty;
    pp : Format.formatter -&gt; qty -&gt; unit;
    of_string : string -&gt; option qty;
    to_string : qty -&gt; string;
  }.
  Arguments signature : clear implicits.
End S.

(* ‚ùå Functors are not handled. *)
(* functor *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_context.ml">
  <div class="col-md-6">
    <a href="#raw_context.ml"><code>raw_context.ml</code></a>&nbsp;<span class="label label-danger">73 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module Int_set = Set.Make (Compare.Int)

type t = {
  context : Context.t;
  constants : Constants_repr.parametric;
  first_level : Raw_level_repr.t;
  level : Level_repr.t;
  predecessor_timestamp : Time.t;
  timestamp : Time.t;
  fitness : Int64.t;
  deposits : Tez_repr.t Signature.Public_key_hash.Map.t;
  included_endorsements : int;
  allowed_endorsements :
    (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t;
  fees : Tez_repr.t;
  rewards : Tez_repr.t;
  block_gas : Z.t;
  operation_gas : Gas_limit_repr.t;
  internal_gas : Gas_limit_repr.internal_gas;
  storage_space_to_pay : Z.t option;
  allocated_contracts : int option;
  origination_nonce : Contract_repr.origination_nonce option;
  temporary_big_map : Z.t;
  internal_nonce : int;
  internal_nonces_used : Int_set.t;
}

type context = t

type root_context = t

let current_level ctxt = ctxt.level

let predecessor_timestamp ctxt = ctxt.predecessor_timestamp

let current_timestamp ctxt = ctxt.timestamp

let current_fitness ctxt = ctxt.fitness

let first_level ctxt = ctxt.first_level

let constants ctxt = ctxt.constants

let recover ctxt = ctxt.context

let record_endorsement ctxt k =
  match Signature.Public_key_hash.Map.find_opt k ctxt.allowed_endorsements with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | Some (_, _, true) -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* right already used *)
  | Some (d, s, false) -&gt;
      <abbr class="mark-error" title="Record substitution not handled">{
        ctxt with
        included_endorsements = ctxt.included_endorsements + List.length s;
        allowed_endorsements =
          Signature.Public_key_hash.Map.add
            k
            (d, s, true)
            ctxt.allowed_endorsements;
      }</abbr>

let init_endorsements ctxt allowed_endorsements =
  if Signature.Public_key_hash.Map.is_empty allowed_endorsements then
    <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* can't initialize to empty *)
  else if Signature.Public_key_hash.Map.is_empty ctxt.allowed_endorsements then
    <abbr class="mark-error" title="Record substitution not handled">{ctxt with allowed_endorsements}</abbr>
  else <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>

(* can't initialize twice *)

let allowed_endorsements ctxt = ctxt.allowed_endorsements

let included_endorsements ctxt = ctxt.included_endorsements

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Too_many_internal_operations</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;too_many_internal_operations&quot;
    ~title:&quot;Too many internal operations&quot;
    ~description:
      &quot;A transaction exceeded the hard limit of internal operations it can emit&quot;
    empty
    (function Too_many_internal_operations -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_many_internal_operations)</abbr>

let fresh_internal_nonce ctxt =
  if Compare.Int.(ctxt.internal_nonce &gt;= 65_535) then
    error <abbr class="mark-error" title="Values of extensible types are not handled">Too_many_internal_operations</abbr>
  else
    ok
      ( <abbr class="mark-error" title="Record substitution not handled">{ctxt with internal_nonce = ctxt.internal_nonce + 1}</abbr>,
        ctxt.internal_nonce )

let reset_internal_nonce ctxt =
  <abbr class="mark-error" title="Record substitution not handled">{ctxt with internal_nonces_used = Int_set.empty; internal_nonce = 0}</abbr>

let record_internal_nonce ctxt k =
  <abbr class="mark-error" title="Record substitution not handled">{ctxt with internal_nonces_used = Int_set.add k ctxt.internal_nonces_used}</abbr>

let internal_nonce_already_recorded ctxt k =
  Int_set.mem k ctxt.internal_nonces_used

let set_current_fitness ctxt fitness = <abbr class="mark-error" title="Record substitution not handled">{ctxt with fitness}</abbr>

let add_fees ctxt fees =
  Lwt.return Tez_repr.(ctxt.fees +? fees)
  &gt;&gt;=? fun fees -&gt; return <abbr class="mark-error" title="Record substitution not handled">{ctxt with fees}</abbr>

let add_rewards ctxt rewards =
  Lwt.return Tez_repr.(ctxt.rewards +? rewards)
  &gt;&gt;=? fun rewards -&gt; return <abbr class="mark-error" title="Record substitution not handled">{ctxt with rewards}</abbr>

let add_deposit ctxt delegate deposit =
  let previous =
    match Signature.Public_key_hash.Map.find_opt delegate ctxt.deposits with
    | Some tz -&gt;
        tz
    | None -&gt;
        Tez_repr.zero
  in
  Lwt.return Tez_repr.(previous +? deposit)
  &gt;&gt;=? fun deposit -&gt;
  let deposits =
    Signature.Public_key_hash.Map.add delegate deposit ctxt.deposits
  in
  return <abbr class="mark-error" title="Record substitution not handled">{ctxt with deposits}</abbr>

let get_deposits ctxt = ctxt.deposits

let get_rewards ctxt = ctxt.rewards

let get_fees ctxt = ctxt.fees

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Undefined_operation_nonce</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;undefined_operation_nonce&quot;
    ~title:&quot;Ill timed access to the origination nonce&quot;
    ~description:
      &quot;An origination was attemped out of the scope of a manager operation&quot;
    empty
    (function Undefined_operation_nonce -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Undefined_operation_nonce)</abbr>

let init_origination_nonce ctxt operation_hash =
  let origination_nonce =
    Some (Contract_repr.initial_origination_nonce operation_hash)
  in
  <abbr class="mark-error" title="Record substitution not handled">{ctxt with origination_nonce}</abbr>

let origination_nonce ctxt =
  match ctxt.origination_nonce with
  | None -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Undefined_operation_nonce</abbr>
  | Some origination_nonce -&gt;
      ok origination_nonce

let increment_origination_nonce ctxt =
  match ctxt.origination_nonce with
  | None -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Undefined_operation_nonce</abbr>
  | Some cur_origination_nonce -&gt;
      let origination_nonce =
        Some (Contract_repr.incr_origination_nonce cur_origination_nonce)
      in
      ok (<abbr class="mark-error" title="Record substitution not handled">{ctxt with origination_nonce}</abbr>, cur_origination_nonce)

let unset_origination_nonce ctxt = <abbr class="mark-error" title="Record substitution not handled">{ctxt with origination_nonce = None}</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Gas_limit_too_high</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;gas_limit_too_high&quot;
    ~title:&quot;Gas limit out of protocol hard bounds&quot;
    ~description:&quot;A transaction tried to exceed the hard limit on gas&quot;
    empty
    (function Gas_limit_too_high -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Gas_limit_too_high)</abbr>

let check_gas_limit ctxt remaining =
  if
    Compare.Z.(remaining &gt; ctxt.constants.hard_gas_limit_per_operation)
    || Compare.Z.(remaining &lt; Z.zero)
  then error <abbr class="mark-error" title="Values of extensible types are not handled">Gas_limit_too_high</abbr>
  else ok ()

let set_gas_limit ctxt remaining =
  <abbr class="mark-error" title="Record substitution not handled">{
    ctxt with
    operation_gas = Limited {remaining};
    internal_gas = Gas_limit_repr.internal_gas_zero;
  }</abbr>

let set_gas_unlimited ctxt = <abbr class="mark-error" title="Record substitution not handled">{ctxt with operation_gas = Unaccounted}</abbr>

let consume_gas ctxt cost =
  Gas_limit_repr.consume
    ctxt.block_gas
    ctxt.operation_gas
    ctxt.internal_gas
    cost
  &gt;&gt;? fun (block_gas, operation_gas, internal_gas) -&gt;
  ok <abbr class="mark-error" title="Record substitution not handled">{ctxt with block_gas; operation_gas; internal_gas}</abbr>

let check_enough_gas ctxt cost =
  Gas_limit_repr.check_enough
    ctxt.block_gas
    ctxt.operation_gas
    ctxt.internal_gas
    cost

let gas_level ctxt = ctxt.operation_gas

let block_gas_level ctxt = ctxt.block_gas

let gas_consumed ~since ~until =
  match (gas_level since, gas_level until) with
  | (Limited {remaining = before}, Limited {remaining = after}) -&gt;
      Z.sub before after
  | (_, _) -&gt;
      Z.zero

let init_storage_space_to_pay ctxt =
  match ctxt.storage_space_to_pay with
  | Some _ -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | None -&gt;
      <abbr class="mark-error" title="Record substitution not handled">{
        ctxt with
        storage_space_to_pay = Some Z.zero;
        allocated_contracts = Some 0;
      }</abbr>

let update_storage_space_to_pay ctxt n =
  match ctxt.storage_space_to_pay with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | Some storage_space_to_pay -&gt;
      <abbr class="mark-error" title="Record substitution not handled">{ctxt with storage_space_to_pay = Some (Z.add n storage_space_to_pay)}</abbr>

let update_allocated_contracts_count ctxt =
  match ctxt.allocated_contracts with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | Some allocated_contracts -&gt;
      <abbr class="mark-error" title="Record substitution not handled">{ctxt with allocated_contracts = Some (succ allocated_contracts)}</abbr>

let clear_storage_space_to_pay ctxt =
  match (ctxt.storage_space_to_pay, ctxt.allocated_contracts) with
  | (None, _) | (_, None) -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | (Some storage_space_to_pay, Some allocated_contracts) -&gt;
      ( <abbr class="mark-error" title="Record substitution not handled">{ctxt with storage_space_to_pay = None; allocated_contracts = None}</abbr>,
        storage_space_to_pay,
        allocated_contracts )

type storage_error =
  | Incompatible_protocol_version of string
  <abbr class="mark-error" title="Polymorphic variant types are not handled">| Missing_key of string list * [`Get | `Set | `Del | `Copy]</abbr>
  | Existing_key of string list
  | Corrupted_data of string list

let storage_error_encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;Incompatible_protocol_version&quot;
        (obj1 (req &quot;incompatible_protocol_version&quot; string))
        (function Incompatible_protocol_version arg -&gt; Some arg | _ -&gt; None)
        (fun arg -&gt; Incompatible_protocol_version arg);
      case
        (Tag 1)
        ~title:&quot;Missing_key&quot;
        (obj2
           (req &quot;missing_key&quot; (list string))
           (req
              &quot;function&quot;
              (string_enum
                 [(&quot;get&quot;, <abbr class="mark-error" title="Variants not supported">`Get</abbr>); (&quot;set&quot;, <abbr class="mark-error" title="Variants not supported">`Set</abbr>); (&quot;del&quot;, <abbr class="mark-error" title="Variants not supported">`Del</abbr>); (&quot;copy&quot;, <abbr class="mark-error" title="Variants not supported">`Copy</abbr>)])))
        (function Missing_key (key, f) -&gt; Some (key, f) | _ -&gt; None)
        (fun (key, f) -&gt; Missing_key (key, f));
      case
        (Tag 2)
        ~title:&quot;Existing_key&quot;
        (obj1 (req &quot;existing_key&quot; (list string)))
        (function Existing_key key -&gt; Some key | _ -&gt; None)
        (fun key -&gt; Existing_key key);
      case
        (Tag 3)
        ~title:&quot;Corrupted_data&quot;
        (obj1 (req &quot;corrupted_data&quot; (list string)))
        (function Corrupted_data key -&gt; Some key | _ -&gt; None)
        (fun key -&gt; Corrupted_data key) ]

let pp_storage_error ppf = function
  | Incompatible_protocol_version version -&gt;
      Format.fprintf
        ppf
        &quot;Found a context with an unexpected version '%s'.&quot;
        version
  | Missing_key (key, <abbr class="mark-error" title="Patterns on variants are not supported">`Get</abbr>) -&gt;
      Format.fprintf ppf &quot;Missing key '%s'.&quot; (String.concat &quot;/&quot; key)
  | Missing_key (key, <abbr class="mark-error" title="Patterns on variants are not supported">`Set</abbr>) -&gt;
      Format.fprintf
        ppf
        &quot;Cannot set undefined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Missing_key (key, <abbr class="mark-error" title="Patterns on variants are not supported">`Del</abbr>) -&gt;
      Format.fprintf
        ppf
        &quot;Cannot delete undefined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Missing_key (key, <abbr class="mark-error" title="Patterns on variants are not supported">`Copy</abbr>) -&gt;
      Format.fprintf
        ppf
        &quot;Cannot copy undefined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Existing_key key -&gt;
      Format.fprintf
        ppf
        &quot;Cannot initialize defined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Corrupted_data key -&gt;
      Format.fprintf
        ppf
        &quot;Failed to parse the data at '%s'.&quot;
        (String.concat &quot;/&quot; key)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Storage_error of storage_error</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;context.storage_error&quot;
    ~title:&quot;Storage error (fatal internal error)&quot;
    ~description:
      &quot;An error that should never happen unless something has been deleted or \
       corrupted in the database.&quot;
    ~pp:(fun ppf err -&gt;
      Format.fprintf ppf &quot;@[&lt;v 2&gt;Storage error:@ %a@]&quot; pp_storage_error err)
    storage_error_encoding
    (function Storage_error err -&gt; Some err | _ -&gt; None)
    (fun err -&gt; Storage_error err)</abbr>

let storage_error err = fail <abbr class="mark-error" title="Values of extensible types are not handled">(Storage_error err)</abbr>

(* Initialization *********************************************************)

(* This key should always be populated for every version of the
   protocol.  It's absence meaning that the context is empty. *)
let version_key = [&quot;version&quot;]

let version_value = &quot;alpha_current&quot;

let version = &quot;v1&quot;

let first_level_key = [version; &quot;first_level&quot;]

let constants_key = [version; &quot;constants&quot;]

let protocol_param_key = [&quot;protocol_parameters&quot;]

let get_first_level ctxt =
  Context.get ctxt first_level_key
  &gt;&gt;= function
  | None -&gt;
      storage_error (Missing_key (first_level_key, <abbr class="mark-error" title="Variants not supported">`Get</abbr>))
  | Some bytes -&gt; (
    match Data_encoding.Binary.of_bytes Raw_level_repr.encoding bytes with
    | None -&gt;
        storage_error (Corrupted_data first_level_key)
    | Some level -&gt;
        return level )

let set_first_level ctxt level =
  let bytes =
    Data_encoding.Binary.to_bytes_exn Raw_level_repr.encoding level
  in
  Context.set ctxt first_level_key bytes &gt;&gt;= fun ctxt -&gt; return ctxt

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Failed_to_parse_parameter of MBytes.t</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Failed_to_decode_parameter of Data_encoding.json * string</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Temporary
    ~id:&quot;context.failed_to_parse_parameter&quot;
    ~title:&quot;Failed to parse parameter&quot;
    ~description:&quot;The protocol parameters are not valid JSON.&quot;
    ~pp:(fun ppf bytes -&gt;
      Format.fprintf
        ppf
        &quot;@[&lt;v 2&gt;Cannot parse the protocol parameter:@ %s@]&quot;
        (MBytes.to_string bytes))
    Data_encoding.(obj1 (req &quot;contents&quot; bytes))
    (function Failed_to_parse_parameter data -&gt; Some data | _ -&gt; None)
    (fun data -&gt; Failed_to_parse_parameter data) ;
  register_error_kind
    `Temporary
    ~id:&quot;context.failed_to_decode_parameter&quot;
    ~title:&quot;Failed to decode parameter&quot;
    ~description:&quot;Unexpected JSON object.&quot;
    ~pp:(fun ppf (json, msg) -&gt;
      Format.fprintf
        ppf
        &quot;@[&lt;v 2&gt;Cannot decode the protocol parameter:@ %s@ %a@]&quot;
        msg
        Data_encoding.Json.pp
        json)
    Data_encoding.(obj2 (req &quot;contents&quot; json) (req &quot;error&quot; string))
    (function
      | Failed_to_decode_parameter (json, msg) -&gt; Some (json, msg) | _ -&gt; None)
    (fun (json, msg) -&gt; Failed_to_decode_parameter (json, msg))</abbr>

let get_proto_param ctxt =
  Context.get ctxt protocol_param_key
  &gt;&gt;= function
  | None -&gt;
      failwith &quot;Missing protocol parameters.&quot;
  | Some bytes -&gt; (
    match Data_encoding.Binary.of_bytes Data_encoding.json bytes with
    | None -&gt;
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Failed_to_parse_parameter bytes)</abbr>
    | Some json -&gt; (
        Context.del ctxt protocol_param_key
        &gt;&gt;= fun ctxt -&gt;
        match Data_encoding.Json.destruct Parameters_repr.encoding json with
        | exception <abbr class="mark-error" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">(Data_encoding.Json.Cannot_destruct _ as exn)</abbr> -&gt;
            Format.kasprintf
              failwith
              &quot;Invalid protocol_parameters: %a %a&quot;
              (fun ppf -&gt; Data_encoding.Json.print_error ppf)
              exn
              Data_encoding.Json.pp
              json
        | param -&gt;
            return (param, ctxt) ) )

let set_constants ctxt constants =
  let bytes =
    Data_encoding.Binary.to_bytes_exn
      Constants_repr.parametric_encoding
      constants
  in
  Context.set ctxt constants_key bytes

let get_constants ctxt =
  Context.get ctxt constants_key
  &gt;&gt;= function
  | None -&gt;
      failwith &quot;Internal error: cannot read constants in context.&quot;
  | Some bytes -&gt; (
    match
      Data_encoding.Binary.of_bytes Constants_repr.parametric_encoding bytes
    with
    | None -&gt;
        failwith &quot;Internal error: cannot parse constants in context.&quot;
    | Some constants -&gt;
        return constants )

let patch_constants ctxt f =
  let constants = f ctxt.constants in
  set_constants ctxt.context constants
  &gt;&gt;= fun context -&gt; Lwt.return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context; constants}</abbr>

let check_inited ctxt =
  Context.get ctxt version_key
  &gt;&gt;= function
  | None -&gt;
      failwith &quot;Internal error: un-initialized context.&quot;
  | Some bytes -&gt;
      let s = MBytes.to_string bytes in
      if Compare.String.(s = version_value) then return_unit
      else storage_error (Incompatible_protocol_version s)

let prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt =
  Lwt.return (Raw_level_repr.of_int32 level)
  &gt;&gt;=? fun level -&gt;
  Lwt.return (Fitness_repr.to_int64 fitness)
  &gt;&gt;=? fun fitness -&gt;
  check_inited ctxt
  &gt;&gt;=? fun () -&gt;
  get_constants ctxt
  &gt;&gt;=? fun constants -&gt;
  get_first_level ctxt
  &gt;&gt;=? fun first_level -&gt;
  let level =
    Level_repr.from_raw
      ~first_level
      ~blocks_per_cycle:constants.Constants_repr.blocks_per_cycle
      ~blocks_per_voting_period:
        constants.Constants_repr.blocks_per_voting_period
      ~blocks_per_commitment:constants.Constants_repr.blocks_per_commitment
      level
  in
  return
    {
      context = ctxt;
      constants;
      level;
      predecessor_timestamp;
      timestamp;
      fitness;
      first_level;
      allowed_endorsements = Signature.Public_key_hash.Map.empty;
      included_endorsements = 0;
      fees = Tez_repr.zero;
      rewards = Tez_repr.zero;
      deposits = Signature.Public_key_hash.Map.empty;
      operation_gas = Unaccounted;
      internal_gas = Gas_limit_repr.internal_gas_zero;
      storage_space_to_pay = None;
      allocated_contracts = None;
      block_gas = constants.Constants_repr.hard_gas_limit_per_block;
      origination_nonce = None;
      temporary_big_map = Z.sub Z.zero Z.one;
      internal_nonce = 0;
      internal_nonces_used = Int_set.empty;
    }

type previous_protocol = Genesis of Parameters_repr.t | Alpha_previous

let check_and_update_protocol_version ctxt =
  Context.get ctxt version_key
  &gt;&gt;= (function
        | None -&gt;
            failwith
              &quot;Internal error: un-initialized context in check_first_block.&quot;
        | Some bytes -&gt;
            let s = MBytes.to_string bytes in
            if Compare.String.(s = version_value) then
              failwith &quot;Internal error: previously initialized context.&quot;
            else if Compare.String.(s = &quot;genesis&quot;) then
              get_proto_param ctxt
              &gt;&gt;=? fun (param, ctxt) -&gt; return (Genesis param, ctxt)
            else if Compare.String.(s = &quot;alpha_previous&quot;) then
              return (Alpha_previous, ctxt)
            else storage_error (Incompatible_protocol_version s))
  &gt;&gt;=? fun (previous_proto, ctxt) -&gt;
  Context.set ctxt version_key (MBytes.of_string version_value)
  &gt;&gt;= fun ctxt -&gt; return (previous_proto, ctxt)

let prepare_first_block ~level ~timestamp ~fitness ctxt =
  check_and_update_protocol_version ctxt
  &gt;&gt;=? fun (previous_proto, ctxt) -&gt;
  ( match previous_proto with
  | Genesis param -&gt;
      Lwt.return (Raw_level_repr.of_int32 level)
      &gt;&gt;=? fun first_level -&gt;
      set_first_level ctxt first_level
      &gt;&gt;=? fun ctxt -&gt;
      set_constants ctxt param.constants &gt;&gt;= fun ctxt -&gt; return ctxt
  | Alpha_previous -&gt;
      return ctxt )
  &gt;&gt;=? fun ctxt -&gt;
  prepare ctxt ~level ~predecessor_timestamp:timestamp ~timestamp ~fitness
  &gt;&gt;=? fun ctxt -&gt; return (previous_proto, ctxt)

let activate ({context = c; _} as s) h =
  Updater.activate c h &gt;&gt;= fun c -&gt; Lwt.return <abbr class="mark-error" title="Record substitution not handled">{s with context = c}</abbr>

let fork_test_chain ({context = c; _} as s) protocol expiration =
  Updater.fork_test_chain c ~protocol ~expiration
  &gt;&gt;= fun c -&gt; Lwt.return <abbr class="mark-error" title="Record substitution not handled">{s with context = c}</abbr>

(* Generic context ********************************************************)

type key = string list

type value = MBytes.t

module type T = sig
  type t

  type context = t

  val mem : context -&gt; key -&gt; bool Lwt.t

  val dir_mem : context -&gt; key -&gt; bool Lwt.t

  val get : context -&gt; key -&gt; value tzresult Lwt.t

  val get_option : context -&gt; key -&gt; value option Lwt.t

  val init : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  val set : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  val init_set : context -&gt; key -&gt; value -&gt; context Lwt.t

  val set_option : context -&gt; key -&gt; value option -&gt; context Lwt.t

  val delete : context -&gt; key -&gt; context tzresult Lwt.t

  val remove : context -&gt; key -&gt; context Lwt.t

  val remove_rec : context -&gt; key -&gt; context Lwt.t

  val copy : context -&gt; from:key -&gt; to_:key -&gt; context tzresult Lwt.t

  <abbr class="mark-error" title="Polymorphic variant types are not handled">val fold :
    context -&gt;
    key -&gt;
    init:'a -&gt;
    f:([`Key of key | `Dir of key] -&gt; 'a -&gt; 'a Lwt.t) -&gt;
    'a Lwt.t</abbr>

  val keys : context -&gt; key -&gt; key list Lwt.t

  val fold_keys :
    context -&gt; key -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val project : context -&gt; root_context

  val absolute_key : context -&gt; key -&gt; key

  val consume_gas : context -&gt; Gas_limit_repr.cost -&gt; context tzresult

  val check_enough_gas : context -&gt; Gas_limit_repr.cost -&gt; unit tzresult

  val description : context Storage_description.t
end

let mem ctxt k = Context.mem ctxt.context k

let dir_mem ctxt k = Context.dir_mem ctxt.context k

let get ctxt k =
  Context.get ctxt.context k
  &gt;&gt;= function
  | None -&gt; storage_error (Missing_key (k, <abbr class="mark-error" title="Variants not supported">`Get</abbr>)) | Some v -&gt; return v

let get_option ctxt k = Context.get ctxt.context k

(* Verify that the k is present before modifying *)
let set ctxt k v =
  Context.mem ctxt.context k
  &gt;&gt;= function
  | false -&gt;
      storage_error (Missing_key (k, <abbr class="mark-error" title="Variants not supported">`Set</abbr>))
  | true -&gt;
      Context.set ctxt.context k v
      &gt;&gt;= fun context -&gt; return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context}</abbr>

(* Verify that the k is not present before inserting *)
let init ctxt k v =
  Context.mem ctxt.context k
  &gt;&gt;= function
  | true -&gt;
      storage_error (Existing_key k)
  | false -&gt;
      Context.set ctxt.context k v
      &gt;&gt;= fun context -&gt; return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context}</abbr>

(* Does not verify that the key is present or not *)
let init_set ctxt k v =
  Context.set ctxt.context k v
  &gt;&gt;= fun context -&gt; Lwt.return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context}</abbr>

(* Verify that the key is present before deleting *)
let delete ctxt k =
  Context.mem ctxt.context k
  &gt;&gt;= function
  | false -&gt;
      storage_error (Missing_key (k, <abbr class="mark-error" title="Variants not supported">`Del</abbr>))
  | true -&gt;
      Context.del ctxt.context k &gt;&gt;= fun context -&gt; return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context}</abbr>

(* Do not verify before deleting *)
let remove ctxt k =
  Context.del ctxt.context k &gt;&gt;= fun context -&gt; Lwt.return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context}</abbr>

let set_option ctxt k = function
  | None -&gt;
      remove ctxt k
  | Some v -&gt;
      init_set ctxt k v

let remove_rec ctxt k =
  Context.remove_rec ctxt.context k
  &gt;&gt;= fun context -&gt; Lwt.return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context}</abbr>

let copy ctxt ~from ~to_ =
  Context.copy ctxt.context ~from ~to_
  &gt;&gt;= function
  | None -&gt;
      storage_error (Missing_key (from, <abbr class="mark-error" title="Variants not supported">`Copy</abbr>))
  | Some context -&gt;
      return <abbr class="mark-error" title="Record substitution not handled">{ctxt with context}</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">fold</abbr> ctxt k ~init ~f = Context.fold ctxt.context k ~init ~f

let keys ctxt k = Context.keys ctxt.context k

let fold_keys ctxt k ~init ~f = Context.fold_keys ctxt.context k ~init ~f

let project x = x

let absolute_key _ k = k

let description = Storage_description.create ()

let fresh_temporary_big_map ctxt =
  ( <abbr class="mark-error" title="Record substitution not handled">{ctxt with temporary_big_map = Z.sub ctxt.temporary_big_map Z.one}</abbr>,
    ctxt.temporary_big_map )

let reset_temporary_big_map ctxt =
  <abbr class="mark-error" title="Record substitution not handled">{ctxt with temporary_big_map = Z.sub Z.zero Z.one}</abbr>

let temporary_big_maps ctxt f acc =
  let rec iter acc id =
    if Z.equal id ctxt.temporary_big_map then Lwt.return acc
    else f acc id &gt;&gt;= fun acc -&gt; iter acc (Z.sub id Z.one)
  in
  iter acc (Z.sub Z.zero Z.one)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_context.ml"><code>Raw_context.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Fitness_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Parameters_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

Definition Int_set :=
  __Set.Make
    (existT _ _
      {|
        Compare.COMPARABLE.compare := Compare.Int.[Compare.S.compare]
        |}).

Module t.
  Record record := {
    context : Context.t;
    constants : Constants_repr.parametric;
    first_level : Raw_level_repr.t;
    level : Level_repr.t;
    predecessor_timestamp : Time.t;
    timestamp : Time.t;
    fitness : Int64.t;
    deposits :
      Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
        Tez_repr.t;
    included_endorsements : Z;
    allowed_endorsements :
      Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
        (Signature.Public_key.[S.SPublic_key.t] * list Z * bool);
    fees : Tez_repr.t;
    rewards : Tez_repr.t;
    block_gas : Z.t;
    operation_gas : Gas_limit_repr.t;
    internal_gas : Gas_limit_repr.internal_gas;
    storage_space_to_pay : option Z.t;
    allocated_contracts : option Z;
    origination_nonce : option Contract_repr.origination_nonce;
    temporary_big_map : Z.t;
    internal_nonce : Z;
    internal_nonces_used : Int_set.[S.SET.t] }.
End t.
Definition t := t.record.

Definition context := t.

Definition root_context := t.

Definition current_level (ctxt : t) : Level_repr.t := t.level ctxt.

Definition predecessor_timestamp (ctxt : t) : Time.t :=
  t.predecessor_timestamp ctxt.

Definition current_timestamp (ctxt : t) : Time.t := t.timestamp ctxt.

Definition current_fitness (ctxt : t) : Int64.t := t.fitness ctxt.

Definition first_level (ctxt : t) : Raw_level_repr.t := t.first_level ctxt.

Definition constants (ctxt : t) : Constants_repr.parametric := t.constants ctxt.

Definition recover (ctxt : t) : Context.t := t.context ctxt.

Definition record_endorsement
  (ctxt : t)
  (k : Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.key))
  : t :=
  match
    Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.find_opt)
      k (t.allowed_endorsements ctxt) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some (_, _, true) =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some (d, s, false) =&gt;
    (* ‚ùå Record substitution not handled *)
    record_substitution
  end.

Definition init_endorsements
  (ctxt : t)
  (allowed_endorsements :
    Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
      (Signature.Public_key.[S.SPublic_key.t] * list Z * bool)) : t :=
  if
    Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.is_empty)
      allowed_endorsements then
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  else
    if
      Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.is_empty)
        (t.allowed_endorsements ctxt) then
      (* ‚ùå Record substitution not handled *)
      record_substitution
    else
      (* ‚ùå Assert instruction is not handled. *)
      assert false.

Definition allowed_endorsements (ctxt : t)
  : Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    (Signature.Public_key.[S.SPublic_key.t] * list Z * bool) :=
  t.allowed_endorsements ctxt.

Definition included_endorsements (ctxt : t) : Z := t.included_endorsements ctxt.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition fresh_internal_nonce (ctxt : t) : Error_monad.tzresult (t * Z) :=
  if Compare.Int.[Compare.S.op_gteq] (t.internal_nonce ctxt) 65535 then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok
      ((* ‚ùå Record substitution not handled *)
      record_substitution, (t.internal_nonce ctxt)).

Definition reset_internal_nonce (ctxt : t) : t :=
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition record_internal_nonce (ctxt : t) (k : Int_set.[S.SET.elt]) : t :=
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition internal_nonce_already_recorded (ctxt : t) (k : Int_set.[S.SET.elt])
  : bool := Int_set.[S.SET.mem] k (t.internal_nonces_used ctxt).

Definition set_current_fitness (ctxt : t) (fitness : Int64.t) : t :=
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition add_fees (ctxt : t) (fees : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Tez_repr.op_plusquestion (t.fees ctxt) fees))
    (fun fees =&gt;
      Error_monad.__return
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition add_rewards (ctxt : t) (rewards : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Tez_repr.op_plusquestion (t.rewards ctxt) rewards))
    (fun rewards =&gt;
      Error_monad.__return
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition add_deposit
  (ctxt : t)
  (delegate :
    Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.key))
  (deposit : Tez_repr.t) : Lwt.t (Error_monad.tzresult t) :=
  let previous :=
    match
      Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.find_opt)
        delegate (t.deposits ctxt) with
    | Some tz =&gt; tz
    | None =&gt; Tez_repr.zero
    end in
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Tez_repr.op_plusquestion previous deposit))
    (fun deposit =&gt;
      let deposits :=
        Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.add)
          delegate deposit (t.deposits ctxt) in
      Error_monad.__return
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition get_deposits (ctxt : t)
  : Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    Tez_repr.t := t.deposits ctxt.

Definition get_rewards (ctxt : t) : Tez_repr.t := t.rewards ctxt.

Definition get_fees (ctxt : t) : Tez_repr.t := t.fees ctxt.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition init_origination_nonce
  (ctxt : t) (operation_hash : Operation_hash.[S.HASH.t]) : t :=
  let origination_nonce :=
    Some (Contract_repr.initial_origination_nonce operation_hash) in
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition origination_nonce (ctxt : t)
  : Error_monad.tzresult Contract_repr.origination_nonce :=
  match t.origination_nonce ctxt with
  | None =&gt; Error_monad.__error_value extensible_type_value
  | Some origination_nonce =&gt; Error_monad.ok origination_nonce
  end.

Definition increment_origination_nonce (ctxt : t)
  : Error_monad.tzresult (t * Contract_repr.origination_nonce) :=
  match t.origination_nonce ctxt with
  | None =&gt; Error_monad.__error_value extensible_type_value
  | Some cur_origination_nonce =&gt;
    let origination_nonce :=
      Some (Contract_repr.incr_origination_nonce cur_origination_nonce) in
    Error_monad.ok
      ((* ‚ùå Record substitution not handled *)
      record_substitution, cur_origination_nonce)
  end.

Definition unset_origination_nonce (ctxt : t) : t :=
  (* ‚ùå Record substitution not handled *)
  record_substitution.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition check_gas_limit (ctxt : t) (remaining : Compare.Z.[Compare.S.t])
  : Error_monad.tzresult unit :=
  if
    Pervasives.op_pipepipe
      (Compare.Z.[Compare.S.op_gt] remaining
        (Constants_repr.parametric.hard_gas_limit_per_operation
          (t.constants ctxt))) (Compare.Z.[Compare.S.op_lt] remaining Z.zero)
    then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok tt.

Definition set_gas_limit (ctxt : t) (remaining : Z.t) : t :=
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition set_gas_unlimited (ctxt : t) : t :=
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition consume_gas (ctxt : t) (cost : Gas_limit_repr.cost)
  : Error_monad.tzresult t :=
  Error_monad.op_gtgtquestion
    (Gas_limit_repr.consume (t.block_gas ctxt) (t.operation_gas ctxt)
      (t.internal_gas ctxt) cost)
    (fun function_parameter =&gt;
      let '(block_gas, operation_gas, __internal_gas_value) :=
        function_parameter in
      Error_monad.ok
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition check_enough_gas (ctxt : t) (cost : Gas_limit_repr.cost)
  : Error_monad.tzresult unit :=
  Gas_limit_repr.check_enough (t.block_gas ctxt) (t.operation_gas ctxt)
    (t.internal_gas ctxt) cost.

Definition gas_level (ctxt : t) : Gas_limit_repr.t := t.operation_gas ctxt.

Definition block_gas_level (ctxt : t) : Z.t := t.block_gas ctxt.

Definition gas_consumed (since : t) (until : t) : Z.t :=
  match ((gas_level since), (gas_level until)) with
  |
    (Gas_limit_repr.Limited {| Gas_limit_repr.t.Limited.remaining := before |},
      Gas_limit_repr.Limited {| Gas_limit_repr.t.Limited.remaining := after |})
    =&gt; Z.sub before after
  | (_, _) =&gt; Z.zero
  end.

Definition init_storage_space_to_pay (ctxt : t) : t :=
  match t.storage_space_to_pay ctxt with
  | Some _ =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | None =&gt;
    (* ‚ùå Record substitution not handled *)
    record_substitution
  end.

Definition update_storage_space_to_pay (ctxt : t) (n : Z.t) : t :=
  match t.storage_space_to_pay ctxt with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some storage_space_to_pay =&gt;
    (* ‚ùå Record substitution not handled *)
    record_substitution
  end.

Definition update_allocated_contracts_count (ctxt : t) : t :=
  match t.allocated_contracts ctxt with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some allocated_contracts =&gt;
    (* ‚ùå Record substitution not handled *)
    record_substitution
  end.

Definition clear_storage_space_to_pay (ctxt : t) : t * Z.t * Z :=
  match ((t.storage_space_to_pay ctxt), (t.allocated_contracts ctxt)) with
  | (None, _) | (_, None) =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | (Some storage_space_to_pay, Some allocated_contracts) =&gt;
    ((* ‚ùå Record substitution not handled *)
    record_substitution, storage_space_to_pay, allocated_contracts)
  end.

Inductive storage_error : Set :=
| Incompatible_protocol_version : string -&gt; storage_error
| Missing_key :
  list string -&gt;
  (* `Del *) unit + (* `Copy *) unit + (* `Get *) unit + (* `Set *) unit -&gt;
  storage_error
| Existing_key : list string -&gt; storage_error
| Corrupted_data : list string -&gt; storage_error.

Definition storage_error_encoding : Data_encoding.encoding storage_error :=
  Data_encoding.union None
    (cons
      (Data_encoding.__case_value &quot;Incompatible_protocol_version&quot; % string None
        (Data_encoding.Tag 0)
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;incompatible_protocol_version&quot; % string
            Data_encoding.__string_value))
        (fun function_parameter =&gt;
          match function_parameter with
          | Incompatible_protocol_version arg =&gt; Some arg
          | _ =&gt; None
          end) (fun arg =&gt; Incompatible_protocol_version arg))
      (cons
        (Data_encoding.__case_value &quot;Missing_key&quot; % string None
          (Data_encoding.Tag 1)
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;missing_key&quot; % string
              (Data_encoding.__list_value None Data_encoding.__string_value))
            (Data_encoding.req None None &quot;function&quot; % string
              (Data_encoding.string_enum
                (cons
                  (&quot;get&quot; % string,
                    (* ‚ùå Variants not supported *)
                    (* ‚ùå `Get *)
                    tt)
                  (cons
                    (&quot;set&quot; % string,
                      (* ‚ùå Variants not supported *)
                      (* ‚ùå `Set *)
                      tt)
                    (cons
                      (&quot;del&quot; % string,
                        (* ‚ùå Variants not supported *)
                        (* ‚ùå `Del *)
                        tt)
                      (cons
                        (&quot;copy&quot; % string,
                          (* ‚ùå Variants not supported *)
                          (* ‚ùå `Copy *)
                          tt) [])))))))
          (fun function_parameter =&gt;
            match function_parameter with
            | Missing_key key f =&gt; Some (key, f)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(key, f) := function_parameter in
            Missing_key key f))
        (cons
          (Data_encoding.__case_value &quot;Existing_key&quot; % string None
            (Data_encoding.Tag 2)
            (Data_encoding.obj1
              (Data_encoding.req None None &quot;existing_key&quot; % string
                (Data_encoding.__list_value None Data_encoding.__string_value)))
            (fun function_parameter =&gt;
              match function_parameter with
              | Existing_key key =&gt; Some key
              | _ =&gt; None
              end) (fun key =&gt; Existing_key key))
          (cons
            (Data_encoding.__case_value &quot;Corrupted_data&quot; % string None
              (Data_encoding.Tag 3)
              (Data_encoding.obj1
                (Data_encoding.req None None &quot;corrupted_data&quot; % string
                  (Data_encoding.__list_value None Data_encoding.__string_value)))
              (fun function_parameter =&gt;
                match function_parameter with
                | Corrupted_data key =&gt; Some key
                | _ =&gt; None
                end) (fun key =&gt; Corrupted_data key)) [])))).

Definition pp_storage_error
  (ppf : Format.formatter) (function_parameter : storage_error) : unit :=
  match function_parameter with
  | Incompatible_protocol_version version =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Found a context with an unexpected version '&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;Found a context with an unexpected version '%s'.&quot; % string) version
  | Missing_key key Get =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Missing key '&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;Missing key '%s'.&quot; % string) (String.concat &quot;/&quot; % string key)
  | Missing_key key __Set =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Cannot set undefined key '&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot set undefined key '%s'.&quot; % string)
      (String.concat &quot;/&quot; % string key)
  | Missing_key key Del =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Cannot delete undefined key '&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot delete undefined key '%s'.&quot; % string)
      (String.concat &quot;/&quot; % string key)
  | Missing_key key Copy =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Cannot copy undefined key '&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot copy undefined key '%s'.&quot; % string)
      (String.concat &quot;/&quot; % string key)
  | Existing_key key =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Cannot initialize defined key '&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot initialize defined key '%s'.&quot; % string)
      (String.concat &quot;/&quot; % string key)
  | Corrupted_data key =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Failed to parse the data at '&quot; % string
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot; % string
              CamlinternalFormatBasics.End_of_format)))
        &quot;Failed to parse the data at '%s'.&quot; % string)
      (String.concat &quot;/&quot; % string key)
  end.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition storage_error {A : Set} (err : storage_error)
  : Lwt.t (Error_monad.tzresult A) := Error_monad.fail extensible_type_value.

Definition version_key : list string := cons &quot;version&quot; % string [].

Definition version_value : string := &quot;alpha_current&quot; % string.

Definition version : string := &quot;v1&quot; % string.

Definition first_level_key : list string :=
  cons version (cons &quot;first_level&quot; % string []).

Definition constants_key : list string :=
  cons version (cons &quot;constants&quot; % string []).

Definition protocol_param_key : list string :=
  cons &quot;protocol_parameters&quot; % string [].

Definition get_first_level (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult Raw_level_repr.raw_level) :=
  Error_monad.op_gtgteq (Context.get ctxt first_level_key)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt;
        storage_error
          (Missing_key first_level_key
            (* ‚ùå Variants not supported *)
            (* ‚ùå `Get *)
            tt)
      | Some __bytes_value =&gt;
        match
          Data_encoding.Binary.of_bytes Raw_level_repr.encoding __bytes_value
          with
        | None =&gt; storage_error (Corrupted_data first_level_key)
        | Some level =&gt; Error_monad.__return level
        end
      end).

Definition set_first_level (ctxt : Context.t) (level : Raw_level_repr.raw_level)
  : Lwt.t (Error_monad.tzresult Context.t) :=
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Raw_level_repr.encoding level in
  Error_monad.op_gtgteq (Context.set ctxt first_level_key __bytes_value)
    (fun ctxt =&gt; Error_monad.__return ctxt).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition get_proto_param (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult (Parameters_repr.t * Context.t)) :=
  Error_monad.op_gtgteq (Context.get ctxt protocol_param_key)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Pervasives.failwith &quot;Missing protocol parameters.&quot; % string
      | Some __bytes_value =&gt;
        match
          Data_encoding.Binary.of_bytes Data_encoding.__json_value __bytes_value
          with
        | None =&gt; Error_monad.fail extensible_type_value
        | Some __json_value =&gt;
          Error_monad.op_gtgteq (Context.del ctxt protocol_param_key)
            (fun ctxt =&gt;
              let 'param :=
                Data_encoding.Json.destruct Parameters_repr.encoding
                  __json_value in
              Error_monad.__return (param, ctxt))
        end
      end).

Definition set_constants
  (ctxt : Context.t) (constants : Constants_repr.parametric)
  : Lwt.t Context.t :=
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Constants_repr.parametric_encoding
      constants in
  Context.set ctxt constants_key __bytes_value.

Definition get_constants (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult Constants_repr.parametric) :=
  Error_monad.op_gtgteq (Context.get ctxt constants_key)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt;
        Pervasives.failwith
          &quot;Internal error: cannot read constants in context.&quot; % string
      | Some __bytes_value =&gt;
        match
          Data_encoding.Binary.of_bytes Constants_repr.parametric_encoding
            __bytes_value with
        | None =&gt;
          Pervasives.failwith
            &quot;Internal error: cannot parse constants in context.&quot; % string
        | Some constants =&gt; Error_monad.__return constants
        end
      end).

Definition patch_constants
  (ctxt : t) (f : Constants_repr.parametric -&gt; Constants_repr.parametric)
  : Lwt.t t :=
  let constants := f (t.constants ctxt) in
  Error_monad.op_gtgteq (set_constants (t.context ctxt) constants)
    (fun context =&gt;
      Lwt.__return
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition check_inited (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult unit) :=
  Error_monad.op_gtgteq (Context.get ctxt version_key)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt;
        Pervasives.failwith &quot;Internal error: un-initialized context.&quot; % string
      | Some __bytes_value =&gt;
        let s := MBytes.to_string __bytes_value in
        if Compare.String.[Compare.S.op_eq] s version_value then
          Error_monad.return_unit
        else
          storage_error (Incompatible_protocol_version s)
      end).

Definition prepare
  (level : int32) (predecessor_timestamp : Time.t) (timestamp : Time.t)
  (fitness : list MBytes.t) (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteqquestion (Lwt.__return (Raw_level_repr.of_int32 level))
    (fun level =&gt;
      Error_monad.op_gtgteqquestion
        (Lwt.__return (Fitness_repr.to_int64 fitness))
        (fun fitness =&gt;
          Error_monad.op_gtgteqquestion (check_inited ctxt)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion (get_constants ctxt)
                (fun constants =&gt;
                  Error_monad.op_gtgteqquestion (get_first_level ctxt)
                    (fun first_level =&gt;
                      let level :=
                        Level_repr.from_raw first_level
                          (Constants_repr.parametric.blocks_per_cycle constants)
                          (Constants_repr.parametric.blocks_per_voting_period
                            constants)
                          (Constants_repr.parametric.blocks_per_commitment
                            constants) level in
                      Error_monad.__return
                        {| t.context := ctxt; t.constants := constants;
                          t.first_level := first_level; t.level := level;
                          t.predecessor_timestamp := predecessor_timestamp;
                          t.timestamp := timestamp; t.fitness := fitness;
                          t.deposits :=
                            Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.empty);
                          t.included_endorsements := 0;
                          t.allowed_endorsements :=
                            Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.empty);
                          t.fees := Tez_repr.zero; t.rewards := Tez_repr.zero;
                          t.block_gas :=
                            Constants_repr.parametric.hard_gas_limit_per_block
                              constants;
                          t.operation_gas := Gas_limit_repr.Unaccounted;
                          t.internal_gas := Gas_limit_repr.internal_gas_zero;
                          t.storage_space_to_pay := None;
                          t.allocated_contracts := None;
                          t.origination_nonce := None;
                          t.temporary_big_map := Z.sub Z.zero Z.one;
                          t.internal_nonce := 0;
                          t.internal_nonces_used := Int_set.[S.SET.empty] |}))))).

Inductive previous_protocol : Set :=
| Genesis : Parameters_repr.t -&gt; previous_protocol
| Alpha_previous : previous_protocol.

Definition check_and_update_protocol_version (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult (previous_protocol * Context.t)) :=
  Error_monad.op_gtgteqquestion
    (Error_monad.op_gtgteq (Context.get ctxt version_key)
      (fun function_parameter =&gt;
        match function_parameter with
        | None =&gt;
          Pervasives.failwith
            &quot;Internal error: un-initialized context in check_first_block.&quot; %
              string
        | Some __bytes_value =&gt;
          let s := MBytes.to_string __bytes_value in
          if Compare.String.[Compare.S.op_eq] s version_value then
            Pervasives.failwith
              &quot;Internal error: previously initialized context.&quot; % string
          else
            if Compare.String.[Compare.S.op_eq] s &quot;genesis&quot; % string then
              Error_monad.op_gtgteqquestion (get_proto_param ctxt)
                (fun function_parameter =&gt;
                  let '(param, ctxt) := function_parameter in
                  Error_monad.__return ((Genesis param), ctxt))
            else
              if Compare.String.[Compare.S.op_eq] s &quot;alpha_previous&quot; % string
                then
                Error_monad.__return (Alpha_previous, ctxt)
              else
                storage_error (Incompatible_protocol_version s)
        end))
    (fun function_parameter =&gt;
      let '(previous_proto, ctxt) := function_parameter in
      Error_monad.op_gtgteq
        (Context.set ctxt version_key (MBytes.of_string version_value))
        (fun ctxt =&gt; Error_monad.__return (previous_proto, ctxt))).

Definition prepare_first_block
  (level : int32) (timestamp : Time.t) (fitness : list MBytes.t)
  (ctxt : Context.t) : Lwt.t (Error_monad.tzresult (previous_protocol * t)) :=
  Error_monad.op_gtgteqquestion (check_and_update_protocol_version ctxt)
    (fun function_parameter =&gt;
      let '(previous_proto, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        match previous_proto with
        | Genesis param =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Raw_level_repr.of_int32 level))
            (fun first_level =&gt;
              Error_monad.op_gtgteqquestion (set_first_level ctxt first_level)
                (fun ctxt =&gt;
                  Error_monad.op_gtgteq
                    (set_constants ctxt (Parameters_repr.t.constants param))
                    (fun ctxt =&gt; Error_monad.__return ctxt)))
        | Alpha_previous =&gt; Error_monad.__return ctxt
        end
        (fun ctxt =&gt;
          Error_monad.op_gtgteqquestion
            (prepare level timestamp timestamp fitness ctxt)
            (fun ctxt =&gt; Error_monad.__return (previous_proto, ctxt)))).

Definition activate (function_parameter : t)
  : Protocol_hash.[S.HASH.t] -&gt; Lwt.t t :=
  let '{| t.context := c |} as s := function_parameter in
  fun h =&gt;
    Error_monad.op_gtgteq (Updater.activate c h)
      (fun c =&gt;
        Lwt.__return
          (* ‚ùå Record substitution not handled *)
          record_substitution).

Definition fork_test_chain (function_parameter : t)
  : Protocol_hash.[S.HASH.t] -&gt; Time.t -&gt; Lwt.t t :=
  let '{| t.context := c |} as s := function_parameter in
  fun protocol =&gt;
    fun expiration =&gt;
      Error_monad.op_gtgteq (Updater.fork_test_chain c protocol expiration)
        (fun c =&gt;
          Lwt.__return
            (* ‚ùå Record substitution not handled *)
            record_substitution).

Definition key := list string.

Definition value := MBytes.t.

Module T.
  Record signature {t : Set} := {
    t := t;
    context := t;
    mem : context -&gt; key -&gt; Lwt.t bool;
    dir_mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (option value);
    init : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t context;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t context;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    remove : context -&gt; key -&gt; Lwt.t context;
    remove_rec : context -&gt; key -&gt; Lwt.t context;
    copy : context -&gt; key -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    fold : forall {a : Set},
      context -&gt; key -&gt; a -&gt;
      ((* `Dir *) key + (* `Key *) key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    keys : context -&gt; key -&gt; Lwt.t (list key);
    fold_keys : forall {a : Set},
      context -&gt; key -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    project : context -&gt; root_context;
    absolute_key : context -&gt; key -&gt; key;
    consume_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult context;
    check_enough_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult unit;
    description : Storage_description.t context;
  }.
  Arguments signature : clear implicits.
End T.

Definition mem (ctxt : t) (k : Context.key) : Lwt.t bool :=
  Context.mem (t.context ctxt) k.

Definition dir_mem (ctxt : t) (k : Context.key) : Lwt.t bool :=
  Context.dir_mem (t.context ctxt) k.

Definition get (ctxt : t) (k : Context.key)
  : Lwt.t (Error_monad.tzresult Context.value) :=
  Error_monad.op_gtgteq (Context.get (t.context ctxt) k)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt;
        storage_error
          (Missing_key k
            (* ‚ùå Variants not supported *)
            (* ‚ùå `Get *)
            tt)
      | Some v =&gt; Error_monad.__return v
      end).

Definition get_option (ctxt : t) (k : Context.key)
  : Lwt.t (option Context.value) := Context.get (t.context ctxt) k.

Definition set (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.mem (t.context ctxt) k)
    (fun function_parameter =&gt;
      match function_parameter with
      | false =&gt;
        storage_error
          (Missing_key k
            (* ‚ùå Variants not supported *)
            (* ‚ùå `Set *)
            tt)
      | true =&gt;
        Error_monad.op_gtgteq (Context.set (t.context ctxt) k v)
          (fun context =&gt;
            Error_monad.__return
              (* ‚ùå Record substitution not handled *)
              record_substitution)
      end).

Definition init (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.mem (t.context ctxt) k)
    (fun function_parameter =&gt;
      match function_parameter with
      | true =&gt; storage_error (Existing_key k)
      | false =&gt;
        Error_monad.op_gtgteq (Context.set (t.context ctxt) k v)
          (fun context =&gt;
            Error_monad.__return
              (* ‚ùå Record substitution not handled *)
              record_substitution)
      end).

Definition init_set (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t t :=
  Error_monad.op_gtgteq (Context.set (t.context ctxt) k v)
    (fun context =&gt;
      Lwt.__return
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition delete (ctxt : t) (k : Context.key)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.mem (t.context ctxt) k)
    (fun function_parameter =&gt;
      match function_parameter with
      | false =&gt;
        storage_error
          (Missing_key k
            (* ‚ùå Variants not supported *)
            (* ‚ùå `Del *)
            tt)
      | true =&gt;
        Error_monad.op_gtgteq (Context.del (t.context ctxt) k)
          (fun context =&gt;
            Error_monad.__return
              (* ‚ùå Record substitution not handled *)
              record_substitution)
      end).

Definition remove (ctxt : t) (k : Context.key) : Lwt.t t :=
  Error_monad.op_gtgteq (Context.del (t.context ctxt) k)
    (fun context =&gt;
      Lwt.__return
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition set_option
  (ctxt : t) (k : Context.key) (function_parameter : option Context.value)
  : Lwt.t t :=
  match function_parameter with
  | None =&gt; remove ctxt k
  | Some v =&gt; init_set ctxt k v
  end.

Definition remove_rec (ctxt : t) (k : Context.key) : Lwt.t t :=
  Error_monad.op_gtgteq (Context.remove_rec (t.context ctxt) k)
    (fun context =&gt;
      Lwt.__return
        (* ‚ùå Record substitution not handled *)
        record_substitution).

Definition copy (ctxt : t) (from : Context.key) (to_ : Context.key)
  : Lwt.t (Error_monad.tzresult t) :=
  Error_monad.op_gtgteq (Context.copy (t.context ctxt) from to_)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt;
        storage_error
          (Missing_key from
            (* ‚ùå Variants not supported *)
            (* ‚ùå `Copy *)
            tt)
      | Some context =&gt;
        Error_monad.__return
          (* ‚ùå Record substitution not handled *)
          record_substitution
      end).

Definition fold {A : Set}
  (ctxt : t) (k : Context.key) (init : A)
  (f : (* `Dir *) Context.key + (* `Key *) Context.key -&gt; A -&gt; Lwt.t A)
  : Lwt.t A := Context.fold (t.context ctxt) k init f.

Definition keys (ctxt : t) (k : Context.key) : Lwt.t (list Context.key) :=
  Context.keys (t.context ctxt) k.

Definition fold_keys {A : Set}
  (ctxt : t) (k : Context.key) (init : A) (f : Context.key -&gt; A -&gt; Lwt.t A)
  : Lwt.t A := Context.fold_keys (t.context ctxt) k init f.

Definition project {A : Set} (x : A) : A := x.

Definition absolute_key {A B : Set} (function_parameter : A) : B -&gt; B :=
  let '_ := function_parameter in
  fun k =&gt; k.

Definition description {A : Set} : Storage_description.t A :=
  Storage_description.create tt.

Definition fresh_temporary_big_map (ctxt : t) : t * Z.t :=
  ((* ‚ùå Record substitution not handled *)
  record_substitution, (t.temporary_big_map ctxt)).

Definition reset_temporary_big_map (ctxt : t) : t :=
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition temporary_big_maps {A : Set}
  (ctxt : t) (f : A -&gt; Z.t -&gt; Lwt.t A) (acc : A) : Lwt.t A :=
  let fix iter (acc : A) (id : Z.t) {struct acc} : Lwt.t A :=
    if Z.equal id (t.temporary_big_map ctxt) then
      Lwt.__return acc
    else
      Error_monad.op_gtgteq (f acc id) (fun acc =&gt; iter acc (Z.sub id Z.one)) in
  iter acc (Z.sub Z.zero Z.one).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_context.mli">
  <div class="col-md-6">
    <a href="#raw_context.mli"><code>raw_context.mli</code></a>&nbsp;<span class="label label-danger">8 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** {1 Errors} *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Too_many_internal_operations</abbr> (* `Permanent *)

(** An internal storage error that should not happen *)
type storage_error =
  | Incompatible_protocol_version of string
  <abbr class="mark-error" title="Polymorphic variant types are not handled">| Missing_key of string list * [`Get | `Set | `Del | `Copy]</abbr>
  | Existing_key of string list
  | Corrupted_data of string list

<abbr class="mark-error" title="Extensible types are not handled.">type error += Storage_error of storage_error</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Failed_to_parse_parameter of MBytes.t</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Failed_to_decode_parameter of Data_encoding.json * string</abbr>

val storage_error : storage_error -&gt; 'a tzresult Lwt.t

(** {1 Abstract Context} *)

(** Abstract view of the context.
    Includes a handle to the functional key-value database
    ({!Context.t}) along with some in-memory values (gas, etc.). *)
type t

type context = t

type root_context = t

(** Retrieves the state of the database and gives its abstract view.
    It also returns wether this is the first block validated
    with this version of the protocol. *)
val prepare :
  level:Int32.t -&gt;
  predecessor_timestamp:Time.t -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  Context.t -&gt;
  context tzresult Lwt.t

type previous_protocol = Genesis of Parameters_repr.t | Alpha_previous

val prepare_first_block :
  level:int32 -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  Context.t -&gt;
  (previous_protocol * context) tzresult Lwt.t

val activate : context -&gt; Protocol_hash.t -&gt; t Lwt.t

val fork_test_chain : context -&gt; Protocol_hash.t -&gt; Time.t -&gt; t Lwt.t

(** Returns the state of the database resulting of operations on its
    abstract view *)
val recover : context -&gt; Context.t

val current_level : context -&gt; Level_repr.t

val predecessor_timestamp : context -&gt; Time.t

val current_timestamp : context -&gt; Time.t

val current_fitness : context -&gt; Int64.t

val set_current_fitness : context -&gt; Int64.t -&gt; t

val constants : context -&gt; Constants_repr.parametric

val patch_constants :
  context -&gt;
  (Constants_repr.parametric -&gt; Constants_repr.parametric) -&gt;
  context Lwt.t

val first_level : context -&gt; Raw_level_repr.t

(** Increment the current block fee stash that will be credited to baker's
    frozen_fees account at finalize_application *)
val add_fees : context -&gt; Tez_repr.t -&gt; context tzresult Lwt.t

(** Increment the current block reward stash that will be credited to baker's
    frozen_fees account at finalize_application *)
val add_rewards : context -&gt; Tez_repr.t -&gt; context tzresult Lwt.t

(** Increment the current block deposit stash for a specific delegate. All the
    delegates' frozen_deposit accounts are credited at finalize_application *)
val add_deposit :
  context -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  context tzresult Lwt.t

val get_fees : context -&gt; Tez_repr.t

val get_rewards : context -&gt; Tez_repr.t

val get_deposits : context -&gt; Tez_repr.t Signature.Public_key_hash.Map.t

<abbr class="mark-error" title="Extensible types are not handled.">type error += Gas_limit_too_high</abbr> (* `Permanent *)

val check_gas_limit : t -&gt; Z.t -&gt; unit tzresult

val set_gas_limit : t -&gt; Z.t -&gt; t

val set_gas_unlimited : t -&gt; t

val gas_level : t -&gt; Gas_limit_repr.t

val gas_consumed : since:t -&gt; until:t -&gt; Z.t

val block_gas_level : t -&gt; Z.t

val init_storage_space_to_pay : t -&gt; t

val update_storage_space_to_pay : t -&gt; Z.t -&gt; t

val update_allocated_contracts_count : t -&gt; t

val clear_storage_space_to_pay : t -&gt; t * Z.t * int

<abbr class="mark-error" title="Extensible types are not handled.">type error += Undefined_operation_nonce</abbr> (* `Permanent *)

val init_origination_nonce : t -&gt; Operation_hash.t -&gt; t

val origination_nonce : t -&gt; Contract_repr.origination_nonce tzresult

val increment_origination_nonce :
  t -&gt; (t * Contract_repr.origination_nonce) tzresult

val unset_origination_nonce : t -&gt; t

(** {1 Generic accessors} *)

type key = string list

type value = MBytes.t

(** All context manipulation functions. This signature is included
    as-is for direct context accesses, and used in {!Storage_functors}
    to provide restricted views to the context. *)
module type T = sig
  type t

  type context = t

  (** Tells if the key is already defined as a value. *)
  val mem : context -&gt; key -&gt; bool Lwt.t

  (** Tells if the key is already defined as a directory. *)
  val dir_mem : context -&gt; key -&gt; bool Lwt.t

  (** Retrieve the value from the storage bucket ; returns a
      {!Storage_error Missing_key} if the key is not set. *)
  val get : context -&gt; key -&gt; value tzresult Lwt.t

  (** Retrieves the value from the storage bucket ; returns [None] if
      the data is not initialized. *)
  val get_option : context -&gt; key -&gt; value option Lwt.t

  (** Allocates the storage bucket and initializes it ; returns a
      {!Storage_error Existing_key} if the bucket exists. *)
  val init : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  (** Updates the content of the bucket ; returns a {!Storage_error
      Missing_key} if the value does not exists. *)
  val set : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  (** Allocates the data and initializes it with a value ; just
      updates it if the bucket exists. *)
  val init_set : context -&gt; key -&gt; value -&gt; context Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists. *)
  val set_option : context -&gt; key -&gt; value option -&gt; context Lwt.t

  (** Delete the storage bucket ; returns a {!Storage_error
      Missing_key} if the bucket does not exists. *)
  val delete : context -&gt; key -&gt; context tzresult Lwt.t

  (** Removes the storage bucket and its contents ; does nothing if the
      bucket does not exists. *)
  val remove : context -&gt; key -&gt; context Lwt.t

  (** Recursively removes all the storage buckets and contents ; does
      nothing if no bucket exists. *)
  val remove_rec : context -&gt; key -&gt; context Lwt.t

  val copy : context -&gt; from:key -&gt; to_:key -&gt; context tzresult Lwt.t

  (** Iterator on all the items of a given directory. *)
  <abbr class="mark-error" title="Polymorphic variant types are not handled">val fold :
    context -&gt;
    key -&gt;
    init:'a -&gt;
    f:([`Key of key | `Dir of key] -&gt; 'a -&gt; 'a Lwt.t) -&gt;
    'a Lwt.t</abbr>

  (** Recursively list all subkeys of a given key. *)
  val keys : context -&gt; key -&gt; key list Lwt.t

  (** Recursive iterator on all the subkeys of a given key. *)
  val fold_keys :
    context -&gt; key -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  (** Internally used in {!Storage_functors} to escape from a view. *)
  val project : context -&gt; root_context

  (** Internally used in {!Storage_functors} to retrieve a full key
      from partial key relative a view. *)
  val absolute_key : context -&gt; key -&gt; key

  (** Internally used in {!Storage_functors} to consume gas from
      within a view. *)
  val consume_gas : context -&gt; Gas_limit_repr.cost -&gt; context tzresult

  (** Check if consume_gas will fail *)
  val check_enough_gas : context -&gt; Gas_limit_repr.cost -&gt; unit tzresult

  val description : context Storage_description.t
end

include T with type t := t and type context := context

(** Initialize the local nonce used for preventing a script to
    duplicate an internal operation to replay it. *)
val reset_internal_nonce : context -&gt; context

(** Increments the internal operation nonce. *)
val fresh_internal_nonce : context -&gt; (context * int) tzresult

(** Mark an internal operation nonce as taken. *)
val record_internal_nonce : context -&gt; int -&gt; context

(** Check is the internal operation nonce has been taken. *)
val internal_nonce_already_recorded : context -&gt; int -&gt; bool

(** Returns a map where to each endorser's pkh is associated the list of its
    endorsing slots (in decreasing order) for a given level. *)
val allowed_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t

(** Keep track of the number of endorsements that are included in a block *)
val included_endorsements : context -&gt; int

(** Initializes the map of allowed endorsements, this function must only be
    called once. *)
val init_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t -&gt;
  context

(** Marks an endorsment in the map as used. *)
val record_endorsement : context -&gt; Signature.Public_key_hash.t -&gt; context

(** Provide a fresh identifier for a temporary big map (negative index). *)
val fresh_temporary_big_map : context -&gt; context * Z.t

(** Reset the temporary big_map identifier generator to [-1]. *)
val reset_temporary_big_map : context -&gt; context

(** Iterate over all created temporary big maps since the last {!reset_temporary_big_map}. *)
val temporary_big_maps : context -&gt; ('a -&gt; Z.t -&gt; 'a Lwt.t) -&gt; 'a -&gt; 'a Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_context.mli"><code>Raw_context_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Parameters_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Inductive storage_error : Set :=
| Incompatible_protocol_version : string -&gt; storage_error
| Missing_key :
  list string -&gt;
  (* `Del *) unit + (* `Copy *) unit + (* `Get *) unit + (* `Set *) unit -&gt;
  storage_error
| Existing_key : list string -&gt; storage_error
| Corrupted_data : list string -&gt; storage_error.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter storage_error : forall {a : Set},
  storage_error -&gt; Lwt.t (Error_monad.tzresult a).

Parameter t : Set.

Definition context := t.

Definition root_context := t.

Parameter prepare :
  Int32.t -&gt; Time.t -&gt; Time.t -&gt; Fitness.[S.T.t] -&gt; Context.t -&gt;
  Lwt.t (Error_monad.tzresult context).

Inductive previous_protocol : Set :=
| Genesis : Parameters_repr.t -&gt; previous_protocol
| Alpha_previous : previous_protocol.

Parameter prepare_first_block :
  int32 -&gt; Time.t -&gt; Fitness.[S.T.t] -&gt; Context.t -&gt;
  Lwt.t (Error_monad.tzresult (previous_protocol * context)).

Parameter activate : context -&gt; Protocol_hash.[S.HASH.t] -&gt; Lwt.t t.

Parameter fork_test_chain :
  context -&gt; Protocol_hash.[S.HASH.t] -&gt; Time.t -&gt; Lwt.t t.

Parameter recover : context -&gt; Context.t.

Parameter current_level : context -&gt; Level_repr.t.

Parameter predecessor_timestamp : context -&gt; Time.t.

Parameter current_timestamp : context -&gt; Time.t.

Parameter current_fitness : context -&gt; Int64.t.

Parameter set_current_fitness : context -&gt; Int64.t -&gt; t.

Parameter constants : context -&gt; Constants_repr.parametric.

Parameter patch_constants :
  context -&gt; (Constants_repr.parametric -&gt; Constants_repr.parametric) -&gt;
  Lwt.t context.

Parameter first_level : context -&gt; Raw_level_repr.t.

Parameter add_fees :
  context -&gt; Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_rewards :
  context -&gt; Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_deposit :
  context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult context).

Parameter get_fees : context -&gt; Tez_repr.t.

Parameter get_rewards : context -&gt; Tez_repr.t.

Parameter get_deposits :
  context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    Tez_repr.t.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter check_gas_limit : t -&gt; Z.t -&gt; Error_monad.tzresult unit.

Parameter set_gas_limit : t -&gt; Z.t -&gt; t.

Parameter set_gas_unlimited : t -&gt; t.

Parameter gas_level : t -&gt; Gas_limit_repr.t.

Parameter gas_consumed : t -&gt; t -&gt; Z.t.

Parameter block_gas_level : t -&gt; Z.t.

Parameter init_storage_space_to_pay : t -&gt; t.

Parameter update_storage_space_to_pay : t -&gt; Z.t -&gt; t.

Parameter update_allocated_contracts_count : t -&gt; t.

Parameter clear_storage_space_to_pay : t -&gt; t * Z.t * Z.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter init_origination_nonce : t -&gt; Operation_hash.[S.HASH.t] -&gt; t.

Parameter origination_nonce :
  t -&gt; Error_monad.tzresult Contract_repr.origination_nonce.

Parameter increment_origination_nonce :
  t -&gt; Error_monad.tzresult (t * Contract_repr.origination_nonce).

Parameter unset_origination_nonce : t -&gt; t.

Definition key := list string.

Definition value := MBytes.t.

Module T.
  Record signature {t : Set} := {
    t := t;
    context := t;
    mem : context -&gt; key -&gt; Lwt.t bool;
    dir_mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (option value);
    init : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t context;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t context;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    remove : context -&gt; key -&gt; Lwt.t context;
    remove_rec : context -&gt; key -&gt; Lwt.t context;
    copy : context -&gt; key -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    fold : forall {a : Set},
      context -&gt; key -&gt; a -&gt;
      ((* `Dir *) key + (* `Key *) key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    keys : context -&gt; key -&gt; Lwt.t (list key);
    fold_keys : forall {a : Set},
      context -&gt; key -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    project : context -&gt; root_context;
    absolute_key : context -&gt; key -&gt; key;
    consume_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult context;
    check_enough_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult unit;
    description : Storage_description.t context;
  }.
  Arguments signature : clear implicits.
End T.

Parameter Included_T : {_ : unit &amp; T.signature t}.

Definition mem := Included_T.[T.mem].

Definition dir_mem := Included_T.[T.dir_mem].

Definition get := Included_T.[T.get].

Definition get_option := Included_T.[T.get_option].

Definition init := Included_T.[T.init].

Definition set := Included_T.[T.set].

Definition init_set := Included_T.[T.init_set].

Definition set_option := Included_T.[T.set_option].

Definition delete := Included_T.[T.delete].

Definition remove := Included_T.[T.remove].

Definition remove_rec := Included_T.[T.remove_rec].

Definition copy := Included_T.[T.copy].

Definition fold := Included_T.[T.fold].

Definition keys := Included_T.[T.keys].

Definition fold_keys := Included_T.[T.fold_keys].

Definition project := Included_T.[T.project].

Definition absolute_key := Included_T.[T.absolute_key].

Definition consume_gas := Included_T.[T.consume_gas].

Definition check_enough_gas := Included_T.[T.check_enough_gas].

Definition description := Included_T.[T.description].

Parameter reset_internal_nonce : context -&gt; context.

Parameter fresh_internal_nonce : context -&gt; Error_monad.tzresult (context * Z).

Parameter record_internal_nonce : context -&gt; Z -&gt; context.

Parameter internal_nonce_already_recorded : context -&gt; Z -&gt; bool.

Parameter allowed_endorsements :
  context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    (Signature.Public_key.[S.SPublic_key.t] * list Z * bool).

Parameter included_endorsements : context -&gt; Z.

Parameter init_endorsements :
  context -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.Map].(S.INDEXES_Map.t)
    (Signature.Public_key.[S.SPublic_key.t] * list Z * bool) -&gt; context.

Parameter record_endorsement :
  context -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt; context.

Parameter fresh_temporary_big_map : context -&gt; context * Z.t.

Parameter reset_temporary_big_map : context -&gt; context.

Parameter temporary_big_maps : forall {a : Set},
  context -&gt; (a -&gt; Z.t -&gt; Lwt.t a) -&gt; a -&gt; Lwt.t a.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_level_repr.ml">
  <div class="col-md-6">
    <a href="#raw_level_repr.ml"><code>raw_level_repr.ml</code></a>&nbsp;<span class="label label-danger">5 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = int32

type raw_level = t

include (Compare.Int32 : Compare.S with type t := t)

let encoding = Data_encoding.int32

let pp ppf level = Format.fprintf ppf &quot;%ld&quot; level

let rpc_arg =
  let construct raw_level = Int32.to_string raw_level in
  let destruct str =
    match Int32.of_string str with
    | exception <abbr class="mark-error" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">_</abbr> -&gt;
        Error &quot;Cannot parse level&quot;
    | raw_level -&gt;
        Ok raw_level
  in
  RPC_arg.make
    ~descr:&quot;A level integer&quot;
    ~name:&quot;block_level&quot;
    ~construct
    ~destruct
    ()

let root = 0l

let succ = Int32.succ

let pred l = if l = 0l then None else Some (Int32.pred l)

let diff = Int32.sub

let to_int32 l = l

let of_int32_exn l =
  if Compare.Int32.(l &gt;= 0l) then l else invalid_arg &quot;Level_repr.of_int32&quot;

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unexpected_level of Int32.t</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;unexpected_level&quot;
    ~title:&quot;Unexpected level&quot;
    ~description:&quot;Level must be non-negative.&quot;
    ~pp:(fun ppf l -&gt;
      Format.fprintf
        ppf
        &quot;The level is %s but should be non-negative.&quot;
        (Int32.to_string l))
    Data_encoding.(obj1 (req &quot;level&quot; int32))
    (function Unexpected_level l -&gt; Some l | _ -&gt; None)
    (fun l -&gt; Unexpected_level l)</abbr>

let of_int32 l = <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Ok (of_int32_exn l) with _ -&gt; error (Unexpected_level l)</abbr>

module Index = struct
  type t = raw_level

  let path_length = 1

  let to_path level l = Int32.to_string level :: l

  let of_path = function
    | [s] -&gt; <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try Some (Int32.of_string s) with _ -&gt; None )</abbr>
    | _ -&gt;
        None

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_level_repr.ml"><code>Raw_level_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition t := int32.

Definition raw_level := t.

Definition op_eq := Compare.Int32.[Compare.S.op_eq].

Definition op_ltgt := Compare.Int32.[Compare.S.op_ltgt].

Definition op_lt := Compare.Int32.[Compare.S.op_lt].

Definition op_lteq := Compare.Int32.[Compare.S.op_lteq].

Definition op_gteq := Compare.Int32.[Compare.S.op_gteq].

Definition op_gt := Compare.Int32.[Compare.S.op_gt].

Definition compare := Compare.Int32.[Compare.S.compare].

Definition equal := Compare.Int32.[Compare.S.equal].

Definition max := Compare.Int32.[Compare.S.max].

Definition min := Compare.Int32.[Compare.S.min].

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition pp (ppf : Format.formatter) (level : int32) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%ld&quot; % string) level.

Definition rpc_arg : RPC_arg.arg int32 :=
  let construct (raw_level : int32) : string :=
    Int32.to_string raw_level in
  let destruct (str : string) : Pervasives.result int32 string :=
    let 'raw_level := Int32.of_string str in
    Pervasives.Ok raw_level in
  RPC_arg.make (Some &quot;A level integer&quot; % string) &quot;block_level&quot; % string destruct
    construct tt.

Definition root : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ : int32 -&gt; int32 := Int32.succ.

Definition pred (l : t) : option int32 :=
  if
    op_eq l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    None
  else
    Some (Int32.pred l).

Definition diff : int32 -&gt; int32 -&gt; int32 := Int32.sub.

Definition to_int32 {A : Set} (l : A) : A := l.

Definition of_int32_exn (l : Compare.Int32.[Compare.S.t])
  : Compare.Int32.[Compare.S.t] :=
  if
    Compare.Int32.[Compare.S.op_gteq] l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    l
  else
    Pervasives.invalid_arg &quot;Level_repr.of_int32&quot; % string.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition of_int32 (l : Compare.Int32.[Compare.S.t])
  : Pervasives.result Compare.Int32.[Compare.S.t] (list Error_monad.__error) :=
  (* ‚ùå Try-with are not handled *)
  try (Pervasives.Ok (of_int32_exn l)).

Module Index.
  Definition t := raw_level.
  
  Definition path_length : Z := 1.
  
  Definition to_path (level : int32) (l : list string) : list string :=
    cons (Int32.to_string level) l.
  
  Definition of_path (function_parameter : list string) : option int32 :=
    match function_parameter with
    | cons s [] =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Some (Int32.of_string s))
    | _ =&gt; None
    end.
  
  Definition rpc_arg : RPC_arg.arg int32 := rpc_arg.
  
  Definition encoding : Data_encoding.encoding int32 := encoding.
  
  Definition compare : t -&gt; t -&gt; Z := compare.
End Index.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_level_repr.mli">
  <div class="col-md-6">
    <a href="#raw_level_repr.mli"><code>raw_level_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** The shell's notion of a level: an integer indicating the number of blocks
    since genesis: genesis is 0, all other blocks have increasing levels from
    there. *)
type t

type raw_level = t

val encoding : raw_level Data_encoding.t

val rpc_arg : raw_level RPC_arg.arg

val pp : Format.formatter -&gt; raw_level -&gt; unit

include Compare.S with type t := raw_level

val to_int32 : raw_level -&gt; int32

val of_int32_exn : int32 -&gt; raw_level

val of_int32 : int32 -&gt; raw_level tzresult

val diff : raw_level -&gt; raw_level -&gt; int32

val root : raw_level

val succ : raw_level -&gt; raw_level

val pred : raw_level -&gt; raw_level option

module Index : Storage_description.INDEX with type t = raw_level
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_level_repr.mli"><code>Raw_level_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Storage_description.

Parameter t : Set.

Definition raw_level := t.

Parameter encoding : Data_encoding.t raw_level.

Parameter rpc_arg : RPC_arg.arg raw_level.

Parameter pp : Format.formatter -&gt; raw_level -&gt; unit.

Parameter Included_S : {_ : unit &amp; Compare.S.signature raw_level}.

Definition op_eq := Included_S.[Compare.S.op_eq].

Definition op_ltgt := Included_S.[Compare.S.op_ltgt].

Definition op_lt := Included_S.[Compare.S.op_lt].

Definition op_lteq := Included_S.[Compare.S.op_lteq].

Definition op_gteq := Included_S.[Compare.S.op_gteq].

Definition op_gt := Included_S.[Compare.S.op_gt].

Definition compare := Included_S.[Compare.S.compare].

Definition equal := Included_S.[Compare.S.equal].

Definition max := Included_S.[Compare.S.max].

Definition min := Included_S.[Compare.S.min].

Parameter to_int32 : raw_level -&gt; int32.

Parameter of_int32_exn : int32 -&gt; raw_level.

Parameter of_int32 : int32 -&gt; Error_monad.tzresult raw_level.

Parameter diff : raw_level -&gt; raw_level -&gt; int32.

Parameter root : raw_level.

Parameter succ : raw_level -&gt; raw_level.

Parameter pred : raw_level -&gt; option raw_level.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature raw_level}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_repr.ml">
  <div class="col-md-6">
    <a href="#roll_repr.ml"><code>roll_repr.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

include Compare.Int32

type roll = t

let encoding = Data_encoding.int32

let first = 0l

let succ i = Int32.succ i

let random sequence ~bound = Seed_repr.take_int32 sequence bound

let rpc_arg = RPC_arg.like RPC_arg.int32 &quot;roll&quot;

let to_int32 v = v

module Index = struct
  type t = roll

  let path_length = 3

  let to_path roll l =
    (Int32.to_string @@ Int32.logand roll (Int32.of_int 0xff))
    :: ( Int32.to_string
       @@ Int32.logand (Int32.shift_right_logical roll 8) (Int32.of_int 0xff)
       )
    :: Int32.to_string roll :: l

  let of_path = function
    | _ :: _ :: s :: _ -&gt; <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try Some (Int32.of_string s) with _ -&gt; None )</abbr>
    | _ -&gt;
        None

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_repr.ml"><code>Roll_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Seed_repr.

Definition t := Compare.Int32.[Compare.S.t].

Definition op_eq := Compare.Int32.[Compare.S.op_eq].

Definition op_ltgt := Compare.Int32.[Compare.S.op_ltgt].

Definition op_lt := Compare.Int32.[Compare.S.op_lt].

Definition op_lteq := Compare.Int32.[Compare.S.op_lteq].

Definition op_gteq := Compare.Int32.[Compare.S.op_gteq].

Definition op_gt := Compare.Int32.[Compare.S.op_gt].

Definition compare := Compare.Int32.[Compare.S.compare].

Definition equal := Compare.Int32.[Compare.S.equal].

Definition max := Compare.Int32.[Compare.S.max].

Definition min := Compare.Int32.[Compare.S.min].

Definition roll := t.

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition first : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ (i : int32) : int32 := Int32.succ i.

Definition random (sequence : Seed_repr.sequence) (bound : int32)
  : int32 * Seed_repr.sequence := Seed_repr.take_int32 sequence bound.

Definition rpc_arg : RPC_arg.arg int32 :=
  RPC_arg.like RPC_arg.__int32_value None &quot;roll&quot; % string.

Definition to_int32 {A : Set} (v : A) : A := v.

Module Index.
  Definition t := roll.
  
  Definition path_length : Z := 3.
  
  Definition to_path (roll : int32) (l : list string) : list string :=
    cons
      (Pervasives.op_atat Int32.to_string (Int32.logand roll (Int32.of_int 255)))
      (cons
        (Pervasives.op_atat Int32.to_string
          (Int32.logand (Int32.shift_right_logical roll 8) (Int32.of_int 255)))
        (cons (Int32.to_string roll) l)).
  
  Definition of_path (function_parameter : list string) : option int32 :=
    match function_parameter with
    | cons _ (cons _ (cons s _)) =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Some (Int32.of_string s))
    | _ =&gt; None
    end.
  
  Definition rpc_arg : RPC_arg.arg int32 := rpc_arg.
  
  Definition encoding : Data_encoding.encoding int32 := encoding.
  
  Definition compare : t -&gt; t -&gt; Z := compare.
End Index.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_repr.mli">
  <div class="col-md-6">
    <a href="#roll_repr.mli"><code>roll_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = private int32

type roll = t

val encoding : roll Data_encoding.t

val rpc_arg : roll RPC_arg.t

val random : Seed_repr.sequence -&gt; bound:roll -&gt; roll * Seed_repr.sequence

val first : roll

val succ : roll -&gt; roll

val to_int32 : roll -&gt; Int32.t

val ( = ) : roll -&gt; roll -&gt; bool

module Index : Storage_description.INDEX with type t = roll
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_repr.mli"><code>Roll_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Seed_repr.
Require Tezos.Storage_description.

Definition t := int32.

Definition roll := t.

Parameter encoding : Data_encoding.t roll.

Parameter rpc_arg : RPC_arg.t roll.

Parameter random : Seed_repr.sequence -&gt; roll -&gt; roll * Seed_repr.sequence.

Parameter first : roll.

Parameter succ : roll -&gt; roll.

Parameter to_int32 : roll -&gt; Int32.t.

Parameter op_eq : roll -&gt; roll -&gt; bool.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature roll}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_storage.ml">
  <div class="col-md-6">
    <a href="#roll_storage.ml"><code>roll_storage.ml</code></a>&nbsp;<span class="label label-danger">8 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Misc

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Consume_roll_change (* `Permanent *)
  | No_roll_for_delegate (* `Permanent *)
  | No_roll_snapshot_for_cycle of Cycle_repr.t (* `Permanent *)
  | Unregistered_delegate of Signature.Public_key_hash.t</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  (* Consume roll change *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.consume_roll_change&quot;
    ~title:&quot;Consume roll change&quot;
    ~description:&quot;Change is not enough to consume a roll.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;Not enough change to consume a roll.&quot;)
    empty
    (function Consume_roll_change -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Consume_roll_change) ;
  (* No roll for delegate *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.no_roll_for_delegate&quot;
    ~title:&quot;No roll for delegate&quot;
    ~description:&quot;Delegate has no roll.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Delegate has no roll.&quot;)
    empty
    (function No_roll_for_delegate -&gt; Some () | _ -&gt; None)
    (fun () -&gt; No_roll_for_delegate) ;
  (* No roll snapshot for cycle *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.no_roll_snapshot_for_cycle&quot;
    ~title:&quot;No roll snapshot for cycle&quot;
    ~description:
      &quot;A snapshot of the rolls distribution does not exist for this cycle.&quot;
    ~pp:(fun ppf c -&gt;
      Format.fprintf
        ppf
        &quot;A snapshot of the rolls distribution does not exist for cycle %a&quot;
        Cycle_repr.pp
        c)
    (obj1 (req &quot;cycle&quot; Cycle_repr.encoding))
    (function No_roll_snapshot_for_cycle c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; No_roll_snapshot_for_cycle c) ;
  (* Unregistered delegate *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.unregistered_delegate&quot;
    ~title:&quot;Unregistered delegate&quot;
    ~description:&quot;A contract cannot be delegated to an unregistered delegate&quot;
    ~pp:(fun ppf k -&gt;
      Format.fprintf
        ppf
        &quot;The provided public key (with hash %a) is  not registered as valid \
         delegate key.&quot;
        Signature.Public_key_hash.pp
        k)
    (obj1 (req &quot;hash&quot; Signature.Public_key_hash.encoding))
    (function Unregistered_delegate k -&gt; Some k | _ -&gt; None)
    (fun k -&gt; Unregistered_delegate k)</abbr>

let get_contract_delegate c contract =
  Storage.Contract.Delegate.get_option c contract

let delegate_pubkey ctxt delegate =
  Storage.Contract.Manager.get_option
    ctxt
    (Contract_repr.implicit_contract delegate)
  &gt;&gt;=? function
  | None | Some (Manager_repr.Hash _) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unregistered_delegate delegate)</abbr>
  | Some (Manager_repr.Public_key pk) -&gt;
      return pk

let clear_cycle c cycle =
  Storage.Roll.Snapshot_for_cycle.get c cycle
  &gt;&gt;=? fun index -&gt;
  Storage.Roll.Snapshot_for_cycle.delete c cycle
  &gt;&gt;=? fun c -&gt;
  Storage.Roll.Last_for_snapshot.delete (c, cycle) index
  &gt;&gt;=? fun c -&gt;
  Storage.Roll.Owner.delete_snapshot c (cycle, index) &gt;&gt;= fun c -&gt; return c

let fold ctxt ~f init =
  Storage.Roll.Next.get ctxt
  &gt;&gt;=? fun last -&gt;
  let rec loop ctxt roll acc =
    acc
    &gt;&gt;=? fun acc -&gt;
    if Roll_repr.(roll = last) then return acc
    else
      Storage.Roll.Owner.get_option ctxt roll
      &gt;&gt;=? function
      | None -&gt;
          loop ctxt (Roll_repr.succ roll) (return acc)
      | Some delegate -&gt;
          loop ctxt (Roll_repr.succ roll) (f roll delegate acc)
  in
  loop ctxt Roll_repr.first (return init)

let snapshot_rolls_for_cycle ctxt cycle =
  Storage.Roll.Snapshot_for_cycle.get ctxt cycle
  &gt;&gt;=? fun index -&gt;
  Storage.Roll.Snapshot_for_cycle.set ctxt cycle (index + 1)
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Roll.Owner.snapshot ctxt (cycle, index)
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Roll.Next.get ctxt
  &gt;&gt;=? fun last -&gt;
  Storage.Roll.Last_for_snapshot.init (ctxt, cycle) index last
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let freeze_rolls_for_cycle ctxt cycle =
  Storage.Roll.Snapshot_for_cycle.get ctxt cycle
  &gt;&gt;=? fun max_index -&gt;
  Storage.Seed.For_cycle.get ctxt cycle
  &gt;&gt;=? fun seed -&gt;
  let rd = Seed_repr.initialize_new seed [MBytes.of_string &quot;roll_snapshot&quot;] in
  let seq = Seed_repr.sequence rd 0l in
  let selected_index =
    Seed_repr.take_int32 seq (Int32.of_int max_index) |&gt; fst |&gt; Int32.to_int
  in
  Storage.Roll.Snapshot_for_cycle.set ctxt cycle selected_index
  &gt;&gt;=? fun ctxt -&gt;
  fold_left_s
    (fun ctxt index -&gt;
      if Compare.Int.(index = selected_index) then return ctxt
      else
        Storage.Roll.Owner.delete_snapshot ctxt (cycle, index)
        &gt;&gt;= fun ctxt -&gt;
        Storage.Roll.Last_for_snapshot.delete (ctxt, cycle) index
        &gt;&gt;=? fun ctxt -&gt; return ctxt)
    ctxt
    Misc.(0 --&gt; (max_index - 1))
  &gt;&gt;=? fun ctxt -&gt; return ctxt

(* Roll selection *)

module Random = struct
  let int32_to_bytes i =
    let b = MBytes.create 4 in
    <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">MBytes.set_int32 b 0 i ; b</abbr>

  let level_random seed use level =
    let position = level.Level_repr.cycle_position in
    Seed_repr.initialize_new
      seed
      [MBytes.of_string (&quot;level &quot; ^ use ^ &quot;:&quot;); int32_to_bytes position]

  let owner c kind level offset =
    let cycle = level.Level_repr.cycle in
    Seed_storage.for_cycle c cycle
    &gt;&gt;=? fun random_seed -&gt;
    let rd = level_random random_seed kind level in
    let sequence = Seed_repr.sequence rd (Int32.of_int offset) in
    Storage.Roll.Snapshot_for_cycle.get c cycle
    &gt;&gt;=? fun index -&gt;
    Storage.Roll.Last_for_snapshot.get (c, cycle) index
    &gt;&gt;=? fun bound -&gt;
    let rec loop sequence =
      let (roll, sequence) = Roll_repr.random sequence ~bound in
      Storage.Roll.Owner.Snapshot.get_option c ((cycle, index), roll)
      &gt;&gt;=? function None -&gt; loop sequence | Some delegate -&gt; return delegate
    in
    Storage.Roll.Owner.snapshot_exists c (cycle, index)
    &gt;&gt;= fun snapshot_exists -&gt;
    fail_unless snapshot_exists <abbr class="mark-error" title="Values of extensible types are not handled">(No_roll_snapshot_for_cycle cycle)</abbr>
    &gt;&gt;=? fun () -&gt; loop sequence
end

let baking_rights_owner c level ~priority =
  Random.owner c &quot;baking&quot; level priority

let endorsement_rights_owner c level ~slot =
  Random.owner c &quot;endorsement&quot; level slot

let traverse_rolls ctxt head =
  let rec loop acc roll =
    Storage.Roll.Successor.get_option ctxt roll
    &gt;&gt;=? function
    | None -&gt; return (List.rev acc) | Some next -&gt; loop (next :: acc) next
  in
  loop [head] head

let get_rolls ctxt delegate =
  Storage.Roll.Delegate_roll_list.get_option ctxt delegate
  &gt;&gt;=? function
  | None -&gt; return_nil | Some head_roll -&gt; traverse_rolls ctxt head_roll

let count_rolls ctxt delegate =
  Storage.Roll.Delegate_roll_list.get_option ctxt delegate
  &gt;&gt;=? function
  | None -&gt;
      return 0
  | Some head_roll -&gt;
      let rec loop acc roll =
        Storage.Roll.Successor.get_option ctxt roll
        &gt;&gt;=? function None -&gt; return acc | Some next -&gt; loop (succ acc) next
      in
      loop 1 head_roll

let get_change c delegate =
  Storage.Roll.Delegate_change.get_option c delegate
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some change -&gt; return change

module Delegate = struct
  let fresh_roll c =
    Storage.Roll.Next.get c
    &gt;&gt;=? fun roll -&gt;
    Storage.Roll.Next.set c (Roll_repr.succ roll) &gt;&gt;=? fun c -&gt; return (roll, c)

  let get_limbo_roll c =
    Storage.Roll.Limbo.get_option c
    &gt;&gt;=? function
    | None -&gt;
        fresh_roll c
        &gt;&gt;=? fun (roll, c) -&gt;
        Storage.Roll.Limbo.init c roll &gt;&gt;=? fun c -&gt; return (roll, c)
    | Some roll -&gt;
        return (roll, c)

  let consume_roll_change c delegate =
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    trace <abbr class="mark-error" title="Values of extensible types are not handled">Consume_roll_change</abbr> (Lwt.return Tez_repr.(change -? tokens_per_roll))
    &gt;&gt;=? fun new_change -&gt;
    Storage.Roll.Delegate_change.set c delegate new_change

  let recover_roll_change c delegate =
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    Lwt.return Tez_repr.(change +? tokens_per_roll)
    &gt;&gt;=? fun new_change -&gt;
    Storage.Roll.Delegate_change.set c delegate new_change

  let pop_roll_from_delegate c delegate =
    recover_roll_change c delegate
    &gt;&gt;=? fun c -&gt;
    (* beginning:
       delegate : roll -&gt; successor_roll -&gt; ...
       limbo : limbo_head -&gt; ...
    *)
    Storage.Roll.Limbo.get_option c
    &gt;&gt;=? fun limbo_head -&gt;
    Storage.Roll.Delegate_roll_list.get_option c delegate
    &gt;&gt;=? function
    | None -&gt;
        fail <abbr class="mark-error" title="Values of extensible types are not handled">No_roll_for_delegate</abbr>
    | Some roll -&gt;
        Storage.Roll.Owner.delete c roll
        &gt;&gt;=? fun c -&gt;
        Storage.Roll.Successor.get_option c roll
        &gt;&gt;=? fun successor_roll -&gt;
        Storage.Roll.Delegate_roll_list.set_option c delegate successor_roll
        &gt;&gt;= fun c -&gt;
        (* delegate : successor_roll -&gt; ...
           roll ------^
           limbo : limbo_head -&gt; ... *)
        Storage.Roll.Successor.set_option c roll limbo_head
        &gt;&gt;= fun c -&gt;
        (* delegate : successor_roll -&gt; ...
           roll ------v
           limbo : limbo_head -&gt; ... *)
        Storage.Roll.Limbo.init_set c roll
        &gt;&gt;= fun c -&gt;
        (* delegate : successor_roll -&gt; ...
           limbo : roll -&gt; limbo_head -&gt; ... *)
        return (roll, c)

  let create_roll_in_delegate c delegate delegate_pk =
    consume_roll_change c delegate
    &gt;&gt;=? fun c -&gt;
    (* beginning:
       delegate : delegate_head -&gt; ...
       limbo : roll -&gt; limbo_successor -&gt; ...
    *)
    Storage.Roll.Delegate_roll_list.get_option c delegate
    &gt;&gt;=? fun delegate_head -&gt;
    get_limbo_roll c
    &gt;&gt;=? fun (roll, c) -&gt;
    Storage.Roll.Owner.init c roll delegate_pk
    &gt;&gt;=? fun c -&gt;
    Storage.Roll.Successor.get_option c roll
    &gt;&gt;=? fun limbo_successor -&gt;
    Storage.Roll.Limbo.set_option c limbo_successor
    &gt;&gt;= fun c -&gt;
    (* delegate : delegate_head -&gt; ...
       roll ------v
       limbo : limbo_successor -&gt; ... *)
    Storage.Roll.Successor.set_option c roll delegate_head
    &gt;&gt;= fun c -&gt;
    (* delegate : delegate_head -&gt; ...
       roll ------^
       limbo : limbo_successor -&gt; ... *)
    Storage.Roll.Delegate_roll_list.init_set c delegate roll
    &gt;&gt;= fun c -&gt;
    (* delegate : roll -&gt; delegate_head -&gt; ...
       limbo : limbo_successor -&gt; ... *)
    return c

  let ensure_inited c delegate =
    Storage.Roll.Delegate_change.mem c delegate
    &gt;&gt;= function
    | true -&gt;
        return c
    | false -&gt;
        Storage.Roll.Delegate_change.init c delegate Tez_repr.zero

  let is_inactive c delegate =
    Storage.Contract.Inactive_delegate.mem
      c
      (Contract_repr.implicit_contract delegate)
    &gt;&gt;= fun inactive -&gt;
    if inactive then return inactive
    else
      Storage.Contract.Delegate_desactivation.get_option
        c
        (Contract_repr.implicit_contract delegate)
      &gt;&gt;=? function
      | Some last_active_cycle -&gt;
          let {Level_repr.cycle = current_cycle} =
            Raw_context.current_level c
          in
          return Cycle_repr.(last_active_cycle &lt; current_cycle)
      | None -&gt;
          (* This case is only when called from `set_active`, when creating
             a contract. *)
          return_false

  let add_amount c delegate amount =
    ensure_inited c delegate
    &gt;&gt;=? fun c -&gt;
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    Lwt.return Tez_repr.(amount +? change)
    &gt;&gt;=? fun change -&gt;
    Storage.Roll.Delegate_change.set c delegate change
    &gt;&gt;=? fun c -&gt;
    delegate_pubkey c delegate
    &gt;&gt;=? fun delegate_pk -&gt;
    let rec loop c change =
      if Tez_repr.(change &lt; tokens_per_roll) then return c
      else
        Lwt.return Tez_repr.(change -? tokens_per_roll)
        &gt;&gt;=? fun change -&gt;
        create_roll_in_delegate c delegate delegate_pk
        &gt;&gt;=? fun c -&gt; loop c change
    in
    is_inactive c delegate
    &gt;&gt;=? fun inactive -&gt;
    if inactive then return c
    else
      loop c change
      &gt;&gt;=? fun c -&gt;
      Storage.Roll.Delegate_roll_list.get_option c delegate
      &gt;&gt;=? fun rolls -&gt;
      match rolls with
      | None -&gt;
          return c
      | Some _ -&gt;
          Storage.Active_delegates_with_rolls.add c delegate
          &gt;&gt;= fun c -&gt; return c

  let remove_amount c delegate amount =
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    let rec loop c change =
      if Tez_repr.(amount &lt;= change) then return (c, change)
      else
        pop_roll_from_delegate c delegate
        &gt;&gt;=? fun (_, c) -&gt;
        Lwt.return Tez_repr.(change +? tokens_per_roll)
        &gt;&gt;=? fun change -&gt; loop c change
    in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    is_inactive c delegate
    &gt;&gt;=? fun inactive -&gt;
    ( if inactive then return (c, change)
    else
      loop c change
      &gt;&gt;=? fun (c, change) -&gt;
      Storage.Roll.Delegate_roll_list.get_option c delegate
      &gt;&gt;=? fun rolls -&gt;
      match rolls with
      | None -&gt;
          Storage.Active_delegates_with_rolls.del c delegate
          &gt;&gt;= fun c -&gt; return (c, change)
      | Some _ -&gt;
          return (c, change) )
    &gt;&gt;=? fun (c, change) -&gt;
    Lwt.return Tez_repr.(change -? amount)
    &gt;&gt;=? fun change -&gt; Storage.Roll.Delegate_change.set c delegate change

  let set_inactive ctxt delegate =
    ensure_inited ctxt delegate
    &gt;&gt;=? fun ctxt -&gt;
    let tokens_per_roll = Constants_storage.tokens_per_roll ctxt in
    Storage.Roll.Delegate_change.get ctxt delegate
    &gt;&gt;=? fun change -&gt;
    Storage.Contract.Inactive_delegate.add
      ctxt
      (Contract_repr.implicit_contract delegate)
    &gt;&gt;= fun ctxt -&gt;
    Storage.Active_delegates_with_rolls.del ctxt delegate
    &gt;&gt;= fun ctxt -&gt;
    let rec loop ctxt change =
      Storage.Roll.Delegate_roll_list.get_option ctxt delegate
      &gt;&gt;=? function
      | None -&gt;
          return (ctxt, change)
      | Some _roll -&gt;
          pop_roll_from_delegate ctxt delegate
          &gt;&gt;=? fun (_, ctxt) -&gt;
          Lwt.return Tez_repr.(change +? tokens_per_roll)
          &gt;&gt;=? fun change -&gt; loop ctxt change
    in
    loop ctxt change
    &gt;&gt;=? fun (ctxt, change) -&gt;
    Storage.Roll.Delegate_change.set ctxt delegate change
    &gt;&gt;=? fun ctxt -&gt; return ctxt

  let set_active ctxt delegate =
    is_inactive ctxt delegate
    &gt;&gt;=? fun inactive -&gt;
    let current_cycle = (Raw_context.current_level ctxt).cycle in
    let preserved_cycles = Constants_storage.preserved_cycles ctxt in
    (* When the delegate is new or inactive, she will become active in
       `1+preserved_cycles`, and we allow `preserved_cycles` for the
       delegate to start baking. When the delegate is active, we only
       give her at least `preserved_cycles` after the current cycle
       before to be deactivated.  *)
    Storage.Contract.Delegate_desactivation.get_option
      ctxt
      (Contract_repr.implicit_contract delegate)
    &gt;&gt;=? fun current_expiration -&gt;
    let expiration =
      match current_expiration with
      | None -&gt;
          Cycle_repr.add current_cycle (1 + (2 * preserved_cycles))
      | Some current_expiration -&gt;
          let delay =
            if inactive then 1 + (2 * preserved_cycles)
            else 1 + preserved_cycles
          in
          let updated = Cycle_repr.add current_cycle delay in
          Cycle_repr.max current_expiration updated
    in
    Storage.Contract.Delegate_desactivation.init_set
      ctxt
      (Contract_repr.implicit_contract delegate)
      expiration
    &gt;&gt;= fun ctxt -&gt;
    if not inactive then return ctxt
    else
      ensure_inited ctxt delegate
      &gt;&gt;=? fun ctxt -&gt;
      let tokens_per_roll = Constants_storage.tokens_per_roll ctxt in
      Storage.Roll.Delegate_change.get ctxt delegate
      &gt;&gt;=? fun change -&gt;
      Storage.Contract.Inactive_delegate.del
        ctxt
        (Contract_repr.implicit_contract delegate)
      &gt;&gt;= fun ctxt -&gt;
      delegate_pubkey ctxt delegate
      &gt;&gt;=? fun delegate_pk -&gt;
      let rec loop ctxt change =
        if Tez_repr.(change &lt; tokens_per_roll) then return ctxt
        else
          Lwt.return Tez_repr.(change -? tokens_per_roll)
          &gt;&gt;=? fun change -&gt;
          create_roll_in_delegate ctxt delegate delegate_pk
          &gt;&gt;=? fun ctxt -&gt; loop ctxt change
      in
      loop ctxt change
      &gt;&gt;=? fun ctxt -&gt;
      Storage.Roll.Delegate_roll_list.get_option ctxt delegate
      &gt;&gt;=? fun rolls -&gt;
      match rolls with
      | None -&gt;
          return ctxt
      | Some _ -&gt;
          Storage.Active_delegates_with_rolls.add ctxt delegate
          &gt;&gt;= fun ctxt -&gt; return ctxt
end

module Contract = struct
  let add_amount c contract amount =
    get_contract_delegate c contract
    &gt;&gt;=? function
    | None -&gt; return c | Some delegate -&gt; Delegate.add_amount c delegate amount

  let remove_amount c contract amount =
    get_contract_delegate c contract
    &gt;&gt;=? function
    | None -&gt;
        return c
    | Some delegate -&gt;
        Delegate.remove_amount c delegate amount
end

let init ctxt = Storage.Roll.Next.init ctxt Roll_repr.first

let init_first_cycles ctxt =
  let preserved = Constants_storage.preserved_cycles ctxt in
  (* Precompute rolls for cycle (0 --&gt; preserved_cycles) *)
  List.fold_left
    (fun ctxt c -&gt;
      ctxt
      &gt;&gt;=? fun ctxt -&gt;
      let cycle = Cycle_repr.of_int32_exn (Int32.of_int c) in
      Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0
      &gt;&gt;=? fun ctxt -&gt;
      snapshot_rolls_for_cycle ctxt cycle
      &gt;&gt;=? fun ctxt -&gt; freeze_rolls_for_cycle ctxt cycle)
    (return ctxt)
    (0 --&gt; preserved)
  &gt;&gt;=? fun ctxt -&gt;
  let cycle = Cycle_repr.of_int32_exn (Int32.of_int (preserved + 1)) in
  (* Precomputed a snapshot for cycle (preserved_cycles + 1) *)
  Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0
  &gt;&gt;=? fun ctxt -&gt;
  snapshot_rolls_for_cycle ctxt cycle
  &gt;&gt;=? fun ctxt -&gt;
  (* Prepare storage for storing snapshots for cycle (preserved_cycles+2) *)
  let cycle = Cycle_repr.of_int32_exn (Int32.of_int (preserved + 2)) in
  Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let snapshot_rolls ctxt =
  let current_level = Raw_context.current_level ctxt in
  let preserved = Constants_storage.preserved_cycles ctxt in
  let cycle = Cycle_repr.add current_level.cycle (preserved + 2) in
  snapshot_rolls_for_cycle ctxt cycle

let cycle_end ctxt last_cycle =
  let preserved = Constants_storage.preserved_cycles ctxt in
  ( match Cycle_repr.sub last_cycle preserved with
  | None -&gt;
      return ctxt
  | Some cleared_cycle -&gt;
      clear_cycle ctxt cleared_cycle )
  &gt;&gt;=? fun ctxt -&gt;
  let frozen_roll_cycle = Cycle_repr.add last_cycle (preserved + 1) in
  freeze_rolls_for_cycle ctxt frozen_roll_cycle
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Roll.Snapshot_for_cycle.init
    ctxt
    (Cycle_repr.succ (Cycle_repr.succ frozen_roll_cycle))
    0
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let update_tokens_per_roll ctxt new_tokens_per_roll =
  let constants = Raw_context.constants ctxt in
  let old_tokens_per_roll = constants.tokens_per_roll in
  Raw_context.patch_constants ctxt (fun constants -&gt;
      <abbr class="mark-error" title="Record substitution not handled">{constants with Constants_repr.tokens_per_roll = new_tokens_per_roll}</abbr>)
  &gt;&gt;= fun ctxt -&gt;
  let decrease = Tez_repr.(new_tokens_per_roll &lt; old_tokens_per_roll) in
  ( if decrease then
    Lwt.return Tez_repr.(old_tokens_per_roll -? new_tokens_per_roll)
  else Lwt.return Tez_repr.(new_tokens_per_roll -? old_tokens_per_roll) )
  &gt;&gt;=? fun abs_diff -&gt;
  Storage.Delegates.fold ctxt (Ok ctxt) (fun pkh ctxt -&gt;
      Lwt.return ctxt
      &gt;&gt;=? fun ctxt -&gt;
      count_rolls ctxt pkh
      &gt;&gt;=? fun rolls -&gt;
      Lwt.return Tez_repr.(abs_diff *? Int64.of_int rolls)
      &gt;&gt;=? fun amount -&gt;
      if decrease then Delegate.add_amount ctxt pkh amount
      else Delegate.remove_amount ctxt pkh amount)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_storage.ml"><code>Roll_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Manager_repr.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Seed_repr.
Require Tezos.Seed_storage.
Require Tezos.Storage.
Require Tezos.Tez_repr.

Import Misc.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition get_contract_delegate
  (c : Storage.Contract.Delegate.context)
  (contract : Storage.Contract.Delegate.key)
  : Lwt.t (Error_monad.tzresult (option Storage.Contract.Delegate.value)) :=
  Storage.Contract.Delegate.get_option c contract.

Definition delegate_pubkey
  (ctxt : Storage.Contract.Manager.context)
  (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
  : Lwt.t (Error_monad.tzresult Signature.Public_key.[S.SPublic_key.t]) :=
  Error_monad.op_gtgteqquestion
    (Storage.Contract.Manager.get_option ctxt
      (Contract_repr.implicit_contract delegate))
    (fun function_parameter =&gt;
      match function_parameter with
      | None | Some (Manager_repr.Hash _) =&gt;
        Error_monad.fail extensible_type_value
      | Some (Manager_repr.Public_key pk) =&gt; Error_monad.__return pk
      end).

Definition clear_cycle
  (c : Storage.Roll.Snapshot_for_cycle.context)
  (cycle : Storage.Roll.Snapshot_for_cycle.key)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion (Storage.Roll.Snapshot_for_cycle.get c cycle)
    (fun index =&gt;
      Error_monad.op_gtgteqquestion
        (Storage.Roll.Snapshot_for_cycle.delete c cycle)
        (fun c =&gt;
          Error_monad.op_gtgteqquestion
            (Storage.Roll.Last_for_snapshot.delete (c, cycle) index)
            (fun c =&gt;
              Error_monad.op_gtgteq
                (Storage.Roll.Owner.delete_snapshot c (cycle, index))
                (fun c =&gt; Error_monad.__return c)))).

Definition fold {A : Set}
  (ctxt : Storage.Roll.Next.context)
  (f :
    Roll_repr.roll -&gt; Storage.Roll.Owner.value -&gt; A -&gt;
    Lwt.t (Error_monad.tzresult A)) (init : A)
  : Lwt.t (Error_monad.tzresult A) :=
  Error_monad.op_gtgteqquestion (Storage.Roll.Next.get ctxt)
    (fun last =&gt;
      let fix loop
        (ctxt : Storage.Roll.Owner.context) (roll : Roll_repr.roll)
        (acc : Lwt.t (Error_monad.tzresult A)) {struct ctxt}
        : Lwt.t (Error_monad.tzresult A) :=
        Error_monad.op_gtgteqquestion acc
          (fun acc =&gt;
            if Roll_repr.op_eq roll last then
              Error_monad.__return acc
            else
              Error_monad.op_gtgteqquestion
                (Storage.Roll.Owner.get_option ctxt roll)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | None =&gt;
                    loop ctxt (Roll_repr.succ roll) (Error_monad.__return acc)
                  | Some delegate =&gt;
                    loop ctxt (Roll_repr.succ roll) (f roll delegate acc)
                  end)) in
      loop ctxt Roll_repr.first (Error_monad.__return init)).

Definition snapshot_rolls_for_cycle
  (ctxt : Storage.Roll.Snapshot_for_cycle.context)
  (cycle : Storage.Roll.Snapshot_for_cycle.key)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion (Storage.Roll.Snapshot_for_cycle.get ctxt cycle)
    (fun index =&gt;
      Error_monad.op_gtgteqquestion
        (Storage.Roll.Snapshot_for_cycle.set ctxt cycle
          (Pervasives.op_plus index 1))
        (fun ctxt =&gt;
          Error_monad.op_gtgteqquestion
            (Storage.Roll.Owner.snapshot ctxt (cycle, index))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion (Storage.Roll.Next.get ctxt)
                (fun last =&gt;
                  Error_monad.op_gtgteqquestion
                    (Storage.Roll.Last_for_snapshot.init (ctxt, cycle) index
                      last) (fun ctxt =&gt; Error_monad.__return ctxt))))).

Definition freeze_rolls_for_cycle
  (ctxt : Storage.Roll.Snapshot_for_cycle.context)
  (cycle : Storage.Roll.Snapshot_for_cycle.key)
  : Lwt.t (Error_monad.tzresult Storage.Roll.Owner.context) :=
  Error_monad.op_gtgteqquestion (Storage.Roll.Snapshot_for_cycle.get ctxt cycle)
    (fun max_index =&gt;
      Error_monad.op_gtgteqquestion (Storage.Seed.For_cycle.get ctxt cycle)
        (fun seed =&gt;
          let rd :=
            Seed_repr.initialize_new seed
              (cons (MBytes.of_string &quot;roll_snapshot&quot; % string) []) in
          let seq :=
            Seed_repr.sequence rd
              (* ‚ùå Constant of type int32 is converted to int *)
              0 in
          let selected_index :=
            Pervasives.op_pipegt
              (Pervasives.op_pipegt
                (Seed_repr.take_int32 seq (Int32.of_int max_index))
                Pervasives.fst) Int32.to_int in
          Error_monad.op_gtgteqquestion
            (Storage.Roll.Snapshot_for_cycle.set ctxt cycle selected_index)
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Error_monad.fold_left_s
                  (fun ctxt =&gt;
                    fun index =&gt;
                      if Compare.Int.[Compare.S.op_eq] index selected_index then
                        Error_monad.__return ctxt
                      else
                        Error_monad.op_gtgteq
                          (Storage.Roll.Owner.delete_snapshot ctxt
                            (cycle, index))
                          (fun ctxt =&gt;
                            Error_monad.op_gtgteqquestion
                              (Storage.Roll.Last_for_snapshot.delete
                                (ctxt, cycle) index)
                              (fun ctxt =&gt; Error_monad.__return ctxt))) ctxt
                  (Misc.op_minusminusgt 0 (Pervasives.op_minus max_index 1)))
                (fun ctxt =&gt; Error_monad.__return ctxt)))).

Module Random.
  Definition int32_to_bytes (i : int32) : MBytes.t :=
    let b := MBytes.create 4 in
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    b.
  
  Definition level_random
    (seed : Seed_repr.seed) (use : string) (level : Level_repr.t)
    : Seed_repr.t :=
    let position := Level_repr.t.cycle_position level in
    Seed_repr.initialize_new seed
      (cons
        (MBytes.of_string
          (Pervasives.op_caret &quot;level &quot; % string
            (Pervasives.op_caret use &quot;:&quot; % string)))
        (cons (int32_to_bytes position) [])).
  
  Definition owner
    (c : Raw_context.t) (kind : string) (level : Level_repr.t) (offset : Z)
    : Lwt.t (Error_monad.tzresult Storage.Roll.Owner.Snapshot.value) :=
    let cycle := Level_repr.t.cycle level in
    Error_monad.op_gtgteqquestion (Seed_storage.for_cycle c cycle)
      (fun random_seed =&gt;
        let rd := level_random random_seed kind level in
        let sequence := Seed_repr.sequence rd (Int32.of_int offset) in
        Error_monad.op_gtgteqquestion
          (Storage.Roll.Snapshot_for_cycle.get c cycle)
          (fun index =&gt;
            Error_monad.op_gtgteqquestion
              (Storage.Roll.Last_for_snapshot.get (c, cycle) index)
              (fun bound =&gt;
                let fix loop (sequence : Seed_repr.sequence) {struct sequence}
                  : Lwt.t
                    (Error_monad.tzresult Storage.Roll.Owner.Snapshot.value) :=
                  let '(roll, sequence) := Roll_repr.random sequence bound in
                  Error_monad.op_gtgteqquestion
                    (Storage.Roll.Owner.Snapshot.get_option c
                      ((cycle, index), roll))
                    (fun function_parameter =&gt;
                      match function_parameter with
                      | None =&gt; loop sequence
                      | Some delegate =&gt; Error_monad.__return delegate
                      end) in
                Error_monad.op_gtgteq
                  (Storage.Roll.Owner.snapshot_exists c (cycle, index))
                  (fun snapshot_exists =&gt;
                    Error_monad.op_gtgteqquestion
                      (Error_monad.fail_unless snapshot_exists
                        extensible_type_value)
                      (fun function_parameter =&gt;
                        let 'tt := function_parameter in
                        loop sequence))))).
End Random.

Definition baking_rights_owner
  (c : Raw_context.t) (level : Level_repr.t) (priority : Z)
  : Lwt.t (Error_monad.tzresult Storage.Roll.Owner.Snapshot.value) :=
  Random.owner c &quot;baking&quot; % string level priority.

Definition endorsement_rights_owner
  (c : Raw_context.t) (level : Level_repr.t) (slot : Z)
  : Lwt.t (Error_monad.tzresult Storage.Roll.Owner.Snapshot.value) :=
  Random.owner c &quot;endorsement&quot; % string level slot.

Definition traverse_rolls
  (ctxt : Storage.Roll.Successor.context) (head : Storage.Roll.Successor.value)
  : Lwt.t (Error_monad.tzresult (list Storage.Roll.Successor.value)) :=
  let fix loop
    (acc : list Storage.Roll.Successor.value)
    (roll : Storage.Roll.Successor.key) {struct acc}
    : Lwt.t (Error_monad.tzresult (list Storage.Roll.Successor.value)) :=
    Error_monad.op_gtgteqquestion (Storage.Roll.Successor.get_option ctxt roll)
      (fun function_parameter =&gt;
        match function_parameter with
        | None =&gt; Error_monad.__return (List.rev acc)
        | Some next =&gt; loop (cons next acc) next
        end) in
  loop (cons head []) head.

Definition get_rolls
  (ctxt : Storage.Roll.Delegate_roll_list.context)
  (delegate : Storage.Roll.Delegate_roll_list.key)
  : Lwt.t (Error_monad.tzresult (list Storage.Roll.Successor.value)) :=
  Error_monad.op_gtgteqquestion
    (Storage.Roll.Delegate_roll_list.get_option ctxt delegate)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.return_nil
      | Some head_roll =&gt; traverse_rolls ctxt head_roll
      end).

Definition count_rolls
  (ctxt : Storage.Roll.Delegate_roll_list.context)
  (delegate : Storage.Roll.Delegate_roll_list.key)
  : Lwt.t (Error_monad.tzresult Z) :=
  Error_monad.op_gtgteqquestion
    (Storage.Roll.Delegate_roll_list.get_option ctxt delegate)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return 0
      | Some head_roll =&gt;
        let fix loop (acc : Z) (roll : Storage.Roll.Successor.key) {struct acc}
          : Lwt.t (Error_monad.tzresult Z) :=
          Error_monad.op_gtgteqquestion
            (Storage.Roll.Successor.get_option ctxt roll)
            (fun function_parameter =&gt;
              match function_parameter with
              | None =&gt; Error_monad.__return acc
              | Some next =&gt; loop (Pervasives.succ acc) next
              end) in
        loop 1 head_roll
      end).

Definition get_change
  (c : Storage.Roll.Delegate_change.context)
  (delegate : Storage.Roll.Delegate_change.key)
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  Error_monad.op_gtgteqquestion
    (Storage.Roll.Delegate_change.get_option c delegate)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return Tez_repr.zero
      | Some change =&gt; Error_monad.__return change
      end).

Module Delegate.
  Definition fresh_roll (c : Storage.Roll.Next.context)
    : Lwt.t (Error_monad.tzresult (Storage.Roll.Next.value * Raw_context.t)) :=
    Error_monad.op_gtgteqquestion (Storage.Roll.Next.get c)
      (fun roll =&gt;
        Error_monad.op_gtgteqquestion
          (Storage.Roll.Next.set c (Roll_repr.succ roll))
          (fun c =&gt; Error_monad.__return (roll, c))).
  
  Definition get_limbo_roll (c : Storage.Roll.Limbo.context)
    : Lwt.t (Error_monad.tzresult (Storage.Roll.Next.value * Raw_context.t)) :=
    Error_monad.op_gtgteqquestion (Storage.Roll.Limbo.get_option c)
      (fun function_parameter =&gt;
        match function_parameter with
        | None =&gt;
          Error_monad.op_gtgteqquestion (fresh_roll c)
            (fun function_parameter =&gt;
              let '(roll, c) := function_parameter in
              Error_monad.op_gtgteqquestion (Storage.Roll.Limbo.init c roll)
                (fun c =&gt; Error_monad.__return (roll, c)))
        | Some roll =&gt; Error_monad.__return (roll, c)
        end).
  
  Definition consume_roll_change
    (c : Raw_context.context) (delegate : Storage.Roll.Delegate_change.key)
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    Error_monad.op_gtgteqquestion (Storage.Roll.Delegate_change.get c delegate)
      (fun change =&gt;
        Error_monad.op_gtgteqquestion
          (Error_monad.trace extensible_type_value
            (Lwt.__return (Tez_repr.op_minusquestion change tokens_per_roll)))
          (fun new_change =&gt;
            Storage.Roll.Delegate_change.set c delegate new_change)).
  
  Definition recover_roll_change
    (c : Raw_context.context) (delegate : Storage.Roll.Delegate_change.key)
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    Error_monad.op_gtgteqquestion (Storage.Roll.Delegate_change.get c delegate)
      (fun change =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Tez_repr.op_plusquestion change tokens_per_roll))
          (fun new_change =&gt;
            Storage.Roll.Delegate_change.set c delegate new_change)).
  
  Definition pop_roll_from_delegate
    (c : Raw_context.context) (delegate : Storage.Roll.Delegate_change.key)
    : Lwt.t
      (Error_monad.tzresult
        (Storage.Roll.Delegate_roll_list.value * Raw_context.t)) :=
    Error_monad.op_gtgteqquestion (recover_roll_change c delegate)
      (fun c =&gt;
        Error_monad.op_gtgteqquestion (Storage.Roll.Limbo.get_option c)
          (fun limbo_head =&gt;
            Error_monad.op_gtgteqquestion
              (Storage.Roll.Delegate_roll_list.get_option c delegate)
              (fun function_parameter =&gt;
                match function_parameter with
                | None =&gt; Error_monad.fail extensible_type_value
                | Some roll =&gt;
                  Error_monad.op_gtgteqquestion
                    (Storage.Roll.Owner.delete c roll)
                    (fun c =&gt;
                      Error_monad.op_gtgteqquestion
                        (Storage.Roll.Successor.get_option c roll)
                        (fun successor_roll =&gt;
                          Error_monad.op_gtgteq
                            (Storage.Roll.Delegate_roll_list.set_option c
                              delegate successor_roll)
                            (fun c =&gt;
                              Error_monad.op_gtgteq
                                (Storage.Roll.Successor.set_option c roll
                                  limbo_head)
                                (fun c =&gt;
                                  Error_monad.op_gtgteq
                                    (Storage.Roll.Limbo.init_set c roll)
                                    (fun c =&gt; Error_monad.__return (roll, c))))))
                end))).
  
  Definition create_roll_in_delegate
    (c : Raw_context.context) (delegate : Storage.Roll.Delegate_change.key)
    (delegate_pk : Storage.Roll.Owner.value)
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (consume_roll_change c delegate)
      (fun c =&gt;
        Error_monad.op_gtgteqquestion
          (Storage.Roll.Delegate_roll_list.get_option c delegate)
          (fun delegate_head =&gt;
            Error_monad.op_gtgteqquestion (get_limbo_roll c)
              (fun function_parameter =&gt;
                let '(roll, c) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Storage.Roll.Owner.init c roll delegate_pk)
                  (fun c =&gt;
                    Error_monad.op_gtgteqquestion
                      (Storage.Roll.Successor.get_option c roll)
                      (fun limbo_successor =&gt;
                        Error_monad.op_gtgteq
                          (Storage.Roll.Limbo.set_option c limbo_successor)
                          (fun c =&gt;
                            Error_monad.op_gtgteq
                              (Storage.Roll.Successor.set_option c roll
                                delegate_head)
                              (fun c =&gt;
                                Error_monad.op_gtgteq
                                  (Storage.Roll.Delegate_roll_list.init_set c
                                    delegate roll)
                                  (fun c =&gt; Error_monad.__return c)))))))).
  
  Definition ensure_inited
    (c : Storage.Roll.Delegate_change.context)
    (delegate : Storage.Roll.Delegate_change.key)
    : Lwt.t (Error_monad.tzresult Storage.Roll.Delegate_change.context) :=
    Error_monad.op_gtgteq (Storage.Roll.Delegate_change.mem c delegate)
      (fun function_parameter =&gt;
        match function_parameter with
        | true =&gt; Error_monad.__return c
        | false =&gt; Storage.Roll.Delegate_change.init c delegate Tez_repr.zero
        end).
  
  Definition is_inactive
    (c : Storage.Contract.Inactive_delegate.context)
    (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
    : Lwt.t (Error_monad.tzresult bool) :=
    Error_monad.op_gtgteq
      (Storage.Contract.Inactive_delegate.mem c
        (Contract_repr.implicit_contract delegate))
      (fun inactive =&gt;
        if inactive then
          Error_monad.__return inactive
        else
          Error_monad.op_gtgteqquestion
            (Storage.Contract.Delegate_desactivation.get_option c
              (Contract_repr.implicit_contract delegate))
            (fun function_parameter =&gt;
              match function_parameter with
              | Some last_active_cycle =&gt;
                let '{| Level_repr.t.cycle := current_cycle |} :=
                  Raw_context.current_level c in
                Error_monad.__return
                  (Cycle_repr.op_lt last_active_cycle current_cycle)
              | None =&gt; Error_monad.return_false
              end)).
  
  Definition add_amount
    (c : Storage.Roll.Delegate_change.context)
    (delegate : Storage.Roll.Delegate_change.key) (amount : Tez_repr.t)
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (ensure_inited c delegate)
      (fun c =&gt;
        let tokens_per_roll := Constants_storage.tokens_per_roll c in
        Error_monad.op_gtgteqquestion
          (Storage.Roll.Delegate_change.get c delegate)
          (fun change =&gt;
            Error_monad.op_gtgteqquestion
              (Lwt.__return (Tez_repr.op_plusquestion amount change))
              (fun change =&gt;
                Error_monad.op_gtgteqquestion
                  (Storage.Roll.Delegate_change.set c delegate change)
                  (fun c =&gt;
                    Error_monad.op_gtgteqquestion (delegate_pubkey c delegate)
                      (fun delegate_pk =&gt;
                        let fix loop
                          (c : Raw_context.context) (change : Tez_repr.t)
                          {struct c}
                          : Lwt.t (Error_monad.tzresult Raw_context.context) :=
                          if Tez_repr.op_lt change tokens_per_roll then
                            Error_monad.__return c
                          else
                            Error_monad.op_gtgteqquestion
                              (Lwt.__return
                                (Tez_repr.op_minusquestion change
                                  tokens_per_roll))
                              (fun change =&gt;
                                Error_monad.op_gtgteqquestion
                                  (create_roll_in_delegate c delegate
                                    delegate_pk) (fun c =&gt; loop c change)) in
                        Error_monad.op_gtgteqquestion (is_inactive c delegate)
                          (fun inactive =&gt;
                            if inactive then
                              Error_monad.__return c
                            else
                              Error_monad.op_gtgteqquestion (loop c change)
                                (fun c =&gt;
                                  Error_monad.op_gtgteqquestion
                                    (Storage.Roll.Delegate_roll_list.get_option
                                      c delegate)
                                    (fun rolls =&gt;
                                      match rolls with
                                      | None =&gt; Error_monad.__return c
                                      | Some _ =&gt;
                                        Error_monad.op_gtgteq
                                          (Storage.Active_delegates_with_rolls.add
                                            c delegate)
                                          (fun c =&gt; Error_monad.__return c)
                                      end)))))))).
  
  Definition remove_amount
    (c : Raw_context.context) (delegate : Storage.Roll.Delegate_change.key)
    (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    let fix loop (c : Raw_context.context) (change : Tez_repr.t) {struct c}
      : Lwt.t (Error_monad.tzresult (Raw_context.context * Tez_repr.t)) :=
      if Tez_repr.op_lteq amount change then
        Error_monad.__return (c, change)
      else
        Error_monad.op_gtgteqquestion (pop_roll_from_delegate c delegate)
          (fun function_parameter =&gt;
            let '(_, c) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return (Tez_repr.op_plusquestion change tokens_per_roll))
              (fun change =&gt; loop c change)) in
    Error_monad.op_gtgteqquestion (Storage.Roll.Delegate_change.get c delegate)
      (fun change =&gt;
        Error_monad.op_gtgteqquestion (is_inactive c delegate)
          (fun inactive =&gt;
            Error_monad.op_gtgteqquestion
              (if inactive then
                Error_monad.__return (c, change)
              else
                Error_monad.op_gtgteqquestion (loop c change)
                  (fun function_parameter =&gt;
                    let '(c, change) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (Storage.Roll.Delegate_roll_list.get_option c delegate)
                      (fun rolls =&gt;
                        match rolls with
                        | None =&gt;
                          Error_monad.op_gtgteq
                            (Storage.Active_delegates_with_rolls.del c delegate)
                            (fun c =&gt; Error_monad.__return (c, change))
                        | Some _ =&gt; Error_monad.__return (c, change)
                        end)))
              (fun function_parameter =&gt;
                let '(c, change) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return (Tez_repr.op_minusquestion change amount))
                  (fun change =&gt;
                    Storage.Roll.Delegate_change.set c delegate change)))).
  
  Definition set_inactive
    (ctxt : Storage.Roll.Delegate_change.context)
    (delegate : Storage.Roll.Delegate_change.key)
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (ensure_inited ctxt delegate)
      (fun ctxt =&gt;
        let tokens_per_roll := Constants_storage.tokens_per_roll ctxt in
        Error_monad.op_gtgteqquestion
          (Storage.Roll.Delegate_change.get ctxt delegate)
          (fun change =&gt;
            Error_monad.op_gtgteq
              (Storage.Contract.Inactive_delegate.add ctxt
                (Contract_repr.implicit_contract delegate))
              (fun ctxt =&gt;
                Error_monad.op_gtgteq
                  (Storage.Active_delegates_with_rolls.del ctxt delegate)
                  (fun ctxt =&gt;
                    let fix loop
                      (ctxt : Storage.Roll.Delegate_roll_list.context)
                      (change : Tez_repr.t) {struct ctxt}
                      : Lwt.t
                        (Error_monad.tzresult
                          (Storage.Roll.Delegate_roll_list.context * Tez_repr.t)) :=
                      Error_monad.op_gtgteqquestion
                        (Storage.Roll.Delegate_roll_list.get_option ctxt
                          delegate)
                        (fun function_parameter =&gt;
                          match function_parameter with
                          | None =&gt; Error_monad.__return (ctxt, change)
                          | Some _roll =&gt;
                            Error_monad.op_gtgteqquestion
                              (pop_roll_from_delegate ctxt delegate)
                              (fun function_parameter =&gt;
                                let '(_, ctxt) := function_parameter in
                                Error_monad.op_gtgteqquestion
                                  (Lwt.__return
                                    (Tez_repr.op_plusquestion change
                                      tokens_per_roll))
                                  (fun change =&gt; loop ctxt change))
                          end) in
                    Error_monad.op_gtgteqquestion (loop ctxt change)
                      (fun function_parameter =&gt;
                        let '(ctxt, change) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (Storage.Roll.Delegate_change.set ctxt delegate change)
                          (fun ctxt =&gt; Error_monad.__return ctxt)))))).
  
  Definition set_active
    (ctxt : Storage.Contract.Inactive_delegate.context)
    (delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t])
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Error_monad.op_gtgteqquestion (is_inactive ctxt delegate)
      (fun inactive =&gt;
        let current_cycle := Level_repr.t.cycle (Raw_context.current_level ctxt)
          in
        let preserved_cycles := Constants_storage.preserved_cycles ctxt in
        Error_monad.op_gtgteqquestion
          (Storage.Contract.Delegate_desactivation.get_option ctxt
            (Contract_repr.implicit_contract delegate))
          (fun current_expiration =&gt;
            let expiration :=
              match current_expiration with
              | None =&gt;
                Cycle_repr.add current_cycle
                  (Pervasives.op_plus 1 (Pervasives.op_star 2 preserved_cycles))
              | Some current_expiration =&gt;
                let delay :=
                  if inactive then
                    Pervasives.op_plus 1 (Pervasives.op_star 2 preserved_cycles)
                  else
                    Pervasives.op_plus 1 preserved_cycles in
                let updated := Cycle_repr.add current_cycle delay in
                Cycle_repr.max current_expiration updated
              end in
            Error_monad.op_gtgteq
              (Storage.Contract.Delegate_desactivation.init_set ctxt
                (Contract_repr.implicit_contract delegate) expiration)
              (fun ctxt =&gt;
                if Pervasives.not inactive then
                  Error_monad.__return ctxt
                else
                  Error_monad.op_gtgteqquestion (ensure_inited ctxt delegate)
                    (fun ctxt =&gt;
                      let tokens_per_roll :=
                        Constants_storage.tokens_per_roll ctxt in
                      Error_monad.op_gtgteqquestion
                        (Storage.Roll.Delegate_change.get ctxt delegate)
                        (fun change =&gt;
                          Error_monad.op_gtgteq
                            (Storage.Contract.Inactive_delegate.del ctxt
                              (Contract_repr.implicit_contract delegate))
                            (fun ctxt =&gt;
                              Error_monad.op_gtgteqquestion
                                (delegate_pubkey ctxt delegate)
                                (fun delegate_pk =&gt;
                                  let fix loop
                                    (ctxt : Raw_context.context)
                                    (change : Tez_repr.t) {struct ctxt}
                                    : Lwt.t
                                      (Error_monad.tzresult Raw_context.context) :=
                                    if Tez_repr.op_lt change tokens_per_roll
                                      then
                                      Error_monad.__return ctxt
                                    else
                                      Error_monad.op_gtgteqquestion
                                        (Lwt.__return
                                          (Tez_repr.op_minusquestion change
                                            tokens_per_roll))
                                        (fun change =&gt;
                                          Error_monad.op_gtgteqquestion
                                            (create_roll_in_delegate ctxt
                                              delegate delegate_pk)
                                            (fun ctxt =&gt; loop ctxt change)) in
                                  Error_monad.op_gtgteqquestion
                                    (loop ctxt change)
                                    (fun ctxt =&gt;
                                      Error_monad.op_gtgteqquestion
                                        (Storage.Roll.Delegate_roll_list.get_option
                                          ctxt delegate)
                                        (fun rolls =&gt;
                                          match rolls with
                                          | None =&gt; Error_monad.__return ctxt
                                          | Some _ =&gt;
                                            Error_monad.op_gtgteq
                                              (Storage.Active_delegates_with_rolls.add
                                                ctxt delegate)
                                              (fun ctxt =&gt;
                                                Error_monad.__return ctxt)
                                          end))))))))).
End Delegate.

Module Contract.
  Definition add_amount
    (c : Storage.Contract.Delegate.context)
    (contract : Storage.Contract.Delegate.key) (amount : Tez_repr.t)
    : Lwt.t (Error_monad.tzresult Storage.Contract.Delegate.context) :=
    Error_monad.op_gtgteqquestion (get_contract_delegate c contract)
      (fun function_parameter =&gt;
        match function_parameter with
        | None =&gt; Error_monad.__return c
        | Some delegate =&gt; Delegate.add_amount c delegate amount
        end).
  
  Definition remove_amount
    (c : Storage.Contract.Delegate.context)
    (contract : Storage.Contract.Delegate.key) (amount : Tez_repr.t)
    : Lwt.t (Error_monad.tzresult Storage.Contract.Delegate.context) :=
    Error_monad.op_gtgteqquestion (get_contract_delegate c contract)
      (fun function_parameter =&gt;
        match function_parameter with
        | None =&gt; Error_monad.__return c
        | Some delegate =&gt; Delegate.remove_amount c delegate amount
        end).
End Contract.

Definition init (ctxt : Storage.Roll.Next.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Roll.Next.init ctxt Roll_repr.first.

Definition init_first_cycles (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  Error_monad.op_gtgteqquestion
    (List.fold_left
      (fun ctxt =&gt;
        fun c =&gt;
          Error_monad.op_gtgteqquestion ctxt
            (fun ctxt =&gt;
              let cycle := Cycle_repr.of_int32_exn (Int32.of_int c) in
              Error_monad.op_gtgteqquestion
                (Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0)
                (fun ctxt =&gt;
                  Error_monad.op_gtgteqquestion
                    (snapshot_rolls_for_cycle ctxt cycle)
                    (fun ctxt =&gt; freeze_rolls_for_cycle ctxt cycle))))
      (Error_monad.__return ctxt) (Misc.op_minusminusgt 0 preserved))
    (fun ctxt =&gt;
      let cycle :=
        Cycle_repr.of_int32_exn (Int32.of_int (Pervasives.op_plus preserved 1))
        in
      Error_monad.op_gtgteqquestion
        (Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0)
        (fun ctxt =&gt;
          Error_monad.op_gtgteqquestion (snapshot_rolls_for_cycle ctxt cycle)
            (fun ctxt =&gt;
              let cycle :=
                Cycle_repr.of_int32_exn
                  (Int32.of_int (Pervasives.op_plus preserved 2)) in
              Error_monad.op_gtgteqquestion
                (Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0)
                (fun ctxt =&gt; Error_monad.__return ctxt)))).

Definition snapshot_rolls (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let current_level := Raw_context.current_level ctxt in
  let preserved := Constants_storage.preserved_cycles ctxt in
  let cycle :=
    Cycle_repr.add (Level_repr.t.cycle current_level)
      (Pervasives.op_plus preserved 2) in
  snapshot_rolls_for_cycle ctxt cycle.

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  Error_monad.op_gtgteqquestion
    match Cycle_repr.sub last_cycle preserved with
    | None =&gt; Error_monad.__return ctxt
    | Some cleared_cycle =&gt; clear_cycle ctxt cleared_cycle
    end
    (fun ctxt =&gt;
      let frozen_roll_cycle :=
        Cycle_repr.add last_cycle (Pervasives.op_plus preserved 1) in
      Error_monad.op_gtgteqquestion
        (freeze_rolls_for_cycle ctxt frozen_roll_cycle)
        (fun ctxt =&gt;
          Error_monad.op_gtgteqquestion
            (Storage.Roll.Snapshot_for_cycle.init ctxt
              (Cycle_repr.succ (Cycle_repr.succ frozen_roll_cycle)) 0)
            (fun ctxt =&gt; Error_monad.__return ctxt))).

Definition update_tokens_per_roll
  (ctxt : Raw_context.context) (new_tokens_per_roll : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.context) :=
  let constants := Raw_context.constants ctxt in
  let old_tokens_per_roll := Constants_repr.parametric.tokens_per_roll constants
    in
  Error_monad.op_gtgteq
    (Raw_context.patch_constants ctxt
      (fun constants =&gt;
        (* ‚ùå Record substitution not handled *)
        record_substitution))
    (fun ctxt =&gt;
      let decrease := Tez_repr.op_lt new_tokens_per_roll old_tokens_per_roll in
      Error_monad.op_gtgteqquestion
        (if decrease then
          Lwt.__return
            (Tez_repr.op_minusquestion old_tokens_per_roll new_tokens_per_roll)
        else
          Lwt.__return
            (Tez_repr.op_minusquestion new_tokens_per_roll old_tokens_per_roll))
        (fun abs_diff =&gt;
          Storage.Delegates.fold ctxt (Pervasives.Ok ctxt)
            (fun pkh =&gt;
              fun ctxt =&gt;
                Error_monad.op_gtgteqquestion (Lwt.__return ctxt)
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion (count_rolls ctxt pkh)
                      (fun rolls =&gt;
                        Error_monad.op_gtgteqquestion
                          (Lwt.__return
                            (Tez_repr.op_starquestion abs_diff
                              (Int64.of_int rolls)))
                          (fun amount =&gt;
                            if decrease then
                              Delegate.add_amount ctxt pkh amount
                            else
                              Delegate.remove_amount ctxt pkh amount)))))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_storage.mli">
  <div class="col-md-6">
    <a href="#roll_storage.mli"><code>roll_storage.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(**

   Basic roll manipulation.

   If storage related to roll (a.k.a. `Storage.Roll`) are not used
   outside of this module, this interface enforces the invariant that a
   roll is always either in the limbo list or in a contract list.

*)

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Consume_roll_change
  | No_roll_for_delegate
  | No_roll_snapshot_for_cycle of Cycle_repr.t
  | Unregistered_delegate of Signature.Public_key_hash.t</abbr>

(* `Permanent *)

val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val init_first_cycles : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val cycle_end : Raw_context.t -&gt; Cycle_repr.t -&gt; Raw_context.t tzresult Lwt.t

val snapshot_rolls : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val fold :
  Raw_context.t -&gt;
  f:(Roll_repr.roll -&gt; Signature.Public_key.t -&gt; 'a -&gt; 'a tzresult Lwt.t) -&gt;
  'a -&gt;
  'a tzresult Lwt.t

val baking_rights_owner :
  Raw_context.t -&gt;
  Level_repr.t -&gt;
  priority:int -&gt;
  Signature.Public_key.t tzresult Lwt.t

val endorsement_rights_owner :
  Raw_context.t -&gt;
  Level_repr.t -&gt;
  slot:int -&gt;
  Signature.Public_key.t tzresult Lwt.t

module Delegate : sig
  val is_inactive :
    Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

  val add_amount :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t

  val remove_amount :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t

  val set_inactive :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Raw_context.t tzresult Lwt.t

  val set_active :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Raw_context.t tzresult Lwt.t
end

module Contract : sig
  val add_amount :
    Raw_context.t -&gt;
    Contract_repr.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t

  val remove_amount :
    Raw_context.t -&gt;
    Contract_repr.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t
end

val delegate_pubkey :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Signature.Public_key.t tzresult Lwt.t

val get_rolls :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Roll_repr.t list tzresult Lwt.t

val get_change :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val update_tokens_per_roll :
  Raw_context.t -&gt; Tez_repr.t -&gt; Raw_context.t tzresult Lwt.t

(**/**)

val get_contract_delegate :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t option tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_storage.mli"><code>Roll_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Tez_repr.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter init_first_cycles :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter snapshot_rolls :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter fold : forall {a : Set},
  Raw_context.t -&gt;
  (Roll_repr.roll -&gt; Signature.Public_key.[S.SPublic_key.t] -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult a)) -&gt; a -&gt; Lwt.t (Error_monad.tzresult a).

Parameter baking_rights_owner :
  Raw_context.t -&gt; Level_repr.t -&gt; Z -&gt;
  Lwt.t (Error_monad.tzresult Signature.Public_key.[S.SPublic_key.t]).

Parameter endorsement_rights_owner :
  Raw_context.t -&gt; Level_repr.t -&gt; Z -&gt;
  Lwt.t (Error_monad.tzresult Signature.Public_key.[S.SPublic_key.t]).

Module Delegate.
  Parameter is_inactive :
    Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult bool).
  
  Parameter add_amount :
    Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter remove_amount :
    Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter set_inactive :
    Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter set_active :
    Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
End Delegate.

Module Contract.
  Parameter add_amount :
    Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter remove_amount :
    Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
End Contract.

Parameter delegate_pubkey :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Signature.Public_key.[S.SPublic_key.t]).

Parameter get_rolls :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult (list Roll_repr.t)).

Parameter get_change :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter update_tokens_per_roll :
  Raw_context.t -&gt; Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_contract_delegate :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      (option Signature.Public_key_hash.[S.SPublic_key_hash.t])).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_expr_hash.ml">
  <div class="col-md-6">
    <a href="#script_expr_hash.ml"><code>script_expr_hash.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let script_expr_hash = &quot;\013\044\064\027&quot; (* expr(54) *)

module Blake2BModule = Blake2B.Make
          (Base58)
          (struct
            let name = &quot;script_expr&quot;

            let title = &quot;A script expression ID&quot;

            let b58check_prefix = script_expr_hash

            let size = None
          end)

include Blake2BModule

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () = Base58.check_encoded_prefix b58check_encoding &quot;expr&quot; 54</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_expr_hash.ml"><code>Script_expr_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition script_expr_hash : string := &quot;\r,@\027&quot; % string.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT _ tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
        |}))
    (let name := &quot;script_expr&quot; % string in
    let title := &quot;A script expression ID&quot; % string in
    let b58check_prefix := script_expr_hash in
    let size := None in
    existT _ tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
        |}).

Definition t := Blake2BModule.[S.HASH.t].

Definition name := Blake2BModule.[S.HASH.name].

Definition title := Blake2BModule.[S.HASH.title].

Definition pp := Blake2BModule.[S.HASH.pp].

Definition pp_short := Blake2BModule.[S.HASH.pp_short].

Definition op_eq := Blake2BModule.[S.HASH.op_eq].

Definition op_ltgt := Blake2BModule.[S.HASH.op_ltgt].

Definition op_lt := Blake2BModule.[S.HASH.op_lt].

Definition op_lteq := Blake2BModule.[S.HASH.op_lteq].

Definition op_gteq := Blake2BModule.[S.HASH.op_gteq].

Definition op_gt := Blake2BModule.[S.HASH.op_gt].

Definition compare := Blake2BModule.[S.HASH.compare].

Definition equal := Blake2BModule.[S.HASH.equal].

Definition max := Blake2BModule.[S.HASH.max].

Definition min := Blake2BModule.[S.HASH.min].

Definition hash_bytes := Blake2BModule.[S.HASH.hash_bytes].

Definition hash_string := Blake2BModule.[S.HASH.hash_string].

Definition zero := Blake2BModule.[S.HASH.zero].

Definition size := Blake2BModule.[S.HASH.size].

Definition to_bytes := Blake2BModule.[S.HASH.to_bytes].

Definition of_bytes_opt := Blake2BModule.[S.HASH.of_bytes_opt].

Definition of_bytes_exn := Blake2BModule.[S.HASH.of_bytes_exn].

Definition to_b58check := Blake2BModule.[S.HASH.to_b58check].

Definition to_short_b58check := Blake2BModule.[S.HASH.to_short_b58check].

Definition of_b58check_exn := Blake2BModule.[S.HASH.of_b58check_exn].

Definition of_b58check_opt := Blake2BModule.[S.HASH.of_b58check_opt].

Definition b58check_encoding := Blake2BModule.[S.HASH.b58check_encoding].

Definition encoding := Blake2BModule.[S.HASH.encoding].

Definition rpc_arg := Blake2BModule.[S.HASH.rpc_arg].

Definition to_path := Blake2BModule.[S.HASH.to_path].

Definition of_path := Blake2BModule.[S.HASH.of_path].

Definition of_path_exn := Blake2BModule.[S.HASH.of_path_exn].

Definition prefix_path := Blake2BModule.[S.HASH.prefix_path].

Definition path_length := Blake2BModule.[S.HASH.path_length].

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_int_repr.ml">
  <div class="col-md-6">
    <a href="#script_int_repr.ml"><code>script_int_repr.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type n = Natural_tag

type z = Integer_tag

type 't num = Z.t

let compare x y = Z.compare x y

let zero = Z.zero

let zero_n = Z.zero

let to_string x = Z.to_string x

let of_string s = <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (Z.of_string s) with _ -&gt; None</abbr>

let to_int64 x = <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (Z.to_int64 x) with _ -&gt; None</abbr>

let of_int64 n = Z.of_int64 n

let to_int x = <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (Z.to_int x) with _ -&gt; None</abbr>

let of_int n = Z.of_int n

let of_zint x = x

let to_zint x = x

let add x y = Z.add x y

let sub x y = Z.sub x y

let mul x y = Z.mul x y

let ediv x y =
  <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let (q, r) = Z.ediv_rem x y in
    Some (q, r)
  with _ -&gt; None</abbr>

let add_n = add

let mul_n = mul

let ediv_n = ediv

let abs x = Z.abs x

let is_nat x = if Compare.Z.(x &lt; Z.zero) then None else Some x

let neg x = Z.neg x

let int x = x

let shift_left x y =
  if Compare.Int.(Z.compare y (Z.of_int 256) &gt; 0) then None
  else
    let y = Z.to_int y in
    Some (Z.shift_left x y)

let shift_right x y =
  if Compare.Int.(Z.compare y (Z.of_int 256) &gt; 0) then None
  else
    let y = Z.to_int y in
    Some (Z.shift_right x y)

let shift_left_n = shift_left

let shift_right_n = shift_right

let logor x y = Z.logor x y

let logxor x y = Z.logxor x y

let logand x y = Z.logand x y

let lognot x = Z.lognot x
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_int_repr.ml"><code>Script_int_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Inductive n : Set :=
| Natural_tag : n.

Inductive z : Set :=
| Integer_tag : z.

Definition num (t : Set) := Z.t.

Definition compare (x : Z.t) (y : Z.t) : Z := Z.compare x y.

Definition zero : Z.t := Z.zero.

Definition zero_n : Z.t := Z.zero.

Definition to_string (x : Z.t) : string := Z.to_string x.

Definition of_string (s : string) : option Z.t :=
  (* ‚ùå Try-with are not handled *)
  try (Some (Z.of_string s)).

Definition to_int64 (x : Z.t) : option int64 :=
  (* ‚ùå Try-with are not handled *)
  try (Some (Z.to_int64 x)).

Definition of_int64 (n : int64) : Z.t := Z.of_int64 n.

Definition to_int (x : Z.t) : option Z :=
  (* ‚ùå Try-with are not handled *)
  try (Some (Z.to_int x)).

Definition of_int (n : Z) : Z.t := Z.of_int n.

Definition of_zint {A : Set} (x : A) : A := x.

Definition to_zint {A : Set} (x : A) : A := x.

Definition add (x : Z.t) (y : Z.t) : Z.t := Z.add x y.

Definition sub (x : Z.t) (y : Z.t) : Z.t := Z.sub x y.

Definition mul (x : Z.t) (y : Z.t) : Z.t := Z.mul x y.

Definition ediv (x : Z.t) (y : Z.t) : option (Z.t * Z.t) :=
  (* ‚ùå Try-with are not handled *)
  try
    (let '(q, r) := Z.ediv_rem x y in
    Some (q, r)).

Definition add_n : Z.t -&gt; Z.t -&gt; Z.t := add.

Definition mul_n : Z.t -&gt; Z.t -&gt; Z.t := mul.

Definition ediv_n : Z.t -&gt; Z.t -&gt; option (Z.t * Z.t) := ediv.

Definition abs (x : Z.t) : Z.t := Z.abs x.

Definition is_nat (x : Compare.Z.[Compare.S.t])
  : option Compare.Z.[Compare.S.t] :=
  if Compare.Z.[Compare.S.op_lt] x Z.zero then
    None
  else
    Some x.

Definition neg (x : Z.t) : Z.t := Z.neg x.

Definition int {A : Set} (x : A) : A := x.

Definition shift_left (x : Z.t) (y : Z.t) : option Z.t :=
  if Compare.Int.[Compare.S.op_gt] (Z.compare y (Z.of_int 256)) 0 then
    None
  else
    let y := Z.to_int y in
    Some (Z.shift_left x y).

Definition shift_right (x : Z.t) (y : Z.t) : option Z.t :=
  if Compare.Int.[Compare.S.op_gt] (Z.compare y (Z.of_int 256)) 0 then
    None
  else
    let y := Z.to_int y in
    Some (Z.shift_right x y).

Definition shift_left_n : Z.t -&gt; Z.t -&gt; option Z.t := shift_left.

Definition shift_right_n : Z.t -&gt; Z.t -&gt; option Z.t := shift_right.

Definition logor (x : Z.t) (y : Z.t) : Z.t := Z.logor x y.

Definition logxor (x : Z.t) (y : Z.t) : Z.t := Z.logxor x y.

Definition logand (x : Z.t) (y : Z.t) : Z.t := Z.logand x y.

Definition lognot (x : Z.t) : Z.t := Z.lognot x.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_int_repr.mli">
  <div class="col-md-6">
    <a href="#script_int_repr.mli"><code>script_int_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** The types for arbitraty precision integers in Michelson.
    The type variable ['t] is always [n] or [z],
    [n num] and [z num] are incompatible.

    This is internally a [Z.t].
    This module mostly adds signedness preservation guarantees. *)
type 't num

(** Flag for natural numbers. *)
type n = Natural_tag

(** Flag for relative numbers. *)
type z = Integer_tag

(** Natural zero. *)
val zero_n : n num

(** Relative zero. *)
val zero : z num

(** Compare two numbers as if they were *)
val compare : 'a num -&gt; 'a num -&gt; int

(** Conversion to an OCaml [string] in decimal notation. *)
val to_string : _ num -&gt; string

(** Conversion from an OCaml [string].
    Returns [None] in case of an invalid notation.
    Supports [+] and [-] sign modifiers, and [0x], [0o] and [0b] base modifiers. *)
val of_string : string -&gt; z num option

(** Conversion to an OCaml [int64], returns [None] on overflow. *)
val to_int64 : _ num -&gt; int64 option

(** Conversion from an OCaml [int]. *)
val of_int64 : int64 -&gt; z num

(** Conversion to an OCaml [int], returns [None] on overflow. *)
val to_int : _ num -&gt; int option

(** Conversion from an OCaml [int64]. *)
val of_int : int -&gt; z num

(** Conversion from a Zarith integer ([Z.t]). *)
val of_zint : Z.t -&gt; z num

(** Conversion to a Zarith integer ([Z.t]). *)
val to_zint : 'a num -&gt; Z.t

(** Addition between naturals. *)
val add_n : n num -&gt; n num -&gt; n num

(** Multiplication between naturals. *)
val mul_n : n num -&gt; n num -&gt; n num

(** Euclidean division between naturals.
    [ediv_n n d] returns [None] if divisor is zero,
    or [Some (q, r)] where [n = d * q + r] and [[0 &lt;= r &lt; d]] otherwise. *)
val ediv_n : n num -&gt; n num -&gt; (n num * n num) option

(** Sign agnostic addition.
    Use {!add_n} when working with naturals to preserve the sign. *)
val add : _ num -&gt; _ num -&gt; z num

(** Sign agnostic subtraction.
    Use {!sub_n} when working with naturals to preserve the sign. *)
val sub : _ num -&gt; _ num -&gt; z num

(** Sign agnostic multiplication.
    Use {!mul_n} when working with naturals to preserve the sign. *)
val mul : _ num -&gt; _ num -&gt; z num

(** Sign agnostic euclidean division.
    [ediv n d] returns [None] if divisor is zero,
    or [Some (q, r)] where [n = d * q + r] and [[0 &lt;= r &lt; |d|]] otherwise.
    Use {!ediv_n} when working with naturals to preserve the sign. *)
val ediv : _ num -&gt; _ num -&gt; (z num * n num) option

(** Compute the absolute value of a relative, turning it into a natural. *)
val abs : z num -&gt; n num

(** Partial identity over [N]. *)
val is_nat : z num -&gt; n num option

(** Negates a number. *)
val neg : _ num -&gt; z num

(** Turns a natural into a relative, not changing its value. *)
val int : n num -&gt; z num

(** Reverses each bit in the representation of the number.
    Also applies to the sign. *)
val lognot : _ num -&gt; z num

(** Shifts the natural to the left of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_left_n : n num -&gt; n num -&gt; n num option

(** Shifts the natural to the right of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_right_n : n num -&gt; n num -&gt; n num option

(** Shifts the number to the left of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_left : 'a num -&gt; n num -&gt; 'a num option

(** Shifts the number to the right of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_right : 'a num -&gt; n num -&gt; 'a num option

(** Applies a boolean or operation to each bit. *)
val logor : 'a num -&gt; 'a num -&gt; 'a num

(** Applies a boolean and operation to each bit. *)
val logand : _ num -&gt; n num -&gt; n num

(** Applies a boolean xor operation to each bit. *)
val logxor : n num -&gt; n num -&gt; n num
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_int_repr.mli"><code>Script_int_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Parameter num : forall (t : Set), Set.

Inductive n : Set :=
| Natural_tag : n.

Inductive z : Set :=
| Integer_tag : z.

Parameter zero_n : num n.

Parameter zero : num z.

Parameter compare : forall {a : Set}, num a -&gt; num a -&gt; Z.

Parameter to_string : forall {A : Set}, num A -&gt; string.

Parameter of_string : string -&gt; option (num z).

Parameter to_int64 : forall {A : Set}, num A -&gt; option int64.

Parameter of_int64 : int64 -&gt; num z.

Parameter to_int : forall {A : Set}, num A -&gt; option Z.

Parameter of_int : Z -&gt; num z.

Parameter of_zint : Z.t -&gt; num z.

Parameter to_zint : forall {a : Set}, num a -&gt; Z.t.

Parameter add_n : num n -&gt; num n -&gt; num n.

Parameter mul_n : num n -&gt; num n -&gt; num n.

Parameter ediv_n : num n -&gt; num n -&gt; option (num n * num n).

Parameter add : forall {A B : Set}, num A -&gt; num B -&gt; num z.

Parameter sub : forall {A B : Set}, num A -&gt; num B -&gt; num z.

Parameter mul : forall {A B : Set}, num A -&gt; num B -&gt; num z.

Parameter ediv : forall {A B : Set}, num A -&gt; num B -&gt; option (num z * num n).

Parameter abs : num z -&gt; num n.

Parameter is_nat : num z -&gt; option (num n).

Parameter neg : forall {A : Set}, num A -&gt; num z.

Parameter int : num n -&gt; num z.

Parameter lognot : forall {A : Set}, num A -&gt; num z.

Parameter shift_left_n : num n -&gt; num n -&gt; option (num n).

Parameter shift_right_n : num n -&gt; num n -&gt; option (num n).

Parameter shift_left : forall {a : Set}, num a -&gt; num n -&gt; option (num a).

Parameter shift_right : forall {a : Set}, num a -&gt; num n -&gt; option (num a).

Parameter logor : forall {a : Set}, num a -&gt; num a -&gt; num a.

Parameter logand : forall {A : Set}, num A -&gt; num n -&gt; num n.

Parameter logxor : num n -&gt; num n -&gt; num n.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_interpreter.ml">
  <div class="col-md-6">
    <a href="#script_interpreter.ml"><code>script_interpreter.ml</code></a>&nbsp;<span class="label label-danger">30 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script
open Script_typed_ir
open Script_ir_translator

(* ---- Run-time errors -----------------------------------------------------*)

type execution_trace =
  (Script.location * Gas.t * (Script.expr * string option) list) list

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Reject of Script.location * Script.expr * execution_trace option</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Overflow of Script.location * execution_trace option</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Runtime_contract_error : Contract.t * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Bad_contract_parameter of Contract.t</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Cannot_serialize_log</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Cannot_serialize_failure</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Cannot_serialize_storage</abbr>

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  let trace_encoding =
    list
    @@ obj3
         (req &quot;location&quot; Script.location_encoding)
         (req &quot;gas&quot; Gas.encoding)
         (req
            &quot;stack&quot;
            (list (obj2 (req &quot;item&quot; Script.expr_encoding) (opt &quot;annot&quot; string))))
  in
  (* Reject *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.script_rejected&quot;
    ~title:&quot;Script failed&quot;
    ~description:&quot;A FAILWITH instruction was reached&quot;
    (obj3
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;with&quot; Script.expr_encoding)
       (opt &quot;trace&quot; trace_encoding))
    (function Reject (loc, v, trace) -&gt; Some (loc, v, trace) | _ -&gt; None)
    (fun (loc, v, trace) -&gt; Reject (loc, v, trace)) ;
  (* Overflow *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.script_overflow&quot;
    ~title:&quot;Script failed (overflow error)&quot;
    ~description:
      &quot;A FAIL instruction was reached due to the detection of an overflow&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (opt &quot;trace&quot; trace_encoding))
    (function Overflow (loc, trace) -&gt; Some (loc, trace) | _ -&gt; None)
    (fun (loc, trace) -&gt; Overflow (loc, trace)) ;
  (* Runtime contract error *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.runtime_error&quot;
    ~title:&quot;Script runtime error&quot;
    ~description:&quot;Toplevel error for all runtime script errors&quot;
    (obj2
       (req &quot;contract_handle&quot; Contract.encoding)
       (req &quot;contract_code&quot; Script.expr_encoding))
    (function
      | Runtime_contract_error (contract, expr) -&gt;
          Some (contract, expr)
      | _ -&gt;
          None)
    (fun (contract, expr) -&gt; Runtime_contract_error (contract, expr)) ;
  (* Bad contract parameter *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_contract_parameter&quot;
    ~title:&quot;Contract supplied an invalid parameter&quot;
    ~description:
      &quot;Either no parameter was supplied to a contract with a non-unit \
       parameter type, a non-unit parameter was passed to an account, or a \
       parameter was supplied of the wrong type&quot;
    Data_encoding.(obj1 (req &quot;contract&quot; Contract.encoding))
    (function Bad_contract_parameter c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Bad_contract_parameter c) ;
  (* Cannot serialize log *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_log&quot;
    ~title:&quot;Not enough gas to serialize execution trace&quot;
    ~description:
      &quot;Execution trace with stacks was to big to be serialized with the \
       provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_log -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_log) ;
  (* Cannot serialize failure *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_failure&quot;
    ~title:&quot;Not enough gas to serialize argument of FAILWITH&quot;
    ~description:
      &quot;Argument of FAILWITH was too big to be serialized with the provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_failure -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_failure) ;
  (* Cannot serialize storage *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_storage&quot;
    ~title:&quot;Not enough gas to serialize execution storage&quot;
    ~description:
      &quot;The returned storage was too big to be serialized with the provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_storage -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_storage)</abbr>

(* ---- interpreter ---------------------------------------------------------*)

type 'tys stack =
  | Item : 'ty * 'rest stack -&gt; ('ty * 'rest) stack
  | Empty : end_of_stack stack

let unparse_stack ctxt (stack, stack_ty) =
  (* We drop the gas limit as this function is only used for debugging/errors. *)
  let ctxt = Gas.set_unlimited ctxt in
  let rec unparse_stack :
      type a.
      a stack * a stack_ty -&gt; (Script.expr * string option) list tzresult Lwt.t
      = function
    | (Empty, Empty_t) -&gt;
        return_nil
    | (Item (v, rest), Item_t (ty, rest_ty, annot)) -&gt;
        unparse_data ctxt Readable ty v
        &gt;&gt;=? fun (data, _ctxt) -&gt;
        unparse_stack (rest, rest_ty)
        &gt;&gt;=? fun rest -&gt;
        let annot =
          match Script_ir_annot.unparse_var_annot annot with
          | [] -&gt;
              None
          | [a] -&gt;
              Some a
          | _ -&gt;
              <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
        in
        let data = Micheline.strip_locations data in
        return ((data, annot) :: rest)
  in
  unparse_stack (stack, stack_ty)

module Interp_costs = Michelson_v1_gas.Cost_of.Interpreter

let rec interp_stack_prefix_preserving_operation :
    type fbef bef faft aft result.
    (fbef stack -&gt; (faft stack * result) tzresult Lwt.t) -&gt;
    (fbef, faft, bef, aft) stack_prefix_preservation_witness -&gt;
    bef stack -&gt;
    (aft stack * result) tzresult Lwt.t =
 fun f n stk -&gt;
  match (n, stk) with
  | ( Prefix
        (Prefix
          (Prefix
            (Prefix
              (Prefix
                (Prefix
                  (Prefix
                    (Prefix
                      (Prefix
                        (Prefix
                          (Prefix
                            (Prefix (Prefix (Prefix (Prefix (Prefix n))))))))))))))),
      Item
        ( v0,
          Item
            ( v1,
              Item
                ( v2,
                  Item
                    ( v3,
                      Item
                        ( v4,
                          Item
                            ( v5,
                              Item
                                ( v6,
                                  Item
                                    ( v7,
                                      Item
                                        ( v8,
                                          Item
                                            ( v9,
                                              Item
                                                ( va,
                                                  Item
                                                    ( vb,
                                                      Item
                                                        ( vc,
                                                          Item
                                                            ( vd,
                                                              Item
                                                                ( ve,
                                                                  Item
                                                                    (vf, rest)
                                                                ) ) ) ) ) ) )
                                    ) ) ) ) ) ) ) ) ) -&gt;
      interp_stack_prefix_preserving_operation f n rest
      &gt;&gt;=? fun (rest', result) -&gt;
      return
        ( Item
            ( v0,
              Item
                ( v1,
                  Item
                    ( v2,
                      Item
                        ( v3,
                          Item
                            ( v4,
                              Item
                                ( v5,
                                  Item
                                    ( v6,
                                      Item
                                        ( v7,
                                          Item
                                            ( v8,
                                              Item
                                                ( v9,
                                                  Item
                                                    ( va,
                                                      Item
                                                        ( vb,
                                                          Item
                                                            ( vc,
                                                              Item
                                                                ( vd,
                                                                  Item
                                                                    ( ve,
                                                                      Item
                                                                        ( vf,
                                                                          rest'
                                                                        ) ) )
                                                            ) ) ) ) ) ) ) ) )
                        ) ) ) ),
          result )
  | ( Prefix (Prefix (Prefix (Prefix n))),
      Item (v0, Item (v1, Item (v2, Item (v3, rest)))) ) -&gt;
      interp_stack_prefix_preserving_operation f n rest
      &gt;&gt;=? fun (rest', result) -&gt;
      return (Item (v0, Item (v1, Item (v2, Item (v3, rest')))), result)
  | (Prefix n, Item (v, rest)) -&gt;
      interp_stack_prefix_preserving_operation f n rest
      &gt;&gt;=? fun (rest', result) -&gt; return (Item (v, rest'), result)
  | (Rest, v) -&gt;
      f v

type step_constants = {
  source : Contract.t;
  payer : Contract.t;
  self : Contract.t;
  amount : Tez.t;
  chain_id : Chain_id.t;
}

let rec step :
    type b a.
    ?log:execution_trace ref -&gt;
    context -&gt;
    step_constants -&gt;
    (b, a) descr -&gt;
    b stack -&gt;
    (a stack * context) tzresult Lwt.t =
 fun ?log ctxt step_constants ({instr; loc; _} as descr) stack -&gt;
  Lwt.return (Gas.consume ctxt Interp_costs.cycle)
  &gt;&gt;=? fun ctxt -&gt;
  let logged_return :
      type a b.
      (b, a) descr -&gt; a stack * context -&gt; (a stack * context) tzresult Lwt.t =
   fun descr (ret, ctxt) -&gt;
    match log with
    | None -&gt;
        return (ret, ctxt)
    | Some log -&gt;
        trace <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_serialize_log</abbr> (unparse_stack ctxt (ret, descr.aft))
        &gt;&gt;=? fun stack -&gt;
        <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">log := (descr.loc, Gas.level ctxt, stack) :: !log ;
        return (ret, ctxt)</abbr>
  in
  let get_log (log : execution_trace ref option) =
    Option.map ~f:(fun l -&gt; List.rev !l) log
  in
  let consume_gas_terop :
      type ret arg1 arg2 arg3 rest.
      (_ * (_ * (_ * rest)), ret * rest) descr -&gt;
      (arg1 -&gt; arg2 -&gt; arg3 -&gt; ret) * arg1 * arg2 * arg3 -&gt;
      (arg1 -&gt; arg2 -&gt; arg3 -&gt; Gas.cost) -&gt;
      rest stack -&gt;
      ((ret * rest) stack * context) tzresult Lwt.t =
   fun descr (op, x1, x2, x3) cost_func rest -&gt;
    Lwt.return (Gas.consume ctxt (cost_func x1 x2 x3))
    &gt;&gt;=? fun ctxt -&gt; logged_return descr (Item (op x1 x2 x3, rest), ctxt)
  in
  let consume_gas_binop :
      type ret arg1 arg2 rest.
      (_ * (_ * rest), ret * rest) descr -&gt;
      (arg1 -&gt; arg2 -&gt; ret) * arg1 * arg2 -&gt;
      (arg1 -&gt; arg2 -&gt; Gas.cost) -&gt;
      rest stack -&gt;
      context -&gt;
      ((ret * rest) stack * context) tzresult Lwt.t =
   fun descr (op, x1, x2) cost_func rest ctxt -&gt;
    Lwt.return (Gas.consume ctxt (cost_func x1 x2))
    &gt;&gt;=? fun ctxt -&gt; logged_return descr (Item (op x1 x2, rest), ctxt)
  in
  let consume_gas_unop :
      type ret arg rest.
      (_ * rest, ret * rest) descr -&gt;
      (arg -&gt; ret) * arg -&gt;
      (arg -&gt; Gas.cost) -&gt;
      rest stack -&gt;
      context -&gt;
      ((ret * rest) stack * context) tzresult Lwt.t =
   fun descr (op, arg) cost_func rest ctxt -&gt;
    Lwt.return (Gas.consume ctxt (cost_func arg))
    &gt;&gt;=? fun ctxt -&gt; logged_return descr (Item (op arg, rest), ctxt)
  in
  let logged_return : a stack * context -&gt; (a stack * context) tzresult Lwt.t =
    logged_return descr
  in
  match (instr, stack) with
  (* stack ops *)
  | (Drop, Item (_, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt; logged_return (rest, ctxt)
  | (Dup, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (v, Item (v, rest)), ctxt)
  | (Swap, Item (vi, Item (vo, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (vo, Item (vi, rest)), ctxt)
  | (Const v, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (v, rest), ctxt)
  (* options *)
  | (Cons_some, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.wrap)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (Some v, rest), ctxt)
  | (Cons_none _, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.variant_no_data)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (None, rest), ctxt)
  | (If_none (bt, _), Item (None, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt; step ?log ctxt step_constants bt rest
  | (If_none (_, bf), Item (Some v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt; step ?log ctxt step_constants bf (Item (v, rest))
  (* pairs *)
  | (Cons_pair, Item (a, Item (b, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.pair)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item ((a, b), rest), ctxt)
  (* Peephole optimization for UNPAIR *)
  | ( Seq
        ( {instr = Dup; _},
          { instr =
              Seq
                ( {instr = Car; _},
                  { instr = Seq ({instr = Dip {instr = Cdr}}, {instr = Nop; _});
                    _ } );
            _ } ),
      Item ((a, b), rest) ) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.pair_access)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (a, Item (b, rest)), ctxt)
  | (Car, Item ((a, _), rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.pair_access)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (a, rest), ctxt)
  | (Cdr, Item ((_, b), rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.pair_access)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (b, rest), ctxt)
  (* unions *)
  | (Left, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.wrap)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (L v, rest), ctxt)
  | (Right, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.wrap)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (R v, rest), ctxt)
  | (If_left (bt, _), Item (L v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt; step ?log ctxt step_constants bt (Item (v, rest))
  | (If_left (_, bf), Item (R v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt; step ?log ctxt step_constants bf (Item (v, rest))
  (* lists *)
  | (Cons_list, Item (hd, Item (tl, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.cons)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (hd :: tl, rest), ctxt)
  | (Nil, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.variant_no_data)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item ([], rest), ctxt)
  | (If_cons (_, bf), Item ([], rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt; step ?log ctxt step_constants bf rest
  | (If_cons (bt, _), Item (hd :: tl, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt;
      step ?log ctxt step_constants bt (Item (hd, Item (tl, rest)))
  | (List_map body, Item (l, rest)) -&gt;
      let rec loop rest ctxt l acc =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_map)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (Item (List.rev acc, rest), ctxt)
        | hd :: tl -&gt;
            step ?log ctxt step_constants body (Item (hd, rest))
            &gt;&gt;=? fun (Item (hd, rest), ctxt) -&gt; loop rest ctxt tl (hd :: acc)
      in
      loop rest ctxt l [] &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  | (List_size, Item (list, rest)) -&gt;
      Lwt.return
        (List.fold_left
           (fun acc _ -&gt;
             acc
             &gt;&gt;? fun (size, ctxt) -&gt;
             Gas.consume ctxt Interp_costs.loop_size
             &gt;&gt;? fun ctxt -&gt; ok (size + 1 (* FIXME: overflow *), ctxt))
           (ok (0, ctxt))
           list)
      &gt;&gt;=? fun (len, ctxt) -&gt;
      logged_return (Item (Script_int.(abs (of_int len)), rest), ctxt)
  | (List_iter body, Item (l, init)) -&gt;
      let rec loop ctxt l stack =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_iter)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (stack, ctxt)
        | hd :: tl -&gt;
            step ?log ctxt step_constants body (Item (hd, stack))
            &gt;&gt;=? fun (stack, ctxt) -&gt; loop ctxt tl stack
      in
      loop ctxt l init &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  (* sets *)
  | (Empty_set t, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.empty_set)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (empty_set t, rest), ctxt)
  | (Set_iter body, Item (set, init)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.set_to_list set))
      &gt;&gt;=? fun ctxt -&gt;
      let l = List.rev (set_fold (fun e acc -&gt; e :: acc) set []) in
      let rec loop ctxt l stack =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_iter)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (stack, ctxt)
        | hd :: tl -&gt;
            step ?log ctxt step_constants body (Item (hd, stack))
            &gt;&gt;=? fun (stack, ctxt) -&gt; loop ctxt tl stack
      in
      loop ctxt l init &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  | (Set_mem, Item (v, Item (set, rest))) -&gt;
      consume_gas_binop descr (set_mem, v, set) Interp_costs.set_mem rest ctxt
  | (Set_update, Item (v, Item (presence, Item (set, rest)))) -&gt;
      consume_gas_terop
        descr
        (set_update, v, presence, set)
        Interp_costs.set_update
        rest
  | (Set_size, Item (set, rest)) -&gt;
      consume_gas_unop
        descr
        (set_size, set)
        (fun _ -&gt; Interp_costs.set_size)
        rest
        ctxt
  (* maps *)
  | (Empty_map (t, _), rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.empty_map)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (empty_map t, rest), ctxt)
  | (Map_map body, Item (map, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_to_list map))
      &gt;&gt;=? fun ctxt -&gt;
      let l = List.rev (map_fold (fun k v acc -&gt; (k, v) :: acc) map []) in
      let rec loop rest ctxt l acc =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_map)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (acc, ctxt)
        | ((k, _) as hd) :: tl -&gt;
            step ?log ctxt step_constants body (Item (hd, rest))
            &gt;&gt;=? fun (Item (hd, rest), ctxt) -&gt;
            loop rest ctxt tl (map_update k (Some hd) acc)
      in
      loop rest ctxt l (empty_map (map_key_ty map))
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (res, rest), ctxt)
  | (Map_iter body, Item (map, init)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_to_list map))
      &gt;&gt;=? fun ctxt -&gt;
      let l = List.rev (map_fold (fun k v acc -&gt; (k, v) :: acc) map []) in
      let rec loop ctxt l stack =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_iter)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (stack, ctxt)
        | hd :: tl -&gt;
            step ?log ctxt step_constants body (Item (hd, stack))
            &gt;&gt;=? fun (stack, ctxt) -&gt; loop ctxt tl stack
      in
      loop ctxt l init &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  | (Map_mem, Item (v, Item (map, rest))) -&gt;
      consume_gas_binop descr (map_mem, v, map) Interp_costs.map_mem rest ctxt
  | (Map_get, Item (v, Item (map, rest))) -&gt;
      consume_gas_binop descr (map_get, v, map) Interp_costs.map_get rest ctxt
  | (Map_update, Item (k, Item (v, Item (map, rest)))) -&gt;
      consume_gas_terop
        descr
        (map_update, k, v, map)
        Interp_costs.map_update
        rest
  | (Map_size, Item (map, rest)) -&gt;
      consume_gas_unop
        descr
        (map_size, map)
        (fun _ -&gt; Interp_costs.map_size)
        rest
        ctxt
  (* Big map operations *)
  | (Empty_big_map (tk, tv), rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.empty_map)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        (Item (Script_ir_translator.empty_big_map tk tv, rest), ctxt)
  | (Big_map_mem, Item (key, Item (map, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_mem key map.diff))
      &gt;&gt;=? fun ctxt -&gt;
      Script_ir_translator.big_map_mem ctxt key map
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (res, rest), ctxt)
  | (Big_map_get, Item (key, Item (map, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_get key map.diff))
      &gt;&gt;=? fun ctxt -&gt;
      Script_ir_translator.big_map_get ctxt key map
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (res, rest), ctxt)
  | (Big_map_update, Item (key, Item (maybe_value, Item (map, rest)))) -&gt;
      consume_gas_terop
        descr
        (Script_ir_translator.big_map_update, key, maybe_value, map)
        (fun k v m -&gt; Interp_costs.map_update k (Some v) m.diff)
        rest
  (* timestamp operations *)
  | (Add_seconds_to_timestamp, Item (n, Item (t, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.add_delta, t, n)
        Interp_costs.add_timestamp
        rest
        ctxt
  | (Add_timestamp_to_seconds, Item (t, Item (n, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.add_delta, t, n)
        Interp_costs.add_timestamp
        rest
        ctxt
  | (Sub_timestamp_seconds, Item (t, Item (s, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.sub_delta, t, s)
        Interp_costs.sub_timestamp
        rest
        ctxt
  | (Diff_timestamps, Item (t1, Item (t2, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.diff, t1, t2)
        Interp_costs.diff_timestamps
        rest
        ctxt
  (* string operations *)
  | (Concat_string_pair, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_string [x; y]))
      &gt;&gt;=? fun ctxt -&gt;
      let s = String.concat &quot;&quot; [x; y] in
      logged_return (Item (s, rest), ctxt)
  | (Concat_string, Item (ss, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_string ss))
      &gt;&gt;=? fun ctxt -&gt;
      let s = String.concat &quot;&quot; ss in
      logged_return (Item (s, rest), ctxt)
  | (Slice_string, Item (offset, Item (length, Item (s, rest)))) -&gt;
      let s_length = Z.of_int (String.length s) in
      let offset = Script_int.to_zint offset in
      let length = Script_int.to_zint length in
      if Compare.Z.(offset &lt; s_length &amp;&amp; Z.add offset length &lt;= s_length) then
        Lwt.return
          (Gas.consume ctxt (Interp_costs.slice_string (Z.to_int length)))
        &gt;&gt;=? fun ctxt -&gt;
        logged_return
          ( Item (Some (String.sub s (Z.to_int offset) (Z.to_int length)), rest),
            ctxt )
      else
        Lwt.return (Gas.consume ctxt (Interp_costs.slice_string 0))
        &gt;&gt;=? fun ctxt -&gt; logged_return (Item (None, rest), ctxt)
  | (String_size, Item (s, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        (Item (Script_int.(abs (of_int (String.length s))), rest), ctxt)
  (* bytes operations *)
  | (Concat_bytes_pair, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_bytes [x; y]))
      &gt;&gt;=? fun ctxt -&gt;
      let s = MBytes.concat &quot;&quot; [x; y] in
      logged_return (Item (s, rest), ctxt)
  | (Concat_bytes, Item (ss, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_bytes ss))
      &gt;&gt;=? fun ctxt -&gt;
      let s = MBytes.concat &quot;&quot; ss in
      logged_return (Item (s, rest), ctxt)
  | (Slice_bytes, Item (offset, Item (length, Item (s, rest)))) -&gt;
      let s_length = Z.of_int (MBytes.length s) in
      let offset = Script_int.to_zint offset in
      let length = Script_int.to_zint length in
      if Compare.Z.(offset &lt; s_length &amp;&amp; Z.add offset length &lt;= s_length) then
        Lwt.return
          (Gas.consume ctxt (Interp_costs.slice_string (Z.to_int length)))
        &gt;&gt;=? fun ctxt -&gt;
        logged_return
          ( Item (Some (MBytes.sub s (Z.to_int offset) (Z.to_int length)), rest),
            ctxt )
      else
        Lwt.return (Gas.consume ctxt (Interp_costs.slice_string 0))
        &gt;&gt;=? fun ctxt -&gt; logged_return (Item (None, rest), ctxt)
  | (Bytes_size, Item (s, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        (Item (Script_int.(abs (of_int (MBytes.length s))), rest), ctxt)
  (* currency operations *)
  | (Add_tez, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return Tez.(x +? y)
      &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt)
  | (Sub_tez, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return Tez.(x -? y)
      &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt)
  | (Mul_teznat, Item (x, Item (y, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.z_to_int64)
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.to_int64 y with
      | None -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Overflow (loc, get_log log))</abbr>
      | Some y -&gt;
          Lwt.return Tez.(x *? y)
          &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt) )
  | (Mul_nattez, Item (y, Item (x, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.z_to_int64)
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.to_int64 y with
      | None -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Overflow (loc, get_log log))</abbr>
      | Some y -&gt;
          Lwt.return Tez.(x *? y)
          &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt) )
  (* boolean operations *)
  | (Or, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (( || ), x, y) Interp_costs.bool_binop rest ctxt
  | (And, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (( &amp;&amp; ), x, y) Interp_costs.bool_binop rest ctxt
  | (Xor, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Compare.Bool.( &lt;&gt; ), x, y)
        Interp_costs.bool_binop
        rest
        ctxt
  | (Not, Item (x, rest)) -&gt;
      consume_gas_unop descr (not, x) Interp_costs.bool_unop rest ctxt
  (* integer operations *)
  | (Is_nat, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.is_nat, x) Interp_costs.abs rest ctxt
  | (Abs_int, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.abs, x) Interp_costs.abs rest ctxt
  | (Int_nat, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.int, x) Interp_costs.int rest ctxt
  | (Neg_int, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.neg, x) Interp_costs.neg rest ctxt
  | (Neg_nat, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.neg, x) Interp_costs.neg rest ctxt
  | (Add_intint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.add, x, y) Interp_costs.add rest ctxt
  | (Add_intnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.add, x, y) Interp_costs.add rest ctxt
  | (Add_natint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.add, x, y) Interp_costs.add rest ctxt
  | (Add_natnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.add_n, x, y)
        Interp_costs.add
        rest
        ctxt
  | (Sub_int, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.sub, x, y) Interp_costs.sub rest ctxt
  | (Mul_intint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.mul, x, y) Interp_costs.mul rest ctxt
  | (Mul_intnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.mul, x, y) Interp_costs.mul rest ctxt
  | (Mul_natint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.mul, x, y) Interp_costs.mul rest ctxt
  | (Mul_natnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.mul_n, x, y)
        Interp_costs.mul
        rest
        ctxt
  | (Ediv_teznat, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_to_z)
      &gt;&gt;=? fun ctxt -&gt;
      let x = Script_int.of_int64 (Tez.to_mutez x) in
      consume_gas_binop
        descr
        ( (fun x y -&gt;
            match Script_int.ediv x y with
            | None -&gt;
                None
            | Some (q, r) -&gt; (
              match (Script_int.to_int64 q, Script_int.to_int64 r) with
              | (Some q, Some r) -&gt; (
                match (Tez.of_mutez q, Tez.of_mutez r) with
                | (Some q, Some r) -&gt;
                    Some (q, r)
                (* Cannot overflow *)
                | _ -&gt;
                    <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> )
              (* Cannot overflow *)
              | _ -&gt;
                  <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> )),
          x,
          y )
        Interp_costs.div
        rest
        ctxt
  | (Ediv_tez, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_to_z)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_to_z)
      &gt;&gt;=? fun ctxt -&gt;
      let x = Script_int.abs (Script_int.of_int64 (Tez.to_mutez x)) in
      let y = Script_int.abs (Script_int.of_int64 (Tez.to_mutez y)) in
      consume_gas_binop
        descr
        ( (fun x y -&gt;
            match Script_int.ediv_n x y with
            | None -&gt;
                None
            | Some (q, r) -&gt; (
              match Script_int.to_int64 r with
              | None -&gt;
                  <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* Cannot overflow *)
              | Some r -&gt; (
                match Tez.of_mutez r with
                | None -&gt;
                    <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* Cannot overflow *)
                | Some r -&gt;
                    Some (q, r) ) )),
          x,
          y )
        Interp_costs.div
        rest
        ctxt
  | (Ediv_intint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Ediv_intnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Ediv_natint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Ediv_natnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv_n, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Lsl_nat, Item (x, Item (y, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt (Interp_costs.shift_left x y))
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.shift_left_n x y with
      | None -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Overflow (loc, get_log log))</abbr>
      | Some x -&gt;
          logged_return (Item (x, rest), ctxt) )
  | (Lsr_nat, Item (x, Item (y, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt (Interp_costs.shift_right x y))
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.shift_right_n x y with
      | None -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Overflow (loc, get_log log))</abbr>
      | Some r -&gt;
          logged_return (Item (r, rest), ctxt) )
  | (Or_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logor, x, y)
        Interp_costs.logor
        rest
        ctxt
  | (And_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logand, x, y)
        Interp_costs.logand
        rest
        ctxt
  | (And_int_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logand, x, y)
        Interp_costs.logand
        rest
        ctxt
  | (Xor_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logxor, x, y)
        Interp_costs.logxor
        rest
        ctxt
  | (Not_int, Item (x, rest)) -&gt;
      consume_gas_unop
        descr
        (Script_int.lognot, x)
        Interp_costs.lognot
        rest
        ctxt
  | (Not_nat, Item (x, rest)) -&gt;
      consume_gas_unop
        descr
        (Script_int.lognot, x)
        Interp_costs.lognot
        rest
        ctxt
  (* control *)
  | (Seq (hd, tl), stack) -&gt;
      step ?log ctxt step_constants hd stack
      &gt;&gt;=? fun (trans, ctxt) -&gt; step ?log ctxt step_constants tl trans
  | (If (bt, _), Item (true, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt; step ?log ctxt step_constants bt rest
  | (If (_, bf), Item (false, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.branch)
      &gt;&gt;=? fun ctxt -&gt; step ?log ctxt step_constants bf rest
  | (Loop body, Item (true, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.loop_cycle)
      &gt;&gt;=? fun ctxt -&gt;
      step ?log ctxt step_constants body rest
      &gt;&gt;=? fun (trans, ctxt) -&gt; step ?log ctxt step_constants descr trans
  | (Loop _, Item (false, rest)) -&gt;
      logged_return (rest, ctxt)
  | (Loop_left body, Item (L v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.loop_cycle)
      &gt;&gt;=? fun ctxt -&gt;
      step ?log ctxt step_constants body (Item (v, rest))
      &gt;&gt;=? fun (trans, ctxt) -&gt; step ?log ctxt step_constants descr trans
  | (Loop_left _, Item (R v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.loop_cycle)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (v, rest), ctxt)
  | (Dip b, Item (ign, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt;
      step ?log ctxt step_constants b rest
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (ign, res), ctxt)
  | (Exec, Item (arg, Item (lam, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.exec)
      &gt;&gt;=? fun ctxt -&gt;
      interp ?log ctxt step_constants lam arg
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (res, rest), ctxt)
  | (Apply capture_ty, Item (capture, Item (lam, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.apply)
      &gt;&gt;=? fun ctxt -&gt;
      let (Lam (descr, expr)) = lam in
      let (Item_t (full_arg_ty, _, _)) = descr.bef in
      unparse_data ctxt Optimized capture_ty capture
      &gt;&gt;=? fun (const_expr, ctxt) -&gt;
      unparse_ty ctxt capture_ty
      &gt;&gt;=? fun (ty_expr, ctxt) -&gt;
      match full_arg_ty with
      | Pair_t ((capture_ty, _, _), (arg_ty, _, _), _, _) -&gt;
          let arg_stack_ty = Item_t (arg_ty, Empty_t, None) in
          let const_descr =
            ( {
                loc = descr.loc;
                bef = arg_stack_ty;
                aft = Item_t (capture_ty, arg_stack_ty, None);
                instr = Const capture;
              }
              : (_, _) descr )
          in
          let pair_descr =
            ( {
                loc = descr.loc;
                bef = Item_t (capture_ty, arg_stack_ty, None);
                aft = Item_t (full_arg_ty, Empty_t, None);
                instr = Cons_pair;
              }
              : (_, _) descr )
          in
          let seq_descr =
            ( {
                loc = descr.loc;
                bef = arg_stack_ty;
                aft = Item_t (full_arg_ty, Empty_t, None);
                instr = Seq (const_descr, pair_descr);
              }
              : (_, _) descr )
          in
          let full_descr =
            ( {
                loc = descr.loc;
                bef = arg_stack_ty;
                aft = descr.aft;
                instr = Seq (seq_descr, descr);
              }
              : (_, _) descr )
          in
          let full_expr =
            Micheline.Seq
              ( 0,
                [ Prim (0, I_PUSH, [ty_expr; const_expr], []);
                  Prim (0, I_PAIR, [], []);
                  expr ] )
          in
          let lam' = Lam (full_descr, full_expr) in
          logged_return (Item (lam', rest), ctxt)
      | _ -&gt;
          <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> )
  | (Lambda lam, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (lam, rest), ctxt)
  | (Failwith tv, Item (v, _)) -&gt;
      trace <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_serialize_failure</abbr> (unparse_data ctxt Optimized tv v)
      &gt;&gt;=? fun (v, _ctxt) -&gt;
      let v = Micheline.strip_locations v in
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Reject (loc, v, get_log log))</abbr>
  | (Nop, stack) -&gt;
      logged_return (stack, ctxt)
  (* comparison *)
  | (Compare ty, Item (a, Item (b, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.compare ty a b))
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        ( Item
            ( Script_int.of_int
              @@ Script_ir_translator.compare_comparable ty a b,
              rest ),
          ctxt )
  (* comparators *)
  | (Eq, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres = 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Neq, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &lt;&gt; 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Lt, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &lt; 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Le, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &lt;= 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Gt, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &gt; 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Ge, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &gt;= 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  (* packing *)
  | (Pack t, Item (value, rest)) -&gt;
      Script_ir_translator.pack_data ctxt t value
      &gt;&gt;=? fun (bytes, ctxt) -&gt; logged_return (Item (bytes, rest), ctxt)
  | (Unpack t, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.check_enough ctxt (Script.serialized_cost bytes))
      &gt;&gt;=? fun () -&gt;
      if
        Compare.Int.(MBytes.length bytes &gt;= 1)
        &amp;&amp; Compare.Int.(MBytes.get_uint8 bytes 0 = 0x05)
      then
        let bytes = MBytes.sub bytes 1 (MBytes.length bytes - 1) in
        match Data_encoding.Binary.of_bytes Script.expr_encoding bytes with
        | None -&gt;
            Lwt.return (Gas.consume ctxt (Interp_costs.unpack_failed bytes))
            &gt;&gt;=? fun ctxt -&gt; logged_return (Item (None, rest), ctxt)
        | Some expr -&gt; (
            Lwt.return (Gas.consume ctxt (Script.deserialized_cost expr))
            &gt;&gt;=? fun ctxt -&gt;
            parse_data ctxt ~legacy:false t (Micheline.root expr)
            &gt;&gt;= function
            | Ok (value, ctxt) -&gt;
                logged_return (Item (Some value, rest), ctxt)
            | Error _ignored -&gt;
                Lwt.return
                  (Gas.consume ctxt (Interp_costs.unpack_failed bytes))
                &gt;&gt;=? fun ctxt -&gt; logged_return (Item (None, rest), ctxt) )
      else logged_return (Item (None, rest), ctxt)
  (* protocol *)
  | (Address, Item ((_, address), rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.address)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (address, rest), ctxt)
  | (Contract (t, entrypoint), Item (contract, rest)) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match (contract, entrypoint) with
      | ((contract, &quot;default&quot;), entrypoint)
      | ((contract, entrypoint), &quot;default&quot;) -&gt;
          Script_ir_translator.parse_contract_for_script
            ~legacy:false
            ctxt
            loc
            t
            contract
            ~entrypoint
          &gt;&gt;=? fun (ctxt, maybe_contract) -&gt;
          logged_return (Item (maybe_contract, rest), ctxt)
      | _ -&gt;
          logged_return (Item (None, rest), ctxt) )
  | ( Transfer_tokens,
      Item (p, Item (amount, Item ((tp, (destination, entrypoint)), rest))) )
    -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.transfer)
      &gt;&gt;=? fun ctxt -&gt;
      collect_big_maps ctxt tp p
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = no_big_map_id in
      extract_big_map_diff
        ctxt
        Optimized
        tp
        p
        ~to_duplicate
        ~to_update
        ~temporary:true
      &gt;&gt;=? fun (p, big_map_diff, ctxt) -&gt;
      unparse_data ctxt Optimized tp p
      &gt;&gt;=? fun (p, ctxt) -&gt;
      let operation =
        Transaction
          {
            amount;
            destination;
            entrypoint;
            parameters = Script.lazy_expr (Micheline.strip_locations p);
          }
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                big_map_diff ),
              rest ),
          ctxt )
  | ( Create_account,
      Item (manager, Item (delegate, Item (_delegatable, Item (credit, rest))))
    ) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_account)
      &gt;&gt;=? fun ctxt -&gt;
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      (* store in optimized binary representation - as unparsed with [Optimized]. *)
      let manager_bytes =
        Data_encoding.Binary.to_bytes_exn
          Signature.Public_key_hash.encoding
          manager
      in
      let storage =
        Script_repr.lazy_expr @@ Micheline.strip_locations
        @@ Micheline.Bytes (0, manager_bytes)
      in
      let script = {code = Legacy_support.manager_script_code; storage} in
      let operation =
        Origination {credit; delegate; preorigination = Some contract; script}
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                None ),
              Item ((contract, &quot;default&quot;), rest) ),
          ctxt )
  | (Implicit_account, Item (key, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.implicit_account)
      &gt;&gt;=? fun ctxt -&gt;
      let contract = Contract.implicit_contract key in
      logged_return (Item ((Unit_t None, (contract, &quot;default&quot;)), rest), ctxt)
  | ( Create_contract (storage_type, param_type, Lam (_, code), root_name),
      Item
        ( manager,
          Item
            ( delegate,
              Item
                ( spendable,
                  Item (delegatable, Item (credit, Item (init, rest))) ) ) ) )
    -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_contract)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_ty ctxt param_type
      &gt;&gt;=? fun (unparsed_param_type, ctxt) -&gt;
      let unparsed_param_type =
        Script_ir_translator.add_field_annot
          (Option.map ~f:(fun n -&gt; <abbr class="mark-error" title="Variants not supported">`Field_annot n</abbr>) root_name)
          None
          unparsed_param_type
      in
      unparse_ty ctxt storage_type
      &gt;&gt;=? fun (unparsed_storage_type, ctxt) -&gt;
      let code =
        Script.lazy_expr
        @@ Micheline.strip_locations
             (Seq
                ( 0,
                  [ Prim (0, K_parameter, [unparsed_param_type], []);
                    Prim (0, K_storage, [unparsed_storage_type], []);
                    Prim (0, K_code, [code], []) ] ))
      in
      collect_big_maps ctxt storage_type init
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = no_big_map_id in
      extract_big_map_diff
        ctxt
        Optimized
        storage_type
        init
        ~to_duplicate
        ~to_update
        ~temporary:true
      &gt;&gt;=? fun (init, big_map_diff, ctxt) -&gt;
      unparse_data ctxt Optimized storage_type init
      &gt;&gt;=? fun (storage, ctxt) -&gt;
      let storage = Script.lazy_expr @@ Micheline.strip_locations storage in
      ( if spendable then
        Legacy_support.add_do
          ~manager_pkh:manager
          ~script_code:code
          ~script_storage:storage
      else if delegatable then
        Legacy_support.add_set_delegate
          ~manager_pkh:manager
          ~script_code:code
          ~script_storage:storage
      else if Legacy_support.has_default_entrypoint code then
        Legacy_support.add_root_entrypoint code
        &gt;&gt;=? fun code -&gt; return (code, storage)
      else return (code, storage) )
      &gt;&gt;=? fun (code, storage) -&gt;
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      let operation =
        Origination
          {
            credit;
            delegate;
            preorigination = Some contract;
            script = {code; storage};
          }
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                big_map_diff ),
              Item ((contract, &quot;default&quot;), rest) ),
          ctxt )
  | ( Create_contract_2 (storage_type, param_type, Lam (_, code), root_name),
      (* Removed the instruction's arguments manager, spendable and delegatable *)
    Item (delegate, Item (credit, Item (init, rest))) ) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_contract)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_ty ctxt param_type
      &gt;&gt;=? fun (unparsed_param_type, ctxt) -&gt;
      let unparsed_param_type =
        Script_ir_translator.add_field_annot
          (Option.map ~f:(fun n -&gt; <abbr class="mark-error" title="Variants not supported">`Field_annot n</abbr>) root_name)
          None
          unparsed_param_type
      in
      unparse_ty ctxt storage_type
      &gt;&gt;=? fun (unparsed_storage_type, ctxt) -&gt;
      let code =
        Micheline.strip_locations
          (Seq
             ( 0,
               [ Prim (0, K_parameter, [unparsed_param_type], []);
                 Prim (0, K_storage, [unparsed_storage_type], []);
                 Prim (0, K_code, [code], []) ] ))
      in
      collect_big_maps ctxt storage_type init
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = no_big_map_id in
      extract_big_map_diff
        ctxt
        Optimized
        storage_type
        init
        ~to_duplicate
        ~to_update
        ~temporary:true
      &gt;&gt;=? fun (init, big_map_diff, ctxt) -&gt;
      unparse_data ctxt Optimized storage_type init
      &gt;&gt;=? fun (storage, ctxt) -&gt;
      let storage = Micheline.strip_locations storage in
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      let operation =
        Origination
          {
            credit;
            delegate;
            preorigination = Some contract;
            script =
              {
                code = Script.lazy_expr code;
                storage = Script.lazy_expr storage;
              };
          }
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                big_map_diff ),
              Item ((contract, &quot;default&quot;), rest) ),
          ctxt )
  | (Set_delegate, Item (delegate, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_account)
      &gt;&gt;=? fun ctxt -&gt;
      let operation = Delegation delegate in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                None ),
              rest ),
          ctxt )
  | (Balance, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.balance)
      &gt;&gt;=? fun ctxt -&gt;
      Contract.get_balance ctxt step_constants.self
      &gt;&gt;=? fun balance -&gt; logged_return (Item (balance, rest), ctxt)
  | (Now, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.now)
      &gt;&gt;=? fun ctxt -&gt;
      let now = Script_timestamp.now ctxt in
      logged_return (Item (now, rest), ctxt)
  | (Check_signature, Item (key, Item (signature, Item (message, rest)))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.check_signature key message))
      &gt;&gt;=? fun ctxt -&gt;
      let res = Signature.check key signature message in
      logged_return (Item (res, rest), ctxt)
  | (Hash_key, Item (key, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.hash_key)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item (Signature.Public_key.hash key, rest), ctxt)
  | (Blake2b, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.hash_blake2b bytes))
      &gt;&gt;=? fun ctxt -&gt;
      let hash = Raw_hashes.blake2b bytes in
      logged_return (Item (hash, rest), ctxt)
  | (Sha256, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.hash_sha256 bytes))
      &gt;&gt;=? fun ctxt -&gt;
      let hash = Raw_hashes.sha256 bytes in
      logged_return (Item (hash, rest), ctxt)
  | (Sha512, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.hash_sha512 bytes))
      &gt;&gt;=? fun ctxt -&gt;
      let hash = Raw_hashes.sha512 bytes in
      logged_return (Item (hash, rest), ctxt)
  | (Steps_to_quota, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.steps_to_quota)
      &gt;&gt;=? fun ctxt -&gt;
      let steps =
        match Gas.level ctxt with
        | Limited {remaining} -&gt;
            remaining
        | Unaccounted -&gt;
            Z.of_string &quot;99999999&quot;
      in
      logged_return (Item (Script_int.(abs (of_zint steps)), rest), ctxt)
  | (Source, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.source)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((step_constants.payer, &quot;default&quot;), rest), ctxt)
  | (Sender, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.source)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((step_constants.source, &quot;default&quot;), rest), ctxt)
  | (Self (t, entrypoint), rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.self)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((t, (step_constants.self, entrypoint)), rest), ctxt)
  | (Amount, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.amount)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (step_constants.amount, rest), ctxt)
  | (Dig (n, n'), stack) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      interp_stack_prefix_preserving_operation
        (fun (Item (v, rest)) -&gt; return (rest, v))
        n'
        stack
      &gt;&gt;=? fun (aft, x) -&gt; logged_return (Item (x, aft), ctxt)
  | (Dug (n, n'), Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      interp_stack_prefix_preserving_operation
        (fun stk -&gt; return (Item (v, stk), ()))
        n'
        rest
      &gt;&gt;=? fun (aft, ()) -&gt; logged_return (aft, ctxt)
  | (Dipn (n, n', b), stack) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      interp_stack_prefix_preserving_operation
        (fun stk -&gt;
          step ?log ctxt step_constants b stk
          &gt;&gt;=? fun (res, ctxt') -&gt; return (res, ctxt'))
        n'
        stack
      &gt;&gt;=? fun (aft, ctxt') -&gt; logged_return (aft, ctxt')
  | (Dropn (n, n'), stack) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      interp_stack_prefix_preserving_operation
        (fun stk -&gt; return (stk, stk))
        n'
        stack
      &gt;&gt;=? fun (_, rest) -&gt; logged_return (rest, ctxt)
  | (ChainId, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.chain_id)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item (step_constants.chain_id, rest), ctxt)

and interp :
    type p r.
    ?log:execution_trace ref -&gt;
    context -&gt;
    step_constants -&gt;
    (p, r) lambda -&gt;
    p -&gt;
    (r * context) tzresult Lwt.t =
 fun ?log ctxt step_constants (Lam (code, _)) arg -&gt;
  let stack = Item (arg, Empty) in
  ( match log with
  | None -&gt;
      return_unit
  | Some log -&gt;
      trace <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_serialize_log</abbr> (unparse_stack ctxt (stack, code.bef))
      &gt;&gt;=? fun stack -&gt;
      <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">log := (code.loc, Gas.level ctxt, stack) :: !log ;
      return_unit</abbr> )
  &gt;&gt;=? fun () -&gt;
  step ?log ctxt step_constants code stack
  &gt;&gt;=? fun (Item (ret, Empty), ctxt) -&gt; return (ret, ctxt)

(* ---- contract handling ---------------------------------------------------*)
and execute ?log ctxt mode step_constants ~entrypoint unparsed_script arg :
    ( Script.expr
    * packed_internal_operation list
    * context
    * Contract.big_map_diff option )
    tzresult
    Lwt.t =
  parse_script ctxt unparsed_script ~legacy:true
  &gt;&gt;=? fun (Ex_script {code; arg_type; storage; storage_type; root_name}, ctxt) -&gt;
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_contract_parameter step_constants.self)</abbr>
    (Lwt.return (find_entrypoint arg_type ~root_name entrypoint))
  &gt;&gt;=? fun (box, _) -&gt;
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_contract_parameter step_constants.self)</abbr>
    (parse_data ctxt ~legacy:false arg_type (box arg))
  &gt;&gt;=? fun (arg, ctxt) -&gt;
  Script.force_decode ctxt unparsed_script.code
  &gt;&gt;=? fun (script_code, ctxt) -&gt;
  Script_ir_translator.collect_big_maps ctxt arg_type arg
  &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
  Script_ir_translator.collect_big_maps ctxt storage_type storage
  &gt;&gt;=? fun (to_update, ctxt) -&gt;
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Runtime_contract_error (step_constants.self, script_code))</abbr>
    (interp ?log ctxt step_constants code (arg, storage))
  &gt;&gt;=? fun ((ops, storage), ctxt) -&gt;
  Script_ir_translator.extract_big_map_diff
    ctxt
    mode
    ~temporary:false
    ~to_duplicate
    ~to_update
    storage_type
    storage
  &gt;&gt;=? fun (storage, big_map_diff, ctxt) -&gt;
  trace <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_serialize_storage</abbr> (unparse_data ctxt mode storage_type storage)
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  let (ops, op_diffs) = List.split ops in
  let big_map_diff =
    match
      List.flatten
        (List.map (Option.unopt ~default:[]) (op_diffs @ [big_map_diff]))
    with
    | [] -&gt;
        None
    | diff -&gt;
        Some diff
  in
  return (Micheline.strip_locations storage, ops, ctxt, big_map_diff)

type execution_result = {
  ctxt : context;
  storage : Script.expr;
  big_map_diff : Contract.big_map_diff option;
  operations : packed_internal_operation list;
}

let trace ctxt mode step_constants ~script ~entrypoint ~parameter =
  let log = ref [] in
  execute
    ~log
    ctxt
    mode
    step_constants
    ~entrypoint
    script
    (Micheline.root parameter)
  &gt;&gt;=? fun (storage, operations, ctxt, big_map_diff) -&gt;
  let trace = List.rev !log in
  return ({ctxt; storage; big_map_diff; operations}, trace)

let execute ctxt mode step_constants ~script ~entrypoint ~parameter =
  execute
    ctxt
    mode
    step_constants
    ~entrypoint
    script
    (Micheline.root parameter)
  &gt;&gt;=? fun (storage, operations, ctxt, big_map_diff) -&gt;
  return {ctxt; storage; big_map_diff; operations}
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_interpreter.ml"><code>Script_interpreter.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Script_ir_annot.
Require Tezos.Script_ir_translator.
Require Tezos.Script_repr.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Script.

Import Script_typed_ir.

Import Script_ir_translator.

Definition execution_trace :=
  list
    (Alpha_context.Script.location * Alpha_context.Gas.t *
      list (Alpha_context.Script.expr * option string)).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Reserved Notation &quot;'stack&quot;.

Inductive stack_gadt : Set :=
| Item : forall {ty : Set}, ty -&gt; stack_gadt -&gt; stack_gadt
| Empty : stack_gadt

where &quot;'stack&quot; := (fun (tys : Set) =&gt; stack_gadt).

Definition stack := 'stack.

Definition unparse_stack {A : Set}
  (ctxt : Alpha_context.context)
  (function_parameter : stack A * Script_typed_ir.stack_ty A)
  : Lwt.t
    (Error_monad.tzresult (list (Alpha_context.Script.expr * option string))) :=
  let '(stack, stack_ty) := function_parameter in
  let ctxt := Alpha_context.Gas.set_unlimited ctxt in
  let fix unparse_stack {a : Set}
    (function_parameter : stack a * Script_typed_ir.stack_ty a)
    {struct function_parameter}
    : Lwt.t
      (Error_monad.tzresult (list (Alpha_context.Script.expr * option string))) :=
    match function_parameter with
    | (Empty, Script_typed_ir.Empty_t) =&gt; Error_monad.return_nil
    | (Item v rest, Script_typed_ir.Item_t ty rest_ty annot) =&gt;
      Error_monad.op_gtgteqquestion
        (Script_ir_translator.unparse_data ctxt Script_ir_translator.Readable ty
          v)
        (fun function_parameter =&gt;
          let '(data, _ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion (unparse_stack (rest, rest_ty))
            (fun rest =&gt;
              let annot :=
                match Script_ir_annot.unparse_var_annot annot with
                | [] =&gt; None
                | cons a [] =&gt; Some a
                | _ =&gt;
                  (* ‚ùå Assert instruction is not handled. *)
                  assert false
                end in
              let data := Micheline.strip_locations data in
              Error_monad.__return (cons (data, annot) rest)))
    end in
  unparse_stack (stack, stack_ty).

Module Interp_costs := Michelson_v1_gas.Cost_of.Interpreter.

Fixpoint interp_stack_prefix_preserving_operation
  {aft bef faft fbef result : Set}
  (f : stack fbef -&gt; Lwt.t (Error_monad.tzresult (stack faft * result)))
  (n : Script_typed_ir.stack_prefix_preservation_witness fbef faft bef aft)
  (stk : stack bef) {struct f}
  : Lwt.t (Error_monad.tzresult (stack aft * result)) :=
  match (n, stk) with
  |
    (Script_typed_ir.Prefix
      (Script_typed_ir.Prefix
        (Script_typed_ir.Prefix
          (Script_typed_ir.Prefix
            (Script_typed_ir.Prefix
              (Script_typed_ir.Prefix
                (Script_typed_ir.Prefix
                  (Script_typed_ir.Prefix
                    (Script_typed_ir.Prefix
                      (Script_typed_ir.Prefix
                        (Script_typed_ir.Prefix
                          (Script_typed_ir.Prefix
                            (Script_typed_ir.Prefix
                              (Script_typed_ir.Prefix
                                (Script_typed_ir.Prefix
                                  (Script_typed_ir.Prefix n))))))))))))))),
      Item v0
        (Item v1
          (Item v2
            (Item v3
              (Item v4
                (Item v5
                  (Item v6
                    (Item v7
                      (Item v8
                        (Item v9
                          (Item va
                            (Item vb
                              (Item vc (Item vd (Item ve (Item vf rest))))))))))))))))
    =&gt;
    Error_monad.op_gtgteqquestion
      (interp_stack_prefix_preserving_operation f n rest)
      (fun function_parameter =&gt;
        let '(rest', __result_value) := function_parameter in
        Error_monad.__return
          ((Item v0
            (Item v1
              (Item v2
                (Item v3
                  (Item v4
                    (Item v5
                      (Item v6
                        (Item v7
                          (Item v8
                            (Item v9
                              (Item va
                                (Item vb
                                  (Item vc (Item vd (Item ve (Item vf rest')))))))))))))))),
            __result_value))
  |
    (Script_typed_ir.Prefix
      (Script_typed_ir.Prefix
        (Script_typed_ir.Prefix (Script_typed_ir.Prefix n))),
      Item v0 (Item v1 (Item v2 (Item v3 rest)))) =&gt;
    Error_monad.op_gtgteqquestion
      (interp_stack_prefix_preserving_operation f n rest)
      (fun function_parameter =&gt;
        let '(rest', __result_value) := function_parameter in
        Error_monad.__return
          ((Item v0 (Item v1 (Item v2 (Item v3 rest')))), __result_value))
  | (Script_typed_ir.Prefix n, Item v rest) =&gt;
    Error_monad.op_gtgteqquestion
      (interp_stack_prefix_preserving_operation f n rest)
      (fun function_parameter =&gt;
        let '(rest', __result_value) := function_parameter in
        Error_monad.__return ((Item v rest'), __result_value))
  | (Script_typed_ir.Rest, v) =&gt; f v
  end.

Module step_constants.
  Record record := {
    source : Alpha_context.Contract.t;
    payer : Alpha_context.Contract.t;
    self : Alpha_context.Contract.t;
    amount : Alpha_context.Tez.t;
    chain_id : Chain_id.[S.HASH.t] }.
End step_constants.
Definition step_constants := step_constants.record.

Fixpoint step {a b : Set}
  (log : option (Pervasives.ref execution_trace)) (ctxt : Alpha_context.context)
  (step_constants : step_constants)
  (function_parameter : Script_typed_ir.descr b a) {struct log}
  : stack b -&gt; Lwt.t (Error_monad.tzresult (stack a * Alpha_context.context)) :=
  let
    '{|
      Script_typed_ir.descr.loc := loc;
        Script_typed_ir.descr.instr := instr
        |} as __descr_value := function_parameter in
  fun stack =&gt;
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.cycle))
      (fun ctxt =&gt;
        let logged_return
          (__descr_value : Script_typed_ir.descr b a)
          (function_parameter : stack a * Alpha_context.context)
          : Lwt.t (Error_monad.tzresult (stack a * Alpha_context.context)) :=
          let '(ret, ctxt) := function_parameter in
          match log with
          | None =&gt; Error_monad.__return (ret, ctxt)
          | Some log =&gt;
            Error_monad.op_gtgteqquestion
              (Error_monad.trace extensible_type_value
                (unparse_stack ctxt
                  (ret, (Script_typed_ir.descr.aft __descr_value))))
              (fun stack =&gt;
                (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
                (* ‚ùå instruction_sequence &quot;;&quot; *)
                Error_monad.__return (ret, ctxt))
          end in
        let get_log (log : option (Pervasives.ref execution_trace))
          : option
            (list
              (Alpha_context.Script.location * Alpha_context.Gas.t *
                list (Alpha_context.Script.expr * option string))) :=
          Option.map (fun l =&gt; List.rev (Pervasives.op_exclamation l)) log in
        let consume_gas_terop {C D E arg1 arg2 arg3 rest ret : Set}
          (__descr_value :
            Script_typed_ir.descr (C * (D * (E * rest))) (ret * rest))
          (function_parameter :
            (arg1 -&gt; arg2 -&gt; arg3 -&gt; ret) * arg1 * arg2 * arg3)
          : (arg1 -&gt; arg2 -&gt; arg3 -&gt; Alpha_context.Gas.cost) -&gt; stack rest -&gt;
          Lwt.t
            (Error_monad.tzresult (stack (ret * rest) * Alpha_context.context)) :=
          let '(op, x1, x2, x3) := function_parameter in
          fun cost_func =&gt;
            fun rest =&gt;
              Error_monad.op_gtgteqquestion
                (Lwt.__return
                  (Alpha_context.Gas.consume ctxt (cost_func x1 x2 x3)))
                (fun ctxt =&gt;
                  logged_return __descr_value ((Item (op x1 x2 x3) rest), ctxt))
          in
        let consume_gas_binop {C D arg1 arg2 rest ret : Set}
          (__descr_value : Script_typed_ir.descr (C * (D * rest)) (ret * rest))
          (function_parameter : (arg1 -&gt; arg2 -&gt; ret) * arg1 * arg2)
          : (arg1 -&gt; arg2 -&gt; Alpha_context.Gas.cost) -&gt; stack rest -&gt;
          Alpha_context.context -&gt;
          Lwt.t
            (Error_monad.tzresult (stack (ret * rest) * Alpha_context.context)) :=
          let '(op, x1, x2) := function_parameter in
          fun cost_func =&gt;
            fun rest =&gt;
              fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt (cost_func x1 x2)))
                  (fun ctxt =&gt;
                    logged_return __descr_value ((Item (op x1 x2) rest), ctxt))
          in
        let consume_gas_unop {C arg rest ret : Set}
          (__descr_value : Script_typed_ir.descr (C * rest) (ret * rest))
          (function_parameter : (arg -&gt; ret) * arg)
          : (arg -&gt; Alpha_context.Gas.cost) -&gt; stack rest -&gt;
          Alpha_context.context -&gt;
          Lwt.t
            (Error_monad.tzresult (stack (ret * rest) * Alpha_context.context)) :=
          let '(op, arg) := function_parameter in
          fun cost_func =&gt;
            fun rest =&gt;
              fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Lwt.__return (Alpha_context.Gas.consume ctxt (cost_func arg)))
                  (fun ctxt =&gt;
                    logged_return __descr_value ((Item (op arg) rest), ctxt)) in
        let logged_return := logged_return __descr_value in
        match (instr, stack) with
        | (Script_typed_ir.Drop, Item _ rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op))
            (fun ctxt =&gt; logged_return (rest, ctxt))
        | (Script_typed_ir.Dup, Item v rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op))
            (fun ctxt =&gt; logged_return ((Item v (Item v rest)), ctxt))
        | (Script_typed_ir.Swap, Item vi (Item vo rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op))
            (fun ctxt =&gt; logged_return ((Item vo (Item vi rest)), ctxt))
        | (Script_typed_ir.Const v, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push))
            (fun ctxt =&gt; logged_return ((Item v rest), ctxt))
        | (Script_typed_ir.Cons_some, Item v rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.wrap))
            (fun ctxt =&gt; logged_return ((Item (Some v) rest), ctxt))
        | (Script_typed_ir.Cons_none _, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.variant_no_data))
            (fun ctxt =&gt; logged_return ((Item None rest), ctxt))
        | (Script_typed_ir.If_none bt _, Item None rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt; step log ctxt step_constants bt rest)
        | (Script_typed_ir.If_none _ bf, Item (Some v) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt; step log ctxt step_constants bf (Item v rest))
        | (Script_typed_ir.Cons_pair, Item a (Item b rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.pair))
            (fun ctxt =&gt; logged_return ((Item (a, b) rest), ctxt))
        |
          (Script_typed_ir.Seq {|
            Script_typed_ir.descr.instr := Script_typed_ir.Dup |} {|
            Script_typed_ir.descr.instr :=
              Script_typed_ir.Seq {|
                Script_typed_ir.descr.instr := Script_typed_ir.Car
                  |} {|
                Script_typed_ir.descr.instr :=
                  Script_typed_ir.Seq {|
                    Script_typed_ir.descr.instr :=
                      Script_typed_ir.Dip
                        {|
                        Script_typed_ir.descr.instr
                          :=
                          Script_typed_ir.Cdr
                          |}
                      |}
                    {|
                    Script_typed_ir.descr.instr := Script_typed_ir.Nop
                      |}
                  |}
              |}, Item (a, b) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.pair_access))
            (fun ctxt =&gt; logged_return ((Item a (Item b rest)), ctxt))
        | (Script_typed_ir.Car, Item (a, _) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.pair_access))
            (fun ctxt =&gt; logged_return ((Item a rest), ctxt))
        | (Script_typed_ir.Cdr, Item (_, b) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.pair_access))
            (fun ctxt =&gt; logged_return ((Item b rest), ctxt))
        | (Script_typed_ir.Left, Item v rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.wrap))
            (fun ctxt =&gt; logged_return ((Item (Script_typed_ir.L v) rest), ctxt))
        | (Script_typed_ir.Right, Item v rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.wrap))
            (fun ctxt =&gt; logged_return ((Item (Script_typed_ir.R v) rest), ctxt))
        | (Script_typed_ir.If_left bt _, Item (Script_typed_ir.L v) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt; step log ctxt step_constants bt (Item v rest))
        | (Script_typed_ir.If_left _ bf, Item (Script_typed_ir.R v) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt; step log ctxt step_constants bf (Item v rest))
        | (Script_typed_ir.Cons_list, Item hd (Item tl rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.cons))
            (fun ctxt =&gt; logged_return ((Item (cons hd tl) rest), ctxt))
        | (Script_typed_ir.Nil, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.variant_no_data))
            (fun ctxt =&gt; logged_return ((Item [] rest), ctxt))
        | (Script_typed_ir.If_cons _ bf, Item [] rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt; step log ctxt step_constants bf rest)
        | (Script_typed_ir.If_cons bt _, Item (cons hd tl) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt;
              step log ctxt step_constants bt (Item hd (Item tl rest)))
        | (Script_typed_ir.List_map body, Item l rest) =&gt;
          let fix loop
            (rest : stack op_dollar49) (ctxt : Alpha_context.context)
            (l : list op_dollar48) (acc : list op_dollar50) {struct rest}
            : Lwt.t
              (Error_monad.tzresult
                (stack (list op_dollar50 * op_dollar49) * Alpha_context.context)) :=
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Interp_costs.loop_map))
              (fun ctxt =&gt;
                match l with
                | [] =&gt; Error_monad.__return ((Item (List.rev acc) rest), ctxt)
                | cons hd tl =&gt;
                  Error_monad.op_gtgteqquestion
                    (step log ctxt step_constants body (Item hd rest))
                    (fun function_parameter =&gt;
                      let '(Item hd rest, ctxt) := function_parameter in
                      loop rest ctxt tl (cons hd acc))
                end) in
          Error_monad.op_gtgteqquestion (loop rest ctxt l [])
            (fun function_parameter =&gt;
              let '(res, ctxt) := function_parameter in
              logged_return (res, ctxt))
        | (Script_typed_ir.List_size, Item __list_value rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (List.fold_left
                (fun acc =&gt;
                  fun function_parameter =&gt;
                    let '_ := function_parameter in
                    Error_monad.op_gtgtquestion acc
                      (fun function_parameter =&gt;
                        let '(size, ctxt) := function_parameter in
                        Error_monad.op_gtgtquestion
                          (Alpha_context.Gas.consume ctxt Interp_costs.loop_size)
                          (fun ctxt =&gt;
                            Error_monad.ok ((Pervasives.op_plus size 1), ctxt))))
                (Error_monad.ok (0, ctxt)) __list_value))
            (fun function_parameter =&gt;
              let '(len, ctxt) := function_parameter in
              logged_return
                ((Item
                  (Alpha_context.Script_int.abs
                    (Alpha_context.Script_int.of_int len)) rest), ctxt))
        | (Script_typed_ir.List_iter body, Item l init) =&gt;
          let fix loop
            (ctxt : Alpha_context.context) (l : list op_dollar53)
            (stack : stack op_dollar54) {struct ctxt}
            : Lwt.t
              (Error_monad.tzresult (stack op_dollar54 * Alpha_context.context)) :=
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Interp_costs.loop_iter))
              (fun ctxt =&gt;
                match l with
                | [] =&gt; Error_monad.__return (stack, ctxt)
                | cons hd tl =&gt;
                  Error_monad.op_gtgteqquestion
                    (step log ctxt step_constants body (Item hd stack))
                    (fun function_parameter =&gt;
                      let '(stack, ctxt) := function_parameter in
                      loop ctxt tl stack)
                end) in
          Error_monad.op_gtgteqquestion (loop ctxt l init)
            (fun function_parameter =&gt;
              let '(res, ctxt) := function_parameter in
              logged_return (res, ctxt))
        | (Script_typed_ir.Empty_set t, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.empty_set))
            (fun ctxt =&gt;
              logged_return
                ((Item (Script_ir_translator.empty_set t) rest), ctxt))
        | (Script_typed_ir.Set_iter body, Item set init) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.set_to_list set)))
            (fun ctxt =&gt;
              let l :=
                List.rev
                  (Script_ir_translator.set_fold
                    (fun e =&gt; fun acc =&gt; cons e acc) set []) in
              let fix loop
                (ctxt : Alpha_context.context) (l : list op_dollar56)
                (stack : stack op_dollar57) {struct ctxt}
                : Lwt.t
                  (Error_monad.tzresult
                    (stack op_dollar57 * Alpha_context.context)) :=
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Interp_costs.loop_iter))
                  (fun ctxt =&gt;
                    match l with
                    | [] =&gt; Error_monad.__return (stack, ctxt)
                    | cons hd tl =&gt;
                      Error_monad.op_gtgteqquestion
                        (step log ctxt step_constants body (Item hd stack))
                        (fun function_parameter =&gt;
                          let '(stack, ctxt) := function_parameter in
                          loop ctxt tl stack)
                    end) in
              Error_monad.op_gtgteqquestion (loop ctxt l init)
                (fun function_parameter =&gt;
                  let '(res, ctxt) := function_parameter in
                  logged_return (res, ctxt)))
        | (Script_typed_ir.Set_mem, Item v (Item set rest)) =&gt;
          consume_gas_binop __descr_value (Script_ir_translator.set_mem, v, set)
            Interp_costs.set_mem rest ctxt
        | (Script_typed_ir.Set_update, Item v (Item presence (Item set rest)))
          =&gt;
          consume_gas_terop __descr_value
            (Script_ir_translator.set_update, v, presence, set)
            Interp_costs.set_update rest
        | (Script_typed_ir.Set_size, Item set rest) =&gt;
          consume_gas_unop __descr_value (Script_ir_translator.set_size, set)
            (fun function_parameter =&gt;
              let '_ := function_parameter in
              Interp_costs.set_size) rest ctxt
        | (Script_typed_ir.Empty_map t _, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.empty_map))
            (fun ctxt =&gt;
              logged_return
                ((Item (Script_ir_translator.empty_map t) rest), ctxt))
        | (Script_typed_ir.Map_map body, Item map rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.map_to_list map)))
            (fun ctxt =&gt;
              let l :=
                List.rev
                  (Script_ir_translator.map_fold
                    (fun k =&gt; fun v =&gt; fun acc =&gt; cons (k, v) acc) map []) in
              let fix loop
                (rest : stack op_dollar68) (ctxt : Alpha_context.context)
                (l : list (op_dollar66 * op_dollar67))
                (acc : Script_typed_ir.map op_dollar66 op_dollar69)
                {struct rest}
                : Lwt.t
                  (Error_monad.tzresult
                    (Script_typed_ir.map op_dollar66 op_dollar69 *
                      Alpha_context.context)) :=
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Interp_costs.loop_map))
                  (fun ctxt =&gt;
                    match l with
                    | [] =&gt; Error_monad.__return (acc, ctxt)
                    | cons ((k, _) as hd) tl =&gt;
                      Error_monad.op_gtgteqquestion
                        (step log ctxt step_constants body (Item hd rest))
                        (fun function_parameter =&gt;
                          let '(Item hd rest, ctxt) := function_parameter in
                          loop rest ctxt tl
                            (Script_ir_translator.map_update k (Some hd) acc))
                    end) in
              Error_monad.op_gtgteqquestion
                (loop rest ctxt l
                  (Script_ir_translator.empty_map
                    (Script_ir_translator.map_key_ty map)))
                (fun function_parameter =&gt;
                  let '(res, ctxt) := function_parameter in
                  logged_return ((Item res rest), ctxt)))
        | (Script_typed_ir.Map_iter body, Item map init) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.map_to_list map)))
            (fun ctxt =&gt;
              let l :=
                List.rev
                  (Script_ir_translator.map_fold
                    (fun k =&gt; fun v =&gt; fun acc =&gt; cons (k, v) acc) map []) in
              let fix loop
                (ctxt : Alpha_context.context)
                (l : list (op_dollar70 * op_dollar71))
                (stack : stack op_dollar72) {struct ctxt}
                : Lwt.t
                  (Error_monad.tzresult
                    (stack op_dollar72 * Alpha_context.context)) :=
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Interp_costs.loop_iter))
                  (fun ctxt =&gt;
                    match l with
                    | [] =&gt; Error_monad.__return (stack, ctxt)
                    | cons hd tl =&gt;
                      Error_monad.op_gtgteqquestion
                        (step log ctxt step_constants body (Item hd stack))
                        (fun function_parameter =&gt;
                          let '(stack, ctxt) := function_parameter in
                          loop ctxt tl stack)
                    end) in
              Error_monad.op_gtgteqquestion (loop ctxt l init)
                (fun function_parameter =&gt;
                  let '(res, ctxt) := function_parameter in
                  logged_return (res, ctxt)))
        | (Script_typed_ir.Map_mem, Item v (Item map rest)) =&gt;
          consume_gas_binop __descr_value (Script_ir_translator.map_mem, v, map)
            Interp_costs.map_mem rest ctxt
        | (Script_typed_ir.Map_get, Item v (Item map rest)) =&gt;
          consume_gas_binop __descr_value (Script_ir_translator.map_get, v, map)
            Interp_costs.map_get rest ctxt
        | (Script_typed_ir.Map_update, Item k (Item v (Item map rest))) =&gt;
          consume_gas_terop __descr_value
            (Script_ir_translator.map_update, k, v, map) Interp_costs.map_update
            rest
        | (Script_typed_ir.Map_size, Item map rest) =&gt;
          consume_gas_unop __descr_value (Script_ir_translator.map_size, map)
            (fun function_parameter =&gt;
              let '_ := function_parameter in
              Interp_costs.map_size) rest ctxt
        | (Script_typed_ir.Empty_big_map tk tv, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.empty_map))
            (fun ctxt =&gt;
              logged_return
                ((Item (Script_ir_translator.empty_big_map tk tv) rest), ctxt))
        | (Script_typed_ir.Big_map_mem, Item key (Item map rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.map_mem key (Script_typed_ir.big_map.diff map))))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Script_ir_translator.big_map_mem ctxt key map)
                (fun function_parameter =&gt;
                  let '(res, ctxt) := function_parameter in
                  logged_return ((Item res rest), ctxt)))
        | (Script_typed_ir.Big_map_get, Item key (Item map rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.map_get key (Script_typed_ir.big_map.diff map))))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Script_ir_translator.big_map_get ctxt key map)
                (fun function_parameter =&gt;
                  let '(res, ctxt) := function_parameter in
                  logged_return ((Item res rest), ctxt)))
        |
          (Script_typed_ir.Big_map_update,
            Item key (Item maybe_value (Item map rest))) =&gt;
          consume_gas_terop __descr_value
            (Script_ir_translator.big_map_update, key, maybe_value, map)
            (fun k =&gt;
              fun v =&gt;
                fun m =&gt;
                  Interp_costs.map_update k (Some v)
                    (Script_typed_ir.big_map.diff m)) rest
        | (Script_typed_ir.Add_seconds_to_timestamp, Item n (Item t rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_timestamp.add_delta, t, n)
            Interp_costs.add_timestamp rest ctxt
        | (Script_typed_ir.Add_timestamp_to_seconds, Item t (Item n rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_timestamp.add_delta, t, n)
            Interp_costs.add_timestamp rest ctxt
        | (Script_typed_ir.Sub_timestamp_seconds, Item t (Item s rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_timestamp.sub_delta, t, s)
            Interp_costs.sub_timestamp rest ctxt
        | (Script_typed_ir.Diff_timestamps, Item t1 (Item t2 rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_timestamp.diff, t1, t2)
            Interp_costs.diff_timestamps rest ctxt
        | (Script_typed_ir.Concat_string_pair, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.concat_string (cons x (cons y [])))))
            (fun ctxt =&gt;
              let s := String.concat &quot;&quot; % string (cons x (cons y [])) in
              logged_return ((Item s rest), ctxt))
        | (Script_typed_ir.Concat_string, Item ss rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.concat_string ss)))
            (fun ctxt =&gt;
              let s := String.concat &quot;&quot; % string ss in
              logged_return ((Item s rest), ctxt))
        |
          (Script_typed_ir.Slice_string, Item offset (Item length (Item s rest)))
          =&gt;
          let s_length := Z.of_int (String.length s) in
          let offset := Alpha_context.Script_int.to_zint offset in
          let length := Alpha_context.Script_int.to_zint length in
          if
            Pervasives.op_andand (Compare.Z.[Compare.S.op_lt] offset s_length)
              (Compare.Z.[Compare.S.op_lteq] (Z.add offset length) s_length)
            then
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt
                  (Interp_costs.slice_string (Z.to_int length))))
              (fun ctxt =&gt;
                logged_return
                  ((Item
                    (Some (String.sub s (Z.to_int offset) (Z.to_int length)))
                    rest), ctxt))
          else
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt (Interp_costs.slice_string 0)))
              (fun ctxt =&gt; logged_return ((Item None rest), ctxt))
        | (Script_typed_ir.String_size, Item s rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push))
            (fun ctxt =&gt;
              logged_return
                ((Item
                  (Alpha_context.Script_int.abs
                    (Alpha_context.Script_int.of_int (String.length s))) rest),
                  ctxt))
        | (Script_typed_ir.Concat_bytes_pair, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.concat_bytes (cons x (cons y [])))))
            (fun ctxt =&gt;
              let s := MBytes.concat &quot;&quot; % string (cons x (cons y [])) in
              logged_return ((Item s rest), ctxt))
        | (Script_typed_ir.Concat_bytes, Item ss rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.concat_bytes ss)))
            (fun ctxt =&gt;
              let s := MBytes.concat &quot;&quot; % string ss in
              logged_return ((Item s rest), ctxt))
        | (Script_typed_ir.Slice_bytes, Item offset (Item length (Item s rest)))
          =&gt;
          let s_length := Z.of_int (MBytes.length s) in
          let offset := Alpha_context.Script_int.to_zint offset in
          let length := Alpha_context.Script_int.to_zint length in
          if
            Pervasives.op_andand (Compare.Z.[Compare.S.op_lt] offset s_length)
              (Compare.Z.[Compare.S.op_lteq] (Z.add offset length) s_length)
            then
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt
                  (Interp_costs.slice_string (Z.to_int length))))
              (fun ctxt =&gt;
                logged_return
                  ((Item
                    (Some (MBytes.sub s (Z.to_int offset) (Z.to_int length)))
                    rest), ctxt))
          else
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt (Interp_costs.slice_string 0)))
              (fun ctxt =&gt; logged_return ((Item None rest), ctxt))
        | (Script_typed_ir.Bytes_size, Item s rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push))
            (fun ctxt =&gt;
              logged_return
                ((Item
                  (Alpha_context.Script_int.abs
                    (Alpha_context.Script_int.of_int (MBytes.length s))) rest),
                  ctxt))
        | (Script_typed_ir.Add_tez, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Lwt.__return (Alpha_context.Tez.op_plusquestion x y))
                (fun res =&gt; logged_return ((Item res rest), ctxt)))
        | (Script_typed_ir.Sub_tez, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Lwt.__return (Alpha_context.Tez.op_minusquestion x y))
                (fun res =&gt; logged_return ((Item res rest), ctxt)))
        | (Script_typed_ir.Mul_teznat, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Lwt.__return
                  (Alpha_context.Gas.consume ctxt Interp_costs.z_to_int64))
                (fun ctxt =&gt;
                  match Alpha_context.Script_int.to_int64 y with
                  | None =&gt; Error_monad.fail extensible_type_value
                  | Some y =&gt;
                    Error_monad.op_gtgteqquestion
                      (Lwt.__return (Alpha_context.Tez.op_starquestion x y))
                      (fun res =&gt; logged_return ((Item res rest), ctxt))
                  end))
        | (Script_typed_ir.Mul_nattez, Item y (Item x rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Lwt.__return
                  (Alpha_context.Gas.consume ctxt Interp_costs.z_to_int64))
                (fun ctxt =&gt;
                  match Alpha_context.Script_int.to_int64 y with
                  | None =&gt; Error_monad.fail extensible_type_value
                  | Some y =&gt;
                    Error_monad.op_gtgteqquestion
                      (Lwt.__return (Alpha_context.Tez.op_starquestion x y))
                      (fun res =&gt; logged_return ((Item res rest), ctxt))
                  end))
        | (Script_typed_ir.Or, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Pervasives.op_pipepipe, x, y)
            Interp_costs.bool_binop rest ctxt
        | (Script_typed_ir.And, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Pervasives.op_andand, x, y)
            Interp_costs.bool_binop rest ctxt
        | (Script_typed_ir.Xor, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value
            (Compare.Bool.[Compare.S.op_ltgt], x, y) Interp_costs.bool_binop
            rest ctxt
        | (Script_typed_ir.Not, Item x rest) =&gt;
          consume_gas_unop __descr_value (Pervasives.not, x)
            Interp_costs.bool_unop rest ctxt
        | (Script_typed_ir.Is_nat, Item x rest) =&gt;
          consume_gas_unop __descr_value (Alpha_context.Script_int.is_nat, x)
            Interp_costs.abs rest ctxt
        | (Script_typed_ir.Abs_int, Item x rest) =&gt;
          consume_gas_unop __descr_value (Alpha_context.Script_int.abs, x)
            Interp_costs.abs rest ctxt
        | (Script_typed_ir.Int_nat, Item x rest) =&gt;
          consume_gas_unop __descr_value (Alpha_context.Script_int.int, x)
            Interp_costs.int rest ctxt
        | (Script_typed_ir.Neg_int, Item x rest) =&gt;
          consume_gas_unop __descr_value (Alpha_context.Script_int.neg, x)
            Interp_costs.neg rest ctxt
        | (Script_typed_ir.Neg_nat, Item x rest) =&gt;
          consume_gas_unop __descr_value (Alpha_context.Script_int.neg, x)
            Interp_costs.neg rest ctxt
        | (Script_typed_ir.Add_intint, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.add, x, y)
            Interp_costs.add rest ctxt
        | (Script_typed_ir.Add_intnat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.add, x, y)
            Interp_costs.add rest ctxt
        | (Script_typed_ir.Add_natint, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.add, x, y)
            Interp_costs.add rest ctxt
        | (Script_typed_ir.Add_natnat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.add_n, x, y)
            Interp_costs.add rest ctxt
        | (Script_typed_ir.Sub_int, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.sub, x, y)
            Interp_costs.sub rest ctxt
        | (Script_typed_ir.Mul_intint, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.mul, x, y)
            Interp_costs.mul rest ctxt
        | (Script_typed_ir.Mul_intnat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.mul, x, y)
            Interp_costs.mul rest ctxt
        | (Script_typed_ir.Mul_natint, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.mul, x, y)
            Interp_costs.mul rest ctxt
        | (Script_typed_ir.Mul_natnat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.mul_n, x, y)
            Interp_costs.mul rest ctxt
        | (Script_typed_ir.Ediv_teznat, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.int64_to_z))
            (fun ctxt =&gt;
              let x :=
                Alpha_context.Script_int.of_int64 (Alpha_context.Tez.to_mutez x)
                in
              consume_gas_binop __descr_value
                ((fun x =&gt;
                  fun y =&gt;
                    match Alpha_context.Script_int.ediv x y with
                    | None =&gt; None
                    | Some (q, r) =&gt;
                      match
                        ((Alpha_context.Script_int.to_int64 q),
                          (Alpha_context.Script_int.to_int64 r)) with
                      | (Some q, Some r) =&gt;
                        match
                          ((Alpha_context.Tez.of_mutez q),
                            (Alpha_context.Tez.of_mutez r)) with
                        | (Some q, Some r) =&gt; Some (q, r)
                        | _ =&gt;
                          (* ‚ùå Assert instruction is not handled. *)
                          assert false
                        end
                      | _ =&gt;
                        (* ‚ùå Assert instruction is not handled. *)
                        assert false
                      end
                    end), x, y) Interp_costs.div rest ctxt)
        | (Script_typed_ir.Ediv_tez, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.int64_to_z))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Lwt.__return
                  (Alpha_context.Gas.consume ctxt Interp_costs.int64_to_z))
                (fun ctxt =&gt;
                  let x :=
                    Alpha_context.Script_int.abs
                      (Alpha_context.Script_int.of_int64
                        (Alpha_context.Tez.to_mutez x)) in
                  let y :=
                    Alpha_context.Script_int.abs
                      (Alpha_context.Script_int.of_int64
                        (Alpha_context.Tez.to_mutez y)) in
                  consume_gas_binop __descr_value
                    ((fun x =&gt;
                      fun y =&gt;
                        match Alpha_context.Script_int.ediv_n x y with
                        | None =&gt; None
                        | Some (q, r) =&gt;
                          match Alpha_context.Script_int.to_int64 r with
                          | None =&gt;
                            (* ‚ùå Assert instruction is not handled. *)
                            assert false
                          | Some r =&gt;
                            match Alpha_context.Tez.of_mutez r with
                            | None =&gt;
                              (* ‚ùå Assert instruction is not handled. *)
                              assert false
                            | Some r =&gt; Some (q, r)
                            end
                          end
                        end), x, y) Interp_costs.div rest ctxt))
        | (Script_typed_ir.Ediv_intint, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.ediv, x, y)
            Interp_costs.div rest ctxt
        | (Script_typed_ir.Ediv_intnat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.ediv, x, y)
            Interp_costs.div rest ctxt
        | (Script_typed_ir.Ediv_natint, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.ediv, x, y)
            Interp_costs.div rest ctxt
        | (Script_typed_ir.Ediv_natnat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_int.ediv_n, x, y) Interp_costs.div rest ctxt
        | (Script_typed_ir.Lsl_nat, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.shift_left x y)))
            (fun ctxt =&gt;
              match Alpha_context.Script_int.shift_left_n x y with
              | None =&gt; Error_monad.fail extensible_type_value
              | Some x =&gt; logged_return ((Item x rest), ctxt)
              end)
        | (Script_typed_ir.Lsr_nat, Item x (Item y rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.shift_right x y)))
            (fun ctxt =&gt;
              match Alpha_context.Script_int.shift_right_n x y with
              | None =&gt; Error_monad.fail extensible_type_value
              | Some r =&gt; logged_return ((Item r rest), ctxt)
              end)
        | (Script_typed_ir.Or_nat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value (Alpha_context.Script_int.logor, x, y)
            Interp_costs.logor rest ctxt
        | (Script_typed_ir.And_nat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_int.logand, x, y) Interp_costs.logand rest
            ctxt
        | (Script_typed_ir.And_int_nat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_int.logand, x, y) Interp_costs.logand rest
            ctxt
        | (Script_typed_ir.Xor_nat, Item x (Item y rest)) =&gt;
          consume_gas_binop __descr_value
            (Alpha_context.Script_int.logxor, x, y) Interp_costs.logxor rest
            ctxt
        | (Script_typed_ir.Not_int, Item x rest) =&gt;
          consume_gas_unop __descr_value (Alpha_context.Script_int.lognot, x)
            Interp_costs.lognot rest ctxt
        | (Script_typed_ir.Not_nat, Item x rest) =&gt;
          consume_gas_unop __descr_value (Alpha_context.Script_int.lognot, x)
            Interp_costs.lognot rest ctxt
        | (Script_typed_ir.Seq hd tl, stack) =&gt;
          Error_monad.op_gtgteqquestion (step log ctxt step_constants hd stack)
            (fun function_parameter =&gt;
              let '(trans, ctxt) := function_parameter in
              step log ctxt step_constants tl trans)
        | (Script_typed_ir.If bt _, Item true rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt; step log ctxt step_constants bt rest)
        | (Script_typed_ir.If _ bf, Item false rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch))
            (fun ctxt =&gt; step log ctxt step_constants bf rest)
        | (Script_typed_ir.Loop body, Item true rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.loop_cycle))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (step log ctxt step_constants body rest)
                (fun function_parameter =&gt;
                  let '(trans, ctxt) := function_parameter in
                  step log ctxt step_constants __descr_value trans))
        | (Script_typed_ir.Loop _, Item false rest) =&gt;
          logged_return (rest, ctxt)
        | (Script_typed_ir.Loop_left body, Item (Script_typed_ir.L v) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.loop_cycle))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (step log ctxt step_constants body (Item v rest))
                (fun function_parameter =&gt;
                  let '(trans, ctxt) := function_parameter in
                  step log ctxt step_constants __descr_value trans))
        | (Script_typed_ir.Loop_left _, Item (Script_typed_ir.R v) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.loop_cycle))
            (fun ctxt =&gt; logged_return ((Item v rest), ctxt))
        | (Script_typed_ir.Dip b, Item ign rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (step log ctxt step_constants b rest)
                (fun function_parameter =&gt;
                  let '(res, ctxt) := function_parameter in
                  logged_return ((Item ign res), ctxt)))
        | (Script_typed_ir.Exec, Item arg (Item lam rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.exec))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (interp log ctxt step_constants lam arg)
                (fun function_parameter =&gt;
                  let '(res, ctxt) := function_parameter in
                  logged_return ((Item res rest), ctxt)))
        | (Script_typed_ir.Apply capture_ty, Item capture (Item lam rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.apply))
            (fun ctxt =&gt;
              let 'Script_typed_ir.Lam __descr_value expr := lam in
              let 'Script_typed_ir.Item_t full_arg_ty _ _ :=
                Script_typed_ir.descr.bef __descr_value in
              Error_monad.op_gtgteqquestion
                (Script_ir_translator.unparse_data ctxt
                  Script_ir_translator.Optimized capture_ty capture)
                (fun function_parameter =&gt;
                  let '(const_expr, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Script_ir_translator.unparse_ty ctxt capture_ty)
                    (fun function_parameter =&gt;
                      let '(ty_expr, ctxt) := function_parameter in
                      match full_arg_ty with
                      |
                        Script_typed_ir.Pair_t (capture_ty, _, _) (arg_ty, _, _)
                          _ _ =&gt;
                        let arg_stack_ty :=
                          Script_typed_ir.Item_t arg_ty Script_typed_ir.Empty_t
                            None in
                        let const_descr :=
                          {|
                            Script_typed_ir.descr.loc :=
                              Script_typed_ir.descr.loc __descr_value;
                            Script_typed_ir.descr.bef := arg_stack_ty;
                            Script_typed_ir.descr.aft :=
                              Script_typed_ir.Item_t capture_ty arg_stack_ty
                                None;
                            Script_typed_ir.descr.instr :=
                              Script_typed_ir.Const capture |} in
                        let pair_descr :=
                          {|
                            Script_typed_ir.descr.loc :=
                              Script_typed_ir.descr.loc __descr_value;
                            Script_typed_ir.descr.bef :=
                              Script_typed_ir.Item_t capture_ty arg_stack_ty
                                None;
                            Script_typed_ir.descr.aft :=
                              Script_typed_ir.Item_t full_arg_ty
                                Script_typed_ir.Empty_t None;
                            Script_typed_ir.descr.instr :=
                              Script_typed_ir.Cons_pair |} in
                        let seq_descr :=
                          {|
                            Script_typed_ir.descr.loc :=
                              Script_typed_ir.descr.loc __descr_value;
                            Script_typed_ir.descr.bef := arg_stack_ty;
                            Script_typed_ir.descr.aft :=
                              Script_typed_ir.Item_t full_arg_ty
                                Script_typed_ir.Empty_t None;
                            Script_typed_ir.descr.instr :=
                              Script_typed_ir.Seq const_descr pair_descr |} in
                        let full_descr :=
                          {|
                            Script_typed_ir.descr.loc :=
                              Script_typed_ir.descr.loc __descr_value;
                            Script_typed_ir.descr.bef := arg_stack_ty;
                            Script_typed_ir.descr.aft :=
                              Script_typed_ir.descr.aft __descr_value;
                            Script_typed_ir.descr.instr :=
                              Script_typed_ir.Seq seq_descr __descr_value |} in
                        let full_expr :=
                          Micheline.Seq 0
                            (cons
                              (Micheline.Prim 0 Alpha_context.Script.I_PUSH
                                (cons ty_expr (cons const_expr [])) [])
                              (cons
                                (Micheline.Prim 0 Alpha_context.Script.I_PAIR []
                                  []) (cons expr []))) in
                        let lam' := Script_typed_ir.Lam full_descr full_expr in
                        logged_return ((Item lam' rest), ctxt)
                      | _ =&gt;
                        (* ‚ùå Assert instruction is not handled. *)
                        assert false
                      end)))
        | (Script_typed_ir.Lambda lam, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push))
            (fun ctxt =&gt; logged_return ((Item lam rest), ctxt))
        | (Script_typed_ir.Failwith tv, Item v _) =&gt;
          Error_monad.op_gtgteqquestion
            (Error_monad.trace extensible_type_value
              (Script_ir_translator.unparse_data ctxt
                Script_ir_translator.Optimized tv v))
            (fun function_parameter =&gt;
              let '(v, _ctxt) := function_parameter in
              let v := Micheline.strip_locations v in
              Error_monad.fail extensible_type_value)
        | (Script_typed_ir.Nop, stack) =&gt; logged_return (stack, ctxt)
        | (Script_typed_ir.Compare ty, Item a (Item b rest)) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.compare ty a b)))
            (fun ctxt =&gt;
              logged_return
                ((Item
                  (Pervasives.op_atat Alpha_context.Script_int.of_int
                    (Script_ir_translator.compare_comparable ty a b)) rest),
                  ctxt))
        | (Script_typed_ir.Eq, Item cmpres rest) =&gt;
          let cmpres :=
            Alpha_context.Script_int.compare cmpres
              Alpha_context.Script_int.zero in
          let cmpres := Compare.Int.[Compare.S.op_eq] cmpres 0 in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.compare_res))
            (fun ctxt =&gt; logged_return ((Item cmpres rest), ctxt))
        | (Script_typed_ir.Neq, Item cmpres rest) =&gt;
          let cmpres :=
            Alpha_context.Script_int.compare cmpres
              Alpha_context.Script_int.zero in
          let cmpres := Compare.Int.[Compare.S.op_ltgt] cmpres 0 in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.compare_res))
            (fun ctxt =&gt; logged_return ((Item cmpres rest), ctxt))
        | (Script_typed_ir.Lt, Item cmpres rest) =&gt;
          let cmpres :=
            Alpha_context.Script_int.compare cmpres
              Alpha_context.Script_int.zero in
          let cmpres := Compare.Int.[Compare.S.op_lt] cmpres 0 in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.compare_res))
            (fun ctxt =&gt; logged_return ((Item cmpres rest), ctxt))
        | (Script_typed_ir.Le, Item cmpres rest) =&gt;
          let cmpres :=
            Alpha_context.Script_int.compare cmpres
              Alpha_context.Script_int.zero in
          let cmpres := Compare.Int.[Compare.S.op_lteq] cmpres 0 in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.compare_res))
            (fun ctxt =&gt; logged_return ((Item cmpres rest), ctxt))
        | (Script_typed_ir.Gt, Item cmpres rest) =&gt;
          let cmpres :=
            Alpha_context.Script_int.compare cmpres
              Alpha_context.Script_int.zero in
          let cmpres := Compare.Int.[Compare.S.op_gt] cmpres 0 in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.compare_res))
            (fun ctxt =&gt; logged_return ((Item cmpres rest), ctxt))
        | (Script_typed_ir.Ge, Item cmpres rest) =&gt;
          let cmpres :=
            Alpha_context.Script_int.compare cmpres
              Alpha_context.Script_int.zero in
          let cmpres := Compare.Int.[Compare.S.op_gteq] cmpres 0 in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.compare_res))
            (fun ctxt =&gt; logged_return ((Item cmpres rest), ctxt))
        | (Script_typed_ir.Pack t, Item value rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Script_ir_translator.pack_data ctxt t value)
            (fun function_parameter =&gt;
              let '(__bytes_value, ctxt) := function_parameter in
              logged_return ((Item __bytes_value rest), ctxt))
        | (Script_typed_ir.Unpack t, Item __bytes_value rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.check_enough ctxt
                (Alpha_context.Script.serialized_cost __bytes_value)))
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              if
                Pervasives.op_andand
                  (Compare.Int.[Compare.S.op_gteq] (MBytes.length __bytes_value)
                    1)
                  (Compare.Int.[Compare.S.op_eq]
                    (MBytes.get_uint8 __bytes_value 0) 5) then
                let __bytes_value :=
                  MBytes.sub __bytes_value 1
                    (Pervasives.op_minus (MBytes.length __bytes_value) 1) in
                match
                  Data_encoding.Binary.of_bytes
                    Alpha_context.Script.expr_encoding __bytes_value with
                | None =&gt;
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Interp_costs.unpack_failed __bytes_value)))
                    (fun ctxt =&gt; logged_return ((Item None rest), ctxt))
                | Some expr =&gt;
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Alpha_context.Script.deserialized_cost expr)))
                    (fun ctxt =&gt;
                      Error_monad.op_gtgteq
                        (Script_ir_translator.parse_data None ctxt false t
                          (Micheline.root expr))
                        (fun function_parameter =&gt;
                          match function_parameter with
                          | Pervasives.Ok (value, ctxt) =&gt;
                            logged_return ((Item (Some value) rest), ctxt)
                          | Pervasives.Error _ignored =&gt;
                            Error_monad.op_gtgteqquestion
                              (Lwt.__return
                                (Alpha_context.Gas.consume ctxt
                                  (Interp_costs.unpack_failed __bytes_value)))
                              (fun ctxt =&gt;
                                logged_return ((Item None rest), ctxt))
                          end))
                end
              else
                logged_return ((Item None rest), ctxt))
        | (Script_typed_ir.Address, Item (_, address) rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.address))
            (fun ctxt =&gt; logged_return ((Item address rest), ctxt))
        | (Script_typed_ir.Contract t entrypoint, Item contract rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.contract))
            (fun ctxt =&gt;
              match (contract, entrypoint) with
              |
                ((contract, &quot;default&quot; % string), entrypoint) |
                ((contract, entrypoint), &quot;default&quot; % string) =&gt;
                Error_monad.op_gtgteqquestion
                  (Script_ir_translator.parse_contract_for_script false ctxt loc
                    t contract entrypoint)
                  (fun function_parameter =&gt;
                    let '(ctxt, maybe_contract) := function_parameter in
                    logged_return ((Item maybe_contract rest), ctxt))
              | _ =&gt; logged_return ((Item None rest), ctxt)
              end)
        |
          (Script_typed_ir.Transfer_tokens,
            Item p (Item amount (Item (tp, (destination, entrypoint)) rest))) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.transfer))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Script_ir_translator.collect_big_maps ctxt tp p)
                (fun function_parameter =&gt;
                  let '(to_duplicate, ctxt) := function_parameter in
                  let to_update := Script_ir_translator.no_big_map_id in
                  Error_monad.op_gtgteqquestion
                    (Script_ir_translator.extract_big_map_diff ctxt
                      Script_ir_translator.Optimized true to_duplicate to_update
                      tp p)
                    (fun function_parameter =&gt;
                      let '(p, big_map_diff, ctxt) := function_parameter in
                      Error_monad.op_gtgteqquestion
                        (Script_ir_translator.unparse_data ctxt
                          Script_ir_translator.Optimized tp p)
                        (fun function_parameter =&gt;
                          let '(p, ctxt) := function_parameter in
                          let operation :=
                            Alpha_context.Transaction
                              {|
                                Alpha_context.manager_operation.Transaction.amount :=
                                  amount;
                                Alpha_context.manager_operation.Transaction.parameters :=
                                  Alpha_context.Script.lazy_expr
                                    (Micheline.strip_locations p);
                                Alpha_context.manager_operation.Transaction.entrypoint :=
                                  entrypoint;
                                Alpha_context.manager_operation.Transaction.destination :=
                                  destination |} in
                          Error_monad.op_gtgteqquestion
                            (Lwt.__return
                              (Alpha_context.fresh_internal_nonce ctxt))
                            (fun function_parameter =&gt;
                              let '(ctxt, nonce) := function_parameter in
                              logged_return
                                ((Item
                                  ((Alpha_context.Internal_operation
                                    {|
                                      Alpha_context.internal_operation.source :=
                                        step_constants.self step_constants;
                                      Alpha_context.internal_operation.operation :=
                                        operation;
                                      Alpha_context.internal_operation.nonce :=
                                        nonce |}), big_map_diff) rest), ctxt))))))
        |
          (Script_typed_ir.Create_account,
            Item manager (Item delegate (Item _delegatable (Item credit rest))))
          =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.create_account))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Alpha_context.Contract.fresh_contract_from_current_nonce ctxt)
                (fun function_parameter =&gt;
                  let '(ctxt, contract) := function_parameter in
                  let manager_bytes :=
                    Data_encoding.Binary.to_bytes_exn
                      Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
                      manager in
                  let storage :=
                    Pervasives.op_atat Script_repr.lazy_expr
                      (Pervasives.op_atat Micheline.strip_locations
                        (Micheline.Bytes 0 manager_bytes)) in
                  let script :=
                    {|
                      Alpha_context.Script.t.code :=
                        Alpha_context.Script.Legacy_support.manager_script_code;
                      Alpha_context.Script.t.storage := storage |} in
                  let operation :=
                    Alpha_context.Origination
                      {|
                        Alpha_context.manager_operation.Origination.delegate :=
                          delegate;
                        Alpha_context.manager_operation.Origination.script :=
                          script;
                        Alpha_context.manager_operation.Origination.credit :=
                          credit;
                        Alpha_context.manager_operation.Origination.preorigination :=
                          Some contract |} in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return (Alpha_context.fresh_internal_nonce ctxt))
                    (fun function_parameter =&gt;
                      let '(ctxt, nonce) := function_parameter in
                      logged_return
                        ((Item
                          ((Alpha_context.Internal_operation
                            {|
                              Alpha_context.internal_operation.source :=
                                step_constants.self step_constants;
                              Alpha_context.internal_operation.operation :=
                                operation;
                              Alpha_context.internal_operation.nonce := nonce |}),
                            None) (Item (contract, &quot;default&quot; % string) rest)),
                          ctxt))))
        | (Script_typed_ir.Implicit_account, Item key rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.implicit_account))
            (fun ctxt =&gt;
              let contract := Alpha_context.Contract.implicit_contract key in
              logged_return
                ((Item
                  ((Script_typed_ir.Unit_t None), (contract, &quot;default&quot; % string))
                  rest), ctxt))
        |
          (Script_typed_ir.Create_contract storage_type param_type
            (Script_typed_ir.Lam _ code) root_name,
            Item manager
              (Item delegate
                (Item spendable
                  (Item delegatable (Item credit (Item init rest)))))) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.create_contract))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Script_ir_translator.unparse_ty ctxt param_type)
                (fun function_parameter =&gt;
                  let '(unparsed_param_type, ctxt) := function_parameter in
                  let unparsed_param_type :=
                    Script_ir_translator.add_field_annot
                      (Option.map
                        (fun n =&gt;
                          (* ‚ùå Variants not supported *)
                          (* ‚ùå `Field_annot *)
                          n) root_name) None unparsed_param_type in
                  Error_monad.op_gtgteqquestion
                    (Script_ir_translator.unparse_ty ctxt storage_type)
                    (fun function_parameter =&gt;
                      let '(unparsed_storage_type, ctxt) := function_parameter
                        in
                      let code :=
                        Pervasives.op_atat Alpha_context.Script.lazy_expr
                          (Micheline.strip_locations
                            (Micheline.Seq 0
                              (cons
                                (Micheline.Prim 0
                                  Alpha_context.Script.K_parameter
                                  (cons unparsed_param_type []) [])
                                (cons
                                  (Micheline.Prim 0
                                    Alpha_context.Script.K_storage
                                    (cons unparsed_storage_type []) [])
                                  (cons
                                    (Micheline.Prim 0
                                      Alpha_context.Script.K_code (cons code [])
                                      []) []))))) in
                      Error_monad.op_gtgteqquestion
                        (Script_ir_translator.collect_big_maps ctxt storage_type
                          init)
                        (fun function_parameter =&gt;
                          let '(to_duplicate, ctxt) := function_parameter in
                          let to_update := Script_ir_translator.no_big_map_id in
                          Error_monad.op_gtgteqquestion
                            (Script_ir_translator.extract_big_map_diff ctxt
                              Script_ir_translator.Optimized true to_duplicate
                              to_update storage_type init)
                            (fun function_parameter =&gt;
                              let '(init, big_map_diff, ctxt) :=
                                function_parameter in
                              Error_monad.op_gtgteqquestion
                                (Script_ir_translator.unparse_data ctxt
                                  Script_ir_translator.Optimized storage_type
                                  init)
                                (fun function_parameter =&gt;
                                  let '(storage, ctxt) := function_parameter in
                                  let storage :=
                                    Pervasives.op_atat
                                      Alpha_context.Script.lazy_expr
                                      (Micheline.strip_locations storage) in
                                  Error_monad.op_gtgteqquestion
                                    (if spendable then
                                      Alpha_context.Script.Legacy_support.add_do
                                        manager code storage
                                    else
                                      if delegatable then
                                        Alpha_context.Script.Legacy_support.add_set_delegate
                                          manager code storage
                                      else
                                        if
                                          Alpha_context.Script.Legacy_support.has_default_entrypoint
                                            code then
                                          Error_monad.op_gtgteqquestion
                                            (Alpha_context.Script.Legacy_support.add_root_entrypoint
                                              code)
                                            (fun code =&gt;
                                              Error_monad.__return
                                                (code, storage))
                                        else
                                          Error_monad.__return (code, storage))
                                    (fun function_parameter =&gt;
                                      let '(code, storage) := function_parameter
                                        in
                                      Error_monad.op_gtgteqquestion
                                        (Alpha_context.Contract.fresh_contract_from_current_nonce
                                          ctxt)
                                        (fun function_parameter =&gt;
                                          let '(ctxt, contract) :=
                                            function_parameter in
                                          let operation :=
                                            Alpha_context.Origination
                                              {|
                                                Alpha_context.manager_operation.Origination.delegate :=
                                                  delegate;
                                                Alpha_context.manager_operation.Origination.script :=
                                                  {|
                                                    Alpha_context.Script.t.code :=
                                                      code;
                                                    Alpha_context.Script.t.storage :=
                                                      storage |};
                                                Alpha_context.manager_operation.Origination.credit :=
                                                  credit;
                                                Alpha_context.manager_operation.Origination.preorigination :=
                                                  Some contract |} in
                                          Error_monad.op_gtgteqquestion
                                            (Lwt.__return
                                              (Alpha_context.fresh_internal_nonce
                                                ctxt))
                                            (fun function_parameter =&gt;
                                              let '(ctxt, nonce) :=
                                                function_parameter in
                                              logged_return
                                                ((Item
                                                  ((Alpha_context.Internal_operation
                                                    {|
                                                      Alpha_context.internal_operation.source :=
                                                        step_constants.self
                                                          step_constants;
                                                      Alpha_context.internal_operation.operation :=
                                                        operation;
                                                      Alpha_context.internal_operation.nonce :=
                                                        nonce |}), big_map_diff)
                                                  (Item
                                                    (contract,
                                                      &quot;default&quot; % string) rest)),
                                                  ctxt))))))))))
        |
          (Script_typed_ir.Create_contract_2 storage_type param_type
            (Script_typed_ir.Lam _ code) root_name,
            Item delegate (Item credit (Item init rest))) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.create_contract))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Script_ir_translator.unparse_ty ctxt param_type)
                (fun function_parameter =&gt;
                  let '(unparsed_param_type, ctxt) := function_parameter in
                  let unparsed_param_type :=
                    Script_ir_translator.add_field_annot
                      (Option.map
                        (fun n =&gt;
                          (* ‚ùå Variants not supported *)
                          (* ‚ùå `Field_annot *)
                          n) root_name) None unparsed_param_type in
                  Error_monad.op_gtgteqquestion
                    (Script_ir_translator.unparse_ty ctxt storage_type)
                    (fun function_parameter =&gt;
                      let '(unparsed_storage_type, ctxt) := function_parameter
                        in
                      let code :=
                        Micheline.strip_locations
                          (Micheline.Seq 0
                            (cons
                              (Micheline.Prim 0 Alpha_context.Script.K_parameter
                                (cons unparsed_param_type []) [])
                              (cons
                                (Micheline.Prim 0 Alpha_context.Script.K_storage
                                  (cons unparsed_storage_type []) [])
                                (cons
                                  (Micheline.Prim 0 Alpha_context.Script.K_code
                                    (cons code []) []) [])))) in
                      Error_monad.op_gtgteqquestion
                        (Script_ir_translator.collect_big_maps ctxt storage_type
                          init)
                        (fun function_parameter =&gt;
                          let '(to_duplicate, ctxt) := function_parameter in
                          let to_update := Script_ir_translator.no_big_map_id in
                          Error_monad.op_gtgteqquestion
                            (Script_ir_translator.extract_big_map_diff ctxt
                              Script_ir_translator.Optimized true to_duplicate
                              to_update storage_type init)
                            (fun function_parameter =&gt;
                              let '(init, big_map_diff, ctxt) :=
                                function_parameter in
                              Error_monad.op_gtgteqquestion
                                (Script_ir_translator.unparse_data ctxt
                                  Script_ir_translator.Optimized storage_type
                                  init)
                                (fun function_parameter =&gt;
                                  let '(storage, ctxt) := function_parameter in
                                  let storage :=
                                    Micheline.strip_locations storage in
                                  Error_monad.op_gtgteqquestion
                                    (Alpha_context.Contract.fresh_contract_from_current_nonce
                                      ctxt)
                                    (fun function_parameter =&gt;
                                      let '(ctxt, contract) :=
                                        function_parameter in
                                      let operation :=
                                        Alpha_context.Origination
                                          {|
                                            Alpha_context.manager_operation.Origination.delegate :=
                                              delegate;
                                            Alpha_context.manager_operation.Origination.script :=
                                              {|
                                                Alpha_context.Script.t.code :=
                                                  Alpha_context.Script.lazy_expr
                                                    code;
                                                Alpha_context.Script.t.storage :=
                                                  Alpha_context.Script.lazy_expr
                                                    storage |};
                                            Alpha_context.manager_operation.Origination.credit :=
                                              credit;
                                            Alpha_context.manager_operation.Origination.preorigination :=
                                              Some contract |} in
                                      Error_monad.op_gtgteqquestion
                                        (Lwt.__return
                                          (Alpha_context.fresh_internal_nonce
                                            ctxt))
                                        (fun function_parameter =&gt;
                                          let '(ctxt, nonce) :=
                                            function_parameter in
                                          logged_return
                                            ((Item
                                              ((Alpha_context.Internal_operation
                                                {|
                                                  Alpha_context.internal_operation.source :=
                                                    step_constants.self
                                                      step_constants;
                                                  Alpha_context.internal_operation.operation :=
                                                    operation;
                                                  Alpha_context.internal_operation.nonce :=
                                                    nonce |}), big_map_diff)
                                              (Item
                                                (contract, &quot;default&quot; % string)
                                                rest)), ctxt)))))))))
        | (Script_typed_ir.Set_delegate, Item delegate rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.create_account))
            (fun ctxt =&gt;
              let operation := Alpha_context.Delegation delegate in
              Error_monad.op_gtgteqquestion
                (Lwt.__return (Alpha_context.fresh_internal_nonce ctxt))
                (fun function_parameter =&gt;
                  let '(ctxt, nonce) := function_parameter in
                  logged_return
                    ((Item
                      ((Alpha_context.Internal_operation
                        {|
                          Alpha_context.internal_operation.source :=
                            step_constants.self step_constants;
                          Alpha_context.internal_operation.operation :=
                            operation;
                          Alpha_context.internal_operation.nonce := nonce |}),
                        None) rest), ctxt)))
        | (Script_typed_ir.Balance, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.balance))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (Alpha_context.Contract.get_balance ctxt
                  (step_constants.self step_constants))
                (fun balance =&gt; logged_return ((Item balance rest), ctxt)))
        | (Script_typed_ir.Now, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.now))
            (fun ctxt =&gt;
              let now := Alpha_context.Script_timestamp.now ctxt in
              logged_return ((Item now rest), ctxt))
        |
          (Script_typed_ir.Check_signature,
            Item key (Item signature (Item message rest))) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.check_signature key message)))
            (fun ctxt =&gt;
              let res := Signature.check None key signature message in
              logged_return ((Item res rest), ctxt))
        | (Script_typed_ir.Hash_key, Item key rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.hash_key))
            (fun ctxt =&gt;
              logged_return
                ((Item (Signature.Public_key.[S.SPublic_key.__hash_value] key)
                  rest), ctxt))
        | (Script_typed_ir.Blake2b, Item __bytes_value rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.hash_blake2b __bytes_value)))
            (fun ctxt =&gt;
              let __hash_value := Raw_hashes.blake2b __bytes_value in
              logged_return ((Item __hash_value rest), ctxt))
        | (Script_typed_ir.Sha256, Item __bytes_value rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.hash_sha256 __bytes_value)))
            (fun ctxt =&gt;
              let __hash_value := Raw_hashes.sha256 __bytes_value in
              logged_return ((Item __hash_value rest), ctxt))
        | (Script_typed_ir.Sha512, Item __bytes_value rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.hash_sha512 __bytes_value)))
            (fun ctxt =&gt;
              let __hash_value := Raw_hashes.sha512 __bytes_value in
              logged_return ((Item __hash_value rest), ctxt))
        | (Script_typed_ir.Steps_to_quota, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt Interp_costs.steps_to_quota))
            (fun ctxt =&gt;
              let steps :=
                match Alpha_context.Gas.level ctxt with
                |
                  Alpha_context.Gas.Limited {|
                    Alpha_context.Gas.t.Limited.remaining := remaining |} =&gt;
                  remaining
                | Alpha_context.Gas.Unaccounted =&gt;
                  Z.of_string &quot;99999999&quot; % string
                end in
              logged_return
                ((Item
                  (Alpha_context.Script_int.abs
                    (Alpha_context.Script_int.of_zint steps)) rest), ctxt))
        | (Script_typed_ir.Source, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.source))
            (fun ctxt =&gt;
              logged_return
                ((Item
                  ((step_constants.payer step_constants), &quot;default&quot; % string)
                  rest), ctxt))
        | (Script_typed_ir.Sender, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.source))
            (fun ctxt =&gt;
              logged_return
                ((Item
                  ((step_constants.source step_constants), &quot;default&quot; % string)
                  rest), ctxt))
        | (Script_typed_ir.Self t entrypoint, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.self))
            (fun ctxt =&gt;
              logged_return
                ((Item (t, ((step_constants.self step_constants), entrypoint))
                  rest), ctxt))
        | (Script_typed_ir.Amount, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.amount))
            (fun ctxt =&gt;
              logged_return
                ((Item (step_constants.amount step_constants) rest), ctxt))
        | (Script_typed_ir.Dig n n', stack) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n)))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (interp_stack_prefix_preserving_operation
                  (fun function_parameter =&gt;
                    let 'Item v rest := function_parameter in
                    Error_monad.__return (rest, v)) n' stack)
                (fun function_parameter =&gt;
                  let '(aft, x) := function_parameter in
                  logged_return ((Item x aft), ctxt)))
        | (Script_typed_ir.Dug n n', Item v rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n)))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (interp_stack_prefix_preserving_operation
                  (fun stk =&gt; Error_monad.__return ((Item v stk), tt)) n' rest)
                (fun function_parameter =&gt;
                  let '(aft, tt) := function_parameter in
                  logged_return (aft, ctxt)))
        | (Script_typed_ir.Dipn n n' b, stack) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n)))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (interp_stack_prefix_preserving_operation
                  (fun stk =&gt;
                    Error_monad.op_gtgteqquestion
                      (step log ctxt step_constants b stk)
                      (fun function_parameter =&gt;
                        let '(res, ctxt') := function_parameter in
                        Error_monad.__return (res, ctxt'))) n' stack)
                (fun function_parameter =&gt;
                  let '(aft, ctxt') := function_parameter in
                  logged_return (aft, ctxt')))
        | (Script_typed_ir.Dropn n n', stack) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n)))
            (fun ctxt =&gt;
              Error_monad.op_gtgteqquestion
                (interp_stack_prefix_preserving_operation
                  (fun stk =&gt; Error_monad.__return (stk, stk)) n' stack)
                (fun function_parameter =&gt;
                  let '(_, rest) := function_parameter in
                  logged_return (rest, ctxt)))
        | (Script_typed_ir.ChainId, rest) =&gt;
          Error_monad.op_gtgteqquestion
            (Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.chain_id))
            (fun ctxt =&gt;
              logged_return
                ((Item (step_constants.chain_id step_constants) rest), ctxt))
        end)

with interp {p r : Set}
  (log : option (Pervasives.ref execution_trace)) (ctxt : Alpha_context.context)
  (step_constants : step_constants)
  (function_parameter : Script_typed_ir.lambda p r) {struct log}
  : p -&gt; Lwt.t (Error_monad.tzresult (r * Alpha_context.context)) :=
  let 'Script_typed_ir.Lam code _ := function_parameter in
  fun arg =&gt;
    let stack := Item arg Empty in
    Error_monad.op_gtgteqquestion
      match log with
      | None =&gt; Error_monad.return_unit
      | Some log =&gt;
        Error_monad.op_gtgteqquestion
          (Error_monad.trace extensible_type_value
            (unparse_stack ctxt (stack, (Script_typed_ir.descr.bef code))))
          (fun stack =&gt;
            (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ‚ùå instruction_sequence &quot;;&quot; *)
            Error_monad.return_unit)
      end
      (fun function_parameter =&gt;
        let 'tt := function_parameter in
        Error_monad.op_gtgteqquestion (step log ctxt step_constants code stack)
          (fun function_parameter =&gt;
            let '(Item ret Empty, ctxt) := function_parameter in
            Error_monad.__return (ret, ctxt)))

with execute
  (log : option (Pervasives.ref execution_trace)) (ctxt : Alpha_context.context)
  (mode : Script_ir_translator.unparsing_mode) (step_constants : step_constants)
  (entrypoint : string) (unparsed_script : Alpha_context.Script.t)
  (arg : Alpha_context.Script.node) {struct log}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.Script.expr * list Alpha_context.packed_internal_operation
        * Alpha_context.context * option Alpha_context.Contract.big_map_diff)) :=
  Error_monad.op_gtgteqquestion
    (Script_ir_translator.parse_script None ctxt true unparsed_script)
    (fun function_parameter =&gt;
      let
        '(Script_ir_translator.Ex_script {|
          Script_typed_ir.script.code := code;
            Script_typed_ir.script.arg_type := arg_type;
            Script_typed_ir.script.storage := storage;
            Script_typed_ir.script.storage_type := storage_type;
            Script_typed_ir.script.root_name := root_name
            |}, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Error_monad.trace extensible_type_value
          (Lwt.__return
            (Script_ir_translator.find_entrypoint arg_type root_name entrypoint)))
        (fun function_parameter =&gt;
          let '(box, _) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Error_monad.trace extensible_type_value
              (Script_ir_translator.parse_data None ctxt false arg_type
                (box arg)))
            (fun function_parameter =&gt;
              let '(arg, ctxt) := function_parameter in
              Error_monad.op_gtgteqquestion
                (Alpha_context.Script.force_decode ctxt
                  (Alpha_context.Script.t.code unparsed_script))
                (fun function_parameter =&gt;
                  let '(script_code, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Script_ir_translator.collect_big_maps ctxt arg_type arg)
                    (fun function_parameter =&gt;
                      let '(to_duplicate, ctxt) := function_parameter in
                      Error_monad.op_gtgteqquestion
                        (Script_ir_translator.collect_big_maps ctxt storage_type
                          storage)
                        (fun function_parameter =&gt;
                          let '(to_update, ctxt) := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (Error_monad.trace extensible_type_value
                              (interp log ctxt step_constants code
                                (arg, storage)))
                            (fun function_parameter =&gt;
                              let '((ops, storage), ctxt) := function_parameter
                                in
                              Error_monad.op_gtgteqquestion
                                (Script_ir_translator.extract_big_map_diff ctxt
                                  mode false to_duplicate to_update storage_type
                                  storage)
                                (fun function_parameter =&gt;
                                  let '(storage, big_map_diff, ctxt) :=
                                    function_parameter in
                                  Error_monad.op_gtgteqquestion
                                    (Error_monad.trace extensible_type_value
                                      (Script_ir_translator.unparse_data ctxt
                                        mode storage_type storage))
                                    (fun function_parameter =&gt;
                                      let '(storage, ctxt) := function_parameter
                                        in
                                      let '(ops, op_diffs) := List.split ops in
                                      let big_map_diff :=
                                        match
                                          List.flatten
                                            (List.map (Option.unopt [])
                                              (Pervasives.op_at op_diffs
                                                (cons big_map_diff []))) with
                                        | [] =&gt; None
                                        | diff =&gt; Some diff
                                        end in
                                      Error_monad.__return
                                        ((Micheline.strip_locations storage),
                                          ops, ctxt, big_map_diff)))))))))).

Module execution_result.
  Record record := {
    ctxt : Alpha_context.context;
    storage : Alpha_context.Script.expr;
    big_map_diff : option Alpha_context.Contract.big_map_diff;
    operations : list Alpha_context.packed_internal_operation }.
End execution_result.
Definition execution_result := execution_result.record.

Definition trace
  (ctxt : Alpha_context.context) (mode : Script_ir_translator.unparsing_mode)
  (step_constants : step_constants) (script : Alpha_context.Script.t)
  (entrypoint : string)
  (parameter : Micheline.canonical Alpha_context.Script.prim)
  : Lwt.t
    (Error_monad.tzresult
      (execution_result *
        list
          (Alpha_context.Script.location * Alpha_context.Gas.t *
            list (Alpha_context.Script.expr * option string)))) :=
  let log := Pervasives.__ref_value [] in
  Error_monad.op_gtgteqquestion
    (execute (Some log) ctxt mode step_constants entrypoint script
      (Micheline.root parameter))
    (fun function_parameter =&gt;
      let '(storage, operations, ctxt, big_map_diff) := function_parameter in
      let trace := List.rev (Pervasives.op_exclamation log) in
      Error_monad.__return
        ({| execution_result.ctxt := ctxt; execution_result.storage := storage;
          execution_result.big_map_diff := big_map_diff;
          execution_result.operations := operations |}, trace)).

Definition execute
  (ctxt : Alpha_context.context) (mode : Script_ir_translator.unparsing_mode)
  (step_constants : step_constants) (script : Alpha_context.Script.t)
  (entrypoint : string)
  (parameter : Micheline.canonical Alpha_context.Script.prim)
  : Lwt.t (Error_monad.tzresult execution_result) :=
  Error_monad.op_gtgteqquestion
    (execute None ctxt mode step_constants entrypoint script
      (Micheline.root parameter))
    (fun function_parameter =&gt;
      let '(storage, operations, ctxt, big_map_diff) := function_parameter in
      Error_monad.__return
        {| execution_result.ctxt := ctxt; execution_result.storage := storage;
          execution_result.big_map_diff := big_map_diff;
          execution_result.operations := operations |}).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_interpreter.mli">
  <div class="col-md-6">
    <a href="#script_interpreter.mli"><code>script_interpreter.mli</code></a>&nbsp;<span class="label label-danger">7 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

type execution_trace =
  (Script.location * Gas.t * (Script.expr * string option) list) list

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Reject of Script.location * Script.expr * execution_trace option</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Overflow of Script.location * execution_trace option</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Runtime_contract_error : Contract.t * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Bad_contract_parameter of Contract.t</abbr> (* `Permanent *)

<abbr class="mark-error" title="Extensible types are not handled.">type error += Cannot_serialize_log</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Cannot_serialize_failure</abbr>

<abbr class="mark-error" title="Extensible types are not handled.">type error += Cannot_serialize_storage</abbr>

type execution_result = {
  ctxt : context;
  storage : Script.expr;
  big_map_diff : Contract.big_map_diff option;
  operations : packed_internal_operation list;
}

type step_constants = {
  source : Contract.t;
  payer : Contract.t;
  self : Contract.t;
  amount : Tez.t;
  chain_id : Chain_id.t;
}

type 'tys stack =
  | Item : 'ty * 'rest stack -&gt; ('ty * 'rest) stack
  | Empty : Script_typed_ir.end_of_stack stack

val step :
  ?log:execution_trace ref -&gt;
  context -&gt;
  step_constants -&gt;
  ('bef, 'aft) Script_typed_ir.descr -&gt;
  'bef stack -&gt;
  ('aft stack * context) tzresult Lwt.t

val execute :
  Alpha_context.t -&gt;
  Script_ir_translator.unparsing_mode -&gt;
  step_constants -&gt;
  script:Script.t -&gt;
  entrypoint:string -&gt;
  parameter:Script.expr -&gt;
  execution_result tzresult Lwt.t

val trace :
  Alpha_context.t -&gt;
  Script_ir_translator.unparsing_mode -&gt;
  step_constants -&gt;
  script:Script.t -&gt;
  entrypoint:string -&gt;
  parameter:Script.expr -&gt;
  (execution_result * execution_trace) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_interpreter.mli"><code>Script_interpreter_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Script_ir_translator.
Require Tezos.Script_typed_ir.

Definition execution_trace :=
  list
    (Alpha_context.Script.location * Alpha_context.Gas.t *
      list (Alpha_context.Script.expr * option string)).

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Module execution_result.
  Record record := {
    ctxt : Alpha_context.context;
    storage : Alpha_context.Script.expr;
    big_map_diff : option Alpha_context.Contract.big_map_diff;
    operations : list Alpha_context.packed_internal_operation }.
End execution_result.
Definition execution_result := execution_result.record.

Module step_constants.
  Record record := {
    source : Alpha_context.Contract.t;
    payer : Alpha_context.Contract.t;
    self : Alpha_context.Contract.t;
    amount : Alpha_context.Tez.t;
    chain_id : Chain_id.[S.HASH.t] }.
End step_constants.
Definition step_constants := step_constants.record.

Reserved Notation &quot;'stack&quot;.

Inductive stack_gadt : Set :=
| Item : forall {ty : Set}, ty -&gt; stack_gadt -&gt; stack_gadt
| Empty : stack_gadt

where &quot;'stack&quot; := (fun (tys : Set) =&gt; stack_gadt).

Definition stack := 'stack.

Parameter step : forall {aft bef : Set},
  option (Pervasives.ref execution_trace) -&gt; Alpha_context.context -&gt;
  step_constants -&gt; Script_typed_ir.descr bef aft -&gt; stack bef -&gt;
  Lwt.t (Error_monad.tzresult (stack aft * Alpha_context.context)).

Parameter execute :
  Alpha_context.t -&gt; Script_ir_translator.unparsing_mode -&gt; step_constants -&gt;
  Alpha_context.Script.t -&gt; string -&gt; Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.tzresult execution_result).

Parameter trace :
  Alpha_context.t -&gt; Script_ir_translator.unparsing_mode -&gt; step_constants -&gt;
  Alpha_context.Script.t -&gt; string -&gt; Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.tzresult (execution_result * execution_trace)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_annot.ml">
  <div class="col-md-6">
    <a href="#script_ir_annot.ml"><code>script_ir_annot.ml</code></a>&nbsp;<span class="label label-danger">138 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Micheline
open Script_tc_errors
open Script_typed_ir

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_now_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;now&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_amount_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;amount&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_balance_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;balance&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_steps_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;steps&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_source_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;source&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_sender_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;sender&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_self_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;self&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_arg_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;arg&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_param_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;parameter&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_storage_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;storage&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_car_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;car&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_cdr_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;cdr&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_contract_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;contract&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_addr_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;address&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_manager_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;manager&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_pack_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;packed&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_unpack_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;unpacked&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_slice_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;slice&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_elt_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;elt&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_key_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;key&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_hd_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;hd&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_tl_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;tl&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_some_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;some&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_left_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;left&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_right_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;right&quot;)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">default_binding_annot</abbr> = Some <abbr class="mark-error" title="Variants not supported">(`Field_annot &quot;bnd&quot;)</abbr>

let unparse_type_annot : type_annot option -&gt; string list = function
  | None -&gt;
      []
  | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Type_annot a)</abbr> -&gt;
      [&quot;:&quot; ^ a]

let unparse_var_annot : var_annot option -&gt; string list = function
  | None -&gt;
      []
  | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot a)</abbr> -&gt;
      [&quot;@&quot; ^ a]

let unparse_field_annot : field_annot option -&gt; string list = function
  | None -&gt;
      []
  | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot a)</abbr> -&gt;
      [&quot;%&quot; ^ a]

let field_to_var_annot : field_annot option -&gt; var_annot option = function
  | None -&gt;
      None
  | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot s)</abbr> -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Var_annot s)</abbr>

let type_to_var_annot : type_annot option -&gt; var_annot option = function
  | None -&gt;
      None
  | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Type_annot s)</abbr> -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Var_annot s)</abbr>

let var_to_field_annot : var_annot option -&gt; field_annot option = function
  | None -&gt;
      None
  | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot s)</abbr> -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Field_annot s)</abbr>

let default_annot ~default = function None -&gt; default | annot -&gt; annot

let gen_access_annot :
    var_annot option -&gt;
    ?default:field_annot option -&gt;
    field_annot option -&gt;
    var_annot option =
 fun value_annot ?(default = None) field_annot -&gt;
  match (value_annot, field_annot, default) with
  | (None, None, _) | (Some _, None, None) | (None, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;&quot;)</abbr>, _)
    -&gt;
      None
  | (None, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot f)</abbr>, _) -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Var_annot f)</abbr>
  | ( Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot v)</abbr>,
      (None | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;&quot;)</abbr>),
      Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot f)</abbr> ) -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Var_annot (String.concat &quot;.&quot; [v; f]))</abbr>
  | (Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot v)</abbr>, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot f)</abbr>, _) -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Var_annot (String.concat &quot;.&quot; [v; f]))</abbr>

let merge_type_annot :
    legacy:bool -&gt;
    type_annot option -&gt;
    type_annot option -&gt;
    type_annot option tzresult =
 fun ~legacy annot1 annot2 -&gt;
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) -&gt;
      ok None
  | (Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Type_annot a1)</abbr>, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Type_annot a2)</abbr>) -&gt;
      if legacy || String.equal a1 a2 then ok annot1
      else error <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_annotations (&quot;:&quot; ^ a1, &quot;:&quot; ^ a2))</abbr>

let merge_field_annot :
    legacy:bool -&gt;
    field_annot option -&gt;
    field_annot option -&gt;
    field_annot option tzresult =
 fun ~legacy annot1 annot2 -&gt;
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) -&gt;
      ok None
  | (Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot a1)</abbr>, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot a2)</abbr>) -&gt;
      if legacy || String.equal a1 a2 then ok annot1
      else error <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_annotations (&quot;%&quot; ^ a1, &quot;%&quot; ^ a2))</abbr>

let merge_var_annot : var_annot option -&gt; var_annot option -&gt; var_annot option
    =
 fun annot1 annot2 -&gt;
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) -&gt;
      None
  | (Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot a1)</abbr>, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot a2)</abbr>) -&gt;
      if String.equal a1 a2 then annot1 else None

let error_unexpected_annot loc annot =
  match annot with [] -&gt; ok () | _ :: _ -&gt; error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>

let fail_unexpected_annot loc annot =
  Lwt.return (error_unexpected_annot loc annot)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">parse_annots</abbr> loc ?(allow_special_var = false)
    ?(allow_special_field = false) l =
  (* allow emtpty annotations as wildcards but otherwise only accept
     annotations that start with [a-zA-Z_] *)
  let sub_or_wildcard ~specials wrap s acc =
    let len = String.length s in
    if Compare.Int.(len = 1) then ok @@ (wrap None :: acc)
    else
      match s.[1] with
      | 'a' .. 'z' | 'A' .. 'Z' | '_' -&gt;
          ok @@ (wrap (Some (String.sub s 1 (len - 1))) :: acc)
      | '@' when Compare.Int.(len = 2) &amp;&amp; List.mem '@' specials -&gt;
          ok @@ (wrap (Some &quot;@&quot;) :: acc)
      | '%' when List.mem '%' specials -&gt;
          if Compare.Int.(len = 2) then ok @@ (wrap (Some &quot;%&quot;) :: acc)
          else if Compare.Int.(len = 3) &amp;&amp; Compare.Char.(s.[2] = '%') then
            ok @@ (wrap (Some &quot;%%&quot;) :: acc)
          else error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>
      | _ -&gt;
          error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>
  in
  List.fold_left
    (fun acc s -&gt;
      acc
      &gt;&gt;? fun acc -&gt;
      if Compare.Int.(String.length s = 0) then
        error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>
      else
        match s.[0] with
        | ':' -&gt;
            sub_or_wildcard ~specials:[] (fun a -&gt; <abbr class="mark-error" title="Variants not supported">`Type_annot a</abbr>) s acc
        | '@' -&gt;
            sub_or_wildcard
              ~specials:(if allow_special_var then ['%'] else [])
              (fun a -&gt; <abbr class="mark-error" title="Variants not supported">`Var_annot a</abbr>)
              s
              acc
        | '%' -&gt;
            sub_or_wildcard
              ~specials:(if allow_special_field then ['@'] else [])
              (fun a -&gt; <abbr class="mark-error" title="Variants not supported">`Field_annot a</abbr>)
              s
              acc
        | _ -&gt;
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>)
    (ok [])
    l
  &gt;|? List.rev

let <abbr class="mark-error" title="Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">opt_var_of_var_opt</abbr> = function
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Var_annot None</abbr> -&gt;
      None
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Var_annot (Some a)</abbr> -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Var_annot a)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">opt_field_of_field_opt</abbr> = function
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Field_annot None</abbr> -&gt;
      None
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Field_annot (Some a)</abbr> -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Field_annot a)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">opt_type_of_type_opt</abbr> = function
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Type_annot None</abbr> -&gt;
      None
  | <abbr class="mark-error" title="Patterns on variants are not supported">`Type_annot (Some a)</abbr> -&gt;
      Some <abbr class="mark-error" title="Variants not supported">(`Type_annot a)</abbr>

let <abbr class="mark-error" title="Polymorphic variant types are not handled">classify_annot</abbr> loc l :
    (var_annot option list * type_annot option list * field_annot option list)
    tzresult =
  <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let (_, rv, _, rt, _, rf) =
      List.fold_left
        (fun (in_v, rv, in_t, rt, in_f, rf) a -&gt;
          match (a, in_v, rv, in_t, rt, in_f, rf) with
          | ((</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">`Var_annot _</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> as a), true, _, _, _, _, _)
          | ((</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">`Var_annot _</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> as a), false, [], _, _, _, _) -&gt;
              (true, opt_var_of_var_opt a :: rv, false, rt, false, rf)
          | ((</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">`Type_annot _</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> as a), _, _, true, _, _, _)
          | ((</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">`Type_annot _</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> as a), _, _, false, [], _, _) -&gt;
              (false, rv, true, opt_type_of_type_opt a :: rt, false, rf)
          | ((</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">`Field_annot _</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> as a), _, _, _, _, true, _)
          | ((</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">`Field_annot _</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> as a), _, _, _, _, false, []) -&gt;
              (false, rv, false, rt, true, opt_field_of_field_opt a :: rf)
          | _ -&gt;
              raise </abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">Exit</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">)
        (false, [], false, [], false, [])
        l
    in
    ok (List.rev rv, List.rev rt, List.rev rf)
  with Exit -&gt; error (Ungrouped_annotations loc)</abbr>

let get_one_annot loc = function
  | [] -&gt;
      ok None
  | [a] -&gt;
      ok a
  | _ -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>

let get_two_annot loc = function
  | [] -&gt;
      ok (None, None)
  | [a] -&gt;
      ok (a, None)
  | [a; b] -&gt;
      ok (a, b)
  | _ -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>

let parse_type_annot : int -&gt; string list -&gt; type_annot option tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc fields &gt;&gt;? fun () -&gt; get_one_annot loc types

let parse_type_field_annot :
    int -&gt; string list -&gt; (type_annot option * field_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  get_one_annot loc types
  &gt;&gt;? fun t -&gt; get_one_annot loc fields &gt;|? fun f -&gt; (t, f)

let parse_composed_type_annot :
    int -&gt;
    string list -&gt;
    (type_annot option * field_annot option * field_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  get_one_annot loc types
  &gt;&gt;? fun t -&gt; get_two_annot loc fields &gt;|? fun (f1, f2) -&gt; (t, f1, f2)

let parse_field_annot : int -&gt; string list -&gt; field_annot option tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc types &gt;&gt;? fun () -&gt; get_one_annot loc fields

let extract_field_annot :
    Script.node -&gt; (Script.node * field_annot option) tzresult = function
  | Prim (loc, prim, args, annot) -&gt;
      let rec extract_first acc = function
        | [] -&gt;
            (None, annot)
        | s :: rest -&gt;
            if Compare.Int.(String.length s &gt; 0) &amp;&amp; Compare.Char.(s.[0] = '%')
            then (Some s, List.rev_append acc rest)
            else extract_first (s :: acc) rest
      in
      let (field_annot, annot) = extract_first [] annot in
      let field_annot =
        match field_annot with
        | None -&gt;
            None
        | Some field_annot -&gt;
            Some
              <abbr class="mark-error" title="Variants not supported">(`Field_annot
                (String.sub field_annot 1 (String.length field_annot - 1)))</abbr>
      in
      ok (Prim (loc, prim, args, annot), field_annot)
  | expr -&gt;
      ok (expr, None)

let check_correct_field :
    field_annot option -&gt; field_annot option -&gt; unit tzresult =
 fun f1 f2 -&gt;
  match (f1, f2) with
  | (None, _) | (_, None) -&gt;
      ok ()
  | (Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot s1)</abbr>, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot s2)</abbr>) -&gt;
      if String.equal s1 s2 then ok ()
      else error <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_field_annotations (&quot;%&quot; ^ s1, &quot;%&quot; ^ s2))</abbr>

let parse_var_annot :
    int -&gt;
    ?default:var_annot option -&gt;
    string list -&gt;
    var_annot option tzresult =
 fun loc ?default annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc fields
  &gt;&gt;? fun () -&gt;
  get_one_annot loc vars
  &gt;|? function
  | Some _ as a -&gt;
      a
  | None -&gt; (
    match default with Some a -&gt; a | None -&gt; None )

let <abbr class="mark-error" title="Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">split_last_dot</abbr> = function
  | None -&gt;
      (None, None)
  | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot s)</abbr> -&gt; (
    match String.rindex_opt s '.' with
    | None -&gt;
        (None, Some <abbr class="mark-error" title="Variants not supported">(`Field_annot s)</abbr>)
    | Some i -&gt;
        let s1 = String.sub s 0 i in
        let s2 = String.sub s (i + 1) (String.length s - i - 1) in
        let f =
          if Compare.String.equal s2 &quot;car&quot; || Compare.String.equal s2 &quot;cdr&quot;
          then None
          else Some <abbr class="mark-error" title="Variants not supported">(`Field_annot s2)</abbr>
        in
        (Some <abbr class="mark-error" title="Variants not supported">(`Var_annot s1)</abbr>, f) )

let <abbr class="mark-error" title="Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">common_prefix</abbr> v1 v2 =
  match (v1, v2) with
  | (Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot s1)</abbr>, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot s2)</abbr>)
    when Compare.String.equal s1 s2 -&gt;
      v1
  | (Some _, None) -&gt;
      v1
  | (None, Some _) -&gt;
      v2
  | (_, _) -&gt;
      None

let parse_constr_annot :
    int -&gt;
    ?if_special_first:field_annot option -&gt;
    ?if_special_second:field_annot option -&gt;
    string list -&gt;
    ( var_annot option
    * type_annot option
    * field_annot option
    * field_annot option )
    tzresult =
 fun loc ?if_special_first ?if_special_second annot -&gt;
  parse_annots ~allow_special_field:true loc annot
  &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  get_one_annot loc vars
  &gt;&gt;? fun v -&gt;
  get_one_annot loc types
  &gt;&gt;? fun t -&gt;
  get_two_annot loc fields
  &gt;&gt;? fun (f1, f2) -&gt;
  ( match (if_special_first, f1) with
  | (Some special_var, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;@&quot;)</abbr>) -&gt;
      ok (split_last_dot special_var)
  | (None, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;@&quot;)</abbr>) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>
  | (_, _) -&gt;
      ok (v, f1) )
  &gt;&gt;? fun (v1, f1) -&gt;
  ( match (if_special_second, f2) with
  | (Some special_var, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;@&quot;)</abbr>) -&gt;
      ok (split_last_dot special_var)
  | (None, Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;@&quot;)</abbr>) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>
  | (_, _) -&gt;
      ok (v, f2) )
  &gt;|? fun (v2, f2) -&gt;
  let v = match v with None -&gt; common_prefix v1 v2 | Some _ -&gt; v in
  (v, t, f1, f2)

let parse_two_var_annot :
    int -&gt; string list -&gt; (var_annot option * var_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc fields &gt;&gt;? fun () -&gt; get_two_annot loc vars

let parse_destr_annot :
    int -&gt;
    string list -&gt;
    default_accessor:field_annot option -&gt;
    field_name:field_annot option -&gt;
    pair_annot:var_annot option -&gt;
    value_annot:var_annot option -&gt;
    (var_annot option * field_annot option) tzresult =
 fun loc annot ~default_accessor ~field_name ~pair_annot ~value_annot -&gt;
  parse_annots loc ~allow_special_var:true annot
  &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  get_one_annot loc vars
  &gt;&gt;? fun v -&gt;
  get_one_annot loc fields
  &gt;|? fun f -&gt;
  let default =
    gen_access_annot pair_annot field_name ~default:default_accessor
  in
  let v =
    match v with
    | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot &quot;%&quot;)</abbr> -&gt;
        field_to_var_annot field_name
    | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Var_annot &quot;%%&quot;)</abbr> -&gt;
        default
    | Some _ -&gt;
        v
    | None -&gt;
        value_annot
  in
  (v, f)

let parse_entrypoint_annot :
    int -&gt;
    ?default:var_annot option -&gt;
    string list -&gt;
    (var_annot option * field_annot option) tzresult =
 fun loc ?default annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  get_one_annot loc fields
  &gt;&gt;? fun f -&gt;
  get_one_annot loc vars
  &gt;|? function
  | Some _ as a -&gt;
      (a, f)
  | None -&gt; (
    match default with Some a -&gt; (a, f) | None -&gt; (None, f) )

let parse_var_type_annot :
    int -&gt; string list -&gt; (var_annot option * type_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc fields
  &gt;&gt;? fun () -&gt;
  get_one_annot loc vars
  &gt;&gt;? fun v -&gt; get_one_annot loc types &gt;|? fun t -&gt; (v, t)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_annot.ml"><code>Script_ir_annot.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Script_tc_errors.

Import Script_typed_ir.

Definition default_now_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;now&quot; % string.

Definition default_amount_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;amount&quot; % string.

Definition default_balance_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;balance&quot; % string.

Definition default_steps_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;steps&quot; % string.

Definition default_source_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;source&quot; % string.

Definition default_sender_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;sender&quot; % string.

Definition default_self_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;self&quot; % string.

Definition default_arg_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;arg&quot; % string.

Definition default_param_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;parameter&quot; % string.

Definition default_storage_annot : option (* `Var_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Var_annot *)
    &quot;storage&quot; % string.

Definition default_car_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;car&quot; % string.

Definition default_cdr_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;cdr&quot; % string.

Definition default_contract_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;contract&quot; % string.

Definition default_addr_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;address&quot; % string.

Definition default_manager_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;manager&quot; % string.

Definition default_pack_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;packed&quot; % string.

Definition default_unpack_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;unpacked&quot; % string.

Definition default_slice_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;slice&quot; % string.

Definition default_elt_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;elt&quot; % string.

Definition default_key_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;key&quot; % string.

Definition default_hd_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;hd&quot; % string.

Definition default_tl_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;tl&quot; % string.

Definition default_some_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;some&quot; % string.

Definition default_left_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;left&quot; % string.

Definition default_right_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;right&quot; % string.

Definition default_binding_annot : option (* `Field_annot *) string :=
  Some
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Field_annot *)
    &quot;bnd&quot; % string.

Definition unparse_type_annot
  (function_parameter : option Script_typed_ir.type_annot) : list string :=
  match function_parameter with
  | None =&gt; []
  | Some (Type_annot a) =&gt; cons (Pervasives.op_caret &quot;:&quot; % string a) []
  end.

Definition unparse_var_annot
  (function_parameter : option Script_typed_ir.var_annot) : list string :=
  match function_parameter with
  | None =&gt; []
  | Some (Var_annot a) =&gt; cons (Pervasives.op_caret &quot;@&quot; % string a) []
  end.

Definition unparse_field_annot
  (function_parameter : option Script_typed_ir.field_annot) : list string :=
  match function_parameter with
  | None =&gt; []
  | Some (Field_annot a) =&gt; cons (Pervasives.op_caret &quot;%&quot; % string a) []
  end.

Definition field_to_var_annot
  (function_parameter : option Script_typed_ir.field_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None =&gt; None
  | Some (Field_annot s) =&gt;
    Some
      (* ‚ùå Variants not supported *)
      (* ‚ùå `Var_annot *)
      s
  end.

Definition type_to_var_annot
  (function_parameter : option Script_typed_ir.type_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None =&gt; None
  | Some (Type_annot s) =&gt;
    Some
      (* ‚ùå Variants not supported *)
      (* ‚ùå `Var_annot *)
      s
  end.

Definition var_to_field_annot
  (function_parameter : option Script_typed_ir.var_annot)
  : option Script_typed_ir.field_annot :=
  match function_parameter with
  | None =&gt; None
  | Some (Var_annot s) =&gt;
    Some
      (* ‚ùå Variants not supported *)
      (* ‚ùå `Field_annot *)
      s
  end.

Definition default_annot {A : Set}
  (default : option A) (function_parameter : option A) : option A :=
  match function_parameter with
  | None =&gt; default
  | annot =&gt; annot
  end.

Definition gen_access_annot
  (value_annot : option Script_typed_ir.var_annot)
  (op_staroptstar : option (option Script_typed_ir.field_annot))
  : option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot :=
  let default :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; None
    end in
  fun field_annot =&gt;
    match (value_annot, field_annot, default) with
    |
      (None, None, _) | (Some _, None, None) |
      (None, Some (Field_annot &quot;&quot; % string), _) =&gt; None
    | (None, Some (Field_annot f), _) =&gt;
      Some
        (* ‚ùå Variants not supported *)
        (* ‚ùå `Var_annot *)
        f
    |
      (Some (Var_annot v), None | Some (Field_annot &quot;&quot; % string),
        Some (Field_annot f)) =&gt;
      Some
        (* ‚ùå Variants not supported *)
        (* ‚ùå `Var_annot *)
        (String.concat &quot;.&quot; % string (cons v (cons f [])))
    | (Some (Var_annot v), Some (Field_annot f), _) =&gt;
      Some
        (* ‚ùå Variants not supported *)
        (* ‚ùå `Var_annot *)
        (String.concat &quot;.&quot; % string (cons v (cons f [])))
    end.

Definition merge_type_annot
  (legacy : bool) (annot1 : option Script_typed_ir.type_annot)
  (annot2 : option Script_typed_ir.type_annot)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) =&gt; Error_monad.ok None
  | (Some (Type_annot a1), Some (Type_annot a2)) =&gt;
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_field_annot
  (legacy : bool) (annot1 : option Script_typed_ir.field_annot)
  (annot2 : option Script_typed_ir.field_annot)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) =&gt; Error_monad.ok None
  | (Some (Field_annot a1), Some (Field_annot a2)) =&gt;
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_var_annot
  (annot1 : option Script_typed_ir.var_annot)
  (annot2 : option Script_typed_ir.var_annot)
  : option Script_typed_ir.var_annot :=
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) =&gt; None
  | (Some (Var_annot a1), Some (Var_annot a2)) =&gt;
    if String.equal a1 a2 then
      annot1
    else
      None
  end.

Definition error_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Error_monad.tzresult unit :=
  match annot with
  | [] =&gt; Error_monad.ok tt
  | cons _ _ =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition fail_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Lwt.t (Error_monad.tzresult unit) :=
  Lwt.__return (error_unexpected_annot loc annot).

Definition parse_annots
  (loc : Alpha_context.Script.location) (op_staroptstar : option bool)
  : option bool -&gt; list string -&gt;
  Error_monad.tzresult (list (* `Field_annot *) (option string)) :=
  let allow_special_var :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun op_staroptstar =&gt;
    let allow_special_field :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; false
      end in
    fun l =&gt;
      let sub_or_wildcard {A : Set}
        (specials : list ascii) (wrap : option string -&gt; A) (s : string)
        (acc : list A) : Error_monad.tzresult (list A) :=
        let len := String.length s in
        if Compare.Int.[Compare.S.op_eq] len 1 then
          Pervasives.op_atat Error_monad.ok (cons (wrap None) acc)
        else
          match
            ((String.get s 1),
              match String.get s 1 with
              | &quot;@&quot; % char =&gt;
                Pervasives.op_andand (Compare.Int.[Compare.S.op_eq] len 2)
                  (List.mem &quot;@&quot; % char specials)
              | _ =&gt; false
              end,
              match String.get s 1 with
              | &quot;%&quot; % char =&gt; List.mem &quot;%&quot; % char specials
              | _ =&gt; false
              end) with
          |
            (&quot;a&quot; % char | &quot;b&quot; % char | &quot;c&quot; % char | &quot;d&quot; % char | &quot;e&quot; % char |
            &quot;f&quot; % char | &quot;g&quot; % char | &quot;h&quot; % char | &quot;i&quot; % char | &quot;j&quot; % char |
            &quot;k&quot; % char | &quot;l&quot; % char | &quot;m&quot; % char | &quot;n&quot; % char | &quot;o&quot; % char |
            &quot;p&quot; % char | &quot;q&quot; % char | &quot;r&quot; % char | &quot;s&quot; % char | &quot;t&quot; % char |
            &quot;u&quot; % char | &quot;v&quot; % char | &quot;w&quot; % char | &quot;x&quot; % char | &quot;y&quot; % char |
            &quot;z&quot; % char | &quot;A&quot; % char | &quot;B&quot; % char | &quot;C&quot; % char | &quot;D&quot; % char |
            &quot;E&quot; % char | &quot;F&quot; % char | &quot;G&quot; % char | &quot;H&quot; % char | &quot;I&quot; % char |
            &quot;J&quot; % char | &quot;K&quot; % char | &quot;L&quot; % char | &quot;M&quot; % char | &quot;N&quot; % char |
            &quot;O&quot; % char | &quot;P&quot; % char | &quot;Q&quot; % char | &quot;R&quot; % char | &quot;S&quot; % char |
            &quot;T&quot; % char | &quot;U&quot; % char | &quot;V&quot; % char | &quot;W&quot; % char | &quot;X&quot; % char |
            &quot;Y&quot; % char | &quot;Z&quot; % char | &quot;_&quot; % char, _, _) =&gt;
            Pervasives.op_atat Error_monad.ok
              (cons (wrap (Some (String.sub s 1 (Pervasives.op_minus len 1))))
                acc)
          | (&quot;@&quot; % char, true, _) =&gt;
            Pervasives.op_atat Error_monad.ok
              (cons (wrap (Some &quot;@&quot; % string)) acc)
          | (&quot;%&quot; % char, _, true) =&gt;
            if Compare.Int.[Compare.S.op_eq] len 2 then
              Pervasives.op_atat Error_monad.ok
                (cons (wrap (Some &quot;%&quot; % string)) acc)
            else
              if
                Pervasives.op_andand (Compare.Int.[Compare.S.op_eq] len 3)
                  (Compare.Char.[Compare.S.op_eq] (String.get s 2) &quot;%&quot; % char)
                then
                Pervasives.op_atat Error_monad.ok
                  (cons (wrap (Some &quot;%%&quot; % string)) acc)
              else
                Error_monad.__error_value extensible_type_value
          | (_, _, _) =&gt; Error_monad.__error_value extensible_type_value
          end in
      Error_monad.op_gtpipequestion
        (List.fold_left
          (fun acc =&gt;
            fun s =&gt;
              Error_monad.op_gtgtquestion acc
                (fun acc =&gt;
                  if Compare.Int.[Compare.S.op_eq] (String.length s) 0 then
                    Error_monad.__error_value extensible_type_value
                  else
                    match String.get s 0 with
                    | &quot;:&quot; % char =&gt;
                      sub_or_wildcard []
                        (fun a =&gt;
                          (* ‚ùå Variants not supported *)
                          (* ‚ùå `Type_annot *)
                          a) s acc
                    | &quot;@&quot; % char =&gt;
                      sub_or_wildcard
                        (if allow_special_var then
                          cons &quot;%&quot; % char []
                        else
                          [])
                        (fun a =&gt;
                          (* ‚ùå Variants not supported *)
                          (* ‚ùå `Var_annot *)
                          a) s acc
                    | &quot;%&quot; % char =&gt;
                      sub_or_wildcard
                        (if allow_special_field then
                          cons &quot;@&quot; % char []
                        else
                          [])
                        (fun a =&gt;
                          (* ‚ùå Variants not supported *)
                          (* ‚ùå `Field_annot *)
                          a) s acc
                    | _ =&gt; Error_monad.__error_value extensible_type_value
                    end)) (Error_monad.ok []) l) List.rev.

Definition opt_var_of_var_opt {A : Set}
  (function_parameter : (* `Var_annot *) option A)
  : option (* `Var_annot *) A :=
  match function_parameter with
  | Var_annot None =&gt; None
  | Var_annot (Some a) =&gt;
    Some
      (* ‚ùå Variants not supported *)
      (* ‚ùå `Var_annot *)
      a
  end.

Definition opt_field_of_field_opt {A : Set}
  (function_parameter : (* `Field_annot *) option A)
  : option (* `Field_annot *) A :=
  match function_parameter with
  | Field_annot None =&gt; None
  | Field_annot (Some a) =&gt;
    Some
      (* ‚ùå Variants not supported *)
      (* ‚ùå `Field_annot *)
      a
  end.

Definition opt_type_of_type_opt {A : Set}
  (function_parameter : (* `Type_annot *) option A)
  : option (* `Type_annot *) A :=
  match function_parameter with
  | Type_annot None =&gt; None
  | Type_annot (Some a) =&gt;
    Some
      (* ‚ùå Variants not supported *)
      (* ‚ùå `Type_annot *)
      a
  end.

Definition classify_annot
  (loc : Alpha_context.Script.location)
  (l : list (* `Var_annot *) (option string))
  : Error_monad.tzresult
    (list (option Script_typed_ir.var_annot) *
      list (option Script_typed_ir.type_annot) *
      list (option Script_typed_ir.field_annot)) :=
  (* ‚ùå Try-with are not handled *)
  try
    (let '(_, rv, _, rt, _, rf) :=
      List.fold_left
        (fun function_parameter =&gt;
          let '(in_v, rv, in_t, rt, in_f, rf) := function_parameter in
          fun a =&gt;
            match (a, in_v, rv, in_t, rt, in_f, rf) with
            |
              ((Var_annot _) as a, true, _, _, _, _, _) |
              ((Var_annot _) as a, false, [], _, _, _, _) =&gt;
              (true, (cons (opt_var_of_var_opt a) rv), false, rt, false, rf)
            |
              ((Type_annot _) as a, _, _, true, _, _, _) |
              ((Type_annot _) as a, _, _, false, [], _, _) =&gt;
              (false, rv, true, (cons (opt_type_of_type_opt a) rt), false, rf)
            |
              ((Field_annot _) as a, _, _, _, _, true, _) |
              ((Field_annot _) as a, _, _, _, _, false, []) =&gt;
              (false, rv, false, rt, true, (cons (opt_field_of_field_opt a) rf))
            | _ =&gt; Pervasives.raise extensible_type_value
            end) (false, [], false, [], false, []) l in
    Error_monad.ok ((List.rev rv), (List.rev rt), (List.rev rf))).

Definition get_one_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A) :=
  match function_parameter with
  | [] =&gt; Error_monad.ok None
  | cons a [] =&gt; Error_monad.ok a
  | _ =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition get_two_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A * option A) :=
  match function_parameter with
  | [] =&gt; Error_monad.ok (None, None)
  | cons a [] =&gt; Error_monad.ok (a, None)
  | cons a (cons b []) =&gt; Error_monad.ok (a, b)
  | _ =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition parse_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              get_one_annot loc types))).

Definition parse_type_field_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc types)
            (fun t =&gt;
              Error_monad.op_gtpipequestion (get_one_annot loc fields)
                (fun f =&gt; (t, f))))).

Definition parse_composed_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot *
      option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc types)
            (fun t =&gt;
              Error_monad.op_gtpipequestion (get_two_annot loc fields)
                (fun function_parameter =&gt;
                  let '(f1, f2) := function_parameter in
                  (t, f1, f2))))).

Definition parse_field_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc vars)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              get_one_annot loc fields))).

Definition extract_field_annot (function_parameter : Alpha_context.Script.node)
  : Error_monad.tzresult
    (Alpha_context.Script.node * option Script_typed_ir.field_annot) :=
  match function_parameter with
  | Micheline.Prim loc prim args annot =&gt;
    let fix extract_first (acc : list string) (function_parameter : list string)
      {struct acc} : option string * Micheline.annot :=
      match function_parameter with
      | [] =&gt; (None, annot)
      | cons s rest =&gt;
        if
          Pervasives.op_andand
            (Compare.Int.[Compare.S.op_gt] (String.length s) 0)
            (Compare.Char.[Compare.S.op_eq] (String.get s 0) &quot;%&quot; % char) then
          ((Some s), (List.rev_append acc rest))
        else
          extract_first (cons s acc) rest
      end in
    let '(field_annot, annot) := extract_first [] annot in
    let field_annot :=
      match field_annot with
      | None =&gt; None
      | Some field_annot =&gt;
        Some
          (* ‚ùå Variants not supported *)
          (* ‚ùå `Field_annot *)
          (String.sub field_annot 1
            (Pervasives.op_minus (String.length field_annot) 1))
      end in
    Error_monad.ok ((Micheline.Prim loc prim args annot), field_annot)
  | expr =&gt; Error_monad.ok (expr, None)
  end.

Definition check_correct_field
  (f1 : option Script_typed_ir.field_annot)
  (f2 : option Script_typed_ir.field_annot) : Error_monad.tzresult unit :=
  match (f1, f2) with
  | (None, _) | (_, None) =&gt; Error_monad.ok tt
  | (Some (Field_annot s1), Some (Field_annot s2)) =&gt;
    if String.equal s1 s2 then
      Error_monad.ok tt
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition parse_var_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.var_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtpipequestion (get_one_annot loc vars)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (Some _) as a =&gt; a
                  | None =&gt;
                    match default with
                    | Some a =&gt; a
                    | None =&gt; None
                    end
                  end)))).

Definition split_last_dot
  (function_parameter : option (* `Field_annot *) string)
  : option (* `Var_annot *) string * option (* `Field_annot *) string :=
  match function_parameter with
  | None =&gt; (None, None)
  | Some (Field_annot s) =&gt;
    match String.rindex_opt s &quot;.&quot; % char with
    | None =&gt;
      (None,
        (Some
          (* ‚ùå Variants not supported *)
          (* ‚ùå `Field_annot *)
          s))
    | Some i =&gt;
      let s1 := String.sub s 0 i in
      let s2 :=
        String.sub s (Pervasives.op_plus i 1)
          (Pervasives.op_minus (Pervasives.op_minus (String.length s) i) 1) in
      let f :=
        if
          Pervasives.op_pipepipe
            (Compare.String.[Compare.S.equal] s2 &quot;car&quot; % string)
            (Compare.String.[Compare.S.equal] s2 &quot;cdr&quot; % string) then
          None
        else
          Some
            (* ‚ùå Variants not supported *)
            (* ‚ùå `Field_annot *)
            s2 in
      ((Some
        (* ‚ùå Variants not supported *)
        (* ‚ùå `Var_annot *)
        s1), f)
    end
  end.

Definition common_prefix
  (v1 : option (* `Var_annot *) Compare.String.[Compare.S.t])
  (v2 : option (* `Var_annot *) Compare.String.[Compare.S.t])
  : option (* `Var_annot *) Compare.String.[Compare.S.t] :=
  match
    ((v1, v2),
      match (v1, v2) with
      | (Some (Var_annot s1), Some (Var_annot s2)) =&gt;
        Compare.String.[Compare.S.equal] s1 s2
      | _ =&gt; false
      end) with
  | ((Some (Var_annot s1), Some (Var_annot s2)), true) =&gt; v1
  | ((Some _, None), _) =&gt; v1
  | ((None, Some _), _) =&gt; v2
  | ((_, _), _) =&gt; None
  end.

Definition parse_constr_annot
  (loc : Z) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
      option Script_typed_ir.field_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None (Some true) annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (get_one_annot loc vars)
        (fun v =&gt;
          Error_monad.op_gtgtquestion (get_one_annot loc types)
            (fun t =&gt;
              Error_monad.op_gtgtquestion (get_two_annot loc fields)
                (fun function_parameter =&gt;
                  let '(f1, f2) := function_parameter in
                  Error_monad.op_gtgtquestion
                    match (if_special_first, f1) with
                    | (Some special_var, Some (Field_annot &quot;@&quot; % string)) =&gt;
                      Error_monad.ok (split_last_dot special_var)
                    | (None, Some (Field_annot &quot;@&quot; % string)) =&gt;
                      Error_monad.__error_value extensible_type_value
                    | (_, _) =&gt; Error_monad.ok (v, f1)
                    end
                    (fun function_parameter =&gt;
                      let '(v1, f1) := function_parameter in
                      Error_monad.op_gtpipequestion
                        match (if_special_second, f2) with
                        | (Some special_var, Some (Field_annot &quot;@&quot; % string)) =&gt;
                          Error_monad.ok (split_last_dot special_var)
                        | (None, Some (Field_annot &quot;@&quot; % string)) =&gt;
                          Error_monad.__error_value extensible_type_value
                        | (_, _) =&gt; Error_monad.ok (v, f2)
                        end
                        (fun function_parameter =&gt;
                          let '(v2, f2) := function_parameter in
                          let v :=
                            match v with
                            | None =&gt; common_prefix v1 v2
                            | Some _ =&gt; v
                            end in
                          (v, t, f1, f2))))))).

Definition parse_two_var_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              get_two_annot loc vars))).

Definition parse_destr_annot
  (loc : Z) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc (Some true) None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc vars)
            (fun v =&gt;
              Error_monad.op_gtpipequestion (get_one_annot loc fields)
                (fun f =&gt;
                  let default :=
                    gen_access_annot pair_annot (Some default_accessor)
                      field_name in
                  let v :=
                    match v with
                    | Some (Var_annot &quot;%&quot; % string) =&gt;
                      field_to_var_annot field_name
                    | Some (Var_annot &quot;%%&quot; % string) =&gt; default
                    | Some _ =&gt; v
                    | None =&gt; value_annot
                    end in
                  (v, f))))).

Definition parse_entrypoint_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc types)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc fields)
            (fun f =&gt;
              Error_monad.op_gtpipequestion (get_one_annot loc vars)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (Some _) as a =&gt; (a, f)
                  | None =&gt;
                    match default with
                    | Some a =&gt; (a, f)
                    | None =&gt; (None, f)
                    end
                  end)))).

Definition parse_var_type_annot (loc : Z) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot) :=
  Error_monad.op_gtgtquestion
    (Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc))
    (fun function_parameter =&gt;
      let '(vars, types, fields) := function_parameter in
      Error_monad.op_gtgtquestion (error_unexpected_annot loc fields)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtquestion (get_one_annot loc vars)
            (fun v =&gt;
              Error_monad.op_gtpipequestion (get_one_annot loc types)
                (fun t =&gt; (v, t))))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_annot.mli">
  <div class="col-md-6">
    <a href="#script_ir_annot.mli"><code>script_ir_annot.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script_typed_ir

(** Default annotations *)

val default_now_annot : var_annot option

val default_amount_annot : var_annot option

val default_balance_annot : var_annot option

val default_steps_annot : var_annot option

val default_source_annot : var_annot option

val default_sender_annot : var_annot option

val default_self_annot : var_annot option

val default_arg_annot : var_annot option

val default_param_annot : var_annot option

val default_storage_annot : var_annot option

val default_car_annot : field_annot option

val default_cdr_annot : field_annot option

val default_contract_annot : field_annot option

val default_addr_annot : field_annot option

val default_manager_annot : field_annot option

val default_pack_annot : field_annot option

val default_unpack_annot : field_annot option

val default_slice_annot : field_annot option

val default_elt_annot : field_annot option

val default_key_annot : field_annot option

val default_hd_annot : field_annot option

val default_tl_annot : field_annot option

val default_some_annot : field_annot option

val default_left_annot : field_annot option

val default_right_annot : field_annot option

val default_binding_annot : field_annot option

(** Unparse annotations to their string representation *)

val unparse_type_annot : type_annot option -&gt; string list

val unparse_var_annot : var_annot option -&gt; string list

val unparse_field_annot : field_annot option -&gt; string list

(** Convertions functions between different annotation kinds *)

val field_to_var_annot : field_annot option -&gt; var_annot option

val type_to_var_annot : type_annot option -&gt; var_annot option

val var_to_field_annot : var_annot option -&gt; field_annot option

(** Replace an annotation by its default value if it is [None] *)
val default_annot : default:'a option -&gt; 'a option -&gt; 'a option

(** Generate annotation for field accesses, of the form [var.field1.field2] *)
val gen_access_annot :
  var_annot option -&gt;
  ?default:field_annot option -&gt;
  field_annot option -&gt;
  var_annot option

(** Merge type annotations.
    @return an error {!Inconsistent_type_annotations} if they are both present
    and different, unless [legacy] *)
val merge_type_annot :
  legacy:bool -&gt;
  type_annot option -&gt;
  type_annot option -&gt;
  type_annot option tzresult

(** Merge field annotations.
    @return an error {!Inconsistent_type_annotations} if they are both present
    and different, unless [legacy] *)
val merge_field_annot :
  legacy:bool -&gt;
  field_annot option -&gt;
  field_annot option -&gt;
  field_annot option tzresult

(** Merge variable annotations, does not fail ([None] if different). *)
val merge_var_annot : var_annot option -&gt; var_annot option -&gt; var_annot option

(** @return an error {!Unexpected_annotation} in the monad the list is not empty. *)
val error_unexpected_annot : int -&gt; 'a list -&gt; unit tzresult

(** Same as {!error_unexpected_annot} in Lwt. *)
val fail_unexpected_annot : int -&gt; 'a list -&gt; unit tzresult Lwt.t

(** Parse a type annotation only. *)
val parse_type_annot : int -&gt; string list -&gt; type_annot option tzresult

(** Parse a field annotation only. *)
val parse_field_annot : int -&gt; string list -&gt; field_annot option tzresult

(** Parse an annotation for composed types, of the form
    [:ty_name %field] in any order. *)
val parse_type_field_annot :
  int -&gt; string list -&gt; (type_annot option * field_annot option) tzresult

(** Parse an annotation for composed types, of the form
    [:ty_name %field1 %field2] in any order. *)
val parse_composed_type_annot :
  int -&gt;
  string list -&gt;
  (type_annot option * field_annot option * field_annot option) tzresult

(** Extract and remove a field annotation from a node *)
val extract_field_annot :
  Script.node -&gt; (Script.node * field_annot option) tzresult

(** Check that field annotations match, used for field accesses. *)
val check_correct_field :
  field_annot option -&gt; field_annot option -&gt; unit tzresult

(** Instruction annotations parsing *)

(** Parse a variable annotation, replaced by a default value if [None]. *)
val parse_var_annot :
  int -&gt; ?default:var_annot option -&gt; string list -&gt; var_annot option tzresult

val parse_constr_annot :
  int -&gt;
  ?if_special_first:field_annot option -&gt;
  ?if_special_second:field_annot option -&gt;
  string list -&gt;
  ( var_annot option
  * type_annot option
  * field_annot option
  * field_annot option )
  tzresult

val parse_two_var_annot :
  int -&gt; string list -&gt; (var_annot option * var_annot option) tzresult

val parse_destr_annot :
  int -&gt;
  string list -&gt;
  default_accessor:field_annot option -&gt;
  field_name:field_annot option -&gt;
  pair_annot:var_annot option -&gt;
  value_annot:var_annot option -&gt;
  (var_annot option * field_annot option) tzresult

val parse_entrypoint_annot :
  int -&gt;
  ?default:var_annot option -&gt;
  string list -&gt;
  (var_annot option * field_annot option) tzresult

val parse_var_type_annot :
  int -&gt; string list -&gt; (var_annot option * type_annot option) tzresult
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_annot.mli"><code>Script_ir_annot_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Script_typed_ir.

Parameter default_now_annot : option Script_typed_ir.var_annot.

Parameter default_amount_annot : option Script_typed_ir.var_annot.

Parameter default_balance_annot : option Script_typed_ir.var_annot.

Parameter default_steps_annot : option Script_typed_ir.var_annot.

Parameter default_source_annot : option Script_typed_ir.var_annot.

Parameter default_sender_annot : option Script_typed_ir.var_annot.

Parameter default_self_annot : option Script_typed_ir.var_annot.

Parameter default_arg_annot : option Script_typed_ir.var_annot.

Parameter default_param_annot : option Script_typed_ir.var_annot.

Parameter default_storage_annot : option Script_typed_ir.var_annot.

Parameter default_car_annot : option Script_typed_ir.field_annot.

Parameter default_cdr_annot : option Script_typed_ir.field_annot.

Parameter default_contract_annot : option Script_typed_ir.field_annot.

Parameter default_addr_annot : option Script_typed_ir.field_annot.

Parameter default_manager_annot : option Script_typed_ir.field_annot.

Parameter default_pack_annot : option Script_typed_ir.field_annot.

Parameter default_unpack_annot : option Script_typed_ir.field_annot.

Parameter default_slice_annot : option Script_typed_ir.field_annot.

Parameter default_elt_annot : option Script_typed_ir.field_annot.

Parameter default_key_annot : option Script_typed_ir.field_annot.

Parameter default_hd_annot : option Script_typed_ir.field_annot.

Parameter default_tl_annot : option Script_typed_ir.field_annot.

Parameter default_some_annot : option Script_typed_ir.field_annot.

Parameter default_left_annot : option Script_typed_ir.field_annot.

Parameter default_right_annot : option Script_typed_ir.field_annot.

Parameter default_binding_annot : option Script_typed_ir.field_annot.

Parameter unparse_type_annot : option Script_typed_ir.type_annot -&gt; list string.

Parameter unparse_var_annot : option Script_typed_ir.var_annot -&gt; list string.

Parameter unparse_field_annot :
  option Script_typed_ir.field_annot -&gt; list string.

Parameter field_to_var_annot :
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot.

Parameter type_to_var_annot :
  option Script_typed_ir.type_annot -&gt; option Script_typed_ir.var_annot.

Parameter var_to_field_annot :
  option Script_typed_ir.var_annot -&gt; option Script_typed_ir.field_annot.

Parameter default_annot : forall {a : Set}, option a -&gt; option a -&gt; option a.

Parameter gen_access_annot :
  option Script_typed_ir.var_annot -&gt;
  option (option Script_typed_ir.field_annot) -&gt;
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot.

Parameter merge_type_annot :
  bool -&gt; option Script_typed_ir.type_annot -&gt;
  option Script_typed_ir.type_annot -&gt;
  Error_monad.tzresult (option Script_typed_ir.type_annot).

Parameter merge_field_annot :
  bool -&gt; option Script_typed_ir.field_annot -&gt;
  option Script_typed_ir.field_annot -&gt;
  Error_monad.tzresult (option Script_typed_ir.field_annot).

Parameter merge_var_annot :
  option Script_typed_ir.var_annot -&gt; option Script_typed_ir.var_annot -&gt;
  option Script_typed_ir.var_annot.

Parameter error_unexpected_annot : forall {a : Set},
  Z -&gt; list a -&gt; Error_monad.tzresult unit.

Parameter fail_unexpected_annot : forall {a : Set},
  Z -&gt; list a -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter parse_type_annot :
  Z -&gt; list string -&gt; Error_monad.tzresult (option Script_typed_ir.type_annot).

Parameter parse_field_annot :
  Z -&gt; list string -&gt; Error_monad.tzresult (option Script_typed_ir.field_annot).

Parameter parse_type_field_annot :
  Z -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot).

Parameter parse_composed_type_annot :
  Z -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot *
      option Script_typed_ir.field_annot).

Parameter extract_field_annot :
  Alpha_context.Script.node -&gt;
  Error_monad.tzresult
    (Alpha_context.Script.node * option Script_typed_ir.field_annot).

Parameter check_correct_field :
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.field_annot -&gt;
  Error_monad.tzresult unit.

Parameter parse_var_annot :
  Z -&gt; option (option Script_typed_ir.var_annot) -&gt; list string -&gt;
  Error_monad.tzresult (option Script_typed_ir.var_annot).

Parameter parse_constr_annot :
  Z -&gt; option (option Script_typed_ir.field_annot) -&gt;
  option (option Script_typed_ir.field_annot) -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
      option Script_typed_ir.field_annot * option Script_typed_ir.field_annot).

Parameter parse_two_var_annot :
  Z -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot).

Parameter parse_destr_annot :
  Z -&gt; list string -&gt; option Script_typed_ir.field_annot -&gt;
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot -&gt;
  option Script_typed_ir.var_annot -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot).

Parameter parse_entrypoint_annot :
  Z -&gt; option (option Script_typed_ir.var_annot) -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot).

Parameter parse_var_type_annot :
  Z -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_translator.ml">
  <div class="col-md-6">
    <a href="#script_ir_translator.ml"><code>script_ir_translator.ml</code></a>&nbsp;<span class="label label-danger">264 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Micheline
open Script
open Script_typed_ir
open Script_tc_errors
open Script_ir_annot
module Typecheck_costs = Michelson_v1_gas.Cost_of.Typechecking
module Unparse_costs = Michelson_v1_gas.Cost_of.Unparse

type ex_comparable_ty =
  | Ex_comparable_ty : 'a comparable_ty -&gt; ex_comparable_ty

type ex_ty = Ex_ty : 'a ty -&gt; ex_ty

type ex_stack_ty = Ex_stack_ty : 'a stack_ty -&gt; ex_stack_ty

type tc_context =
  | Lambda : tc_context
  | Dip : 'a stack_ty * tc_context -&gt; tc_context
  | Toplevel : {
      storage_type : 'sto ty;
      param_type : 'param ty;
      root_name : string option;
      legacy_create_contract_literal : bool;
    }
      -&gt; tc_context

type unparsing_mode = Optimized | Readable

type type_logger =
  int -&gt;
  (Script.expr * Script.annot) list -&gt;
  (Script.expr * Script.annot) list -&gt;
  unit

let add_dip ty annot prev =
  match prev with
  | Lambda | Toplevel _ -&gt;
      Dip (Item_t (ty, Empty_t, annot), prev)
  | Dip (stack, _) -&gt;
      Dip (Item_t (ty, stack, annot), prev)

(* ---- Type size accounting ------------------------------------------------*)

let rec comparable_type_size : type t a. (t, a) comparable_struct -&gt; int =
 fun ty -&gt;
  (* No wildcard to force the update when comparable_ty chages. *)
  match ty with
  | Int_key _ -&gt;
      1
  | Nat_key _ -&gt;
      1
  | String_key _ -&gt;
      1
  | Bytes_key _ -&gt;
      1
  | Mutez_key _ -&gt;
      1
  | Bool_key _ -&gt;
      1
  | Key_hash_key _ -&gt;
      1
  | Timestamp_key _ -&gt;
      1
  | Address_key _ -&gt;
      1
  | Pair_key (_, (t, _), _) -&gt;
      1 + comparable_type_size t

let rec type_size : type t. t ty -&gt; int =
 fun ty -&gt;
  match ty with
  | Unit_t _ -&gt;
      1
  | Int_t _ -&gt;
      1
  | Nat_t _ -&gt;
      1
  | Signature_t _ -&gt;
      1
  | Bytes_t _ -&gt;
      1
  | String_t _ -&gt;
      1
  | Mutez_t _ -&gt;
      1
  | Key_hash_t _ -&gt;
      1
  | Key_t _ -&gt;
      1
  | Timestamp_t _ -&gt;
      1
  | Address_t _ -&gt;
      1
  | Bool_t _ -&gt;
      1
  | Operation_t _ -&gt;
      1
  | Pair_t ((l, _, _), (r, _, _), _, _) -&gt;
      1 + type_size l + type_size r
  | Union_t ((l, _), (r, _), _, _) -&gt;
      1 + type_size l + type_size r
  | Lambda_t (arg, ret, _) -&gt;
      1 + type_size arg + type_size ret
  | Option_t (t, _, _) -&gt;
      1 + type_size t
  | List_t (t, _, _) -&gt;
      1 + type_size t
  | Set_t (k, _) -&gt;
      1 + comparable_type_size k
  | Map_t (k, v, _, _) -&gt;
      1 + comparable_type_size k + type_size v
  | Big_map_t (k, v, _) -&gt;
      1 + comparable_type_size k + type_size v
  | Contract_t (arg, _) -&gt;
      1 + type_size arg
  | Chain_id_t _ -&gt;
      1

let rec type_size_of_stack_head : type st. st stack_ty -&gt; up_to:int -&gt; int =
 fun stack ~up_to -&gt;
  match stack with
  | Empty_t -&gt;
      0
  | Item_t (head, tail, _annot) -&gt;
      if Compare.Int.(up_to &gt; 0) then
        Compare.Int.max
          (type_size head)
          (type_size_of_stack_head tail ~up_to:(up_to - 1))
      else 0

(* This is the depth of the stack to inspect for sizes overflow. We
   only need to check the produced types that can be larger than the
   arguments. That's why Swap is 0 for instance as no type grows.
   Constant sized types are not checked: it is assumed they are lower
   than the bound (otherwise every program would be rejected). *)
let number_of_generated_growing_types : type b a. (b, a) instr -&gt; int =
  function
  | Drop -&gt;
      0
  | Dup -&gt;
      0
  | Swap -&gt;
      0
  | Const _ -&gt;
      1
  | Cons_pair -&gt;
      1
  | Car -&gt;
      0
  | Cdr -&gt;
      0
  | Cons_some -&gt;
      1
  | Cons_none _ -&gt;
      1
  | If_none _ -&gt;
      0
  | Left -&gt;
      0
  | Right -&gt;
      0
  | If_left _ -&gt;
      0
  | Cons_list -&gt;
      1
  | Nil -&gt;
      1
  | If_cons _ -&gt;
      0
  | List_map _ -&gt;
      1
  | List_size -&gt;
      0
  | List_iter _ -&gt;
      1
  | Empty_set _ -&gt;
      1
  | Set_iter _ -&gt;
      0
  | Set_mem -&gt;
      0
  | Set_update -&gt;
      0
  | Set_size -&gt;
      0
  | Empty_map _ -&gt;
      1
  | Map_map _ -&gt;
      1
  | Map_iter _ -&gt;
      1
  | Map_mem -&gt;
      0
  | Map_get -&gt;
      0
  | Map_update -&gt;
      0
  | Map_size -&gt;
      0
  | Empty_big_map _ -&gt;
      1
  | Big_map_get -&gt;
      0
  | Big_map_update -&gt;
      0
  | Big_map_mem -&gt;
      0
  | Concat_string -&gt;
      0
  | Concat_string_pair -&gt;
      0
  | Slice_string -&gt;
      0
  | String_size -&gt;
      0
  | Concat_bytes -&gt;
      0
  | Concat_bytes_pair -&gt;
      0
  | Slice_bytes -&gt;
      0
  | Bytes_size -&gt;
      0
  | Add_seconds_to_timestamp -&gt;
      0
  | Add_timestamp_to_seconds -&gt;
      0
  | Sub_timestamp_seconds -&gt;
      0
  | Diff_timestamps -&gt;
      0
  | Add_tez -&gt;
      0
  | Sub_tez -&gt;
      0
  | Mul_teznat -&gt;
      0
  | Mul_nattez -&gt;
      0
  | Ediv_teznat -&gt;
      0
  | Ediv_tez -&gt;
      0
  | Or -&gt;
      0
  | And -&gt;
      0
  | Xor -&gt;
      0
  | Not -&gt;
      0
  | Is_nat -&gt;
      0
  | Neg_nat -&gt;
      0
  | Neg_int -&gt;
      0
  | Abs_int -&gt;
      0
  | Int_nat -&gt;
      0
  | Add_intint -&gt;
      0
  | Add_intnat -&gt;
      0
  | Add_natint -&gt;
      0
  | Add_natnat -&gt;
      0
  | Sub_int -&gt;
      0
  | Mul_intint -&gt;
      0
  | Mul_intnat -&gt;
      0
  | Mul_natint -&gt;
      0
  | Mul_natnat -&gt;
      0
  | Ediv_intint -&gt;
      0
  | Ediv_intnat -&gt;
      0
  | Ediv_natint -&gt;
      0
  | Ediv_natnat -&gt;
      0
  | Lsl_nat -&gt;
      0
  | Lsr_nat -&gt;
      0
  | Or_nat -&gt;
      0
  | And_nat -&gt;
      0
  | And_int_nat -&gt;
      0
  | Xor_nat -&gt;
      0
  | Not_nat -&gt;
      0
  | Not_int -&gt;
      0
  | Seq _ -&gt;
      0
  | If _ -&gt;
      0
  | Loop _ -&gt;
      0
  | Loop_left _ -&gt;
      0
  | Dip _ -&gt;
      0
  | Exec -&gt;
      0
  | Apply _ -&gt;
      0
  | Lambda _ -&gt;
      1
  | Failwith _ -&gt;
      1
  | Nop -&gt;
      0
  | Compare _ -&gt;
      1
  | Eq -&gt;
      0
  | Neq -&gt;
      0
  | Lt -&gt;
      0
  | Gt -&gt;
      0
  | Le -&gt;
      0
  | Ge -&gt;
      0
  | Address -&gt;
      0
  | Contract _ -&gt;
      1
  | Transfer_tokens -&gt;
      1
  | Create_account -&gt;
      0
  | Implicit_account -&gt;
      0
  | Create_contract _ -&gt;
      1
  | Create_contract_2 _ -&gt;
      1
  | Now -&gt;
      0
  | Balance -&gt;
      0
  | Check_signature -&gt;
      0
  | Hash_key -&gt;
      0
  | Blake2b -&gt;
      0
  | Sha256 -&gt;
      0
  | Sha512 -&gt;
      0
  | Steps_to_quota -&gt;
      0
  | Source -&gt;
      0
  | Sender -&gt;
      0
  | Self _ -&gt;
      1
  | Amount -&gt;
      0
  | Set_delegate -&gt;
      0
  | Pack _ -&gt;
      0
  | Unpack _ -&gt;
      1
  | Dig _ -&gt;
      0
  | Dug _ -&gt;
      0
  | Dipn _ -&gt;
      0
  | Dropn _ -&gt;
      0
  | ChainId -&gt;
      0

(* ---- Error helpers -------------------------------------------------------*)

let location = function
  | Prim (loc, _, _, _)
  | Int (loc, _)
  | String (loc, _)
  | Bytes (loc, _)
  | Seq (loc, _) -&gt;
      loc

let kind = function
  | Int _ -&gt;
      Int_kind
  | String _ -&gt;
      String_kind
  | Bytes _ -&gt;
      Bytes_kind
  | Prim _ -&gt;
      Prim_kind
  | Seq _ -&gt;
      Seq_kind

let namespace = function
  | K_parameter | K_storage | K_code -&gt;
      Keyword_namespace
  | D_False
  | D_Elt
  | D_Left
  | D_None
  | D_Pair
  | D_Right
  | D_Some
  | D_True
  | D_Unit -&gt;
      Constant_namespace
  | I_PACK
  | I_UNPACK
  | I_BLAKE2B
  | I_SHA256
  | I_SHA512
  | I_ABS
  | I_ADD
  | I_AMOUNT
  | I_AND
  | I_BALANCE
  | I_CAR
  | I_CDR
  | I_CHAIN_ID
  | I_CHECK_SIGNATURE
  | I_COMPARE
  | I_CONCAT
  | I_CONS
  | I_CREATE_ACCOUNT
  | I_CREATE_CONTRACT
  | I_IMPLICIT_ACCOUNT
  | I_DIP
  | I_DROP
  | I_DUP
  | I_EDIV
  | I_EMPTY_BIG_MAP
  | I_EMPTY_MAP
  | I_EMPTY_SET
  | I_EQ
  | I_EXEC
  | I_APPLY
  | I_FAILWITH
  | I_GE
  | I_GET
  | I_GT
  | I_HASH_KEY
  | I_IF
  | I_IF_CONS
  | I_IF_LEFT
  | I_IF_NONE
  | I_INT
  | I_LAMBDA
  | I_LE
  | I_LEFT
  | I_LOOP
  | I_LSL
  | I_LSR
  | I_LT
  | I_MAP
  | I_MEM
  | I_MUL
  | I_NEG
  | I_NEQ
  | I_NIL
  | I_NONE
  | I_NOT
  | I_NOW
  | I_OR
  | I_PAIR
  | I_PUSH
  | I_RIGHT
  | I_SIZE
  | I_SOME
  | I_SOURCE
  | I_SENDER
  | I_SELF
  | I_SLICE
  | I_STEPS_TO_QUOTA
  | I_SUB
  | I_SWAP
  | I_TRANSFER_TOKENS
  | I_SET_DELEGATE
  | I_UNIT
  | I_UPDATE
  | I_XOR
  | I_ITER
  | I_LOOP_LEFT
  | I_ADDRESS
  | I_CONTRACT
  | I_ISNAT
  | I_CAST
  | I_RENAME
  | I_DIG
  | I_DUG -&gt;
      Instr_namespace
  | T_bool
  | T_contract
  | T_int
  | T_key
  | T_key_hash
  | T_lambda
  | T_list
  | T_map
  | T_big_map
  | T_nat
  | T_option
  | T_or
  | T_pair
  | T_set
  | T_signature
  | T_string
  | T_bytes
  | T_mutez
  | T_timestamp
  | T_unit
  | T_operation
  | T_address
  | T_chain_id -&gt;
      Type_namespace

let unexpected expr exp_kinds exp_ns exp_prims =
  match expr with
  | Int (loc, _) -&gt;
      <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_kind (loc, Prim_kind :: exp_kinds, Int_kind)</abbr>
  | String (loc, _) -&gt;
      <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_kind (loc, Prim_kind :: exp_kinds, String_kind)</abbr>
  | Bytes (loc, _) -&gt;
      <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_kind (loc, Prim_kind :: exp_kinds, Bytes_kind)</abbr>
  | Seq (loc, _) -&gt;
      <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_kind (loc, Prim_kind :: exp_kinds, Seq_kind)</abbr>
  | Prim (loc, name, _, _) -&gt; (
    match (namespace name, exp_ns) with
    | (Type_namespace, Type_namespace)
    | (Instr_namespace, Instr_namespace)
    | (Constant_namespace, Constant_namespace) -&gt;
        <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_primitive (loc, exp_prims, name)</abbr>
    | (ns, _) -&gt;
        <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_namespace (loc, name, exp_ns, ns)</abbr> )

let check_kind kinds expr =
  let kind = kind expr in
  if List.mem kind kinds then return_unit
  else
    let loc = location expr in
    fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, kinds, kind))</abbr>

(* ---- Sets and Maps -------------------------------------------------------*)

let wrap_compare compare a b =
  let res = compare a b in
  if Compare.Int.(res = 0) then 0 else if Compare.Int.(res &gt; 0) then 1 else -1

let rec compare_comparable :
    type a s. (a, s) comparable_struct -&gt; a -&gt; a -&gt; int =
 fun kind -&gt;
  match kind with
  | String_key _ -&gt;
      wrap_compare Compare.String.compare
  | Bool_key _ -&gt;
      wrap_compare Compare.Bool.compare
  | Mutez_key _ -&gt;
      wrap_compare Tez.compare
  | Key_hash_key _ -&gt;
      wrap_compare Signature.Public_key_hash.compare
  | Int_key _ -&gt;
      wrap_compare Script_int.compare
  | Nat_key _ -&gt;
      wrap_compare Script_int.compare
  | Timestamp_key _ -&gt;
      wrap_compare Script_timestamp.compare
  | Address_key _ -&gt;
      wrap_compare
      @@ fun (x, ex) (y, ey) -&gt;
      let lres = Contract.compare x y in
      if Compare.Int.(lres = 0) then Compare.String.compare ex ey else lres
  | Bytes_key _ -&gt;
      wrap_compare MBytes.compare
  | Pair_key ((tl, _), (tr, _), _) -&gt;
      fun (lx, rx) (ly, ry) -&gt;
        let lres = compare_comparable tl lx ly in
        if Compare.Int.(lres = 0) then compare_comparable tr rx ry else lres

let empty_set : type a. a comparable_ty -&gt; a set =
 fun ty -&gt;
  let module OPS = Set.Make (struct
    type t = a

    let compare = compare_comparable ty
  end) in
  ( module <abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
    type elt = a

    let elt_ty = ty

    module OPS = OPS

    let boxed = OPS.empty

    let size = 0
  end</abbr> )

let set_update : type a. a -&gt; bool -&gt; a set -&gt; a set =
 fun v b (module Box) -&gt;
  ( module <abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
    type elt = a

    let elt_ty = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.elt_ty</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    module OPS = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    let boxed =
      if b then </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.add</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> v </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> else </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.remove</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> v </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    let size =
      let mem = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.mem</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> v </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> in
      if mem then if b then </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.size</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> else </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.size</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> - 1
      else if b then </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.size</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> + 1
      else </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.size</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">
  end</abbr> )

let set_mem : type elt. elt -&gt; elt set -&gt; bool =
 fun v (module Box) -&gt; <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.mem</abbr> v <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr>

let set_fold : type elt acc. (elt -&gt; acc -&gt; acc) -&gt; elt set -&gt; acc -&gt; acc =
 fun f (module Box) -&gt; <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.fold</abbr> f <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr>

let set_size : type elt. elt set -&gt; Script_int.n Script_int.num =
 fun (module Box) -&gt; Script_int.(abs (of_int <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_set, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_set

We were looking for a module signature name for the following shape:
[ elt_ty; OPS; boxed; size ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.size</abbr>))

let map_key_ty : type a b. (a, b) map -&gt; a comparable_ty =
 fun (module Box) -&gt; <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.key_ty</abbr>

let empty_map : type a b. a comparable_ty -&gt; (a, b) map =
 fun ty -&gt;
  let module OPS = Map.Make (struct
    type t = a

    let compare = compare_comparable ty
  end) in
  ( module <abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
    type key = a

    type value = b

    let key_ty = ty

    module OPS = OPS

    let boxed = (OPS.empty, 0)
  end</abbr> )

let map_get : type key value. key -&gt; (key, value) map -&gt; value option =
 fun k (module Box) -&gt; <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.find_opt</abbr> k (fst <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr>)

let map_update : type a b. a -&gt; b option -&gt; (a, b) map -&gt; (a, b) map =
 fun k v (module Box) -&gt;
  ( module <abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
    type key = a

    type value = b

    let key_ty = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.key_ty</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    module OPS = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    let boxed =
      let (map, size) = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> in
      let contains = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.mem</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> k map in
      match v with
      | Some v -&gt;
          (</abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.add</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> k v map, size + if contains then 0 else 1)
      | None -&gt;
          (</abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.remove</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> k map, size - if contains then 1 else 0)
  end</abbr> )

let map_set : type a b. a -&gt; b -&gt; (a, b) map -&gt; (a, b) map =
 fun k v (module Box) -&gt;
  ( module <abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
    type key = a

    type value = b

    let key_ty = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.key_ty</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    module OPS = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    let boxed =
      let (map, size) = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> in
      (</abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.add</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> k v map, if </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.mem</abbr><abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq."> k map then size else size + 1)
  end</abbr> )

let map_mem : type key value. key -&gt; (key, value) map -&gt; bool =
 fun k (module Box) -&gt; <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.mem</abbr> k (fst <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr>)

let map_fold :
    type key value acc.
    (key -&gt; value -&gt; acc -&gt; acc) -&gt; (key, value) map -&gt; acc -&gt; acc =
 fun f (module Box) -&gt; <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.OPS.fold</abbr> f (fst <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr>)

let map_size : type key value. (key, value) map -&gt; Script_int.n Script_int.num
    =
 fun (module Box) -&gt; Script_int.(abs (of_int (snd <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Box.boxed</abbr>)))

(* ---- Unparsing (Typed IR -&gt; Untyped expressions) of types -----------------*)

let rec ty_of_comparable_ty : type a s. (a, s) comparable_struct -&gt; a ty =
  function
  | Int_key tname -&gt;
      Int_t tname
  | Nat_key tname -&gt;
      Nat_t tname
  | String_key tname -&gt;
      String_t tname
  | Bytes_key tname -&gt;
      Bytes_t tname
  | Mutez_key tname -&gt;
      Mutez_t tname
  | Bool_key tname -&gt;
      Bool_t tname
  | Key_hash_key tname -&gt;
      Key_hash_t tname
  | Timestamp_key tname -&gt;
      Timestamp_t tname
  | Address_key tname -&gt;
      Address_t tname
  | Pair_key ((l, al), (r, ar), tname) -&gt;
      Pair_t
        ( (ty_of_comparable_ty l, al, None),
          (ty_of_comparable_ty r, ar, None),
          tname,
          false )

let rec comparable_ty_of_ty : type a. a ty -&gt; a comparable_ty option = function
  | Int_t tname -&gt;
      Some (Int_key tname)
  | Nat_t tname -&gt;
      Some (Nat_key tname)
  | String_t tname -&gt;
      Some (String_key tname)
  | Bytes_t tname -&gt;
      Some (Bytes_key tname)
  | Mutez_t tname -&gt;
      Some (Mutez_key tname)
  | Bool_t tname -&gt;
      Some (Bool_key tname)
  | Key_hash_t tname -&gt;
      Some (Key_hash_key tname)
  | Timestamp_t tname -&gt;
      Some (Timestamp_key tname)
  | Address_t tname -&gt;
      Some (Address_key tname)
  | Pair_t ((l, al, _), (r, ar, _), pname, _) -&gt; (
    match comparable_ty_of_ty r with
    | None -&gt;
        None
    | Some rty -&gt; (
      match comparable_ty_of_ty l with
      | None -&gt;
          None
      | Some (Pair_key _) -&gt;
          None (* not a comb *)
      | Some (Int_key tname) -&gt;
          Some (Pair_key ((Int_key tname, al), (rty, ar), pname))
      | Some (Nat_key tname) -&gt;
          Some (Pair_key ((Nat_key tname, al), (rty, ar), pname))
      | Some (String_key tname) -&gt;
          Some (Pair_key ((String_key tname, al), (rty, ar), pname))
      | Some (Bytes_key tname) -&gt;
          Some (Pair_key ((Bytes_key tname, al), (rty, ar), pname))
      | Some (Mutez_key tname) -&gt;
          Some (Pair_key ((Mutez_key tname, al), (rty, ar), pname))
      | Some (Bool_key tname) -&gt;
          Some (Pair_key ((Bool_key tname, al), (rty, ar), pname))
      | Some (Key_hash_key tname) -&gt;
          Some (Pair_key ((Key_hash_key tname, al), (rty, ar), pname))
      | Some (Timestamp_key tname) -&gt;
          Some (Pair_key ((Timestamp_key tname, al), (rty, ar), pname))
      | Some (Address_key tname) -&gt;
          Some (Pair_key ((Address_key tname, al), (rty, ar), pname)) ) )
  | _ -&gt;
      None

let add_field_annot a var = function
  | Prim (loc, prim, args, annots) -&gt;
      Prim
        ( loc,
          prim,
          args,
          annots @ unparse_field_annot a @ unparse_var_annot var )
  | expr -&gt;
      expr

let rec unparse_comparable_ty :
    type a s. (a, s) comparable_struct -&gt; Script.node = function
  | Int_key tname -&gt;
      Prim (-1, T_int, [], unparse_type_annot tname)
  | Nat_key tname -&gt;
      Prim (-1, T_nat, [], unparse_type_annot tname)
  | String_key tname -&gt;
      Prim (-1, T_string, [], unparse_type_annot tname)
  | Bytes_key tname -&gt;
      Prim (-1, T_bytes, [], unparse_type_annot tname)
  | Mutez_key tname -&gt;
      Prim (-1, T_mutez, [], unparse_type_annot tname)
  | Bool_key tname -&gt;
      Prim (-1, T_bool, [], unparse_type_annot tname)
  | Key_hash_key tname -&gt;
      Prim (-1, T_key_hash, [], unparse_type_annot tname)
  | Timestamp_key tname -&gt;
      Prim (-1, T_timestamp, [], unparse_type_annot tname)
  | Address_key tname -&gt;
      Prim (-1, T_address, [], unparse_type_annot tname)
  | Pair_key ((l, al), (r, ar), pname) -&gt;
      let tl = add_field_annot al None (unparse_comparable_ty l) in
      let tr = add_field_annot ar None (unparse_comparable_ty r) in
      Prim (-1, T_pair, [tl; tr], unparse_type_annot pname)

let rec unparse_ty_no_lwt :
    type a. context -&gt; a ty -&gt; (Script.node * context) tzresult =
 fun ctxt ty -&gt;
  Gas.consume ctxt Unparse_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  let return ctxt (name, args, annot) =
    let result = Prim (-1, name, args, annot) in
    Gas.consume ctxt (Unparse_costs.prim_cost (List.length args) annot)
    &gt;&gt;? fun ctxt -&gt; ok (result, ctxt)
  in
  match ty with
  | Unit_t tname -&gt;
      return ctxt (T_unit, [], unparse_type_annot tname)
  | Int_t tname -&gt;
      return ctxt (T_int, [], unparse_type_annot tname)
  | Nat_t tname -&gt;
      return ctxt (T_nat, [], unparse_type_annot tname)
  | String_t tname -&gt;
      return ctxt (T_string, [], unparse_type_annot tname)
  | Bytes_t tname -&gt;
      return ctxt (T_bytes, [], unparse_type_annot tname)
  | Mutez_t tname -&gt;
      return ctxt (T_mutez, [], unparse_type_annot tname)
  | Bool_t tname -&gt;
      return ctxt (T_bool, [], unparse_type_annot tname)
  | Key_hash_t tname -&gt;
      return ctxt (T_key_hash, [], unparse_type_annot tname)
  | Key_t tname -&gt;
      return ctxt (T_key, [], unparse_type_annot tname)
  | Timestamp_t tname -&gt;
      return ctxt (T_timestamp, [], unparse_type_annot tname)
  | Address_t tname -&gt;
      return ctxt (T_address, [], unparse_type_annot tname)
  | Signature_t tname -&gt;
      return ctxt (T_signature, [], unparse_type_annot tname)
  | Operation_t tname -&gt;
      return ctxt (T_operation, [], unparse_type_annot tname)
  | Chain_id_t tname -&gt;
      return ctxt (T_chain_id, [], unparse_type_annot tname)
  | Contract_t (ut, tname) -&gt;
      unparse_ty_no_lwt ctxt ut
      &gt;&gt;? fun (t, ctxt) -&gt;
      return ctxt (T_contract, [t], unparse_type_annot tname)
  | Pair_t ((utl, l_field, l_var), (utr, r_field, r_var), tname, _) -&gt;
      let annot = unparse_type_annot tname in
      unparse_ty_no_lwt ctxt utl
      &gt;&gt;? fun (utl, ctxt) -&gt;
      let tl = add_field_annot l_field l_var utl in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (utr, ctxt) -&gt;
      let tr = add_field_annot r_field r_var utr in
      return ctxt (T_pair, [tl; tr], annot)
  | Union_t ((utl, l_field), (utr, r_field), tname, _) -&gt;
      let annot = unparse_type_annot tname in
      unparse_ty_no_lwt ctxt utl
      &gt;&gt;? fun (utl, ctxt) -&gt;
      let tl = add_field_annot l_field None utl in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (utr, ctxt) -&gt;
      let tr = add_field_annot r_field None utr in
      return ctxt (T_or, [tl; tr], annot)
  | Lambda_t (uta, utr, tname) -&gt;
      unparse_ty_no_lwt ctxt uta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (tr, ctxt) -&gt;
      return ctxt (T_lambda, [ta; tr], unparse_type_annot tname)
  | Option_t (ut, tname, _) -&gt;
      let annot = unparse_type_annot tname in
      unparse_ty_no_lwt ctxt ut
      &gt;&gt;? fun (ut, ctxt) -&gt; return ctxt (T_option, [ut], annot)
  | List_t (ut, tname, _) -&gt;
      unparse_ty_no_lwt ctxt ut
      &gt;&gt;? fun (t, ctxt) -&gt; return ctxt (T_list, [t], unparse_type_annot tname)
  | Set_t (ut, tname) -&gt;
      let t = unparse_comparable_ty ut in
      return ctxt (T_set, [t], unparse_type_annot tname)
  | Map_t (uta, utr, tname, _) -&gt;
      let ta = unparse_comparable_ty uta in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (tr, ctxt) -&gt;
      return ctxt (T_map, [ta; tr], unparse_type_annot tname)
  | Big_map_t (uta, utr, tname) -&gt;
      let ta = unparse_comparable_ty uta in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (tr, ctxt) -&gt;
      return ctxt (T_big_map, [ta; tr], unparse_type_annot tname)

let unparse_ty ctxt ty = Lwt.return (unparse_ty_no_lwt ctxt ty)

let rec strip_var_annots = function
  | (Int _ | String _ | Bytes _) as atom -&gt;
      atom
  | Seq (loc, args) -&gt;
      Seq (loc, List.map strip_var_annots args)
  | Prim (loc, name, args, annots) -&gt;
      let not_var_annot s = Compare.Char.(s.[0] &lt;&gt; '@') in
      let annots = List.filter not_var_annot annots in
      Prim (loc, name, List.map strip_var_annots args, annots)

let serialize_ty_for_error ctxt ty =
  unparse_ty_no_lwt ctxt ty
  |&gt; record_trace <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_serialize_error</abbr>
  &gt;|? fun (ty, ctxt) -&gt; (strip_locations (strip_var_annots ty), ctxt)

let rec unparse_stack :
    type a.
    context -&gt;
    a stack_ty -&gt;
    ((Script.expr * Script.annot) list * context) tzresult Lwt.t =
 fun ctxt -&gt; function
  | Empty_t -&gt;
      return ([], ctxt)
  | Item_t (ty, rest, annot) -&gt;
      unparse_ty ctxt ty
      &gt;&gt;=? fun (uty, ctxt) -&gt;
      unparse_stack ctxt rest
      &gt;&gt;=? fun (urest, ctxt) -&gt;
      return ((strip_locations uty, unparse_var_annot annot) :: urest, ctxt)

let serialize_stack_for_error ctxt stack_ty =
  trace <abbr class="mark-error" title="Values of extensible types are not handled">Cannot_serialize_error</abbr> (unparse_stack ctxt stack_ty)

let name_of_ty : type a. a ty -&gt; type_annot option = function
  | Unit_t tname -&gt;
      tname
  | Int_t tname -&gt;
      tname
  | Nat_t tname -&gt;
      tname
  | String_t tname -&gt;
      tname
  | Bytes_t tname -&gt;
      tname
  | Mutez_t tname -&gt;
      tname
  | Bool_t tname -&gt;
      tname
  | Key_hash_t tname -&gt;
      tname
  | Key_t tname -&gt;
      tname
  | Timestamp_t tname -&gt;
      tname
  | Address_t tname -&gt;
      tname
  | Signature_t tname -&gt;
      tname
  | Operation_t tname -&gt;
      tname
  | Chain_id_t tname -&gt;
      tname
  | Contract_t (_, tname) -&gt;
      tname
  | Pair_t (_, _, tname, _) -&gt;
      tname
  | Union_t (_, _, tname, _) -&gt;
      tname
  | Lambda_t (_, _, tname) -&gt;
      tname
  | Option_t (_, tname, _) -&gt;
      tname
  | List_t (_, tname, _) -&gt;
      tname
  | Set_t (_, tname) -&gt;
      tname
  | Map_t (_, _, tname, _) -&gt;
      tname
  | Big_map_t (_, _, tname) -&gt;
      tname

(* ---- Equality witnesses --------------------------------------------------*)

type ('ta, 'tb) eq = Eq : ('same, 'same) eq

let comparable_ty_eq :
    type ta tb.
    context -&gt;
    ta comparable_ty -&gt;
    tb comparable_ty -&gt;
    (ta comparable_ty, tb comparable_ty) eq tzresult =
 fun ctxt ta tb -&gt;
  match (ta, tb) with
  | (Int_key _, Int_key _) -&gt;
      Ok Eq
  | (Nat_key _, Nat_key _) -&gt;
      Ok Eq
  | (String_key _, String_key _) -&gt;
      Ok Eq
  | (Bytes_key _, Bytes_key _) -&gt;
      Ok Eq
  | (Mutez_key _, Mutez_key _) -&gt;
      Ok Eq
  | (Bool_key _, Bool_key _) -&gt;
      Ok Eq
  | (Key_hash_key _, Key_hash_key _) -&gt;
      Ok Eq
  | (Timestamp_key _, Timestamp_key _) -&gt;
      Ok Eq
  | (Address_key _, Address_key _) -&gt;
      Ok Eq
  | (_, _) -&gt;
      serialize_ty_for_error ctxt (ty_of_comparable_ty ta)
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt (ty_of_comparable_ty tb)
      &gt;&gt;? fun (tb, _ctxt) -&gt; error <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_types (ta, tb))</abbr>

let record_inconsistent ctxt ta tb =
  record_trace_eval (fun () -&gt;
      serialize_ty_for_error ctxt ta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt tb
      &gt;|? fun (tb, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Inconsistent_types (ta, tb)</abbr>)

let record_inconsistent_type_annotations ctxt loc ta tb =
  record_trace_eval (fun () -&gt;
      serialize_ty_for_error ctxt ta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt tb
      &gt;|? fun (tb, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Inconsistent_type_annotations (loc, ta, tb)</abbr>)

let rec ty_eq :
    type ta tb.
    context -&gt; ta ty -&gt; tb ty -&gt; ((ta ty, tb ty) eq * context) tzresult =
 fun ctxt ta tb -&gt;
  let ok (eq : (ta ty, tb ty) eq) ctxt nb_args :
      ((ta ty, tb ty) eq * context) tzresult =
    Gas.consume ctxt (Typecheck_costs.type_ (2 * nb_args))
    &gt;&gt;? fun ctxt -&gt; Ok (eq, ctxt)
  in
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  match (ta, tb) with
  | (Unit_t _, Unit_t _) -&gt;
      ok Eq ctxt 0
  | (Int_t _, Int_t _) -&gt;
      ok Eq ctxt 0
  | (Nat_t _, Nat_t _) -&gt;
      ok Eq ctxt 0
  | (Key_t _, Key_t _) -&gt;
      ok Eq ctxt 0
  | (Key_hash_t _, Key_hash_t _) -&gt;
      ok Eq ctxt 0
  | (String_t _, String_t _) -&gt;
      ok Eq ctxt 0
  | (Bytes_t _, Bytes_t _) -&gt;
      ok Eq ctxt 0
  | (Signature_t _, Signature_t _) -&gt;
      ok Eq ctxt 0
  | (Mutez_t _, Mutez_t _) -&gt;
      ok Eq ctxt 0
  | (Timestamp_t _, Timestamp_t _) -&gt;
      ok Eq ctxt 0
  | (Chain_id_t _, Chain_id_t _) -&gt;
      ok Eq ctxt 0
  | (Address_t _, Address_t _) -&gt;
      ok Eq ctxt 0
  | (Bool_t _, Bool_t _) -&gt;
      ok Eq ctxt 0
  | (Operation_t _, Operation_t _) -&gt;
      ok Eq ctxt 0
  | (Map_t (tal, tar, _, _), Map_t (tbl, tbr, _, _)) -&gt;
      comparable_ty_eq ctxt tal tbl
      &gt;&gt;? (fun Eq -&gt; ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Big_map_t (tal, tar, _), Big_map_t (tbl, tbr, _)) -&gt;
      comparable_ty_eq ctxt tal tbl
      &gt;&gt;? (fun Eq -&gt; ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Set_t (ea, _), Set_t (eb, _)) -&gt;
      comparable_ty_eq ctxt ea eb
      &gt;&gt;? (fun Eq -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | ( Pair_t ((tal, _, _), (tar, _, _), _, _),
      Pair_t ((tbl, _, _), (tbr, _, _), _, _) ) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt;
            ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Union_t ((tal, _), (tar, _), _, _), Union_t ((tbl, _), (tbr, _), _, _)) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt;
            ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Lambda_t (tal, tar, _), Lambda_t (tbl, tbr, _)) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt;
            ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Contract_t (tal, _), Contract_t (tbl, _)) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | (Option_t (tva, _, _), Option_t (tvb, _, _)) -&gt;
      ty_eq ctxt tva tvb
      &gt;&gt;? (fun (Eq, ctxt) -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | (List_t (tva, _, _), List_t (tvb, _, _)) -&gt;
      ty_eq ctxt tva tvb
      &gt;&gt;? (fun (Eq, ctxt) -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | (_, _) -&gt;
      serialize_ty_for_error ctxt ta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt tb
      &gt;&gt;? fun (tb, _ctxt) -&gt; error <abbr class="mark-error" title="Values of extensible types are not handled">(Inconsistent_types (ta, tb))</abbr>

let rec stack_ty_eq :
    type ta tb.
    context -&gt;
    int -&gt;
    ta stack_ty -&gt;
    tb stack_ty -&gt;
    ((ta stack_ty, tb stack_ty) eq * context) tzresult =
 fun ctxt lvl ta tb -&gt;
  match (ta, tb) with
  | (Item_t (tva, ra, _), Item_t (tvb, rb, _)) -&gt;
      ty_eq ctxt tva tvb
      |&gt; record_trace <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack_item lvl)</abbr>
      &gt;&gt;? fun (Eq, ctxt) -&gt;
      stack_ty_eq ctxt (lvl + 1) ra rb
      &gt;&gt;? fun (Eq, ctxt) -&gt;
      (Ok (Eq, ctxt) : ((ta stack_ty, tb stack_ty) eq * context) tzresult)
  | (Empty_t, Empty_t) -&gt;
      Ok (Eq, ctxt)
  | (_, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Bad_stack_length</abbr>

let merge_comparable_types :
    type ta.
    legacy:bool -&gt;
    ta comparable_ty -&gt;
    ta comparable_ty -&gt;
    ta comparable_ty tzresult =
 fun ~legacy ta tb -&gt;
  match (ta, tb) with
  | (Int_key annot_a, Int_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Int_key annot
  | (Nat_key annot_a, Nat_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Nat_key annot
  | (String_key annot_a, String_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; String_key annot
  | (Bytes_key annot_a, Bytes_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Bytes_key annot
  | (Mutez_key annot_a, Mutez_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Mutez_key annot
  | (Bool_key annot_a, Bool_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Bool_key annot
  | (Key_hash_key annot_a, Key_hash_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; Key_hash_key annot
  | (Timestamp_key annot_a, Timestamp_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; Timestamp_key annot
  | (Address_key annot_a, Address_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; Address_key annot
  | (_, _) -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>

(* FIXME: fix injectivity of some types *)

let merge_types :
    type b.
    legacy:bool -&gt;
    context -&gt;
    Script.location -&gt;
    b ty -&gt;
    b ty -&gt;
    (b ty * context) tzresult =
 fun ~legacy -&gt;
  let rec help : type a. context -&gt; a ty -&gt; a ty -&gt; (a ty * context) tzresult =
   fun ctxt ty1 ty2 -&gt;
    match (ty1, ty2) with
    | (Unit_t tn1, Unit_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Unit_t tname, ctxt)
    | (Int_t tn1, Int_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Int_t tname, ctxt)
    | (Nat_t tn1, Nat_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Nat_t tname, ctxt)
    | (Key_t tn1, Key_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Key_t tname, ctxt)
    | (Key_hash_t tn1, Key_hash_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Key_hash_t tname, ctxt)
    | (String_t tn1, String_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (String_t tname, ctxt)
    | (Bytes_t tn1, Bytes_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Bytes_t tname, ctxt)
    | (Signature_t tn1, Signature_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Signature_t tname, ctxt)
    | (Mutez_t tn1, Mutez_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Mutez_t tname, ctxt)
    | (Timestamp_t tn1, Timestamp_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Timestamp_t tname, ctxt)
    | (Address_t tn1, Address_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Address_t tname, ctxt)
    | (Bool_t tn1, Bool_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Bool_t tname, ctxt)
    | (Chain_id_t tn1, Chain_id_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Chain_id_t tname, ctxt)
    | (Operation_t tn1, Operation_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Operation_t tname, ctxt)
    | (Map_t (tal, tar, tn1, has_big_map), Map_t (tbl, tbr, tn2, _)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tar tbr
        &gt;&gt;? fun (value, ctxt) -&gt;
        ty_eq ctxt tar value
        &gt;&gt;? fun (Eq, ctxt) -&gt;
        merge_comparable_types ~legacy tal tbl
        &gt;|? fun tk -&gt; (Map_t (tk, value, tname, has_big_map), ctxt)
    | (Big_map_t (tal, tar, tn1), Big_map_t (tbl, tbr, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tar tbr
        &gt;&gt;? fun (value, ctxt) -&gt;
        ty_eq ctxt tar value
        &gt;&gt;? fun (Eq, ctxt) -&gt;
        merge_comparable_types ~legacy tal tbl
        &gt;|? fun tk -&gt; (Big_map_t (tk, value, tname), ctxt)
    | (Set_t (ea, tn1), Set_t (eb, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        merge_comparable_types ~legacy ea eb
        &gt;|? fun e -&gt; (Set_t (e, tname), ctxt)
    | ( Pair_t
          ((tal, l_field1, l_var1), (tar, r_field1, r_var1), tn1, has_big_map),
        Pair_t ((tbl, l_field2, l_var2), (tbr, r_field2, r_var2), tn2, _) ) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        merge_field_annot ~legacy l_field1 l_field2
        &gt;&gt;? fun l_field -&gt;
        merge_field_annot ~legacy r_field1 r_field2
        &gt;&gt;? fun r_field -&gt;
        let l_var = merge_var_annot l_var1 l_var2 in
        let r_var = merge_var_annot r_var1 r_var2 in
        help ctxt tal tbl
        &gt;&gt;? fun (left_ty, ctxt) -&gt;
        help ctxt tar tbr
        &gt;|? fun (right_ty, ctxt) -&gt;
        ( Pair_t
            ( (left_ty, l_field, l_var),
              (right_ty, r_field, r_var),
              tname,
              has_big_map ),
          ctxt )
    | ( Union_t ((tal, tal_annot), (tar, tar_annot), tn1, has_big_map),
        Union_t ((tbl, tbl_annot), (tbr, tbr_annot), tn2, _) ) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        merge_field_annot ~legacy tal_annot tbl_annot
        &gt;&gt;? fun left_annot -&gt;
        merge_field_annot ~legacy tar_annot tbr_annot
        &gt;&gt;? fun right_annot -&gt;
        help ctxt tal tbl
        &gt;&gt;? fun (left_ty, ctxt) -&gt;
        help ctxt tar tbr
        &gt;|? fun (right_ty, ctxt) -&gt;
        ( Union_t
            ((left_ty, left_annot), (right_ty, right_annot), tname, has_big_map),
          ctxt )
    | (Lambda_t (tal, tar, tn1), Lambda_t (tbl, tbr, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tal tbl
        &gt;&gt;? fun (left_ty, ctxt) -&gt;
        help ctxt tar tbr
        &gt;|? fun (right_ty, ctxt) -&gt; (Lambda_t (left_ty, right_ty, tname), ctxt)
    | (Contract_t (tal, tn1), Contract_t (tbl, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tal tbl
        &gt;|? fun (arg_ty, ctxt) -&gt; (Contract_t (arg_ty, tname), ctxt)
    | (Option_t (tva, tn1, has_big_map), Option_t (tvb, tn2, _)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tva tvb
        &gt;|? fun (ty, ctxt) -&gt; (Option_t (ty, tname, has_big_map), ctxt)
    | (List_t (tva, tn1, has_big_map), List_t (tvb, tn2, _)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tva tvb
        &gt;|? fun (ty, ctxt) -&gt; (List_t (ty, tname, has_big_map), ctxt)
    | (_, _) -&gt;
        <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  in
  fun ctxt loc ty1 ty2 -&gt;
    record_inconsistent_type_annotations ctxt loc ty1 ty2 (help ctxt ty1 ty2)

let merge_stacks :
    type ta.
    legacy:bool -&gt;
    Script.location -&gt;
    context -&gt;
    ta stack_ty -&gt;
    ta stack_ty -&gt;
    (ta stack_ty * context) tzresult =
 fun ~legacy loc -&gt;
  let rec help :
      type a.
      context -&gt; a stack_ty -&gt; a stack_ty -&gt; (a stack_ty * context) tzresult =
   fun ctxt stack1 stack2 -&gt;
    match (stack1, stack2) with
    | (Empty_t, Empty_t) -&gt;
        ok (Empty_t, ctxt)
    | (Item_t (ty1, rest1, annot1), Item_t (ty2, rest2, annot2)) -&gt;
        let annot = merge_var_annot annot1 annot2 in
        merge_types ~legacy ctxt loc ty1 ty2
        &gt;&gt;? fun (ty, ctxt) -&gt;
        help ctxt rest1 rest2
        &gt;|? fun (rest, ctxt) -&gt; (Item_t (ty, rest, annot), ctxt)
  in
  help

let has_big_map : type t. t ty -&gt; bool = function
  | Unit_t _ -&gt;
      false
  | Int_t _ -&gt;
      false
  | Nat_t _ -&gt;
      false
  | Signature_t _ -&gt;
      false
  | String_t _ -&gt;
      false
  | Bytes_t _ -&gt;
      false
  | Mutez_t _ -&gt;
      false
  | Key_hash_t _ -&gt;
      false
  | Key_t _ -&gt;
      false
  | Timestamp_t _ -&gt;
      false
  | Address_t _ -&gt;
      false
  | Bool_t _ -&gt;
      false
  | Lambda_t (_, _, _) -&gt;
      false
  | Set_t (_, _) -&gt;
      false
  | Big_map_t (_, _, _) -&gt;
      true
  | Contract_t (_, _) -&gt;
      false
  | Operation_t _ -&gt;
      false
  | Chain_id_t _ -&gt;
      false
  | Pair_t (_, _, _, has_big_map) -&gt;
      has_big_map
  | Union_t (_, _, _, has_big_map) -&gt;
      has_big_map
  | Option_t (_, _, has_big_map) -&gt;
      has_big_map
  | List_t (_, _, has_big_map) -&gt;
      has_big_map
  | Map_t (_, _, _, has_big_map) -&gt;
      has_big_map

(* ---- Type checker results -------------------------------------------------*)

type 'bef judgement =
  | Typed : ('bef, 'aft) descr -&gt; 'bef judgement
  <abbr class="mark-error" title="Forall quantifier is not handled">| Failed : {
      descr : 'aft. 'aft stack_ty -&gt; ('bef, 'aft) descr;
    }
      -&gt; 'bef judgement</abbr>

(* ---- Type checker (Untyped expressions -&gt; Typed IR) ----------------------*)

<abbr class="mark-error" title="Forall quantifier is not handled">type ('t, 'f, 'b) branch = {
  branch : 'r. ('t, 'r) descr -&gt; ('f, 'r) descr -&gt; ('b, 'r) descr;
}
[@@unboxed]</abbr>

let merge_branches :
    type bef a b.
    legacy:bool -&gt;
    context -&gt;
    int -&gt;
    a judgement -&gt;
    b judgement -&gt;
    (a, b, bef) branch -&gt;
    (bef judgement * context) tzresult Lwt.t =
 fun ~legacy ctxt loc btr bfr {branch} -&gt;
  match (btr, bfr) with
  | (Typed ({aft = aftbt; _} as dbt), Typed ({aft = aftbf; _} as dbf)) -&gt;
      let unmatched_branches () =
        serialize_stack_for_error ctxt aftbt
        &gt;&gt;=? fun (aftbt, ctxt) -&gt;
        serialize_stack_for_error ctxt aftbf
        &gt;&gt;|? fun (aftbf, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Unmatched_branches (loc, aftbt, aftbf)</abbr>
      in
      trace_eval
        unmatched_branches
        ( Lwt.return (stack_ty_eq ctxt 1 aftbt aftbf)
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return (merge_stacks ~legacy loc ctxt aftbt aftbf)
        &gt;&gt;=? fun (merged_stack, ctxt) -&gt;
        return
          ( Typed
              (branch
                 <abbr class="mark-error" title="Record substitution not handled">{dbt with aft = merged_stack}</abbr>
                 <abbr class="mark-error" title="Record substitution not handled">{dbf with aft = merged_stack}</abbr>),
            ctxt ) )
  | (Failed {descr = descrt}, Failed {descr = descrf}) -&gt;
      let descr ret = branch (descrt ret) (descrf ret) in
      return (Failed {descr}, ctxt)
  | (Typed dbt, Failed {descr = descrf}) -&gt;
      return (Typed (branch dbt (descrf dbt.aft)), ctxt)
  | (Failed {descr = descrt}, Typed dbf) -&gt;
      return (Typed (branch (descrt dbf.aft) dbf), ctxt)

let rec parse_comparable_ty :
    context -&gt; Script.node -&gt; (ex_comparable_ty * context) tzresult =
 fun ctxt ty -&gt;
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  Gas.consume ctxt (Typecheck_costs.type_ 0)
  &gt;&gt;? fun ctxt -&gt;
  match ty with
  | Prim (loc, T_int, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Int_key tname), ctxt)
  | Prim (loc, T_nat, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Nat_key tname), ctxt)
  | Prim (loc, T_string, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (String_key tname), ctxt)
  | Prim (loc, T_bytes, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Bytes_key tname), ctxt)
  | Prim (loc, T_mutez, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Mutez_key tname), ctxt)
  | Prim (loc, T_bool, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Bool_key tname), ctxt)
  | Prim (loc, T_key_hash, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Key_hash_key tname), ctxt)
  | Prim (loc, T_timestamp, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Timestamp_key tname), ctxt)
  | Prim (loc, T_address, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Address_key tname), ctxt)
  | Prim
      ( loc,
        ( ( T_int
          | T_nat
          | T_string
          | T_mutez
          | T_bool
          | T_key
          | T_address
          | T_timestamp ) as prim ),
        l,
        _ ) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, prim, 0, List.length l))</abbr>
  | Prim
      ( loc,
        ( T_pair
        | T_or
        | T_set
        | T_map
        | T_list
        | T_option
        | T_lambda
        | T_unit
        | T_signature
        | T_contract ),
        _,
        _ ) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Comparable_type_expected (loc, Micheline.strip_locations ty))</abbr>
  | expr -&gt;
      error
      @@ unexpected
           expr
           []
           Type_namespace
           [ T_int;
             T_nat;
             T_string;
             T_mutez;
             T_bool;
             T_key;
             T_key_hash;
             T_timestamp ]

and parse_packable_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy -&gt;
  parse_ty
    ctxt
    ~legacy
    ~allow_big_map:false
    ~allow_operation:false
    ~allow_contract:legacy

and parse_parameter_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy -&gt;
  parse_ty
    ctxt
    ~legacy
    ~allow_big_map:true
    ~allow_operation:false
    ~allow_contract:true

and parse_any_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy -&gt;
  parse_ty
    ctxt
    ~legacy
    ~allow_big_map:true
    ~allow_operation:true
    ~allow_contract:true

and parse_ty :
    context -&gt;
    legacy:bool -&gt;
    allow_big_map:bool -&gt;
    allow_operation:bool -&gt;
    allow_contract:bool -&gt;
    Script.node -&gt;
    (ex_ty * context) tzresult =
 fun ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract node -&gt;
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  match node with
  | Prim (loc, T_unit, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Unit_t ty_name), ctxt)
  | Prim (loc, T_int, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Int_t ty_name), ctxt)
  | Prim (loc, T_nat, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Nat_t ty_name), ctxt)
  | Prim (loc, T_string, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (String_t ty_name), ctxt)
  | Prim (loc, T_bytes, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Bytes_t ty_name), ctxt)
  | Prim (loc, T_mutez, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Mutez_t ty_name), ctxt)
  | Prim (loc, T_bool, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Bool_t ty_name), ctxt)
  | Prim (loc, T_key, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Key_t ty_name), ctxt)
  | Prim (loc, T_key_hash, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Key_hash_t ty_name), ctxt)
  | Prim (loc, T_timestamp, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Timestamp_t ty_name), ctxt)
  | Prim (loc, T_address, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Address_t ty_name), ctxt)
  | Prim (loc, T_signature, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Signature_t ty_name), ctxt)
  | Prim (loc, T_operation, [], annot) -&gt;
      if allow_operation then
        parse_type_annot loc annot
        &gt;&gt;? fun ty_name -&gt;
        Gas.consume ctxt (Typecheck_costs.type_ 0)
        &gt;|? fun ctxt -&gt; (Ex_ty (Operation_t ty_name), ctxt)
      else error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_operation loc)</abbr>
  | Prim (loc, T_chain_id, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Chain_id_t ty_name), ctxt)
  | Prim (loc, T_contract, [utl], annot) -&gt;
      if allow_contract then
        parse_parameter_ty ctxt ~legacy utl
        &gt;&gt;? fun (Ex_ty tl, ctxt) -&gt;
        parse_type_annot loc annot
        &gt;&gt;? fun ty_name -&gt;
        Gas.consume ctxt (Typecheck_costs.type_ 1)
        &gt;|? fun ctxt -&gt; (Ex_ty (Contract_t (tl, ty_name)), ctxt)
      else error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_contract loc)</abbr>
  | Prim (loc, T_pair, [utl; utr], annot) -&gt;
      extract_field_annot utl
      &gt;&gt;? fun (utl, left_field) -&gt;
      extract_field_annot utr
      &gt;&gt;? fun (utr, right_field) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utl
      &gt;&gt;? fun (Ex_ty tl, ctxt) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt;
      ( Ex_ty
          (Pair_t
             ( (tl, left_field, None),
               (tr, right_field, None),
               ty_name,
               has_big_map tl || has_big_map tr )),
        ctxt )
  | Prim (loc, T_or, [utl; utr], annot) -&gt;
      extract_field_annot utl
      &gt;&gt;? fun (utl, left_constr) -&gt;
      extract_field_annot utr
      &gt;&gt;? fun (utr, right_constr) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utl
      &gt;&gt;? fun (Ex_ty tl, ctxt) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt;
      ( Ex_ty
          (Union_t
             ( (tl, left_constr),
               (tr, right_constr),
               ty_name,
               has_big_map tl || has_big_map tr )),
        ctxt )
  | Prim (loc, T_lambda, [uta; utr], annot) -&gt;
      parse_any_ty ctxt ~legacy uta
      &gt;&gt;? fun (Ex_ty ta, ctxt) -&gt;
      parse_any_ty ctxt ~legacy utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (Ex_ty (Lambda_t (ta, tr, ty_name)), ctxt)
  | Prim (loc, T_option, [ut], annot) -&gt;
      ( if legacy then
        (* legacy semantics with (broken) field annotations *)
        extract_field_annot ut
        &gt;&gt;? fun (ut, _some_constr) -&gt;
        parse_composed_type_annot loc annot
        &gt;&gt;? fun (ty_name, _none_constr, _) -&gt; ok (ut, ty_name)
      else parse_type_annot loc annot &gt;&gt;? fun ty_name -&gt; ok (ut, ty_name) )
      &gt;&gt;? fun (ut, ty_name) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract ut
      &gt;&gt;? fun (Ex_ty t, ctxt) -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (Ex_ty (Option_t (t, ty_name, has_big_map t)), ctxt)
  | Prim (loc, T_list, [ut], annot) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract ut
      &gt;&gt;? fun (Ex_ty t, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 1)
      &gt;|? fun ctxt -&gt; (Ex_ty (List_t (t, ty_name, has_big_map t)), ctxt)
  | Prim (loc, T_set, [ut], annot) -&gt;
      parse_comparable_ty ctxt ut
      &gt;&gt;? fun (Ex_comparable_ty t, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 1)
      &gt;|? fun ctxt -&gt; (Ex_ty (Set_t (t, ty_name)), ctxt)
  | Prim (loc, T_map, [uta; utr], annot) -&gt;
      parse_comparable_ty ctxt uta
      &gt;&gt;? fun (Ex_comparable_ty ta, ctxt) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (Ex_ty (Map_t (ta, tr, ty_name, has_big_map tr)), ctxt)
  | Prim (loc, T_big_map, args, annot) when allow_big_map -&gt;
      parse_big_map_ty ctxt ~legacy loc args annot
      &gt;&gt;? fun (big_map_ty, ctxt) -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (big_map_ty, ctxt)
  | Prim (loc, T_big_map, _, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_big_map loc)</abbr>
  | Prim
      ( loc,
        ( ( T_unit
          | T_signature
          | T_int
          | T_nat
          | T_string
          | T_bytes
          | T_mutez
          | T_bool
          | T_key
          | T_key_hash
          | T_timestamp
          | T_address ) as prim ),
        l,
        _ ) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, prim, 0, List.length l))</abbr>
  | Prim (loc, ((T_set | T_list | T_option | T_contract) as prim), l, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, prim, 1, List.length l))</abbr>
  | Prim (loc, ((T_pair | T_or | T_map | T_lambda) as prim), l, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, prim, 2, List.length l))</abbr>
  | expr -&gt;
      error
      @@ unexpected
           expr
           []
           Type_namespace
           [ T_pair;
             T_or;
             T_set;
             T_map;
             T_list;
             T_option;
             T_lambda;
             T_unit;
             T_signature;
             T_contract;
             T_int;
             T_nat;
             T_operation;
             T_string;
             T_bytes;
             T_mutez;
             T_bool;
             T_key;
             T_key_hash;
             T_timestamp;
             T_chain_id ]

and parse_big_map_ty ctxt ~legacy big_map_loc args map_annot =
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  match args with
  | [key_ty; value_ty] -&gt;
      parse_comparable_ty ctxt key_ty
      &gt;&gt;? fun (Ex_comparable_ty key_ty, ctxt) -&gt;
      parse_packable_ty ctxt ~legacy value_ty
      &gt;&gt;? fun (Ex_ty value_ty, ctxt) -&gt;
      parse_type_annot big_map_loc map_annot
      &gt;|? fun map_name -&gt;
      let big_map_ty = Big_map_t (key_ty, value_ty, map_name) in
      (Ex_ty big_map_ty, ctxt)
  | args -&gt;
      error @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arity (big_map_loc, T_big_map, 2, List.length args)</abbr>

and parse_storage_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy node -&gt;
  match node with
  | Prim
      ( loc,
        T_pair,
        [Prim (big_map_loc, T_big_map, args, map_annot); remaining_storage],
        storage_annot )
    when legacy -&gt; (
    match storage_annot with
    | [] -&gt;
        parse_ty
          ctxt
          ~legacy
          ~allow_big_map:true
          ~allow_operation:false
          ~allow_contract:legacy
          node
    | [single]
      when Compare.Int.(String.length single &gt; 0)
           &amp;&amp; Compare.Char.(single.[0] = '%') -&gt;
        parse_ty
          ctxt
          ~legacy
          ~allow_big_map:true
          ~allow_operation:false
          ~allow_contract:legacy
          node
    | _ -&gt;
        (* legacy semantics of big maps used the wrong annotation parser *)
        Gas.consume ctxt Typecheck_costs.cycle
        &gt;&gt;? fun ctxt -&gt;
        parse_big_map_ty ctxt ~legacy big_map_loc args map_annot
        &gt;&gt;? fun (Ex_ty big_map_ty, ctxt) -&gt;
        parse_ty
          ctxt
          ~legacy
          ~allow_big_map:true
          ~allow_operation:false
          ~allow_contract:legacy
          remaining_storage
        &gt;&gt;? fun (Ex_ty remaining_storage, ctxt) -&gt;
        parse_composed_type_annot loc storage_annot
        &gt;&gt;? fun (ty_name, map_field, storage_field) -&gt;
        Gas.consume ctxt (Typecheck_costs.type_ 5)
        &gt;|? fun ctxt -&gt;
        ( Ex_ty
            (Pair_t
               ( (big_map_ty, map_field, None),
                 (remaining_storage, storage_field, None),
                 ty_name,
                 true )),
          ctxt ) )
  | _ -&gt;
      parse_ty
        ctxt
        ~legacy
        ~allow_big_map:true
        ~allow_operation:false
        ~allow_contract:legacy
        node

let check_packable ~legacy loc root =
  let rec check : type t. t ty -&gt; unit tzresult = function
    | Big_map_t _ -&gt;
        error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_big_map loc)</abbr>
    | Operation_t _ -&gt;
        error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_operation loc)</abbr>
    | Unit_t _ -&gt;
        ok ()
    | Int_t _ -&gt;
        ok ()
    | Nat_t _ -&gt;
        ok ()
    | Signature_t _ -&gt;
        ok ()
    | String_t _ -&gt;
        ok ()
    | Bytes_t _ -&gt;
        ok ()
    | Mutez_t _ -&gt;
        ok ()
    | Key_hash_t _ -&gt;
        ok ()
    | Key_t _ -&gt;
        ok ()
    | Timestamp_t _ -&gt;
        ok ()
    | Address_t _ -&gt;
        ok ()
    | Bool_t _ -&gt;
        ok ()
    | Chain_id_t _ -&gt;
        ok ()
    | Pair_t ((l_ty, _, _), (r_ty, _, _), _, _) -&gt;
        check l_ty &gt;&gt;? fun () -&gt; check r_ty
    | Union_t ((l_ty, _), (r_ty, _), _, _) -&gt;
        check l_ty &gt;&gt;? fun () -&gt; check r_ty
    | Option_t (v_ty, _, _) -&gt;
        check v_ty
    | List_t (elt_ty, _, _) -&gt;
        check elt_ty
    | Set_t (_, _) -&gt;
        ok ()
    | Map_t (_, elt_ty, _, _) -&gt;
        check elt_ty
    | Lambda_t (_l_ty, _r_ty, _) -&gt;
        ok ()
    | Contract_t (_, _) when legacy -&gt;
        ok ()
    | Contract_t (_, _) -&gt;
        error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_contract loc)</abbr>
  in
  check root

type ex_script = Ex_script : ('a, 'c) script -&gt; ex_script

type _ dig_proof_argument =
  | Dig_proof_argument :
      ( ('x * 'rest, 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      * ('x ty * var_annot option)
      * 'aft stack_ty )
      -&gt; 'bef dig_proof_argument

type (_, _) dug_proof_argument =
  | Dug_proof_argument :
      ( ('rest, 'x * 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      * unit
      * 'aft stack_ty )
      -&gt; ('bef, 'x) dug_proof_argument

type _ dipn_proof_argument =
  | Dipn_proof_argument :
      ( ('fbef, 'faft, 'bef, 'aft) stack_prefix_preservation_witness
      * (context * ('fbef, 'faft) descr)
      * 'aft stack_ty )
      -&gt; 'bef dipn_proof_argument

type _ dropn_proof_argument =
  | Dropn_proof_argument :
      ( ('rest, 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      * 'rest stack_ty
      * 'aft stack_ty )
      -&gt; 'bef dropn_proof_argument

(* Lwt versions *)
let parse_var_annot loc ?default annot =
  Lwt.return (parse_var_annot loc ?default annot)

let parse_entrypoint_annot loc ?default annot =
  Lwt.return (parse_entrypoint_annot loc ?default annot)

let parse_constr_annot loc ?if_special_first ?if_special_second annot =
  Lwt.return
    (parse_constr_annot loc ?if_special_first ?if_special_second annot)

let parse_two_var_annot loc annot = Lwt.return (parse_two_var_annot loc annot)

let parse_destr_annot loc annot ~default_accessor ~field_name ~pair_annot
    ~value_annot =
  Lwt.return
    (parse_destr_annot
       loc
       annot
       ~default_accessor
       ~field_name
       ~pair_annot
       ~value_annot)

let parse_var_type_annot loc annot =
  Lwt.return (parse_var_type_annot loc annot)

let find_entrypoint (type full) (full : full ty) ~root_name entrypoint =
  let rec find_entrypoint :
      type t. t ty -&gt; string -&gt; (Script.node -&gt; Script.node) * ex_ty =
   fun t entrypoint -&gt;
    match t with
    | Union_t ((tl, al), (tr, ar), _, _) -&gt; (
        if
          match al with
          | None -&gt;
              false
          | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot l)</abbr> -&gt;
              Compare.String.(l = entrypoint)
        then ((fun e -&gt; Prim (0, D_Left, [e], [])), Ex_ty tl)
        else if
          match ar with
          | None -&gt;
              false
          | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot r)</abbr> -&gt;
              Compare.String.(r = entrypoint)
        then ((fun e -&gt; Prim (0, D_Right, [e], [])), Ex_ty tr)
        else
          <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
            let (f, t) = find_entrypoint tl entrypoint in
            ((fun e -&gt; Prim (0, D_Left, [f e], [])), t)
          with Not_found -&gt;
            let (f, t) = find_entrypoint tr entrypoint in
            ((fun e -&gt; Prim (0, D_Right, [f e], [])), t)</abbr> )
    | _ -&gt;
        raise <abbr class="mark-error" title="Values of extensible types are not handled">Not_found</abbr>
  in
  let entrypoint =
    if Compare.String.(entrypoint = &quot;&quot;) then &quot;default&quot; else entrypoint
  in
  if Compare.Int.(String.length entrypoint &gt; 31) then
    error <abbr class="mark-error" title="Values of extensible types are not handled">(Entrypoint_name_too_long entrypoint)</abbr>
  else
    match root_name with
    | Some root_name when Compare.String.(entrypoint = root_name) -&gt;
        ok ((fun e -&gt; e), Ex_ty full)
    | _ -&gt; <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try ok (find_entrypoint full entrypoint)
      with Not_found -&gt; (
        match entrypoint with
        | &quot;default&quot; -&gt;
            ok ((fun e -&gt; e), Ex_ty full)
        | _ -&gt;
            error (No_such_entrypoint entrypoint) ) )</abbr>

let find_entrypoint_for_type (type full exp) ~(full : full ty)
    ~(expected : exp ty) ~root_name entrypoint ctxt :
    (context * string * exp ty) tzresult =
  match (entrypoint, root_name) with
  | (&quot;default&quot;, Some &quot;root&quot;) -&gt; (
    match find_entrypoint full ~root_name entrypoint with
    | Error _ as err -&gt;
        err
    | Ok (_, Ex_ty ty) -&gt; (
      match ty_eq ctxt expected ty with
      | Ok (Eq, ctxt) -&gt;
          ok (ctxt, &quot;default&quot;, (ty : exp ty))
      | Error _ -&gt;
          ty_eq ctxt expected full
          &gt;&gt;? fun (Eq, ctxt) -&gt; ok (ctxt, &quot;root&quot;, (full : exp ty)) ) )
  | _ -&gt;
      find_entrypoint full ~root_name entrypoint
      &gt;&gt;? fun (_, Ex_ty ty) -&gt;
      ty_eq ctxt expected ty
      &gt;&gt;? fun (Eq, ctxt) -&gt; ok (ctxt, entrypoint, (ty : exp ty))

module Entrypoints = Set.Make (String)

<abbr class="mark-error" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception Duplicate of string</abbr>

<abbr class="mark-error" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception Too_long of string</abbr>

let well_formed_entrypoints (type full) (full : full ty) ~root_name =
  let <abbr class="mark-error" title="Polymorphic variant types are not handled">merge</abbr> path annot (type t) (ty : t ty) reachable
      ((first_unreachable, all) as acc) =
    match annot with
    | None | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;&quot;)</abbr> -&gt; (
        if reachable then acc
        else
          match ty with
          | Union_t _ -&gt;
              acc
          | _ -&gt; (
            match first_unreachable with
            | None -&gt;
                (Some (List.rev path), all)
            | Some _ -&gt;
                acc ) )
    | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot name)</abbr> -&gt;
        if Compare.Int.(String.length name &gt; 31) then raise <abbr class="mark-error" title="Values of extensible types are not handled">(Too_long name)</abbr>
        else if Entrypoints.mem name all then raise <abbr class="mark-error" title="Values of extensible types are not handled">(Duplicate name)</abbr>
        else (first_unreachable, Entrypoints.add name all)
  in
  let rec check :
      type t.
      t ty -&gt;
      prim list -&gt;
      bool -&gt;
      prim list option * Entrypoints.t -&gt;
      prim list option * Entrypoints.t =
   fun t path reachable acc -&gt;
    match t with
    | Union_t ((tl, al), (tr, ar), _, _) -&gt;
        let acc = merge (D_Left :: path) al tl reachable acc in
        let acc = merge (D_Right :: path) ar tr reachable acc in
        let acc =
          check
            tl
            (D_Left :: path)
            (match al with Some _ -&gt; true | None -&gt; reachable)
            acc
        in
        check
          tr
          (D_Right :: path)
          (match ar with Some _ -&gt; true | None -&gt; reachable)
          acc
    | _ -&gt;
        acc
  in
  <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let (init, reachable) =
      match root_name with
      | None | Some &quot;&quot; -&gt;
          (Entrypoints.empty, false)
      | Some name -&gt;
          (Entrypoints.singleton name, true)
    in
    let (first_unreachable, all) = check full [] reachable (None, init) in
    if not (Entrypoints.mem &quot;default&quot; all) then ok ()
    else
      match first_unreachable with
      | None -&gt;
          ok ()
      | Some path -&gt;
          error </abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">(Unreachable_entrypoint path)</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
  with
  | Duplicate name -&gt;
      error (Duplicate_entrypoint name)
  | Too_long name -&gt;
      error (Entrypoint_name_too_long name)</abbr>

let rec parse_data :
    type a.
    ?type_logger:type_logger -&gt;
    context -&gt;
    legacy:bool -&gt;
    a ty -&gt;
    Script.node -&gt;
    (a * context) tzresult Lwt.t =
 fun ?type_logger ctxt ~legacy ty script_data -&gt;
  Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
  &gt;&gt;=? fun ctxt -&gt;
  let error () =
    Lwt.return (serialize_ty_for_error ctxt ty)
    &gt;&gt;|? fun (ty, _ctxt) -&gt;
    <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_constant (location script_data, strip_locations script_data, ty)</abbr>
  in
  let traced body = trace_eval error body in
  let parse_items ?type_logger loc ctxt expr key_type value_type items
      item_wrapper =
    let length = List.length items in
    fold_left_s
      (fun (last_value, map, ctxt) item -&gt;
        Lwt.return (Gas.consume ctxt (Typecheck_costs.map_element length))
        &gt;&gt;=? fun ctxt -&gt;
        match item with
        | Prim (_, D_Elt, [k; v], _) -&gt;
            parse_comparable_data ?type_logger ctxt key_type k
            &gt;&gt;=? fun (k, ctxt) -&gt;
            parse_data ?type_logger ctxt ~legacy value_type v
            &gt;&gt;=? fun (v, ctxt) -&gt;
            ( match last_value with
            | Some value -&gt;
                if Compare.Int.(0 &lt;= compare_comparable key_type value k) then
                  if Compare.Int.(0 = compare_comparable key_type value k) then
                    fail <abbr class="mark-error" title="Values of extensible types are not handled">(Duplicate_map_keys (loc, strip_locations expr))</abbr>
                  else fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unordered_map_keys (loc, strip_locations expr))</abbr>
                else return_unit
            | None -&gt;
                return_unit )
            &gt;&gt;=? fun () -&gt;
            return (Some k, map_update k (Some (item_wrapper v)) map, ctxt)
        | Prim (loc, D_Elt, l, _) -&gt;
            fail @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arity (loc, D_Elt, 2, List.length l)</abbr>
        | Prim (loc, name, _, _) -&gt;
            fail @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_primitive (loc, [D_Elt], name)</abbr>
        | Int _ | String _ | Bytes _ | Seq _ -&gt;
            error () &gt;&gt;=? fail)
      (None, empty_map key_type, ctxt)
      items
    |&gt; traced
    &gt;&gt;|? fun (_, items, ctxt) -&gt; (items, ctxt)
  in
  match (ty, script_data) with
  (* Unit *)
  | (Unit_t _, Prim (loc, D_Unit, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.unit)
      &gt;&gt;|? fun ctxt -&gt; ((() : a), ctxt)
  | (Unit_t _, Prim (loc, D_Unit, l, _)) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, D_Unit, 0, List.length l))</abbr>)
  | (Unit_t _, expr) -&gt;
      traced (fail (unexpected expr [] Constant_namespace [D_Unit]))
  (* Booleans *)
  | (Bool_t _, Prim (loc, D_True, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.bool)
      &gt;&gt;|? fun ctxt -&gt; (true, ctxt)
  | (Bool_t _, Prim (loc, D_False, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.bool)
      &gt;&gt;|? fun ctxt -&gt; (false, ctxt)
  | (Bool_t _, Prim (loc, ((D_True | D_False) as c), l, _)) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, c, 0, List.length l))</abbr>)
  | (Bool_t _, expr) -&gt;
      traced (fail (unexpected expr [] Constant_namespace [D_True; D_False]))
  (* Strings *)
  | (String_t _, String (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.string (String.length v)))
      &gt;&gt;=? fun ctxt -&gt;
      let rec check_printable_ascii i =
        if Compare.Int.(i &lt; 0) then true
        else
          match v.[i] with
          | '\n' | '\x20' .. '\x7E' -&gt;
              check_printable_ascii (i - 1)
          | _ -&gt;
              false
      in
      if check_printable_ascii (String.length v - 1) then return (v, ctxt)
      else error () &gt;&gt;=? fail
  | (String_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind], kind expr))</abbr>)
  (* Byte sequences *)
  | (Bytes_t _, Bytes (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.string (MBytes.length v)))
      &gt;&gt;=? fun ctxt -&gt; return (v, ctxt)
  | (Bytes_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Bytes_kind], kind expr))</abbr>)
  (* Integers *)
  | (Int_t _, Int (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.z v))
      &gt;&gt;=? fun ctxt -&gt; return (Script_int.of_zint v, ctxt)
  | (Nat_t _, Int (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.z v))
      &gt;&gt;=? fun ctxt -&gt;
      let v = Script_int.of_zint v in
      if Compare.Int.(Script_int.compare v Script_int.zero &gt;= 0) then
        return (Script_int.abs v, ctxt)
      else error () &gt;&gt;=? fail
  | (Int_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Int_kind], kind expr))</abbr>)
  | (Nat_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Int_kind], kind expr))</abbr>)
  (* Tez amounts *)
  | (Mutez_t _, Int (_, v)) -&gt; (
      Lwt.return
        ( Gas.consume ctxt Typecheck_costs.tez
        &gt;&gt;? fun ctxt -&gt;
        Gas.consume ctxt Michelson_v1_gas.Cost_of.Legacy.z_to_int64 )
      &gt;&gt;=? fun ctxt -&gt;
      <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
        match Tez.of_mutez (Z.to_int64 v) with
        | None -&gt;
            raise </abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are not handled">Exit</abbr><abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
        | Some tez -&gt;
            return (tez, ctxt)
      with _ -&gt; error () &gt;&gt;=? fail</abbr> )
  | (Mutez_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Int_kind], kind expr))</abbr>)
  (* Timestamps *)
  | (Timestamp_t _, Int (_, v))
  (* As unparsed with [Optimized] or out of bounds [Readable]. *) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.z v))
      &gt;&gt;=? fun ctxt -&gt; return (Script_timestamp.of_zint v, ctxt)
  | (Timestamp_t _, String (_, s)) (* As unparsed with [Redable]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.string_timestamp)
      &gt;&gt;=? fun ctxt -&gt;
      match Script_timestamp.of_string s with
      | Some v -&gt;
          return (v, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Timestamp_t _, expr) -&gt;
      traced
        (fail
           <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind; Int_kind], kind expr))</abbr>)
  (* IDs *)
  | (Key_t _, Bytes (_, bytes)) -&gt; (
      (* As unparsed with [Optimized]. *)
      Lwt.return (Gas.consume ctxt Typecheck_costs.key)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes Signature.Public_key.encoding bytes
      with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_t _, String (_, s)) -&gt; (
      (* As unparsed with [Readable]. *)
      Lwt.return (Gas.consume ctxt Typecheck_costs.key)
      &gt;&gt;=? fun ctxt -&gt;
      match Signature.Public_key.of_b58check_opt s with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_t _, expr) -&gt;
      traced
        (fail
           <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  | (Key_hash_t _, Bytes (_, bytes)) -&gt; (
      (* As unparsed with [Optimized]. *)
      Lwt.return (Gas.consume ctxt Typecheck_costs.key_hash)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes Signature.Public_key_hash.encoding bytes
      with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_hash_t _, String (_, s)) (* As unparsed with [Readable]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.key_hash)
      &gt;&gt;=? fun ctxt -&gt;
      match Signature.Public_key_hash.of_b58check_opt s with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_hash_t _, expr) -&gt;
      traced
        (fail
           <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Signatures *)
  | (Signature_t _, Bytes (_, bytes)) (* As unparsed with [Optimized]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.signature)
      &gt;&gt;=? fun ctxt -&gt;
      match Data_encoding.Binary.of_bytes Signature.encoding bytes with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Signature_t _, String (_, s)) (* As unparsed with [Readable]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.signature)
      &gt;&gt;=? fun ctxt -&gt;
      match Signature.of_b58check_opt s with
      | Some s -&gt;
          return (s, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Signature_t _, expr) -&gt;
      traced
        (fail
           <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Operations *)
  | (Operation_t _, _) -&gt;
      (* operations cannot appear in parameters or storage,
           the protocol should never parse the bytes of an operation *)
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  (* Chain_ids *)
  | (Chain_id_t _, Bytes (_, bytes)) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.chain_id)
      &gt;&gt;=? fun ctxt -&gt;
      match Data_encoding.Binary.of_bytes Chain_id.encoding bytes with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Chain_id_t _, String (_, s)) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.chain_id)
      &gt;&gt;=? fun ctxt -&gt;
      match Chain_id.of_b58check_opt s with
      | Some s -&gt;
          return (s, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Chain_id_t _, expr) -&gt;
      traced
        (fail
           <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Addresses *)
  | (Address_t _, Bytes (loc, bytes)) (* As unparsed with [O[ptimized]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes
          Data_encoding.(tup2 Contract.encoding Variable.string)
          bytes
      with
      | Some (c, entrypoint) -&gt;
          if Compare.Int.(String.length entrypoint &gt; 31) then
            fail <abbr class="mark-error" title="Values of extensible types are not handled">(Entrypoint_name_too_long entrypoint)</abbr>
          else
            ( match entrypoint with
            | &quot;&quot; -&gt;
                return &quot;default&quot;
            | &quot;default&quot; -&gt;
                fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>
            | name -&gt;
                return name )
            &gt;&gt;=? fun entrypoint -&gt; return ((c, entrypoint), ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Address_t _, String (loc, s)) (* As unparsed with [Readable]. *) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      ( match String.index_opt s '%' with
      | None -&gt;
          return (s, &quot;default&quot;)
      | Some pos -&gt; (
          let len = String.length s - pos - 1 in
          let name = String.sub s (pos + 1) len in
          if Compare.Int.(len &gt; 31) then fail <abbr class="mark-error" title="Values of extensible types are not handled">(Entrypoint_name_too_long name)</abbr>
          else
            match (String.sub s 0 pos, name) with
            | (_, &quot;default&quot;) -&gt;
                traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>)
            | addr_and_name -&gt;
                return addr_and_name ) )
      &gt;&gt;=? fun (addr, entrypoint) -&gt;
      Lwt.return (Contract.of_b58check addr)
      &gt;&gt;=? fun c -&gt; return ((c, entrypoint), ctxt)
  | (Address_t _, expr) -&gt;
      traced
        (fail
           <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Contracts *)
  | (Contract_t (ty, _), Bytes (loc, bytes))
  (* As unparsed with [Optimized]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes
          Data_encoding.(tup2 Contract.encoding Variable.string)
          bytes
      with
      | Some (c, entrypoint) -&gt;
          if Compare.Int.(String.length entrypoint &gt; 31) then
            fail <abbr class="mark-error" title="Values of extensible types are not handled">(Entrypoint_name_too_long entrypoint)</abbr>
          else
            ( match entrypoint with
            | &quot;&quot; -&gt;
                return &quot;default&quot;
            | &quot;default&quot; -&gt;
                traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>)
            | name -&gt;
                return name )
            &gt;&gt;=? fun entrypoint -&gt;
            traced (parse_contract ~legacy ctxt loc ty c ~entrypoint)
            &gt;&gt;=? fun (ctxt, _) -&gt; return ((ty, (c, entrypoint)), ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Contract_t (ty, _), String (loc, s)) (* As unparsed with [Readable]. *) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      ( match String.index_opt s '%' with
      | None -&gt;
          return (s, &quot;default&quot;)
      | Some pos -&gt; (
          let len = String.length s - pos - 1 in
          let name = String.sub s (pos + 1) len in
          if Compare.Int.(len &gt; 31) then fail <abbr class="mark-error" title="Values of extensible types are not handled">(Entrypoint_name_too_long name)</abbr>
          else
            match (String.sub s 0 pos, name) with
            | (_, &quot;default&quot;) -&gt;
                traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>)
            | addr_and_name -&gt;
                return addr_and_name ) )
      &gt;&gt;=? fun (addr, entrypoint) -&gt;
      traced (Lwt.return (Contract.of_b58check addr))
      &gt;&gt;=? fun c -&gt;
      parse_contract ~legacy ctxt loc ty c ~entrypoint
      &gt;&gt;=? fun (ctxt, _) -&gt; return ((ty, (c, entrypoint)), ctxt)
  | (Contract_t _, expr) -&gt;
      traced
        (fail
           <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Pairs *)
  | (Pair_t ((ta, _, _), (tb, _, _), _, _), Prim (loc, D_Pair, [va; vb], annot))
    -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.pair)
      &gt;&gt;=? fun ctxt -&gt;
      traced @@ parse_data ?type_logger ctxt ~legacy ta va
      &gt;&gt;=? fun (va, ctxt) -&gt;
      parse_data ?type_logger ctxt ~legacy tb vb
      &gt;&gt;=? fun (vb, ctxt) -&gt; return ((va, vb), ctxt)
  | (Pair_t _, Prim (loc, D_Pair, l, _)) -&gt;
      fail @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arity (loc, D_Pair, 2, List.length l)</abbr>
  | (Pair_t _, expr) -&gt;
      traced (fail (unexpected expr [] Constant_namespace [D_Pair]))
  (* Unions *)
  | (Union_t ((tl, _), _, _, _), Prim (loc, D_Left, [v], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.union)
      &gt;&gt;=? fun ctxt -&gt;
      traced @@ parse_data ?type_logger ctxt ~legacy tl v
      &gt;&gt;=? fun (v, ctxt) -&gt; return (L v, ctxt)
  | (Union_t _, Prim (loc, D_Left, l, _)) -&gt;
      fail @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arity (loc, D_Left, 1, List.length l)</abbr>
  | (Union_t (_, (tr, _), _, _), Prim (loc, D_Right, [v], annot)) -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.union)
      &gt;&gt;=? fun ctxt -&gt;
      traced @@ parse_data ?type_logger ctxt ~legacy tr v
      &gt;&gt;=? fun (v, ctxt) -&gt; return (R v, ctxt)
  | (Union_t _, Prim (loc, D_Right, l, _)) -&gt;
      fail @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arity (loc, D_Right, 1, List.length l)</abbr>
  | (Union_t _, expr) -&gt;
      traced (fail (unexpected expr [] Constant_namespace [D_Left; D_Right]))
  (* Lambdas *)
  | (Lambda_t (ta, tr, _ty_name), (Seq (_loc, _) as script_instr)) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.lambda)
      &gt;&gt;=? fun ctxt -&gt;
      traced
      @@ parse_returning
           Lambda
           ?type_logger
           ctxt
           ~legacy
           (ta, Some <abbr class="mark-error" title="Variants not supported">(`Var_annot &quot;@arg&quot;)</abbr>)
           tr
           script_instr
  | (Lambda_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  (* Options *)
  | (Option_t (t, _, _), Prim (loc, D_Some, [v], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.some)
      &gt;&gt;=? fun ctxt -&gt;
      traced @@ parse_data ?type_logger ctxt ~legacy t v
      &gt;&gt;=? fun (v, ctxt) -&gt; return (Some v, ctxt)
  | (Option_t _, Prim (loc, D_Some, l, _)) -&gt;
      fail @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arity (loc, D_Some, 1, List.length l)</abbr>
  | (Option_t (_, _, _), Prim (loc, D_None, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.none)
      &gt;&gt;=? fun ctxt -&gt; return (None, ctxt)
  | (Option_t _, Prim (loc, D_None, l, _)) -&gt;
      fail @@ <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_arity (loc, D_None, 0, List.length l)</abbr>
  | (Option_t _, expr) -&gt;
      traced (fail (unexpected expr [] Constant_namespace [D_Some; D_None]))
  (* Lists *)
  | (List_t (t, _ty_name, _), Seq (_loc, items)) -&gt;
      traced
      @@ fold_right_s
           (fun v (rest, ctxt) -&gt;
             Lwt.return (Gas.consume ctxt Typecheck_costs.list_element)
             &gt;&gt;=? fun ctxt -&gt;
             parse_data ?type_logger ctxt ~legacy t v
             &gt;&gt;=? fun (v, ctxt) -&gt; return (v :: rest, ctxt))
           items
           ([], ctxt)
  | (List_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  (* Sets *)
  | (Set_t (t, _ty_name), (Seq (loc, vs) as expr)) -&gt;
      let length = List.length vs in
      traced
      @@ fold_left_s
           (fun (last_value, set, ctxt) v -&gt;
             Lwt.return (Gas.consume ctxt (Typecheck_costs.set_element length))
             &gt;&gt;=? fun ctxt -&gt;
             parse_comparable_data ?type_logger ctxt t v
             &gt;&gt;=? fun (v, ctxt) -&gt;
             ( match last_value with
             | Some value -&gt;
                 if Compare.Int.(0 &lt;= compare_comparable t value v) then
                   if Compare.Int.(0 = compare_comparable t value v) then
                     fail <abbr class="mark-error" title="Values of extensible types are not handled">(Duplicate_set_values (loc, strip_locations expr))</abbr>
                   else fail <abbr class="mark-error" title="Values of extensible types are not handled">(Unordered_set_values (loc, strip_locations expr))</abbr>
                 else return_unit
             | None -&gt;
                 return_unit )
             &gt;&gt;=? fun () -&gt;
             Lwt.return
               (Gas.consume
                  ctxt
                  (Michelson_v1_gas.Cost_of.Legacy.set_update v false set))
             &gt;&gt;=? fun ctxt -&gt; return (Some v, set_update v true set, ctxt))
           (None, empty_set t, ctxt)
           vs
      &gt;&gt;|? fun (_, set, ctxt) -&gt; (set, ctxt)
  | (Set_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  (* Maps *)
  | (Map_t (tk, tv, _ty_name, _), (Seq (loc, vs) as expr)) -&gt;
      parse_items ?type_logger loc ctxt expr tk tv vs (fun x -&gt; x)
  | (Map_t _, expr) -&gt;
      traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  | (Big_map_t (tk, tv, _ty_name), (Seq (loc, vs) as expr)) -&gt;
      parse_items ?type_logger loc ctxt expr tk tv vs (fun x -&gt; Some x)
      &gt;&gt;|? fun (diff, ctxt) -&gt;
      ( {id = None; diff; key_type = ty_of_comparable_ty tk; value_type = tv},
        ctxt )
  | (Big_map_t (tk, tv, _ty_name), Int (loc, id)) -&gt; (
      Big_map.exists ctxt id
      &gt;&gt;=? function
      | (_, None) -&gt;
          traced (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_big_map (loc, id))</abbr>)
      | (ctxt, Some (btk, btv)) -&gt;
          Lwt.return
            ( parse_comparable_ty ctxt (Micheline.root btk)
            &gt;&gt;? fun (Ex_comparable_ty btk, ctxt) -&gt;
            parse_packable_ty ctxt ~legacy (Micheline.root btv)
            &gt;&gt;? fun (Ex_ty btv, ctxt) -&gt;
            comparable_ty_eq ctxt tk btk
            &gt;&gt;? fun Eq -&gt;
            ty_eq ctxt tv btv
            &gt;&gt;? fun (Eq, ctxt) -&gt;
            ok
              ( {
                  id = Some id;
                  diff = empty_map tk;
                  key_type = ty_of_comparable_ty tk;
                  value_type = tv;
                },
                ctxt ) ) )
  | (Big_map_t (_tk, _tv, _), expr) -&gt;
      traced
        (fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (location expr, [Seq_kind; Int_kind], kind expr))</abbr>)

and parse_comparable_data :
    type a.
    ?type_logger:type_logger -&gt;
    context -&gt;
    a comparable_ty -&gt;
    Script.node -&gt;
    (a * context) tzresult Lwt.t =
 fun ?type_logger ctxt ty script_data -&gt;
  parse_data
    ?type_logger
    ctxt
    ~legacy:false
    (ty_of_comparable_ty ty)
    script_data

and parse_returning :
    type arg ret.
    ?type_logger:type_logger -&gt;
    tc_context -&gt;
    context -&gt;
    legacy:bool -&gt;
    arg ty * var_annot option -&gt;
    ret ty -&gt;
    Script.node -&gt;
    ((arg, ret) lambda * context) tzresult Lwt.t =
 fun ?type_logger tc_context ctxt ~legacy (arg, arg_annot) ret script_instr -&gt;
  parse_instr
    ?type_logger
    tc_context
    ctxt
    ~legacy
    script_instr
    (Item_t (arg, Empty_t, arg_annot))
  &gt;&gt;=? function
  | (Typed ({loc; aft = Item_t (ty, Empty_t, _) as stack_ty; _} as descr), ctxt)
    -&gt;
      trace_eval
        (fun () -&gt;
          Lwt.return (serialize_ty_for_error ctxt ret)
          &gt;&gt;=? fun (ret, ctxt) -&gt;
          serialize_stack_for_error ctxt stack_ty
          &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Bad_return (loc, stack_ty, ret)</abbr>)
        ( Lwt.return (ty_eq ctxt ty ret)
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return (merge_types ~legacy ctxt loc ty ret)
        &gt;&gt;=? fun (_ret, ctxt) -&gt;
        return ((Lam (descr, script_instr) : (arg, ret) lambda), ctxt) )
  | (Typed {loc; aft = stack_ty; _}, ctxt) -&gt;
      Lwt.return (serialize_ty_for_error ctxt ret)
      &gt;&gt;=? fun (ret, ctxt) -&gt;
      serialize_stack_for_error ctxt stack_ty
      &gt;&gt;=? fun (stack_ty, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_return (loc, stack_ty, ret))</abbr>
  | (Failed {descr}, ctxt) -&gt;
      return
        ( ( Lam (descr (Item_t (ret, Empty_t, None)), script_instr)
            : (arg, ret) lambda ),
          ctxt )

and parse_int32 (n : (location, prim) Micheline.node) : int tzresult =
  let error' () =
    <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_syntactic_constant
      ( location n,
        strip_locations n,
        &quot;a positive 32-bit integer (between 0 and &quot;
        ^ Int32.to_string Int32.max_int
        ^ &quot;)&quot; )</abbr>
  in
  match n with
  | Micheline.Int (_, n') -&gt; <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
    try
      let n'' = Z.to_int n' in
      if
        Compare.Int.(0 &lt;= n'')
        &amp;&amp; Compare.Int.(n'' &lt;= Int32.to_int Int32.max_int)
      then ok n''
      else error @@ error' ()
    with _ -&gt; error @@ error' () )</abbr>
  | _ -&gt;
      error @@ error' ()

and parse_instr :
    type bef.
    ?type_logger:type_logger -&gt;
    tc_context -&gt;
    context -&gt;
    legacy:bool -&gt;
    Script.node -&gt;
    bef stack_ty -&gt;
    (bef judgement * context) tzresult Lwt.t =
 fun ?type_logger tc_context ctxt ~legacy script_instr stack_ty -&gt;
  let _check_item check loc name n m =
    trace_eval (fun () -&gt;
        serialize_stack_for_error ctxt stack_ty
        &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Bad_stack (loc, name, m, stack_ty)</abbr>)
    @@ trace <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack_item n)</abbr> @@ Lwt.return check
  in
  let check_item_ty (type a b) ctxt (exp : a ty) (got : b ty) loc name n m :
      ((a, b) eq * a ty * context) tzresult Lwt.t =
    trace_eval (fun () -&gt;
        serialize_stack_for_error ctxt stack_ty
        &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Bad_stack (loc, name, m, stack_ty)</abbr>)
    @@ trace <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack_item n)</abbr>
    @@ Lwt.return
         ( ty_eq ctxt exp got
         &gt;&gt;? fun (Eq, ctxt) -&gt;
         merge_types ~legacy ctxt loc exp got
         &gt;&gt;? fun (ty, ctxt) -&gt; ok ((Eq : (a, b) eq), (ty : a ty), ctxt) )
  in
  let check_item_comparable_ty (type a b) (exp : a comparable_ty)
      (got : b comparable_ty) loc name n m :
      ((a, b) eq * a comparable_ty) tzresult Lwt.t =
    trace_eval (fun () -&gt;
        serialize_stack_for_error ctxt stack_ty
        &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Bad_stack (loc, name, m, stack_ty)</abbr>)
    @@ trace <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack_item n)</abbr>
    @@ Lwt.return
         ( comparable_ty_eq ctxt exp got
         &gt;&gt;? fun Eq -&gt;
         merge_comparable_types ~legacy exp got
         &gt;&gt;? fun ty -&gt; ok ((Eq : (a, b) eq), (ty : a comparable_ty)) )
  in
  let log_stack ctxt loc stack_ty aft =
    match (type_logger, script_instr) with
    | (None, _) | (Some _, (Seq (-1, _) | Int _ | String _ | Bytes _)) -&gt;
        return_unit
    | (Some log, (Prim _ | Seq _)) -&gt;
        (* Unparsing for logging done in an unlimited context as this
             is used only by the client and not the protocol *)
        let ctxt = Gas.set_unlimited ctxt in
        unparse_stack ctxt stack_ty
        &gt;&gt;=? fun (stack_ty, _) -&gt;
        unparse_stack ctxt aft
        &gt;&gt;=? fun (aft, _) -&gt; <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">log loc stack_ty aft ; return_unit</abbr>
  in
  let outer_return = return in
  let return :
      type bef.
      context -&gt; bef judgement -&gt; (bef judgement * context) tzresult Lwt.t =
   fun ctxt judgement -&gt;
    match judgement with
    | Typed {instr; loc; aft; _} -&gt;
        let maximum_type_size = Constants.michelson_maximum_type_size ctxt in
        let type_size =
          type_size_of_stack_head
            aft
            ~up_to:(number_of_generated_growing_types instr)
        in
        if Compare.Int.(type_size &gt; maximum_type_size) then
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Type_too_large (loc, type_size, maximum_type_size))</abbr>
        else return (judgement, ctxt)
    | Failed _ -&gt;
        return (judgement, ctxt)
  in
  let typed ctxt loc instr aft =
    log_stack ctxt loc stack_ty aft
    &gt;&gt;=? fun () -&gt;
    Lwt.return @@ Gas.consume ctxt (Typecheck_costs.instr instr)
    &gt;&gt;=? fun ctxt -&gt; return ctxt (Typed {loc; instr; bef = stack_ty; aft})
  in
  Lwt.return @@ Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;=? fun ctxt -&gt;
  match (script_instr, stack_ty) with
  (* stack ops *)
  | (Prim (loc, I_DROP, [], annot), Item_t (_, rest, _)) -&gt;
      ( fail_unexpected_annot loc annot &gt;&gt;=? fun () -&gt; typed ctxt loc Drop rest
        : (bef judgement * context) tzresult Lwt.t )
  | (Prim (loc, I_DROP, [n], result_annot), whole_stack) -&gt;
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun whole_n -&gt;
      let rec make_proof_argument :
          type tstk.
          int -&gt; tstk stack_ty -&gt; tstk dropn_proof_argument tzresult Lwt.t =
       fun n stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, rest) -&gt;
            outer_return @@ Dropn_proof_argument (Rest, rest, rest)
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) rest
            &gt;&gt;=? fun (Dropn_proof_argument (n', stack_after_drops, aft')) -&gt;
            outer_return
            @@ Dropn_proof_argument
                 (Prefix n', stack_after_drops, Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt whole_stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_DROP, whole_n, whole_stack))</abbr>
      in
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument whole_n whole_stack
      &gt;&gt;=? fun (Dropn_proof_argument (n', stack_after_drops, _aft)) -&gt;
      typed ctxt loc (Dropn (whole_n, n')) stack_after_drops
  | (Prim (loc, I_DROP, (_ :: _ :: _ as l), _), _) -&gt;
      (* Technically, the arities 0 and 1 are allowed but the error only mentions 1.
           However, DROP is equivalent to DROP 1 so hinting at an arity of 1 makes sense. *)
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, I_DROP, 1, List.length l))</abbr>
  | (Prim (loc, I_DUP, [], annot), Item_t (v, rest, stack_annot)) -&gt;
      parse_var_annot loc annot ~default:stack_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Dup (Item_t (v, Item_t (v, rest, stack_annot), annot))
  | (Prim (loc, I_DIG, [n], result_annot), stack) -&gt;
      let rec make_proof_argument :
          type tstk.
          int -&gt; tstk stack_ty -&gt; tstk dig_proof_argument tzresult Lwt.t =
       fun n stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, Item_t (v, rest, annot)) -&gt;
            outer_return @@ Dig_proof_argument (Rest, (v, annot), rest)
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) rest
            &gt;&gt;=? fun (Dig_proof_argument (n', (x, xv), aft')) -&gt;
            outer_return
            @@ Dig_proof_argument (Prefix n', (x, xv), Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_DIG, 1, whole_stack))</abbr>
      in
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun n -&gt;
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument n stack
      &gt;&gt;=? fun (Dig_proof_argument (n', (x, stack_annot), aft)) -&gt;
      typed ctxt loc (Dig (n, n')) (Item_t (x, aft, stack_annot))
  | (Prim (loc, I_DIG, (([] | _ :: _ :: _) as l), _), _) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, I_DIG, 1, List.length l))</abbr>
  | (Prim (loc, I_DUG, [n], result_annot), Item_t (x, whole_stack, stack_annot))
    -&gt;
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun whole_n -&gt;
      let rec make_proof_argument :
          type tstk x.
          int -&gt;
          x ty -&gt;
          var_annot option -&gt;
          tstk stack_ty -&gt;
          (tstk, x) dug_proof_argument tzresult Lwt.t =
       fun n x stack_annot stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, rest) -&gt;
            outer_return
            @@ Dug_proof_argument (Rest, (), Item_t (x, rest, stack_annot))
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) x stack_annot rest
            &gt;&gt;=? fun (Dug_proof_argument (n', (), aft')) -&gt;
            outer_return
            @@ Dug_proof_argument (Prefix n', (), Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt whole_stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_DUG, whole_n, whole_stack))</abbr>
      in
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument whole_n x stack_annot whole_stack
      &gt;&gt;=? fun (Dug_proof_argument (n', (), aft)) -&gt;
      typed ctxt loc (Dug (whole_n, n')) aft
  | (Prim (loc, I_DUG, [_], result_annot), (Empty_t as stack)) -&gt;
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_DUG, 1, stack))</abbr>
  | (Prim (loc, I_DUG, (([] | _ :: _ :: _) as l), _), _) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, I_DUG, 1, List.length l))</abbr>
  | ( Prim (loc, I_SWAP, [], annot),
      Item_t (v, Item_t (w, rest, stack_annot), cur_top_annot) ) -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      typed
        ctxt
        loc
        Swap
        (Item_t (w, Item_t (v, rest, cur_top_annot), stack_annot))
  | (Prim (loc, I_PUSH, [t; d], annot), stack) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ parse_packable_ty ctxt ~legacy t
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_data ?type_logger ctxt ~legacy t d
      &gt;&gt;=? fun (v, ctxt) -&gt; typed ctxt loc (Const v) (Item_t (t, stack, annot))
  | (Prim (loc, I_UNIT, [], annot), stack) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed ctxt loc (Const ()) (Item_t (Unit_t ty_name, stack, annot))
  (* options *)
  | (Prim (loc, I_SOME, [], annot), Item_t (t, rest, _)) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        Cons_some
        (Item_t (Option_t (t, ty_name, has_big_map t), rest, annot))
  | (Prim (loc, I_NONE, [t], annot), stack) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy t
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        (Cons_none t)
        (Item_t (Option_t (t, ty_name, has_big_map t), stack, annot))
  | ( Prim (loc, I_IF_NONE, [bt; bf], annot),
      (Item_t (Option_t (t, _, _), rest, option_annot) as bef) ) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let annot = gen_access_annot option_annot default_some_annot in
      parse_instr ?type_logger tc_context ctxt ~legacy bt rest
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bf
        (Item_t (t, rest, annot))
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf =
        {loc; instr = If_none (ibt, ibf); bef; aft = ibt.aft}
      in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  (* pairs *)
  | ( Prim (loc, I_PAIR, [], annot),
      Item_t (a, Item_t (b, rest, snd_annot), fst_annot) ) -&gt;
      parse_constr_annot
        loc
        annot
        ~if_special_first:(var_to_field_annot fst_annot)
        ~if_special_second:(var_to_field_annot snd_annot)
      &gt;&gt;=? fun (annot, ty_name, l_field, r_field) -&gt;
      typed
        ctxt
        loc
        Cons_pair
        (Item_t
           ( Pair_t
               ( (a, l_field, fst_annot),
                 (b, r_field, snd_annot),
                 ty_name,
                 has_big_map a || has_big_map b ),
             rest,
             annot ))
  | ( Prim (loc, I_CAR, [], annot),
      Item_t
        (Pair_t ((a, expected_field_annot, a_annot), _, _, _), rest, pair_annot)
    ) -&gt;
      parse_destr_annot
        loc
        annot
        ~pair_annot
        ~value_annot:a_annot
        ~field_name:expected_field_annot
        ~default_accessor:default_car_annot
      &gt;&gt;=? fun (annot, field_annot) -&gt;
      Lwt.return @@ check_correct_field field_annot expected_field_annot
      &gt;&gt;=? fun () -&gt; typed ctxt loc Car (Item_t (a, rest, annot))
  | ( Prim (loc, I_CDR, [], annot),
      Item_t
        (Pair_t (_, (b, expected_field_annot, b_annot), _, _), rest, pair_annot)
    ) -&gt;
      parse_destr_annot
        loc
        annot
        ~pair_annot
        ~value_annot:b_annot
        ~field_name:expected_field_annot
        ~default_accessor:default_cdr_annot
      &gt;&gt;=? fun (annot, field_annot) -&gt;
      Lwt.return @@ check_correct_field field_annot expected_field_annot
      &gt;&gt;=? fun () -&gt; typed ctxt loc Cdr (Item_t (b, rest, annot))
  (* unions *)
  | (Prim (loc, I_LEFT, [tr], annot), Item_t (tl, rest, stack_annot)) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy tr
      &gt;&gt;=? fun (Ex_ty tr, ctxt) -&gt;
      parse_constr_annot
        loc
        annot
        ~if_special_first:(var_to_field_annot stack_annot)
      &gt;&gt;=? fun (annot, tname, l_field, r_field) -&gt;
      typed
        ctxt
        loc
        Left
        (Item_t
           ( Union_t
               ( (tl, l_field),
                 (tr, r_field),
                 tname,
                 has_big_map tl || has_big_map tr ),
             rest,
             annot ))
  | (Prim (loc, I_RIGHT, [tl], annot), Item_t (tr, rest, stack_annot)) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy tl
      &gt;&gt;=? fun (Ex_ty tl, ctxt) -&gt;
      parse_constr_annot
        loc
        annot
        ~if_special_second:(var_to_field_annot stack_annot)
      &gt;&gt;=? fun (annot, tname, l_field, r_field) -&gt;
      typed
        ctxt
        loc
        Right
        (Item_t
           ( Union_t
               ( (tl, l_field),
                 (tr, r_field),
                 tname,
                 has_big_map tl || has_big_map tr ),
             rest,
             annot ))
  | ( Prim (loc, I_IF_LEFT, [bt; bf], annot),
      ( Item_t (Union_t ((tl, l_field), (tr, r_field), _, _), rest, union_annot)
      as bef ) ) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let left_annot =
        gen_access_annot union_annot l_field ~default:default_left_annot
      in
      let right_annot =
        gen_access_annot union_annot r_field ~default:default_right_annot
      in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bt
        (Item_t (tl, rest, left_annot))
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bf
        (Item_t (tr, rest, right_annot))
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf =
        {loc; instr = If_left (ibt, ibf); bef; aft = ibt.aft}
      in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  (* lists *)
  | (Prim (loc, I_NIL, [t], annot), stack) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy t
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        Nil
        (Item_t (List_t (t, ty_name, has_big_map t), stack, annot))
  | ( Prim (loc, I_CONS, [], annot),
      Item_t (tv, Item_t (List_t (t, ty_name, has_big_map), rest, _), _) ) -&gt;
      check_item_ty ctxt tv t loc I_CONS 1 2
      &gt;&gt;=? fun (Eq, t, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Cons_list
        (Item_t (List_t (t, ty_name, has_big_map), rest, annot))
  | ( Prim (loc, I_IF_CONS, [bt; bf], annot),
      (Item_t (List_t (t, ty_name, has_big_map), rest, list_annot) as bef) ) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let hd_annot = gen_access_annot list_annot default_hd_annot in
      let tl_annot = gen_access_annot list_annot default_tl_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bt
        (Item_t
           ( t,
             Item_t (List_t (t, ty_name, has_big_map), rest, tl_annot),
             hd_annot ))
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy bf rest
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf =
        {loc; instr = If_cons (ibt, ibf); bef; aft = ibt.aft}
      in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  | (Prim (loc, I_SIZE, [], annot), Item_t (List_t _, rest, _)) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, tname) -&gt;
      typed ctxt loc List_size (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_MAP, [body], annot),
      Item_t (List_t (elt, _, _), starting_rest, list_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (ret_annot, list_ty_name) -&gt;
      let elt_annot = gen_access_annot list_annot default_elt_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (elt, starting_rest, elt_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft = Item_t (ret, rest, _); _} as ibody) -&gt;
          let invalid_map_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;|? fun (aft, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_map_body (loc, aft)</abbr>
          in
          trace_eval
            invalid_map_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 rest starting_rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt rest starting_rest
            &gt;&gt;=? fun (rest, ctxt) -&gt;
            typed
              ctxt
              loc
              (List_map ibody)
              (Item_t
                 (List_t (ret, list_ty_name, has_big_map ret), rest, ret_annot))
            )
      | Typed {aft; _} -&gt;
          serialize_stack_for_error ctxt aft
          &gt;&gt;=? fun (aft, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_map_body (loc, aft))</abbr>
      | Failed _ -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_map_block_fail loc)</abbr> )
  | ( Prim (loc, I_ITER, [body], annot),
      Item_t (List_t (elt, _, _), rest, list_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let elt_annot = gen_access_annot list_annot default_elt_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (elt, rest, elt_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as ibody) -&gt;
          let invalid_iter_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt rest
            &gt;&gt;|? fun (rest, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_iter_body (loc, rest, aft)</abbr>
          in
          trace_eval
            invalid_iter_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 aft rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt aft rest
            &gt;&gt;=? fun (rest, ctxt) -&gt; typed ctxt loc (List_iter ibody) rest )
      | Failed {descr} -&gt;
          typed ctxt loc (List_iter (descr rest)) rest )
  (* sets *)
  | (Prim (loc, I_EMPTY_SET, [t], annot), rest) -&gt;
      Lwt.return @@ parse_comparable_ty ctxt t
      &gt;&gt;=? fun (Ex_comparable_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, tname) -&gt;
      typed ctxt loc (Empty_set t) (Item_t (Set_t (t, tname), rest, annot))
  | ( Prim (loc, I_ITER, [body], annot),
      Item_t (Set_t (comp_elt, _), rest, set_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let elt_annot = gen_access_annot set_annot default_elt_annot in
      let elt = ty_of_comparable_ty comp_elt in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (elt, rest, elt_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as ibody) -&gt;
          let invalid_iter_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt rest
            &gt;&gt;|? fun (rest, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_iter_body (loc, rest, aft)</abbr>
          in
          trace_eval
            invalid_iter_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 aft rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt aft rest
            &gt;&gt;=? fun (rest, ctxt) -&gt; typed ctxt loc (Set_iter ibody) rest )
      | Failed {descr} -&gt;
          typed ctxt loc (Set_iter (descr rest)) rest )
  | ( Prim (loc, I_MEM, [], annot),
      Item_t (v, Item_t (Set_t (elt, _), rest, _), _) ) -&gt;
      let elt = ty_of_comparable_ty elt in
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, tname) -&gt;
      check_item_ty ctxt elt v loc I_MEM 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      typed ctxt loc Set_mem (Item_t (Bool_t tname, rest, annot))
  | ( Prim (loc, I_UPDATE, [], annot),
      Item_t
        ( v,
          Item_t (Bool_t _, Item_t (Set_t (elt, tname), rest, set_annot), _),
          _ ) ) -&gt; (
    match comparable_ty_of_ty v with
    | None -&gt;
        unparse_ty ctxt v
        &gt;&gt;=? fun (v, _ctxt) -&gt;
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Comparable_type_expected (loc, Micheline.strip_locations v))</abbr>
    | Some v -&gt;
        parse_var_annot loc annot ~default:set_annot
        &gt;&gt;=? fun annot -&gt;
        check_item_comparable_ty elt v loc I_UPDATE 1 3
        &gt;&gt;=? fun (Eq, elt) -&gt;
        typed ctxt loc Set_update (Item_t (Set_t (elt, tname), rest, annot)) )
  | (Prim (loc, I_SIZE, [], annot), Item_t (Set_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Set_size (Item_t (Nat_t None, rest, annot))
  (* maps *)
  | (Prim (loc, I_EMPTY_MAP, [tk; tv], annot), stack) -&gt;
      Lwt.return @@ parse_comparable_ty ctxt tk
      &gt;&gt;=? fun (Ex_comparable_ty tk, ctxt) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy tv
      &gt;&gt;=? fun (Ex_ty tv, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        (Empty_map (tk, tv))
        (Item_t (Map_t (tk, tv, ty_name, has_big_map tv), stack, annot))
  | ( Prim (loc, I_MAP, [body], annot),
      Item_t (Map_t (ck, elt, _, _), starting_rest, _map_annot) ) -&gt; (
      let k = ty_of_comparable_ty ck in
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (ret_annot, ty_name) -&gt;
      let k_name = field_to_var_annot default_key_annot in
      let e_name = field_to_var_annot default_elt_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t
           ( Pair_t
               ((k, None, k_name), (elt, None, e_name), None, has_big_map elt),
             starting_rest,
             None ))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft = Item_t (ret, rest, _); _} as ibody) -&gt;
          let invalid_map_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;|? fun (aft, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_map_body (loc, aft)</abbr>
          in
          trace_eval
            invalid_map_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 rest starting_rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt rest starting_rest
            &gt;&gt;=? fun (rest, ctxt) -&gt;
            typed
              ctxt
              loc
              (Map_map ibody)
              (Item_t
                 (Map_t (ck, ret, ty_name, has_big_map ret), rest, ret_annot))
            )
      | Typed {aft; _} -&gt;
          serialize_stack_for_error ctxt aft
          &gt;&gt;=? fun (aft, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_map_body (loc, aft))</abbr>
      | Failed _ -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_map_block_fail loc)</abbr> )
  | ( Prim (loc, I_ITER, [body], annot),
      Item_t (Map_t (comp_elt, element_ty, _, _), rest, _map_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let k_name = field_to_var_annot default_key_annot in
      let e_name = field_to_var_annot default_elt_annot in
      let key = ty_of_comparable_ty comp_elt in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t
           ( Pair_t
               ( (key, None, k_name),
                 (element_ty, None, e_name),
                 None,
                 has_big_map element_ty ),
             rest,
             None ))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as ibody) -&gt;
          let invalid_iter_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt rest
            &gt;&gt;|? fun (rest, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Invalid_iter_body (loc, rest, aft)</abbr>
          in
          trace_eval
            invalid_iter_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 aft rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt aft rest
            &gt;&gt;=? fun (rest, ctxt) -&gt; typed ctxt loc (Map_iter ibody) rest )
      | Failed {descr} -&gt;
          typed ctxt loc (Map_iter (descr rest)) rest )
  | ( Prim (loc, I_MEM, [], annot),
      Item_t (vk, Item_t (Map_t (ck, _, _, _), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_MEM 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Map_mem (Item_t (Bool_t None, rest, annot))
  | ( Prim (loc, I_GET, [], annot),
      Item_t (vk, Item_t (Map_t (ck, elt, _, has_big_map), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_GET 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Map_get
        (Item_t (Option_t (elt, None, has_big_map), rest, annot))
  | ( Prim (loc, I_UPDATE, [], annot),
      Item_t
        ( vk,
          Item_t
            ( Option_t (vv, _, _),
              Item_t (Map_t (ck, v, map_name, has_big_map), rest, map_annot),
              _ ),
          _ ) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_UPDATE 1 3
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      check_item_ty ctxt vv v loc I_UPDATE 2 3
      &gt;&gt;=? fun (Eq, v, ctxt) -&gt;
      parse_var_annot loc annot ~default:map_annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Map_update
        (Item_t (Map_t (ck, v, map_name, has_big_map), rest, annot))
  | (Prim (loc, I_SIZE, [], annot), Item_t (Map_t (_, _, _, _), rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Map_size (Item_t (Nat_t None, rest, annot))
  (* big_map *)
  | (Prim (loc, I_EMPTY_BIG_MAP, [tk; tv], annot), stack) -&gt;
      Lwt.return @@ parse_comparable_ty ctxt tk
      &gt;&gt;=? fun (Ex_comparable_ty tk, ctxt) -&gt;
      Lwt.return @@ parse_packable_ty ctxt ~legacy tv
      &gt;&gt;=? fun (Ex_ty tv, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        (Empty_big_map (tk, tv))
        (Item_t (Big_map_t (tk, tv, ty_name), stack, annot))
  | ( Prim (loc, I_MEM, [], annot),
      Item_t (set_key, Item_t (Big_map_t (map_key, _, _), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty map_key in
      check_item_ty ctxt set_key k loc I_MEM 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Big_map_mem (Item_t (Bool_t None, rest, annot))
  | ( Prim (loc, I_GET, [], annot),
      Item_t (vk, Item_t (Big_map_t (ck, elt, _), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_GET 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Big_map_get
        (Item_t (Option_t (elt, None, has_big_map elt), rest, annot))
  | ( Prim (loc, I_UPDATE, [], annot),
      Item_t
        ( set_key,
          Item_t
            ( Option_t (set_value, _, _),
              Item_t (Big_map_t (map_key, map_value, map_name), rest, map_annot),
              _ ),
          _ ) ) -&gt;
      let k = ty_of_comparable_ty map_key in
      check_item_ty ctxt set_key k loc I_UPDATE 1 3
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      check_item_ty ctxt set_value map_value loc I_UPDATE 2 3
      &gt;&gt;=? fun (Eq, map_value, ctxt) -&gt;
      parse_var_annot loc annot ~default:map_annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Big_map_update
        (Item_t (Big_map_t (map_key, map_value, map_name), rest, annot))
  (* control *)
  | (Seq (loc, []), stack) -&gt;
      typed ctxt loc Nop stack
  | (Seq (loc, [single]), stack) -&gt; (
      parse_instr ?type_logger tc_context ctxt ~legacy single stack
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as instr) -&gt;
          let nop = {bef = aft; loc; aft; instr = Nop} in
          typed ctxt loc (Seq (instr, nop)) aft
      | Failed {descr; _} -&gt;
          let descr aft =
            let nop = {bef = aft; loc; aft; instr = Nop} in
            let descr = descr aft in
            <abbr class="mark-error" title="Record substitution not handled">{descr with instr = Seq (descr, nop)}</abbr>
          in
          return ctxt (Failed {descr}) )
  | (Seq (loc, hd :: tl), stack) -&gt; (
      parse_instr ?type_logger tc_context ctxt ~legacy hd stack
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Failed _ -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Fail_not_in_tail_position (Micheline.location hd))</abbr>
      | Typed ({aft = middle; _} as ihd) -&gt; (
          parse_instr
            ?type_logger
            tc_context
            ctxt
            ~legacy
            (Seq (-1, tl))
            middle
          &gt;&gt;=? fun (judgement, ctxt) -&gt;
          match judgement with
          | Failed {descr} -&gt;
              let descr ret =
                {loc; instr = Seq (ihd, descr ret); bef = stack; aft = ret}
              in
              return ctxt (Failed {descr})
          | Typed itl -&gt;
              typed ctxt loc (Seq (ihd, itl)) itl.aft ) )
  | (Prim (loc, I_IF, [bt; bf], annot), (Item_t (Bool_t _, rest, _) as bef)) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy bt rest
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy bf rest
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf = {loc; instr = If (ibt, ibf); bef; aft = ibt.aft} in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  | ( Prim (loc, I_LOOP, [body], annot),
      (Item_t (Bool_t _, rest, _stack_annot) as stack) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy body rest
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ibody -&gt;
          let unmatched_branches () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;|? fun (stack, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Unmatched_branches (loc, aft, stack)</abbr>
          in
          trace_eval
            unmatched_branches
            ( Lwt.return @@ stack_ty_eq ctxt 1 ibody.aft stack
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt ibody.aft stack
            &gt;&gt;=? fun (_stack, ctxt) -&gt; typed ctxt loc (Loop ibody) rest )
      | Failed {descr} -&gt;
          let ibody = descr stack in
          typed ctxt loc (Loop ibody) rest )
  | ( Prim (loc, I_LOOP_LEFT, [body], annot),
      ( Item_t (Union_t ((tl, l_field), (tr, _), _, _), rest, union_annot) as
      stack ) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      let l_annot =
        gen_access_annot union_annot l_field ~default:default_left_annot
      in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (tl, rest, l_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ibody -&gt;
          let unmatched_branches () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;|? fun (stack, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Unmatched_branches (loc, aft, stack)</abbr>
          in
          trace_eval
            unmatched_branches
            ( Lwt.return @@ stack_ty_eq ctxt 1 ibody.aft stack
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt ibody.aft stack
            &gt;&gt;=? fun (_stack, ctxt) -&gt;
            typed ctxt loc (Loop_left ibody) (Item_t (tr, rest, annot)) )
      | Failed {descr} -&gt;
          let ibody = descr stack in
          typed ctxt loc (Loop_left ibody) (Item_t (tr, rest, annot)) )
  | (Prim (loc, I_LAMBDA, [arg; ret; code], annot), stack) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy arg
      &gt;&gt;=? fun (Ex_ty arg, ctxt) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy ret
      &gt;&gt;=? fun (Ex_ty ret, ctxt) -&gt;
      check_kind [Seq_kind] code
      &gt;&gt;=? fun () -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      parse_returning
        Lambda
        ?type_logger
        ctxt
        ~legacy
        (arg, default_arg_annot)
        ret
        code
      &gt;&gt;=? fun (lambda, ctxt) -&gt;
      typed
        ctxt
        loc
        (Lambda lambda)
        (Item_t (Lambda_t (arg, ret, None), stack, annot))
  | ( Prim (loc, I_EXEC, [], annot),
      Item_t (arg, Item_t (Lambda_t (param, ret, _), rest, _), _) ) -&gt;
      check_item_ty ctxt arg param loc I_EXEC 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Exec (Item_t (ret, rest, annot))
  | ( Prim (loc, I_APPLY, [], annot),
      Item_t
        ( capture,
          Item_t
            ( Lambda_t
                ( Pair_t ((capture_ty, _, _), (arg_ty, _, _), lam_annot, _),
                  ret,
                  _ ),
              rest,
              _ ),
          _ ) ) -&gt;
      Lwt.return @@ check_packable ~legacy:false loc capture_ty
      &gt;&gt;=? fun () -&gt;
      check_item_ty ctxt capture capture_ty loc I_APPLY 1 2
      &gt;&gt;=? fun (Eq, capture_ty, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        (Apply capture_ty)
        (Item_t (Lambda_t (arg_ty, ret, lam_annot), rest, annot))
  | (Prim (loc, I_DIP, [code], annot), Item_t (v, rest, stack_annot)) -&gt; (
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] code
      &gt;&gt;=? fun () -&gt;
      parse_instr
        ?type_logger
        (add_dip v stack_annot tc_context)
        ctxt
        ~legacy
        code
        rest
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed descr -&gt;
          typed ctxt loc (Dip descr) (Item_t (v, descr.aft, stack_annot))
      | Failed _ -&gt;
          fail <abbr class="mark-error" title="Values of extensible types are not handled">(Fail_not_in_tail_position loc)</abbr> )
  | (Prim (loc, I_DIP, [n; code], result_annot), stack)
    when match parse_int32 n with Ok _ -&gt; true | Error _ -&gt; false -&gt;
      let rec make_proof_argument :
          type tstk.
          int
          (* -&gt; (fbef stack_ty -&gt; (fbef judgement * context) tzresult Lwt.t) *) -&gt;
          tc_context -&gt;
          tstk stack_ty -&gt;
          tstk dipn_proof_argument tzresult Lwt.t =
       fun n inner_tc_context stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, rest) -&gt; (
            parse_instr ?type_logger inner_tc_context ctxt ~legacy code rest
            &gt;&gt;=? fun (judgement, ctxt) -&gt;
            match judgement with
            | Typed descr -&gt;
                outer_return
                @@ Dipn_proof_argument (Rest, (ctxt, descr), descr.aft)
            | Failed _ -&gt;
                fail <abbr class="mark-error" title="Values of extensible types are not handled">(Fail_not_in_tail_position loc)</abbr> )
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) (add_dip v annot tc_context) rest
            &gt;&gt;=? fun (Dipn_proof_argument (n', descr, aft')) -&gt;
            outer_return
            @@ Dipn_proof_argument (Prefix n', descr, Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_DIP, 1, whole_stack))</abbr>
      in
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun n -&gt;
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument n tc_context stack
      &gt;&gt;=? fun (Dipn_proof_argument (n', (new_ctxt, descr), aft)) -&gt;
      (* TODO: which context should be used in the next line? new_ctxt or the old ctxt? *)
      typed new_ctxt loc (Dipn (n, n', descr)) aft
  | (Prim (loc, I_DIP, (([] | _ :: _ :: _ :: _) as l), _), _) -&gt;
      (* Technically, the arities 1 and 2 are allowed but the error only mentions 2.
           However, DIP {code} is equivalent to DIP 1 {code} so hinting at an arity of 2 makes sense. *)
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, I_DIP, 2, List.length l))</abbr>
  | (Prim (loc, I_FAILWITH, [], annot), Item_t (v, _rest, _)) -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let descr aft = {loc; instr = Failwith v; bef = stack_ty; aft} in
      log_stack ctxt loc stack_ty Empty_t
      &gt;&gt;=? fun () -&gt; return ctxt (Failed {descr})
  (* timestamp operations *)
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Timestamp_t tname, Item_t (Int_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Add_timestamp_to_seconds
        (Item_t (Timestamp_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Int_t _, Item_t (Timestamp_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Add_seconds_to_timestamp
        (Item_t (Timestamp_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Timestamp_t tname, Item_t (Int_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Sub_timestamp_seconds
        (Item_t (Timestamp_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Timestamp_t tn1, Item_t (Timestamp_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Diff_timestamps (Item_t (Int_t tname, rest, annot))
  (* string operations *)
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (String_t tn1, Item_t (String_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Concat_string_pair (Item_t (String_t tname, rest, annot))
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (List_t (String_t tname, _, _), rest, list_annot) ) -&gt;
      parse_var_annot ~default:list_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Concat_string (Item_t (String_t tname, rest, annot))
  | ( Prim (loc, I_SLICE, [], annot),
      Item_t
        ( Nat_t _,
          Item_t (Nat_t _, Item_t (String_t tname, rest, string_annot), _),
          _ ) ) -&gt;
      parse_var_annot
        ~default:(gen_access_annot string_annot default_slice_annot)
        loc
        annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Slice_string
        (Item_t (Option_t (String_t tname, None, false), rest, annot))
  | (Prim (loc, I_SIZE, [], annot), Item_t (String_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc String_size (Item_t (Nat_t None, rest, annot))
  (* bytes operations *)
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (Bytes_t tn1, Item_t (Bytes_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Concat_bytes_pair (Item_t (Bytes_t tname, rest, annot))
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (List_t (Bytes_t tname, _, _), rest, list_annot) ) -&gt;
      parse_var_annot ~default:list_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Concat_bytes (Item_t (Bytes_t tname, rest, annot))
  | ( Prim (loc, I_SLICE, [], annot),
      Item_t
        ( Nat_t _,
          Item_t (Nat_t _, Item_t (Bytes_t tname, rest, bytes_annot), _),
          _ ) ) -&gt;
      parse_var_annot
        ~default:(gen_access_annot bytes_annot default_slice_annot)
        loc
        annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Slice_bytes
        (Item_t (Option_t (Bytes_t tname, None, false), rest, annot))
  | (Prim (loc, I_SIZE, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Bytes_size (Item_t (Nat_t None, rest, annot))
  (* currency operations *)
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Mutez_t tn1, Item_t (Mutez_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Add_tez (Item_t (Mutez_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Mutez_t tn1, Item_t (Mutez_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Sub_tez (Item_t (Mutez_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Mutez_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      (* no type name check *)
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_teznat (Item_t (Mutez_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Nat_t _, Item_t (Mutez_t tname, rest, _), _) ) -&gt;
      (* no type name check *)
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_nattez (Item_t (Mutez_t tname, rest, annot))
  (* boolean operations *)
  | ( Prim (loc, I_OR, [], annot),
      Item_t (Bool_t tn1, Item_t (Bool_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt; typed ctxt loc Or (Item_t (Bool_t tname, rest, annot))
  | ( Prim (loc, I_AND, [], annot),
      Item_t (Bool_t tn1, Item_t (Bool_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt; typed ctxt loc And (Item_t (Bool_t tname, rest, annot))
  | ( Prim (loc, I_XOR, [], annot),
      Item_t (Bool_t tn1, Item_t (Bool_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt; typed ctxt loc Xor (Item_t (Bool_t tname, rest, annot))
  | (Prim (loc, I_NOT, [], annot), Item_t (Bool_t tname, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Not (Item_t (Bool_t tname, rest, annot))
  (* integer operations *)
  | (Prim (loc, I_ABS, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Abs_int (Item_t (Nat_t None, rest, annot))
  | (Prim (loc, I_ISNAT, [], annot), Item_t (Int_t _, rest, int_annot)) -&gt;
      parse_var_annot loc annot ~default:int_annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Is_nat
        (Item_t (Option_t (Nat_t None, None, false), rest, annot))
  | (Prim (loc, I_INT, [], annot), Item_t (Nat_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Int_nat (Item_t (Int_t None, rest, annot))
  | (Prim (loc, I_NEG, [], annot), Item_t (Int_t tname, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Neg_int (Item_t (Int_t tname, rest, annot))
  | (Prim (loc, I_NEG, [], annot), Item_t (Nat_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Neg_nat (Item_t (Int_t None, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Add_intint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Add_intnat (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Nat_t _, Item_t (Int_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Add_natint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Add_natnat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Nat_t _, Item_t (Int_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun _tname -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t None, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Mul_intint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_intnat (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Nat_t _, Item_t (Int_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_natint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Mul_natnat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Mutez_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Ediv_teznat
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Mutez_t tname, None, None),
                     (Mutez_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Mutez_t tn1, Item_t (Mutez_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed
        ctxt
        loc
        Ediv_tez
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Nat_t None, None, None),
                     (Mutez_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed
        ctxt
        loc
        Ediv_intint
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Int_t tname, None, None),
                     (Nat_t None, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Ediv_intnat
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Int_t tname, None, None),
                     (Nat_t None, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Nat_t tname, Item_t (Int_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Ediv_natint
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Int_t None, None, None),
                     (Nat_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed
        ctxt
        loc
        Ediv_natnat
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Nat_t tname, None, None),
                     (Nat_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_LSL, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Lsl_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_LSR, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Lsr_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_OR, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Or_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_AND, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc And_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_AND, [], annot),
      Item_t (Int_t _, Item_t (Nat_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc And_int_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_XOR, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Xor_nat (Item_t (Nat_t tname, rest, annot))
  | (Prim (loc, I_NOT, [], annot), Item_t (Int_t tname, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Not_int (Item_t (Int_t tname, rest, annot))
  | (Prim (loc, I_NOT, [], annot), Item_t (Nat_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Not_nat (Item_t (Int_t None, rest, annot))
  (* comparison *)
  | (Prim (loc, I_COMPARE, [], annot), Item_t (t1, Item_t (t2, rest, _), _))
    -&gt; (
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      check_item_ty ctxt t1 t2 loc I_COMPARE 1 2
      &gt;&gt;=? fun (Eq, t, ctxt) -&gt;
      match comparable_ty_of_ty t with
      | None -&gt;
          Lwt.return (serialize_ty_for_error ctxt t)
          &gt;&gt;=? fun (t, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Comparable_type_expected (loc, t))</abbr>
      | Some key -&gt;
          typed ctxt loc (Compare key) (Item_t (Int_t None, rest, annot)) )
  (* comparators *)
  | (Prim (loc, I_EQ, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Eq (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_NEQ, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Neq (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_LT, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Lt (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_GT, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Gt (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_LE, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Le (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_GE, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Ge (Item_t (Bool_t None, rest, annot))
  (* annotations *)
  | (Prim (loc, I_CAST, [cast_t], annot), Item_t (t, stack, item_annot)) -&gt;
      parse_var_annot loc annot ~default:item_annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy cast_t
      &gt;&gt;=? fun (Ex_ty cast_t, ctxt) -&gt;
      Lwt.return @@ ty_eq ctxt cast_t t
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc cast_t t
      &gt;&gt;=? fun (_, ctxt) -&gt; typed ctxt loc Nop (Item_t (cast_t, stack, annot))
  | (Prim (loc, I_RENAME, [], annot), Item_t (t, stack, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      (* can erase annot *)
      typed ctxt loc Nop (Item_t (t, stack, annot))
  (* packing *)
  | (Prim (loc, I_PACK, [], annot), Item_t (t, rest, unpacked_annot)) -&gt;
      Lwt.return
        (check_packable
           ~legacy:true
           (* allow to pack contracts for hash/signature checks *) loc
           t)
      &gt;&gt;=? fun () -&gt;
      parse_var_annot
        loc
        annot
        ~default:(gen_access_annot unpacked_annot default_pack_annot)
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc (Pack t) (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_UNPACK, [ty], annot), Item_t (Bytes_t _, rest, packed_annot))
    -&gt;
      Lwt.return @@ parse_packable_ty ctxt ~legacy ty
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      let annot =
        default_annot
          annot
          ~default:(gen_access_annot packed_annot default_unpack_annot)
      in
      typed
        ctxt
        loc
        (Unpack t)
        (Item_t
           ( Option_t (t, ty_name, false (* cannot unpack big_maps *)),
             rest,
             annot ))
  (* protocol *)
  | ( Prim (loc, I_ADDRESS, [], annot),
      Item_t (Contract_t _, rest, contract_annot) ) -&gt;
      parse_var_annot
        loc
        annot
        ~default:(gen_access_annot contract_annot default_addr_annot)
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Address (Item_t (Address_t None, rest, annot))
  | ( Prim (loc, I_CONTRACT, [ty], annot),
      Item_t (Address_t _, rest, addr_annot) ) -&gt;
      Lwt.return @@ parse_parameter_ty ctxt ~legacy ty
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_entrypoint_annot
        loc
        annot
        ~default:(gen_access_annot addr_annot default_contract_annot)
      &gt;&gt;=? fun (annot, entrypoint) -&gt;
      ( Lwt.return
      @@
      match entrypoint with
      | None -&gt;
          Ok &quot;default&quot;
      | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;default&quot;)</abbr> -&gt;
          error <abbr class="mark-error" title="Values of extensible types are not handled">(Unexpected_annotation loc)</abbr>
      | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot entrypoint)</abbr> -&gt;
          if Compare.Int.(String.length entrypoint &gt; 31) then
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Entrypoint_name_too_long entrypoint)</abbr>
          else Ok entrypoint )
      &gt;&gt;=? fun entrypoint -&gt;
      typed
        ctxt
        loc
        (Contract (t, entrypoint))
        (Item_t (Option_t (Contract_t (t, None), None, false), rest, annot))
  | ( Prim (loc, I_TRANSFER_TOKENS, [], annot),
      Item_t (p, Item_t (Mutez_t _, Item_t (Contract_t (cp, _), rest, _), _), _)
    ) -&gt;
      check_item_ty ctxt p cp loc I_TRANSFER_TOKENS 1 4
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Transfer_tokens (Item_t (Operation_t None, rest, annot))
  | ( Prim (loc, I_SET_DELEGATE, [], annot),
      Item_t (Option_t (Key_hash_t _, _, _), rest, _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Set_delegate (Item_t (Operation_t None, rest, annot))
  | ( Prim (loc, I_CREATE_ACCOUNT, [], annot),
      Item_t
        ( Key_hash_t _,
          Item_t
            ( Option_t (Key_hash_t _, _, _),
              Item_t (Bool_t _, Item_t (Mutez_t _, rest, _), _),
              _ ),
          _ ) ) -&gt;
      if legacy then
        (* For existing contracts, this instruction is still allowed *)
        parse_two_var_annot loc annot
        &gt;&gt;=? fun (op_annot, addr_annot) -&gt;
        typed
          ctxt
          loc
          Create_account
          (Item_t
             ( Operation_t None,
               Item_t (Address_t None, rest, addr_annot),
               op_annot ))
      else
        (* For new contracts this instruction is not allowed anymore *)
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Deprecated_instruction I_CREATE_ACCOUNT)</abbr>
  | (Prim (loc, I_IMPLICIT_ACCOUNT, [], annot), Item_t (Key_hash_t _, rest, _))
    -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Implicit_account
        (Item_t (Contract_t (Unit_t None, None), rest, annot))
  | ( Prim (loc, I_CREATE_CONTRACT, [(Seq _ as code)], annot),
      Item_t
        ( Key_hash_t _,
          Item_t
            ( Option_t (Key_hash_t _, _, _),
              Item_t
                ( Bool_t _,
                  Item_t
                    ( Bool_t _,
                      Item_t (Mutez_t _, Item_t (ginit, rest, _), _),
                      _ ),
                  _ ),
              _ ),
          _ ) ) -&gt;
      if legacy then
        (* For existing contracts, this instruction is still allowed *)
        parse_two_var_annot loc annot
        &gt;&gt;=? fun (op_annot, addr_annot) -&gt;
        let cannonical_code = fst @@ Micheline.extract_locations code in
        Lwt.return @@ parse_toplevel ~legacy cannonical_code
        &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
        trace
          <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type
             (Some &quot;parameter&quot;, cannonical_code, location arg_type))</abbr>
          (Lwt.return @@ parse_parameter_ty ctxt ~legacy arg_type)
        &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
        ( if legacy then Error_monad.return ()
        else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
        &gt;&gt;=? fun () -&gt;
        trace
          <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type
             (Some &quot;storage&quot;, cannonical_code, location storage_type))</abbr>
          (Lwt.return @@ parse_storage_ty ctxt ~legacy storage_type)
        &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
        let arg_annot =
          default_annot
            (type_to_var_annot (name_of_ty arg_type))
            ~default:default_param_annot
        in
        let storage_annot =
          default_annot
            (type_to_var_annot (name_of_ty storage_type))
            ~default:default_storage_annot
        in
        let arg_type_full =
          Pair_t
            ( (arg_type, None, arg_annot),
              (storage_type, None, storage_annot),
              None,
              has_big_map arg_type || has_big_map storage_type )
        in
        let ret_type_full =
          Pair_t
            ( (List_t (Operation_t None, None, false), None, None),
              (storage_type, None, None),
              None,
              has_big_map storage_type )
        in
        trace
          <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_typed_contract (cannonical_code, []))</abbr>
          (parse_returning
             (Toplevel
                {
                  storage_type;
                  param_type = arg_type;
                  root_name;
                  legacy_create_contract_literal = true;
                })
             ctxt
             ~legacy
             ?type_logger
             (arg_type_full, None)
             ret_type_full
             code_field)
        &gt;&gt;=? fun ( ( Lam
                       ( { bef = Item_t (arg, Empty_t, _);
                           aft = Item_t (ret, Empty_t, _);
                           _ },
                         _ ) as lambda ),
                   ctxt ) -&gt;
        Lwt.return @@ ty_eq ctxt arg arg_type_full
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return @@ merge_types ~legacy ctxt loc arg arg_type_full
        &gt;&gt;=? fun (_, ctxt) -&gt;
        Lwt.return @@ ty_eq ctxt ret ret_type_full
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return @@ merge_types ~legacy ctxt loc ret ret_type_full
        &gt;&gt;=? fun (_, ctxt) -&gt;
        Lwt.return @@ ty_eq ctxt storage_type ginit
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return @@ merge_types ~legacy ctxt loc storage_type ginit
        &gt;&gt;=? fun (_, ctxt) -&gt;
        typed
          ctxt
          loc
          (Create_contract (storage_type, arg_type, lambda, root_name))
          (Item_t
             ( Operation_t None,
               Item_t (Address_t None, rest, addr_annot),
               op_annot ))
      else
        (* For new contracts this instruction is not allowed anymore *)
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Deprecated_instruction I_CREATE_CONTRACT)</abbr>
  | ( Prim (loc, I_CREATE_CONTRACT, [(Seq _ as code)], annot),
      (* Removed the instruction's arguments manager, spendable and delegatable *)
    Item_t
      ( Option_t (Key_hash_t _, _, _),
        Item_t (Mutez_t _, Item_t (ginit, rest, _), _),
        _ ) ) -&gt;
      parse_two_var_annot loc annot
      &gt;&gt;=? fun (op_annot, addr_annot) -&gt;
      let cannonical_code = fst @@ Micheline.extract_locations code in
      Lwt.return @@ parse_toplevel ~legacy cannonical_code
      &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
      trace
        <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type (Some &quot;parameter&quot;, cannonical_code, location arg_type))</abbr>
        (Lwt.return @@ parse_parameter_ty ctxt ~legacy arg_type)
      &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
      ( if legacy then Error_monad.return ()
      else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
      &gt;&gt;=? fun () -&gt;
      trace
        <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type
           (Some &quot;storage&quot;, cannonical_code, location storage_type))</abbr>
        (Lwt.return @@ parse_storage_ty ctxt ~legacy storage_type)
      &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
      let arg_annot =
        default_annot
          (type_to_var_annot (name_of_ty arg_type))
          ~default:default_param_annot
      in
      let storage_annot =
        default_annot
          (type_to_var_annot (name_of_ty storage_type))
          ~default:default_storage_annot
      in
      let arg_type_full =
        Pair_t
          ( (arg_type, None, arg_annot),
            (storage_type, None, storage_annot),
            None,
            has_big_map arg_type || has_big_map storage_type )
      in
      let ret_type_full =
        Pair_t
          ( (List_t (Operation_t None, None, false), None, None),
            (storage_type, None, None),
            None,
            has_big_map storage_type )
      in
      trace
        <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_typed_contract (cannonical_code, []))</abbr>
        (parse_returning
           (Toplevel
              {
                storage_type;
                param_type = arg_type;
                root_name;
                legacy_create_contract_literal = false;
              })
           ctxt
           ~legacy
           ?type_logger
           (arg_type_full, None)
           ret_type_full
           code_field)
      &gt;&gt;=? fun ( ( Lam
                     ( { bef = Item_t (arg, Empty_t, _);
                         aft = Item_t (ret, Empty_t, _);
                         _ },
                       _ ) as lambda ),
                 ctxt ) -&gt;
      Lwt.return @@ ty_eq ctxt arg arg_type_full
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc arg arg_type_full
      &gt;&gt;=? fun (_, ctxt) -&gt;
      Lwt.return @@ ty_eq ctxt ret ret_type_full
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc ret ret_type_full
      &gt;&gt;=? fun (_, ctxt) -&gt;
      Lwt.return @@ ty_eq ctxt storage_type ginit
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc storage_type ginit
      &gt;&gt;=? fun (_, ctxt) -&gt;
      typed
        ctxt
        loc
        (Create_contract_2 (storage_type, arg_type, lambda, root_name))
        (Item_t
           ( Operation_t None,
             Item_t (Address_t None, rest, addr_annot),
             op_annot ))
  | (Prim (loc, I_NOW, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_now_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Now (Item_t (Timestamp_t None, stack, annot))
  | (Prim (loc, I_AMOUNT, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_amount_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Amount (Item_t (Mutez_t None, stack, annot))
  | (Prim (loc, I_CHAIN_ID, [], annot), stack) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc ChainId (Item_t (Chain_id_t None, stack, annot))
  | (Prim (loc, I_BALANCE, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_balance_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Balance (Item_t (Mutez_t None, stack, annot))
  | (Prim (loc, I_HASH_KEY, [], annot), Item_t (Key_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Hash_key (Item_t (Key_hash_t None, rest, annot))
  | ( Prim (loc, I_CHECK_SIGNATURE, [], annot),
      Item_t
        (Key_t _, Item_t (Signature_t _, Item_t (Bytes_t _, rest, _), _), _) )
    -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Check_signature (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_BLAKE2B, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Blake2b (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_SHA256, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sha256 (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_SHA512, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sha512 (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_STEPS_TO_QUOTA, [], annot), stack) -&gt;
      if legacy then
        (* For existing contracts, this instruction is still allowed *)
        parse_var_annot loc annot ~default:default_steps_annot
        &gt;&gt;=? fun annot -&gt;
        typed ctxt loc Steps_to_quota (Item_t (Nat_t None, stack, annot))
      else
        (* For new contracts this instruction is not allowed anymore *)
        fail <abbr class="mark-error" title="Values of extensible types are not handled">(Deprecated_instruction I_STEPS_TO_QUOTA)</abbr>
  | (Prim (loc, I_SOURCE, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_source_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Source (Item_t (Address_t None, stack, annot))
  | (Prim (loc, I_SENDER, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_sender_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sender (Item_t (Address_t None, stack, annot))
  | (Prim (loc, I_SELF, [], annot), stack) -&gt;
      parse_entrypoint_annot loc annot ~default:default_self_annot
      &gt;&gt;=? fun (annot, entrypoint) -&gt;
      let entrypoint =
        Option.unopt_map
          ~f:(fun <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot annot)</abbr> -&gt; annot)
          ~default:&quot;default&quot;
          entrypoint
      in
      let rec get_toplevel_type :
          tc_context -&gt; (bef judgement * context) tzresult Lwt.t = function
        | Lambda -&gt;
            fail <abbr class="mark-error" title="Values of extensible types are not handled">(Self_in_lambda loc)</abbr>
        | Dip (_, prev) -&gt;
            get_toplevel_type prev
        | Toplevel
            {param_type; root_name; legacy_create_contract_literal = false} -&gt;
            Lwt.return (find_entrypoint param_type ~root_name entrypoint)
            &gt;&gt;=? fun (_, Ex_ty param_type) -&gt;
            typed
              ctxt
              loc
              (Self (param_type, entrypoint))
              (Item_t (Contract_t (param_type, None), stack, annot))
        | Toplevel
            {param_type; root_name = _; legacy_create_contract_literal = true}
          -&gt;
            typed
              ctxt
              loc
              (Self (param_type, &quot;default&quot;))
              (Item_t (Contract_t (param_type, None), stack, annot))
      in
      get_toplevel_type tc_context
  (* Primitive parsing errors *)
  | ( Prim
        ( loc,
          ( ( I_DUP
            | I_SWAP
            | I_SOME
            | I_UNIT
            | I_PAIR
            | I_CAR
            | I_CDR
            | I_CONS
            | I_CONCAT
            | I_SLICE
            | I_MEM
            | I_UPDATE
            | I_MAP
            | I_GET
            | I_EXEC
            | I_FAILWITH
            | I_SIZE
            | I_ADD
            | I_SUB
            | I_MUL
            | I_EDIV
            | I_OR
            | I_AND
            | I_XOR
            | I_NOT
            | I_ABS
            | I_NEG
            | I_LSL
            | I_LSR
            | I_COMPARE
            | I_EQ
            | I_NEQ
            | I_LT
            | I_GT
            | I_LE
            | I_GE
            | I_TRANSFER_TOKENS
            | I_CREATE_ACCOUNT
            | I_SET_DELEGATE
            | I_NOW
            | I_IMPLICIT_ACCOUNT
            | I_AMOUNT
            | I_BALANCE
            | I_CHECK_SIGNATURE
            | I_HASH_KEY
            | I_SOURCE
            | I_SENDER
            | I_BLAKE2B
            | I_SHA256
            | I_SHA512
            | I_STEPS_TO_QUOTA
            | I_ADDRESS ) as name ),
          (_ :: _ as l),
          _ ),
      _ ) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, name, 0, List.length l))</abbr>
  | ( Prim
        ( loc,
          ( ( I_NONE
            | I_LEFT
            | I_RIGHT
            | I_NIL
            | I_MAP
            | I_ITER
            | I_EMPTY_SET
            | I_DIP
            | I_LOOP
            | I_LOOP_LEFT
            | I_CONTRACT ) as name ),
          (([] | _ :: _ :: _) as l),
          _ ),
      _ ) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, name, 1, List.length l))</abbr>
  | ( Prim
        ( loc,
          ( (I_PUSH | I_IF_NONE | I_IF_LEFT | I_IF_CONS | I_EMPTY_MAP | I_IF)
          as name ),
          (([] | [_] | _ :: _ :: _ :: _) as l),
          _ ),
      _ ) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, name, 2, List.length l))</abbr>
  | (Prim (loc, I_LAMBDA, (([] | [_] | _ :: _ :: _ :: _ :: _) as l), _), _) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, I_LAMBDA, 3, List.length l))</abbr>
  (* Stack errors *)
  | ( Prim
        ( loc,
          ( ( I_ADD
            | I_SUB
            | I_MUL
            | I_EDIV
            | I_AND
            | I_OR
            | I_XOR
            | I_LSL
            | I_LSR ) as name ),
          [],
          _ ),
      Item_t (ta, Item_t (tb, _, _), _) ) -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt ta
      &gt;&gt;=? fun (ta, ctxt) -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt tb
      &gt;&gt;=? fun (tb, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Undefined_binop (loc, name, ta, tb))</abbr>
  | ( Prim
        ( loc,
          ( ( I_NEG
            | I_ABS
            | I_NOT
            | I_CONCAT
            | I_SIZE
            | I_EQ
            | I_NEQ
            | I_LT
            | I_GT
            | I_LE
            | I_GE ) as name ),
          [],
          _ ),
      Item_t (t, _, _) ) -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt t
      &gt;&gt;=? fun (t, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Undefined_unop (loc, name, t))</abbr>
  | (Prim (loc, ((I_UPDATE | I_SLICE) as name), [], _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, name, 3, stack))</abbr>
  | (Prim (loc, I_CREATE_CONTRACT, _, _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_CREATE_CONTRACT, 7, stack))</abbr>
  | (Prim (loc, I_CREATE_ACCOUNT, [], _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_CREATE_ACCOUNT, 4, stack))</abbr>
  | (Prim (loc, I_TRANSFER_TOKENS, [], _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, I_TRANSFER_TOKENS, 4, stack))</abbr>
  | ( Prim
        ( loc,
          ( ( I_DROP
            | I_DUP
            | I_CAR
            | I_CDR
            | I_SOME
            | I_BLAKE2B
            | I_SHA256
            | I_SHA512
            | I_DIP
            | I_IF_NONE
            | I_LEFT
            | I_RIGHT
            | I_IF_LEFT
            | I_IF
            | I_LOOP
            | I_IF_CONS
            | I_IMPLICIT_ACCOUNT
            | I_NEG
            | I_ABS
            | I_INT
            | I_NOT
            | I_HASH_KEY
            | I_EQ
            | I_NEQ
            | I_LT
            | I_GT
            | I_LE
            | I_GE ) as name ),
          _,
          _ ),
      stack ) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, name, 1, stack))</abbr>
  | ( Prim
        ( loc,
          ( ( I_SWAP
            | I_PAIR
            | I_CONS
            | I_GET
            | I_MEM
            | I_EXEC
            | I_CHECK_SIGNATURE
            | I_ADD
            | I_SUB
            | I_MUL
            | I_EDIV
            | I_AND
            | I_OR
            | I_XOR
            | I_LSL
            | I_LSR ) as name ),
          _,
          _ ),
      stack ) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-error" title="Values of extensible types are not handled">(Bad_stack (loc, name, 2, stack))</abbr>
  (* Generic parsing errors *)
  | (expr, _) -&gt;
      fail
      @@ unexpected
           expr
           [Seq_kind]
           Instr_namespace
           [ I_DROP;
             I_DUP;
             I_DIG;
             I_DUG;
             I_SWAP;
             I_SOME;
             I_UNIT;
             I_PAIR;
             I_CAR;
             I_CDR;
             I_CONS;
             I_MEM;
             I_UPDATE;
             I_MAP;
             I_ITER;
             I_GET;
             I_EXEC;
             I_FAILWITH;
             I_SIZE;
             I_CONCAT;
             I_ADD;
             I_SUB;
             I_MUL;
             I_EDIV;
             I_OR;
             I_AND;
             I_XOR;
             I_NOT;
             I_ABS;
             I_INT;
             I_NEG;
             I_LSL;
             I_LSR;
             I_COMPARE;
             I_EQ;
             I_NEQ;
             I_LT;
             I_GT;
             I_LE;
             I_GE;
             I_TRANSFER_TOKENS;
             I_CREATE_ACCOUNT;
             I_CREATE_CONTRACT;
             I_NOW;
             I_AMOUNT;
             I_BALANCE;
             I_IMPLICIT_ACCOUNT;
             I_CHECK_SIGNATURE;
             I_BLAKE2B;
             I_SHA256;
             I_SHA512;
             I_HASH_KEY;
             I_STEPS_TO_QUOTA;
             I_PUSH;
             I_NONE;
             I_LEFT;
             I_RIGHT;
             I_NIL;
             I_EMPTY_SET;
             I_DIP;
             I_LOOP;
             I_IF_NONE;
             I_IF_LEFT;
             I_IF_CONS;
             I_EMPTY_MAP;
             I_IF;
             I_SOURCE;
             I_SENDER;
             I_SELF;
             I_LAMBDA ]

and parse_contract :
    type arg.
    legacy:bool -&gt;
    context -&gt;
    Script.location -&gt;
    arg ty -&gt;
    Contract.t -&gt;
    entrypoint:string -&gt;
    (context * arg typed_contract) tzresult Lwt.t =
 fun ~legacy ctxt loc arg contract ~entrypoint -&gt;
  Lwt.return @@ Gas.consume ctxt Typecheck_costs.contract_exists
  &gt;&gt;=? fun ctxt -&gt;
  Contract.exists ctxt contract
  &gt;&gt;=? function
  | false -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_contract (loc, contract))</abbr>
  | true -&gt; (
      Lwt.return @@ Gas.consume ctxt Typecheck_costs.get_script
      &gt;&gt;=? fun ctxt -&gt;
      trace <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_contract (loc, contract))</abbr>
      @@ Contract.get_script_code ctxt contract
      &gt;&gt;=? fun (ctxt, code) -&gt;
      match code with
      | None -&gt;
          Lwt.return
            ( ty_eq ctxt arg (Unit_t None)
            &gt;&gt;? fun (Eq, ctxt) -&gt;
            match entrypoint with
            | &quot;default&quot; -&gt;
                let contract : arg typed_contract =
                  (arg, (contract, entrypoint))
                in
                ok (ctxt, contract)
            | entrypoint -&gt;
                error <abbr class="mark-error" title="Values of extensible types are not handled">(No_such_entrypoint entrypoint)</abbr> )
      | Some code -&gt;
          Script.force_decode ctxt code
          &gt;&gt;=? fun (code, ctxt) -&gt;
          Lwt.return
            ( parse_toplevel ~legacy:true code
            &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
            parse_parameter_ty ctxt ~legacy:true arg_type
            &gt;&gt;? fun (Ex_ty targ, ctxt) -&gt;
            let return ctxt targ entrypoint =
              merge_types ~legacy ctxt loc targ arg
              &gt;&gt;? fun (arg, ctxt) -&gt;
              let contract : arg typed_contract =
                (arg, (contract, entrypoint))
              in
              ok (ctxt, contract)
            in
            find_entrypoint_for_type
              ~full:targ
              ~expected:arg
              ~root_name
              entrypoint
              ctxt
            &gt;&gt;? fun (ctxt, entrypoint, targ) -&gt;
            merge_types ~legacy ctxt loc targ arg
            &gt;&gt;? fun (targ, ctxt) -&gt; return ctxt targ entrypoint ) )

(* Same as the one above, but does not fail when the contact is missing or
   if the expected type doesn't match the actual one. In that case None is
   returned and some overapproximation of the typechecking gas is consumed.
   This can still fail on gas exhaustion. *)
and parse_contract_for_script :
    type arg.
    legacy:bool -&gt;
    context -&gt;
    Script.location -&gt;
    arg ty -&gt;
    Contract.t -&gt;
    entrypoint:string -&gt;
    (context * arg typed_contract option) tzresult Lwt.t =
 fun ~legacy ctxt loc arg contract ~entrypoint -&gt;
  Lwt.return @@ Gas.consume ctxt Typecheck_costs.contract_exists
  &gt;&gt;=? fun ctxt -&gt;
  Contract.exists ctxt contract
  &gt;&gt;=? function
  | false -&gt;
      return (ctxt, None)
  | true -&gt; (
      Lwt.return @@ Gas.consume ctxt Typecheck_costs.get_script
      &gt;&gt;=? fun ctxt -&gt;
      trace <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_contract (loc, contract))</abbr>
      @@ Contract.get_script_code ctxt contract
      &gt;&gt;=? fun (ctxt, code) -&gt;
      match code with
      (* can only fail because of gas *)
      | None -&gt; (
        match entrypoint with
        | &quot;default&quot; -&gt;
            Lwt.return
              ( match ty_eq ctxt arg (Unit_t None) with
              | Ok (Eq, ctxt) -&gt;
                  let contract : arg typed_contract =
                    (arg, (contract, entrypoint))
                  in
                  ok (ctxt, Some contract)
              | Error _ -&gt;
                  Gas.consume ctxt Typecheck_costs.cycle
                  &gt;&gt;? fun ctxt -&gt; ok (ctxt, None) )
        | _ -&gt;
            return (ctxt, None) )
      | Some code -&gt;
          Script.force_decode ctxt code
          &gt;&gt;=? fun (code, ctxt) -&gt;
          (* can only fail because of gas *)
          Lwt.return
            ( match parse_toplevel ~legacy:true code with
            | Error _ -&gt;
                error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_contract (loc, contract))</abbr>
            | Ok (arg_type, _, _, root_name) -&gt; (
              match parse_parameter_ty ctxt ~legacy:true arg_type with
              | Error _ -&gt;
                  error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_contract (loc, contract))</abbr>
              | Ok (Ex_ty targ, ctxt) -&gt; (
                match
                  find_entrypoint_for_type
                    ~full:targ
                    ~expected:arg
                    ~root_name
                    entrypoint
                    ctxt
                  &gt;&gt;? fun (ctxt, entrypoint, targ) -&gt;
                  merge_types ~legacy ctxt loc targ arg
                  &gt;&gt;? fun (targ, ctxt) -&gt;
                  merge_types ~legacy ctxt loc targ arg
                  &gt;&gt;? fun (arg, ctxt) -&gt;
                  let contract : arg typed_contract =
                    (arg, (contract, entrypoint))
                  in
                  ok (ctxt, Some contract)
                with
                | Ok res -&gt;
                    ok res
                | Error _ -&gt;
                    (* overapproximation by checking if targ = targ,
                                                       can only fail because of gas *)
                    ty_eq ctxt targ targ
                    &gt;&gt;? fun (Eq, ctxt) -&gt;
                    merge_types ~legacy ctxt loc targ targ
                    &gt;&gt;? fun (_, ctxt) -&gt; ok (ctxt, None) ) ) ) )

and parse_toplevel :
    legacy:bool -&gt;
    Script.expr -&gt;
    (Script.node * Script.node * Script.node * string option) tzresult =
 fun ~legacy toplevel -&gt;
  record_trace <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_typed_contract (toplevel, []))</abbr>
  @@
  match root toplevel with
  | Int (loc, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Seq_kind], Int_kind))</abbr>
  | String (loc, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Seq_kind], String_kind))</abbr>
  | Bytes (loc, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Seq_kind], Bytes_kind))</abbr>
  | Prim (loc, _, _, _) -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Seq_kind], Prim_kind))</abbr>
  | Seq (_, fields) -&gt; (
      let rec find_fields p s c fields =
        match fields with
        | [] -&gt;
            ok (p, s, c)
        | Int (loc, _) :: _ -&gt;
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Prim_kind], Int_kind))</abbr>
        | String (loc, _) :: _ -&gt;
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Prim_kind], String_kind))</abbr>
        | Bytes (loc, _) :: _ -&gt;
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Prim_kind], Bytes_kind))</abbr>
        | Seq (loc, _) :: _ -&gt;
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_kind (loc, [Prim_kind], Seq_kind))</abbr>
        | Prim (loc, K_parameter, [arg], annot) :: rest -&gt; (
          match p with
          | None -&gt;
              find_fields (Some (arg, loc, annot)) s c rest
          | Some _ -&gt;
              error <abbr class="mark-error" title="Values of extensible types are not handled">(Duplicate_field (loc, K_parameter))</abbr> )
        | Prim (loc, K_storage, [arg], annot) :: rest -&gt; (
          match s with
          | None -&gt;
              find_fields p (Some (arg, loc, annot)) c rest
          | Some _ -&gt;
              error <abbr class="mark-error" title="Values of extensible types are not handled">(Duplicate_field (loc, K_storage))</abbr> )
        | Prim (loc, K_code, [arg], annot) :: rest -&gt; (
          match c with
          | None -&gt;
              find_fields p s (Some (arg, loc, annot)) rest
          | Some _ -&gt;
              error <abbr class="mark-error" title="Values of extensible types are not handled">(Duplicate_field (loc, K_code))</abbr> )
        | Prim (loc, ((K_parameter | K_storage | K_code) as name), args, _)
          :: _ -&gt;
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_arity (loc, name, 1, List.length args))</abbr>
        | Prim (loc, name, _, _) :: _ -&gt;
            let allowed = [K_parameter; K_storage; K_code] in
            error <abbr class="mark-error" title="Values of extensible types are not handled">(Invalid_primitive (loc, allowed, name))</abbr>
      in
      find_fields None None None fields
      &gt;&gt;? function
      | (None, _, _) -&gt;
          error <abbr class="mark-error" title="Values of extensible types are not handled">(Missing_field K_parameter)</abbr>
      | (Some _, None, _) -&gt;
          error <abbr class="mark-error" title="Values of extensible types are not handled">(Missing_field K_storage)</abbr>
      | (Some _, Some _, None) -&gt;
          error <abbr class="mark-error" title="Values of extensible types are not handled">(Missing_field K_code)</abbr>
      | (Some (p, ploc, pannot), Some (s, sloc, sannot), Some (c, cloc, carrot))
        -&gt;
          let maybe_root_name =
            (* root name can be attached to either the parameter
                 primitive or the toplevel constructor *)
            Script_ir_annot.extract_field_annot p
            &gt;&gt;? fun (p, root_name) -&gt;
            match root_name with
            | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot root_name)</abbr> -&gt;
                ok (p, pannot, Some root_name)
            | None -&gt; (
              match pannot with
              | [single]
                when Compare.Int.(String.length single &gt; 0)
                     &amp;&amp; Compare.Char.(single.[0] = '%') -&gt;
                  ok
                    ( p,
                      [],
                      Some (String.sub single 1 (String.length single - 1)) )
              | _ -&gt;
                  ok (p, pannot, None) )
          in
          if legacy then
            (* legacy semantics ignores spurious annotations *)
            let (p, root_name) =
              match maybe_root_name with
              | Ok (p, _, root_name) -&gt;
                  (p, root_name)
              | Error _ -&gt;
                  (p, None)
            in
            ok (p, s, c, root_name)
          else
            (* only one field annot is allowed to set the root entrypoint name *)
            maybe_root_name
            &gt;&gt;? fun (p, pannot, root_name) -&gt;
            Script_ir_annot.error_unexpected_annot ploc pannot
            &gt;&gt;? fun () -&gt;
            Script_ir_annot.error_unexpected_annot cloc carrot
            &gt;&gt;? fun () -&gt;
            Script_ir_annot.error_unexpected_annot sloc sannot
            &gt;&gt;? fun () -&gt; ok (p, s, c, root_name) )

let parse_script :
    ?type_logger:type_logger -&gt;
    context -&gt;
    legacy:bool -&gt;
    Script.t -&gt;
    (ex_script * context) tzresult Lwt.t =
 fun ?type_logger ctxt ~legacy {code; storage} -&gt;
  Script.force_decode ctxt code
  &gt;&gt;=? fun (code, ctxt) -&gt;
  Script.force_decode ctxt storage
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  Lwt.return @@ parse_toplevel ~legacy code
  &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type (Some &quot;parameter&quot;, code, location arg_type))</abbr>
    (Lwt.return (parse_parameter_ty ctxt ~legacy arg_type))
  &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
  ( if legacy then return ()
  else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
  &gt;&gt;=? fun () -&gt;
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type (Some &quot;storage&quot;, code, location storage_type))</abbr>
    (Lwt.return (parse_storage_ty ctxt ~legacy storage_type))
  &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
  let arg_annot =
    default_annot
      (type_to_var_annot (name_of_ty arg_type))
      ~default:default_param_annot
  in
  let storage_annot =
    default_annot
      (type_to_var_annot (name_of_ty storage_type))
      ~default:default_storage_annot
  in
  let arg_type_full =
    Pair_t
      ( (arg_type, None, arg_annot),
        (storage_type, None, storage_annot),
        None,
        has_big_map arg_type || has_big_map storage_type )
  in
  let ret_type_full =
    Pair_t
      ( (List_t (Operation_t None, None, false), None, None),
        (storage_type, None, None),
        None,
        has_big_map storage_type )
  in
  trace_eval
    (fun () -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt storage_type
      &gt;&gt;|? fun (storage_type, _ctxt) -&gt;
      <abbr class="mark-error" title="Values of extensible types are not handled">Ill_typed_data (None, storage, storage_type)</abbr>)
    (parse_data ?type_logger ctxt ~legacy storage_type (root storage))
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_typed_contract (code, []))</abbr>
    (parse_returning
       (Toplevel
          {
            storage_type;
            param_type = arg_type;
            root_name;
            legacy_create_contract_literal = false;
          })
       ctxt
       ~legacy
       ?type_logger
       (arg_type_full, None)
       ret_type_full
       code_field)
  &gt;&gt;=? fun (code, ctxt) -&gt;
  return (Ex_script {code; arg_type; storage; storage_type; root_name}, ctxt)

let typecheck_code :
    context -&gt; Script.expr -&gt; (type_map * context) tzresult Lwt.t =
 fun ctxt code -&gt;
  let legacy = false in
  Lwt.return @@ parse_toplevel ~legacy code
  &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
  let type_map = ref [] in
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type (Some &quot;parameter&quot;, code, location arg_type))</abbr>
    (Lwt.return (parse_parameter_ty ctxt ~legacy arg_type))
  &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
  ( if legacy then return ()
  else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
  &gt;&gt;=? fun () -&gt;
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type (Some &quot;storage&quot;, code, location storage_type))</abbr>
    (Lwt.return (parse_storage_ty ctxt ~legacy storage_type))
  &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
  let arg_annot =
    default_annot
      (type_to_var_annot (name_of_ty arg_type))
      ~default:default_param_annot
  in
  let storage_annot =
    default_annot
      (type_to_var_annot (name_of_ty storage_type))
      ~default:default_storage_annot
  in
  let arg_type_full =
    Pair_t
      ( (arg_type, None, arg_annot),
        (storage_type, None, storage_annot),
        None,
        has_big_map arg_type || has_big_map storage_type )
  in
  let ret_type_full =
    Pair_t
      ( (List_t (Operation_t None, None, false), None, None),
        (storage_type, None, None),
        None,
        has_big_map storage_type )
  in
  let result =
    parse_returning
      (Toplevel
         {
           storage_type;
           param_type = arg_type;
           root_name;
           legacy_create_contract_literal = false;
         })
      ctxt
      ~legacy
      ~type_logger:(fun loc bef aft -&gt;
        type_map := (loc, (bef, aft)) :: !type_map)
      (arg_type_full, None)
      ret_type_full
      code_field
  in
  trace <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_typed_contract (code, !type_map))</abbr> result
  &gt;&gt;=? fun (Lam _, ctxt) -&gt; return (!type_map, ctxt)

let typecheck_data :
    ?type_logger:type_logger -&gt;
    context -&gt;
    Script.expr * Script.expr -&gt;
    context tzresult Lwt.t =
 fun ?type_logger ctxt (data, exp_ty) -&gt;
  let legacy = false in
  trace
    <abbr class="mark-error" title="Values of extensible types are not handled">(Ill_formed_type (None, exp_ty, 0))</abbr>
    (Lwt.return @@ parse_packable_ty ctxt ~legacy (root exp_ty))
  &gt;&gt;=? fun (Ex_ty exp_ty, ctxt) -&gt;
  trace_eval
    (fun () -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt exp_ty
      &gt;&gt;|? fun (exp_ty, _ctxt) -&gt; <abbr class="mark-error" title="Values of extensible types are not handled">Ill_typed_data (None, data, exp_ty)</abbr>)
    (parse_data ?type_logger ctxt ~legacy exp_ty (root data))
  &gt;&gt;=? fun (_, ctxt) -&gt; return ctxt

module Entrypoints_map = Map.Make (String)

let list_entrypoints (type full) (full : full ty) ctxt ~root_name =
  let <abbr class="mark-error" title="Polymorphic variant types are not handled">merge</abbr> path annot (type t) (ty : t ty) reachable
      ((unreachables, all) as acc) =
    match annot with
    | None | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot &quot;&quot;)</abbr> -&gt; (
        ok
        @@
        if reachable then acc
        else
          match ty with
          | Union_t _ -&gt;
              acc
          | _ -&gt;
              (List.rev path :: unreachables, all) )
    | Some <abbr class="mark-error" title="Patterns on variants are not supported">(`Field_annot name)</abbr> -&gt;
        if Compare.Int.(String.length name &gt; 31) then
          ok (List.rev path :: unreachables, all)
        else if Entrypoints_map.mem name all then
          ok (List.rev path :: unreachables, all)
        else
          unparse_ty_no_lwt ctxt ty
          &gt;&gt;? fun (unparsed_ty, _) -&gt;
          ok
            ( unreachables,
              Entrypoints_map.add name (List.rev path, unparsed_ty) all )
  in
  let rec fold_tree :
      type t.
      t ty -&gt;
      prim list -&gt;
      bool -&gt;
      prim list list * (prim list * Script.node) Entrypoints_map.t -&gt;
      (prim list list * (prim list * Script.node) Entrypoints_map.t) tzresult =
   fun t path reachable acc -&gt;
    match t with
    | Union_t ((tl, al), (tr, ar), _, _) -&gt;
        merge (D_Left :: path) al tl reachable acc
        &gt;&gt;? fun acc -&gt;
        merge (D_Right :: path) ar tr reachable acc
        &gt;&gt;? fun acc -&gt;
        fold_tree
          tl
          (D_Left :: path)
          (match al with Some _ -&gt; true | None -&gt; reachable)
          acc
        &gt;&gt;? fun acc -&gt;
        fold_tree
          tr
          (D_Right :: path)
          (match ar with Some _ -&gt; true | None -&gt; reachable)
          acc
    | _ -&gt;
        ok acc
  in
  unparse_ty_no_lwt ctxt full
  &gt;&gt;? fun (unparsed_full, _) -&gt;
  let (init, reachable) =
    match root_name with
    | None | Some &quot;&quot; -&gt;
        (Entrypoints_map.empty, false)
    | Some name -&gt;
        (Entrypoints_map.singleton name ([], unparsed_full), true)
  in
  fold_tree full [] reachable ([], init)

(* ---- Unparsing (Typed IR -&gt; Untyped expressions) --------------------------*)

let rec unparse_data :
    type a.
    context -&gt;
    unparsing_mode -&gt;
    a ty -&gt;
    a -&gt;
    (Script.node * context) tzresult Lwt.t =
 fun ctxt mode ty a -&gt;
  Lwt.return (Gas.consume ctxt Unparse_costs.cycle)
  &gt;&gt;=? fun ctxt -&gt;
  match (ty, a) with
  | (Unit_t _, ()) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.unit)
      &gt;&gt;=? fun ctxt -&gt; return (Prim (-1, D_Unit, [], []), ctxt)
  | (Int_t _, v) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.int v))
      &gt;&gt;=? fun ctxt -&gt; return (Int (-1, Script_int.to_zint v), ctxt)
  | (Nat_t _, v) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.int v))
      &gt;&gt;=? fun ctxt -&gt; return (Int (-1, Script_int.to_zint v), ctxt)
  | (String_t _, s) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.string s))
      &gt;&gt;=? fun ctxt -&gt; return (String (-1, s), ctxt)
  | (Bytes_t _, s) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.bytes s))
      &gt;&gt;=? fun ctxt -&gt; return (Bytes (-1, s), ctxt)
  | (Bool_t _, true) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.bool)
      &gt;&gt;=? fun ctxt -&gt; return (Prim (-1, D_True, [], []), ctxt)
  | (Bool_t _, false) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.bool)
      &gt;&gt;=? fun ctxt -&gt; return (Prim (-1, D_False, [], []), ctxt)
  | (Timestamp_t _, t) -&gt; (
      Lwt.return (Gas.consume ctxt (Unparse_costs.timestamp t))
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          return (Int (-1, Script_timestamp.to_zint t), ctxt)
      | Readable -&gt; (
        match Script_timestamp.to_notation t with
        | None -&gt;
            return (Int (-1, Script_timestamp.to_zint t), ctxt)
        | Some s -&gt;
            return (String (-1, s), ctxt) ) )
  | (Address_t _, (c, entrypoint)) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let entrypoint =
            match entrypoint with &quot;default&quot; -&gt; &quot;&quot; | name -&gt; name
          in
          let bytes =
            Data_encoding.Binary.to_bytes_exn
              Data_encoding.(tup2 Contract.encoding Variable.string)
              (c, entrypoint)
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          let notation =
            match entrypoint with
            | &quot;default&quot; -&gt;
                Contract.to_b58check c
            | entrypoint -&gt;
                Contract.to_b58check c ^ &quot;%&quot; ^ entrypoint
          in
          return (String (-1, notation), ctxt) )
  | (Contract_t _, (_, (c, entrypoint))) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let entrypoint =
            match entrypoint with &quot;default&quot; -&gt; &quot;&quot; | name -&gt; name
          in
          let bytes =
            Data_encoding.Binary.to_bytes_exn
              Data_encoding.(tup2 Contract.encoding Variable.string)
              (c, entrypoint)
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          let notation =
            match entrypoint with
            | &quot;default&quot; -&gt;
                Contract.to_b58check c
            | entrypoint -&gt;
                Contract.to_b58check c ^ &quot;%&quot; ^ entrypoint
          in
          return (String (-1, notation), ctxt) )
  | (Signature_t _, s) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.signature)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let bytes = Data_encoding.Binary.to_bytes_exn Signature.encoding s in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          return (String (-1, Signature.to_b58check s), ctxt) )
  | (Mutez_t _, v) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.tez)
      &gt;&gt;=? fun ctxt -&gt; return (Int (-1, Z.of_int64 (Tez.to_mutez v)), ctxt)
  | (Key_t _, k) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.key)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let bytes =
            Data_encoding.Binary.to_bytes_exn Signature.Public_key.encoding k
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          return (String (-1, Signature.Public_key.to_b58check k), ctxt) )
  | (Key_hash_t _, k) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.key_hash)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let bytes =
            Data_encoding.Binary.to_bytes_exn
              Signature.Public_key_hash.encoding
              k
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          return (String (-1, Signature.Public_key_hash.to_b58check k), ctxt) )
  | (Operation_t _, (op, _big_map_diff)) -&gt;
      let bytes =
        Data_encoding.Binary.to_bytes_exn
          Operation.internal_operation_encoding
          op
      in
      Lwt.return (Gas.consume ctxt (Unparse_costs.operation bytes))
      &gt;&gt;=? fun ctxt -&gt; return (Bytes (-1, bytes), ctxt)
  | (Chain_id_t _, chain_id) -&gt;
      let bytes =
        Data_encoding.Binary.to_bytes_exn Chain_id.encoding chain_id
      in
      Lwt.return (Gas.consume ctxt (Unparse_costs.chain_id bytes))
      &gt;&gt;=? fun ctxt -&gt; return (Bytes (-1, bytes), ctxt)
  | (Pair_t ((tl, _, _), (tr, _, _), _, _), (l, r)) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.pair)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_data ctxt mode tl l
      &gt;&gt;=? fun (l, ctxt) -&gt;
      unparse_data ctxt mode tr r
      &gt;&gt;=? fun (r, ctxt) -&gt; return (Prim (-1, D_Pair, [l; r], []), ctxt)
  | (Union_t ((tl, _), _, _, _), L l) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.union)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_data ctxt mode tl l
      &gt;&gt;=? fun (l, ctxt) -&gt; return (Prim (-1, D_Left, [l], []), ctxt)
  | (Union_t (_, (tr, _), _, _), R r) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.union)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_data ctxt mode tr r
      &gt;&gt;=? fun (r, ctxt) -&gt; return (Prim (-1, D_Right, [r], []), ctxt)
  | (Option_t (t, _, _), Some v) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.some)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_data ctxt mode t v
      &gt;&gt;=? fun (v, ctxt) -&gt; return (Prim (-1, D_Some, [v], []), ctxt)
  | (Option_t _, None) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.none)
      &gt;&gt;=? fun ctxt -&gt; return (Prim (-1, D_None, [], []), ctxt)
  | (List_t (t, _, _), items) -&gt;
      fold_left_s
        (fun (l, ctxt) element -&gt;
          Lwt.return (Gas.consume ctxt Unparse_costs.list_element)
          &gt;&gt;=? fun ctxt -&gt;
          unparse_data ctxt mode t element
          &gt;&gt;=? fun (unparsed, ctxt) -&gt; return (unparsed :: l, ctxt))
        ([], ctxt)
        items
      &gt;&gt;=? fun (items, ctxt) -&gt;
      return (Micheline.Seq (-1, List.rev items), ctxt)
  | (Set_t (t, _), set) -&gt;
      let t = ty_of_comparable_ty t in
      fold_left_s
        (fun (l, ctxt) item -&gt;
          Lwt.return (Gas.consume ctxt Unparse_costs.set_element)
          &gt;&gt;=? fun ctxt -&gt;
          unparse_data ctxt mode t item
          &gt;&gt;=? fun (item, ctxt) -&gt; return (item :: l, ctxt))
        ([], ctxt)
        (set_fold (fun e acc -&gt; e :: acc) set [])
      &gt;&gt;=? fun (items, ctxt) -&gt; return (Micheline.Seq (-1, items), ctxt)
  | (Map_t (kt, vt, _, _), map) -&gt;
      let kt = ty_of_comparable_ty kt in
      fold_left_s
        (fun (l, ctxt) (k, v) -&gt;
          Lwt.return (Gas.consume ctxt Unparse_costs.map_element)
          &gt;&gt;=? fun ctxt -&gt;
          unparse_data ctxt mode kt k
          &gt;&gt;=? fun (key, ctxt) -&gt;
          unparse_data ctxt mode vt v
          &gt;&gt;=? fun (value, ctxt) -&gt;
          return (Prim (-1, D_Elt, [key; value], []) :: l, ctxt))
        ([], ctxt)
        (map_fold (fun k v acc -&gt; (k, v) :: acc) map [])
      &gt;&gt;=? fun (items, ctxt) -&gt; return (Micheline.Seq (-1, items), ctxt)
  | (Big_map_t (kt, vt, _), {id = None; diff = (module Diff); _}) -&gt;
      (* this branch is to allow roundtrip of big map literals *)
      let kt = ty_of_comparable_ty kt in
      fold_left_s
        (fun (l, ctxt) (k, v) -&gt;
          Lwt.return (Gas.consume ctxt Unparse_costs.map_element)
          &gt;&gt;=? fun ctxt -&gt;
          unparse_data ctxt mode kt k
          &gt;&gt;=? fun (key, ctxt) -&gt;
          unparse_data ctxt mode vt v
          &gt;&gt;=? fun (value, ctxt) -&gt;
          return (Prim (-1, D_Elt, [key; value], []) :: l, ctxt))
        ([], ctxt)
        (<abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Diff.OPS.fold</abbr>
           (fun k v acc -&gt;
             match v with None -&gt; acc | Some v -&gt; (k, v) :: acc)
           (fst <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Diff.boxed</abbr>)
           [])
      &gt;&gt;=? fun (items, ctxt) -&gt; return (Micheline.Seq (-1, items), ctxt)
  | (Big_map_t (_kt, _kv, _), {id = Some id; diff = (module Diff); _}) -&gt;
      if Compare.Int.(<abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Diff.OPS.cardinal</abbr> (fst <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Diff.boxed</abbr>) = 0) then
        return (Micheline.Int (-1, id), ctxt)
      else
        (* this can only be the result of an execution and the map
             must have been flushed at this point *)
        <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
  | (Lambda_t _, Lam (_, original_code)) -&gt;
      unparse_code ctxt mode original_code

(* Gas accounting may not be perfect in this function, as it is only called by RPCs. *)
and unparse_code ctxt mode =
  let legacy = true in
  function
  | Prim (loc, I_PUSH, [ty; data], annot) -&gt;
      Lwt.return (parse_packable_ty ctxt ~legacy ty)
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_data ctxt ~legacy t data
      &gt;&gt;=? fun (data, ctxt) -&gt;
      unparse_data ctxt mode t data
      &gt;&gt;=? fun (data, ctxt) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.prim_cost 2 annot))
      &gt;&gt;=? fun ctxt -&gt; return (Prim (loc, I_PUSH, [ty; data], annot), ctxt)
  | Seq (loc, items) -&gt;
      fold_left_s
        (fun (l, ctxt) item -&gt;
          unparse_code ctxt mode item
          &gt;&gt;=? fun (item, ctxt) -&gt; return (item :: l, ctxt))
        ([], ctxt)
        items
      &gt;&gt;=? fun (items, ctxt) -&gt;
      Lwt.return
        (Gas.consume ctxt (Unparse_costs.seq_cost (List.length items)))
      &gt;&gt;=? fun ctxt -&gt; return (Micheline.Seq (loc, List.rev items), ctxt)
  | Prim (loc, prim, items, annot) -&gt;
      fold_left_s
        (fun (l, ctxt) item -&gt;
          unparse_code ctxt mode item
          &gt;&gt;=? fun (item, ctxt) -&gt; return (item :: l, ctxt))
        ([], ctxt)
        items
      &gt;&gt;=? fun (items, ctxt) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.prim_cost 3 annot))
      &gt;&gt;=? fun ctxt -&gt; return (Prim (loc, prim, List.rev items, annot), ctxt)
  | (Int _ | String _ | Bytes _) as atom -&gt;
      return (atom, ctxt)

(* Gas accounting may not be perfect in this function, as it is only called by RPCs. *)
let unparse_script ctxt mode {code; arg_type; storage; storage_type; root_name}
    =
  let (Lam (_, original_code)) = code in
  unparse_code ctxt mode original_code
  &gt;&gt;=? fun (code, ctxt) -&gt;
  unparse_data ctxt mode storage_type storage
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  unparse_ty ctxt arg_type
  &gt;&gt;=? fun (arg_type, ctxt) -&gt;
  unparse_ty ctxt storage_type
  &gt;&gt;=? fun (storage_type, ctxt) -&gt;
  let arg_type =
    add_field_annot
      (Option.map ~f:(fun n -&gt; <abbr class="mark-error" title="Variants not supported">`Field_annot n</abbr>) root_name)
      None
      arg_type
  in
  let open Micheline in
  let code =
    Seq
      ( -1,
        [ Prim (-1, K_parameter, [arg_type], []);
          Prim (-1, K_storage, [storage_type], []);
          Prim (-1, K_code, [code], []) ] )
  in
  Lwt.return
    ( Gas.consume ctxt (Unparse_costs.seq_cost 3)
    &gt;&gt;? fun ctxt -&gt;
    Gas.consume ctxt (Unparse_costs.prim_cost 1 [])
    &gt;&gt;? fun ctxt -&gt;
    Gas.consume ctxt (Unparse_costs.prim_cost 1 [])
    &gt;&gt;? fun ctxt -&gt; Gas.consume ctxt (Unparse_costs.prim_cost 1 []) )
  &gt;&gt;=? fun ctxt -&gt;
  return
    ( {
        code = lazy_expr (strip_locations code);
        storage = lazy_expr (strip_locations storage);
      },
      ctxt )

let pack_data ctxt typ data =
  unparse_data ctxt Optimized typ data
  &gt;&gt;=? fun (unparsed, ctxt) -&gt;
  let bytes =
    Data_encoding.Binary.to_bytes_exn
      expr_encoding
      (Micheline.strip_locations unparsed)
  in
  Lwt.return @@ Gas.consume ctxt (Script.serialized_cost bytes)
  &gt;&gt;=? fun ctxt -&gt;
  let bytes = MBytes.concat &quot;&quot; [MBytes.of_string &quot;\005&quot;; bytes] in
  Lwt.return @@ Gas.consume ctxt (Script.serialized_cost bytes)
  &gt;&gt;=? fun ctxt -&gt; return (bytes, ctxt)

let hash_data ctxt typ data =
  pack_data ctxt typ data
  &gt;&gt;=? fun (bytes, ctxt) -&gt;
  Lwt.return
  @@ Gas.consume
       ctxt
       (Michelson_v1_gas.Cost_of.Legacy.hash bytes Script_expr_hash.size)
  &gt;&gt;=? fun ctxt -&gt; return (Script_expr_hash.(hash_bytes [bytes]), ctxt)

(* ---------------- Big map -------------------------------------------------*)

let empty_big_map tk tv =
  {
    id = None;
    diff = empty_map tk;
    key_type = ty_of_comparable_ty tk;
    value_type = tv;
  }

let big_map_mem ctxt key {id; diff; key_type; _} =
  match (map_get key diff, id) with
  | (None, None) -&gt;
      return (false, ctxt)
  | (None, Some id) -&gt;
      hash_data ctxt key_type key
      &gt;&gt;=? fun (hash, ctxt) -&gt;
      Alpha_context.Big_map.mem ctxt id hash
      &gt;&gt;=? fun (ctxt, res) -&gt; return (res, ctxt)
  | (Some None, _) -&gt;
      return (false, ctxt)
  | (Some (Some _), _) -&gt;
      return (true, ctxt)

let big_map_get ctxt key {id; diff; key_type; value_type} =
  match (map_get key diff, id) with
  | (Some x, _) -&gt;
      return (x, ctxt)
  | (None, None) -&gt;
      return (None, ctxt)
  | (None, Some id) -&gt; (
      hash_data ctxt key_type key
      &gt;&gt;=? fun (hash, ctxt) -&gt;
      Alpha_context.Big_map.get_opt ctxt id hash
      &gt;&gt;=? function
      | (ctxt, None) -&gt;
          return (None, ctxt)
      | (ctxt, Some value) -&gt;
          parse_data ctxt ~legacy:true value_type (Micheline.root value)
          &gt;&gt;=? fun (x, ctxt) -&gt; return (Some x, ctxt) )

let big_map_update key value ({diff; _} as map) =
  <abbr class="mark-error" title="Record substitution not handled">{map with diff = map_set key value diff}</abbr>

module Ids = Set.Make (Compare.Z)

type big_map_ids = Ids.t

let no_big_map_id = Ids.empty

let diff_of_big_map ctxt fresh mode ~ids {id; key_type; value_type; diff} =
  Lwt.return
    (Gas.consume ctxt (Michelson_v1_gas.Cost_of.Legacy.map_to_list diff))
  &gt;&gt;=? fun ctxt -&gt;
  ( match id with
  | Some id -&gt;
      if Ids.mem id ids then
        fresh ctxt
        &gt;&gt;=? fun (ctxt, duplicate) -&gt;
        return (ctxt, [Contract.Copy (id, duplicate)], duplicate)
      else
        (* The first occurence encountered of a big_map reuses the
             ID. This way, the payer is only charged for the diff.
             For this to work, this diff has to be put at the end of
             the global diff, otherwise the duplicates will use the
             updated version as a base. This is true because we add
             this diff first in the accumulator of
             `extract_big_map_updates`, and this accumulator is not
             reversed before being flattened. *)
        return (ctxt, [], id)
  | None -&gt;
      fresh ctxt
      &gt;&gt;=? fun (ctxt, id) -&gt;
      unparse_ty ctxt key_type
      &gt;&gt;=? fun (kt, ctxt) -&gt;
      unparse_ty ctxt value_type
      &gt;&gt;=? fun (kv, ctxt) -&gt;
      return
        ( ctxt,
          [ Contract.Alloc
              {
                big_map = id;
                key_type = Micheline.strip_locations kt;
                value_type = Micheline.strip_locations kv;
              } ],
          id ) )
  &gt;&gt;=? fun (ctxt, init, big_map) -&gt;
  let pairs = map_fold (fun key value acc -&gt; (key, value) :: acc) diff [] in
  fold_left_s
    (fun (acc, ctxt) (key, value) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      hash_data ctxt key_type key
      &gt;&gt;=? fun (diff_key_hash, ctxt) -&gt;
      unparse_data ctxt mode key_type key
      &gt;&gt;=? fun (key_node, ctxt) -&gt;
      let diff_key = Micheline.strip_locations key_node in
      ( match value with
      | None -&gt;
          return (None, ctxt)
      | Some x -&gt;
          unparse_data ctxt mode value_type x
          &gt;&gt;=? fun (node, ctxt) -&gt;
          return (Some (Micheline.strip_locations node), ctxt) )
      &gt;&gt;=? fun (diff_value, ctxt) -&gt;
      let diff_item =
        Contract.Update {big_map; diff_key; diff_key_hash; diff_value}
      in
      return (diff_item :: acc, ctxt))
    ([], ctxt)
    pairs
  &gt;&gt;=? fun (diff, ctxt) -&gt; return (init @ diff, big_map, ctxt)

let rec extract_big_map_updates :
    type a.
    context -&gt;
    (context -&gt; (context * Big_map.id) tzresult Lwt.t) -&gt;
    unparsing_mode -&gt;
    Ids.t -&gt;
    Contract.big_map_diff list -&gt;
    a ty -&gt;
    a -&gt;
    (context * a * Ids.t * Contract.big_map_diff list) tzresult Lwt.t =
 fun ctxt fresh mode ids acc ty x -&gt;
  match (ty, x) with
  | (Big_map_t (_, _, _), map) -&gt;
      diff_of_big_map ctxt fresh mode ids map
      &gt;&gt;=? fun (diff, id, ctxt) -&gt;
      let (module Map) = map.diff in
      let map = <abbr class="mark-error" title="Record substitution not handled">{map with diff = empty_map Map.key_ty; id = Some id}</abbr> in
      return (ctxt, map, Ids.add id ids, diff :: acc)
  | (Pair_t ((tyl, _, _), (tyr, _, _), _, true), (xl, xr)) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      extract_big_map_updates ctxt fresh mode ids acc tyl xl
      &gt;&gt;=? fun (ctxt, xl, ids, acc) -&gt;
      extract_big_map_updates ctxt fresh mode ids acc tyr xr
      &gt;&gt;=? fun (ctxt, xr, ids, acc) -&gt; return (ctxt, (xl, xr), ids, acc)
  | (Union_t ((ty, _), (_, _), _, true), L x) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      extract_big_map_updates ctxt fresh mode ids acc ty x
      &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, L x, ids, acc)
  | (Union_t ((_, _), (ty, _), _, true), R x) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      extract_big_map_updates ctxt fresh mode ids acc ty x
      &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, R x, ids, acc)
  | (Option_t (ty, _, true), Some x) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      extract_big_map_updates ctxt fresh mode ids acc ty x
      &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, Some x, ids, acc)
  | (List_t (ty, _, true), l) -&gt;
      fold_left_s
        (fun (ctxt, l, ids, acc) x -&gt;
          Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
          &gt;&gt;=? fun ctxt -&gt;
          extract_big_map_updates ctxt fresh mode ids acc ty x
          &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, x :: l, ids, acc))
        (ctxt, [], ids, acc)
        l
      &gt;&gt;=? fun (ctxt, l, ids, acc) -&gt; return (ctxt, List.rev l, ids, acc)
  | (Map_t (_, ty, _, true), ((module M) as m)) -&gt;
      Lwt.return
        (Gas.consume ctxt (Michelson_v1_gas.Cost_of.Legacy.map_to_list m))
      &gt;&gt;=? fun ctxt -&gt;
      fold_left_s
        (fun (ctxt, m, ids, acc) (k, x) -&gt;
          Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
          &gt;&gt;=? fun ctxt -&gt;
          extract_big_map_updates ctxt fresh mode ids acc ty x
          &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt;
          return (ctxt, <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M.OPS.add</abbr> k x m, ids, acc))
        (ctxt, <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M.OPS.empty</abbr>, ids, acc)
        (<abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M.OPS.bindings</abbr> (fst <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M.boxed</abbr>))
      &gt;&gt;=? fun (ctxt, m, ids, acc) -&gt;
      let module M = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
        module OPS = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M.OPS</abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

        type key = M.key

        type value = M.value

        let key_ty = </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M.key_ty</abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

        let boxed = (m, snd </abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M.boxed</abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">)
      end</abbr> in
      return
        ( ctxt,
          (module <abbr class="mark-error" title="Module 'OPS' not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ key_ty; OPS; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Script_typed_ir.Boxed_map, Tezos_raw_protocol_alpha__Script_typed_ir.Boxed_map

We were looking for a module signature name for the following shape:
[ OPS; key_ty; boxed ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">M</abbr> : Boxed_map with type key = M.key and type value = M.value),
          ids,
          acc )
  | (Option_t (_, _, true), None) -&gt;
      return (ctxt, None, ids, acc)
  | (List_t (_, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Map_t (_, _, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Option_t (_, _, false), None) -&gt;
      return (ctxt, None, ids, acc)
  | (Pair_t (_, _, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Union_t (_, _, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Option_t (_, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Chain_id_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Set_t (_, _), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Unit_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Int_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Nat_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Signature_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (String_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Bytes_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Mutez_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Key_hash_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Key_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Timestamp_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Address_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Bool_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Lambda_t (_, _, _), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Contract_t (_, _), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Operation_t _, _) -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>

(* called only on parameters and storage, which cannot contain operations *)

let collect_big_maps ctxt ty x =
  let rec collect :
      type a. context -&gt; a ty -&gt; a -&gt; Ids.t -&gt; (Ids.t * context) tzresult =
   fun ctxt ty x acc -&gt;
    match (ty, x) with
    | (Big_map_t (_, _, _), {id = Some id}) -&gt;
        Gas.consume ctxt Typecheck_costs.cycle
        &gt;&gt;? fun ctxt -&gt; ok (Ids.add id acc, ctxt)
    | (Pair_t ((tyl, _, _), (tyr, _, _), _, true), (xl, xr)) -&gt;
        collect ctxt tyl xl acc &gt;&gt;? fun (acc, ctxt) -&gt; collect ctxt tyr xr acc
    | (Union_t ((ty, _), (_, _), _, true), L x) -&gt;
        collect ctxt ty x acc
    | (Union_t ((_, _), (ty, _), _, true), R x) -&gt;
        collect ctxt ty x acc
    | (Option_t (ty, _, true), Some x) -&gt;
        collect ctxt ty x acc
    | (List_t (ty, _, true), l) -&gt;
        List.fold_left
          (fun acc x -&gt; acc &gt;&gt;? fun (acc, ctxt) -&gt; collect ctxt ty x acc)
          (ok (acc, ctxt))
          l
    | (Map_t (_, ty, _, true), m) -&gt;
        map_fold
          (fun _ v acc -&gt; acc &gt;&gt;? fun (acc, ctxt) -&gt; collect ctxt ty v acc)
          m
          (ok (acc, ctxt))
    | (List_t (_, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Map_t (_, _, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Big_map_t (_, _, _), {id = None}) -&gt;
        ok (acc, ctxt)
    | (Option_t (_, _, true), None) -&gt;
        ok (acc, ctxt)
    | (Option_t (_, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Union_t (_, _, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Pair_t (_, _, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Chain_id_t _, _) -&gt;
        ok (acc, ctxt)
    | (Set_t (_, _), _) -&gt;
        ok (acc, ctxt)
    | (Unit_t _, _) -&gt;
        ok (acc, ctxt)
    | (Int_t _, _) -&gt;
        ok (acc, ctxt)
    | (Nat_t _, _) -&gt;
        ok (acc, ctxt)
    | (Signature_t _, _) -&gt;
        ok (acc, ctxt)
    | (String_t _, _) -&gt;
        ok (acc, ctxt)
    | (Bytes_t _, _) -&gt;
        ok (acc, ctxt)
    | (Mutez_t _, _) -&gt;
        ok (acc, ctxt)
    | (Key_hash_t _, _) -&gt;
        ok (acc, ctxt)
    | (Key_t _, _) -&gt;
        ok (acc, ctxt)
    | (Timestamp_t _, _) -&gt;
        ok (acc, ctxt)
    | (Address_t _, _) -&gt;
        ok (acc, ctxt)
    | (Bool_t _, _) -&gt;
        ok (acc, ctxt)
    | (Lambda_t (_, _, _), _) -&gt;
        ok (acc, ctxt)
    | (Contract_t (_, _), _) -&gt;
        ok (acc, ctxt)
    | (Operation_t _, _) -&gt;
        <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr>
   (* called only on parameters and storage, which cannot contain operations *)
  in
  Lwt.return (collect ctxt ty x no_big_map_id)

let extract_big_map_diff ctxt mode ~temporary ~to_duplicate ~to_update ty v =
  let to_duplicate = Ids.diff to_duplicate to_update in
  let fresh =
    if temporary then fun c -&gt; return (Big_map.fresh_temporary c)
    else Big_map.fresh
  in
  extract_big_map_updates ctxt fresh mode to_duplicate [] ty v
  &gt;&gt;=? fun (ctxt, v, alive, diffs) -&gt;
  let diffs =
    if temporary then diffs
    else
      let dead = Ids.diff to_update alive in
      Ids.fold (fun id acc -&gt; Contract.Clear id :: acc) dead [] :: diffs
  in
  match diffs with
  | [] -&gt;
      return (v, None, ctxt)
  | diffs -&gt;
      return (v, Some (List.flatten diffs (* do not reverse *)), ctxt)

let list_of_big_map_ids ids = Ids.elements ids
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_translator.ml"><code>Script_ir_translator.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_gas.
Require Tezos.Script_expr_hash.
Require Tezos.Script_ir_annot.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Script.

Import Script_typed_ir.

Import Script_tc_errors.

Import Script_ir_annot.

Module Typecheck_costs := Michelson_v1_gas.Cost_of.Typechecking.

Module Unparse_costs := Michelson_v1_gas.Cost_of.Unparse.

Reserved Notation &quot;'ex_comparable_ty&quot;.

Inductive ex_comparable_ty_gadt : Set :=
| Ex_comparable_ty : forall {a : Set},
  Script_typed_ir.comparable_ty a -&gt; ex_comparable_ty_gadt

where &quot;'ex_comparable_ty&quot; := (ex_comparable_ty_gadt).

Definition ex_comparable_ty := 'ex_comparable_ty.

Reserved Notation &quot;'ex_ty&quot;.

Inductive ex_ty_gadt : Set :=
| Ex_ty : forall {a : Set}, Script_typed_ir.ty a -&gt; ex_ty_gadt

where &quot;'ex_ty&quot; := (ex_ty_gadt).

Definition ex_ty := 'ex_ty.

Reserved Notation &quot;'ex_stack_ty&quot;.

Inductive ex_stack_ty_gadt : Set :=
| Ex_stack_ty : forall {a : Set}, Script_typed_ir.stack_ty a -&gt; ex_stack_ty_gadt

where &quot;'ex_stack_ty&quot; := (ex_stack_ty_gadt).

Definition ex_stack_ty := 'ex_stack_ty.

Module tc_context.
  Module Toplevel.
    Record record {storage_type param_type root_name
      legacy_create_contract_literal : Set} := {
      storage_type : storage_type;
      param_type : param_type;
      root_name : root_name;
      legacy_create_contract_literal : legacy_create_contract_literal }.
    Arguments record : clear implicits.
  End Toplevel.
  Definition Toplevel := Toplevel.record.
End tc_context.

Reserved Notation &quot;'tc_context&quot;.

Inductive tc_context_gadt : Set :=
| Lambda : tc_context_gadt
| Dip : forall {a : Set},
  Script_typed_ir.stack_ty a -&gt; tc_context_gadt -&gt; tc_context_gadt
| Toplevel : forall {param sto : Set},
  tc_context.Toplevel (Script_typed_ir.ty sto) (Script_typed_ir.ty param)
    (option string) bool -&gt; tc_context_gadt

where &quot;'tc_context&quot; := (tc_context_gadt).

Definition tc_context := 'tc_context.

Inductive unparsing_mode : Set :=
| Optimized : unparsing_mode
| Readable : unparsing_mode.

Definition type_logger :=
  Z -&gt; list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt;
  list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt; unit.

Definition add_dip {A : Set}
  (ty : Script_typed_ir.ty A) (annot : option Script_typed_ir.var_annot)
  (prev : tc_context) : tc_context :=
  match prev with
  | Lambda | Toplevel _ =&gt;
    Dip (Script_typed_ir.Item_t ty Script_typed_ir.Empty_t annot) prev
  | Dip stack _ =&gt; Dip (Script_typed_ir.Item_t ty stack annot) prev
  end.

Fixpoint comparable_type_size {a t : Set}
  (ty : Script_typed_ir.comparable_struct t a) {struct ty} : Z :=
  match ty with
  | Script_typed_ir.Int_key _ =&gt; 1
  | Script_typed_ir.Nat_key _ =&gt; 1
  | Script_typed_ir.String_key _ =&gt; 1
  | Script_typed_ir.Bytes_key _ =&gt; 1
  | Script_typed_ir.Mutez_key _ =&gt; 1
  | Script_typed_ir.Bool_key _ =&gt; 1
  | Script_typed_ir.Key_hash_key _ =&gt; 1
  | Script_typed_ir.Timestamp_key _ =&gt; 1
  | Script_typed_ir.Address_key _ =&gt; 1
  | Script_typed_ir.Pair_key _ (t, _) _ =&gt;
    Pervasives.op_plus 1 (comparable_type_size t)
  end.

Fixpoint type_size {t : Set} (ty : Script_typed_ir.ty t) {struct ty} : Z :=
  match ty with
  | Script_typed_ir.Unit_t _ =&gt; 1
  | Script_typed_ir.Int_t _ =&gt; 1
  | Script_typed_ir.Nat_t _ =&gt; 1
  | Script_typed_ir.Signature_t _ =&gt; 1
  | Script_typed_ir.Bytes_t _ =&gt; 1
  | Script_typed_ir.String_t _ =&gt; 1
  | Script_typed_ir.Mutez_t _ =&gt; 1
  | Script_typed_ir.Key_hash_t _ =&gt; 1
  | Script_typed_ir.Key_t _ =&gt; 1
  | Script_typed_ir.Timestamp_t _ =&gt; 1
  | Script_typed_ir.Address_t _ =&gt; 1
  | Script_typed_ir.Bool_t _ =&gt; 1
  | Script_typed_ir.Operation_t _ =&gt; 1
  | Script_typed_ir.Pair_t (l, _, _) (r, _, _) _ _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l)) (type_size r)
  | Script_typed_ir.Union_t (l, _) (r, _) _ _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l)) (type_size r)
  | Script_typed_ir.Lambda_t arg ret _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size arg)) (type_size ret)
  | Script_typed_ir.Option_t t _ _ =&gt; Pervasives.op_plus 1 (type_size t)
  | Script_typed_ir.List_t t _ _ =&gt; Pervasives.op_plus 1 (type_size t)
  | Script_typed_ir.Set_t k _ =&gt; Pervasives.op_plus 1 (comparable_type_size k)
  | Script_typed_ir.Map_t k v _ _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Big_map_t k v _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Contract_t arg _ =&gt; Pervasives.op_plus 1 (type_size arg)
  | Script_typed_ir.Chain_id_t _ =&gt; 1
  end.

Fixpoint type_size_of_stack_head {st : Set}
  (stack : Script_typed_ir.stack_ty st) (up_to : Z) {struct stack} : Z :=
  match stack with
  | Script_typed_ir.Empty_t =&gt; 0
  | Script_typed_ir.Item_t head tail _annot =&gt;
    if Compare.Int.[Compare.S.op_gt] up_to 0 then
      Compare.Int.[Compare.S.max] (type_size head)
        (type_size_of_stack_head tail (Pervasives.op_minus up_to 1))
    else
      0
  end.

Definition number_of_generated_growing_types {a b : Set}
  (function_parameter : Script_typed_ir.instr b a) : Z :=
  match function_parameter with
  | Script_typed_ir.Drop =&gt; 0
  | Script_typed_ir.Dup =&gt; 0
  | Script_typed_ir.Swap =&gt; 0
  | Script_typed_ir.Const _ =&gt; 1
  | Script_typed_ir.Cons_pair =&gt; 1
  | Script_typed_ir.Car =&gt; 0
  | Script_typed_ir.Cdr =&gt; 0
  | Script_typed_ir.Cons_some =&gt; 1
  | Script_typed_ir.Cons_none _ =&gt; 1
  | Script_typed_ir.If_none _ _ =&gt; 0
  | Script_typed_ir.Left =&gt; 0
  | Script_typed_ir.Right =&gt; 0
  | Script_typed_ir.If_left _ _ =&gt; 0
  | Script_typed_ir.Cons_list =&gt; 1
  | Script_typed_ir.Nil =&gt; 1
  | Script_typed_ir.If_cons _ _ =&gt; 0
  | Script_typed_ir.List_map _ =&gt; 1
  | Script_typed_ir.List_size =&gt; 0
  | Script_typed_ir.List_iter _ =&gt; 1
  | Script_typed_ir.Empty_set _ =&gt; 1
  | Script_typed_ir.Set_iter _ =&gt; 0
  | Script_typed_ir.Set_mem =&gt; 0
  | Script_typed_ir.Set_update =&gt; 0
  | Script_typed_ir.Set_size =&gt; 0
  | Script_typed_ir.Empty_map _ _ =&gt; 1
  | Script_typed_ir.Map_map _ =&gt; 1
  | Script_typed_ir.Map_iter _ =&gt; 1
  | Script_typed_ir.Map_mem =&gt; 0
  | Script_typed_ir.Map_get =&gt; 0
  | Script_typed_ir.Map_update =&gt; 0
  | Script_typed_ir.Map_size =&gt; 0
  | Script_typed_ir.Empty_big_map _ _ =&gt; 1
  | Script_typed_ir.Big_map_get =&gt; 0
  | Script_typed_ir.Big_map_update =&gt; 0
  | Script_typed_ir.Big_map_mem =&gt; 0
  | Script_typed_ir.Concat_string =&gt; 0
  | Script_typed_ir.Concat_string_pair =&gt; 0
  | Script_typed_ir.Slice_string =&gt; 0
  | Script_typed_ir.String_size =&gt; 0
  | Script_typed_ir.Concat_bytes =&gt; 0
  | Script_typed_ir.Concat_bytes_pair =&gt; 0
  | Script_typed_ir.Slice_bytes =&gt; 0
  | Script_typed_ir.Bytes_size =&gt; 0
  | Script_typed_ir.Add_seconds_to_timestamp =&gt; 0
  | Script_typed_ir.Add_timestamp_to_seconds =&gt; 0
  | Script_typed_ir.Sub_timestamp_seconds =&gt; 0
  | Script_typed_ir.Diff_timestamps =&gt; 0
  | Script_typed_ir.Add_tez =&gt; 0
  | Script_typed_ir.Sub_tez =&gt; 0
  | Script_typed_ir.Mul_teznat =&gt; 0
  | Script_typed_ir.Mul_nattez =&gt; 0
  | Script_typed_ir.Ediv_teznat =&gt; 0
  | Script_typed_ir.Ediv_tez =&gt; 0
  | Script_typed_ir.Or =&gt; 0
  | Script_typed_ir.And =&gt; 0
  | Script_typed_ir.Xor =&gt; 0
  | Script_typed_ir.Not =&gt; 0
  | Script_typed_ir.Is_nat =&gt; 0
  | Script_typed_ir.Neg_nat =&gt; 0
  | Script_typed_ir.Neg_int =&gt; 0
  | Script_typed_ir.Abs_int =&gt; 0
  | Script_typed_ir.Int_nat =&gt; 0
  | Script_typed_ir.Add_intint =&gt; 0
  | Script_typed_ir.Add_intnat =&gt; 0
  | Script_typed_ir.Add_natint =&gt; 0
  | Script_typed_ir.Add_natnat =&gt; 0
  | Script_typed_ir.Sub_int =&gt; 0
  | Script_typed_ir.Mul_intint =&gt; 0
  | Script_typed_ir.Mul_intnat =&gt; 0
  | Script_typed_ir.Mul_natint =&gt; 0
  | Script_typed_ir.Mul_natnat =&gt; 0
  | Script_typed_ir.Ediv_intint =&gt; 0
  | Script_typed_ir.Ediv_intnat =&gt; 0
  | Script_typed_ir.Ediv_natint =&gt; 0
  | Script_typed_ir.Ediv_natnat =&gt; 0
  | Script_typed_ir.Lsl_nat =&gt; 0
  | Script_typed_ir.Lsr_nat =&gt; 0
  | Script_typed_ir.Or_nat =&gt; 0
  | Script_typed_ir.And_nat =&gt; 0
  | Script_typed_ir.And_int_nat =&gt; 0
  | Script_typed_ir.Xor_nat =&gt; 0
  | Script_typed_ir.Not_nat =&gt; 0
  | Script_typed_ir.Not_int =&gt; 0
  | Script_typed_ir.Seq _ _ =&gt; 0
  | Script_typed_ir.If _ _ =&gt; 0
  | Script_typed_ir.Loop _ =&gt; 0
  | Script_typed_ir.Loop_left _ =&gt; 0
  | Script_typed_ir.Dip _ =&gt; 0
  | Script_typed_ir.Exec =&gt; 0
  | Script_typed_ir.Apply _ =&gt; 0
  | Script_typed_ir.Lambda _ =&gt; 1
  | Script_typed_ir.Failwith _ =&gt; 1
  | Script_typed_ir.Nop =&gt; 0
  | Script_typed_ir.Compare _ =&gt; 1
  | Script_typed_ir.Eq =&gt; 0
  | Script_typed_ir.Neq =&gt; 0
  | Script_typed_ir.Lt =&gt; 0
  | Script_typed_ir.Gt =&gt; 0
  | Script_typed_ir.Le =&gt; 0
  | Script_typed_ir.Ge =&gt; 0
  | Script_typed_ir.Address =&gt; 0
  | Script_typed_ir.Contract _ _ =&gt; 1
  | Script_typed_ir.Transfer_tokens =&gt; 1
  | Script_typed_ir.Create_account =&gt; 0
  | Script_typed_ir.Implicit_account =&gt; 0
  | Script_typed_ir.Create_contract _ _ _ _ =&gt; 1
  | Script_typed_ir.Create_contract_2 _ _ _ _ =&gt; 1
  | Script_typed_ir.Now =&gt; 0
  | Script_typed_ir.Balance =&gt; 0
  | Script_typed_ir.Check_signature =&gt; 0
  | Script_typed_ir.Hash_key =&gt; 0
  | Script_typed_ir.Blake2b =&gt; 0
  | Script_typed_ir.Sha256 =&gt; 0
  | Script_typed_ir.Sha512 =&gt; 0
  | Script_typed_ir.Steps_to_quota =&gt; 0
  | Script_typed_ir.Source =&gt; 0
  | Script_typed_ir.Sender =&gt; 0
  | Script_typed_ir.Self _ _ =&gt; 1
  | Script_typed_ir.Amount =&gt; 0
  | Script_typed_ir.Set_delegate =&gt; 0
  | Script_typed_ir.Pack _ =&gt; 0
  | Script_typed_ir.Unpack _ =&gt; 1
  | Script_typed_ir.Dig _ _ =&gt; 0
  | Script_typed_ir.Dug _ _ =&gt; 0
  | Script_typed_ir.Dipn _ _ _ =&gt; 0
  | Script_typed_ir.Dropn _ _ =&gt; 0
  | Script_typed_ir.ChainId =&gt; 0
  end.

Definition location {A B : Set} (function_parameter : Micheline.node A B) : A :=
  let
    'Micheline.Prim loc _ _ _ | Micheline.Int loc _ | Micheline.String loc _ |
    Micheline.Bytes loc _ | Micheline.Seq loc _ := function_parameter in
  loc.

Definition kind {A B : Set} (function_parameter : Micheline.node A B)
  : Script_tc_errors.kind :=
  match function_parameter with
  | Micheline.Int _ _ =&gt; Script_tc_errors.Int_kind
  | Micheline.String _ _ =&gt; Script_tc_errors.String_kind
  | Micheline.Bytes _ _ =&gt; Script_tc_errors.Bytes_kind
  | Micheline.Prim _ _ _ _ =&gt; Script_tc_errors.Prim_kind
  | Micheline.Seq _ _ =&gt; Script_tc_errors.Seq_kind
  end.

Definition namespace (function_parameter : Alpha_context.Script.prim)
  : Script_tc_errors.namespace :=
  match function_parameter with
  |
    Alpha_context.Script.K_parameter | Alpha_context.Script.K_storage |
    Alpha_context.Script.K_code =&gt; Script_tc_errors.Keyword_namespace
  |
    Alpha_context.Script.D_False | Alpha_context.Script.D_Elt |
    Alpha_context.Script.D_Left | Alpha_context.Script.D_None |
    Alpha_context.Script.D_Pair | Alpha_context.Script.D_Right |
    Alpha_context.Script.D_Some | Alpha_context.Script.D_True |
    Alpha_context.Script.D_Unit =&gt; Script_tc_errors.Constant_namespace
  |
    Alpha_context.Script.I_PACK | Alpha_context.Script.I_UNPACK |
    Alpha_context.Script.I_BLAKE2B | Alpha_context.Script.I_SHA256 |
    Alpha_context.Script.I_SHA512 | Alpha_context.Script.I_ABS |
    Alpha_context.Script.I_ADD | Alpha_context.Script.I_AMOUNT |
    Alpha_context.Script.I_AND | Alpha_context.Script.I_BALANCE |
    Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
    Alpha_context.Script.I_CHAIN_ID | Alpha_context.Script.I_CHECK_SIGNATURE |
    Alpha_context.Script.I_COMPARE | Alpha_context.Script.I_CONCAT |
    Alpha_context.Script.I_CONS | Alpha_context.Script.I_CREATE_ACCOUNT |
    Alpha_context.Script.I_CREATE_CONTRACT |
    Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_DIP |
    Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
    Alpha_context.Script.I_EDIV | Alpha_context.Script.I_EMPTY_BIG_MAP |
    Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_EMPTY_SET |
    Alpha_context.Script.I_EQ | Alpha_context.Script.I_EXEC |
    Alpha_context.Script.I_APPLY | Alpha_context.Script.I_FAILWITH |
    Alpha_context.Script.I_GE | Alpha_context.Script.I_GET |
    Alpha_context.Script.I_GT | Alpha_context.Script.I_HASH_KEY |
    Alpha_context.Script.I_IF | Alpha_context.Script.I_IF_CONS |
    Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_NONE |
    Alpha_context.Script.I_INT | Alpha_context.Script.I_LAMBDA |
    Alpha_context.Script.I_LE | Alpha_context.Script.I_LEFT |
    Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LSL |
    Alpha_context.Script.I_LSR | Alpha_context.Script.I_LT |
    Alpha_context.Script.I_MAP | Alpha_context.Script.I_MEM |
    Alpha_context.Script.I_MUL | Alpha_context.Script.I_NEG |
    Alpha_context.Script.I_NEQ | Alpha_context.Script.I_NIL |
    Alpha_context.Script.I_NONE | Alpha_context.Script.I_NOT |
    Alpha_context.Script.I_NOW | Alpha_context.Script.I_OR |
    Alpha_context.Script.I_PAIR | Alpha_context.Script.I_PUSH |
    Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_SIZE |
    Alpha_context.Script.I_SOME | Alpha_context.Script.I_SOURCE |
    Alpha_context.Script.I_SENDER | Alpha_context.Script.I_SELF |
    Alpha_context.Script.I_SLICE | Alpha_context.Script.I_STEPS_TO_QUOTA |
    Alpha_context.Script.I_SUB | Alpha_context.Script.I_SWAP |
    Alpha_context.Script.I_TRANSFER_TOKENS | Alpha_context.Script.I_SET_DELEGATE
    | Alpha_context.Script.I_UNIT | Alpha_context.Script.I_UPDATE |
    Alpha_context.Script.I_XOR | Alpha_context.Script.I_ITER |
    Alpha_context.Script.I_LOOP_LEFT | Alpha_context.Script.I_ADDRESS |
    Alpha_context.Script.I_CONTRACT | Alpha_context.Script.I_ISNAT |
    Alpha_context.Script.I_CAST | Alpha_context.Script.I_RENAME |
    Alpha_context.Script.I_DIG | Alpha_context.Script.I_DUG =&gt;
    Script_tc_errors.Instr_namespace
  |
    Alpha_context.Script.T_bool | Alpha_context.Script.T_contract |
    Alpha_context.Script.T_int | Alpha_context.Script.T_key |
    Alpha_context.Script.T_key_hash | Alpha_context.Script.T_lambda |
    Alpha_context.Script.T_list | Alpha_context.Script.T_map |
    Alpha_context.Script.T_big_map | Alpha_context.Script.T_nat |
    Alpha_context.Script.T_option | Alpha_context.Script.T_or |
    Alpha_context.Script.T_pair | Alpha_context.Script.T_set |
    Alpha_context.Script.T_signature | Alpha_context.Script.T_string |
    Alpha_context.Script.T_bytes | Alpha_context.Script.T_mutez |
    Alpha_context.Script.T_timestamp | Alpha_context.Script.T_unit |
    Alpha_context.Script.T_operation | Alpha_context.Script.T_address |
    Alpha_context.Script.T_chain_id =&gt; Script_tc_errors.Type_namespace
  end.

Definition unexpected
  (expr : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  (exp_kinds : list Script_tc_errors.kind) (exp_ns : Script_tc_errors.namespace)
  (exp_prims : list Alpha_context.Script.prim) : Error_monad.__error :=
  match expr with
  | Micheline.Int loc _ =&gt; extensible_type_value
  | Micheline.String loc _ =&gt; extensible_type_value
  | Micheline.Bytes loc _ =&gt; extensible_type_value
  | Micheline.Seq loc _ =&gt; extensible_type_value
  | Micheline.Prim loc name _ _ =&gt;
    match ((namespace name), exp_ns) with
    |
      (Script_tc_errors.Type_namespace, Script_tc_errors.Type_namespace) |
      (Script_tc_errors.Instr_namespace, Script_tc_errors.Instr_namespace) |
      (Script_tc_errors.Constant_namespace, Script_tc_errors.Constant_namespace)
      =&gt; extensible_type_value
    | (ns, _) =&gt; extensible_type_value
    end
  end.

Definition check_kind {A : Set}
  (kinds : list Script_tc_errors.kind)
  (expr : Micheline.node Alpha_context.Script.location A)
  : Lwt.t (Error_monad.tzresult unit) :=
  let kind := kind expr in
  if List.mem kind kinds then
    Error_monad.return_unit
  else
    let loc := location expr in
    Error_monad.fail extensible_type_value.

Definition wrap_compare {A B : Set}
  (compare : A -&gt; B -&gt; Compare.Int.[Compare.S.t]) (a : A) (b : B) : Z :=
  let res := compare a b in
  if Compare.Int.[Compare.S.op_eq] res 0 then
    0
  else
    if Compare.Int.[Compare.S.op_gt] res 0 then
      1
    else
      (-1).

Fixpoint compare_comparable {a s : Set}
  (kind : Script_typed_ir.comparable_struct a s) {struct kind} : a -&gt; a -&gt; Z :=
  match kind with
  | Script_typed_ir.String_key _ =&gt;
    wrap_compare Compare.String.[Compare.S.compare]
  | Script_typed_ir.Bool_key _ =&gt; wrap_compare Compare.Bool.[Compare.S.compare]
  | Script_typed_ir.Mutez_key _ =&gt; wrap_compare Alpha_context.Tez.compare
  | Script_typed_ir.Key_hash_key _ =&gt;
    wrap_compare Signature.Public_key_hash.[S.SPublic_key_hash.compare]
  | Script_typed_ir.Int_key _ =&gt; wrap_compare Alpha_context.Script_int.compare
  | Script_typed_ir.Nat_key _ =&gt; wrap_compare Alpha_context.Script_int.compare
  | Script_typed_ir.Timestamp_key _ =&gt;
    wrap_compare Alpha_context.Script_timestamp.compare
  | Script_typed_ir.Address_key _ =&gt;
    Pervasives.op_atat wrap_compare
      (fun function_parameter =&gt;
        let '(x, ex) := function_parameter in
        fun function_parameter =&gt;
          let '(y, ey) := function_parameter in
          let lres := Alpha_context.Contract.compare x y in
          if Compare.Int.[Compare.S.op_eq] lres 0 then
            Compare.String.[Compare.S.compare] ex ey
          else
            lres)
  | Script_typed_ir.Bytes_key _ =&gt; wrap_compare MBytes.compare
  | Script_typed_ir.Pair_key (tl, _) (tr, _) _ =&gt;
    fun function_parameter =&gt;
      let '(lx, rx) := function_parameter in
      fun function_parameter =&gt;
        let '(ly, ry) := function_parameter in
        let lres := compare_comparable tl lx ly in
        if Compare.Int.[Compare.S.op_eq] lres 0 then
          compare_comparable tr rx ry
        else
          lres
  end.

Definition empty_set {a : Set} (ty : Script_typed_ir.comparable_ty a)
  : Script_typed_ir.set a :=
  let OPS :=
    __Set.Make
      (let compare := compare_comparable ty in
      existT _ _
        {|
          Compare.COMPARABLE.compare := compare
          |}) in
  let elt_ty := ty in
  let boxed := OPS.[S.SET.empty] in
  let size := 0 in
  existT _ _
    {|
      Script_typed_ir.Boxed_set.elt_ty := elt_ty;
      Script_typed_ir.Boxed_set.boxed := boxed;
      Script_typed_ir.Boxed_set.size := size
      |}.

Definition set_update {a : Set} (v : a) (b : bool) (Box : Script_typed_ir.set a)
  : Script_typed_ir.set a :=
  let elt_ty := Box.[Script_typed_ir.Boxed_set.elt_ty] in
  let OPS := Box.[Script_typed_ir.Boxed_set.OPS] in
  let boxed :=
    if b then
      Box.[Script_typed_ir.Boxed_set.OPS].(S.SET.add) v
        Box.[Script_typed_ir.Boxed_set.boxed]
    else
      Box.[Script_typed_ir.Boxed_set.OPS].(S.SET.remove) v
        Box.[Script_typed_ir.Boxed_set.boxed] in
  let size :=
    let mem :=
      Box.[Script_typed_ir.Boxed_set.OPS].(S.SET.mem) v
        Box.[Script_typed_ir.Boxed_set.boxed] in
    if mem then
      if b then
        Box.[Script_typed_ir.Boxed_set.size]
      else
        Pervasives.op_minus Box.[Script_typed_ir.Boxed_set.size] 1
    else
      if b then
        Pervasives.op_plus Box.[Script_typed_ir.Boxed_set.size] 1
      else
        Box.[Script_typed_ir.Boxed_set.size] in
  existT _ _
    {|
      Script_typed_ir.Boxed_set.elt_ty := elt_ty;
      Script_typed_ir.Boxed_set.boxed := boxed;
      Script_typed_ir.Boxed_set.size := size
      |}.

Definition set_mem {elt : Set} (v : elt) (Box : Script_typed_ir.set elt)
  : bool :=
  Box.[Script_typed_ir.Boxed_set.OPS].(S.SET.mem) v
    Box.[Script_typed_ir.Boxed_set.boxed].

Definition set_fold {acc elt : Set}
  (f : elt -&gt; acc -&gt; acc) (Box : Script_typed_ir.set elt) : acc -&gt; acc :=
  Box.[Script_typed_ir.Boxed_set.OPS].(S.SET.fold) f
    Box.[Script_typed_ir.Boxed_set.boxed].

Definition set_size {elt : Set} (Box : Script_typed_ir.set elt)
  : Alpha_context.Script_int.num Alpha_context.Script_int.n :=
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int Box.[Script_typed_ir.Boxed_set.size]).

Definition map_key_ty {a b : Set} (Box : Script_typed_ir.map a b)
  : Script_typed_ir.comparable_ty a := Box.[Script_typed_ir.Boxed_map.key_ty].

Definition empty_map {a b : Set} (ty : Script_typed_ir.comparable_ty a)
  : Script_typed_ir.map a b :=
  let OPS :=
    Map.Make
      (let compare := compare_comparable ty in
      existT _ _
        {|
          Compare.COMPARABLE.compare := compare
          |}) in
  let key_ty := ty in
  let boxed := (OPS.[S.MAP.empty], 0) in
  existT _ _
    {|
      Script_typed_ir.Boxed_map.key_ty := key_ty;
      Script_typed_ir.Boxed_map.boxed := boxed
      |}.

Definition map_get {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : option value :=
  Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.find_opt) k
    (Pervasives.fst Box.[Script_typed_ir.Boxed_map.boxed]).

Definition map_update {a b : Set}
  (k : a) (v : option b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let key_ty := Box.[Script_typed_ir.Boxed_map.key_ty] in
  let OPS := Box.[Script_typed_ir.Boxed_map.OPS] in
  let boxed :=
    let '(map, size) := Box.[Script_typed_ir.Boxed_map.boxed] in
    let contains := Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.mem) k map in
    match v with
    | Some v =&gt;
      ((Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.add) k v map),
        (Pervasives.op_plus size
          (if contains then
            0
          else
            1)))
    | None =&gt;
      ((Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.remove) k map),
        (Pervasives.op_minus size
          (if contains then
            1
          else
            0)))
    end in
  existT _ _
    {|
      Script_typed_ir.Boxed_map.key_ty := key_ty;
      Script_typed_ir.Boxed_map.boxed := boxed
      |}.

Definition map_set {a b : Set} (k : a) (v : b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let key_ty := Box.[Script_typed_ir.Boxed_map.key_ty] in
  let OPS := Box.[Script_typed_ir.Boxed_map.OPS] in
  let boxed :=
    let '(map, size) := Box.[Script_typed_ir.Boxed_map.boxed] in
    ((Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.add) k v map),
      (if Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.mem) k map then
        size
      else
        Pervasives.op_plus size 1)) in
  existT _ _
    {|
      Script_typed_ir.Boxed_map.key_ty := key_ty;
      Script_typed_ir.Boxed_map.boxed := boxed
      |}.

Definition map_mem {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : bool :=
  Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.mem) k
    (Pervasives.fst Box.[Script_typed_ir.Boxed_map.boxed]).

Definition map_fold {acc key value : Set}
  (f : key -&gt; value -&gt; acc -&gt; acc) (Box : Script_typed_ir.map key value)
  : acc -&gt; acc :=
  Box.[Script_typed_ir.Boxed_map.OPS].(S.MAP.fold) f
    (Pervasives.fst Box.[Script_typed_ir.Boxed_map.boxed]).

Definition map_size {key value : Set} (Box : Script_typed_ir.map key value)
  : Alpha_context.Script_int.num Alpha_context.Script_int.n :=
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int
      (Pervasives.snd Box.[Script_typed_ir.Boxed_map.boxed])).

Fixpoint ty_of_comparable_ty {a s : Set}
  (function_parameter : Script_typed_ir.comparable_struct a s)
  {struct function_parameter} : Script_typed_ir.ty a :=
  match function_parameter with
  | Script_typed_ir.Int_key tname =&gt; Script_typed_ir.Int_t tname
  | Script_typed_ir.Nat_key tname =&gt; Script_typed_ir.Nat_t tname
  | Script_typed_ir.String_key tname =&gt; Script_typed_ir.String_t tname
  | Script_typed_ir.Bytes_key tname =&gt; Script_typed_ir.Bytes_t tname
  | Script_typed_ir.Mutez_key tname =&gt; Script_typed_ir.Mutez_t tname
  | Script_typed_ir.Bool_key tname =&gt; Script_typed_ir.Bool_t tname
  | Script_typed_ir.Key_hash_key tname =&gt; Script_typed_ir.Key_hash_t tname
  | Script_typed_ir.Timestamp_key tname =&gt; Script_typed_ir.Timestamp_t tname
  | Script_typed_ir.Address_key tname =&gt; Script_typed_ir.Address_t tname
  | Script_typed_ir.Pair_key (l, al) (r, ar) tname =&gt;
    Script_typed_ir.Pair_t ((ty_of_comparable_ty l), al, None)
      ((ty_of_comparable_ty r), ar, None) tname false
  end.

Fixpoint comparable_ty_of_ty {a : Set}
  (function_parameter : Script_typed_ir.ty a) {struct function_parameter}
  : option (Script_typed_ir.comparable_ty a) :=
  match function_parameter with
  | Script_typed_ir.Int_t tname =&gt; Some (Script_typed_ir.Int_key tname)
  | Script_typed_ir.Nat_t tname =&gt; Some (Script_typed_ir.Nat_key tname)
  | Script_typed_ir.String_t tname =&gt; Some (Script_typed_ir.String_key tname)
  | Script_typed_ir.Bytes_t tname =&gt; Some (Script_typed_ir.Bytes_key tname)
  | Script_typed_ir.Mutez_t tname =&gt; Some (Script_typed_ir.Mutez_key tname)
  | Script_typed_ir.Bool_t tname =&gt; Some (Script_typed_ir.Bool_key tname)
  | Script_typed_ir.Key_hash_t tname =&gt;
    Some (Script_typed_ir.Key_hash_key tname)
  | Script_typed_ir.Timestamp_t tname =&gt;
    Some (Script_typed_ir.Timestamp_key tname)
  | Script_typed_ir.Address_t tname =&gt; Some (Script_typed_ir.Address_key tname)
  | Script_typed_ir.Pair_t (l, al, _) (r, ar, _) pname _ =&gt;
    match comparable_ty_of_ty r with
    | None =&gt; None
    | Some rty =&gt;
      match comparable_ty_of_ty l with
      | None =&gt; None
      | Some (Script_typed_ir.Pair_key _ _ _) =&gt; None
      | Some (Script_typed_ir.Int_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Int_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Nat_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Nat_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.String_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.String_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bytes_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bytes_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Mutez_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Mutez_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bool_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bool_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Key_hash_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Key_hash_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Timestamp_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Timestamp_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Address_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Address_key tname), al)
            (rty, ar) pname)
      end
    end
  | _ =&gt; None
  end.

Definition add_field_annot {A B : Set}
  (a : option Script_typed_ir.field_annot)
  (var : option Script_typed_ir.var_annot)
  (function_parameter : Micheline.node A B) : Micheline.node A B :=
  match function_parameter with
  | Micheline.Prim loc prim args annots =&gt;
    Micheline.Prim loc prim args
      (Pervasives.op_at annots
        (Pervasives.op_at (Script_ir_annot.unparse_field_annot a)
          (Script_ir_annot.unparse_var_annot var)))
  | expr =&gt; expr
  end.

Fixpoint unparse_comparable_ty {a s : Set}
  (function_parameter : Script_typed_ir.comparable_struct a s)
  {struct function_parameter} : Alpha_context.Script.node :=
  match function_parameter with
  | Script_typed_ir.Int_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_int []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Nat_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_nat []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.String_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_string []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bytes_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_bytes []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Mutez_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_mutez []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bool_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_bool []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Key_hash_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_key_hash []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Timestamp_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_timestamp []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Address_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_address []
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Pair_key (l, al) (r, ar) pname =&gt;
    let tl := add_field_annot al None (unparse_comparable_ty l) in
    let tr := add_field_annot ar None (unparse_comparable_ty r) in
    Micheline.Prim (-1) Alpha_context.Script.T_pair (cons tl (cons tr []))
      (Script_ir_annot.unparse_type_annot pname)
  end.

Fixpoint unparse_ty_no_lwt {a : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty a) {struct ctxt}
  : Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Unparse_costs.cycle)
    (fun ctxt =&gt;
      let __return {B : Set}
        (ctxt : Alpha_context.context)
        (function_parameter : B * list (Micheline.node Z B) * Micheline.annot)
        : Error_monad.tzresult (Micheline.node Z B * Alpha_context.context) :=
        let '(name, args, annot) := function_parameter in
        let __result_value := Micheline.Prim (-1) name args annot in
        Error_monad.op_gtgtquestion
          (Alpha_context.Gas.consume ctxt
            (Unparse_costs.prim_cost (List.length args) annot))
          (fun ctxt =&gt; Error_monad.ok (__result_value, ctxt)) in
      match ty with
      | Script_typed_ir.Unit_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_unit, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Int_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_int, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Nat_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_nat, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.String_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_string, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Bytes_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_bytes, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Mutez_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_mutez, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Bool_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_bool, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Key_hash_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_key_hash, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Key_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_key, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Timestamp_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_timestamp, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Address_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_address, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Signature_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_signature, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Operation_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_operation, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Chain_id_t tname =&gt;
        __return ctxt
          (Alpha_context.Script.T_chain_id, [],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Contract_t ut tname =&gt;
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ut)
          (fun function_parameter =&gt;
            let '(t, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_contract, (cons t []),
                (Script_ir_annot.unparse_type_annot tname)))
      |
        Script_typed_ir.Pair_t (utl, l_field, l_var) (utr, r_field, r_var) tname
          _ =&gt;
        let annot := Script_ir_annot.unparse_type_annot tname in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utl)
          (fun function_parameter =&gt;
            let '(utl, ctxt) := function_parameter in
            let tl := add_field_annot l_field l_var utl in
            Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
              (fun function_parameter =&gt;
                let '(utr, ctxt) := function_parameter in
                let tr := add_field_annot r_field r_var utr in
                __return ctxt
                  (Alpha_context.Script.T_pair, (cons tl (cons tr [])), annot)))
      | Script_typed_ir.Union_t (utl, l_field) (utr, r_field) tname _ =&gt;
        let annot := Script_ir_annot.unparse_type_annot tname in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utl)
          (fun function_parameter =&gt;
            let '(utl, ctxt) := function_parameter in
            let tl := add_field_annot l_field None utl in
            Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
              (fun function_parameter =&gt;
                let '(utr, ctxt) := function_parameter in
                let tr := add_field_annot r_field None utr in
                __return ctxt
                  (Alpha_context.Script.T_or, (cons tl (cons tr [])), annot)))
      | Script_typed_ir.Lambda_t uta utr tname =&gt;
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt uta)
          (fun function_parameter =&gt;
            let '(ta, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
              (fun function_parameter =&gt;
                let '(tr, ctxt) := function_parameter in
                __return ctxt
                  (Alpha_context.Script.T_lambda, (cons ta (cons tr [])),
                    (Script_ir_annot.unparse_type_annot tname))))
      | Script_typed_ir.Option_t ut tname _ =&gt;
        let annot := Script_ir_annot.unparse_type_annot tname in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ut)
          (fun function_parameter =&gt;
            let '(ut, ctxt) := function_parameter in
            __return ctxt (Alpha_context.Script.T_option, (cons ut []), annot))
      | Script_typed_ir.List_t ut tname _ =&gt;
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ut)
          (fun function_parameter =&gt;
            let '(t, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_list, (cons t []),
                (Script_ir_annot.unparse_type_annot tname)))
      | Script_typed_ir.Set_t ut tname =&gt;
        let t := unparse_comparable_ty ut in
        __return ctxt
          (Alpha_context.Script.T_set, (cons t []),
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Map_t uta utr tname _ =&gt;
        let ta := unparse_comparable_ty uta in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
          (fun function_parameter =&gt;
            let '(tr, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_map, (cons ta (cons tr [])),
                (Script_ir_annot.unparse_type_annot tname)))
      | Script_typed_ir.Big_map_t uta utr tname =&gt;
        let ta := unparse_comparable_ty uta in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
          (fun function_parameter =&gt;
            let '(tr, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_big_map, (cons ta (cons tr [])),
                (Script_ir_annot.unparse_type_annot tname)))
      end).

Definition unparse_ty {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty A)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  Lwt.__return (unparse_ty_no_lwt ctxt ty).

Fixpoint strip_var_annots {A B : Set} (function_parameter : Micheline.node A B)
  {struct function_parameter} : Micheline.node A B :=
  match function_parameter with
  | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom =&gt;
    atom
  | Micheline.Seq loc args =&gt; Micheline.Seq loc (List.map strip_var_annots args)
  | Micheline.Prim loc name args annots =&gt;
    let not_var_annot (s : string) : bool :=
      Compare.Char.[Compare.S.op_ltgt] (String.get s 0) &quot;@&quot; % char in
    let annots := List.filter not_var_annot annots in
    Micheline.Prim loc name (List.map strip_var_annots args) annots
  end.

Definition serialize_ty_for_error {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty A)
  : Error_monad.tzresult
    (Micheline.canonical Alpha_context.Script.prim * Alpha_context.context) :=
  Error_monad.op_gtpipequestion
    (Pervasives.op_pipegt (unparse_ty_no_lwt ctxt ty)
      (Error_monad.record_trace extensible_type_value))
    (fun function_parameter =&gt;
      let '(ty, ctxt) := function_parameter in
      ((Micheline.strip_locations (strip_var_annots ty)), ctxt)).

Fixpoint unparse_stack {a : Set}
  (ctxt : Alpha_context.context)
  (function_parameter : Script_typed_ir.stack_ty a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  match function_parameter with
  | Script_typed_ir.Empty_t =&gt; Error_monad.__return ([], ctxt)
  | Script_typed_ir.Item_t ty rest annot =&gt;
    Error_monad.op_gtgteqquestion (unparse_ty ctxt ty)
      (fun function_parameter =&gt;
        let '(uty, ctxt) := function_parameter in
        Error_monad.op_gtgteqquestion (unparse_stack ctxt rest)
          (fun function_parameter =&gt;
            let '(urest, ctxt) := function_parameter in
            Error_monad.__return
              ((cons
                ((Micheline.strip_locations uty),
                  (Script_ir_annot.unparse_var_annot annot)) urest), ctxt)))
  end.

Definition serialize_stack_for_error {A : Set}
  (ctxt : Alpha_context.context) (stack_ty : Script_typed_ir.stack_ty A)
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  Error_monad.trace extensible_type_value (unparse_stack ctxt stack_ty).

Definition name_of_ty {a : Set} (function_parameter : Script_typed_ir.ty a)
  : option Script_typed_ir.type_annot :=
  match function_parameter with
  | Script_typed_ir.Unit_t tname =&gt; tname
  | Script_typed_ir.Int_t tname =&gt; tname
  | Script_typed_ir.Nat_t tname =&gt; tname
  | Script_typed_ir.String_t tname =&gt; tname
  | Script_typed_ir.Bytes_t tname =&gt; tname
  | Script_typed_ir.Mutez_t tname =&gt; tname
  | Script_typed_ir.Bool_t tname =&gt; tname
  | Script_typed_ir.Key_hash_t tname =&gt; tname
  | Script_typed_ir.Key_t tname =&gt; tname
  | Script_typed_ir.Timestamp_t tname =&gt; tname
  | Script_typed_ir.Address_t tname =&gt; tname
  | Script_typed_ir.Signature_t tname =&gt; tname
  | Script_typed_ir.Operation_t tname =&gt; tname
  | Script_typed_ir.Chain_id_t tname =&gt; tname
  | Script_typed_ir.Contract_t _ tname =&gt; tname
  | Script_typed_ir.Pair_t _ _ tname _ =&gt; tname
  | Script_typed_ir.Union_t _ _ tname _ =&gt; tname
  | Script_typed_ir.Lambda_t _ _ tname =&gt; tname
  | Script_typed_ir.Option_t _ tname _ =&gt; tname
  | Script_typed_ir.List_t _ tname _ =&gt; tname
  | Script_typed_ir.Set_t _ tname =&gt; tname
  | Script_typed_ir.Map_t _ _ tname _ =&gt; tname
  | Script_typed_ir.Big_map_t _ _ tname =&gt; tname
  end.

Reserved Notation &quot;'eq&quot;.

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where &quot;'eq&quot; := (fun (ta tb : Set) =&gt; eq_gadt).

Definition eq := 'eq.

Definition comparable_ty_eq {ta tb : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.comparable_ty ta)
  (tb : Script_typed_ir.comparable_ty tb)
  : Error_monad.tzresult
    (eq (Script_typed_ir.comparable_ty ta) (Script_typed_ir.comparable_ty tb)) :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key _, Script_typed_ir.Int_key _) =&gt; Pervasives.Ok Eq
  | (Script_typed_ir.Nat_key _, Script_typed_ir.Nat_key _) =&gt; Pervasives.Ok Eq
  | (Script_typed_ir.String_key _, Script_typed_ir.String_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Bytes_key _, Script_typed_ir.Bytes_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Mutez_key _, Script_typed_ir.Mutez_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Bool_key _, Script_typed_ir.Bool_key _) =&gt; Pervasives.Ok Eq
  | (Script_typed_ir.Key_hash_key _, Script_typed_ir.Key_hash_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Timestamp_key _, Script_typed_ir.Timestamp_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Address_key _, Script_typed_ir.Address_key _) =&gt;
    Pervasives.Ok Eq
  | (_, _) =&gt;
    Error_monad.op_gtgtquestion
      (serialize_ty_for_error ctxt (ty_of_comparable_ty ta))
      (fun function_parameter =&gt;
        let '(ta, ctxt) := function_parameter in
        Error_monad.op_gtgtquestion
          (serialize_ty_for_error ctxt (ty_of_comparable_ty tb))
          (fun function_parameter =&gt;
            let '(tb, _ctxt) := function_parameter in
            Error_monad.__error_value extensible_type_value))
  end.

Definition record_inconsistent {A B C : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty A)
  (tb : Script_typed_ir.ty B)
  : Error_monad.tzresult C -&gt; Error_monad.tzresult C :=
  Error_monad.record_trace_eval
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt ta)
        (fun function_parameter =&gt;
          let '(ta, ctxt) := function_parameter in
          Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
            (fun function_parameter =&gt;
              let '(tb, _ctxt) := function_parameter in
              extensible_type_value))).

Definition record_inconsistent_type_annotations {A B C : Set}
  (ctxt : Alpha_context.context) (loc : Alpha_context.Script.location)
  (ta : Script_typed_ir.ty A) (tb : Script_typed_ir.ty B)
  : Error_monad.tzresult C -&gt; Error_monad.tzresult C :=
  Error_monad.record_trace_eval
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt ta)
        (fun function_parameter =&gt;
          let '(ta, ctxt) := function_parameter in
          Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
            (fun function_parameter =&gt;
              let '(tb, _ctxt) := function_parameter in
              extensible_type_value))).

Fixpoint ty_eq {ta tb : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty ta)
  (tb : Script_typed_ir.ty tb) {struct ctxt}
  : Error_monad.tzresult
    (eq (Script_typed_ir.ty ta) (Script_typed_ir.ty tb) * Alpha_context.context) :=
  let ok
    (__eq_value : eq (Script_typed_ir.ty ta) (Script_typed_ir.ty tb))
    (ctxt : Alpha_context.context) (nb_args : Z)
    : Error_monad.tzresult
      (eq (Script_typed_ir.ty ta) (Script_typed_ir.ty tb) *
        Alpha_context.context) :=
    Error_monad.op_gtgtquestion
      (Alpha_context.Gas.consume ctxt
        (Typecheck_costs.type_ (Pervasives.op_star 2 nb_args)))
      (fun ctxt =&gt; Pervasives.Ok (__eq_value, ctxt)) in
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =&gt;
      match (ta, tb) with
      | (Script_typed_ir.Unit_t _, Script_typed_ir.Unit_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Int_t _, Script_typed_ir.Int_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Nat_t _, Script_typed_ir.Nat_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Key_t _, Script_typed_ir.Key_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Key_hash_t _, Script_typed_ir.Key_hash_t _) =&gt;
        ok Eq ctxt 0
      | (Script_typed_ir.String_t _, Script_typed_ir.String_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Bytes_t _, Script_typed_ir.Bytes_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Signature_t _, Script_typed_ir.Signature_t _) =&gt;
        ok Eq ctxt 0
      | (Script_typed_ir.Mutez_t _, Script_typed_ir.Mutez_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Timestamp_t _, Script_typed_ir.Timestamp_t _) =&gt;
        ok Eq ctxt 0
      | (Script_typed_ir.Chain_id_t _, Script_typed_ir.Chain_id_t _) =&gt;
        ok Eq ctxt 0
      | (Script_typed_ir.Address_t _, Script_typed_ir.Address_t _) =&gt;
        ok Eq ctxt 0
      | (Script_typed_ir.Bool_t _, Script_typed_ir.Bool_t _) =&gt; ok Eq ctxt 0
      | (Script_typed_ir.Operation_t _, Script_typed_ir.Operation_t _) =&gt;
        ok Eq ctxt 0
      | (Script_typed_ir.Map_t tal tar _ _, Script_typed_ir.Map_t tbl tbr _ _)
        =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt tal tbl)
            (fun function_parameter =&gt;
              let 'Eq := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      |
        (Script_typed_ir.Big_map_t tal tar _,
          Script_typed_ir.Big_map_t tbl tbr _) =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt tal tbl)
            (fun function_parameter =&gt;
              let 'Eq := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Set_t ea _, Script_typed_ir.Set_t eb _) =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt ea eb)
            (fun function_parameter =&gt;
              let 'Eq := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      |
        (Script_typed_ir.Pair_t (tal, _, _) (tar, _, _) _ _,
          Script_typed_ir.Pair_t (tbl, _, _) (tbr, _, _) _ _) =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =&gt;
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      |
        (Script_typed_ir.Union_t (tal, _) (tar, _) _ _,
          Script_typed_ir.Union_t (tbl, _) (tbr, _) _ _) =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =&gt;
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Lambda_t tal tar _, Script_typed_ir.Lambda_t tbl tbr _)
        =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =&gt;
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Contract_t tal _, Script_typed_ir.Contract_t tbl _) =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =&gt;
              let '(Eq, ctxt) := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Option_t tva _ _, Script_typed_ir.Option_t tvb _ _) =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tva tvb)
            (fun function_parameter =&gt;
              let '(Eq, ctxt) := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.List_t tva _ _, Script_typed_ir.List_t tvb _ _) =&gt;
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tva tvb)
            (fun function_parameter =&gt;
              let '(Eq, ctxt) := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      | (_, _) =&gt;
        Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt ta)
          (fun function_parameter =&gt;
            let '(ta, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt tb)
              (fun function_parameter =&gt;
                let '(tb, _ctxt) := function_parameter in
                Error_monad.__error_value extensible_type_value))
      end).

Fixpoint stack_ty_eq {ta tb : Set}
  (ctxt : Alpha_context.context) (lvl : Z) (ta : Script_typed_ir.stack_ty ta)
  (tb : Script_typed_ir.stack_ty tb) {struct ctxt}
  : Error_monad.tzresult
    (eq (Script_typed_ir.stack_ty ta) (Script_typed_ir.stack_ty tb) *
      Alpha_context.context) :=
  match (ta, tb) with
  | (Script_typed_ir.Item_t tva ra _, Script_typed_ir.Item_t tvb rb _) =&gt;
    Error_monad.op_gtgtquestion
      (Pervasives.op_pipegt (ty_eq ctxt tva tvb)
        (Error_monad.record_trace extensible_type_value))
      (fun function_parameter =&gt;
        let '(Eq, ctxt) := function_parameter in
        Error_monad.op_gtgtquestion
          (stack_ty_eq ctxt (Pervasives.op_plus lvl 1) ra rb)
          (fun function_parameter =&gt;
            let '(Eq, ctxt) := function_parameter in
            Pervasives.Ok (Eq, ctxt)))
  | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =&gt;
    Pervasives.Ok (Eq, ctxt)
  | (_, _) =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition merge_comparable_types {ta : Set}
  (legacy : bool) (ta : Script_typed_ir.comparable_ty ta)
  (tb : Script_typed_ir.comparable_ty ta)
  : Error_monad.tzresult (Script_typed_ir.comparable_ty ta) :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key annot_a, Script_typed_ir.Int_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Int_key annot)
  | (Script_typed_ir.Nat_key annot_a, Script_typed_ir.Nat_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Nat_key annot)
  | (Script_typed_ir.String_key annot_a, Script_typed_ir.String_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.String_key annot)
  | (Script_typed_ir.Bytes_key annot_a, Script_typed_ir.Bytes_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Bytes_key annot)
  | (Script_typed_ir.Mutez_key annot_a, Script_typed_ir.Mutez_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Mutez_key annot)
  | (Script_typed_ir.Bool_key annot_a, Script_typed_ir.Bool_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Bool_key annot)
  | (Script_typed_ir.Key_hash_key annot_a, Script_typed_ir.Key_hash_key annot_b)
    =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Key_hash_key annot)
  |
    (Script_typed_ir.Timestamp_key annot_a,
      Script_typed_ir.Timestamp_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Timestamp_key annot)
  | (Script_typed_ir.Address_key annot_a, Script_typed_ir.Address_key annot_b)
    =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Address_key annot)
  | (_, _) =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  end.

Definition merge_types {b : Set} (legacy : bool)
  : Alpha_context.context -&gt; Alpha_context.Script.location -&gt;
  Script_typed_ir.ty b -&gt; Script_typed_ir.ty b -&gt;
  Error_monad.tzresult (Script_typed_ir.ty b * Alpha_context.context) :=
  let fix help {a : Set}
    (ctxt : Alpha_context.context) (ty1 : Script_typed_ir.ty a)
    (ty2 : Script_typed_ir.ty a) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.ty a * Alpha_context.context) :=
    match (ty1, ty2) with
    | (Script_typed_ir.Unit_t tn1, Script_typed_ir.Unit_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Unit_t tname), ctxt))
    | (Script_typed_ir.Int_t tn1, Script_typed_ir.Int_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Int_t tname), ctxt))
    | (Script_typed_ir.Nat_t tn1, Script_typed_ir.Nat_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Nat_t tname), ctxt))
    | (Script_typed_ir.Key_t tn1, Script_typed_ir.Key_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Key_t tname), ctxt))
    | (Script_typed_ir.Key_hash_t tn1, Script_typed_ir.Key_hash_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Key_hash_t tname), ctxt))
    | (Script_typed_ir.String_t tn1, Script_typed_ir.String_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.String_t tname), ctxt))
    | (Script_typed_ir.Bytes_t tn1, Script_typed_ir.Bytes_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Bytes_t tname), ctxt))
    | (Script_typed_ir.Signature_t tn1, Script_typed_ir.Signature_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Signature_t tname), ctxt))
    | (Script_typed_ir.Mutez_t tn1, Script_typed_ir.Mutez_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Mutez_t tname), ctxt))
    | (Script_typed_ir.Timestamp_t tn1, Script_typed_ir.Timestamp_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Timestamp_t tname), ctxt))
    | (Script_typed_ir.Address_t tn1, Script_typed_ir.Address_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Address_t tname), ctxt))
    | (Script_typed_ir.Bool_t tn1, Script_typed_ir.Bool_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Bool_t tname), ctxt))
    | (Script_typed_ir.Chain_id_t tn1, Script_typed_ir.Chain_id_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Chain_id_t tname), ctxt))
    | (Script_typed_ir.Operation_t tn1, Script_typed_ir.Operation_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Operation_t tname), ctxt))
    |
      (Script_typed_ir.Map_t tal tar tn1 has_big_map,
        Script_typed_ir.Map_t tbl tbr tn2 _) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtgtquestion (help ctxt tar tbr)
            (fun function_parameter =&gt;
              let '(value, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar value)
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  Error_monad.op_gtpipequestion
                    (merge_comparable_types legacy tal tbl)
                    (fun tk =&gt;
                      ((Script_typed_ir.Map_t tk value tname has_big_map), ctxt)))))
    |
      (Script_typed_ir.Big_map_t tal tar tn1,
        Script_typed_ir.Big_map_t tbl tbr tn2) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtgtquestion (help ctxt tar tbr)
            (fun function_parameter =&gt;
              let '(value, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar value)
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  Error_monad.op_gtpipequestion
                    (merge_comparable_types legacy tal tbl)
                    (fun tk =&gt;
                      ((Script_typed_ir.Big_map_t tk value tname), ctxt)))))
    | (Script_typed_ir.Set_t ea tn1, Script_typed_ir.Set_t eb tn2) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtpipequestion (merge_comparable_types legacy ea eb)
            (fun e =&gt; ((Script_typed_ir.Set_t e tname), ctxt)))
    |
      (Script_typed_ir.Pair_t (tal, l_field1, l_var1) (tar, r_field1, r_var1)
        tn1 has_big_map,
        Script_typed_ir.Pair_t (tbl, l_field2, l_var2) (tbr, r_field2, r_var2)
          tn2 _) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtgtquestion
            (Script_ir_annot.merge_field_annot legacy l_field1 l_field2)
            (fun l_field =&gt;
              Error_monad.op_gtgtquestion
                (Script_ir_annot.merge_field_annot legacy r_field1 r_field2)
                (fun r_field =&gt;
                  let l_var := Script_ir_annot.merge_var_annot l_var1 l_var2 in
                  let r_var := Script_ir_annot.merge_var_annot r_var1 r_var2 in
                  Error_monad.op_gtgtquestion (help ctxt tal tbl)
                    (fun function_parameter =&gt;
                      let '(left_ty, ctxt) := function_parameter in
                      Error_monad.op_gtpipequestion (help ctxt tar tbr)
                        (fun function_parameter =&gt;
                          let '(right_ty, ctxt) := function_parameter in
                          ((Script_typed_ir.Pair_t (left_ty, l_field, l_var)
                            (right_ty, r_field, r_var) tname has_big_map), ctxt))))))
    |
      (Script_typed_ir.Union_t (tal, tal_annot) (tar, tar_annot) tn1 has_big_map,
        Script_typed_ir.Union_t (tbl, tbl_annot) (tbr, tbr_annot) tn2 _) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtgtquestion
            (Script_ir_annot.merge_field_annot legacy tal_annot tbl_annot)
            (fun left_annot =&gt;
              Error_monad.op_gtgtquestion
                (Script_ir_annot.merge_field_annot legacy tar_annot tbr_annot)
                (fun right_annot =&gt;
                  Error_monad.op_gtgtquestion (help ctxt tal tbl)
                    (fun function_parameter =&gt;
                      let '(left_ty, ctxt) := function_parameter in
                      Error_monad.op_gtpipequestion (help ctxt tar tbr)
                        (fun function_parameter =&gt;
                          let '(right_ty, ctxt) := function_parameter in
                          ((Script_typed_ir.Union_t (left_ty, left_annot)
                            (right_ty, right_annot) tname has_big_map), ctxt))))))
    |
      (Script_typed_ir.Lambda_t tal tar tn1,
        Script_typed_ir.Lambda_t tbl tbr tn2) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtgtquestion (help ctxt tal tbl)
            (fun function_parameter =&gt;
              let '(left_ty, ctxt) := function_parameter in
              Error_monad.op_gtpipequestion (help ctxt tar tbr)
                (fun function_parameter =&gt;
                  let '(right_ty, ctxt) := function_parameter in
                  ((Script_typed_ir.Lambda_t left_ty right_ty tname), ctxt))))
    | (Script_typed_ir.Contract_t tal tn1, Script_typed_ir.Contract_t tbl tn2)
      =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtpipequestion (help ctxt tal tbl)
            (fun function_parameter =&gt;
              let '(arg_ty, ctxt) := function_parameter in
              ((Script_typed_ir.Contract_t arg_ty tname), ctxt)))
    |
      (Script_typed_ir.Option_t tva tn1 has_big_map,
        Script_typed_ir.Option_t tvb tn2 _) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtpipequestion (help ctxt tva tvb)
            (fun function_parameter =&gt;
              let '(ty, ctxt) := function_parameter in
              ((Script_typed_ir.Option_t ty tname has_big_map), ctxt)))
    |
      (Script_typed_ir.List_t tva tn1 has_big_map,
        Script_typed_ir.List_t tvb tn2 _) =&gt;
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt;
          Error_monad.op_gtpipequestion (help ctxt tva tvb)
            (fun function_parameter =&gt;
              let '(ty, ctxt) := function_parameter in
              ((Script_typed_ir.List_t ty tname has_big_map), ctxt)))
    | (_, _) =&gt;
      (* ‚ùå Assert instruction is not handled. *)
      assert false
    end in
  fun ctxt =&gt;
    fun loc =&gt;
      fun ty1 =&gt;
        fun ty2 =&gt;
          record_inconsistent_type_annotations ctxt loc ty1 ty2
            (help ctxt ty1 ty2).

Definition merge_stacks {ta : Set}
  (legacy : bool) (loc : Alpha_context.Script.location)
  : Alpha_context.context -&gt; Script_typed_ir.stack_ty ta -&gt;
  Script_typed_ir.stack_ty ta -&gt;
  Error_monad.tzresult (Script_typed_ir.stack_ty ta * Alpha_context.context) :=
  let fix help {a : Set}
    (ctxt : Alpha_context.context) (stack1 : Script_typed_ir.stack_ty a)
    (stack2 : Script_typed_ir.stack_ty a) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.stack_ty a * Alpha_context.context) :=
    match (stack1, stack2) with
    | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =&gt;
      Error_monad.ok (Script_typed_ir.Empty_t, ctxt)
    |
      (Script_typed_ir.Item_t ty1 rest1 annot1,
        Script_typed_ir.Item_t ty2 rest2 annot2) =&gt;
      let annot := Script_ir_annot.merge_var_annot annot1 annot2 in
      Error_monad.op_gtgtquestion (merge_types legacy ctxt loc ty1 ty2)
        (fun function_parameter =&gt;
          let '(ty, ctxt) := function_parameter in
          Error_monad.op_gtpipequestion (help ctxt rest1 rest2)
            (fun function_parameter =&gt;
              let '(rest, ctxt) := function_parameter in
              ((Script_typed_ir.Item_t ty rest annot), ctxt)))
    end in
  help.

Definition has_big_map {t : Set} (function_parameter : Script_typed_ir.ty t)
  : bool :=
  match function_parameter with
  | Script_typed_ir.Unit_t _ =&gt; false
  | Script_typed_ir.Int_t _ =&gt; false
  | Script_typed_ir.Nat_t _ =&gt; false
  | Script_typed_ir.Signature_t _ =&gt; false
  | Script_typed_ir.String_t _ =&gt; false
  | Script_typed_ir.Bytes_t _ =&gt; false
  | Script_typed_ir.Mutez_t _ =&gt; false
  | Script_typed_ir.Key_hash_t _ =&gt; false
  | Script_typed_ir.Key_t _ =&gt; false
  | Script_typed_ir.Timestamp_t _ =&gt; false
  | Script_typed_ir.Address_t _ =&gt; false
  | Script_typed_ir.Bool_t _ =&gt; false
  | Script_typed_ir.Lambda_t _ _ _ =&gt; false
  | Script_typed_ir.Set_t _ _ =&gt; false
  | Script_typed_ir.Big_map_t _ _ _ =&gt; true
  | Script_typed_ir.Contract_t _ _ =&gt; false
  | Script_typed_ir.Operation_t _ =&gt; false
  | Script_typed_ir.Chain_id_t _ =&gt; false
  | Script_typed_ir.Pair_t _ _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.Union_t _ _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.Option_t _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.List_t _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.Map_t _ _ _ has_big_map =&gt; has_big_map
  end.

Module judgement.
  Module Failed.
    Record record {descr : Set} := {
      descr : descr }.
    Arguments record : clear implicits.
  End Failed.
  Definition Failed := Failed.record.
End judgement.

Reserved Notation &quot;'judgement&quot;.

Inductive judgement_gadt : Set :=
| Typed : forall {aft bef : Set},
  Script_typed_ir.descr bef aft -&gt; judgement_gadt
| Failed : forall {aft bef : Set},
  judgement.Failed
    ((Script_typed_ir.stack_ty aft -&gt; Script_typed_ir.descr bef aft) * aft) -&gt;
  judgement_gadt

where &quot;'judgement&quot; := (fun (bef : Set) =&gt; judgement_gadt).

Definition judgement := 'judgement.

Module branch.
  Record record {t f b : Set} := {
    branch :
      (Script_typed_ir.descr t r -&gt; Script_typed_ir.descr f r -&gt;
      Script_typed_ir.descr b r) * r }.
  Arguments record : clear implicits.
End branch.
Definition branch := branch.record.

Definition merge_branches {a b bef : Set}
  (legacy : bool) (ctxt : Alpha_context.context) (loc : Z) (btr : judgement a)
  (bfr : judgement b) (function_parameter : branch a b bef)
  : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
  let '{| branch.branch := branch |} := function_parameter in
  match (btr, bfr) with
  |
    (Typed ({| Script_typed_ir.descr.aft := aftbt |} as dbt),
      Typed ({| Script_typed_ir.descr.aft := aftbf |} as dbf)) =&gt;
    let unmatched_branches (function_parameter : unit)
      : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
      let 'tt := function_parameter in
      Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt aftbt)
        (fun function_parameter =&gt;
          let '(aftbt, ctxt) := function_parameter in
          Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt aftbf)
            (fun function_parameter =&gt;
              let '(aftbf, _ctxt) := function_parameter in
              extensible_type_value)) in
    Error_monad.trace_eval unmatched_branches
      (Error_monad.op_gtgteqquestion
        (Lwt.__return (stack_ty_eq ctxt 1 aftbt aftbf))
        (fun function_parameter =&gt;
          let '(Eq, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Lwt.__return (merge_stacks legacy loc ctxt aftbt aftbf))
            (fun function_parameter =&gt;
              let '(merged_stack, ctxt) := function_parameter in
              Error_monad.__return
                ((Typed
                  (branch
                    (* ‚ùå Record substitution not handled *)
                    record_substitution
                    (* ‚ùå Record substitution not handled *)
                    record_substitution)), ctxt))))
  |
    (Failed {| judgement.Failed.descr := descrt |},
      Failed {| judgement.Failed.descr := descrf |}) =&gt;
    let __descr_value {D : Set} (ret : Script_typed_ir.stack_ty D)
      : Script_typed_ir.descr bef D :=
      branch (descrt ret) (descrf ret) in
    Error_monad.__return
      ((Failed {| judgement.Failed.descr := __descr_value |}), ctxt)
  | (Typed dbt, Failed {| judgement.Failed.descr := descrf |}) =&gt;
    Error_monad.__return
      ((Typed (branch dbt (descrf (Script_typed_ir.descr.aft dbt)))), ctxt)
  | (Failed {| judgement.Failed.descr := descrt |}, Typed dbf) =&gt;
    Error_monad.__return
      ((Typed (branch (descrt (Script_typed_ir.descr.aft dbf)) dbf)), ctxt)
  end.

Fixpoint parse_comparable_ty
  (ctxt : Alpha_context.context) (ty : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_comparable_ty * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =&gt;
      Error_monad.op_gtgtquestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
        (fun ctxt =&gt;
          match ty with
          | Micheline.Prim loc Alpha_context.Script.T_int [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Int_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_nat [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Nat_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_string [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.String_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_bytes [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Bytes_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_mutez [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Mutez_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_bool [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Bool_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Key_hash_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Timestamp_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_address [] annot =&gt;
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =&gt;
                ((Ex_comparable_ty (Script_typed_ir.Address_key tname)), ctxt))
          |
            Micheline.Prim loc
              ((Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
              Alpha_context.Script.T_string | Alpha_context.Script.T_mutez |
              Alpha_context.Script.T_bool | Alpha_context.Script.T_key |
              Alpha_context.Script.T_address | Alpha_context.Script.T_timestamp)
                as prim) l _ =&gt; Error_monad.__error_value extensible_type_value
          |
            Micheline.Prim loc
              (Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
              Alpha_context.Script.T_set | Alpha_context.Script.T_map |
              Alpha_context.Script.T_list | Alpha_context.Script.T_option |
              Alpha_context.Script.T_lambda | Alpha_context.Script.T_unit |
              Alpha_context.Script.T_signature | Alpha_context.Script.T_contract)
              _ _ =&gt; Error_monad.__error_value extensible_type_value
          | expr =&gt;
            Pervasives.op_atat Error_monad.__error_value
              (unexpected expr [] Script_tc_errors.Type_namespace
                (cons Alpha_context.Script.T_int
                  (cons Alpha_context.Script.T_nat
                    (cons Alpha_context.Script.T_string
                      (cons Alpha_context.Script.T_mutez
                        (cons Alpha_context.Script.T_bool
                          (cons Alpha_context.Script.T_key
                            (cons Alpha_context.Script.T_key_hash
                              (cons Alpha_context.Script.T_timestamp [])))))))))
          end))

with parse_packable_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy false false legacy

with parse_parameter_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true false true

with parse_any_ty (ctxt : Alpha_context.context) (legacy : bool) {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true true true

with parse_ty
  (ctxt : Alpha_context.context) (legacy : bool) (allow_big_map : bool)
  (allow_operation : bool) (allow_contract : bool)
  (node : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =&gt;
      match
        (node,
          match node with
          | Micheline.Prim loc Alpha_context.Script.T_big_map args annot =&gt;
            allow_big_map
          | _ =&gt; false
          end) with
      | (Micheline.Prim loc Alpha_context.Script.T_unit [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Unit_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_int [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Int_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_nat [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Nat_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_string [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.String_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_bytes [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Bytes_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_mutez [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Mutez_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_bool [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Bool_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_key [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Key_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Key_hash_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Timestamp_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_address [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Address_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_signature [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Signature_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_operation [] annot, _) =&gt;
        if allow_operation then
          Error_monad.op_gtgtquestion
            (Script_ir_annot.parse_type_annot loc annot)
            (fun ty_name =&gt;
              Error_monad.op_gtpipequestion
                (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
                (fun ctxt =&gt;
                  ((Ex_ty (Script_typed_ir.Operation_t ty_name)), ctxt)))
        else
          Error_monad.__error_value extensible_type_value
      | (Micheline.Prim loc Alpha_context.Script.T_chain_id [] annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =&gt;
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Chain_id_t ty_name)), ctxt)))
      |
        (Micheline.Prim loc Alpha_context.Script.T_contract (cons utl []) annot,
          _) =&gt;
        if allow_contract then
          Error_monad.op_gtgtquestion (parse_parameter_ty ctxt legacy utl)
            (fun function_parameter =&gt;
              let '(Ex_ty tl, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion
                (Script_ir_annot.parse_type_annot loc annot)
                (fun ty_name =&gt;
                  Error_monad.op_gtpipequestion
                    (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
                    (fun ctxt =&gt;
                      ((Ex_ty (Script_typed_ir.Contract_t tl ty_name)), ctxt))))
        else
          Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc Alpha_context.Script.T_pair (cons utl (cons utr []))
          annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.extract_field_annot utl)
          (fun function_parameter =&gt;
            let '(utl, left_field) := function_parameter in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.extract_field_annot utr)
              (fun function_parameter =&gt;
                let '(utr, right_field) := function_parameter in
                Error_monad.op_gtgtquestion
                  (parse_ty ctxt legacy allow_big_map allow_operation
                    allow_contract utl)
                  (fun function_parameter =&gt;
                    let '(Ex_ty tl, ctxt) := function_parameter in
                    Error_monad.op_gtgtquestion
                      (parse_ty ctxt legacy allow_big_map allow_operation
                        allow_contract utr)
                      (fun function_parameter =&gt;
                        let '(Ex_ty tr, ctxt) := function_parameter in
                        Error_monad.op_gtgtquestion
                          (Script_ir_annot.parse_type_annot loc annot)
                          (fun ty_name =&gt;
                            Error_monad.op_gtpipequestion
                              (Alpha_context.Gas.consume ctxt
                                (Typecheck_costs.type_ 2))
                              (fun ctxt =&gt;
                                ((Ex_ty
                                  (Script_typed_ir.Pair_t (tl, left_field, None)
                                    (tr, right_field, None) ty_name
                                    (Pervasives.op_pipepipe (has_big_map tl)
                                      (has_big_map tr)))), ctxt)))))))
      |
        (Micheline.Prim loc Alpha_context.Script.T_or (cons utl (cons utr []))
          annot, _) =&gt;
        Error_monad.op_gtgtquestion (Script_ir_annot.extract_field_annot utl)
          (fun function_parameter =&gt;
            let '(utl, left_constr) := function_parameter in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.extract_field_annot utr)
              (fun function_parameter =&gt;
                let '(utr, right_constr) := function_parameter in
                Error_monad.op_gtgtquestion
                  (parse_ty ctxt legacy allow_big_map allow_operation
                    allow_contract utl)
                  (fun function_parameter =&gt;
                    let '(Ex_ty tl, ctxt) := function_parameter in
                    Error_monad.op_gtgtquestion
                      (parse_ty ctxt legacy allow_big_map allow_operation
                        allow_contract utr)
                      (fun function_parameter =&gt;
                        let '(Ex_ty tr, ctxt) := function_parameter in
                        Error_monad.op_gtgtquestion
                          (Script_ir_annot.parse_type_annot loc annot)
                          (fun ty_name =&gt;
                            Error_monad.op_gtpipequestion
                              (Alpha_context.Gas.consume ctxt
                                (Typecheck_costs.type_ 2))
                              (fun ctxt =&gt;
                                ((Ex_ty
                                  (Script_typed_ir.Union_t (tl, left_constr)
                                    (tr, right_constr) ty_name
                                    (Pervasives.op_pipepipe (has_big_map tl)
                                      (has_big_map tr)))), ctxt)))))))
      |
        (Micheline.Prim loc Alpha_context.Script.T_lambda
          (cons uta (cons utr [])) annot, _) =&gt;
        Error_monad.op_gtgtquestion (parse_any_ty ctxt legacy uta)
          (fun function_parameter =&gt;
            let '(Ex_ty ta, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion (parse_any_ty ctxt legacy utr)
              (fun function_parameter =&gt;
                let '(Ex_ty tr, ctxt) := function_parameter in
                Error_monad.op_gtgtquestion
                  (Script_ir_annot.parse_type_annot loc annot)
                  (fun ty_name =&gt;
                    Error_monad.op_gtpipequestion
                      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
                      (fun ctxt =&gt;
                        ((Ex_ty (Script_typed_ir.Lambda_t ta tr ty_name)), ctxt)))))
      | (Micheline.Prim loc Alpha_context.Script.T_option (cons ut []) annot, _)
        =&gt;
        Error_monad.op_gtgtquestion
          (if legacy then
            Error_monad.op_gtgtquestion (Script_ir_annot.extract_field_annot ut)
              (fun function_parameter =&gt;
                let '(ut, _some_constr) := function_parameter in
                Error_monad.op_gtgtquestion
                  (Script_ir_annot.parse_composed_type_annot loc annot)
                  (fun function_parameter =&gt;
                    let '(ty_name, _none_constr, _) := function_parameter in
                    Error_monad.ok (ut, ty_name)))
          else
            Error_monad.op_gtgtquestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun ty_name =&gt; Error_monad.ok (ut, ty_name)))
          (fun function_parameter =&gt;
            let '(ut, ty_name) := function_parameter in
            Error_monad.op_gtgtquestion
              (parse_ty ctxt legacy allow_big_map allow_operation allow_contract
                ut)
              (fun function_parameter =&gt;
                let '(Ex_ty t, ctxt) := function_parameter in
                Error_monad.op_gtpipequestion
                  (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
                  (fun ctxt =&gt;
                    ((Ex_ty (Script_typed_ir.Option_t t ty_name (has_big_map t))),
                      ctxt))))
      | (Micheline.Prim loc Alpha_context.Script.T_list (cons ut []) annot, _)
        =&gt;
        Error_monad.op_gtgtquestion
          (parse_ty ctxt legacy allow_big_map allow_operation allow_contract ut)
          (fun function_parameter =&gt;
            let '(Ex_ty t, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun ty_name =&gt;
                Error_monad.op_gtpipequestion
                  (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
                  (fun ctxt =&gt;
                    ((Ex_ty (Script_typed_ir.List_t t ty_name (has_big_map t))),
                      ctxt))))
      | (Micheline.Prim loc Alpha_context.Script.T_set (cons ut []) annot, _) =&gt;
        Error_monad.op_gtgtquestion (parse_comparable_ty ctxt ut)
          (fun function_parameter =&gt;
            let '(Ex_comparable_ty t, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun ty_name =&gt;
                Error_monad.op_gtpipequestion
                  (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
                  (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Set_t t ty_name)), ctxt))))
      |
        (Micheline.Prim loc Alpha_context.Script.T_map (cons uta (cons utr []))
          annot, _) =&gt;
        Error_monad.op_gtgtquestion (parse_comparable_ty ctxt uta)
          (fun function_parameter =&gt;
            let '(Ex_comparable_ty ta, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion
              (parse_ty ctxt legacy allow_big_map allow_operation allow_contract
                utr)
              (fun function_parameter =&gt;
                let '(Ex_ty tr, ctxt) := function_parameter in
                Error_monad.op_gtgtquestion
                  (Script_ir_annot.parse_type_annot loc annot)
                  (fun ty_name =&gt;
                    Error_monad.op_gtpipequestion
                      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
                      (fun ctxt =&gt;
                        ((Ex_ty
                          (Script_typed_ir.Map_t ta tr ty_name (has_big_map tr))),
                          ctxt)))))
      | (Micheline.Prim loc Alpha_context.Script.T_big_map args annot, true) =&gt;
        Error_monad.op_gtgtquestion
          (parse_big_map_ty ctxt legacy loc args annot)
          (fun function_parameter =&gt;
            let '(big_map_ty, ctxt) := function_parameter in
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
              (fun ctxt =&gt; (big_map_ty, ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_big_map _ _, _) =&gt;
        Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc
          ((Alpha_context.Script.T_unit | Alpha_context.Script.T_signature |
          Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
          Alpha_context.Script.T_string | Alpha_context.Script.T_bytes |
          Alpha_context.Script.T_mutez | Alpha_context.Script.T_bool |
          Alpha_context.Script.T_key | Alpha_context.Script.T_key_hash |
          Alpha_context.Script.T_timestamp | Alpha_context.Script.T_address) as
            prim) l _, _) =&gt; Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc
          ((Alpha_context.Script.T_set | Alpha_context.Script.T_list |
          Alpha_context.Script.T_option | Alpha_context.Script.T_contract) as
            prim) l _, _) =&gt; Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc
          ((Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
          Alpha_context.Script.T_map | Alpha_context.Script.T_lambda) as prim) l
          _, _) =&gt; Error_monad.__error_value extensible_type_value
      | (expr, _) =&gt;
        Pervasives.op_atat Error_monad.__error_value
          (unexpected expr [] Script_tc_errors.Type_namespace
            (cons Alpha_context.Script.T_pair
              (cons Alpha_context.Script.T_or
                (cons Alpha_context.Script.T_set
                  (cons Alpha_context.Script.T_map
                    (cons Alpha_context.Script.T_list
                      (cons Alpha_context.Script.T_option
                        (cons Alpha_context.Script.T_lambda
                          (cons Alpha_context.Script.T_unit
                            (cons Alpha_context.Script.T_signature
                              (cons Alpha_context.Script.T_contract
                                (cons Alpha_context.Script.T_int
                                  (cons Alpha_context.Script.T_nat
                                    (cons Alpha_context.Script.T_operation
                                      (cons Alpha_context.Script.T_string
                                        (cons Alpha_context.Script.T_bytes
                                          (cons Alpha_context.Script.T_mutez
                                            (cons Alpha_context.Script.T_bool
                                              (cons Alpha_context.Script.T_key
                                                (cons
                                                  Alpha_context.Script.T_key_hash
                                                  (cons
                                                    Alpha_context.Script.T_timestamp
                                                    (cons
                                                      Alpha_context.Script.T_chain_id
                                                      []))))))))))))))))))))))
      end)

with parse_big_map_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (big_map_loc : Alpha_context.Script.location)
  (args :
    list
      (Micheline.node Alpha_context.Script.location Alpha_context.Script.prim))
  (map_annot : Micheline.annot) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =&gt;
      match args with
      | cons key_ty (cons value_ty []) =&gt;
        Error_monad.op_gtgtquestion (parse_comparable_ty ctxt key_ty)
          (fun function_parameter =&gt;
            let '(Ex_comparable_ty key_ty, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion (parse_packable_ty ctxt legacy value_ty)
              (fun function_parameter =&gt;
                let '(Ex_ty value_ty, ctxt) := function_parameter in
                Error_monad.op_gtpipequestion
                  (Script_ir_annot.parse_type_annot big_map_loc map_annot)
                  (fun map_name =&gt;
                    let big_map_ty :=
                      Script_typed_ir.Big_map_t key_ty value_ty map_name in
                    ((Ex_ty big_map_ty), ctxt))))
      | args =&gt;
        Pervasives.op_atat Error_monad.__error_value extensible_type_value
      end)

with parse_storage_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (node : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  match
    (node,
      match node with
      |
        Micheline.Prim loc Alpha_context.Script.T_pair
          (cons
            (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
              map_annot) (cons remaining_storage [])) storage_annot =&gt; legacy
      | _ =&gt; false
      end) with
  |
    (Micheline.Prim loc Alpha_context.Script.T_pair
      (cons
        (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
          map_annot) (cons remaining_storage [])) storage_annot, true) =&gt;
    match
      (storage_annot,
        match storage_annot with
        | cons single [] =&gt;
          Pervasives.op_andand
            (Compare.Int.[Compare.S.op_gt] (String.length single) 0)
            (Compare.Char.[Compare.S.op_eq] (String.get single 0) &quot;%&quot; % char)
        | _ =&gt; false
        end) with
    | ([], _) =&gt; parse_ty ctxt legacy true false legacy node
    | (cons single [], true) =&gt; parse_ty ctxt legacy true false legacy node
    | (_, _) =&gt;
      Error_monad.op_gtgtquestion
        (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
        (fun ctxt =&gt;
          Error_monad.op_gtgtquestion
            (parse_big_map_ty ctxt legacy big_map_loc args map_annot)
            (fun function_parameter =&gt;
              let '(Ex_ty big_map_ty, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion
                (parse_ty ctxt legacy true false legacy remaining_storage)
                (fun function_parameter =&gt;
                  let '(Ex_ty remaining_storage, ctxt) := function_parameter in
                  Error_monad.op_gtgtquestion
                    (Script_ir_annot.parse_composed_type_annot loc storage_annot)
                    (fun function_parameter =&gt;
                      let '(ty_name, map_field, storage_field) :=
                        function_parameter in
                      Error_monad.op_gtpipequestion
                        (Alpha_context.Gas.consume ctxt
                          (Typecheck_costs.type_ 5))
                        (fun ctxt =&gt;
                          ((Ex_ty
                            (Script_typed_ir.Pair_t
                              (big_map_ty, map_field, None)
                              (remaining_storage, storage_field, None) ty_name
                              true)), ctxt))))))
    end
  | (_, _) =&gt; parse_ty ctxt legacy true false legacy node
  end.

Definition check_packable {A : Set}
  (legacy : bool) (loc : Alpha_context.Script.location)
  (root : Script_typed_ir.ty A) : Error_monad.tzresult unit :=
  let fix check {t : Set} (function_parameter : Script_typed_ir.ty t)
    {struct function_parameter} : Error_monad.tzresult unit :=
    match
      (function_parameter,
        match function_parameter with
        | Script_typed_ir.Contract_t _ _ =&gt; legacy
        | _ =&gt; false
        end) with
    | (Script_typed_ir.Big_map_t _ _ _, _) =&gt;
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Operation_t _, _) =&gt;
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Unit_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Int_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Nat_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Signature_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.String_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Bytes_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Mutez_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Key_hash_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Key_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Timestamp_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Address_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Bool_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Chain_id_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Pair_t (l_ty, _, _) (r_ty, _, _) _ _, _) =&gt;
      Error_monad.op_gtgtquestion (check l_ty)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          check r_ty)
    | (Script_typed_ir.Union_t (l_ty, _) (r_ty, _) _ _, _) =&gt;
      Error_monad.op_gtgtquestion (check l_ty)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          check r_ty)
    | (Script_typed_ir.Option_t v_ty _ _, _) =&gt; check v_ty
    | (Script_typed_ir.List_t elt_ty _ _, _) =&gt; check elt_ty
    | (Script_typed_ir.Set_t _ _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Map_t _ elt_ty _ _, _) =&gt; check elt_ty
    | (Script_typed_ir.Lambda_t _l_ty _r_ty _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, true) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, _) =&gt;
      Error_monad.__error_value extensible_type_value
    end in
  check root.

Reserved Notation &quot;'ex_script&quot;.

Inductive ex_script_gadt : Set :=
| Ex_script : forall {a c : Set}, Script_typed_ir.script a c -&gt; ex_script_gadt

where &quot;'ex_script&quot; := (ex_script_gadt).

Definition ex_script := 'ex_script.

Reserved Notation &quot;'dig_proof_argument&quot;.

Inductive dig_proof_argument_gadt : Set :=
| Dig_proof_argument : forall {aft bef rest x : Set},
  Script_typed_ir.stack_prefix_preservation_witness (x * rest) rest bef aft *
    (Script_typed_ir.ty x * option Script_typed_ir.var_annot) *
    Script_typed_ir.stack_ty aft -&gt; dig_proof_argument_gadt

where &quot;'dig_proof_argument&quot; := (fun (_ : Set) =&gt; dig_proof_argument_gadt).

Definition dig_proof_argument := 'dig_proof_argument.

Reserved Notation &quot;'dug_proof_argument&quot;.

Inductive dug_proof_argument_gadt : Set :=
| Dug_proof_argument : forall {aft bef rest x : Set},
  Script_typed_ir.stack_prefix_preservation_witness rest (x * rest) bef aft *
    unit * Script_typed_ir.stack_ty aft -&gt; dug_proof_argument_gadt

where &quot;'dug_proof_argument&quot; := (fun (_ _ : Set) =&gt; dug_proof_argument_gadt).

Definition dug_proof_argument := 'dug_proof_argument.

Reserved Notation &quot;'dipn_proof_argument&quot;.

Inductive dipn_proof_argument_gadt : Set :=
| Dipn_proof_argument : forall {aft bef faft fbef : Set},
  Script_typed_ir.stack_prefix_preservation_witness fbef faft bef aft *
    (Alpha_context.context * Script_typed_ir.descr fbef faft) *
    Script_typed_ir.stack_ty aft -&gt; dipn_proof_argument_gadt

where &quot;'dipn_proof_argument&quot; := (fun (_ : Set) =&gt; dipn_proof_argument_gadt).

Definition dipn_proof_argument := 'dipn_proof_argument.

Reserved Notation &quot;'dropn_proof_argument&quot;.

Inductive dropn_proof_argument_gadt : Set :=
| Dropn_proof_argument : forall {aft bef rest : Set},
  Script_typed_ir.stack_prefix_preservation_witness rest rest bef aft *
    Script_typed_ir.stack_ty rest * Script_typed_ir.stack_ty aft -&gt;
  dropn_proof_argument_gadt

where &quot;'dropn_proof_argument&quot; := (fun (_ : Set) =&gt; dropn_proof_argument_gadt).

Definition dropn_proof_argument := 'dropn_proof_argument.

Definition parse_var_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t (Error_monad.tzresult (option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_annot loc default annot).

Definition parse_entrypoint_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return (Script_ir_annot.parse_entrypoint_annot loc default annot).

Definition parse_constr_annot
  (loc : Z) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
        option Script_typed_ir.field_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_constr_annot loc if_special_first if_special_second
      annot).

Definition parse_two_var_annot (loc : Z) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_two_var_annot loc annot).

Definition parse_destr_annot
  (loc : Z) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_destr_annot loc annot default_accessor field_name
      pair_annot value_annot).

Definition parse_var_type_annot (loc : Z) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_type_annot loc annot).

Definition find_entrypoint {A : Set}
  (full : Script_typed_ir.ty A)
  (root_name : option Compare.String.[Compare.S.t])
  (entrypoint : Compare.String.[Compare.S.t])
  : Error_monad.tzresult
    ((Alpha_context.Script.node -&gt; Alpha_context.Script.node) * ex_ty) :=
  let fix find_entrypoint {t : Set}
    (t : Script_typed_ir.ty t) (entrypoint : string) {struct t}
    : (Alpha_context.Script.node -&gt; Alpha_context.Script.node) * ex_ty :=
    match t with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =&gt;
      if
        match al with
        | None =&gt; false
        | Some (Field_annot l) =&gt; Compare.String.[Compare.S.op_eq] l entrypoint
        end then
        ((fun e =&gt; Micheline.Prim 0 Alpha_context.Script.D_Left (cons e []) []),
          (Ex_ty tl))
      else
        if
          match ar with
          | None =&gt; false
          | Some (Field_annot r) =&gt;
            Compare.String.[Compare.S.op_eq] r entrypoint
          end then
          ((fun e =&gt;
            Micheline.Prim 0 Alpha_context.Script.D_Right (cons e []) []),
            (Ex_ty tr))
        else
          (* ‚ùå Try-with are not handled *)
          try
            (let '(f, t) := find_entrypoint tl entrypoint in
            ((fun e =&gt;
              Micheline.Prim 0 Alpha_context.Script.D_Left (cons (f e) []) []),
              t))
    | _ =&gt; Pervasives.raise extensible_type_value
    end in
  let entrypoint :=
    if Compare.String.[Compare.S.op_eq] entrypoint &quot;&quot; % string then
      &quot;default&quot; % string
    else
      entrypoint in
  if Compare.Int.[Compare.S.op_gt] (String.length entrypoint) 31 then
    Error_monad.__error_value extensible_type_value
  else
    match
      (root_name,
        match root_name with
        | Some root_name =&gt;
          Compare.String.[Compare.S.op_eq] entrypoint root_name
        | _ =&gt; false
        end) with
    | (Some root_name, true) =&gt; Error_monad.ok ((fun e =&gt; e), (Ex_ty full))
    | (_, _) =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Error_monad.ok (find_entrypoint full entrypoint))
    end.

Definition find_entrypoint_for_type {A B : Set}
  (full : Script_typed_ir.ty A) (expected : Script_typed_ir.ty B)
  (root_name : option Compare.String.[Compare.S.t])
  (entrypoint : Compare.String.[Compare.S.t]) (ctxt : Alpha_context.context)
  : Error_monad.tzresult (Alpha_context.context * string * Script_typed_ir.ty B) :=
  match (entrypoint, root_name) with
  | (&quot;default&quot; % string, Some &quot;root&quot; % string) =&gt;
    match find_entrypoint full root_name entrypoint with
    | (Pervasives.Error _) as err =&gt; err
    | Pervasives.Ok (_, Ex_ty ty) =&gt;
      match ty_eq ctxt expected ty with
      | Pervasives.Ok (Eq, ctxt) =&gt;
        Error_monad.ok (ctxt, &quot;default&quot; % string, ty)
      | Pervasives.Error _ =&gt;
        Error_monad.op_gtgtquestion (ty_eq ctxt expected full)
          (fun function_parameter =&gt;
            let '(Eq, ctxt) := function_parameter in
            Error_monad.ok (ctxt, &quot;root&quot; % string, full))
      end
    end
  | _ =&gt;
    Error_monad.op_gtgtquestion (find_entrypoint full root_name entrypoint)
      (fun function_parameter =&gt;
        let '(_, Ex_ty ty) := function_parameter in
        Error_monad.op_gtgtquestion (ty_eq ctxt expected ty)
          (fun function_parameter =&gt;
            let '(Eq, ctxt) := function_parameter in
            Error_monad.ok (ctxt, entrypoint, ty)))
  end.

Definition Entrypoints :=
  __Set.Make
    (existT _ _
      {|
        Compare.COMPARABLE.compare := String.compare
        |}).

(* ‚ùå The definition of exceptions is not handled. *)
(* exception Duplicate *)

(* ‚ùå The definition of exceptions is not handled. *)
(* exception Too_long *)

Definition well_formed_entrypoints {A : Set}
  (full : Script_typed_ir.ty A) (root_name : option Entrypoints.[S.SET.elt])
  : Error_monad.tzresult unit :=
  let merge {B C : Set}
    (path : list B) (annot : option (* `Field_annot *) Entrypoints.[S.SET.elt])
    (ty : Script_typed_ir.ty C) (reachable : bool)
    (function_parameter : option (list B) * Entrypoints.[S.SET.t])
    : option (list B) * Entrypoints.[S.SET.t] :=
    let '(first_unreachable, all) as acc := function_parameter in
    match annot with
    | None | Some (Field_annot &quot;&quot; % string) =&gt;
      if reachable then
        acc
      else
        match ty with
        | Script_typed_ir.Union_t _ _ _ _ =&gt; acc
        | _ =&gt;
          match first_unreachable with
          | None =&gt; ((Some (List.rev path)), all)
          | Some _ =&gt; acc
          end
        end
    | Some (Field_annot name) =&gt;
      if Compare.Int.[Compare.S.op_gt] (String.length name) 31 then
        Pervasives.raise extensible_type_value
      else
        if Entrypoints.[S.SET.mem] name all then
          Pervasives.raise extensible_type_value
        else
          (first_unreachable, (Entrypoints.[S.SET.add] name all))
    end in
  let fix check {t : Set}
    (t : Script_typed_ir.ty t) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc : option (list Alpha_context.Script.prim) * Entrypoints.[S.SET.t])
    {struct t}
    : option (list Alpha_context.Script.prim) * Entrypoints.[S.SET.t] :=
    match t with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =&gt;
      let acc :=
        merge (cons Alpha_context.Script.D_Left path) al tl reachable acc in
      let acc :=
        merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc in
      let acc :=
        check tl (cons Alpha_context.Script.D_Left path)
          match al with
          | Some _ =&gt; true
          | None =&gt; reachable
          end acc in
      check tr (cons Alpha_context.Script.D_Right path)
        match ar with
        | Some _ =&gt; true
        | None =&gt; reachable
        end acc
    | _ =&gt; acc
    end in
  (* ‚ùå Try-with are not handled *)
  try
    (let '(init, reachable) :=
      match root_name with
      | None | Some &quot;&quot; % string =&gt; (Entrypoints.[S.SET.empty], false)
      | Some name =&gt; ((Entrypoints.[S.SET.singleton] name), true)
      end in
    let '(first_unreachable, all) := check full [] reachable (None, init) in
    if Pervasives.not (Entrypoints.[S.SET.mem] &quot;default&quot; % string all) then
      Error_monad.ok tt
    else
      match first_unreachable with
      | None =&gt; Error_monad.ok tt
      | Some path =&gt; Error_monad.__error_value extensible_type_value
      end).

Fixpoint parse_data {a : Set}
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (ty : Script_typed_ir.ty a)
  (script_data : Alpha_context.Script.node) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
    (fun ctxt =&gt;
      let __error_value (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let 'tt := function_parameter in
        Error_monad.op_gtgtpipequestion
          (Lwt.__return (serialize_ty_for_error ctxt ty))
          (fun function_parameter =&gt;
            let '(ty, _ctxt) := function_parameter in
            extensible_type_value) in
      let traced {B : Set} (body : Lwt.t (Error_monad.tzresult B))
        : Lwt.t (Error_monad.tzresult B) :=
        Error_monad.trace_eval __error_value body in
      let parse_items {B C D E : Set}
        (type_logger : option type_logger) (loc : Alpha_context.Script.location)
        (ctxt : Alpha_context.context)
        (expr : Micheline.node B Alpha_context.Script.prim)
        (key_type : Script_typed_ir.comparable_ty C)
        (value_type : Script_typed_ir.ty D)
        (items :
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)) (item_wrapper : D -&gt; E)
        : Lwt.t
          (Error_monad.tzresult
            (Script_typed_ir.map C E * Alpha_context.context)) :=
        let length := List.length items in
        Error_monad.op_gtgtpipequestion
          (Pervasives.op_pipegt
            (Error_monad.fold_left_s
              (fun function_parameter =&gt;
                let '(last_value, map, ctxt) := function_parameter in
                fun item =&gt;
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Typecheck_costs.map_element length)))
                    (fun ctxt =&gt;
                      match item with
                      |
                        Micheline.Prim _ Alpha_context.Script.D_Elt
                          (cons k (cons v [])) _ =&gt;
                        Error_monad.op_gtgteqquestion
                          (parse_comparable_data type_logger ctxt key_type k)
                          (fun function_parameter =&gt;
                            let '(k, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (parse_data type_logger ctxt legacy value_type v)
                              (fun function_parameter =&gt;
                                let '(v, ctxt) := function_parameter in
                                Error_monad.op_gtgteqquestion
                                  match last_value with
                                  | Some value =&gt;
                                    if
                                      Compare.Int.[Compare.S.op_lteq] 0
                                        (compare_comparable key_type value k)
                                      then
                                      if
                                        Compare.Int.[Compare.S.op_eq] 0
                                          (compare_comparable key_type value k)
                                        then
                                        Error_monad.fail extensible_type_value
                                      else
                                        Error_monad.fail extensible_type_value
                                    else
                                      Error_monad.return_unit
                                  | None =&gt; Error_monad.return_unit
                                  end
                                  (fun function_parameter =&gt;
                                    let 'tt := function_parameter in
                                    Error_monad.__return
                                      ((Some k),
                                        (map_update k (Some (item_wrapper v))
                                          map), ctxt))))
                      | Micheline.Prim loc Alpha_context.Script.D_Elt l _ =&gt;
                        Pervasives.op_atat Error_monad.fail
                          extensible_type_value
                      | Micheline.Prim loc name _ _ =&gt;
                        Pervasives.op_atat Error_monad.fail
                          extensible_type_value
                      |
                        Micheline.Int _ _ | Micheline.String _ _ |
                        Micheline.Bytes _ _ | Micheline.Seq _ _ =&gt;
                        Error_monad.op_gtgteqquestion (__error_value tt)
                          Error_monad.fail
                      end)) (None, (empty_map key_type), ctxt) items) traced)
          (fun function_parameter =&gt;
            let '(_, items, ctxt) := function_parameter in
            (items, ctxt)) in
      match (ty, script_data) with
      |
        (Script_typed_ir.Unit_t _,
          Micheline.Prim loc Alpha_context.Script.D_Unit [] annot) =&gt;
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.__unit_value))
              (fun ctxt =&gt; (tt, ctxt)))
      |
        (Script_typed_ir.Unit_t _,
          Micheline.Prim loc Alpha_context.Script.D_Unit l _) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Unit_t _, expr) =&gt;
        traced
          (Error_monad.fail
            (unexpected expr [] Script_tc_errors.Constant_namespace
              (cons Alpha_context.Script.D_Unit [])))
      |
        (Script_typed_ir.Bool_t _,
          Micheline.Prim loc Alpha_context.Script.D_True [] annot) =&gt;
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
              (fun ctxt =&gt; (true, ctxt)))
      |
        (Script_typed_ir.Bool_t _,
          Micheline.Prim loc Alpha_context.Script.D_False [] annot) =&gt;
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
              (fun ctxt =&gt; (false, ctxt)))
      |
        (Script_typed_ir.Bool_t _,
          Micheline.Prim loc
            ((Alpha_context.Script.D_True | Alpha_context.Script.D_False) as c)
            l _) =&gt; traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Bool_t _, expr) =&gt;
        traced
          (Error_monad.fail
            (unexpected expr [] Script_tc_errors.Constant_namespace
              (cons Alpha_context.Script.D_True
                (cons Alpha_context.Script.D_False []))))
      | (Script_typed_ir.String_t _, Micheline.String _ v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Typecheck_costs.__string_value (String.length v))))
          (fun ctxt =&gt;
            let fix check_printable_ascii (i : Compare.Int.[Compare.S.t])
              {struct i} : bool :=
              if Compare.Int.[Compare.S.op_lt] i 0 then
                true
              else
                match String.get v i with
                |
                  &quot;010&quot; % char | &quot; &quot; % char | &quot;!&quot; % char | &quot;&quot;&quot;&quot; % char |
                  &quot;#&quot; % char | &quot;$&quot; % char | &quot;%&quot; % char | &quot;&amp;&quot; % char | &quot;'&quot; % char
                  | &quot;(&quot; % char | &quot;)&quot; % char | &quot;*&quot; % char | &quot;+&quot; % char |
                  &quot;,&quot; % char | &quot;-&quot; % char | &quot;.&quot; % char | &quot;/&quot; % char | &quot;0&quot; % char
                  | &quot;1&quot; % char | &quot;2&quot; % char | &quot;3&quot; % char | &quot;4&quot; % char |
                  &quot;5&quot; % char | &quot;6&quot; % char | &quot;7&quot; % char | &quot;8&quot; % char | &quot;9&quot; % char
                  | &quot;:&quot; % char | &quot;;&quot; % char | &quot;&lt;&quot; % char | &quot;=&quot; % char |
                  &quot;&gt;&quot; % char | &quot;?&quot; % char | &quot;@&quot; % char | &quot;A&quot; % char | &quot;B&quot; % char
                  | &quot;C&quot; % char | &quot;D&quot; % char | &quot;E&quot; % char | &quot;F&quot; % char |
                  &quot;G&quot; % char | &quot;H&quot; % char | &quot;I&quot; % char | &quot;J&quot; % char | &quot;K&quot; % char
                  | &quot;L&quot; % char | &quot;M&quot; % char | &quot;N&quot; % char | &quot;O&quot; % char |
                  &quot;P&quot; % char | &quot;Q&quot; % char | &quot;R&quot; % char | &quot;S&quot; % char | &quot;T&quot; % char
                  | &quot;U&quot; % char | &quot;V&quot; % char | &quot;W&quot; % char | &quot;X&quot; % char |
                  &quot;Y&quot; % char | &quot;Z&quot; % char | &quot;[&quot; % char | &quot;\&quot; % char | &quot;]&quot; % char
                  | &quot;^&quot; % char | &quot;_&quot; % char | &quot;`&quot; % char | &quot;a&quot; % char |
                  &quot;b&quot; % char | &quot;c&quot; % char | &quot;d&quot; % char | &quot;e&quot; % char | &quot;f&quot; % char
                  | &quot;g&quot; % char | &quot;h&quot; % char | &quot;i&quot; % char | &quot;j&quot; % char |
                  &quot;k&quot; % char | &quot;l&quot; % char | &quot;m&quot; % char | &quot;n&quot; % char | &quot;o&quot; % char
                  | &quot;p&quot; % char | &quot;q&quot; % char | &quot;r&quot; % char | &quot;s&quot; % char |
                  &quot;t&quot; % char | &quot;u&quot; % char | &quot;v&quot; % char | &quot;w&quot; % char | &quot;x&quot; % char
                  | &quot;y&quot; % char | &quot;z&quot; % char | &quot;{&quot; % char | &quot;|&quot; % char |
                  &quot;}&quot; % char | &quot;~&quot; % char =&gt;
                  check_printable_ascii (Pervasives.op_minus i 1)
                | _ =&gt; false
                end in
            if check_printable_ascii (Pervasives.op_minus (String.length v) 1)
              then
              Error_monad.__return (v, ctxt)
            else
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail)
      | (Script_typed_ir.String_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Bytes_t _, Micheline.Bytes _ v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Typecheck_costs.__string_value (MBytes.length v))))
          (fun ctxt =&gt; Error_monad.__return (v, ctxt))
      | (Script_typed_ir.Bytes_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Int_t _, Micheline.Int _ v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)))
          (fun ctxt =&gt;
            Error_monad.__return ((Alpha_context.Script_int.of_zint v), ctxt))
      | (Script_typed_ir.Nat_t _, Micheline.Int _ v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)))
          (fun ctxt =&gt;
            let v := Alpha_context.Script_int.of_zint v in
            if
              Compare.Int.[Compare.S.op_gteq]
                (Alpha_context.Script_int.compare v
                  Alpha_context.Script_int.zero) 0 then
              Error_monad.__return ((Alpha_context.Script_int.abs v), ctxt)
            else
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail)
      | (Script_typed_ir.Int_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Nat_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Mutez_t _, Micheline.Int _ v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Error_monad.op_gtgtquestion
              (Alpha_context.Gas.consume ctxt Typecheck_costs.tez)
              (fun ctxt =&gt;
                Alpha_context.Gas.consume ctxt
                  Michelson_v1_gas.Cost_of.Legacy.z_to_int64)))
          (fun ctxt =&gt;
            (* ‚ùå Try-with are not handled *)
            try
              match Alpha_context.Tez.of_mutez (Z.to_int64 v) with
              | None =&gt; Pervasives.raise extensible_type_value
              | Some tez =&gt; Error_monad.__return (tez, ctxt)
              end)
      | (Script_typed_ir.Mutez_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Timestamp_t _, Micheline.Int _ v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Alpha_context.Script_timestamp.of_zint v), ctxt))
      | (Script_typed_ir.Timestamp_t _, Micheline.String _ s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.string_timestamp))
          (fun ctxt =&gt;
            match Alpha_context.Script_timestamp.of_string s with
            | Some v =&gt; Error_monad.__return (v, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Timestamp_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Key_t _, Micheline.Bytes _ __bytes_value) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key))
          (fun ctxt =&gt;
            match
              Data_encoding.Binary.of_bytes
                Signature.Public_key.[S.SPublic_key.encoding] __bytes_value with
            | Some k =&gt; Error_monad.__return (k, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_t _, Micheline.String _ s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key))
          (fun ctxt =&gt;
            match Signature.Public_key.[S.SPublic_key.of_b58check_opt] s with
            | Some k =&gt; Error_monad.__return (k, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Key_hash_t _, Micheline.Bytes _ __bytes_value) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash))
          (fun ctxt =&gt;
            match
              Data_encoding.Binary.of_bytes
                Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
                __bytes_value with
            | Some k =&gt; Error_monad.__return (k, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_hash_t _, Micheline.String _ s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash))
          (fun ctxt =&gt;
            match
              Signature.Public_key_hash.[S.SPublic_key_hash.of_b58check_opt] s
              with
            | Some k =&gt; Error_monad.__return (k, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_hash_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Signature_t _, Micheline.Bytes _ __bytes_value) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.signature))
          (fun ctxt =&gt;
            match Data_encoding.Binary.of_bytes Signature.encoding __bytes_value
              with
            | Some k =&gt; Error_monad.__return (k, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Signature_t _, Micheline.String _ s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.signature))
          (fun ctxt =&gt;
            match Signature.of_b58check_opt s with
            | Some s =&gt; Error_monad.__return (s, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Signature_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Operation_t _, _) =&gt;
        (* ‚ùå Assert instruction is not handled. *)
        assert false
      | (Script_typed_ir.Chain_id_t _, Micheline.Bytes _ __bytes_value) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id))
          (fun ctxt =&gt;
            match
              Data_encoding.Binary.of_bytes Chain_id.[S.HASH.encoding]
                __bytes_value with
            | Some k =&gt; Error_monad.__return (k, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Chain_id_t _, Micheline.String _ s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id))
          (fun ctxt =&gt;
            match Chain_id.[S.HASH.of_b58check_opt] s with
            | Some s =&gt; Error_monad.__return (s, ctxt)
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Chain_id_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Address_t _, Micheline.Bytes loc __bytes_value) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =&gt;
            match
              Data_encoding.Binary.of_bytes
                (Data_encoding.tup2 Alpha_context.Contract.encoding
                  Data_encoding.__Variable.__string_value) __bytes_value with
            | Some (c, entrypoint) =&gt;
              if Compare.Int.[Compare.S.op_gt] (String.length entrypoint) 31
                then
                Error_monad.fail extensible_type_value
              else
                Error_monad.op_gtgteqquestion
                  match entrypoint with
                  | &quot;&quot; % string =&gt; Error_monad.__return &quot;default&quot; % string
                  | &quot;default&quot; % string =&gt; Error_monad.fail extensible_type_value
                  | name =&gt; Error_monad.__return name
                  end
                  (fun entrypoint =&gt;
                    Error_monad.__return ((c, entrypoint), ctxt))
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Address_t _, Micheline.String loc s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion
              match String.index_opt s &quot;%&quot; % char with
              | None =&gt; Error_monad.__return (s, &quot;default&quot; % string)
              | Some pos =&gt;
                let len :=
                  Pervasives.op_minus
                    (Pervasives.op_minus (String.length s) pos) 1 in
                let name := String.sub s (Pervasives.op_plus pos 1) len in
                if Compare.Int.[Compare.S.op_gt] len 31 then
                  Error_monad.fail extensible_type_value
                else
                  match ((String.sub s 0 pos), name) with
                  | (_, &quot;default&quot; % string) =&gt;
                    traced (Error_monad.fail extensible_type_value)
                  | addr_and_name =&gt; Error_monad.__return addr_and_name
                  end
              end
              (fun function_parameter =&gt;
                let '(addr, entrypoint) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return (Alpha_context.Contract.of_b58check addr))
                  (fun c =&gt; Error_monad.__return ((c, entrypoint), ctxt))))
      | (Script_typed_ir.Address_t _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Contract_t ty _, Micheline.Bytes loc __bytes_value) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =&gt;
            match
              Data_encoding.Binary.of_bytes
                (Data_encoding.tup2 Alpha_context.Contract.encoding
                  Data_encoding.__Variable.__string_value) __bytes_value with
            | Some (c, entrypoint) =&gt;
              if Compare.Int.[Compare.S.op_gt] (String.length entrypoint) 31
                then
                Error_monad.fail extensible_type_value
              else
                Error_monad.op_gtgteqquestion
                  match entrypoint with
                  | &quot;&quot; % string =&gt; Error_monad.__return &quot;default&quot; % string
                  | &quot;default&quot; % string =&gt;
                    traced (Error_monad.fail extensible_type_value)
                  | name =&gt; Error_monad.__return name
                  end
                  (fun entrypoint =&gt;
                    Error_monad.op_gtgteqquestion
                      (traced (parse_contract legacy ctxt loc ty c entrypoint))
                      (fun function_parameter =&gt;
                        let '(ctxt, _) := function_parameter in
                        Error_monad.__return ((ty, (c, entrypoint)), ctxt)))
            | None =&gt;
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Contract_t ty _, Micheline.String loc s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion
              match String.index_opt s &quot;%&quot; % char with
              | None =&gt; Error_monad.__return (s, &quot;default&quot; % string)
              | Some pos =&gt;
                let len :=
                  Pervasives.op_minus
                    (Pervasives.op_minus (String.length s) pos) 1 in
                let name := String.sub s (Pervasives.op_plus pos 1) len in
                if Compare.Int.[Compare.S.op_gt] len 31 then
                  Error_monad.fail extensible_type_value
                else
                  match ((String.sub s 0 pos), name) with
                  | (_, &quot;default&quot; % string) =&gt;
                    traced (Error_monad.fail extensible_type_value)
                  | addr_and_name =&gt; Error_monad.__return addr_and_name
                  end
              end
              (fun function_parameter =&gt;
                let '(addr, entrypoint) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (traced
                    (Lwt.__return (Alpha_context.Contract.of_b58check addr)))
                  (fun c =&gt;
                    Error_monad.op_gtgteqquestion
                      (parse_contract legacy ctxt loc ty c entrypoint)
                      (fun function_parameter =&gt;
                        let '(ctxt, _) := function_parameter in
                        Error_monad.__return ((ty, (c, entrypoint)), ctxt)))))
      | (Script_typed_ir.Contract_t _ _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      |
        (Script_typed_ir.Pair_t (ta, _, _) (tb, _, _) _ _,
          Micheline.Prim loc Alpha_context.Script.D_Pair (cons va (cons vb []))
            annot) =&gt;
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.pair))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy ta va))
                  (fun function_parameter =&gt;
                    let '(va, ctxt) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (parse_data type_logger ctxt legacy tb vb)
                      (fun function_parameter =&gt;
                        let '(vb, ctxt) := function_parameter in
                        Error_monad.__return ((va, vb), ctxt)))))
      |
        (Script_typed_ir.Pair_t _ _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Pair l _) =&gt;
        Pervasives.op_atat Error_monad.fail extensible_type_value
      | (Script_typed_ir.Pair_t _ _ _ _, expr) =&gt;
        traced
          (Error_monad.fail
            (unexpected expr [] Script_tc_errors.Constant_namespace
              (cons Alpha_context.Script.D_Pair [])))
      |
        (Script_typed_ir.Union_t (tl, _) _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Left (cons v []) annot) =&gt;
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.union))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy tl v))
                  (fun function_parameter =&gt;
                    let '(v, ctxt) := function_parameter in
                    Error_monad.__return ((Script_typed_ir.L v), ctxt))))
      |
        (Script_typed_ir.Union_t _ _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Left l _) =&gt;
        Pervasives.op_atat Error_monad.fail extensible_type_value
      |
        (Script_typed_ir.Union_t _ (tr, _) _ _,
          Micheline.Prim loc Alpha_context.Script.D_Right (cons v []) annot) =&gt;
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.union))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy tr v))
                  (fun function_parameter =&gt;
                    let '(v, ctxt) := function_parameter in
                    Error_monad.__return ((Script_typed_ir.R v), ctxt))))
      |
        (Script_typed_ir.Union_t _ _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Right l _) =&gt;
        Pervasives.op_atat Error_monad.fail extensible_type_value
      | (Script_typed_ir.Union_t _ _ _ _, expr) =&gt;
        traced
          (Error_monad.fail
            (unexpected expr [] Script_tc_errors.Constant_namespace
              (cons Alpha_context.Script.D_Left
                (cons Alpha_context.Script.D_Right []))))
      |
        (Script_typed_ir.Lambda_t ta tr _ty_name,
          (Micheline.Seq _loc _) as script_instr) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.lambda))
          (fun ctxt =&gt;
            Pervasives.op_atat traced
              (parse_returning type_logger Lambda ctxt legacy
                (ta,
                  (Some
                    (* ‚ùå Variants not supported *)
                    (* ‚ùå `Var_annot *)
                    &quot;@arg&quot; % string)) tr script_instr))
      | (Script_typed_ir.Lambda_t _ _ _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      |
        (Script_typed_ir.Option_t t _ _,
          Micheline.Prim loc Alpha_context.Script.D_Some (cons v []) annot) =&gt;
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.some))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy t v))
                  (fun function_parameter =&gt;
                    let '(v, ctxt) := function_parameter in
                    Error_monad.__return ((Some v), ctxt))))
      |
        (Script_typed_ir.Option_t _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Some l _) =&gt;
        Pervasives.op_atat Error_monad.fail extensible_type_value
      |
        (Script_typed_ir.Option_t _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_None [] annot) =&gt;
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.none))
              (fun ctxt =&gt; Error_monad.__return (None, ctxt)))
      |
        (Script_typed_ir.Option_t _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_None l _) =&gt;
        Pervasives.op_atat Error_monad.fail extensible_type_value
      | (Script_typed_ir.Option_t _ _ _, expr) =&gt;
        traced
          (Error_monad.fail
            (unexpected expr [] Script_tc_errors.Constant_namespace
              (cons Alpha_context.Script.D_Some
                (cons Alpha_context.Script.D_None []))))
      | (Script_typed_ir.List_t t _ty_name _, Micheline.Seq _loc items) =&gt;
        Pervasives.op_atat traced
          (Error_monad.fold_right_s
            (fun v =&gt;
              fun function_parameter =&gt;
                let '(rest, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Typecheck_costs.list_element))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion
                      (parse_data type_logger ctxt legacy t v)
                      (fun function_parameter =&gt;
                        let '(v, ctxt) := function_parameter in
                        Error_monad.__return ((cons v rest), ctxt)))) items
            ([], ctxt))
      | (Script_typed_ir.List_t _ _ _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Set_t t _ty_name, (Micheline.Seq loc vs) as expr) =&gt;
        let length := List.length vs in
        Error_monad.op_gtgtpipequestion
          (Pervasives.op_atat traced
            (Error_monad.fold_left_s
              (fun function_parameter =&gt;
                let '(last_value, set, ctxt) := function_parameter in
                fun v =&gt;
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Typecheck_costs.set_element length)))
                    (fun ctxt =&gt;
                      Error_monad.op_gtgteqquestion
                        (parse_comparable_data type_logger ctxt t v)
                        (fun function_parameter =&gt;
                          let '(v, ctxt) := function_parameter in
                          Error_monad.op_gtgteqquestion
                            match last_value with
                            | Some value =&gt;
                              if
                                Compare.Int.[Compare.S.op_lteq] 0
                                  (compare_comparable t value v) then
                                if
                                  Compare.Int.[Compare.S.op_eq] 0
                                    (compare_comparable t value v) then
                                  Error_monad.fail extensible_type_value
                                else
                                  Error_monad.fail extensible_type_value
                              else
                                Error_monad.return_unit
                            | None =&gt; Error_monad.return_unit
                            end
                            (fun function_parameter =&gt;
                              let 'tt := function_parameter in
                              Error_monad.op_gtgteqquestion
                                (Lwt.__return
                                  (Alpha_context.Gas.consume ctxt
                                    (Michelson_v1_gas.Cost_of.Legacy.set_update
                                      v false set)))
                                (fun ctxt =&gt;
                                  Error_monad.__return
                                    ((Some v), (set_update v true set), ctxt))))))
              (None, (empty_set t), ctxt) vs))
          (fun function_parameter =&gt;
            let '(_, set, ctxt) := function_parameter in
            (set, ctxt))
      | (Script_typed_ir.Set_t _ _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Map_t tk tv _ty_name _, (Micheline.Seq loc vs) as expr)
        =&gt; parse_items type_logger loc ctxt expr tk tv vs (fun x =&gt; x)
      | (Script_typed_ir.Map_t _ _ _ _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      |
        (Script_typed_ir.Big_map_t tk tv _ty_name,
          (Micheline.Seq loc vs) as expr) =&gt;
        Error_monad.op_gtgtpipequestion
          (parse_items type_logger loc ctxt expr tk tv vs (fun x =&gt; Some x))
          (fun function_parameter =&gt;
            let '(diff, ctxt) := function_parameter in
            ({| Script_typed_ir.big_map.id := None;
              Script_typed_ir.big_map.diff := diff;
              Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
              Script_typed_ir.big_map.value_type := tv |}, ctxt))
      | (Script_typed_ir.Big_map_t tk tv _ty_name, Micheline.Int loc id) =&gt;
        Error_monad.op_gtgteqquestion (Alpha_context.Big_map.__exists ctxt id)
          (fun function_parameter =&gt;
            match function_parameter with
            | (_, None) =&gt; traced (Error_monad.fail extensible_type_value)
            | (ctxt, Some (btk, btv)) =&gt;
              Lwt.__return
                (Error_monad.op_gtgtquestion
                  (parse_comparable_ty ctxt (Micheline.root btk))
                  (fun function_parameter =&gt;
                    let '(Ex_comparable_ty btk, ctxt) := function_parameter in
                    Error_monad.op_gtgtquestion
                      (parse_packable_ty ctxt legacy (Micheline.root btv))
                      (fun function_parameter =&gt;
                        let '(Ex_ty btv, ctxt) := function_parameter in
                        Error_monad.op_gtgtquestion
                          (comparable_ty_eq ctxt tk btk)
                          (fun function_parameter =&gt;
                            let 'Eq := function_parameter in
                            Error_monad.op_gtgtquestion (ty_eq ctxt tv btv)
                              (fun function_parameter =&gt;
                                let '(Eq, ctxt) := function_parameter in
                                Error_monad.ok
                                  ({| Script_typed_ir.big_map.id := Some id;
                                    Script_typed_ir.big_map.diff := empty_map tk;
                                    Script_typed_ir.big_map.key_type :=
                                      ty_of_comparable_ty tk;
                                    Script_typed_ir.big_map.value_type := tv |},
                                    ctxt))))))
            end)
      | (Script_typed_ir.Big_map_t _tk _tv _, expr) =&gt;
        traced (Error_monad.fail extensible_type_value)
      end)

with parse_comparable_data {a : Set}
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (ty : Script_typed_ir.comparable_ty a)
  (script_data : Alpha_context.Script.node) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  parse_data type_logger ctxt false (ty_of_comparable_ty ty) script_data

with parse_returning {arg ret : Set}
  (type_logger : option type_logger) (tc_context : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (function_parameter :
    Script_typed_ir.ty arg * option Script_typed_ir.var_annot)
  {struct type_logger}
  : Script_typed_ir.ty ret -&gt; Alpha_context.Script.node -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Script_typed_ir.lambda arg ret * Alpha_context.context)) :=
  let '(arg, arg_annot) := function_parameter in
  fun ret =&gt;
    fun script_instr =&gt;
      Error_monad.op_gtgteqquestion
        (parse_instr type_logger tc_context ctxt legacy script_instr
          (Script_typed_ir.Item_t arg Script_typed_ir.Empty_t arg_annot))
        (fun function_parameter =&gt;
          match function_parameter with
          |
            (Typed
              ({|
                Script_typed_ir.descr.loc := loc;
                  Script_typed_ir.descr.aft :=
                    (Script_typed_ir.Item_t ty
                      Script_typed_ir.Empty_t _) as
                      stack_ty
                  |} as __descr_value), ctxt) =&gt;
            Error_monad.trace_eval
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return (serialize_ty_for_error ctxt ret))
                  (fun function_parameter =&gt;
                    let '(ret, ctxt) := function_parameter in
                    Error_monad.op_gtgtpipequestion
                      (serialize_stack_for_error ctxt stack_ty)
                      (fun function_parameter =&gt;
                        let '(stack_ty, _ctxt) := function_parameter in
                        extensible_type_value)))
              (Error_monad.op_gtgteqquestion (Lwt.__return (ty_eq ctxt ty ret))
                (fun function_parameter =&gt;
                  let '(Eq, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return (merge_types legacy ctxt loc ty ret))
                    (fun function_parameter =&gt;
                      let '(_ret, ctxt) := function_parameter in
                      Error_monad.__return
                        ((Script_typed_ir.Lam __descr_value script_instr), ctxt))))
          |
            (Typed {|
              Script_typed_ir.descr.loc := loc;
                Script_typed_ir.descr.aft := stack_ty
                |}, ctxt) =&gt;
            Error_monad.op_gtgteqquestion
              (Lwt.__return (serialize_ty_for_error ctxt ret))
              (fun function_parameter =&gt;
                let '(ret, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (serialize_stack_for_error ctxt stack_ty)
                  (fun function_parameter =&gt;
                    let '(stack_ty, _ctxt) := function_parameter in
                    Error_monad.fail extensible_type_value))
          | (Failed {| judgement.Failed.descr := __descr_value |}, ctxt) =&gt;
            Error_monad.__return
              ((Script_typed_ir.Lam
                (__descr_value
                  (Script_typed_ir.Item_t ret Script_typed_ir.Empty_t None))
                script_instr), ctxt)
          end)

with parse_int32
  (n : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  {struct n} : Error_monad.tzresult Z :=
  let error' (function_parameter : unit) : Error_monad.__error :=
    let 'tt := function_parameter in
    extensible_type_value in
  match n with
  | Micheline.Int _ n' =&gt;
    (* ‚ùå Try-with are not handled *)
    try
      (let n'' := Z.to_int n' in
      if
        Pervasives.op_andand (Compare.Int.[Compare.S.op_lteq] 0 n'')
          (Compare.Int.[Compare.S.op_lteq] n'' (Int32.to_int Int32.max_int))
        then
        Error_monad.ok n''
      else
        Pervasives.op_atat Error_monad.__error_value (error' tt))
  | _ =&gt; Pervasives.op_atat Error_monad.__error_value (error' tt)
  end

with parse_instr {bef : Set}
  (type_logger : option type_logger) (tc_context : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (script_instr : Alpha_context.Script.node)
  (stack_ty : Script_typed_ir.stack_ty bef) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
  let _check_item {B : Set}
    (check : Error_monad.tzresult B) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : Z) (m : Z)
    : Lwt.t (Error_monad.tzresult B) :=
    Pervasives.op_atat
      (Error_monad.trace_eval
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtpipequestion
            (serialize_stack_for_error ctxt stack_ty)
            (fun function_parameter =&gt;
              let '(stack_ty, _ctxt) := function_parameter in
              extensible_type_value)))
      (Pervasives.op_atat (Error_monad.trace extensible_type_value)
        (Lwt.__return check)) in
  let check_item_ty {B C : Set}
    (ctxt : Alpha_context.context) (exp : Script_typed_ir.ty B)
    (got : Script_typed_ir.ty C) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : Z) (m : Z)
    : Lwt.t
      (Error_monad.tzresult
        (eq B C * Script_typed_ir.ty B * Alpha_context.context)) :=
    Pervasives.op_atat
      (Error_monad.trace_eval
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtpipequestion
            (serialize_stack_for_error ctxt stack_ty)
            (fun function_parameter =&gt;
              let '(stack_ty, _ctxt) := function_parameter in
              extensible_type_value)))
      (Pervasives.op_atat (Error_monad.trace extensible_type_value)
        (Lwt.__return
          (Error_monad.op_gtgtquestion (ty_eq ctxt exp got)
            (fun function_parameter =&gt;
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (merge_types legacy ctxt loc exp got)
                (fun function_parameter =&gt;
                  let '(ty, ctxt) := function_parameter in
                  Error_monad.ok (Eq, ty, ctxt)))))) in
  let check_item_comparable_ty {B C : Set}
    (exp : Script_typed_ir.comparable_ty B)
    (got : Script_typed_ir.comparable_ty C)
    (loc : Alpha_context.Script.location) (name : Alpha_context.Script.prim)
    (n : Z) (m : Z)
    : Lwt.t (Error_monad.tzresult (eq B C * Script_typed_ir.comparable_ty B)) :=
    Pervasives.op_atat
      (Error_monad.trace_eval
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgtpipequestion
            (serialize_stack_for_error ctxt stack_ty)
            (fun function_parameter =&gt;
              let '(stack_ty, _ctxt) := function_parameter in
              extensible_type_value)))
      (Pervasives.op_atat (Error_monad.trace extensible_type_value)
        (Lwt.__return
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt exp got)
            (fun function_parameter =&gt;
              let 'Eq := function_parameter in
              Error_monad.op_gtgtquestion
                (merge_comparable_types legacy exp got)
                (fun ty =&gt; Error_monad.ok (Eq, ty)))))) in
  let log_stack {B C : Set}
    (ctxt : Alpha_context.context) (loc : Z)
    (stack_ty : Script_typed_ir.stack_ty B) (aft : Script_typed_ir.stack_ty C)
    : Lwt.t (Error_monad.tzresult unit) :=
    match (type_logger, script_instr) with
    |
      (None, _) |
      (Some _,
        Micheline.Seq (-1) _ | Micheline.Int _ _ | Micheline.String _ _ |
        Micheline.Bytes _ _) =&gt; Error_monad.return_unit
    | (Some log, Micheline.Prim _ _ _ _ | Micheline.Seq _ _) =&gt;
      let ctxt := Alpha_context.Gas.set_unlimited ctxt in
      Error_monad.op_gtgteqquestion (unparse_stack ctxt stack_ty)
        (fun function_parameter =&gt;
          let '(stack_ty, _) := function_parameter in
          Error_monad.op_gtgteqquestion (unparse_stack ctxt aft)
            (fun function_parameter =&gt;
              let '(aft, _) := function_parameter in
              (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
              (* ‚ùå instruction_sequence &quot;;&quot; *)
              Error_monad.return_unit))
    end in
  let outer_return := Error_monad.__return in
  let __return (ctxt : Alpha_context.context) (judgement : judgement bef)
    : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
    match judgement with
    |
      Typed {|
        Script_typed_ir.descr.loc := loc;
          Script_typed_ir.descr.aft := aft;
          Script_typed_ir.descr.instr := instr
          |} =&gt;
      let maximum_type_size :=
        Alpha_context.Constants.michelson_maximum_type_size ctxt in
      let type_size :=
        type_size_of_stack_head aft (number_of_generated_growing_types instr) in
      if Compare.Int.[Compare.S.op_gt] type_size maximum_type_size then
        Error_monad.fail extensible_type_value
      else
        Error_monad.__return (judgement, ctxt)
    | Failed _ =&gt; Error_monad.__return (judgement, ctxt)
    end in
  let typed {B : Set}
    (ctxt : Alpha_context.context) (loc : Z)
    (instr : Script_typed_ir.instr bef B) (aft : Script_typed_ir.stack_ty B)
    : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
    Error_monad.op_gtgteqquestion (log_stack ctxt loc stack_ty aft)
      (fun function_parameter =&gt;
        let 'tt := function_parameter in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return
            (Alpha_context.Gas.consume ctxt (Typecheck_costs.instr instr)))
          (fun ctxt =&gt;
            __return ctxt
              (Typed
                {| Script_typed_ir.descr.loc := loc;
                  Script_typed_ir.descr.bef := stack_ty;
                  Script_typed_ir.descr.aft := aft;
                  Script_typed_ir.descr.instr := instr |}))) in
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
    (fun ctxt =&gt;
      match
        ((script_instr, stack_ty),
          match (script_instr, stack_ty) with
          |
            (Micheline.Prim loc Alpha_context.Script.I_DIP
              (cons n (cons code [])) result_annot, stack) =&gt;
            match parse_int32 n with
            | Pervasives.Ok _ =&gt; true
            | Pervasives.Error _ =&gt; false
            end
          | _ =&gt; false
          end) with
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DROP [] annot,
          Script_typed_ir.Item_t _ rest _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            typed ctxt loc Script_typed_ir.Drop rest)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DROP (cons n [])
          result_annot, whole_stack), _) =&gt;
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun whole_n =&gt;
            let fix make_proof_argument {tstk : Set}
              (n : Z) (stk : Script_typed_ir.stack_ty tstk) {struct n}
              : Lwt.t (Error_monad.tzresult (dropn_proof_argument tstk)) :=
              match ((Compare.Int.[Compare.S.op_eq] n 0), stk) with
              | (true, rest) =&gt;
                Pervasives.op_atat outer_return
                  (Dropn_proof_argument (Script_typed_ir.Rest, rest, rest))
              | (false, Script_typed_ir.Item_t v rest annot) =&gt;
                Error_monad.op_gtgteqquestion
                  (make_proof_argument (Pervasives.op_minus n 1) rest)
                  (fun function_parameter =&gt;
                    let 'Dropn_proof_argument (n', stack_after_drops, aft') :=
                      function_parameter in
                    Pervasives.op_atat outer_return
                      (Dropn_proof_argument
                        ((Script_typed_ir.Prefix n'), stack_after_drops,
                          (Script_typed_ir.Item_t v aft' annot))))
              | (_, _) =&gt;
                Error_monad.op_gtgteqquestion
                  (serialize_stack_for_error ctxt whole_stack)
                  (fun function_parameter =&gt;
                    let '(whole_stack, _ctxt) := function_parameter in
                    Error_monad.fail extensible_type_value)
              end in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument whole_n whole_stack)
                  (fun function_parameter =&gt;
                    let 'Dropn_proof_argument (n', stack_after_drops, _aft) :=
                      function_parameter in
                    typed ctxt loc (Script_typed_ir.Dropn whole_n n')
                      stack_after_drops)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DROP
          ((cons _ (cons _ _)) as l) _, _), _) =&gt;
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUP [] annot,
          Script_typed_ir.Item_t v rest stack_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some stack_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Dup
              (Script_typed_ir.Item_t v
                (Script_typed_ir.Item_t v rest stack_annot) annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIG (cons n []) result_annot,
          stack), _) =&gt;
        let fix make_proof_argument {tstk : Set}
          (n : Z) (stk : Script_typed_ir.stack_ty tstk) {struct n}
          : Lwt.t (Error_monad.tzresult (dig_proof_argument tstk)) :=
          match ((Compare.Int.[Compare.S.op_eq] n 0), stk) with
          | (true, Script_typed_ir.Item_t v rest annot) =&gt;
            Pervasives.op_atat outer_return
              (Dig_proof_argument (Script_typed_ir.Rest, (v, annot), rest))
          | (false, Script_typed_ir.Item_t v rest annot) =&gt;
            Error_monad.op_gtgteqquestion
              (make_proof_argument (Pervasives.op_minus n 1) rest)
              (fun function_parameter =&gt;
                let 'Dig_proof_argument (n', (x, xv), aft') :=
                  function_parameter in
                Pervasives.op_atat outer_return
                  (Dig_proof_argument
                    ((Script_typed_ir.Prefix n'), (x, xv),
                      (Script_typed_ir.Item_t v aft' annot))))
          | (_, _) =&gt;
            Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
              (fun function_parameter =&gt;
                let '(whole_stack, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value)
          end in
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun n =&gt;
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion (make_proof_argument n stack)
                  (fun function_parameter =&gt;
                    let 'Dig_proof_argument (n', (x, stack_annot), aft) :=
                      function_parameter in
                    typed ctxt loc (Script_typed_ir.Dig n n')
                      (Script_typed_ir.Item_t x aft stack_annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIG
          (([] | cons _ (cons _ _)) as l) _, _), _) =&gt;
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons n []) result_annot,
          Script_typed_ir.Item_t x whole_stack stack_annot), _) =&gt;
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun whole_n =&gt;
            let fix make_proof_argument {tstk x : Set}
              (n : Z) (x : Script_typed_ir.ty x)
              (stack_annot : option Script_typed_ir.var_annot)
              (stk : Script_typed_ir.stack_ty tstk) {struct n}
              : Lwt.t (Error_monad.tzresult (dug_proof_argument tstk x)) :=
              match ((Compare.Int.[Compare.S.op_eq] n 0), stk) with
              | (true, rest) =&gt;
                Pervasives.op_atat outer_return
                  (Dug_proof_argument
                    (Script_typed_ir.Rest, tt,
                      (Script_typed_ir.Item_t x rest stack_annot)))
              | (false, Script_typed_ir.Item_t v rest annot) =&gt;
                Error_monad.op_gtgteqquestion
                  (make_proof_argument (Pervasives.op_minus n 1) x stack_annot
                    rest)
                  (fun function_parameter =&gt;
                    let 'Dug_proof_argument (n', tt, aft') := function_parameter
                      in
                    Pervasives.op_atat outer_return
                      (Dug_proof_argument
                        ((Script_typed_ir.Prefix n'), tt,
                          (Script_typed_ir.Item_t v aft' annot))))
              | (_, _) =&gt;
                Error_monad.op_gtgteqquestion
                  (serialize_stack_for_error ctxt whole_stack)
                  (fun function_parameter =&gt;
                    let '(whole_stack, _ctxt) := function_parameter in
                    Error_monad.fail extensible_type_value)
              end in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument whole_n x stack_annot whole_stack)
                  (fun function_parameter =&gt;
                    let 'Dug_proof_argument (n', tt, aft) := function_parameter
                      in
                    typed ctxt loc (Script_typed_ir.Dug whole_n n') aft)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons _ []) result_annot,
          Script_typed_ir.Empty_t as stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc result_annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
              (fun function_parameter =&gt;
                let '(stack, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUG
          (([] | cons _ (cons _ _)) as l) _, _), _) =&gt;
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SWAP [] annot,
          Script_typed_ir.Item_t v (Script_typed_ir.Item_t w rest stack_annot)
            cur_top_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            typed ctxt loc Script_typed_ir.Swap
              (Script_typed_ir.Item_t w
                (Script_typed_ir.Item_t v rest cur_top_annot) stack_annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_PUSH (cons t (cons d []))
          annot, stack), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (parse_packable_ty ctxt legacy t))
              (fun function_parameter =&gt;
                let '(Ex_ty t, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_data type_logger ctxt legacy t d)
                  (fun function_parameter =&gt;
                    let '(v, ctxt) := function_parameter in
                    typed ctxt loc (Script_typed_ir.Const v)
                      (Script_typed_ir.Item_t t stack annot))))
      | ((Micheline.Prim loc Alpha_context.Script.I_UNIT [] annot, stack), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =&gt;
            let '(annot, ty_name) := function_parameter in
            typed ctxt loc (Script_typed_ir.Const tt)
              (Script_typed_ir.Item_t (Script_typed_ir.Unit_t ty_name) stack
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SOME [] annot,
          Script_typed_ir.Item_t t rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =&gt;
            let '(annot, ty_name) := function_parameter in
            typed ctxt loc Script_typed_ir.Cons_some
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t t ty_name (has_big_map t)) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NONE (cons t []) annot,
          stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy t))
          (fun function_parameter =&gt;
            let '(Ex_ty t, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =&gt;
                let '(annot, ty_name) := function_parameter in
                typed ctxt loc (Script_typed_ir.Cons_none t)
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t t ty_name (has_big_map t)) stack
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF_NONE
          (cons bt (cons bf [])) annot,
          (Script_typed_ir.Item_t (Script_typed_ir.Option_t t _ _) rest
            option_annot) as bef), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) bt)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind (cons Script_tc_errors.Seq_kind []) bf)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =&gt;
                    let 'tt := function_parameter in
                    let annot :=
                      Script_ir_annot.gen_access_annot option_annot None
                        Script_ir_annot.default_some_annot in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt rest)
                      (fun function_parameter =&gt;
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            (Script_typed_ir.Item_t t rest annot))
                          (fun function_parameter =&gt;
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt : Script_typed_ir.descr op_dollar57 B)
                              (ibf :
                                Script_typed_ir.descr
                                  (op_dollar58 * op_dollar57) B)
                              : Script_typed_ir.descr
                                (option op_dollar58 * op_dollar57) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  Script_typed_ir.descr.aft ibt;
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If_none ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =&gt;
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_PAIR [] annot,
          Script_typed_ir.Item_t a (Script_typed_ir.Item_t b rest snd_annot)
            fst_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_constr_annot loc
            (Some (Script_ir_annot.var_to_field_annot fst_annot))
            (Some (Script_ir_annot.var_to_field_annot snd_annot)) annot)
          (fun function_parameter =&gt;
            let '(annot, ty_name, l_field, r_field) := function_parameter in
            typed ctxt loc Script_typed_ir.Cons_pair
              (Script_typed_ir.Item_t
                (Script_typed_ir.Pair_t (a, l_field, fst_annot)
                  (b, r_field, snd_annot) ty_name
                  (Pervasives.op_pipepipe (has_big_map a) (has_big_map b))) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CAR [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Pair_t (a, expected_field_annot, a_annot) _ _ _)
            rest pair_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_destr_annot loc annot Script_ir_annot.default_car_annot
            expected_field_annot pair_annot a_annot)
          (fun function_parameter =&gt;
            let '(annot, field_annot) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.check_correct_field field_annot
                  expected_field_annot))
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                typed ctxt loc Script_typed_ir.Car
                  (Script_typed_ir.Item_t a rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CDR [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Pair_t _ (b, expected_field_annot, b_annot) _ _)
            rest pair_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_destr_annot loc annot Script_ir_annot.default_cdr_annot
            expected_field_annot pair_annot b_annot)
          (fun function_parameter =&gt;
            let '(annot, field_annot) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.check_correct_field field_annot
                  expected_field_annot))
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                typed ctxt loc Script_typed_ir.Cdr
                  (Script_typed_ir.Item_t b rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LEFT (cons tr []) annot,
          Script_typed_ir.Item_t tl rest stack_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy tr))
          (fun function_parameter =&gt;
            let '(Ex_ty tr, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (parse_constr_annot loc
                (Some (Script_ir_annot.var_to_field_annot stack_annot)) None
                annot)
              (fun function_parameter =&gt;
                let '(annot, tname, l_field, r_field) := function_parameter in
                typed ctxt loc Script_typed_ir.Left
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
                      (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))
                    rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_RIGHT (cons tl []) annot,
          Script_typed_ir.Item_t tr rest stack_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy tl))
          (fun function_parameter =&gt;
            let '(Ex_ty tl, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (parse_constr_annot loc None
                (Some (Script_ir_annot.var_to_field_annot stack_annot)) annot)
              (fun function_parameter =&gt;
                let '(annot, tname, l_field, r_field) := function_parameter in
                typed ctxt loc Script_typed_ir.Right
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
                      (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))
                    rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF_LEFT
          (cons bt (cons bf [])) annot,
          (Script_typed_ir.Item_t
            (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) _ _) rest
            union_annot) as bef), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) bt)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind (cons Script_tc_errors.Seq_kind []) bf)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =&gt;
                    let 'tt := function_parameter in
                    let left_annot :=
                      Script_ir_annot.gen_access_annot union_annot
                        (Some Script_ir_annot.default_left_annot) l_field in
                    let right_annot :=
                      Script_ir_annot.gen_access_annot union_annot
                        (Some Script_ir_annot.default_right_annot) r_field in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt
                        (Script_typed_ir.Item_t tl rest left_annot))
                      (fun function_parameter =&gt;
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            (Script_typed_ir.Item_t tr rest right_annot))
                          (fun function_parameter =&gt;
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt :
                                Script_typed_ir.descr
                                  (op_dollar77 * op_dollar76) B)
                              (ibf :
                                Script_typed_ir.descr
                                  (op_dollar78 * op_dollar76) B)
                              : Script_typed_ir.descr
                                (Script_typed_ir.union op_dollar77 op_dollar78 *
                                  op_dollar76) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  Script_typed_ir.descr.aft ibt;
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If_left ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =&gt;
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NIL (cons t []) annot, stack),
          _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy t))
          (fun function_parameter =&gt;
            let '(Ex_ty t, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =&gt;
                let '(annot, ty_name) := function_parameter in
                typed ctxt loc Script_typed_ir.Nil
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.List_t t ty_name (has_big_map t)) stack
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONS [] annot,
          Script_typed_ir.Item_t tv
            (Script_typed_ir.Item_t
              (Script_typed_ir.List_t t ty_name has_big_map) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt tv t loc Alpha_context.Script.I_CONS 1 2)
          (fun function_parameter =&gt;
            let '(Eq, t, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                typed ctxt loc Script_typed_ir.Cons_list
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.List_t t ty_name has_big_map) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF_CONS
          (cons bt (cons bf [])) annot,
          (Script_typed_ir.Item_t (Script_typed_ir.List_t t ty_name has_big_map)
            rest list_annot) as bef), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) bt)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind (cons Script_tc_errors.Seq_kind []) bf)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =&gt;
                    let 'tt := function_parameter in
                    let hd_annot :=
                      Script_ir_annot.gen_access_annot list_annot None
                        Script_ir_annot.default_hd_annot in
                    let tl_annot :=
                      Script_ir_annot.gen_access_annot list_annot None
                        Script_ir_annot.default_tl_annot in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt
                        (Script_typed_ir.Item_t t
                          (Script_typed_ir.Item_t
                            (Script_typed_ir.List_t t ty_name has_big_map) rest
                            tl_annot) hd_annot))
                      (fun function_parameter =&gt;
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            rest)
                          (fun function_parameter =&gt;
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt :
                                Script_typed_ir.descr
                                  (op_dollar86 *
                                    (list op_dollar86 * op_dollar85)) B)
                              (ibf : Script_typed_ir.descr op_dollar85 B)
                              : Script_typed_ir.descr
                                (list op_dollar86 * op_dollar85) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  Script_typed_ir.descr.aft ibt;
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If_cons ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =&gt;
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.List_t _ _ _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =&gt;
            let '(annot, tname) := function_parameter in
            typed ctxt loc Script_typed_ir.List_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.List_t elt _ _) starting_rest
            list_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) body)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =&gt;
                let '(ret_annot, list_ty_name) := function_parameter in
                let elt_annot :=
                  Script_ir_annot.gen_access_annot list_annot None
                    Script_ir_annot.default_elt_annot in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t elt starting_rest elt_annot))
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    |
                      Typed
                        ({|
                          Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _
                            |} as ibody) =&gt;
                      let invalid_map_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let 'tt := function_parameter in
                        Error_monad.op_gtgtpipequestion
                          (serialize_stack_for_error ctxt
                            (Script_typed_ir.descr.aft ibody))
                          (fun function_parameter =&gt;
                            let '(aft, _ctxt) := function_parameter in
                            extensible_type_value) in
                      Error_monad.trace_eval invalid_map_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 rest starting_rest))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt rest starting_rest))
                              (fun function_parameter =&gt;
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.List_map ibody)
                                  (Script_typed_ir.Item_t
                                    (Script_typed_ir.List_t ret list_ty_name
                                      (has_big_map ret)) rest ret_annot))))
                    | Typed {| Script_typed_ir.descr.aft := aft |} =&gt;
                      Error_monad.op_gtgteqquestion
                        (serialize_stack_for_error ctxt aft)
                        (fun function_parameter =&gt;
                          let '(aft, _ctxt) := function_parameter in
                          Error_monad.fail extensible_type_value)
                    | Failed _ =&gt; Error_monad.fail extensible_type_value
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.List_t elt _ _) rest
            list_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) body)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                let elt_annot :=
                  Script_ir_annot.gen_access_annot list_annot None
                    Script_ir_annot.default_elt_annot in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t elt rest elt_annot))
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =&gt;
                      let invalid_iter_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let 'tt := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            (Script_typed_ir.descr.aft ibody))
                          (fun function_parameter =&gt;
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt rest)
                              (fun function_parameter =&gt;
                                let '(rest, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval invalid_iter_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 aft rest))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt aft rest))
                              (fun function_parameter =&gt;
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.List_iter ibody)
                                  rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
                      typed ctxt loc
                        (Script_typed_ir.List_iter (__descr_value rest)) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_SET (cons t []) annot,
          rest), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_comparable_ty ctxt t))
          (fun function_parameter =&gt;
            let '(Ex_comparable_ty t, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =&gt;
                let '(annot, tname) := function_parameter in
                typed ctxt loc (Script_typed_ir.Empty_set t)
                  (Script_typed_ir.Item_t (Script_typed_ir.Set_t t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Set_t comp_elt _) rest
            set_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) body)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                let elt_annot :=
                  Script_ir_annot.gen_access_annot set_annot None
                    Script_ir_annot.default_elt_annot in
                let elt := ty_of_comparable_ty comp_elt in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t elt rest elt_annot))
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =&gt;
                      let invalid_iter_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let 'tt := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            (Script_typed_ir.descr.aft ibody))
                          (fun function_parameter =&gt;
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt rest)
                              (fun function_parameter =&gt;
                                let '(rest, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval invalid_iter_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 aft rest))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt aft rest))
                              (fun function_parameter =&gt;
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Set_iter ibody)
                                  rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
                      typed ctxt loc
                        (Script_typed_ir.Set_iter (__descr_value rest)) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
          Script_typed_ir.Item_t v
            (Script_typed_ir.Item_t (Script_typed_ir.Set_t elt _) rest _) _), _)
        =&gt;
        let elt := ty_of_comparable_ty elt in
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =&gt;
            let '(annot, tname) := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt elt v loc Alpha_context.Script.I_MEM 1 2)
              (fun function_parameter =&gt;
                let '(Eq, _, ctxt) := function_parameter in
                typed ctxt loc Script_typed_ir.Set_mem
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
          Script_typed_ir.Item_t v
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Set_t elt tname) rest
                set_annot) _) _), _) =&gt;
        match comparable_ty_of_ty v with
        | None =&gt;
          Error_monad.op_gtgteqquestion (unparse_ty ctxt v)
            (fun function_parameter =&gt;
              let '(v, _ctxt) := function_parameter in
              Error_monad.fail extensible_type_value)
        | Some v =&gt;
          Error_monad.op_gtgteqquestion
            (parse_var_annot loc (Some set_annot) annot)
            (fun annot =&gt;
              Error_monad.op_gtgteqquestion
                (check_item_comparable_ty elt v loc
                  Alpha_context.Script.I_UPDATE 1 3)
                (fun function_parameter =&gt;
                  let '(Eq, elt) := function_parameter in
                  typed ctxt loc Script_typed_ir.Set_update
                    (Script_typed_ir.Item_t (Script_typed_ir.Set_t elt tname)
                      rest annot)))
        end
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Set_t _ _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Set_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_MAP
          (cons tk (cons tv [])) annot, stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_comparable_ty ctxt tk))
          (fun function_parameter =&gt;
            let '(Ex_comparable_ty tk, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy tv))
              (fun function_parameter =&gt;
                let '(Ex_ty tv, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
                  (fun function_parameter =&gt;
                    let '(annot, ty_name) := function_parameter in
                    typed ctxt loc (Script_typed_ir.Empty_map tk tv)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Map_t tk tv ty_name (has_big_map tv))
                        stack annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Map_t ck elt _ _)
            starting_rest _map_annot), _) =&gt;
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) body)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =&gt;
                let '(ret_annot, ty_name) := function_parameter in
                let k_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_key_annot in
                let e_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_elt_annot in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t
                      (Script_typed_ir.Pair_t (k, None, k_name)
                        (elt, None, e_name) None (has_big_map elt))
                      starting_rest None))
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    |
                      Typed
                        ({|
                          Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _
                            |} as ibody) =&gt;
                      let invalid_map_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let 'tt := function_parameter in
                        Error_monad.op_gtgtpipequestion
                          (serialize_stack_for_error ctxt
                            (Script_typed_ir.descr.aft ibody))
                          (fun function_parameter =&gt;
                            let '(aft, _ctxt) := function_parameter in
                            extensible_type_value) in
                      Error_monad.trace_eval invalid_map_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 rest starting_rest))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt rest starting_rest))
                              (fun function_parameter =&gt;
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Map_map ibody)
                                  (Script_typed_ir.Item_t
                                    (Script_typed_ir.Map_t ck ret ty_name
                                      (has_big_map ret)) rest ret_annot))))
                    | Typed {| Script_typed_ir.descr.aft := aft |} =&gt;
                      Error_monad.op_gtgteqquestion
                        (serialize_stack_for_error ctxt aft)
                        (fun function_parameter =&gt;
                          let '(aft, _ctxt) := function_parameter in
                          Error_monad.fail extensible_type_value)
                    | Failed _ =&gt; Error_monad.fail extensible_type_value
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Map_t comp_elt element_ty _ _)
            rest _map_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) body)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                let k_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_key_annot in
                let e_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_elt_annot in
                let key := ty_of_comparable_ty comp_elt in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t
                      (Script_typed_ir.Pair_t (key, None, k_name)
                        (element_ty, None, e_name) None (has_big_map element_ty))
                      rest None))
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =&gt;
                      let invalid_iter_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let 'tt := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            (Script_typed_ir.descr.aft ibody))
                          (fun function_parameter =&gt;
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt rest)
                              (fun function_parameter =&gt;
                                let '(rest, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval invalid_iter_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 aft rest))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt aft rest))
                              (fun function_parameter =&gt;
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Map_iter ibody)
                                  rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
                      typed ctxt loc
                        (Script_typed_ir.Map_iter (__descr_value rest)) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck _ _ _) rest _) _),
          _) =&gt;
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_MEM 1 2)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                typed ctxt loc Script_typed_ir.Map_mem
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck elt _ has_big_map)
              rest _) _), _) =&gt;
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                typed ctxt loc Script_typed_ir.Map_get
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t elt None has_big_map) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Option_t vv _ _)
              (Script_typed_ir.Item_t
                (Script_typed_ir.Map_t ck v map_name has_big_map) rest map_annot)
              _) _), _) =&gt;
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_UPDATE 1 3)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt vv v loc Alpha_context.Script.I_UPDATE 2 3)
              (fun function_parameter =&gt;
                let '(Eq, v, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_var_annot loc (Some map_annot) annot)
                  (fun annot =&gt;
                    typed ctxt loc Script_typed_ir.Map_update
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Map_t ck v map_name has_big_map) rest
                        annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Map_t _ _ _ _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Map_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_BIG_MAP
          (cons tk (cons tv [])) annot, stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_comparable_ty ctxt tk))
          (fun function_parameter =&gt;
            let '(Ex_comparable_ty tk, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (parse_packable_ty ctxt legacy tv))
              (fun function_parameter =&gt;
                let '(Ex_ty tv, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
                  (fun function_parameter =&gt;
                    let '(annot, ty_name) := function_parameter in
                    typed ctxt loc (Script_typed_ir.Empty_big_map tk tv)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Big_map_t tk tv ty_name) stack annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
          Script_typed_ir.Item_t set_key
            (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t map_key _ _) rest
              _) _), _) =&gt;
        let k := ty_of_comparable_ty map_key in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt set_key k loc Alpha_context.Script.I_MEM 1 2)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                typed ctxt loc Script_typed_ir.Big_map_mem
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t ck elt _) rest _)
            _), _) =&gt;
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                typed ctxt loc Script_typed_ir.Big_map_get
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t elt None (has_big_map elt)) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
          Script_typed_ir.Item_t set_key
            (Script_typed_ir.Item_t (Script_typed_ir.Option_t set_value _ _)
              (Script_typed_ir.Item_t
                (Script_typed_ir.Big_map_t map_key map_value map_name) rest
                map_annot) _) _), _) =&gt;
        let k := ty_of_comparable_ty map_key in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt set_key k loc Alpha_context.Script.I_UPDATE 1 3)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt set_value map_value loc
                Alpha_context.Script.I_UPDATE 2 3)
              (fun function_parameter =&gt;
                let '(Eq, map_value, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_var_annot loc (Some map_annot) annot)
                  (fun annot =&gt;
                    typed ctxt loc Script_typed_ir.Big_map_update
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Big_map_t map_key map_value map_name)
                        rest annot))))
      | ((Micheline.Seq loc [], stack), _) =&gt;
        typed ctxt loc Script_typed_ir.Nop stack
      | ((Micheline.Seq loc (cons single []), stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_instr type_logger tc_context ctxt legacy single stack)
          (fun function_parameter =&gt;
            let '(judgement, ctxt) := function_parameter in
            match judgement with
            | Typed ({| Script_typed_ir.descr.aft := aft |} as instr) =&gt;
              let nop :=
                {| Script_typed_ir.descr.loc := loc;
                  Script_typed_ir.descr.bef := aft;
                  Script_typed_ir.descr.aft := aft;
                  Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
              typed ctxt loc (Script_typed_ir.Seq instr nop) aft
            | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
              let __descr_value {B : Set} (aft : Script_typed_ir.stack_ty B)
                : Script_typed_ir.descr bef B :=
                let nop :=
                  {| Script_typed_ir.descr.loc := loc;
                    Script_typed_ir.descr.bef := aft;
                    Script_typed_ir.descr.aft := aft;
                    Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
                let __descr_value := __descr_value aft in
                (* ‚ùå Record substitution not handled *)
                record_substitution in
              __return ctxt
                (Failed {| judgement.Failed.descr := __descr_value |})
            end)
      | ((Micheline.Seq loc (cons hd tl), stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_instr type_logger tc_context ctxt legacy hd stack)
          (fun function_parameter =&gt;
            let '(judgement, ctxt) := function_parameter in
            match judgement with
            | Failed _ =&gt; Error_monad.fail extensible_type_value
            | Typed ({| Script_typed_ir.descr.aft := middle |} as ihd) =&gt;
              Error_monad.op_gtgteqquestion
                (parse_instr type_logger tc_context ctxt legacy
                  (Micheline.Seq (-1) tl) middle)
                (fun function_parameter =&gt;
                  let '(judgement, ctxt) := function_parameter in
                  match judgement with
                  | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
                    let __descr_value {B : Set}
                      (ret : Script_typed_ir.stack_ty B)
                      : Script_typed_ir.descr bef B :=
                      {| Script_typed_ir.descr.loc := loc;
                        Script_typed_ir.descr.bef := stack;
                        Script_typed_ir.descr.aft := ret;
                        Script_typed_ir.descr.instr :=
                          Script_typed_ir.Seq ihd (__descr_value ret) |} in
                    __return ctxt
                      (Failed {| judgement.Failed.descr := __descr_value |})
                  | Typed itl =&gt;
                    typed ctxt loc (Script_typed_ir.Seq ihd itl)
                      (Script_typed_ir.descr.aft itl)
                  end)
            end)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF (cons bt (cons bf []))
          annot,
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _) as bef), _)
        =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) bt)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind (cons Script_tc_errors.Seq_kind []) bf)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =&gt;
                    let 'tt := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt rest)
                      (fun function_parameter =&gt;
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            rest)
                          (fun function_parameter =&gt;
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt : Script_typed_ir.descr op_dollar169 B)
                              (ibf : Script_typed_ir.descr op_dollar169 B)
                              : Script_typed_ir.descr (bool * op_dollar169) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  Script_typed_ir.descr.aft ibt;
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =&gt;
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LOOP (cons body []) annot,
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _stack_annot)
            as stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) body)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body rest)
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ibody =&gt;
                      let unmatched_branches (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let 'tt := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            (Script_typed_ir.descr.aft ibody))
                          (fun function_parameter =&gt;
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt stack)
                              (fun function_parameter =&gt;
                                let '(stack, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval unmatched_branches
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1
                              (Script_typed_ir.descr.aft ibody) stack))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt
                                  (Script_typed_ir.descr.aft ibody) stack))
                              (fun function_parameter =&gt;
                                let '(_stack, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Loop ibody) rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
                      let ibody := __descr_value stack in
                      typed ctxt loc (Script_typed_ir.Loop ibody) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LOOP_LEFT (cons body [])
          annot,
          (Script_typed_ir.Item_t
            (Script_typed_ir.Union_t (tl, l_field) (tr, _) _ _) rest union_annot)
            as stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_kind (cons Script_tc_errors.Seq_kind []) body)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                let l_annot :=
                  Script_ir_annot.gen_access_annot union_annot
                    (Some Script_ir_annot.default_left_annot) l_field in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t tl rest l_annot))
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ibody =&gt;
                      let unmatched_branches (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let 'tt := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            (Script_typed_ir.descr.aft ibody))
                          (fun function_parameter =&gt;
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt stack)
                              (fun function_parameter =&gt;
                                let '(stack, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval unmatched_branches
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1
                              (Script_typed_ir.descr.aft ibody) stack))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt
                                  (Script_typed_ir.descr.aft ibody) stack))
                              (fun function_parameter =&gt;
                                let '(_stack, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Loop_left ibody)
                                  (Script_typed_ir.Item_t tr rest annot))))
                    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
                      let ibody := __descr_value stack in
                      typed ctxt loc (Script_typed_ir.Loop_left ibody)
                        (Script_typed_ir.Item_t tr rest annot)
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
          (cons arg (cons ret (cons code []))) annot, stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy arg))
          (fun function_parameter =&gt;
            let '(Ex_ty arg, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy ret))
              (fun function_parameter =&gt;
                let '(Ex_ty ret, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (check_kind (cons Script_tc_errors.Seq_kind []) code)
                  (fun function_parameter =&gt;
                    let 'tt := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (parse_var_annot loc None annot)
                      (fun annot =&gt;
                        Error_monad.op_gtgteqquestion
                          (parse_returning type_logger Lambda ctxt legacy
                            (arg, Script_ir_annot.default_arg_annot) ret code)
                          (fun function_parameter =&gt;
                            let '(lambda, ctxt) := function_parameter in
                            typed ctxt loc (Script_typed_ir.Lambda lambda)
                              (Script_typed_ir.Item_t
                                (Script_typed_ir.Lambda_t arg ret None) stack
                                annot))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EXEC [] annot,
          Script_typed_ir.Item_t arg
            (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t param ret _) rest
              _) _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt arg param loc Alpha_context.Script.I_EXEC 1 2)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                typed ctxt loc Script_typed_ir.Exec
                  (Script_typed_ir.Item_t ret rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_APPLY [] annot,
          Script_typed_ir.Item_t capture
            (Script_typed_ir.Item_t
              (Script_typed_ir.Lambda_t
                (Script_typed_ir.Pair_t (capture_ty, _, _) (arg_ty, _, _)
                  lam_annot _) ret _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (check_packable false loc capture_ty))
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt capture capture_ty loc
                Alpha_context.Script.I_APPLY 1 2)
              (fun function_parameter =&gt;
                let '(Eq, capture_ty, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
                  (fun annot =&gt;
                    typed ctxt loc (Script_typed_ir.Apply capture_ty)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Lambda_t arg_ty ret lam_annot) rest
                        annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons code []) annot,
          Script_typed_ir.Item_t v rest stack_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind (cons Script_tc_errors.Seq_kind []) code)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger (add_dip v stack_annot tc_context)
                    ctxt legacy code rest)
                  (fun function_parameter =&gt;
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed __descr_value =&gt;
                      typed ctxt loc (Script_typed_ir.Dip __descr_value)
                        (Script_typed_ir.Item_t v
                          (Script_typed_ir.descr.aft __descr_value) stack_annot)
                    | Failed _ =&gt; Error_monad.fail extensible_type_value
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons n (cons code []))
          result_annot, stack), true) =&gt;
        let fix make_proof_argument {tstk : Set}
          (n : Z) (inner_tc_context : tc_context)
          (stk : Script_typed_ir.stack_ty tstk) {struct n}
          : Lwt.t (Error_monad.tzresult (dipn_proof_argument tstk)) :=
          match ((Compare.Int.[Compare.S.op_eq] n 0), stk) with
          | (true, rest) =&gt;
            Error_monad.op_gtgteqquestion
              (parse_instr type_logger inner_tc_context ctxt legacy code rest)
              (fun function_parameter =&gt;
                let '(judgement, ctxt) := function_parameter in
                match judgement with
                | Typed __descr_value =&gt;
                  Pervasives.op_atat outer_return
                    (Dipn_proof_argument
                      (Script_typed_ir.Rest, (ctxt, __descr_value),
                        (Script_typed_ir.descr.aft __descr_value)))
                | Failed _ =&gt; Error_monad.fail extensible_type_value
                end)
          | (false, Script_typed_ir.Item_t v rest annot) =&gt;
            Error_monad.op_gtgteqquestion
              (make_proof_argument (Pervasives.op_minus n 1)
                (add_dip v annot tc_context) rest)
              (fun function_parameter =&gt;
                let 'Dipn_proof_argument (n', __descr_value, aft') :=
                  function_parameter in
                Pervasives.op_atat outer_return
                  (Dipn_proof_argument
                    ((Script_typed_ir.Prefix n'), __descr_value,
                      (Script_typed_ir.Item_t v aft' annot))))
          | (_, _) =&gt;
            Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
              (fun function_parameter =&gt;
                let '(whole_stack, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value)
          end in
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun n =&gt;
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument n tc_context stack)
                  (fun function_parameter =&gt;
                    let
                      'Dipn_proof_argument (n', (new_ctxt, __descr_value), aft) :=
                      function_parameter in
                    typed new_ctxt loc (Script_typed_ir.Dipn n n' __descr_value)
                      aft)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIP
          (([] | cons _ (cons _ (cons _ _))) as l) _, _), _) =&gt;
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_FAILWITH [] annot,
          Script_typed_ir.Item_t v _rest _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            let __descr_value {B : Set} (aft : Script_typed_ir.stack_ty B)
              : Script_typed_ir.descr bef B :=
              {| Script_typed_ir.descr.loc := loc;
                Script_typed_ir.descr.bef := stack_ty;
                Script_typed_ir.descr.aft := aft;
                Script_typed_ir.descr.instr := Script_typed_ir.Failwith v |} in
            Error_monad.op_gtgteqquestion
              (log_stack ctxt loc stack_ty Script_typed_ir.Empty_t)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                __return ctxt
                  (Failed {| judgement.Failed.descr := __descr_value |})))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Add_timestamp_to_seconds
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest _)
            _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Add_seconds_to_timestamp
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Sub_timestamp_seconds
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn2) rest _) _),
          _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Diff_timestamps
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.String_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.String_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Concat_string_pair
                  (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.List_t (Script_typed_ir.String_t tname) _ _) rest
            list_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some list_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Concat_string
              (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
                string_annot) _) _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc
            (Some
              (Script_ir_annot.gen_access_annot string_annot None
                Script_ir_annot.default_slice_annot)) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Slice_string
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t (Script_typed_ir.String_t tname) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.String_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.String_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Concat_bytes_pair
                  (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.List_t (Script_typed_ir.Bytes_t tname) _ _) rest
            list_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some list_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Concat_bytes
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest
                bytes_annot) _) _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc
            (Some
              (Script_ir_annot.gen_access_annot bytes_annot None
                Script_ir_annot.default_slice_annot)) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Slice_bytes
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t (Script_typed_ir.Bytes_t tname) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Bytes_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Add_tez
                  (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Sub_tez
                  (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Mul_teznat
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest _) _),
          _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Mul_nattez
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Or
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.And
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Xor
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Not
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ABS [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Abs_int
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ISNAT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest int_annot), _)
        =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some int_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Is_nat
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t (Script_typed_ir.Nat_t None) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_INT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Int_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Neg_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Neg_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Add_intint
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Add_intnat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Add_natint
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Add_natnat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Sub_int
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Sub_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Sub_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun _tname =&gt;
                typed ctxt loc Script_typed_ir.Sub_int
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Mul_intint
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Mul_intnat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Mul_natint
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Mul_natnat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Ediv_teznat
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t
                  (Script_typed_ir.Pair_t
                    ((Script_typed_ir.Mutez_t tname), None, None)
                    ((Script_typed_ir.Mutez_t tname), None, None) None false)
                  None false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Ediv_tez
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t
                      (Script_typed_ir.Pair_t
                        ((Script_typed_ir.Nat_t None), None, None)
                        ((Script_typed_ir.Mutez_t tname), None, None) None false)
                      None false) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Ediv_intint
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t
                      (Script_typed_ir.Pair_t
                        ((Script_typed_ir.Int_t tname), None, None)
                        ((Script_typed_ir.Nat_t None), None, None) None false)
                      None false) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Ediv_intnat
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t
                  (Script_typed_ir.Pair_t
                    ((Script_typed_ir.Int_t tname), None, None)
                    ((Script_typed_ir.Nat_t None), None, None) None false) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Ediv_natint
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t
                  (Script_typed_ir.Pair_t
                    ((Script_typed_ir.Int_t None), None, None)
                    ((Script_typed_ir.Nat_t tname), None, None) None false) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Ediv_natnat
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t
                      (Script_typed_ir.Pair_t
                        ((Script_typed_ir.Nat_t tname), None, None)
                        ((Script_typed_ir.Nat_t tname), None, None) None false)
                      None false) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LSL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Lsl_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LSR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Lsr_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Or_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.And_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.And_int_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =&gt;
                typed ctxt loc Script_typed_ir.Xor_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Not_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Not_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_COMPARE [] annot,
          Script_typed_ir.Item_t t1 (Script_typed_ir.Item_t t2 rest _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt t1 t2 loc Alpha_context.Script.I_COMPARE 1 2)
              (fun function_parameter =&gt;
                let '(Eq, t, ctxt) := function_parameter in
                match comparable_ty_of_ty t with
                | None =&gt;
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return (serialize_ty_for_error ctxt t))
                    (fun function_parameter =&gt;
                      let '(t, _ctxt) := function_parameter in
                      Error_monad.fail extensible_type_value)
                | Some key =&gt;
                  typed ctxt loc (Script_typed_ir.Compare key)
                    (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest
                      annot)
                end))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EQ [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Eq
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NEQ [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Neq
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Lt
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Gt
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Le
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Ge
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CAST (cons cast_t []) annot,
          Script_typed_ir.Item_t t stack item_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some item_annot) annot)
          (fun annot =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy cast_t))
              (fun function_parameter =&gt;
                let '(Ex_ty cast_t, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat Lwt.__return (ty_eq ctxt cast_t t))
                  (fun function_parameter =&gt;
                    let '(Eq, ctxt) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (Pervasives.op_atat Lwt.__return
                        (merge_types legacy ctxt loc cast_t t))
                      (fun function_parameter =&gt;
                        let '(_, ctxt) := function_parameter in
                        typed ctxt loc Script_typed_ir.Nop
                          (Script_typed_ir.Item_t cast_t stack annot)))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_RENAME [] annot,
          Script_typed_ir.Item_t t stack _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Nop
              (Script_typed_ir.Item_t t stack annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_PACK [] annot,
          Script_typed_ir.Item_t t rest unpacked_annot), _) =&gt;
        Error_monad.op_gtgteqquestion (Lwt.__return (check_packable true loc t))
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgteqquestion
              (parse_var_annot loc
                (Some
                  (Script_ir_annot.gen_access_annot unpacked_annot None
                    Script_ir_annot.default_pack_annot)) annot)
              (fun annot =&gt;
                typed ctxt loc (Script_typed_ir.Pack t)
                  (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UNPACK (cons ty []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest packed_annot),
          _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_packable_ty ctxt legacy ty))
          (fun function_parameter =&gt;
            let '(Ex_ty t, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =&gt;
                let '(annot, ty_name) := function_parameter in
                let annot :=
                  Script_ir_annot.default_annot
                    (Script_ir_annot.gen_access_annot packed_annot None
                      Script_ir_annot.default_unpack_annot) annot in
                typed ctxt loc (Script_typed_ir.Unpack t)
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t t ty_name false) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADDRESS [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Contract_t _ _) rest
            contract_annot), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc
            (Some
              (Script_ir_annot.gen_access_annot contract_annot None
                Script_ir_annot.default_addr_annot)) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Address
              (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONTRACT (cons ty []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Address_t _) rest addr_annot),
          _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_parameter_ty ctxt legacy ty))
          (fun function_parameter =&gt;
            let '(Ex_ty t, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (parse_entrypoint_annot loc
                (Some
                  (Script_ir_annot.gen_access_annot addr_annot None
                    Script_ir_annot.default_contract_annot)) annot)
              (fun function_parameter =&gt;
                let '(annot, entrypoint) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat Lwt.__return
                    match entrypoint with
                    | None =&gt; Pervasives.Ok &quot;default&quot; % string
                    | Some (Field_annot &quot;default&quot; % string) =&gt;
                      Error_monad.__error_value extensible_type_value
                    | Some (Field_annot entrypoint) =&gt;
                      if
                        Compare.Int.[Compare.S.op_gt] (String.length entrypoint)
                          31 then
                        Error_monad.__error_value extensible_type_value
                      else
                        Pervasives.Ok entrypoint
                    end)
                  (fun entrypoint =&gt;
                    typed ctxt loc (Script_typed_ir.Contract t entrypoint)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Option_t
                          (Script_typed_ir.Contract_t t None) None false) rest
                        annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] annot,
          Script_typed_ir.Item_t p
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Contract_t cp _) rest _)
              _) _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt p cp loc Alpha_context.Script.I_TRANSFER_TOKENS 1
            4)
          (fun function_parameter =&gt;
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =&gt;
                typed ctxt loc Script_typed_ir.Transfer_tokens
                  (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
                    rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SET_DELEGATE [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _) rest _),
          _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Set_delegate
              (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
            (Script_typed_ir.Item_t
              (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
                (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _) rest _) _) _)
            _), _) =&gt;
        if legacy then
          Error_monad.op_gtgteqquestion (parse_two_var_annot loc annot)
            (fun function_parameter =&gt;
              let '(op_annot, addr_annot) := function_parameter in
              typed ctxt loc Script_typed_ir.Create_account
                (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
                  (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
                    addr_annot) op_annot))
        else
          Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IMPLICIT_ACCOUNT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Implicit_account
              (Script_typed_ir.Item_t
                (Script_typed_ir.Contract_t (Script_typed_ir.Unit_t None) None)
                rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
          (cons ((Micheline.Seq _ _) as code) []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
            (Script_typed_ir.Item_t
              (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
                (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
                  (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
                    (Script_typed_ir.Item_t ginit rest _) _) _) _) _) _), _) =&gt;
        if legacy then
          Error_monad.op_gtgteqquestion (parse_two_var_annot loc annot)
            (fun function_parameter =&gt;
              let '(op_annot, addr_annot) := function_parameter in
              let cannonical_code :=
                Pervasives.op_atat Pervasives.fst
                  (Micheline.extract_locations code) in
              Error_monad.op_gtgteqquestion
                (Pervasives.op_atat Lwt.__return
                  (parse_toplevel legacy cannonical_code))
                (fun function_parameter =&gt;
                  let '(arg_type, storage_type, code_field, root_name) :=
                    function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Error_monad.trace extensible_type_value
                      (Pervasives.op_atat Lwt.__return
                        (parse_parameter_ty ctxt legacy arg_type)))
                    (fun function_parameter =&gt;
                      let '(Ex_ty arg_type, ctxt) := function_parameter in
                      Error_monad.op_gtgteqquestion
                        (if legacy then
                          Error_monad.__return tt
                        else
                          Lwt.__return
                            (well_formed_entrypoints arg_type root_name))
                        (fun function_parameter =&gt;
                          let 'tt := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (Error_monad.trace extensible_type_value
                              (Pervasives.op_atat Lwt.__return
                                (parse_storage_ty ctxt legacy storage_type)))
                            (fun function_parameter =&gt;
                              let '(Ex_ty storage_type, ctxt) :=
                                function_parameter in
                              let arg_annot :=
                                Script_ir_annot.default_annot
                                  Script_ir_annot.default_param_annot
                                  (Script_ir_annot.type_to_var_annot
                                    (name_of_ty arg_type)) in
                              let storage_annot :=
                                Script_ir_annot.default_annot
                                  Script_ir_annot.default_storage_annot
                                  (Script_ir_annot.type_to_var_annot
                                    (name_of_ty storage_type)) in
                              let arg_type_full :=
                                Script_typed_ir.Pair_t
                                  (arg_type, None, arg_annot)
                                  (storage_type, None, storage_annot) None
                                  (Pervasives.op_pipepipe (has_big_map arg_type)
                                    (has_big_map storage_type)) in
                              let ret_type_full :=
                                Script_typed_ir.Pair_t
                                  ((Script_typed_ir.List_t
                                    (Script_typed_ir.Operation_t None) None
                                    false), None, None)
                                  (storage_type, None, None) None
                                  (has_big_map storage_type) in
                              Error_monad.op_gtgteqquestion
                                (Error_monad.trace extensible_type_value
                                  (parse_returning type_logger
                                    (Toplevel
                                      {|
                                        tc_context.Toplevel.storage_type :=
                                          storage_type;
                                        tc_context.Toplevel.param_type :=
                                          arg_type;
                                        tc_context.Toplevel.root_name :=
                                          root_name;
                                        tc_context.Toplevel.legacy_create_contract_literal :=
                                          true |}) ctxt legacy
                                    (arg_type_full, None) ret_type_full
                                    code_field))
                                (fun function_parameter =&gt;
                                  let
                                    '((Script_typed_ir.Lam {|
                                      Script_typed_ir.descr.bef :=
                                        Script_typed_ir.Item_t arg
                                          Script_typed_ir.Empty_t
                                          _;
                                        Script_typed_ir.descr.aft :=
                                          Script_typed_ir.Item_t
                                            ret
                                            Script_typed_ir.Empty_t
                                            _
                                        |} _) as lambda, ctxt) :=
                                    function_parameter in
                                  Error_monad.op_gtgteqquestion
                                    (Pervasives.op_atat Lwt.__return
                                      (ty_eq ctxt arg arg_type_full))
                                    (fun function_parameter =&gt;
                                      let '(Eq, ctxt) := function_parameter in
                                      Error_monad.op_gtgteqquestion
                                        (Pervasives.op_atat Lwt.__return
                                          (merge_types legacy ctxt loc arg
                                            arg_type_full))
                                        (fun function_parameter =&gt;
                                          let '(_, ctxt) := function_parameter
                                            in
                                          Error_monad.op_gtgteqquestion
                                            (Pervasives.op_atat Lwt.__return
                                              (ty_eq ctxt ret ret_type_full))
                                            (fun function_parameter =&gt;
                                              let '(Eq, ctxt) :=
                                                function_parameter in
                                              Error_monad.op_gtgteqquestion
                                                (Pervasives.op_atat Lwt.__return
                                                  (merge_types legacy ctxt loc
                                                    ret ret_type_full))
                                                (fun function_parameter =&gt;
                                                  let '(_, ctxt) :=
                                                    function_parameter in
                                                  Error_monad.op_gtgteqquestion
                                                    (Pervasives.op_atat
                                                      Lwt.__return
                                                      (ty_eq ctxt storage_type
                                                        ginit))
                                                    (fun function_parameter =&gt;
                                                      let '(Eq, ctxt) :=
                                                        function_parameter in
                                                      Error_monad.op_gtgteqquestion
                                                        (Pervasives.op_atat
                                                          Lwt.__return
                                                          (merge_types legacy
                                                            ctxt loc
                                                            storage_type ginit))
                                                        (fun function_parameter
                                                          =&gt;
                                                          let '(_, ctxt) :=
                                                            function_parameter
                                                            in
                                                          typed ctxt loc
                                                            (Script_typed_ir.Create_contract
                                                              storage_type
                                                              arg_type lambda
                                                              root_name)
                                                            (Script_typed_ir.Item_t
                                                              (Script_typed_ir.Operation_t
                                                                None)
                                                              (Script_typed_ir.Item_t
                                                                (Script_typed_ir.Address_t
                                                                  None) rest
                                                                addr_annot)
                                                              op_annot)))))))))))))
        else
          Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
          (cons ((Micheline.Seq _ _) as code) []) annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
              (Script_typed_ir.Item_t ginit rest _) _) _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_two_var_annot loc annot)
          (fun function_parameter =&gt;
            let '(op_annot, addr_annot) := function_parameter in
            let cannonical_code :=
              Pervasives.op_atat Pervasives.fst
                (Micheline.extract_locations code) in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (parse_toplevel legacy cannonical_code))
              (fun function_parameter =&gt;
                let '(arg_type, storage_type, code_field, root_name) :=
                  function_parameter in
                Error_monad.op_gtgteqquestion
                  (Error_monad.trace extensible_type_value
                    (Pervasives.op_atat Lwt.__return
                      (parse_parameter_ty ctxt legacy arg_type)))
                  (fun function_parameter =&gt;
                    let '(Ex_ty arg_type, ctxt) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (if legacy then
                        Error_monad.__return tt
                      else
                        Lwt.__return
                          (well_formed_entrypoints arg_type root_name))
                      (fun function_parameter =&gt;
                        let 'tt := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (Error_monad.trace extensible_type_value
                            (Pervasives.op_atat Lwt.__return
                              (parse_storage_ty ctxt legacy storage_type)))
                          (fun function_parameter =&gt;
                            let '(Ex_ty storage_type, ctxt) :=
                              function_parameter in
                            let arg_annot :=
                              Script_ir_annot.default_annot
                                Script_ir_annot.default_param_annot
                                (Script_ir_annot.type_to_var_annot
                                  (name_of_ty arg_type)) in
                            let storage_annot :=
                              Script_ir_annot.default_annot
                                Script_ir_annot.default_storage_annot
                                (Script_ir_annot.type_to_var_annot
                                  (name_of_ty storage_type)) in
                            let arg_type_full :=
                              Script_typed_ir.Pair_t (arg_type, None, arg_annot)
                                (storage_type, None, storage_annot) None
                                (Pervasives.op_pipepipe (has_big_map arg_type)
                                  (has_big_map storage_type)) in
                            let ret_type_full :=
                              Script_typed_ir.Pair_t
                                ((Script_typed_ir.List_t
                                  (Script_typed_ir.Operation_t None) None false),
                                  None, None) (storage_type, None, None) None
                                (has_big_map storage_type) in
                            Error_monad.op_gtgteqquestion
                              (Error_monad.trace extensible_type_value
                                (parse_returning type_logger
                                  (Toplevel
                                    {|
                                      tc_context.Toplevel.storage_type :=
                                        storage_type;
                                      tc_context.Toplevel.param_type := arg_type;
                                      tc_context.Toplevel.root_name := root_name;
                                      tc_context.Toplevel.legacy_create_contract_literal :=
                                        false |}) ctxt legacy
                                  (arg_type_full, None) ret_type_full code_field))
                              (fun function_parameter =&gt;
                                let
                                  '((Script_typed_ir.Lam {|
                                    Script_typed_ir.descr.bef :=
                                      Script_typed_ir.Item_t arg
                                        Script_typed_ir.Empty_t
                                        _;
                                      Script_typed_ir.descr.aft :=
                                        Script_typed_ir.Item_t
                                          ret
                                          Script_typed_ir.Empty_t
                                          _
                                      |} _) as lambda, ctxt) :=
                                  function_parameter in
                                Error_monad.op_gtgteqquestion
                                  (Pervasives.op_atat Lwt.__return
                                    (ty_eq ctxt arg arg_type_full))
                                  (fun function_parameter =&gt;
                                    let '(Eq, ctxt) := function_parameter in
                                    Error_monad.op_gtgteqquestion
                                      (Pervasives.op_atat Lwt.__return
                                        (merge_types legacy ctxt loc arg
                                          arg_type_full))
                                      (fun function_parameter =&gt;
                                        let '(_, ctxt) := function_parameter in
                                        Error_monad.op_gtgteqquestion
                                          (Pervasives.op_atat Lwt.__return
                                            (ty_eq ctxt ret ret_type_full))
                                          (fun function_parameter =&gt;
                                            let '(Eq, ctxt) :=
                                              function_parameter in
                                            Error_monad.op_gtgteqquestion
                                              (Pervasives.op_atat Lwt.__return
                                                (merge_types legacy ctxt loc ret
                                                  ret_type_full))
                                              (fun function_parameter =&gt;
                                                let '(_, ctxt) :=
                                                  function_parameter in
                                                Error_monad.op_gtgteqquestion
                                                  (Pervasives.op_atat
                                                    Lwt.__return
                                                    (ty_eq ctxt storage_type
                                                      ginit))
                                                  (fun function_parameter =&gt;
                                                    let '(Eq, ctxt) :=
                                                      function_parameter in
                                                    Error_monad.op_gtgteqquestion
                                                      (Pervasives.op_atat
                                                        Lwt.__return
                                                        (merge_types legacy ctxt
                                                          loc storage_type ginit))
                                                      (fun function_parameter =&gt;
                                                        let '(_, ctxt) :=
                                                          function_parameter in
                                                        typed ctxt loc
                                                          (Script_typed_ir.Create_contract_2
                                                            storage_type
                                                            arg_type lambda
                                                            root_name)
                                                          (Script_typed_ir.Item_t
                                                            (Script_typed_ir.Operation_t
                                                              None)
                                                            (Script_typed_ir.Item_t
                                                              (Script_typed_ir.Address_t
                                                                None) rest
                                                              addr_annot)
                                                            op_annot)))))))))))))
      | ((Micheline.Prim loc Alpha_context.Script.I_NOW [] annot, stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_now_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Now
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_AMOUNT [] annot, stack), _)
        =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_amount_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Amount
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) stack annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CHAIN_ID [] annot, stack), _)
        =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.ChainId
              (Script_typed_ir.Item_t (Script_typed_ir.Chain_id_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_BALANCE [] annot, stack), _)
        =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_balance_annot)
            annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Balance
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) stack annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_HASH_KEY [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Hash_key
              (Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t None) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CHECK_SIGNATURE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Signature_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _) _) _),
          _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Check_signature
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_BLAKE2B [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Blake2b
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SHA256 [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Sha256
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SHA512 [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Sha512
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_STEPS_TO_QUOTA [] annot,
          stack), _) =&gt;
        if legacy then
          Error_monad.op_gtgteqquestion
            (parse_var_annot loc (Some Script_ir_annot.default_steps_annot)
              annot)
            (fun annot =&gt;
              typed ctxt loc Script_typed_ir.Steps_to_quota
                (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) stack annot))
        else
          Error_monad.fail extensible_type_value
      | ((Micheline.Prim loc Alpha_context.Script.I_SOURCE [] annot, stack), _)
        =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_source_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Source
              (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_SENDER [] annot, stack), _)
        =&gt;
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_sender_annot) annot)
          (fun annot =&gt;
            typed ctxt loc Script_typed_ir.Sender
              (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_SELF [] annot, stack), _) =&gt;
        Error_monad.op_gtgteqquestion
          (parse_entrypoint_annot loc (Some Script_ir_annot.default_self_annot)
            annot)
          (fun function_parameter =&gt;
            let '(annot, entrypoint) := function_parameter in
            let entrypoint :=
              Option.unopt_map
                (fun function_parameter =&gt;
                  let 'Field_annot annot := function_parameter in
                  annot) &quot;default&quot; % string entrypoint in
            let fix get_toplevel_type (function_parameter : tc_context)
              {struct function_parameter}
              : Lwt.t
                (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
              match function_parameter with
              | Lambda =&gt; Error_monad.fail extensible_type_value
              | Dip _ prev =&gt; get_toplevel_type prev
              |
                Toplevel {|
                  tc_context.Toplevel.param_type := param_type;
                    tc_context.Toplevel.root_name := root_name;
                    tc_context.Toplevel.legacy_create_contract_literal := false
                    |} =&gt;
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (find_entrypoint param_type root_name entrypoint))
                  (fun function_parameter =&gt;
                    let '(_, Ex_ty param_type) := function_parameter in
                    typed ctxt loc (Script_typed_ir.Self param_type entrypoint)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Contract_t param_type None) stack annot))
              |
                Toplevel {|
                  tc_context.Toplevel.param_type := param_type;
                    tc_context.Toplevel.root_name := _;
                    tc_context.Toplevel.legacy_create_contract_literal := true
                    |} =&gt;
                typed ctxt loc
                  (Script_typed_ir.Self param_type &quot;default&quot; % string)
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Contract_t param_type None) stack annot)
              end in
            get_toplevel_type tc_context)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_DUP | Alpha_context.Script.I_SWAP |
          Alpha_context.Script.I_SOME | Alpha_context.Script.I_UNIT |
          Alpha_context.Script.I_PAIR | Alpha_context.Script.I_CAR |
          Alpha_context.Script.I_CDR | Alpha_context.Script.I_CONS |
          Alpha_context.Script.I_CONCAT | Alpha_context.Script.I_SLICE |
          Alpha_context.Script.I_MEM | Alpha_context.Script.I_UPDATE |
          Alpha_context.Script.I_MAP | Alpha_context.Script.I_GET |
          Alpha_context.Script.I_EXEC | Alpha_context.Script.I_FAILWITH |
          Alpha_context.Script.I_SIZE | Alpha_context.Script.I_ADD |
          Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
          Alpha_context.Script.I_EDIV | Alpha_context.Script.I_OR |
          Alpha_context.Script.I_AND | Alpha_context.Script.I_XOR |
          Alpha_context.Script.I_NOT | Alpha_context.Script.I_ABS |
          Alpha_context.Script.I_NEG | Alpha_context.Script.I_LSL |
          Alpha_context.Script.I_LSR | Alpha_context.Script.I_COMPARE |
          Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
          Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
          Alpha_context.Script.I_LE | Alpha_context.Script.I_GE |
          Alpha_context.Script.I_TRANSFER_TOKENS |
          Alpha_context.Script.I_CREATE_ACCOUNT |
          Alpha_context.Script.I_SET_DELEGATE | Alpha_context.Script.I_NOW |
          Alpha_context.Script.I_IMPLICIT_ACCOUNT |
          Alpha_context.Script.I_AMOUNT | Alpha_context.Script.I_BALANCE |
          Alpha_context.Script.I_CHECK_SIGNATURE |
          Alpha_context.Script.I_HASH_KEY | Alpha_context.Script.I_SOURCE |
          Alpha_context.Script.I_SENDER | Alpha_context.Script.I_BLAKE2B |
          Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
          Alpha_context.Script.I_STEPS_TO_QUOTA | Alpha_context.Script.I_ADDRESS)
            as name) ((cons _ _) as l) _, _), _) =&gt;
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_NONE | Alpha_context.Script.I_LEFT |
          Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_NIL |
          Alpha_context.Script.I_MAP | Alpha_context.Script.I_ITER |
          Alpha_context.Script.I_EMPTY_SET | Alpha_context.Script.I_DIP |
          Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LOOP_LEFT |
          Alpha_context.Script.I_CONTRACT) as name)
          (([] | cons _ (cons _ _)) as l) _, _), _) =&gt;
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_PUSH | Alpha_context.Script.I_IF_NONE |
          Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_CONS |
          Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_IF) as name)
          (([] | cons _ [] | cons _ (cons _ (cons _ _))) as l) _, _), _) =&gt;
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
          (([] | cons _ [] | cons _ (cons _ (cons _ (cons _ _)))) as l) _, _), _)
        =&gt; Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_ADD | Alpha_context.Script.I_SUB |
          Alpha_context.Script.I_MUL | Alpha_context.Script.I_EDIV |
          Alpha_context.Script.I_AND | Alpha_context.Script.I_OR |
          Alpha_context.Script.I_XOR | Alpha_context.Script.I_LSL |
          Alpha_context.Script.I_LSR) as name) [] _,
          Script_typed_ir.Item_t ta (Script_typed_ir.Item_t tb _ _) _), _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (serialize_ty_for_error ctxt ta))
          (fun function_parameter =&gt;
            let '(ta, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (serialize_ty_for_error ctxt tb))
              (fun function_parameter =&gt;
                let '(tb, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value))
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_NEG | Alpha_context.Script.I_ABS |
          Alpha_context.Script.I_NOT | Alpha_context.Script.I_CONCAT |
          Alpha_context.Script.I_SIZE | Alpha_context.Script.I_EQ |
          Alpha_context.Script.I_NEQ | Alpha_context.Script.I_LT |
          Alpha_context.Script.I_GT | Alpha_context.Script.I_LE |
          Alpha_context.Script.I_GE) as name) [] _, Script_typed_ir.Item_t t _ _),
          _) =&gt;
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (serialize_ty_for_error ctxt t))
          (fun function_parameter =&gt;
            let '(t, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_UPDATE | Alpha_context.Script.I_SLICE) as
            name) [] _, stack), _) =&gt;
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =&gt;
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT _ _, stack),
          _) =&gt;
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =&gt;
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] _, stack),
          _) =&gt;
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =&gt;
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] _, stack),
          _) =&gt;
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =&gt;
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
          Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
          Alpha_context.Script.I_SOME | Alpha_context.Script.I_BLAKE2B |
          Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
          Alpha_context.Script.I_DIP | Alpha_context.Script.I_IF_NONE |
          Alpha_context.Script.I_LEFT | Alpha_context.Script.I_RIGHT |
          Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF |
          Alpha_context.Script.I_LOOP | Alpha_context.Script.I_IF_CONS |
          Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_NEG |
          Alpha_context.Script.I_ABS | Alpha_context.Script.I_INT |
          Alpha_context.Script.I_NOT | Alpha_context.Script.I_HASH_KEY |
          Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
          Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
          Alpha_context.Script.I_LE | Alpha_context.Script.I_GE) as name) _ _,
          stack), _) =&gt;
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =&gt;
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_SWAP | Alpha_context.Script.I_PAIR |
          Alpha_context.Script.I_CONS | Alpha_context.Script.I_GET |
          Alpha_context.Script.I_MEM | Alpha_context.Script.I_EXEC |
          Alpha_context.Script.I_CHECK_SIGNATURE | Alpha_context.Script.I_ADD |
          Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
          Alpha_context.Script.I_EDIV | Alpha_context.Script.I_AND |
          Alpha_context.Script.I_OR | Alpha_context.Script.I_XOR |
          Alpha_context.Script.I_LSL | Alpha_context.Script.I_LSR) as name) _ _,
          stack), _) =&gt;
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =&gt;
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      | ((expr, _), _) =&gt;
        Pervasives.op_atat Error_monad.fail
          (unexpected expr (cons Script_tc_errors.Seq_kind [])
            Script_tc_errors.Instr_namespace
            (cons Alpha_context.Script.I_DROP
              (cons Alpha_context.Script.I_DUP
                (cons Alpha_context.Script.I_DIG
                  (cons Alpha_context.Script.I_DUG
                    (cons Alpha_context.Script.I_SWAP
                      (cons Alpha_context.Script.I_SOME
                        (cons Alpha_context.Script.I_UNIT
                          (cons Alpha_context.Script.I_PAIR
                            (cons Alpha_context.Script.I_CAR
                              (cons Alpha_context.Script.I_CDR
                                (cons Alpha_context.Script.I_CONS
                                  (cons Alpha_context.Script.I_MEM
                                    (cons Alpha_context.Script.I_UPDATE
                                      (cons Alpha_context.Script.I_MAP
                                        (cons Alpha_context.Script.I_ITER
                                          (cons Alpha_context.Script.I_GET
                                            (cons Alpha_context.Script.I_EXEC
                                              (cons
                                                Alpha_context.Script.I_FAILWITH
                                                (cons
                                                  Alpha_context.Script.I_SIZE
                                                  (cons
                                                    Alpha_context.Script.I_CONCAT
                                                    (cons
                                                      Alpha_context.Script.I_ADD
                                                      (cons
                                                        Alpha_context.Script.I_SUB
                                                        (cons
                                                          Alpha_context.Script.I_MUL
                                                          (cons
                                                            Alpha_context.Script.I_EDIV
                                                            (cons
                                                              Alpha_context.Script.I_OR
                                                              (cons
                                                                Alpha_context.Script.I_AND
                                                                (cons
                                                                  Alpha_context.Script.I_XOR
                                                                  (cons
                                                                    Alpha_context.Script.I_NOT
                                                                    (cons
                                                                      Alpha_context.Script.I_ABS
                                                                      (cons
                                                                        Alpha_context.Script.I_INT
                                                                        (cons
                                                                          Alpha_context.Script.I_NEG
                                                                          (cons
                                                                            Alpha_context.Script.I_LSL
                                                                            (cons
                                                                              Alpha_context.Script.I_LSR
                                                                              (cons
                                                                                Alpha_context.Script.I_COMPARE
                                                                                (cons
                                                                                  Alpha_context.Script.I_EQ
                                                                                  (cons
                                                                                    Alpha_context.Script.I_NEQ
                                                                                    (cons
                                                                                      Alpha_context.Script.I_LT
                                                                                      (cons
                                                                                        Alpha_context.Script.I_GT
                                                                                        (cons
                                                                                          Alpha_context.Script.I_LE
                                                                                          (cons
                                                                                            Alpha_context.Script.I_GE
                                                                                            (cons
                                                                                              Alpha_context.Script.I_TRANSFER_TOKENS
                                                                                              (cons
                                                                                                Alpha_context.Script.I_CREATE_ACCOUNT
                                                                                                (cons
                                                                                                  Alpha_context.Script.I_CREATE_CONTRACT
                                                                                                  (cons
                                                                                                    Alpha_context.Script.I_NOW
                                                                                                    (cons
                                                                                                      Alpha_context.Script.I_AMOUNT
                                                                                                      (cons
                                                                                                        Alpha_context.Script.I_BALANCE
                                                                                                        (cons
                                                                                                          Alpha_context.Script.I_IMPLICIT_ACCOUNT
                                                                                                          (cons
                                                                                                            Alpha_context.Script.I_CHECK_SIGNATURE
                                                                                                            (cons
                                                                                                              Alpha_context.Script.I_BLAKE2B
                                                                                                              (cons
                                                                                                                Alpha_context.Script.I_SHA256
                                                                                                                (cons
                                                                                                                  Alpha_context.Script.I_SHA512
                                                                                                                  (cons
                                                                                                                    Alpha_context.Script.I_HASH_KEY
                                                                                                                    (cons
                                                                                                                      Alpha_context.Script.I_STEPS_TO_QUOTA
                                                                                                                      (cons
                                                                                                                        Alpha_context.Script.I_PUSH
                                                                                                                        (cons
                                                                                                                          Alpha_context.Script.I_NONE
                                                                                                                          (cons
                                                                                                                            Alpha_context.Script.I_LEFT
                                                                                                                            (cons
                                                                                                                              Alpha_context.Script.I_RIGHT
                                                                                                                              (cons
                                                                                                                                Alpha_context.Script.I_NIL
                                                                                                                                (cons
                                                                                                                                  Alpha_context.Script.I_EMPTY_SET
                                                                                                                                  (cons
                                                                                                                                    Alpha_context.Script.I_DIP
                                                                                                                                    (cons
                                                                                                                                      Alpha_context.Script.I_LOOP
                                                                                                                                      (cons
                                                                                                                                        Alpha_context.Script.I_IF_NONE
                                                                                                                                        (cons
                                                                                                                                          Alpha_context.Script.I_IF_LEFT
                                                                                                                                          (cons
                                                                                                                                            Alpha_context.Script.I_IF_CONS
                                                                                                                                            (cons
                                                                                                                                              Alpha_context.Script.I_EMPTY_MAP
                                                                                                                                              (cons
                                                                                                                                                Alpha_context.Script.I_IF
                                                                                                                                                (cons
                                                                                                                                                  Alpha_context.Script.I_SOURCE
                                                                                                                                                  (cons
                                                                                                                                                    Alpha_context.Script.I_SENDER
                                                                                                                                                    (cons
                                                                                                                                                      Alpha_context.Script.I_SELF
                                                                                                                                                      (cons
                                                                                                                                                        Alpha_context.Script.I_LAMBDA
                                                                                                                                                        [])))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
      end)

with parse_contract {arg : Set}
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty arg)
  (contract : Alpha_context.Contract.t) (entrypoint : string) {struct legacy}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Script_typed_ir.typed_contract arg)) :=
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists))
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Alpha_context.Contract.__exists ctxt contract)
        (fun function_parameter =&gt;
          match function_parameter with
          | false =&gt; Error_monad.fail extensible_type_value
          | true =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat (Error_monad.trace extensible_type_value)
                    (Alpha_context.Contract.get_script_code ctxt contract))
                  (fun function_parameter =&gt;
                    let '(ctxt, code) := function_parameter in
                    match code with
                    | None =&gt;
                      Lwt.__return
                        (Error_monad.op_gtgtquestion
                          (ty_eq ctxt arg (Script_typed_ir.Unit_t None))
                          (fun function_parameter =&gt;
                            let '(Eq, ctxt) := function_parameter in
                            match entrypoint with
                            | &quot;default&quot; % string =&gt;
                              let contract := (arg, (contract, entrypoint)) in
                              Error_monad.ok (ctxt, contract)
                            | entrypoint =&gt;
                              Error_monad.__error_value extensible_type_value
                            end))
                    | Some code =&gt;
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Script.force_decode ctxt code)
                        (fun function_parameter =&gt;
                          let '(code, ctxt) := function_parameter in
                          Lwt.__return
                            (Error_monad.op_gtgtquestion
                              (parse_toplevel true code)
                              (fun function_parameter =&gt;
                                let '(arg_type, _, _, root_name) :=
                                  function_parameter in
                                Error_monad.op_gtgtquestion
                                  (parse_parameter_ty ctxt true arg_type)
                                  (fun function_parameter =&gt;
                                    let '(Ex_ty targ, ctxt) :=
                                      function_parameter in
                                    let __return
                                      (ctxt : Alpha_context.context)
                                      (targ : Script_typed_ir.ty arg)
                                      (entrypoint : string)
                                      : Error_monad.tzresult
                                        (Alpha_context.context *
                                          Script_typed_ir.typed_contract arg) :=
                                      Error_monad.op_gtgtquestion
                                        (merge_types legacy ctxt loc targ arg)
                                        (fun function_parameter =&gt;
                                          let '(arg, ctxt) := function_parameter
                                            in
                                          let contract :=
                                            (arg, (contract, entrypoint)) in
                                          Error_monad.ok (ctxt, contract)) in
                                    Error_monad.op_gtgtquestion
                                      (find_entrypoint_for_type targ arg
                                        root_name entrypoint ctxt)
                                      (fun function_parameter =&gt;
                                        let '(ctxt, entrypoint, targ) :=
                                          function_parameter in
                                        Error_monad.op_gtgtquestion
                                          (merge_types legacy ctxt loc targ arg)
                                          (fun function_parameter =&gt;
                                            let '(targ, ctxt) :=
                                              function_parameter in
                                            __return ctxt targ entrypoint))))))
                    end))
          end))

with parse_contract_for_script {arg : Set}
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty arg)
  (contract : Alpha_context.Contract.t) (entrypoint : string) {struct legacy}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * option (Script_typed_ir.typed_contract arg))) :=
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists))
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Alpha_context.Contract.__exists ctxt contract)
        (fun function_parameter =&gt;
          match function_parameter with
          | false =&gt; Error_monad.__return (ctxt, None)
          | true =&gt;
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat (Error_monad.trace extensible_type_value)
                    (Alpha_context.Contract.get_script_code ctxt contract))
                  (fun function_parameter =&gt;
                    let '(ctxt, code) := function_parameter in
                    match code with
                    | None =&gt;
                      match entrypoint with
                      | &quot;default&quot; % string =&gt;
                        Lwt.__return
                          match ty_eq ctxt arg (Script_typed_ir.Unit_t None)
                            with
                          | Pervasives.Ok (Eq, ctxt) =&gt;
                            let contract := (arg, (contract, entrypoint)) in
                            Error_monad.ok (ctxt, (Some contract))
                          | Pervasives.Error _ =&gt;
                            Error_monad.op_gtgtquestion
                              (Alpha_context.Gas.consume ctxt
                                Typecheck_costs.cycle)
                              (fun ctxt =&gt; Error_monad.ok (ctxt, None))
                          end
                      | _ =&gt; Error_monad.__return (ctxt, None)
                      end
                    | Some code =&gt;
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Script.force_decode ctxt code)
                        (fun function_parameter =&gt;
                          let '(code, ctxt) := function_parameter in
                          Lwt.__return
                            match parse_toplevel true code with
                            | Pervasives.Error _ =&gt;
                              Error_monad.__error_value extensible_type_value
                            | Pervasives.Ok (arg_type, _, _, root_name) =&gt;
                              match parse_parameter_ty ctxt true arg_type with
                              | Pervasives.Error _ =&gt;
                                Error_monad.__error_value extensible_type_value
                              | Pervasives.Ok (Ex_ty targ, ctxt) =&gt;
                                match
                                  Error_monad.op_gtgtquestion
                                    (find_entrypoint_for_type targ arg root_name
                                      entrypoint ctxt)
                                    (fun function_parameter =&gt;
                                      let '(ctxt, entrypoint, targ) :=
                                        function_parameter in
                                      Error_monad.op_gtgtquestion
                                        (merge_types legacy ctxt loc targ arg)
                                        (fun function_parameter =&gt;
                                          let '(targ, ctxt) :=
                                            function_parameter in
                                          Error_monad.op_gtgtquestion
                                            (merge_types legacy ctxt loc targ
                                              arg)
                                            (fun function_parameter =&gt;
                                              let '(arg, ctxt) :=
                                                function_parameter in
                                              let contract :=
                                                (arg, (contract, entrypoint)) in
                                              Error_monad.ok
                                                (ctxt, (Some contract))))) with
                                | Pervasives.Ok res =&gt; Error_monad.ok res
                                | Pervasives.Error _ =&gt;
                                  Error_monad.op_gtgtquestion
                                    (ty_eq ctxt targ targ)
                                    (fun function_parameter =&gt;
                                      let '(Eq, ctxt) := function_parameter in
                                      Error_monad.op_gtgtquestion
                                        (merge_types legacy ctxt loc targ targ)
                                        (fun function_parameter =&gt;
                                          let '(_, ctxt) := function_parameter
                                            in
                                          Error_monad.ok (ctxt, None)))
                                end
                              end
                            end)
                    end))
          end))

with parse_toplevel (legacy : bool) (toplevel : Alpha_context.Script.expr)
  {struct legacy}
  : Error_monad.tzresult
    (Alpha_context.Script.node * Alpha_context.Script.node *
      Alpha_context.Script.node * option string) :=
  Pervasives.op_atat (Error_monad.record_trace extensible_type_value)
    match Micheline.root toplevel with
    | Micheline.Int loc _ =&gt; Error_monad.__error_value extensible_type_value
    | Micheline.String loc _ =&gt; Error_monad.__error_value extensible_type_value
    | Micheline.Bytes loc _ =&gt; Error_monad.__error_value extensible_type_value
    | Micheline.Prim loc _ _ _ =&gt;
      Error_monad.__error_value extensible_type_value
    | Micheline.Seq _ fields =&gt;
      let fix find_fields
        (p :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (s :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (c :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (fields :
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)) {struct p}
        : Error_monad.tzresult
          (option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot)) :=
        match fields with
        | [] =&gt; Error_monad.ok (p, s, c)
        | cons (Micheline.Int loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.String loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Bytes loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Seq loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_parameter (cons arg [])
              annot) rest =&gt;
          match p with
          | None =&gt; find_fields (Some (arg, loc, annot)) s c rest
          | Some _ =&gt; Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_storage (cons arg [])
              annot) rest =&gt;
          match s with
          | None =&gt; find_fields p (Some (arg, loc, annot)) c rest
          | Some _ =&gt; Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_code (cons arg []) annot)
            rest =&gt;
          match c with
          | None =&gt; find_fields p s (Some (arg, loc, annot)) rest
          | Some _ =&gt; Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc
              ((Alpha_context.Script.K_parameter |
              Alpha_context.Script.K_storage | Alpha_context.Script.K_code) as
                name) args _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Prim loc name _ _) _ =&gt;
          let allowed :=
            cons Alpha_context.Script.K_parameter
              (cons Alpha_context.Script.K_storage
                (cons Alpha_context.Script.K_code [])) in
          Error_monad.__error_value extensible_type_value
        end in
      Error_monad.op_gtgtquestion (find_fields None None None fields)
        (fun function_parameter =&gt;
          match function_parameter with
          | (None, _, _) =&gt; Error_monad.__error_value extensible_type_value
          | (Some _, None, _) =&gt; Error_monad.__error_value extensible_type_value
          | (Some _, Some _, None) =&gt;
            Error_monad.__error_value extensible_type_value
          |
            (Some (p, ploc, pannot), Some (s, sloc, sannot),
              Some (c, cloc, carrot)) =&gt;
            let maybe_root_name :=
              Error_monad.op_gtgtquestion
                (Script_ir_annot.extract_field_annot p)
                (fun function_parameter =&gt;
                  let '(p, root_name) := function_parameter in
                  match root_name with
                  | Some (Field_annot root_name) =&gt;
                    Error_monad.ok (p, pannot, (Some root_name))
                  | None =&gt;
                    match
                      (pannot,
                        match pannot with
                        | cons single [] =&gt;
                          Pervasives.op_andand
                            (Compare.Int.[Compare.S.op_gt]
                              (String.length single) 0)
                            (Compare.Char.[Compare.S.op_eq]
                              (String.get single 0) &quot;%&quot; % char)
                        | _ =&gt; false
                        end) with
                    | (cons single [], true) =&gt;
                      Error_monad.ok
                        (p, [],
                          (Some
                            (String.sub single 1
                              (Pervasives.op_minus (String.length single) 1))))
                    | (_, _) =&gt; Error_monad.ok (p, pannot, None)
                    end
                  end) in
            if legacy then
              let '(p, root_name) :=
                match maybe_root_name with
                | Pervasives.Ok (p, _, root_name) =&gt; (p, root_name)
                | Pervasives.Error _ =&gt; (p, None)
                end in
              Error_monad.ok (p, s, c, root_name)
            else
              Error_monad.op_gtgtquestion maybe_root_name
                (fun function_parameter =&gt;
                  let '(p, pannot, root_name) := function_parameter in
                  Error_monad.op_gtgtquestion
                    (Script_ir_annot.error_unexpected_annot ploc pannot)
                    (fun function_parameter =&gt;
                      let 'tt := function_parameter in
                      Error_monad.op_gtgtquestion
                        (Script_ir_annot.error_unexpected_annot cloc carrot)
                        (fun function_parameter =&gt;
                          let 'tt := function_parameter in
                          Error_monad.op_gtgtquestion
                            (Script_ir_annot.error_unexpected_annot sloc sannot)
                            (fun function_parameter =&gt;
                              let 'tt := function_parameter in
                              Error_monad.ok (p, s, c, root_name)))))
          end)
    end.

Definition parse_script
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (function_parameter : Alpha_context.Script.t)
  : Lwt.t (Error_monad.tzresult (ex_script * Alpha_context.context)) :=
  let '{|
    Alpha_context.Script.t.code := code;
      Alpha_context.Script.t.storage := storage
      |} := function_parameter in
  Error_monad.op_gtgteqquestion (Alpha_context.Script.force_decode ctxt code)
    (fun function_parameter =&gt;
      let '(code, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Alpha_context.Script.force_decode ctxt storage)
        (fun function_parameter =&gt;
          let '(storage, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Pervasives.op_atat Lwt.__return (parse_toplevel legacy code))
            (fun function_parameter =&gt;
              let '(arg_type, storage_type, code_field, root_name) :=
                function_parameter in
              Error_monad.op_gtgteqquestion
                (Error_monad.trace extensible_type_value
                  (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)))
                (fun function_parameter =&gt;
                  let '(Ex_ty arg_type, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (if legacy then
                      Error_monad.__return tt
                    else
                      Lwt.__return (well_formed_entrypoints arg_type root_name))
                    (fun function_parameter =&gt;
                      let 'tt := function_parameter in
                      Error_monad.op_gtgteqquestion
                        (Error_monad.trace extensible_type_value
                          (Lwt.__return
                            (parse_storage_ty ctxt legacy storage_type)))
                        (fun function_parameter =&gt;
                          let '(Ex_ty storage_type, ctxt) := function_parameter
                            in
                          let arg_annot :=
                            Script_ir_annot.default_annot
                              Script_ir_annot.default_param_annot
                              (Script_ir_annot.type_to_var_annot
                                (name_of_ty arg_type)) in
                          let storage_annot :=
                            Script_ir_annot.default_annot
                              Script_ir_annot.default_storage_annot
                              (Script_ir_annot.type_to_var_annot
                                (name_of_ty storage_type)) in
                          let arg_type_full :=
                            Script_typed_ir.Pair_t (arg_type, None, arg_annot)
                              (storage_type, None, storage_annot) None
                              (Pervasives.op_pipepipe (has_big_map arg_type)
                                (has_big_map storage_type)) in
                          let ret_type_full :=
                            Script_typed_ir.Pair_t
                              ((Script_typed_ir.List_t
                                (Script_typed_ir.Operation_t None) None false),
                                None, None) (storage_type, None, None) None
                              (has_big_map storage_type) in
                          Error_monad.op_gtgteqquestion
                            (Error_monad.trace_eval
                              (fun function_parameter =&gt;
                                let 'tt := function_parameter in
                                Error_monad.op_gtgtpipequestion
                                  (Pervasives.op_atat Lwt.__return
                                    (serialize_ty_for_error ctxt storage_type))
                                  (fun function_parameter =&gt;
                                    let '(storage_type, _ctxt) :=
                                      function_parameter in
                                    extensible_type_value))
                              (parse_data type_logger ctxt legacy storage_type
                                (Micheline.root storage)))
                            (fun function_parameter =&gt;
                              let '(storage, ctxt) := function_parameter in
                              Error_monad.op_gtgteqquestion
                                (Error_monad.trace extensible_type_value
                                  (parse_returning type_logger
                                    (Toplevel
                                      {|
                                        tc_context.Toplevel.storage_type :=
                                          storage_type;
                                        tc_context.Toplevel.param_type :=
                                          arg_type;
                                        tc_context.Toplevel.root_name :=
                                          root_name;
                                        tc_context.Toplevel.legacy_create_contract_literal :=
                                          false |}) ctxt legacy
                                    (arg_type_full, None) ret_type_full
                                    code_field))
                                (fun function_parameter =&gt;
                                  let '(code, ctxt) := function_parameter in
                                  Error_monad.__return
                                    ((Ex_script
                                      {| Script_typed_ir.script.code := code;
                                        Script_typed_ir.script.arg_type :=
                                          arg_type;
                                        Script_typed_ir.script.storage :=
                                          storage;
                                        Script_typed_ir.script.storage_type :=
                                          storage_type;
                                        Script_typed_ir.script.root_name :=
                                          root_name |}), ctxt))))))))).

Definition typecheck_code
  (ctxt : Alpha_context.context) (code : Alpha_context.Script.expr)
  : Lwt.t
    (Error_monad.tzresult (Script_tc_errors.type_map * Alpha_context.context)) :=
  let legacy := false in
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return (parse_toplevel legacy code))
    (fun function_parameter =&gt;
      let '(arg_type, storage_type, code_field, root_name) := function_parameter
        in
      let type_map := Pervasives.__ref_value [] in
      Error_monad.op_gtgteqquestion
        (Error_monad.trace extensible_type_value
          (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)))
        (fun function_parameter =&gt;
          let '(Ex_ty arg_type, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (if legacy then
              Error_monad.__return tt
            else
              Lwt.__return (well_formed_entrypoints arg_type root_name))
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion
                (Error_monad.trace extensible_type_value
                  (Lwt.__return (parse_storage_ty ctxt legacy storage_type)))
                (fun function_parameter =&gt;
                  let '(Ex_ty storage_type, ctxt) := function_parameter in
                  let arg_annot :=
                    Script_ir_annot.default_annot
                      Script_ir_annot.default_param_annot
                      (Script_ir_annot.type_to_var_annot (name_of_ty arg_type))
                    in
                  let storage_annot :=
                    Script_ir_annot.default_annot
                      Script_ir_annot.default_storage_annot
                      (Script_ir_annot.type_to_var_annot
                        (name_of_ty storage_type)) in
                  let arg_type_full :=
                    Script_typed_ir.Pair_t (arg_type, None, arg_annot)
                      (storage_type, None, storage_annot) None
                      (Pervasives.op_pipepipe (has_big_map arg_type)
                        (has_big_map storage_type)) in
                  let ret_type_full :=
                    Script_typed_ir.Pair_t
                      ((Script_typed_ir.List_t
                        (Script_typed_ir.Operation_t None) None false), None,
                        None) (storage_type, None, None) None
                      (has_big_map storage_type) in
                  let __result_value :=
                    parse_returning
                      (Some
                        (fun loc =&gt;
                          fun bef =&gt;
                            fun aft =&gt;
                              Pervasives.op_coloneq type_map
                                (cons (loc, (bef, aft))
                                  (Pervasives.op_exclamation type_map))))
                      (Toplevel
                        {| tc_context.Toplevel.storage_type := storage_type;
                          tc_context.Toplevel.param_type := arg_type;
                          tc_context.Toplevel.root_name := root_name;
                          tc_context.Toplevel.legacy_create_contract_literal :=
                            false |}) ctxt legacy (arg_type_full, None)
                      ret_type_full code_field in
                  Error_monad.op_gtgteqquestion
                    (Error_monad.trace extensible_type_value __result_value)
                    (fun function_parameter =&gt;
                      let '(Script_typed_ir.Lam _ _, ctxt) := function_parameter
                        in
                      Error_monad.__return
                        ((Pervasives.op_exclamation type_map), ctxt)))))).

Definition typecheck_data
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (function_parameter : Alpha_context.Script.expr * Alpha_context.Script.expr)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let '(data, exp_ty) := function_parameter in
  let legacy := false in
  Error_monad.op_gtgteqquestion
    (Error_monad.trace extensible_type_value
      (Pervasives.op_atat Lwt.__return
        (parse_packable_ty ctxt legacy (Micheline.root exp_ty))))
    (fun function_parameter =&gt;
      let '(Ex_ty exp_ty, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Error_monad.trace_eval
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Pervasives.op_atat Lwt.__return
                (serialize_ty_for_error ctxt exp_ty))
              (fun function_parameter =&gt;
                let '(exp_ty, _ctxt) := function_parameter in
                extensible_type_value))
          (parse_data type_logger ctxt legacy exp_ty (Micheline.root data)))
        (fun function_parameter =&gt;
          let '(_, ctxt) := function_parameter in
          Error_monad.__return ctxt)).

Definition Entrypoints_map :=
  Map.Make
    (existT _ _
      {|
        Compare.COMPARABLE.compare := String.compare
        |}).

Definition list_entrypoints {A : Set}
  (full : Script_typed_ir.ty A) (ctxt : Alpha_context.context)
  (root_name : option Entrypoints_map.[S.MAP.key])
  : Error_monad.tzresult
    (list (list Alpha_context.Script.prim) *
      Entrypoints_map.[S.MAP.t]
        (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
  let merge {B C : Set}
    (path : list B)
    (annot : option (* `Field_annot *) Entrypoints_map.[S.MAP.key])
    (ty : Script_typed_ir.ty C) (reachable : bool)
    (function_parameter :
      list (list B) *
        Entrypoints_map.[S.MAP.t] (list B * Alpha_context.Script.node))
    : Error_monad.tzresult
      (list (list B) *
        Entrypoints_map.[S.MAP.t] (list B * Alpha_context.Script.node)) :=
    let '(unreachables, all) as acc := function_parameter in
    match annot with
    | None | Some (Field_annot &quot;&quot; % string) =&gt;
      Pervasives.op_atat Error_monad.ok
        (if reachable then
          acc
        else
          match ty with
          | Script_typed_ir.Union_t _ _ _ _ =&gt; acc
          | _ =&gt; ((cons (List.rev path) unreachables), all)
          end)
    | Some (Field_annot name) =&gt;
      if Compare.Int.[Compare.S.op_gt] (String.length name) 31 then
        Error_monad.ok ((cons (List.rev path) unreachables), all)
      else
        if Entrypoints_map.[S.MAP.mem] name all then
          Error_monad.ok ((cons (List.rev path) unreachables), all)
        else
          Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ty)
            (fun function_parameter =&gt;
              let '(unparsed_ty, _) := function_parameter in
              Error_monad.ok
                (unreachables,
                  (Entrypoints_map.[S.MAP.add] name
                    ((List.rev path), unparsed_ty) all)))
    end in
  let fix fold_tree {t : Set}
    (t : Script_typed_ir.ty t) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc :
      list (list Alpha_context.Script.prim) *
        Entrypoints_map.[S.MAP.t]
          (list Alpha_context.Script.prim * Alpha_context.Script.node))
    {struct t}
    : Error_monad.tzresult
      (list (list Alpha_context.Script.prim) *
        Entrypoints_map.[S.MAP.t]
          (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
    match t with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =&gt;
      Error_monad.op_gtgtquestion
        (merge (cons Alpha_context.Script.D_Left path) al tl reachable acc)
        (fun acc =&gt;
          Error_monad.op_gtgtquestion
            (merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc)
            (fun acc =&gt;
              Error_monad.op_gtgtquestion
                (fold_tree tl (cons Alpha_context.Script.D_Left path)
                  match al with
                  | Some _ =&gt; true
                  | None =&gt; reachable
                  end acc)
                (fun acc =&gt;
                  fold_tree tr (cons Alpha_context.Script.D_Right path)
                    match ar with
                    | Some _ =&gt; true
                    | None =&gt; reachable
                    end acc)))
    | _ =&gt; Error_monad.ok acc
    end in
  Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt full)
    (fun function_parameter =&gt;
      let '(unparsed_full, _) := function_parameter in
      let '(init, reachable) :=
        match root_name with
        | None | Some &quot;&quot; % string =&gt; (Entrypoints_map.[S.MAP.empty], false)
        | Some name =&gt;
          ((Entrypoints_map.[S.MAP.singleton] name ([], unparsed_full)), true)
        end in
      fold_tree full [] reachable ([], init)).

Fixpoint unparse_data {a : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (ty : Script_typed_ir.ty a) (a : a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.cycle))
    (fun ctxt =&gt;
      match (ty, a) with
      | (Script_typed_ir.Unit_t _, tt) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Unparse_costs.__unit_value))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_Unit [] []), ctxt))
      | (Script_typed_ir.Int_t _, v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Unparse_costs.int v)))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt))
      | (Script_typed_ir.Nat_t _, v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Unparse_costs.int v)))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt))
      | (Script_typed_ir.String_t _, s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt (Unparse_costs.__string_value s)))
          (fun ctxt =&gt; Error_monad.__return ((Micheline.String (-1) s), ctxt))
      | (Script_typed_ir.Bytes_t _, s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt (Unparse_costs.__bytes_value s)))
          (fun ctxt =&gt; Error_monad.__return ((Micheline.Bytes (-1) s), ctxt))
      | (Script_typed_ir.Bool_t _, true) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Unparse_costs.__bool_value))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_True [] []), ctxt))
      | (Script_typed_ir.Bool_t _, false) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Unparse_costs.__bool_value))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_False [] []), ctxt))
      | (Script_typed_ir.Timestamp_t _, t) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt (Unparse_costs.timestamp t)))
          (fun ctxt =&gt;
            match mode with
            | Optimized =&gt;
              Error_monad.__return
                ((Micheline.Int (-1) (Alpha_context.Script_timestamp.to_zint t)),
                  ctxt)
            | Readable =&gt;
              match Alpha_context.Script_timestamp.to_notation t with
              | None =&gt;
                Error_monad.__return
                  ((Micheline.Int (-1)
                    (Alpha_context.Script_timestamp.to_zint t)), ctxt)
              | Some s =&gt; Error_monad.__return ((Micheline.String (-1) s), ctxt)
              end
            end)
      | (Script_typed_ir.Address_t _, (c, entrypoint)) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract))
          (fun ctxt =&gt;
            match mode with
            | Optimized =&gt;
              let entrypoint :=
                match entrypoint with
                | &quot;default&quot; % string =&gt; &quot;&quot; % string
                | name =&gt; name
                end in
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  (Data_encoding.tup2 Alpha_context.Contract.encoding
                    Data_encoding.__Variable.__string_value) (c, entrypoint) in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =&gt;
              let notation :=
                match entrypoint with
                | &quot;default&quot; % string =&gt; Alpha_context.Contract.to_b58check c
                | entrypoint =&gt;
                  Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
                    (Pervasives.op_caret &quot;%&quot; % string entrypoint)
                end in
              Error_monad.__return ((Micheline.String (-1) notation), ctxt)
            end)
      | (Script_typed_ir.Contract_t _ _, (_, (c, entrypoint))) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract))
          (fun ctxt =&gt;
            match mode with
            | Optimized =&gt;
              let entrypoint :=
                match entrypoint with
                | &quot;default&quot; % string =&gt; &quot;&quot; % string
                | name =&gt; name
                end in
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  (Data_encoding.tup2 Alpha_context.Contract.encoding
                    Data_encoding.__Variable.__string_value) (c, entrypoint) in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =&gt;
              let notation :=
                match entrypoint with
                | &quot;default&quot; % string =&gt; Alpha_context.Contract.to_b58check c
                | entrypoint =&gt;
                  Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
                    (Pervasives.op_caret &quot;%&quot; % string entrypoint)
                end in
              Error_monad.__return ((Micheline.String (-1) notation), ctxt)
            end)
      | (Script_typed_ir.Signature_t _, s) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.signature))
          (fun ctxt =&gt;
            match mode with
            | Optimized =&gt;
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn Signature.encoding s in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =&gt;
              Error_monad.__return
                ((Micheline.String (-1) (Signature.to_b58check s)), ctxt)
            end)
      | (Script_typed_ir.Mutez_t _, v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.tez))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Micheline.Int (-1) (Z.of_int64 (Alpha_context.Tez.to_mutez v))),
                ctxt))
      | (Script_typed_ir.Key_t _, k) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.key))
          (fun ctxt =&gt;
            match mode with
            | Optimized =&gt;
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  Signature.Public_key.[S.SPublic_key.encoding] k in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =&gt;
              Error_monad.__return
                ((Micheline.String (-1)
                  (Signature.Public_key.[S.SPublic_key.to_b58check] k)), ctxt)
            end)
      | (Script_typed_ir.Key_hash_t _, k) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.key_hash))
          (fun ctxt =&gt;
            match mode with
            | Optimized =&gt;
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  Signature.Public_key_hash.[S.SPublic_key_hash.encoding] k in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =&gt;
              Error_monad.__return
                ((Micheline.String (-1)
                  (Signature.Public_key_hash.[S.SPublic_key_hash.to_b58check] k)),
                  ctxt)
            end)
      | (Script_typed_ir.Operation_t _, (op, _big_map_diff)) =&gt;
        let __bytes_value :=
          Data_encoding.Binary.to_bytes_exn
            Alpha_context.Operation.internal_operation_encoding op in
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Unparse_costs.operation __bytes_value)))
          (fun ctxt =&gt;
            Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt))
      | (Script_typed_ir.Chain_id_t _, chain_id) =&gt;
        let __bytes_value :=
          Data_encoding.Binary.to_bytes_exn Chain_id.[S.HASH.encoding] chain_id
          in
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Unparse_costs.chain_id __bytes_value)))
          (fun ctxt =&gt;
            Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt))
      | (Script_typed_ir.Pair_t (tl, _, _) (tr, _, _) _ _, (l, r)) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.pair))
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode tl l)
              (fun function_parameter =&gt;
                let '(l, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion (unparse_data ctxt mode tr r)
                  (fun function_parameter =&gt;
                    let '(r, ctxt) := function_parameter in
                    Error_monad.__return
                      ((Micheline.Prim (-1) Alpha_context.Script.D_Pair
                        (cons l (cons r [])) []), ctxt))))
      | (Script_typed_ir.Union_t (tl, _) _ _ _, Script_typed_ir.L l) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.union))
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode tl l)
              (fun function_parameter =&gt;
                let '(l, ctxt) := function_parameter in
                Error_monad.__return
                  ((Micheline.Prim (-1) Alpha_context.Script.D_Left (cons l [])
                    []), ctxt)))
      | (Script_typed_ir.Union_t _ (tr, _) _ _, Script_typed_ir.R r) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.union))
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode tr r)
              (fun function_parameter =&gt;
                let '(r, ctxt) := function_parameter in
                Error_monad.__return
                  ((Micheline.Prim (-1) Alpha_context.Script.D_Right (cons r [])
                    []), ctxt)))
      | (Script_typed_ir.Option_t t _ _, Some v) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.some))
          (fun ctxt =&gt;
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode t v)
              (fun function_parameter =&gt;
                let '(v, ctxt) := function_parameter in
                Error_monad.__return
                  ((Micheline.Prim (-1) Alpha_context.Script.D_Some (cons v [])
                    []), ctxt)))
      | (Script_typed_ir.Option_t _ _ _, None) =&gt;
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.none))
          (fun ctxt =&gt;
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_None [] []), ctxt))
      | (Script_typed_ir.List_t t _ _, items) =&gt;
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =&gt;
              let '(l, ctxt) := function_parameter in
              fun element =&gt;
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.list_element))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion
                      (unparse_data ctxt mode t element)
                      (fun function_parameter =&gt;
                        let '(unparsed, ctxt) := function_parameter in
                        Error_monad.__return ((cons unparsed l), ctxt))))
            ([], ctxt) items)
          (fun function_parameter =&gt;
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) (List.rev items)), ctxt))
      | (Script_typed_ir.Set_t t _, set) =&gt;
        let t := ty_of_comparable_ty t in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =&gt;
              let '(l, ctxt) := function_parameter in
              fun item =&gt;
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.set_element))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion
                      (unparse_data ctxt mode t item)
                      (fun function_parameter =&gt;
                        let '(item, ctxt) := function_parameter in
                        Error_monad.__return ((cons item l), ctxt)))) ([], ctxt)
            (set_fold (fun e =&gt; fun acc =&gt; cons e acc) set []))
          (fun function_parameter =&gt;
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) items), ctxt))
      | (Script_typed_ir.Map_t kt vt _ _, map) =&gt;
        let kt := ty_of_comparable_ty kt in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =&gt;
              let '(l, ctxt) := function_parameter in
              fun function_parameter =&gt;
                let '(k, v) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.map_element))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion (unparse_data ctxt mode kt k)
                      (fun function_parameter =&gt;
                        let '(key, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (unparse_data ctxt mode vt v)
                          (fun function_parameter =&gt;
                            let '(value, ctxt) := function_parameter in
                            Error_monad.__return
                              ((cons
                                (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                                  (cons key (cons value [])) []) l), ctxt)))))
            ([], ctxt)
            (map_fold (fun k =&gt; fun v =&gt; fun acc =&gt; cons (k, v) acc) map []))
          (fun function_parameter =&gt;
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) items), ctxt))
      |
        (Script_typed_ir.Big_map_t kt vt _, {|
          Script_typed_ir.big_map.id := None;
            Script_typed_ir.big_map.diff := Diff
            |}) =&gt;
        let kt := ty_of_comparable_ty kt in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =&gt;
              let '(l, ctxt) := function_parameter in
              fun function_parameter =&gt;
                let '(k, v) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.map_element))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion (unparse_data ctxt mode kt k)
                      (fun function_parameter =&gt;
                        let '(key, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (unparse_data ctxt mode vt v)
                          (fun function_parameter =&gt;
                            let '(value, ctxt) := function_parameter in
                            Error_monad.__return
                              ((cons
                                (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                                  (cons key (cons value [])) []) l), ctxt)))))
            ([], ctxt)
            (Diff.[Script_typed_ir.Boxed_map.OPS].(S.MAP.fold)
              (fun k =&gt;
                fun v =&gt;
                  fun acc =&gt;
                    match v with
                    | None =&gt; acc
                    | Some v =&gt; cons (k, v) acc
                    end) (Pervasives.fst Diff.[Script_typed_ir.Boxed_map.boxed])
              []))
          (fun function_parameter =&gt;
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) items), ctxt))
      |
        (Script_typed_ir.Big_map_t _kt _kv _, {|
          Script_typed_ir.big_map.id := Some id;
            Script_typed_ir.big_map.diff := Diff
            |}) =&gt;
        if
          Compare.Int.[Compare.S.op_eq]
            (Diff.[Script_typed_ir.Boxed_map.OPS].(S.MAP.cardinal)
              (Pervasives.fst Diff.[Script_typed_ir.Boxed_map.boxed])) 0 then
          Error_monad.__return ((Micheline.Int (-1) id), ctxt)
        else
          (* ‚ùå Assert instruction is not handled. *)
          assert false
      | (Script_typed_ir.Lambda_t _ _ _, Script_typed_ir.Lam _ original_code) =&gt;
        unparse_code ctxt mode original_code
      end)

with unparse_code (ctxt : Alpha_context.context) (mode : unparsing_mode)
  {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Micheline.node Z Alpha_context.Script.prim * Alpha_context.context)) :=
  let legacy := true in
  fun function_parameter =&gt;
    match function_parameter with
    |
      Micheline.Prim loc Alpha_context.Script.I_PUSH (cons ty (cons data []))
        annot =&gt;
      Error_monad.op_gtgteqquestion
        (Lwt.__return (parse_packable_ty ctxt legacy ty))
        (fun function_parameter =&gt;
          let '(Ex_ty t, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion (parse_data None ctxt legacy t data)
            (fun function_parameter =&gt;
              let '(data, ctxt) := function_parameter in
              Error_monad.op_gtgteqquestion (unparse_data ctxt mode t data)
                (fun function_parameter =&gt;
                  let '(data, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Unparse_costs.prim_cost 2 annot)))
                    (fun ctxt =&gt;
                      Error_monad.__return
                        ((Micheline.Prim loc Alpha_context.Script.I_PUSH
                          (cons ty (cons data [])) annot), ctxt)))))
    | Micheline.Seq loc items =&gt;
      Error_monad.op_gtgteqquestion
        (Error_monad.fold_left_s
          (fun function_parameter =&gt;
            let '(l, ctxt) := function_parameter in
            fun item =&gt;
              Error_monad.op_gtgteqquestion (unparse_code ctxt mode item)
                (fun function_parameter =&gt;
                  let '(item, ctxt) := function_parameter in
                  Error_monad.__return ((cons item l), ctxt))) ([], ctxt) items)
        (fun function_parameter =&gt;
          let '(items, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Unparse_costs.seq_cost (List.length items))))
            (fun ctxt =&gt;
              Error_monad.__return ((Micheline.Seq loc (List.rev items)), ctxt)))
    | Micheline.Prim loc prim items annot =&gt;
      Error_monad.op_gtgteqquestion
        (Error_monad.fold_left_s
          (fun function_parameter =&gt;
            let '(l, ctxt) := function_parameter in
            fun item =&gt;
              Error_monad.op_gtgteqquestion (unparse_code ctxt mode item)
                (fun function_parameter =&gt;
                  let '(item, ctxt) := function_parameter in
                  Error_monad.__return ((cons item l), ctxt))) ([], ctxt) items)
        (fun function_parameter =&gt;
          let '(items, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 3 annot)))
            (fun ctxt =&gt;
              Error_monad.__return
                ((Micheline.Prim loc prim (List.rev items) annot), ctxt)))
    | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom
      =&gt; Error_monad.__return (atom, ctxt)
    end.

Definition unparse_script {A B : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (function_parameter : Script_typed_ir.script A B)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.t * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.script.code := code;
      Script_typed_ir.script.arg_type := arg_type;
      Script_typed_ir.script.storage := storage;
      Script_typed_ir.script.storage_type := storage_type;
      Script_typed_ir.script.root_name := root_name
      |} := function_parameter in
  let 'Script_typed_ir.Lam _ original_code := code in
  Error_monad.op_gtgteqquestion (unparse_code ctxt mode original_code)
    (fun function_parameter =&gt;
      let '(code, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (unparse_data ctxt mode storage_type storage)
        (fun function_parameter =&gt;
          let '(storage, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion (unparse_ty ctxt arg_type)
            (fun function_parameter =&gt;
              let '(arg_type, ctxt) := function_parameter in
              Error_monad.op_gtgteqquestion (unparse_ty ctxt storage_type)
                (fun function_parameter =&gt;
                  let '(storage_type, ctxt) := function_parameter in
                  let arg_type :=
                    add_field_annot
                      (Option.map
                        (fun n =&gt;
                          (* ‚ùå Variants not supported *)
                          (* ‚ùå `Field_annot *)
                          n) root_name) None arg_type in
                  let code :=
                    Micheline.Seq (-1)
                      (cons
                        (Micheline.Prim (-1) Alpha_context.Script.K_parameter
                          (cons arg_type []) [])
                        (cons
                          (Micheline.Prim (-1) Alpha_context.Script.K_storage
                            (cons storage_type []) [])
                          (cons
                            (Micheline.Prim (-1) Alpha_context.Script.K_code
                              (cons code []) []) []))) in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Error_monad.op_gtgtquestion
                        (Alpha_context.Gas.consume ctxt
                          (Unparse_costs.seq_cost 3))
                        (fun ctxt =&gt;
                          Error_monad.op_gtgtquestion
                            (Alpha_context.Gas.consume ctxt
                              (Unparse_costs.prim_cost 1 []))
                            (fun ctxt =&gt;
                              Error_monad.op_gtgtquestion
                                (Alpha_context.Gas.consume ctxt
                                  (Unparse_costs.prim_cost 1 []))
                                (fun ctxt =&gt;
                                  Alpha_context.Gas.consume ctxt
                                    (Unparse_costs.prim_cost 1 []))))))
                    (fun ctxt =&gt;
                      Error_monad.__return
                        ({|
                          Alpha_context.Script.t.code :=
                            Alpha_context.Script.lazy_expr
                              (Micheline.strip_locations code);
                          Alpha_context.Script.t.storage :=
                            Alpha_context.Script.lazy_expr
                              (Micheline.strip_locations storage) |}, ctxt)))))).

Definition pack_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty A) (data : A)
  : Lwt.t (Error_monad.tzresult (MBytes.t * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion (unparse_data ctxt Optimized typ data)
    (fun function_parameter =&gt;
      let '(unparsed, ctxt) := function_parameter in
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn Alpha_context.Script.expr_encoding
          (Micheline.strip_locations unparsed) in
      Error_monad.op_gtgteqquestion
        (Pervasives.op_atat Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Alpha_context.Script.serialized_cost __bytes_value)))
        (fun ctxt =&gt;
          let __bytes_value :=
            MBytes.concat &quot;&quot; % string
              (cons (MBytes.of_string &quot;\005&quot; % string) (cons __bytes_value []))
            in
          Error_monad.op_gtgteqquestion
            (Pervasives.op_atat Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Alpha_context.Script.serialized_cost __bytes_value)))
            (fun ctxt =&gt; Error_monad.__return (__bytes_value, ctxt)))).

Definition hash_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty A) (data : A)
  : Lwt.t (Error_monad.tzresult (Script_expr_hash.t * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion (pack_data ctxt typ data)
    (fun function_parameter =&gt;
      let '(__bytes_value, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Pervasives.op_atat Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Michelson_v1_gas.Cost_of.Legacy.__hash_value __bytes_value
              Script_expr_hash.size)))
        (fun ctxt =&gt;
          Error_monad.__return
            ((Script_expr_hash.hash_bytes None (cons __bytes_value [])), ctxt))).

Definition empty_big_map {A B : Set}
  (tk : Script_typed_ir.comparable_ty A) (tv : Script_typed_ir.ty B)
  : Script_typed_ir.big_map A B :=
  {| Script_typed_ir.big_map.id := None;
    Script_typed_ir.big_map.diff := empty_map tk;
    Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
    Script_typed_ir.big_map.value_type := tv |}.

Definition big_map_mem {A B : Set}
  (ctxt : Alpha_context.context) (key : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (bool * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type
      |} := function_parameter in
  match ((map_get key diff), id) with
  | (None, None) =&gt; Error_monad.__return (false, ctxt)
  | (None, Some id) =&gt;
    Error_monad.op_gtgteqquestion (hash_data ctxt key_type key)
      (fun function_parameter =&gt;
        let '(__hash_value, ctxt) := function_parameter in
        Error_monad.op_gtgteqquestion
          (Alpha_context.Big_map.mem ctxt id __hash_value)
          (fun function_parameter =&gt;
            let '(ctxt, res) := function_parameter in
            Error_monad.__return (res, ctxt)))
  | (Some None, _) =&gt; Error_monad.__return (false, ctxt)
  | (Some (Some _), _) =&gt; Error_monad.__return (true, ctxt)
  end.

Definition big_map_get {A B : Set}
  (ctxt : Alpha_context.context) (key : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (option B * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  match ((map_get key diff), id) with
  | (Some x, _) =&gt; Error_monad.__return (x, ctxt)
  | (None, None) =&gt; Error_monad.__return (None, ctxt)
  | (None, Some id) =&gt;
    Error_monad.op_gtgteqquestion (hash_data ctxt key_type key)
      (fun function_parameter =&gt;
        let '(__hash_value, ctxt) := function_parameter in
        Error_monad.op_gtgteqquestion
          (Alpha_context.Big_map.get_opt ctxt id __hash_value)
          (fun function_parameter =&gt;
            match function_parameter with
            | (ctxt, None) =&gt; Error_monad.__return (None, ctxt)
            | (ctxt, Some value) =&gt;
              Error_monad.op_gtgteqquestion
                (parse_data None ctxt true value_type (Micheline.root value))
                (fun function_parameter =&gt;
                  let '(x, ctxt) := function_parameter in
                  Error_monad.__return ((Some x), ctxt))
            end))
  end.

Definition big_map_update {A B : Set}
  (key : A) (value : option B)
  (function_parameter : Script_typed_ir.big_map A B)
  : Script_typed_ir.big_map A B :=
  let '{| Script_typed_ir.big_map.diff := diff |} as map := function_parameter
    in
  (* ‚ùå Record substitution not handled *)
  record_substitution.

Definition Ids :=
  __Set.Make
    (existT _ _
      {|
        Compare.COMPARABLE.compare := Compare.Z.[Compare.S.compare]
        |}).

Definition big_map_ids := Ids.[S.SET.t].

Definition no_big_map_id : Ids.[S.SET.t] := Ids.[S.SET.empty].

Definition diff_of_big_map {A B : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context -&gt;
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : Ids.[S.SET.t])
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t
    (Error_monad.tzresult
      (list Alpha_context.Contract.big_map_diff_item * Alpha_context.Big_map.id
        * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  Error_monad.op_gtgteqquestion
    (Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Michelson_v1_gas.Cost_of.Legacy.map_to_list diff)))
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        match id with
        | Some id =&gt;
          if Ids.[S.SET.mem] id ids then
            Error_monad.op_gtgteqquestion (fresh ctxt)
              (fun function_parameter =&gt;
                let '(ctxt, duplicate) := function_parameter in
                Error_monad.__return
                  (ctxt, (cons (Alpha_context.Contract.Copy id duplicate) []),
                    duplicate))
          else
            Error_monad.__return (ctxt, [], id)
        | None =&gt;
          Error_monad.op_gtgteqquestion (fresh ctxt)
            (fun function_parameter =&gt;
              let '(ctxt, id) := function_parameter in
              Error_monad.op_gtgteqquestion (unparse_ty ctxt key_type)
                (fun function_parameter =&gt;
                  let '(kt, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion (unparse_ty ctxt value_type)
                    (fun function_parameter =&gt;
                      let '(kv, ctxt) := function_parameter in
                      Error_monad.__return
                        (ctxt,
                          (cons
                            (Alpha_context.Contract.Alloc
                              {|
                                Alpha_context.Contract.big_map_diff_item.Alloc.big_map :=
                                  id;
                                Alpha_context.Contract.big_map_diff_item.Alloc.key_type :=
                                  Micheline.strip_locations kt;
                                Alpha_context.Contract.big_map_diff_item.Alloc.value_type :=
                                  Micheline.strip_locations kv |}) []), id))))
        end
        (fun function_parameter =&gt;
          let '(ctxt, init, big_map) := function_parameter in
          let pairs :=
            map_fold (fun key =&gt; fun value =&gt; fun acc =&gt; cons (key, value) acc)
              diff [] in
          Error_monad.op_gtgteqquestion
            (Error_monad.fold_left_s
              (fun function_parameter =&gt;
                let '(acc, ctxt) := function_parameter in
                fun function_parameter =&gt;
                  let '(key, value) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
                    (fun ctxt =&gt;
                      Error_monad.op_gtgteqquestion
                        (hash_data ctxt key_type key)
                        (fun function_parameter =&gt;
                          let '(diff_key_hash, ctxt) := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (unparse_data ctxt mode key_type key)
                            (fun function_parameter =&gt;
                              let '(key_node, ctxt) := function_parameter in
                              let diff_key := Micheline.strip_locations key_node
                                in
                              Error_monad.op_gtgteqquestion
                                match value with
                                | None =&gt; Error_monad.__return (None, ctxt)
                                | Some x =&gt;
                                  Error_monad.op_gtgteqquestion
                                    (unparse_data ctxt mode value_type x)
                                    (fun function_parameter =&gt;
                                      let '(node, ctxt) := function_parameter in
                                      Error_monad.__return
                                        ((Some (Micheline.strip_locations node)),
                                          ctxt))
                                end
                                (fun function_parameter =&gt;
                                  let '(diff_value, ctxt) := function_parameter
                                    in
                                  let diff_item :=
                                    Alpha_context.Contract.Update
                                      {|
                                        Alpha_context.Contract.big_map_diff_item.Update.big_map :=
                                          big_map;
                                        Alpha_context.Contract.big_map_diff_item.Update.diff_key :=
                                          diff_key;
                                        Alpha_context.Contract.big_map_diff_item.Update.diff_key_hash :=
                                          diff_key_hash;
                                        Alpha_context.Contract.big_map_diff_item.Update.diff_value :=
                                          diff_value |} in
                                  Error_monad.__return
                                    ((cons diff_item acc), ctxt)))))) ([], ctxt)
              pairs)
            (fun function_parameter =&gt;
              let '(diff, ctxt) := function_parameter in
              Error_monad.__return ((Pervasives.op_at init diff), big_map, ctxt)))).

Fixpoint extract_big_map_updates {a : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context -&gt;
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : Ids.[S.SET.t])
  (acc : list Alpha_context.Contract.big_map_diff) (ty : Script_typed_ir.ty a)
  (x : a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * a * Ids.[S.SET.t] *
        list Alpha_context.Contract.big_map_diff)) :=
  match (ty, x) with
  | (Script_typed_ir.Big_map_t _ _ _, map) =&gt;
    Error_monad.op_gtgteqquestion (diff_of_big_map ctxt fresh mode ids map)
      (fun function_parameter =&gt;
        let '(diff, id, ctxt) := function_parameter in
        let Map := Script_typed_ir.big_map.diff map in
        let map :=
          (* ‚ùå Record substitution not handled *)
          record_substitution in
        Error_monad.__return
          (ctxt, map, (Ids.[S.SET.add] id ids), (cons diff acc)))
  | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, (xl, xr)) =&gt;
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =&gt;
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc tyl xl)
          (fun function_parameter =&gt;
            let '(ctxt, xl, ids, acc) := function_parameter in
            Error_monad.op_gtgteqquestion
              (extract_big_map_updates ctxt fresh mode ids acc tyr xr)
              (fun function_parameter =&gt;
                let '(ctxt, xr, ids, acc) := function_parameter in
                Error_monad.__return (ctxt, (xl, xr), ids, acc))))
  | (Script_typed_ir.Union_t (ty, _) (_, _) _ true, Script_typed_ir.L x) =&gt;
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =&gt;
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc ty x)
          (fun function_parameter =&gt;
            let '(ctxt, x, ids, acc) := function_parameter in
            Error_monad.__return (ctxt, (Script_typed_ir.L x), ids, acc)))
  | (Script_typed_ir.Union_t (_, _) (ty, _) _ true, Script_typed_ir.R x) =&gt;
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =&gt;
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc ty x)
          (fun function_parameter =&gt;
            let '(ctxt, x, ids, acc) := function_parameter in
            Error_monad.__return (ctxt, (Script_typed_ir.R x), ids, acc)))
  | (Script_typed_ir.Option_t ty _ true, Some x) =&gt;
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =&gt;
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc ty x)
          (fun function_parameter =&gt;
            let '(ctxt, x, ids, acc) := function_parameter in
            Error_monad.__return (ctxt, (Some x), ids, acc)))
  | (Script_typed_ir.List_t ty _ true, l) =&gt;
    Error_monad.op_gtgteqquestion
      (Error_monad.fold_left_s
        (fun function_parameter =&gt;
          let '(ctxt, l, ids, acc) := function_parameter in
          fun x =&gt;
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
              (fun ctxt =&gt;
                Error_monad.op_gtgteqquestion
                  (extract_big_map_updates ctxt fresh mode ids acc ty x)
                  (fun function_parameter =&gt;
                    let '(ctxt, x, ids, acc) := function_parameter in
                    Error_monad.__return (ctxt, (cons x l), ids, acc))))
        (ctxt, [], ids, acc) l)
      (fun function_parameter =&gt;
        let '(ctxt, l, ids, acc) := function_parameter in
        Error_monad.__return (ctxt, (List.rev l), ids, acc))
  | (Script_typed_ir.Map_t _ ty _ true, M as m) =&gt;
    Error_monad.op_gtgteqquestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Michelson_v1_gas.Cost_of.Legacy.map_to_list m)))
      (fun ctxt =&gt;
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =&gt;
              let '(ctxt, m, ids, acc) := function_parameter in
              fun function_parameter =&gt;
                let '(k, x) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
                  (fun ctxt =&gt;
                    Error_monad.op_gtgteqquestion
                      (extract_big_map_updates ctxt fresh mode ids acc ty x)
                      (fun function_parameter =&gt;
                        let '(ctxt, x, ids, acc) := function_parameter in
                        Error_monad.__return
                          (ctxt,
                            (M.[Script_typed_ir.Boxed_map.OPS].(S.MAP.add) k x m),
                            ids, acc))))
            (ctxt, M.[Script_typed_ir.Boxed_map.OPS].(S.MAP.empty), ids, acc)
            (M.[Script_typed_ir.Boxed_map.OPS].(S.MAP.bindings)
              (Pervasives.fst M.[Script_typed_ir.Boxed_map.boxed])))
          (fun function_parameter =&gt;
            let '(ctxt, m, ids, acc) := function_parameter in
            let M :=
              let OPS := M.[Script_typed_ir.Boxed_map.OPS] in
              let key_ty := M.[Script_typed_ir.Boxed_map.key_ty] in
              let boxed :=
                (m, (Pervasives.snd M.[Script_typed_ir.Boxed_map.boxed])) in
              existT _ tt
                {|
                  Script_typed_ir.Boxed_map.key_ty := key_ty;
                  Script_typed_ir.Boxed_map.boxed := boxed
                  |} in
            Error_monad.__return
              (ctxt,
                (existT _ _
                  {|
                    Script_typed_ir.Boxed_map.key_ty :=
                      M.[Script_typed_ir.Boxed_map.key_ty];
                    Script_typed_ir.Boxed_map.boxed :=
                      M.[Script_typed_ir.Boxed_map.boxed]
                    |}), ids, acc)))
  | (Script_typed_ir.Option_t _ _ true, None) =&gt;
    Error_monad.__return (ctxt, None, ids, acc)
  | (Script_typed_ir.List_t _ _ false, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Map_t _ _ _ false, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Option_t _ _ false, None) =&gt;
    Error_monad.__return (ctxt, None, ids, acc)
  | (Script_typed_ir.Pair_t _ _ _ false, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Union_t _ _ _ false, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Option_t _ _ false, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Chain_id_t _, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Set_t _ _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Unit_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Int_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Nat_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Signature_t _, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.String_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Bytes_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Mutez_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Key_hash_t _, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Key_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Timestamp_t _, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Address_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Bool_t _, v) =&gt; Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Lambda_t _ _ _, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Contract_t _ _, v) =&gt;
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Operation_t _, _) =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  end.

Definition collect_big_maps {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty A) (x : A)
  : Lwt.t (Error_monad.tzresult (Ids.[S.SET.t] * Alpha_context.context)) :=
  let fix collect {a : Set}
    (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty a) (x : a)
    (acc : Ids.[S.SET.t]) {struct ctxt}
    : Error_monad.tzresult (Ids.[S.SET.t] * Alpha_context.context) :=
    match (ty, x) with
    |
      (Script_typed_ir.Big_map_t _ _ _, {|
        Script_typed_ir.big_map.id := Some id |}) =&gt;
      Error_monad.op_gtgtquestion
        (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
        (fun ctxt =&gt; Error_monad.ok ((Ids.[S.SET.add] id acc), ctxt))
    | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, (xl, xr)) =&gt;
      Error_monad.op_gtgtquestion (collect ctxt tyl xl acc)
        (fun function_parameter =&gt;
          let '(acc, ctxt) := function_parameter in
          collect ctxt tyr xr acc)
    | (Script_typed_ir.Union_t (ty, _) (_, _) _ true, Script_typed_ir.L x) =&gt;
      collect ctxt ty x acc
    | (Script_typed_ir.Union_t (_, _) (ty, _) _ true, Script_typed_ir.R x) =&gt;
      collect ctxt ty x acc
    | (Script_typed_ir.Option_t ty _ true, Some x) =&gt; collect ctxt ty x acc
    | (Script_typed_ir.List_t ty _ true, l) =&gt;
      List.fold_left
        (fun acc =&gt;
          fun x =&gt;
            Error_monad.op_gtgtquestion acc
              (fun function_parameter =&gt;
                let '(acc, ctxt) := function_parameter in
                collect ctxt ty x acc)) (Error_monad.ok (acc, ctxt)) l
    | (Script_typed_ir.Map_t _ ty _ true, m) =&gt;
      map_fold
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          fun v =&gt;
            fun acc =&gt;
              Error_monad.op_gtgtquestion acc
                (fun function_parameter =&gt;
                  let '(acc, ctxt) := function_parameter in
                  collect ctxt ty v acc)) m (Error_monad.ok (acc, ctxt))
    | (Script_typed_ir.List_t _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Map_t _ _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    |
      (Script_typed_ir.Big_map_t _ _ _, {| Script_typed_ir.big_map.id := None |})
      =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Option_t _ _ true, None) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Option_t _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Union_t _ _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Pair_t _ _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Chain_id_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Set_t _ _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Unit_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Int_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Nat_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Signature_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.String_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Bytes_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Mutez_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Key_hash_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Key_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Timestamp_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Address_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Bool_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Lambda_t _ _ _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Contract_t _ _, _) =&gt; Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Operation_t _, _) =&gt;
      (* ‚ùå Assert instruction is not handled. *)
      assert false
    end in
  Lwt.__return (collect ctxt ty x no_big_map_id).

Definition extract_big_map_diff {A : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode) (temporary : bool)
  (to_duplicate : Ids.[S.SET.t]) (to_update : Ids.[S.SET.t])
  (ty : Script_typed_ir.ty A) (v : A)
  : Lwt.t
    (Error_monad.tzresult
      (A * option (list Alpha_context.Contract.big_map_diff_item) *
        Alpha_context.context)) :=
  let to_duplicate := Ids.[S.SET.diff] to_duplicate to_update in
  let fresh :=
    if temporary then
      fun c =&gt; Error_monad.__return (Alpha_context.Big_map.fresh_temporary c)
    else
      Alpha_context.Big_map.fresh in
  Error_monad.op_gtgteqquestion
    (extract_big_map_updates ctxt fresh mode to_duplicate [] ty v)
    (fun function_parameter =&gt;
      let '(ctxt, v, alive, diffs) := function_parameter in
      let diffs :=
        if temporary then
          diffs
        else
          let dead := Ids.[S.SET.diff] to_update alive in
          cons
            (Ids.[S.SET.fold]
              (fun id =&gt; fun acc =&gt; cons (Alpha_context.Contract.Clear id) acc)
              dead []) diffs in
      match diffs with
      | [] =&gt; Error_monad.__return (v, None, ctxt)
      | diffs =&gt; Error_monad.__return (v, (Some (List.flatten diffs)), ctxt)
      end).

Definition list_of_big_map_ids (ids : Ids.[S.SET.t]) : list Ids.[S.SET.elt] :=
  Ids.[S.SET.elements] ids.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_translator.mli">
  <div class="col-md-6">
    <a href="#script_ir_translator.mli"><code>script_ir_translator.mli</code></a>&nbsp;<span class="label label-danger">3 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script_tc_errors

type ('ta, 'tb) eq = Eq : ('same, 'same) eq

type ex_comparable_ty =
  | Ex_comparable_ty : 'a Script_typed_ir.comparable_ty -&gt; ex_comparable_ty

type ex_ty = Ex_ty : 'a Script_typed_ir.ty -&gt; ex_ty

type ex_stack_ty = Ex_stack_ty : 'a Script_typed_ir.stack_ty -&gt; ex_stack_ty

type ex_script = Ex_script : ('a, 'b) Script_typed_ir.script -&gt; ex_script

type tc_context =
  | Lambda : tc_context
  | Dip : 'a Script_typed_ir.stack_ty * tc_context -&gt; tc_context
  | Toplevel : {
      storage_type : 'sto Script_typed_ir.ty;
      param_type : 'param Script_typed_ir.ty;
      root_name : string option;
      legacy_create_contract_literal : bool;
    }
      -&gt; tc_context

type 'bef judgement =
  | Typed : ('bef, 'aft) Script_typed_ir.descr -&gt; 'bef judgement
  <abbr class="mark-error" title="Forall quantifier is not handled">| Failed : {
      descr :
        'aft. 'aft Script_typed_ir.stack_ty -&gt;
        ('bef, 'aft) Script_typed_ir.descr;
    }
      -&gt; 'bef judgement</abbr>

type unparsing_mode = Optimized | Readable

type type_logger =
  int -&gt;
  (Script.expr * Script.annot) list -&gt;
  (Script.expr * Script.annot) list -&gt;
  unit

(* ---- Sets and Maps -------------------------------------------------------*)

val empty_set : 'a Script_typed_ir.comparable_ty -&gt; 'a Script_typed_ir.set

val set_fold :
  ('elt -&gt; 'acc -&gt; 'acc) -&gt; 'elt Script_typed_ir.set -&gt; 'acc -&gt; 'acc

val set_update : 'a -&gt; bool -&gt; 'a Script_typed_ir.set -&gt; 'a Script_typed_ir.set

val set_mem : 'elt -&gt; 'elt Script_typed_ir.set -&gt; bool

val set_size : 'elt Script_typed_ir.set -&gt; Script_int.n Script_int.num

val empty_map :
  'a Script_typed_ir.comparable_ty -&gt; ('a, 'b) Script_typed_ir.map

val map_fold :
  ('key -&gt; 'value -&gt; 'acc -&gt; 'acc) -&gt;
  ('key, 'value) Script_typed_ir.map -&gt;
  'acc -&gt;
  'acc

val map_update :
  'a -&gt;
  'b option -&gt;
  ('a, 'b) Script_typed_ir.map -&gt;
  ('a, 'b) Script_typed_ir.map

val map_mem : 'key -&gt; ('key, 'value) Script_typed_ir.map -&gt; bool

val map_get : 'key -&gt; ('key, 'value) Script_typed_ir.map -&gt; 'value option

val map_key_ty :
  ('a, 'b) Script_typed_ir.map -&gt; 'a Script_typed_ir.comparable_ty

val map_size : ('a, 'b) Script_typed_ir.map -&gt; Script_int.n Script_int.num

val empty_big_map :
  'a Script_typed_ir.comparable_ty -&gt;
  'b Script_typed_ir.ty -&gt;
  ('a, 'b) Script_typed_ir.big_map

val big_map_mem :
  context -&gt;
  'key -&gt;
  ('key, 'value) Script_typed_ir.big_map -&gt;
  (bool * context) tzresult Lwt.t

val big_map_get :
  context -&gt;
  'key -&gt;
  ('key, 'value) Script_typed_ir.big_map -&gt;
  ('value option * context) tzresult Lwt.t

val big_map_update :
  'key -&gt;
  'value option -&gt;
  ('key, 'value) Script_typed_ir.big_map -&gt;
  ('key, 'value) Script_typed_ir.big_map

val ty_eq :
  context -&gt;
  'ta Script_typed_ir.ty -&gt;
  'tb Script_typed_ir.ty -&gt;
  (('ta Script_typed_ir.ty, 'tb Script_typed_ir.ty) eq * context) tzresult

val compare_comparable : 'a Script_typed_ir.comparable_ty -&gt; 'a -&gt; 'a -&gt; int

val parse_data :
  ?type_logger:type_logger -&gt;
  context -&gt;
  legacy:bool -&gt;
  'a Script_typed_ir.ty -&gt;
  Script.node -&gt;
  ('a * context) tzresult Lwt.t

val unparse_data :
  context -&gt;
  unparsing_mode -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  (Script.node * context) tzresult Lwt.t

val parse_instr :
  ?type_logger:type_logger -&gt;
  tc_context -&gt;
  context -&gt;
  legacy:bool -&gt;
  Script.node -&gt;
  'bef Script_typed_ir.stack_ty -&gt;
  ('bef judgement * context) tzresult Lwt.t

val parse_ty :
  context -&gt;
  legacy:bool -&gt;
  allow_big_map:bool -&gt;
  allow_operation:bool -&gt;
  allow_contract:bool -&gt;
  Script.node -&gt;
  (ex_ty * context) tzresult

val parse_packable_ty :
  context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult

val unparse_ty :
  context -&gt; 'a Script_typed_ir.ty -&gt; (Script.node * context) tzresult Lwt.t

val parse_toplevel :
  legacy:bool -&gt;
  Script.expr -&gt;
  (Script.node * Script.node * Script.node * string option) tzresult

<abbr class="mark-error" title="Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val add_field_annot :
  [`Field_annot of string] option -&gt;
  [`Var_annot of string] option -&gt;
  Script.node -&gt;
  Script.node</abbr>

val typecheck_code :
  context -&gt; Script.expr -&gt; (type_map * context) tzresult Lwt.t

val typecheck_data :
  ?type_logger:type_logger -&gt;
  context -&gt;
  Script.expr * Script.expr -&gt;
  context tzresult Lwt.t

val parse_script :
  ?type_logger:type_logger -&gt;
  context -&gt;
  legacy:bool -&gt;
  Script.t -&gt;
  (ex_script * context) tzresult Lwt.t

(* Gas accounting may not be perfect in this function, as it is only called by RPCs. *)
val unparse_script :
  context -&gt;
  unparsing_mode -&gt;
  ('a, 'b) Script_typed_ir.script -&gt;
  (Script.t * context) tzresult Lwt.t

val parse_contract :
  legacy:bool -&gt;
  context -&gt;
  Script.location -&gt;
  'a Script_typed_ir.ty -&gt;
  Contract.t -&gt;
  entrypoint:string -&gt;
  (context * 'a Script_typed_ir.typed_contract) tzresult Lwt.t

val parse_contract_for_script :
  legacy:bool -&gt;
  context -&gt;
  Script.location -&gt;
  'a Script_typed_ir.ty -&gt;
  Contract.t -&gt;
  entrypoint:string -&gt;
  (context * 'a Script_typed_ir.typed_contract option) tzresult Lwt.t

val find_entrypoint :
  't Script_typed_ir.ty -&gt;
  root_name:string option -&gt;
  string -&gt;
  ((Script.node -&gt; Script.node) * ex_ty) tzresult

module Entrypoints_map : S.MAP with type key = string

val list_entrypoints :
  't Script_typed_ir.ty -&gt;
  context -&gt;
  root_name:string option -&gt;
  ( Michelson_v1_primitives.prim list list
  * (Michelson_v1_primitives.prim list * Script.node) Entrypoints_map.t )
  tzresult

val pack_data :
  context -&gt; 'a Script_typed_ir.ty -&gt; 'a -&gt; (MBytes.t * context) tzresult Lwt.t

val hash_data :
  context -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  (Script_expr_hash.t * context) tzresult Lwt.t

type big_map_ids

val no_big_map_id : big_map_ids

val collect_big_maps :
  context -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  (big_map_ids * context) tzresult Lwt.t

val list_of_big_map_ids : big_map_ids -&gt; Z.t list

val extract_big_map_diff :
  context -&gt;
  unparsing_mode -&gt;
  temporary:bool -&gt;
  to_duplicate:big_map_ids -&gt;
  to_update:big_map_ids -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  ('a * Contract.big_map_diff option * context) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_translator.mli"><code>Script_ir_translator_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_expr_hash.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Reserved Notation &quot;'eq&quot;.

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where &quot;'eq&quot; := (fun (ta tb : Set) =&gt; eq_gadt).

Definition eq := 'eq.

Reserved Notation &quot;'ex_comparable_ty&quot;.

Inductive ex_comparable_ty_gadt : Set :=
| Ex_comparable_ty : forall {a : Set},
  Script_typed_ir.comparable_ty a -&gt; ex_comparable_ty_gadt

where &quot;'ex_comparable_ty&quot; := (ex_comparable_ty_gadt).

Definition ex_comparable_ty := 'ex_comparable_ty.

Reserved Notation &quot;'ex_ty&quot;.

Inductive ex_ty_gadt : Set :=
| Ex_ty : forall {a : Set}, Script_typed_ir.ty a -&gt; ex_ty_gadt

where &quot;'ex_ty&quot; := (ex_ty_gadt).

Definition ex_ty := 'ex_ty.

Reserved Notation &quot;'ex_stack_ty&quot;.

Inductive ex_stack_ty_gadt : Set :=
| Ex_stack_ty : forall {a : Set}, Script_typed_ir.stack_ty a -&gt; ex_stack_ty_gadt

where &quot;'ex_stack_ty&quot; := (ex_stack_ty_gadt).

Definition ex_stack_ty := 'ex_stack_ty.

Reserved Notation &quot;'ex_script&quot;.

Inductive ex_script_gadt : Set :=
| Ex_script : forall {a b : Set}, Script_typed_ir.script a b -&gt; ex_script_gadt

where &quot;'ex_script&quot; := (ex_script_gadt).

Definition ex_script := 'ex_script.

Module tc_context.
  Module Toplevel.
    Record record {storage_type param_type root_name
      legacy_create_contract_literal : Set} := {
      storage_type : storage_type;
      param_type : param_type;
      root_name : root_name;
      legacy_create_contract_literal : legacy_create_contract_literal }.
    Arguments record : clear implicits.
  End Toplevel.
  Definition Toplevel := Toplevel.record.
End tc_context.

Reserved Notation &quot;'tc_context&quot;.

Inductive tc_context_gadt : Set :=
| Lambda : tc_context_gadt
| Dip : forall {a : Set},
  Script_typed_ir.stack_ty a -&gt; tc_context_gadt -&gt; tc_context_gadt
| Toplevel : forall {param sto : Set},
  tc_context.Toplevel (Script_typed_ir.ty sto) (Script_typed_ir.ty param)
    (option string) bool -&gt; tc_context_gadt

where &quot;'tc_context&quot; := (tc_context_gadt).

Definition tc_context := 'tc_context.

Module judgement.
  Module Failed.
    Record record {descr : Set} := {
      descr : descr }.
    Arguments record : clear implicits.
  End Failed.
  Definition Failed := Failed.record.
End judgement.

Reserved Notation &quot;'judgement&quot;.

Inductive judgement_gadt : Set :=
| Typed : forall {aft bef : Set},
  Script_typed_ir.descr bef aft -&gt; judgement_gadt
| Failed : forall {aft bef : Set},
  judgement.Failed
    ((Script_typed_ir.stack_ty aft -&gt; Script_typed_ir.descr bef aft) * aft) -&gt;
  judgement_gadt

where &quot;'judgement&quot; := (fun (bef : Set) =&gt; judgement_gadt).

Definition judgement := 'judgement.

Inductive unparsing_mode : Set :=
| Optimized : unparsing_mode
| Readable : unparsing_mode.

Definition type_logger :=
  Z -&gt; list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt;
  list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt; unit.

Parameter empty_set : forall {a : Set},
  Script_typed_ir.comparable_ty a -&gt; Script_typed_ir.set a.

Parameter set_fold : forall {acc elt : Set},
  (elt -&gt; acc -&gt; acc) -&gt; Script_typed_ir.set elt -&gt; acc -&gt; acc.

Parameter set_update : forall {a : Set},
  a -&gt; bool -&gt; Script_typed_ir.set a -&gt; Script_typed_ir.set a.

Parameter set_mem : forall {elt : Set}, elt -&gt; Script_typed_ir.set elt -&gt; bool.

Parameter set_size : forall {elt : Set},
  Script_typed_ir.set elt -&gt;
  Alpha_context.Script_int.num Alpha_context.Script_int.n.

Parameter empty_map : forall {a b : Set},
  Script_typed_ir.comparable_ty a -&gt; Script_typed_ir.map a b.

Parameter map_fold : forall {acc key value : Set},
  (key -&gt; value -&gt; acc -&gt; acc) -&gt; Script_typed_ir.map key value -&gt; acc -&gt; acc.

Parameter map_update : forall {a b : Set},
  a -&gt; option b -&gt; Script_typed_ir.map a b -&gt; Script_typed_ir.map a b.

Parameter map_mem : forall {key value : Set},
  key -&gt; Script_typed_ir.map key value -&gt; bool.

Parameter map_get : forall {key value : Set},
  key -&gt; Script_typed_ir.map key value -&gt; option value.

Parameter map_key_ty : forall {a b : Set},
  Script_typed_ir.map a b -&gt; Script_typed_ir.comparable_ty a.

Parameter map_size : forall {a b : Set},
  Script_typed_ir.map a b -&gt;
  Alpha_context.Script_int.num Alpha_context.Script_int.n.

Parameter empty_big_map : forall {a b : Set},
  Script_typed_ir.comparable_ty a -&gt; Script_typed_ir.ty b -&gt;
  Script_typed_ir.big_map a b.

Parameter big_map_mem : forall {key value : Set},
  Alpha_context.context -&gt; key -&gt; Script_typed_ir.big_map key value -&gt;
  Lwt.t (Error_monad.tzresult (bool * Alpha_context.context)).

Parameter big_map_get : forall {key value : Set},
  Alpha_context.context -&gt; key -&gt; Script_typed_ir.big_map key value -&gt;
  Lwt.t (Error_monad.tzresult (option value * Alpha_context.context)).

Parameter big_map_update : forall {key value : Set},
  key -&gt; option value -&gt; Script_typed_ir.big_map key value -&gt;
  Script_typed_ir.big_map key value.

Parameter ty_eq : forall {ta tb : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty ta -&gt; Script_typed_ir.ty tb -&gt;
  Error_monad.tzresult
    (eq (Script_typed_ir.ty ta) (Script_typed_ir.ty tb) * Alpha_context.context).

Parameter compare_comparable : forall {a : Set},
  Script_typed_ir.comparable_ty a -&gt; a -&gt; a -&gt; Z.

Parameter parse_data : forall {a : Set},
  option type_logger -&gt; Alpha_context.context -&gt; bool -&gt; Script_typed_ir.ty a -&gt;
  Alpha_context.Script.node -&gt;
  Lwt.t (Error_monad.tzresult (a * Alpha_context.context)).

Parameter unparse_data : forall {a : Set},
  Alpha_context.context -&gt; unparsing_mode -&gt; Script_typed_ir.ty a -&gt; a -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)).

Parameter parse_instr : forall {bef : Set},
  option type_logger -&gt; tc_context -&gt; Alpha_context.context -&gt; bool -&gt;
  Alpha_context.Script.node -&gt; Script_typed_ir.stack_ty bef -&gt;
  Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)).

Parameter parse_ty :
  Alpha_context.context -&gt; bool -&gt; bool -&gt; bool -&gt; bool -&gt;
  Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context).

Parameter parse_packable_ty :
  Alpha_context.context -&gt; bool -&gt; Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context).

Parameter unparse_ty : forall {a : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty a -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)).

Parameter parse_toplevel :
  bool -&gt; Alpha_context.Script.expr -&gt;
  Error_monad.tzresult
    (Alpha_context.Script.node * Alpha_context.Script.node *
      Alpha_context.Script.node * option string).

Parameter add_field_annot :
  option (* `Field_annot *) string -&gt; option (* `Var_annot *) string -&gt;
  Alpha_context.Script.node -&gt; Alpha_context.Script.node.

Parameter typecheck_code :
  Alpha_context.context -&gt; Alpha_context.Script.expr -&gt;
  Lwt.t
    (Error_monad.tzresult (Script_tc_errors.type_map * Alpha_context.context)).

Parameter typecheck_data :
  option type_logger -&gt; Alpha_context.context -&gt;
  Alpha_context.Script.expr * Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.context).

Parameter parse_script :
  option type_logger -&gt; Alpha_context.context -&gt; bool -&gt;
  Alpha_context.Script.t -&gt;
  Lwt.t (Error_monad.tzresult (ex_script * Alpha_context.context)).

Parameter unparse_script : forall {a b : Set},
  Alpha_context.context -&gt; unparsing_mode -&gt; Script_typed_ir.script a b -&gt;
  Lwt.t (Error_monad.tzresult (Alpha_context.Script.t * Alpha_context.context)).

Parameter parse_contract : forall {a : Set},
  bool -&gt; Alpha_context.context -&gt; Alpha_context.Script.location -&gt;
  Script_typed_ir.ty a -&gt; Alpha_context.Contract.t -&gt; string -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Script_typed_ir.typed_contract a)).

Parameter parse_contract_for_script : forall {a : Set},
  bool -&gt; Alpha_context.context -&gt; Alpha_context.Script.location -&gt;
  Script_typed_ir.ty a -&gt; Alpha_context.Contract.t -&gt; string -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * option (Script_typed_ir.typed_contract a))).

Parameter find_entrypoint : forall {t : Set},
  Script_typed_ir.ty t -&gt; option string -&gt; string -&gt;
  Error_monad.tzresult
    ((Alpha_context.Script.node -&gt; Alpha_context.Script.node) * ex_ty).

Parameter Entrypoints_map : {t : _ &amp; S.MAP.signature string t}.

Parameter list_entrypoints : forall {t : Set},
  Script_typed_ir.ty t -&gt; Alpha_context.context -&gt; option string -&gt;
  Error_monad.tzresult
    (list (list Michelson_v1_primitives.prim) *
      Entrypoints_map.[S.MAP.t]
        (list Michelson_v1_primitives.prim * Alpha_context.Script.node)).

Parameter pack_data : forall {a : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty a -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult (MBytes.t * Alpha_context.context)).

Parameter hash_data : forall {a : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty a -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult (Script_expr_hash.t * Alpha_context.context)).

Parameter big_map_ids : Set.

Parameter no_big_map_id : big_map_ids.

Parameter collect_big_maps : forall {a : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty a -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult (big_map_ids * Alpha_context.context)).

Parameter list_of_big_map_ids : big_map_ids -&gt; list Z.t.

Parameter extract_big_map_diff : forall {a : Set},
  Alpha_context.context -&gt; unparsing_mode -&gt; bool -&gt; big_map_ids -&gt;
  big_map_ids -&gt; Script_typed_ir.ty a -&gt; a -&gt;
  Lwt.t
    (Error_monad.tzresult
      (a * option Alpha_context.Contract.big_map_diff * Alpha_context.context)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_repr.ml">
  <div class="col-md-6">
    <a href="#script_repr.ml"><code>script_repr.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type location = Micheline.canonical_location

let location_encoding = Micheline.canonical_location_encoding

type annot = Micheline.annot

type expr = Michelson_v1_primitives.prim Micheline.canonical

type lazy_expr = expr Data_encoding.lazy_t

type node = (location, Michelson_v1_primitives.prim) Micheline.node

let expr_encoding =
  Micheline.canonical_encoding_v1
    ~variant:&quot;michelson_v1&quot;
    Michelson_v1_primitives.prim_encoding

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Lazy_script_decode</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;invalid_binary_format&quot;
    ~title:&quot;Invalid binary format&quot;
    ~description:
      &quot;Could not deserialize some piece of data from its binary representation&quot;
    Data_encoding.empty
    (function Lazy_script_decode -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Lazy_script_decode)</abbr>

let lazy_expr_encoding = Data_encoding.lazy_encoding expr_encoding

let lazy_expr expr = Data_encoding.make_lazy expr_encoding expr

type t = {code : lazy_expr; storage : lazy_expr}

let encoding =
  let open Data_encoding in
  def &quot;scripted.contracts&quot;
  @@ conv
       (fun {code; storage} -&gt; (code, storage))
       (fun (code, storage) -&gt; {code; storage})
       (obj2 (req &quot;code&quot; lazy_expr_encoding) (req &quot;storage&quot; lazy_expr_encoding))

let int_node_size_of_numbits n = (1, 1 + ((n + 63) / 64))

let int_node_size n = int_node_size_of_numbits (Z.numbits n)

let string_node_size_of_length s = (1, 1 + ((s + 7) / 8))

let string_node_size s = string_node_size_of_length (String.length s)

let bytes_node_size_of_length s =
  (* approx cost of indirection to the C heap *)
  (2, 1 + ((s + 7) / 8) + 12)

let bytes_node_size s = bytes_node_size_of_length (MBytes.length s)

let prim_node_size_nonrec_of_lengths n_args annots =
  let annots_length =
    List.fold_left (fun acc s -&gt; acc + String.length s) 0 annots
  in
  if Compare.Int.(annots_length = 0) then (1 + n_args, 2 + (2 * n_args))
  else (2 + n_args, 4 + (2 * n_args) + ((annots_length + 7) / 8))

let prim_node_size_nonrec args annots =
  let n_args = List.length args in
  prim_node_size_nonrec_of_lengths n_args annots

let seq_node_size_nonrec_of_length n_args = (1 + n_args, 2 + (2 * n_args))

let seq_node_size_nonrec args =
  let n_args = List.length args in
  seq_node_size_nonrec_of_length n_args

let rec node_size node =
  let open Micheline in
  match node with
  | Int (_, n) -&gt;
      int_node_size n
  | String (_, s) -&gt;
      string_node_size s
  | Bytes (_, s) -&gt;
      bytes_node_size s
  | Prim (_, _, args, annot) -&gt;
      List.fold_left
        (fun (blocks, words) node -&gt;
          let (nblocks, nwords) = node_size node in
          (blocks + nblocks, words + nwords))
        (prim_node_size_nonrec args annot)
        args
  | Seq (_, args) -&gt;
      List.fold_left
        (fun (blocks, words) node -&gt;
          let (nblocks, nwords) = node_size node in
          (blocks + nblocks, words + nwords))
        (seq_node_size_nonrec args)
        args

let expr_size expr = node_size (Micheline.root expr)

let traversal_cost node =
  let (blocks, _words) = node_size node in
  Gas_limit_repr.step_cost blocks

let cost_of_size (blocks, words) =
  let open Gas_limit_repr in
  (Compare.Int.max 0 (blocks - 1) *@ alloc_cost 0)
  +@ alloc_cost words +@ step_cost blocks

let node_cost node = cost_of_size (node_size node)

let int_node_cost n = cost_of_size (int_node_size n)

let int_node_cost_of_numbits n = cost_of_size (int_node_size_of_numbits n)

let string_node_cost s = cost_of_size (string_node_size s)

let string_node_cost_of_length s = cost_of_size (string_node_size_of_length s)

let bytes_node_cost s = cost_of_size (bytes_node_size s)

let bytes_node_cost_of_length s = cost_of_size (bytes_node_size_of_length s)

let prim_node_cost_nonrec args annot =
  cost_of_size (prim_node_size_nonrec args annot)

let prim_node_cost_nonrec_of_length n_args annot =
  cost_of_size (prim_node_size_nonrec_of_lengths n_args annot)

let seq_node_cost_nonrec args = cost_of_size (seq_node_size_nonrec args)

let seq_node_cost_nonrec_of_length n_args =
  cost_of_size (seq_node_size_nonrec_of_length n_args)

let deserialized_cost expr = cost_of_size (expr_size expr)

let serialized_cost bytes =
  let open Gas_limit_repr in
  alloc_mbytes_cost (MBytes.length bytes)

let force_decode lexpr =
  let account_deserialization_cost =
    Data_encoding.apply_lazy
      ~fun_value:(fun _ -&gt; false)
      ~fun_bytes:(fun _ -&gt; true)
      ~fun_combine:(fun _ _ -&gt; false)
      lexpr
  in
  match Data_encoding.force_decode lexpr with
  | Some v -&gt;
      if account_deserialization_cost then ok (v, deserialized_cost v)
      else ok (v, Gas_limit_repr.free)
  | None -&gt;
      error <abbr class="mark-error" title="Values of extensible types are not handled">Lazy_script_decode</abbr>

let force_bytes expr =
  let open Gas_limit_repr in
  let account_serialization_cost =
    Data_encoding.apply_lazy
      ~fun_value:(fun v -&gt; Some v)
      ~fun_bytes:(fun _ -&gt; None)
      ~fun_combine:(fun _ _ -&gt; None)
      expr
  in
  match Data_encoding.force_bytes expr with
  | bytes -&gt; (
    match account_serialization_cost with
    | Some v -&gt;
        ok (bytes, traversal_cost (Micheline.root v) +@ serialized_cost bytes)
    | None -&gt;
        ok (bytes, Gas_limit_repr.free) )
  | exception <abbr class="mark-error" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">_</abbr> -&gt;
      error Lazy_script_decode

let minimal_deserialize_cost lexpr =
  Data_encoding.apply_lazy
    ~fun_value:(fun _ -&gt; Gas_limit_repr.free)
    ~fun_bytes:(fun b -&gt; serialized_cost b)
    ~fun_combine:(fun c_free _ -&gt; c_free)
    lexpr

let unit =
  Micheline.strip_locations (Prim (0, Michelson_v1_primitives.D_Unit, [], []))

let unit_parameter = lazy_expr unit

let is_unit_parameter =
  let unit_bytes = Data_encoding.force_bytes unit_parameter in
  Data_encoding.apply_lazy
    ~fun_value:(fun v -&gt;
      match Micheline.root v with
      | Prim (_, Michelson_v1_primitives.D_Unit, [], []) -&gt;
          true
      | _ -&gt;
          false)
    ~fun_bytes:(fun b -&gt; MBytes.( = ) b unit_bytes)
    ~fun_combine:(fun res _ -&gt; res)

let rec strip_annotations node =
  let open Micheline in
  match node with
  | (Int (_, _) | String (_, _) | Bytes (_, _)) as leaf -&gt;
      leaf
  | Prim (loc, name, args, _) -&gt;
      Prim (loc, name, List.map strip_annotations args, [])
  | Seq (loc, args) -&gt;
      Seq (loc, List.map strip_annotations args)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_repr.ml"><code>Script_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Gas_limit_repr.
Require Tezos.Michelson_v1_primitives.

Definition location := Micheline.canonical_location.

Definition location_encoding
  : Data_encoding.encoding Micheline.canonical_location :=
  Micheline.canonical_location_encoding.

Definition annot := Micheline.annot.

Definition expr := Micheline.canonical Michelson_v1_primitives.prim.

Definition lazy_expr := Data_encoding.lazy_t expr.

Definition node := Micheline.node location Michelson_v1_primitives.prim.

Definition expr_encoding
  : Data_encoding.encoding (Micheline.canonical Michelson_v1_primitives.prim) :=
  Micheline.canonical_encoding_v1 &quot;michelson_v1&quot; % string
    Michelson_v1_primitives.prim_encoding.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition lazy_expr_encoding
  : Data_encoding.encoding
    (Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim)) :=
  Data_encoding.lazy_encoding expr_encoding.

Definition lazy_expr (expr : Micheline.canonical Michelson_v1_primitives.prim)
  : Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim) :=
  Data_encoding.make_lazy expr_encoding expr.

Module t.
  Record record := {
    code : lazy_expr;
    storage : lazy_expr }.
End t.
Definition t := t.record.

Definition encoding : Data_encoding.encoding t :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;scripted.contracts&quot; % string in
    fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{| t.code := code; t.storage := storage |} := function_parameter in
        (code, storage))
      (fun function_parameter =&gt;
        let '(code, storage) := function_parameter in
        {| t.code := code; t.storage := storage |}) None
      (Data_encoding.obj2
        (Data_encoding.req None None &quot;code&quot; % string lazy_expr_encoding)
        (Data_encoding.req None None &quot;storage&quot; % string lazy_expr_encoding))).

Definition int_node_size_of_numbits (n : Z) : Z * Z :=
  (1, (Pervasives.op_plus 1 (Pervasives.op_div (Pervasives.op_plus n 63) 64))).

Definition int_node_size (n : Z.t) : Z * Z :=
  int_node_size_of_numbits (Z.numbits n).

Definition string_node_size_of_length (s : Z) : Z * Z :=
  (1, (Pervasives.op_plus 1 (Pervasives.op_div (Pervasives.op_plus s 7) 8))).

Definition string_node_size (s : string) : Z * Z :=
  string_node_size_of_length (String.length s).

Definition bytes_node_size_of_length (s : Z) : Z * Z :=
  (2,
    (Pervasives.op_plus
      (Pervasives.op_plus 1 (Pervasives.op_div (Pervasives.op_plus s 7) 8)) 12)).

Definition bytes_node_size (s : MBytes.t) : Z * Z :=
  bytes_node_size_of_length (MBytes.length s).

Definition prim_node_size_nonrec_of_lengths (n_args : Z) (annots : list string)
  : Z * Z :=
  let annots_length :=
    List.fold_left
      (fun acc =&gt; fun s =&gt; Pervasives.op_plus acc (String.length s)) 0 annots in
  if Compare.Int.[Compare.S.op_eq] annots_length 0 then
    ((Pervasives.op_plus 1 n_args),
      (Pervasives.op_plus 2 (Pervasives.op_star 2 n_args)))
  else
    ((Pervasives.op_plus 2 n_args),
      (Pervasives.op_plus (Pervasives.op_plus 4 (Pervasives.op_star 2 n_args))
        (Pervasives.op_div (Pervasives.op_plus annots_length 7) 8))).

Definition prim_node_size_nonrec {A : Set}
  (args : list A) (annots : list string) : Z * Z :=
  let n_args := List.length args in
  prim_node_size_nonrec_of_lengths n_args annots.

Definition seq_node_size_nonrec_of_length (n_args : Z) : Z * Z :=
  ((Pervasives.op_plus 1 n_args),
    (Pervasives.op_plus 2 (Pervasives.op_star 2 n_args))).

Definition seq_node_size_nonrec {A : Set} (args : list A) : Z * Z :=
  let n_args := List.length args in
  seq_node_size_nonrec_of_length n_args.

Fixpoint node_size {A B : Set} (node : Micheline.node A B) {struct node}
  : Z * Z :=
  match node with
  | Micheline.Int _ n =&gt; int_node_size n
  | Micheline.String _ s =&gt; string_node_size s
  | Micheline.Bytes _ s =&gt; bytes_node_size s
  | Micheline.Prim _ _ args annot =&gt;
    List.fold_left
      (fun function_parameter =&gt;
        let '(blocks, words) := function_parameter in
        fun node =&gt;
          let '(nblocks, nwords) := node_size node in
          ((Pervasives.op_plus blocks nblocks),
            (Pervasives.op_plus words nwords)))
      (prim_node_size_nonrec args annot) args
  | Micheline.Seq _ args =&gt;
    List.fold_left
      (fun function_parameter =&gt;
        let '(blocks, words) := function_parameter in
        fun node =&gt;
          let '(nblocks, nwords) := node_size node in
          ((Pervasives.op_plus blocks nblocks),
            (Pervasives.op_plus words nwords))) (seq_node_size_nonrec args) args
  end.

Definition expr_size {A : Set} (expr : Micheline.canonical A) : Z * Z :=
  node_size (Micheline.root expr).

Definition traversal_cost {A B : Set} (node : Micheline.node A B)
  : Gas_limit_repr.cost :=
  let '(blocks, _words) := node_size node in
  Gas_limit_repr.step_cost blocks.

Definition cost_of_size (function_parameter : Z * Z) : Gas_limit_repr.cost :=
  let '(blocks, words) := function_parameter in
  Gas_limit_repr.op_plusat
    (Gas_limit_repr.op_plusat
      (Gas_limit_repr.op_starat
        (Compare.Int.[Compare.S.max] 0 (Pervasives.op_minus blocks 1))
        (Gas_limit_repr.alloc_cost 0)) (Gas_limit_repr.alloc_cost words))
    (Gas_limit_repr.step_cost blocks).

Definition node_cost {A B : Set} (node : Micheline.node A B)
  : Gas_limit_repr.cost := cost_of_size (node_size node).

Definition int_node_cost (n : Z.t) : Gas_limit_repr.cost :=
  cost_of_size (int_node_size n).

Definition int_node_cost_of_numbits (n : Z) : Gas_limit_repr.cost :=
  cost_of_size (int_node_size_of_numbits n).

Definition string_node_cost (s : string) : Gas_limit_repr.cost :=
  cost_of_size (string_node_size s).

Definition string_node_cost_of_length (s : Z) : Gas_limit_repr.cost :=
  cost_of_size (string_node_size_of_length s).

Definition bytes_node_cost (s : MBytes.t) : Gas_limit_repr.cost :=
  cost_of_size (bytes_node_size s).

Definition bytes_node_cost_of_length (s : Z) : Gas_limit_repr.cost :=
  cost_of_size (bytes_node_size_of_length s).

Definition prim_node_cost_nonrec {A : Set} (args : list A) (annot : list string)
  : Gas_limit_repr.cost := cost_of_size (prim_node_size_nonrec args annot).

Definition prim_node_cost_nonrec_of_length (n_args : Z) (annot : list string)
  : Gas_limit_repr.cost :=
  cost_of_size (prim_node_size_nonrec_of_lengths n_args annot).

Definition seq_node_cost_nonrec {A : Set} (args : list A)
  : Gas_limit_repr.cost := cost_of_size (seq_node_size_nonrec args).

Definition seq_node_cost_nonrec_of_length (n_args : Z) : Gas_limit_repr.cost :=
  cost_of_size (seq_node_size_nonrec_of_length n_args).

Definition deserialized_cost {A : Set} (expr : Micheline.canonical A)
  : Gas_limit_repr.cost := cost_of_size (expr_size expr).

Definition serialized_cost (__bytes_value : MBytes.t) : Gas_limit_repr.cost :=
  Gas_limit_repr.alloc_mbytes_cost (MBytes.length __bytes_value).

Definition force_decode {A : Set}
  (lexpr : Data_encoding.lazy_t (Micheline.canonical A))
  : Error_monad.tzresult (Micheline.canonical A * Gas_limit_repr.cost) :=
  let account_deserialization_cost :=
    Data_encoding.apply_lazy
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        false)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        true)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          false) lexpr in
  match Data_encoding.force_decode lexpr with
  | Some v =&gt;
    if account_deserialization_cost then
      Error_monad.ok (v, (deserialized_cost v))
    else
      Error_monad.ok (v, Gas_limit_repr.free)
  | None =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition force_bytes {A : Set}
  (expr : Data_encoding.lazy_t (Micheline.canonical A))
  : Error_monad.tzresult (MBytes.t * Gas_limit_repr.cost) :=
  let account_serialization_cost :=
    Data_encoding.apply_lazy (fun v =&gt; Some v)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        None)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          None) expr in
  let '__bytes_value := Data_encoding.force_bytes expr in
  match account_serialization_cost with
  | Some v =&gt;
    Error_monad.ok
      (__bytes_value,
        (Gas_limit_repr.op_plusat (traversal_cost (Micheline.root v))
          (serialized_cost __bytes_value)))
  | None =&gt; Error_monad.ok (__bytes_value, Gas_limit_repr.free)
  end.

Definition minimal_deserialize_cost {A : Set} (lexpr : Data_encoding.lazy_t A)
  : Gas_limit_repr.cost :=
  Data_encoding.apply_lazy
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      Gas_limit_repr.free) (fun b =&gt; serialized_cost b)
    (fun c_free =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        c_free) lexpr.

Definition __unit_value : Micheline.canonical Michelson_v1_primitives.prim :=
  Micheline.strip_locations
    (Micheline.Prim 0 Michelson_v1_primitives.D_Unit [] []).

Definition unit_parameter
  : Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim) :=
  lazy_expr __unit_value.

Definition is_unit_parameter
  : Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim) -&gt;
  bool :=
  let unit_bytes := Data_encoding.force_bytes unit_parameter in
  Data_encoding.apply_lazy
    (fun v =&gt;
      match Micheline.root v with
      | Micheline.Prim _ Michelson_v1_primitives.D_Unit [] [] =&gt; true
      | _ =&gt; false
      end) (fun b =&gt; MBytes.op_eq b unit_bytes)
    (fun res =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        res).

Fixpoint strip_annotations {A B : Set} (node : Micheline.node A B) {struct node}
  : Micheline.node A B :=
  match node with
  | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as leaf =&gt;
    leaf
  | Micheline.Prim loc name args _ =&gt;
    Micheline.Prim loc name (List.map strip_annotations args) []
  | Micheline.Seq loc args =&gt;
    Micheline.Seq loc (List.map strip_annotations args)
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_repr.mli">
  <div class="col-md-6">
    <a href="#script_repr.mli"><code>script_repr.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type location = Micheline.canonical_location

type annot = Micheline.annot

type expr = Michelson_v1_primitives.prim Micheline.canonical

<abbr class="mark-error" title="Extensible types are not handled.">type error += Lazy_script_decode</abbr> (* `Permanent *)

type lazy_expr = expr Data_encoding.lazy_t

type node = (location, Michelson_v1_primitives.prim) Micheline.node

val location_encoding : location Data_encoding.t

val expr_encoding : expr Data_encoding.t

val lazy_expr_encoding : lazy_expr Data_encoding.t

val lazy_expr : expr -&gt; lazy_expr

type t = {code : lazy_expr; storage : lazy_expr}

val encoding : t Data_encoding.encoding

val deserialized_cost : expr -&gt; Gas_limit_repr.cost

val serialized_cost : MBytes.t -&gt; Gas_limit_repr.cost

val traversal_cost : node -&gt; Gas_limit_repr.cost

val node_cost : node -&gt; Gas_limit_repr.cost

val int_node_cost : Z.t -&gt; Gas_limit_repr.cost

val int_node_cost_of_numbits : int -&gt; Gas_limit_repr.cost

val string_node_cost : string -&gt; Gas_limit_repr.cost

val string_node_cost_of_length : int -&gt; Gas_limit_repr.cost

val bytes_node_cost : MBytes.t -&gt; Gas_limit_repr.cost

val bytes_node_cost_of_length : int -&gt; Gas_limit_repr.cost

val prim_node_cost_nonrec : expr list -&gt; annot -&gt; Gas_limit_repr.cost

val prim_node_cost_nonrec_of_length : int -&gt; annot -&gt; Gas_limit_repr.cost

val seq_node_cost_nonrec : expr list -&gt; Gas_limit_repr.cost

val seq_node_cost_nonrec_of_length : int -&gt; Gas_limit_repr.cost

val force_decode : lazy_expr -&gt; (expr * Gas_limit_repr.cost) tzresult

val force_bytes : lazy_expr -&gt; (MBytes.t * Gas_limit_repr.cost) tzresult

val minimal_deserialize_cost : lazy_expr -&gt; Gas_limit_repr.cost

val unit_parameter : lazy_expr

val is_unit_parameter : lazy_expr -&gt; bool

val strip_annotations : node -&gt; node
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_repr.mli"><code>Script_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Gas_limit_repr.
Require Tezos.Michelson_v1_primitives.

Definition location := Micheline.canonical_location.

Definition annot := Micheline.annot.

Definition expr := Micheline.canonical Michelson_v1_primitives.prim.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Definition lazy_expr := Data_encoding.lazy_t expr.

Definition node := Micheline.node location Michelson_v1_primitives.prim.

Parameter location_encoding : Data_encoding.t location.

Parameter expr_encoding : Data_encoding.t expr.

Parameter lazy_expr_encoding : Data_encoding.t lazy_expr.

Parameter lazy_expr : expr -&gt; lazy_expr.

Module t.
  Record record := {
    code : lazy_expr;
    storage : lazy_expr }.
End t.
Definition t := t.record.

Parameter encoding : Data_encoding.encoding t.

Parameter deserialized_cost : expr -&gt; Gas_limit_repr.cost.

Parameter serialized_cost : MBytes.t -&gt; Gas_limit_repr.cost.

Parameter traversal_cost : node -&gt; Gas_limit_repr.cost.

Parameter node_cost : node -&gt; Gas_limit_repr.cost.

Parameter int_node_cost : Z.t -&gt; Gas_limit_repr.cost.

Parameter int_node_cost_of_numbits : Z -&gt; Gas_limit_repr.cost.

Parameter string_node_cost : string -&gt; Gas_limit_repr.cost.

Parameter string_node_cost_of_length : Z -&gt; Gas_limit_repr.cost.

Parameter bytes_node_cost : MBytes.t -&gt; Gas_limit_repr.cost.

Parameter bytes_node_cost_of_length : Z -&gt; Gas_limit_repr.cost.

Parameter prim_node_cost_nonrec : list expr -&gt; annot -&gt; Gas_limit_repr.cost.

Parameter prim_node_cost_nonrec_of_length : Z -&gt; annot -&gt; Gas_limit_repr.cost.

Parameter seq_node_cost_nonrec : list expr -&gt; Gas_limit_repr.cost.

Parameter seq_node_cost_nonrec_of_length : Z -&gt; Gas_limit_repr.cost.

Parameter force_decode :
  lazy_expr -&gt; Error_monad.tzresult (expr * Gas_limit_repr.cost).

Parameter force_bytes :
  lazy_expr -&gt; Error_monad.tzresult (MBytes.t * Gas_limit_repr.cost).

Parameter minimal_deserialize_cost : lazy_expr -&gt; Gas_limit_repr.cost.

Parameter unit_parameter : lazy_expr.

Parameter is_unit_parameter : lazy_expr -&gt; bool.

Parameter strip_annotations : node -&gt; node.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_tc_errors.ml">
  <div class="col-md-6">
    <a href="#script_tc_errors.ml"><code>script_tc_errors.ml</code></a>&nbsp;<span class="label label-danger">46 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script

(* ---- Error definitions ---------------------------------------------------*)

(* Auxiliary types for error documentation *)
type namespace =
  | Type_namespace
  | Constant_namespace
  | Instr_namespace
  | Keyword_namespace

type kind = Int_kind | String_kind | Bytes_kind | Prim_kind | Seq_kind

type unparsed_stack_ty = (Script.expr * Script.annot) list

type type_map = (int * (unparsed_stack_ty * unparsed_stack_ty)) list

(* Structure errors *)
<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_arity of Script.location * prim * int * int</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Invalid_namespace of Script.location * prim * namespace * namespace</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_primitive of Script.location * prim list * prim</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_kind of Script.location * kind list * kind</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Missing_field of prim</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Duplicate_field of Script.location * prim</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unexpected_big_map of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unexpected_operation of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unexpected_contract of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += No_such_entrypoint of string</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Duplicate_entrypoint of string</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unreachable_entrypoint of prim list</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Entrypoint_name_too_long of string</abbr>

(* Instruction typing errors *)
<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Fail_not_in_tail_position of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Undefined_binop :
      Script.location * prim * Script.expr * Script.expr
      -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Undefined_unop : Script.location * prim * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Bad_return : Script.location * unparsed_stack_ty * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Bad_stack : Script.location * prim * int * unparsed_stack_ty -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Unmatched_branches :
      Script.location * unparsed_stack_ty * unparsed_stack_ty
      -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Self_in_lambda of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Bad_stack_length</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Bad_stack_item of int</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Inconsistent_annotations of string * string</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Inconsistent_type_annotations :
      Script.location * Script.expr * Script.expr
      -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Inconsistent_field_annotations of string * string</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unexpected_annotation of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Ungrouped_annotations of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_map_body : Script.location * unparsed_stack_ty -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_map_block_fail of Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Invalid_iter_body :
      Script.location * unparsed_stack_ty * unparsed_stack_ty
      -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Type_too_large : Script.location * int * int -&gt; error</abbr>

(* Value typing errors *)
<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Invalid_constant : Script.location * Script.expr * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Invalid_syntactic_constant :
      Script.location * Script.expr * string
      -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_contract of Script.location * Contract.t</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Invalid_big_map of Script.location * Big_map.id</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Comparable_type_expected : Script.location * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Inconsistent_types : Script.expr * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unordered_map_keys of Script.location * Script.expr</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unordered_set_values of Script.location * Script.expr</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Duplicate_map_keys of Script.location * Script.expr</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Duplicate_set_values of Script.location * Script.expr</abbr>

(* Toplevel errors *)
<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Ill_typed_data : string option * Script.expr * Script.expr -&gt; error</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Ill_formed_type of string option * Script.expr * Script.location</abbr>

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Ill_typed_contract : Script.expr * type_map -&gt; error</abbr>

(* Gas related errors *)
<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Cannot_serialize_error</abbr>

(* Deprecation errors *)
<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Deprecated_instruction of prim</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_tc_errors.ml"><code>Script_tc_errors.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.

Import Alpha_context.

Import Script.

Inductive namespace : Set :=
| Type_namespace : namespace
| Constant_namespace : namespace
| Instr_namespace : namespace
| Keyword_namespace : namespace.

Inductive kind : Set :=
| Int_kind : kind
| String_kind : kind
| Bytes_kind : kind
| Prim_kind : kind
| Seq_kind : kind.

Definition unparsed_stack_ty :=
  list (Alpha_context.Script.expr * Alpha_context.Script.annot).

Definition type_map := list (Z * (unparsed_stack_ty * unparsed_stack_ty)).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_tc_errors_registration.ml">
  <div class="col-md-6">
    <a href="#script_tc_errors_registration.ml"><code>script_tc_errors_registration.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script
open Script_tc_errors

(* Helpers for encoding *)
let type_map_enc =
  let open Data_encoding in
  let stack_enc = list (tup2 Script.expr_encoding (list string)) in
  list
    (conv
       (fun (loc, (bef, aft)) -&gt; (loc, bef, aft))
       (fun (loc, bef, aft) -&gt; (loc, (bef, aft)))
       (obj3
          (req &quot;location&quot; Script.location_encoding)
          (req &quot;stack_before&quot; stack_enc)
          (req &quot;stack_after&quot; stack_enc)))

let stack_ty_enc =
  let open Data_encoding in
  list (obj2 (req &quot;type&quot; Script.expr_encoding) (dft &quot;annots&quot; (list string) []))

(* main registration *)
<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  let open Data_encoding in
  let located enc =
    merge_objs (obj1 (req &quot;location&quot; Script.location_encoding)) enc
  in
  let arity_enc = int8 in
  let namespace_enc =
    def
      &quot;primitiveNamespace&quot;
      ~title:&quot;Primitive namespace&quot;
      ~description:
        &quot;One of the three possible namespaces of primitive (data constructor, \
         type name or instruction).&quot;
    @@ string_enum
         [ (&quot;type&quot;, Type_namespace);
           (&quot;constant&quot;, Constant_namespace);
           (&quot;instruction&quot;, Instr_namespace) ]
  in
  let kind_enc =
    def
      &quot;expressionKind&quot;
      ~title:&quot;Expression kind&quot;
      ~description:
        &quot;One of the four possible kinds of expression (integer, string, \
         primitive application or sequence).&quot;
    @@ string_enum
         [ (&quot;integer&quot;, Int_kind);
           (&quot;string&quot;, String_kind);
           (&quot;bytes&quot;, Bytes_kind);
           (&quot;primitiveApplication&quot;, Prim_kind);
           (&quot;sequence&quot;, Seq_kind) ]
  in
  (* -- Structure errors ---------------------- *)
  (* Invalid arity *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_arity&quot;
    ~title:&quot;Invalid arity&quot;
    ~description:
      &quot;In a script or data expression, a primitive was applied to an \
       unsupported number of arguments.&quot;
    (located
       (obj3
          (req &quot;primitive_name&quot; Script.prim_encoding)
          (req &quot;expected_arity&quot; arity_enc)
          (req &quot;wrong_arity&quot; arity_enc)))
    (function
      | Invalid_arity (loc, name, exp, got) -&gt;
          Some (loc, (name, exp, got))
      | _ -&gt;
          None)
    (fun (loc, (name, exp, got)) -&gt; Invalid_arity (loc, name, exp, got)) ;
  (* Missing field *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.missing_script_field&quot;
    ~title:&quot;Script is missing a field (parse error)&quot;
    ~description:&quot;When parsing script, a field was expected, but not provided&quot;
    (obj1 (req &quot;prim&quot; prim_encoding))
    (function Missing_field prim -&gt; Some prim | _ -&gt; None)
    (fun prim -&gt; Missing_field prim) ;
  (* Invalid primitive *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive&quot;
    ~title:&quot;Invalid primitive&quot;
    ~description:&quot;In a script or data expression, a primitive was unknown.&quot;
    (located
       (obj2
          (dft &quot;expected_primitive_names&quot; (list prim_encoding) [])
          (req &quot;wrong_primitive_name&quot; prim_encoding)))
    (function
      | Invalid_primitive (loc, exp, got) -&gt; Some (loc, (exp, got)) | _ -&gt; None)
    (fun (loc, (exp, got)) -&gt; Invalid_primitive (loc, exp, got)) ;
  (* Invalid kind *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_expression_kind&quot;
    ~title:&quot;Invalid expression kind&quot;
    ~description:
      &quot;In a script or data expression, an expression was of the wrong kind \
       (for instance a string where only a primitive applications can appear).&quot;
    (located
       (obj2 (req &quot;expected_kinds&quot; (list kind_enc)) (req &quot;wrong_kind&quot; kind_enc)))
    (function
      | Invalid_kind (loc, exp, got) -&gt; Some (loc, (exp, got)) | _ -&gt; None)
    (fun (loc, (exp, got)) -&gt; Invalid_kind (loc, exp, got)) ;
  (* Invalid namespace *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive_namespace&quot;
    ~title:&quot;Invalid primitive namespace&quot;
    ~description:
      &quot;In a script or data expression, a primitive was of the wrong namespace.&quot;
    (located
       (obj3
          (req &quot;primitive_name&quot; prim_encoding)
          (req &quot;expected_namespace&quot; namespace_enc)
          (req &quot;wrong_namespace&quot; namespace_enc)))
    (function
      | Invalid_namespace (loc, name, exp, got) -&gt;
          Some (loc, (name, exp, got))
      | _ -&gt;
          None)
    (fun (loc, (name, exp, got)) -&gt; Invalid_namespace (loc, name, exp, got)) ;
  (* Duplicate field *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_script_field&quot;
    ~title:&quot;Script has a duplicated field (parse error)&quot;
    ~description:&quot;When parsing script, a field was found more than once&quot;
    (obj2 (req &quot;loc&quot; location_encoding) (req &quot;prim&quot; prim_encoding))
    (function Duplicate_field (loc, prim) -&gt; Some (loc, prim) | _ -&gt; None)
    (fun (loc, prim) -&gt; Duplicate_field (loc, prim)) ;
  (* Unexpected big_map *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_bigmap&quot;
    ~title:&quot;Big map in unauthorized position (type error)&quot;
    ~description:
      &quot;When parsing script, a big_map type was found in a position where it \
       could end up stored inside a big_map, which is forbidden for now.&quot;
    (obj1 (req &quot;loc&quot; location_encoding))
    (function Unexpected_big_map loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Unexpected_big_map loc) ;
  (* Unexpected operation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_operation&quot;
    ~title:&quot;Operation in unauthorized position (type error)&quot;
    ~description:
      &quot;When parsing script, an operation type was found in the storage or \
       parameter field.&quot;
    (obj1 (req &quot;loc&quot; location_encoding))
    (function Unexpected_operation loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Unexpected_operation loc) ;
  (* No such entrypoint *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.no_such_entrypoint&quot;
    ~title:&quot;No such entrypoint (type error)&quot;
    ~description:&quot;An entrypoint was not found when calling a contract.&quot;
    (obj1 (req &quot;entrypoint&quot; string))
    (function No_such_entrypoint entrypoint -&gt; Some entrypoint | _ -&gt; None)
    (fun entrypoint -&gt; No_such_entrypoint entrypoint) ;
  (* Unreachable entrypoint *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unreachable_entrypoint&quot;
    ~title:&quot;Unreachable entrypoint (type error)&quot;
    ~description:&quot;An entrypoint in the contract is not reachable.&quot;
    (obj1 (req &quot;path&quot; (list prim_encoding)))
    (function Unreachable_entrypoint path -&gt; Some path | _ -&gt; None)
    (fun path -&gt; Unreachable_entrypoint path) ;
  (* Duplicate entrypoint *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_entrypoint&quot;
    ~title:&quot;Duplicate entrypoint (type error)&quot;
    ~description:&quot;Two entrypoints have the same name.&quot;
    (obj1 (req &quot;path&quot; string))
    (function Duplicate_entrypoint entrypoint -&gt; Some entrypoint | _ -&gt; None)
    (fun entrypoint -&gt; Duplicate_entrypoint entrypoint) ;
  (* Entrypoint name too long *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.entrypoint_name_too_long&quot;
    ~title:&quot;Entrypoint name too long (type error)&quot;
    ~description:
      &quot;An entrypoint name exceeds the maximum length of 31 characters.&quot;
    (obj1 (req &quot;name&quot; string))
    (function
      | Entrypoint_name_too_long entrypoint -&gt; Some entrypoint | _ -&gt; None)
    (fun entrypoint -&gt; Entrypoint_name_too_long entrypoint) ;
  (* Unexpected contract *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_contract&quot;
    ~title:&quot;Contract in unauthorized position (type error)&quot;
    ~description:
      &quot;When parsing script, a contract type was found in the storage or \
       parameter field.&quot;
    (obj1 (req &quot;loc&quot; location_encoding))
    (function Unexpected_contract loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Unexpected_contract loc) ;
  (* -- Value typing errors ---------------------- *)
  (* Unordered map keys *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unordered_map_literal&quot;
    ~title:&quot;Invalid map key order&quot;
    ~description:&quot;Map keys must be in strictly increasing order&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;item&quot; Script.expr_encoding))
    (function Unordered_map_keys (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Unordered_map_keys (loc, expr)) ;
  (* Duplicate map keys *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_map_keys&quot;
    ~title:&quot;Duplicate map keys&quot;
    ~description:&quot;Map literals cannot contain duplicated keys&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;item&quot; Script.expr_encoding))
    (function Duplicate_map_keys (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Duplicate_map_keys (loc, expr)) ;
  (* Unordered set values *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unordered_set_literal&quot;
    ~title:&quot;Invalid set value order&quot;
    ~description:&quot;Set values must be in strictly increasing order&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;value&quot; Script.expr_encoding))
    (function
      | Unordered_set_values (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Unordered_set_values (loc, expr)) ;
  (* Duplicate set values *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_set_values_in_literal&quot;
    ~title:&quot;Sets literals cannot contain duplicate elements&quot;
    ~description:
      &quot;Set literals cannot contain duplicate elements, but a duplicae was \
       found while parsing.&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;value&quot; Script.expr_encoding))
    (function
      | Duplicate_set_values (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Duplicate_set_values (loc, expr)) ;
  (* -- Instruction typing errors ------------- *)
  (* Fail not in tail position *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.fail_not_in_tail_position&quot;
    ~title:&quot;FAIL not in tail position&quot;
    ~description:&quot;There is non trivial garbage code after a FAIL instruction.&quot;
    (located empty)
    (function Fail_not_in_tail_position loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Fail_not_in_tail_position loc) ;
  (* Undefined binary operation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.undefined_binop&quot;
    ~title:&quot;Undefined binop&quot;
    ~description:
      &quot;A binary operation is called on operands of types over which it is not \
       defined.&quot;
    (located
       (obj3
          (req &quot;operator_name&quot; prim_encoding)
          (req &quot;wrong_left_operand_type&quot; Script.expr_encoding)
          (req &quot;wrong_right_operand_type&quot; Script.expr_encoding)))
    (function
      | Undefined_binop (loc, n, tyl, tyr) -&gt;
          Some (loc, (n, tyl, tyr))
      | _ -&gt;
          None)
    (fun (loc, (n, tyl, tyr)) -&gt; Undefined_binop (loc, n, tyl, tyr)) ;
  (* Undefined unary operation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.undefined_unop&quot;
    ~title:&quot;Undefined unop&quot;
    ~description:
      &quot;A unary operation is called on an operand of type over which it is not \
       defined.&quot;
    (located
       (obj2
          (req &quot;operator_name&quot; prim_encoding)
          (req &quot;wrong_operand_type&quot; Script.expr_encoding)))
    (function Undefined_unop (loc, n, ty) -&gt; Some (loc, (n, ty)) | _ -&gt; None)
    (fun (loc, (n, ty)) -&gt; Undefined_unop (loc, n, ty)) ;
  (* Bad return *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_return&quot;
    ~title:&quot;Bad return&quot;
    ~description:&quot;Unexpected stack at the end of a lambda or script.&quot;
    (located
       (obj2
          (req &quot;expected_return_type&quot; Script.expr_encoding)
          (req &quot;wrong_stack_type&quot; stack_ty_enc)))
    (function Bad_return (loc, sty, ty) -&gt; Some (loc, (ty, sty)) | _ -&gt; None)
    (fun (loc, (ty, sty)) -&gt; Bad_return (loc, sty, ty)) ;
  (* Bad stack *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_stack&quot;
    ~title:&quot;Bad stack&quot;
    ~description:&quot;The stack has an unexpected length or contents.&quot;
    (located
       (obj3
          (req &quot;primitive_name&quot; prim_encoding)
          (req &quot;relevant_stack_portion&quot; int16)
          (req &quot;wrong_stack_type&quot; stack_ty_enc)))
    (function
      | Bad_stack (loc, name, s, sty) -&gt; Some (loc, (name, s, sty)) | _ -&gt; None)
    (fun (loc, (name, s, sty)) -&gt; Bad_stack (loc, name, s, sty)) ;
  (* Inconsistent annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_annotations&quot;
    ~title:&quot;Annotations inconsistent between branches&quot;
    ~description:&quot;The annotations on two types could not be merged&quot;
    (obj2 (req &quot;annot1&quot; string) (req &quot;annot2&quot; string))
    (function
      | Inconsistent_annotations (annot1, annot2) -&gt;
          Some (annot1, annot2)
      | _ -&gt;
          None)
    (fun (annot1, annot2) -&gt; Inconsistent_annotations (annot1, annot2)) ;
  (* Inconsistent field annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_field_annotations&quot;
    ~title:&quot;Annotations for field accesses is inconsistent&quot;
    ~description:
      &quot;The specified field does not match the field annotation in the type&quot;
    (obj2 (req &quot;annot1&quot; string) (req &quot;annot2&quot; string))
    (function
      | Inconsistent_field_annotations (annot1, annot2) -&gt;
          Some (annot1, annot2)
      | _ -&gt;
          None)
    (fun (annot1, annot2) -&gt; Inconsistent_field_annotations (annot1, annot2)) ;
  (* Inconsistent type annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_type_annotations&quot;
    ~title:&quot;Types contain inconsistent annotations&quot;
    ~description:&quot;The two types contain annotations that do not match&quot;
    (located
       (obj2
          (req &quot;type1&quot; Script.expr_encoding)
          (req &quot;type2&quot; Script.expr_encoding)))
    (function
      | Inconsistent_type_annotations (loc, ty1, ty2) -&gt;
          Some (loc, (ty1, ty2))
      | _ -&gt;
          None)
    (fun (loc, (ty1, ty2)) -&gt; Inconsistent_type_annotations (loc, ty1, ty2)) ;
  (* Unexpected annotation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_annotation&quot;
    ~title:&quot;An annotation was encountered where no annotation is expected&quot;
    ~description:&quot;A node in the syntax tree was impropperly annotated&quot;
    (located empty)
    (function Unexpected_annotation loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Unexpected_annotation loc) ;
  (* Ungrouped annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ungrouped_annotations&quot;
    ~title:&quot;Annotations of the same kind were found spread apart&quot;
    ~description:&quot;Annotations of the same kind must be grouped&quot;
    (located empty)
    (function Ungrouped_annotations loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Ungrouped_annotations loc) ;
  (* Unmatched branches *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unmatched_branches&quot;
    ~title:&quot;Unmatched branches&quot;
    ~description:
      &quot;At the join point at the end of two code branches the stacks have \
       inconsistent lengths or contents.&quot;
    (located
       (obj2
          (req &quot;first_stack_type&quot; stack_ty_enc)
          (req &quot;other_stack_type&quot; stack_ty_enc)))
    (function
      | Unmatched_branches (loc, stya, styb) -&gt;
          Some (loc, (stya, styb))
      | _ -&gt;
          None)
    (fun (loc, (stya, styb)) -&gt; Unmatched_branches (loc, stya, styb)) ;
  (* Bad stack item *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_stack_item&quot;
    ~title:&quot;Bad stack item&quot;
    ~description:
      &quot;The type of a stack item is unexpected (this error is always \
       accompanied by a more precise one).&quot;
    (obj1 (req &quot;item_level&quot; int16))
    (function Bad_stack_item n -&gt; Some n | _ -&gt; None)
    (fun n -&gt; Bad_stack_item n) ;
  (* SELF in lambda *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.self_in_lambda&quot;
    ~title:&quot;SELF instruction in lambda&quot;
    ~description:&quot;A SELF instruction was encountered in a lambda expression.&quot;
    (located empty)
    (function Self_in_lambda loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Self_in_lambda loc) ;
  (* Bad stack length *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_stack_lengths&quot;
    ~title:&quot;Inconsistent stack lengths&quot;
    ~description:
      &quot;A stack was of an unexpected length (this error is always in the \
       context of a located error).&quot;
    empty
    (function Bad_stack_length -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Bad_stack_length) ;
  (* -- Value typing errors ------------------- *)
  (* Invalid constant *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_constant&quot;
    ~title:&quot;Invalid constant&quot;
    ~description:&quot;A data expression was invalid for its expected type.&quot;
    (located
       (obj2
          (req &quot;expected_type&quot; Script.expr_encoding)
          (req &quot;wrong_expression&quot; Script.expr_encoding)))
    (function
      | Invalid_constant (loc, expr, ty) -&gt; Some (loc, (ty, expr)) | _ -&gt; None)
    (fun (loc, (ty, expr)) -&gt; Invalid_constant (loc, expr, ty)) ;
  (* Invalid syntactic constant *)
  register_error_kind
    `Permanent
    ~id:&quot;invalidSyntacticConstantError&quot;
    ~title:&quot;Invalid constant (parse error)&quot;
    ~description:&quot;A compile-time constant was invalid for its expected form.&quot;
    (located
       (obj2
          (req &quot;expectedForm&quot; Script.expr_encoding)
          (req &quot;wrongExpression&quot; Script.expr_encoding)))
    (function
      | Invalid_constant (loc, expr, ty) -&gt; Some (loc, (ty, expr)) | _ -&gt; None)
    (fun (loc, (ty, expr)) -&gt; Invalid_constant (loc, expr, ty)) ;
  (* Invalid contract *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_contract&quot;
    ~title:&quot;Invalid contract&quot;
    ~description:
      &quot;A script or data expression references a contract that does not exist \
       or assumes a wrong type for an existing contract.&quot;
    (located (obj1 (req &quot;contract&quot; Contract.encoding)))
    (function Invalid_contract (loc, c) -&gt; Some (loc, c) | _ -&gt; None)
    (fun (loc, c) -&gt; Invalid_contract (loc, c)) ;
  (* Invalid big_map *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_big_map&quot;
    ~title:&quot;Invalid big_map&quot;
    ~description:
      &quot;A script or data expression references a big_map that does not exist \
       or assumes a wrong type for an existing big_map.&quot;
    (located (obj1 (req &quot;big_map&quot; z)))
    (function Invalid_big_map (loc, c) -&gt; Some (loc, c) | _ -&gt; None)
    (fun (loc, c) -&gt; Invalid_big_map (loc, c)) ;
  (* Comparable type expected *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.comparable_type_expected&quot;
    ~title:&quot;Comparable type expected&quot;
    ~description:
      &quot;A non comparable type was used in a place where only comparable types \
       are accepted.&quot;
    (located (obj1 (req &quot;wrong_type&quot; Script.expr_encoding)))
    (function
      | Comparable_type_expected (loc, ty) -&gt; Some (loc, ty) | _ -&gt; None)
    (fun (loc, ty) -&gt; Comparable_type_expected (loc, ty)) ;
  (* Inconsistent types *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_types&quot;
    ~title:&quot;Inconsistent types&quot;
    ~description:
      &quot;This is the basic type clash error, that appears in several places \
       where the equality of two types have to be proven, it is always \
       accompanied with another error that provides more context.&quot;
    (obj2
       (req &quot;first_type&quot; Script.expr_encoding)
       (req &quot;other_type&quot; Script.expr_encoding))
    (function Inconsistent_types (tya, tyb) -&gt; Some (tya, tyb) | _ -&gt; None)
    (fun (tya, tyb) -&gt; Inconsistent_types (tya, tyb)) ;
  (* -- Instruction typing errors ------------------- *)
  (* Invalid map body *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_map_body&quot;
    ~title:&quot;Invalid map body&quot;
    ~description:&quot;The body of a map block did not match the expected type&quot;
    (obj2 (req &quot;loc&quot; Script.location_encoding) (req &quot;body_type&quot; stack_ty_enc))
    (function Invalid_map_body (loc, stack) -&gt; Some (loc, stack) | _ -&gt; None)
    (fun (loc, stack) -&gt; Invalid_map_body (loc, stack)) ;
  (* Invalid map block FAIL *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_map_block_fail&quot;
    ~title:&quot;FAIL instruction occurred as body of map block&quot;
    ~description:
      &quot;FAIL cannot be the only instruction in the body. The propper type of \
       the return list cannot be inferred.&quot;
    (obj1 (req &quot;loc&quot; Script.location_encoding))
    (function Invalid_map_block_fail loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Invalid_map_block_fail loc) ;
  (* Invalid ITER body *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_iter_body&quot;
    ~title:&quot;ITER body returned wrong stack type&quot;
    ~description:
      &quot;The body of an ITER instruction must result in the same stack type as \
       before the ITER.&quot;
    (obj3
       (req &quot;loc&quot; Script.location_encoding)
       (req &quot;bef_stack&quot; stack_ty_enc)
       (req &quot;aft_stack&quot; stack_ty_enc))
    (function
      | Invalid_iter_body (loc, bef, aft) -&gt; Some (loc, bef, aft) | _ -&gt; None)
    (fun (loc, bef, aft) -&gt; Invalid_iter_body (loc, bef, aft)) ;
  (* Type too large *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.type_too_large&quot;
    ~title:&quot;Stack item type too large&quot;
    ~description:&quot;An instruction generated a type larger than the limit.&quot;
    (obj3
       (req &quot;loc&quot; Script.location_encoding)
       (req &quot;type_size&quot; uint16)
       (req &quot;maximum_type_size&quot; uint16))
    (function
      | Type_too_large (loc, ts, maxts) -&gt; Some (loc, ts, maxts) | _ -&gt; None)
    (fun (loc, ts, maxts) -&gt; Type_too_large (loc, ts, maxts)) ;
  (* -- Toplevel errors ------------------- *)
  (* Ill typed data *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ill_typed_data&quot;
    ~title:&quot;Ill typed data&quot;
    ~description:
      &quot;The toplevel error thrown when trying to typecheck a data expression \
       against a given type (always followed by more precise errors).&quot;
    (obj3
       (opt &quot;identifier&quot; string)
       (req &quot;expected_type&quot; Script.expr_encoding)
       (req &quot;ill_typed_expression&quot; Script.expr_encoding))
    (function
      | Ill_typed_data (name, expr, ty) -&gt; Some (name, ty, expr) | _ -&gt; None)
    (fun (name, ty, expr) -&gt; Ill_typed_data (name, expr, ty)) ;
  (* Ill formed type *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ill_formed_type&quot;
    ~title:&quot;Ill formed type&quot;
    ~description:
      &quot;The toplevel error thrown when trying to parse a type expression \
       (always followed by more precise errors).&quot;
    (obj3
       (opt &quot;identifier&quot; string)
       (req &quot;ill_formed_expression&quot; Script.expr_encoding)
       (req &quot;location&quot; Script.location_encoding))
    (function
      | Ill_formed_type (name, expr, loc) -&gt; Some (name, expr, loc) | _ -&gt; None)
    (fun (name, expr, loc) -&gt; Ill_formed_type (name, expr, loc)) ;
  (* Ill typed contract *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ill_typed_contract&quot;
    ~title:&quot;Ill typed contract&quot;
    ~description:
      &quot;The toplevel error thrown when trying to typecheck a contract code \
       against given input, output and storage types (always followed by more \
       precise errors).&quot;
    (obj2
       (req &quot;ill_typed_code&quot; Script.expr_encoding)
       (req &quot;type_map&quot; type_map_enc))
    (function
      | Ill_typed_contract (expr, type_map) -&gt;
          Some (expr, type_map)
      | _ -&gt;
          None)
    (fun (expr, type_map) -&gt; Ill_typed_contract (expr, type_map)) ;
  (* Cannot serialize error *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_error&quot;
    ~title:&quot;Not enough gas to serialize error&quot;
    ~description:&quot;The error was too big to be serialized with the provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_error -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_error) ;
  (* Deprecated instruction *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.deprecated_instruction&quot;
    ~title:&quot;Script is using a deprecated instruction&quot;
    ~description:
      &quot;A deprecated instruction usage is disallowed in newly created contracts&quot;
    (obj1 (req &quot;prim&quot; prim_encoding))
    (function Deprecated_instruction prim -&gt; Some prim | _ -&gt; None)
    (fun prim -&gt; Deprecated_instruction prim)</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_tc_errors_registration.ml"><code>Script_tc_errors_registration.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.

Import Alpha_context.

Import Script.

Import Script_tc_errors.

Definition type_map_enc
  : Data_encoding.encoding
    (list
      (Alpha_context.Script.location *
        (list (Alpha_context.Script.expr * list string) *
          list (Alpha_context.Script.expr * list string)))) :=
  let stack_enc :=
    Data_encoding.__list_value None
      (Data_encoding.tup2 Alpha_context.Script.expr_encoding
        (Data_encoding.__list_value None Data_encoding.__string_value)) in
  Data_encoding.__list_value None
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '(loc, (bef, aft)) := function_parameter in
        (loc, bef, aft))
      (fun function_parameter =&gt;
        let '(loc, bef, aft) := function_parameter in
        (loc, (bef, aft))) None
      (Data_encoding.obj3
        (Data_encoding.req None None &quot;location&quot; % string
          Alpha_context.Script.location_encoding)
        (Data_encoding.req None None &quot;stack_before&quot; % string stack_enc)
        (Data_encoding.req None None &quot;stack_after&quot; % string stack_enc))).

Definition stack_ty_enc
  : Data_encoding.encoding (list (Alpha_context.Script.expr * list string)) :=
  Data_encoding.__list_value None
    (Data_encoding.obj2
      (Data_encoding.req None None &quot;type&quot; % string
        Alpha_context.Script.expr_encoding)
      (Data_encoding.dft None None &quot;annots&quot; % string
        (Data_encoding.__list_value None Data_encoding.__string_value) [])).

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_timestamp_repr.ml">
  <div class="col-md-6">
    <a href="#script_timestamp_repr.ml"><code>script_timestamp_repr.ml</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Z.t

let compare = Z.compare

let of_int64 = Z.of_int64

let of_string x =
  match Time_repr.of_notation x with
  | None -&gt; <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
    try Some (Z.of_string x) with _ -&gt; None )</abbr>
  | Some time -&gt;
      Some (of_int64 (Time_repr.to_seconds time))

let to_notation x =
  <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let notation = Time_repr.to_notation (Time.of_seconds (Z.to_int64 x)) in
    if String.equal notation &quot;out_of_range&quot; then None else Some notation
  with _ -&gt; None</abbr>

let to_num_str = Z.to_string

let to_string x = match to_notation x with None -&gt; to_num_str x | Some s -&gt; s

let diff x y = Script_int_repr.of_zint @@ Z.sub x y

let sub_delta t delta = Z.sub t (Script_int_repr.to_zint delta)

let add_delta t delta = Z.add t (Script_int_repr.to_zint delta)

let to_zint x = x

let of_zint x = x
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_timestamp_repr.ml"><code>Script_timestamp_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Script_int_repr.
Require Tezos.Time_repr.

Definition t := Z.t.

Definition compare : Z.t -&gt; Z.t -&gt; Z := Z.compare.

Definition of_int64 : int64 -&gt; Z.t := Z.of_int64.

Definition of_string (x : string) : option Z.t :=
  match Time_repr.of_notation x with
  | None =&gt;
    (* ‚ùå Try-with are not handled *)
    try (Some (Z.of_string x))
  | Some time =&gt; Some (of_int64 (Time_repr.to_seconds time))
  end.

Definition to_notation (x : Z.t) : option string :=
  (* ‚ùå Try-with are not handled *)
  try
    (let notation := Time_repr.to_notation (Time.of_seconds (Z.to_int64 x)) in
    if String.equal notation &quot;out_of_range&quot; % string then
      None
    else
      Some notation).

Definition to_num_str : Z.t -&gt; string := Z.to_string.

Definition to_string (x : Z.t) : string :=
  match to_notation x with
  | None =&gt; to_num_str x
  | Some s =&gt; s
  end.

Definition diff (x : Z.t) (y : Z.t) : Script_int_repr.num Script_int_repr.z :=
  Pervasives.op_atat Script_int_repr.of_zint (Z.sub x y).

Definition sub_delta {A : Set} (t : Z.t) (delta : Script_int_repr.num A)
  : Z.t := Z.sub t (Script_int_repr.to_zint delta).

Definition add_delta {A : Set} (t : Z.t) (delta : Script_int_repr.num A)
  : Z.t := Z.add t (Script_int_repr.to_zint delta).

Definition to_zint {A : Set} (x : A) : A := x.

Definition of_zint {A : Set} (x : A) : A := x.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_timestamp_repr.mli">
  <div class="col-md-6">
    <a href="#script_timestamp_repr.mli"><code>script_timestamp_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Script_int_repr

type t

val of_int64 : int64 -&gt; t

val compare : t -&gt; t -&gt; int

(* Convert a timestamp to a notation if possible *)
val to_notation : t -&gt; string option

(* Convert a timestamp to a string representation of the seconds *)
val to_num_str : t -&gt; string

(* Convert to a notation if possible, or num if not *)
val to_string : t -&gt; string

val of_string : string -&gt; t option

val diff : t -&gt; t -&gt; z num

val add_delta : t -&gt; z num -&gt; t

val sub_delta : t -&gt; z num -&gt; t

val to_zint : t -&gt; Z.t

val of_zint : Z.t -&gt; t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_timestamp_repr.mli"><code>Script_timestamp_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Script_int_repr.

Parameter t : Set.

Parameter of_int64 : int64 -&gt; t.

Parameter compare : t -&gt; t -&gt; Z.

Parameter to_notation : t -&gt; option string.

Parameter to_num_str : t -&gt; string.

Parameter to_string : t -&gt; string.

Parameter of_string : string -&gt; option t.

Parameter diff : t -&gt; t -&gt; Script_int_repr.num Script_int_repr.z.

Parameter add_delta : t -&gt; Script_int_repr.num Script_int_repr.z -&gt; t.

Parameter sub_delta : t -&gt; Script_int_repr.num Script_int_repr.z -&gt; t.

Parameter to_zint : t -&gt; Z.t.

Parameter of_zint : Z.t -&gt; t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_typed_ir.ml">
  <div class="col-md-6">
    <a href="#script_typed_ir.ml"><code>script_typed_ir.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script_int

(* ---- Auxiliary types -----------------------------------------------------*)

<abbr class="mark-error" title="Polymorphic variant types are not handled">type var_annot = [`Var_annot of string]</abbr>

<abbr class="mark-error" title="Polymorphic variant types are not handled">type type_annot = [`Type_annot of string]</abbr>

<abbr class="mark-error" title="Polymorphic variant types are not handled">type field_annot = [`Field_annot of string]</abbr>

<abbr class="mark-error" title="Polymorphic variant types are not handled">type annot = [var_annot | type_annot | field_annot]</abbr>

type address = Contract.t * string

type ('a, 'b) pair = 'a * 'b

type ('a, 'b) union = L of 'a | R of 'b

type comb = Comb

type leaf = Leaf

type (_, _) comparable_struct =
  | Int_key : type_annot option -&gt; (z num, _) comparable_struct
  | Nat_key : type_annot option -&gt; (n num, _) comparable_struct
  | String_key : type_annot option -&gt; (string, _) comparable_struct
  | Bytes_key : type_annot option -&gt; (MBytes.t, _) comparable_struct
  | Mutez_key : type_annot option -&gt; (Tez.t, _) comparable_struct
  | Bool_key : type_annot option -&gt; (bool, _) comparable_struct
  | Key_hash_key : type_annot option -&gt; (public_key_hash, _) comparable_struct
  | Timestamp_key :
      type_annot option
      -&gt; (Script_timestamp.t, _) comparable_struct
  | Address_key : type_annot option -&gt; (address, _) comparable_struct
  | Pair_key :
      (('a, leaf) comparable_struct * field_annot option)
      * (('b, _) comparable_struct * field_annot option)
      * type_annot option
      -&gt; (('a, 'b) pair, comb) comparable_struct

type 'a comparable_ty = ('a, comb) comparable_struct

module type Boxed_set = sig
  type elt

  val elt_ty : elt comparable_ty

  module OPS : S.SET with type elt = elt

  val boxed : OPS.t

  val size : int
end

type 'elt set = (module Boxed_set with type elt = 'elt)

module type Boxed_map = sig
  type key

  type value

  val key_ty : key comparable_ty

  module OPS : S.MAP with type key = key

  val boxed : value OPS.t * int
end

type ('key, 'value) map =
  (module Boxed_map with type key = 'key and type value = 'value)

type operation = packed_internal_operation * Contract.big_map_diff option

type ('arg, 'storage) script = {
  code : (('arg, 'storage) pair, (operation list, 'storage) pair) lambda;
  arg_type : 'arg ty;
  storage : 'storage;
  storage_type : 'storage ty;
  root_name : string option;
}

and end_of_stack = unit

and ('arg, 'ret) lambda =
  | Lam :
      ('arg * end_of_stack, 'ret * end_of_stack) descr * Script.node
      -&gt; ('arg, 'ret) lambda

and 'arg typed_contract = 'arg ty * address

and 'ty ty =
  | Unit_t : type_annot option -&gt; unit ty
  | Int_t : type_annot option -&gt; z num ty
  | Nat_t : type_annot option -&gt; n num ty
  | Signature_t : type_annot option -&gt; signature ty
  | String_t : type_annot option -&gt; string ty
  | Bytes_t : type_annot option -&gt; MBytes.t ty
  | Mutez_t : type_annot option -&gt; Tez.t ty
  | Key_hash_t : type_annot option -&gt; public_key_hash ty
  | Key_t : type_annot option -&gt; public_key ty
  | Timestamp_t : type_annot option -&gt; Script_timestamp.t ty
  | Address_t : type_annot option -&gt; address ty
  | Bool_t : type_annot option -&gt; bool ty
  | Pair_t :
      ('a ty * field_annot option * var_annot option)
      * ('b ty * field_annot option * var_annot option)
      * type_annot option
      * bool
      -&gt; ('a, 'b) pair ty
  | Union_t :
      ('a ty * field_annot option)
      * ('b ty * field_annot option)
      * type_annot option
      * bool
      -&gt; ('a, 'b) union ty
  | Lambda_t : 'arg ty * 'ret ty * type_annot option -&gt; ('arg, 'ret) lambda ty
  | Option_t : 'v ty * type_annot option * bool -&gt; 'v option ty
  | List_t : 'v ty * type_annot option * bool -&gt; 'v list ty
  | Set_t : 'v comparable_ty * type_annot option -&gt; 'v set ty
  | Map_t :
      'k comparable_ty * 'v ty * type_annot option * bool
      -&gt; ('k, 'v) map ty
  | Big_map_t :
      'k comparable_ty * 'v ty * type_annot option
      -&gt; ('k, 'v) big_map ty
  | Contract_t : 'arg ty * type_annot option -&gt; 'arg typed_contract ty
  | Operation_t : type_annot option -&gt; operation ty
  | Chain_id_t : type_annot option -&gt; Chain_id.t ty

and 'ty stack_ty =
  | Item_t :
      'ty ty * 'rest stack_ty * var_annot option
      -&gt; ('ty * 'rest) stack_ty
  | Empty_t : end_of_stack stack_ty

and ('key, 'value) big_map = {
  id : Z.t option;
  diff : ('key, 'value option) map;
  key_type : 'key ty;
  value_type : 'value ty;
}

(* ---- Instructions --------------------------------------------------------*)

(* The low-level, typed instructions, as a GADT whose parameters
   encode the typing rules.

   The left parameter is the typed shape of the stack before the
   instruction, the right one the shape after. Any program whose
   construction is accepted by OCaml's type-checker is guaranteed to
   be type-safe. Overloadings of the concrete syntax are already
   resolved in this representation, either by using different
   constructors or type witness parameters. *)
and ('bef, 'aft) instr =
  (* stack ops *)
  | Drop : (_ * 'rest, 'rest) instr
  | Dup : ('top * 'rest, 'top * ('top * 'rest)) instr
  | Swap : ('tip * ('top * 'rest), 'top * ('tip * 'rest)) instr
  | Const : 'ty -&gt; ('rest, 'ty * 'rest) instr
  (* pairs *)
  | Cons_pair : ('car * ('cdr * 'rest), ('car, 'cdr) pair * 'rest) instr
  | Car : (('car, _) pair * 'rest, 'car * 'rest) instr
  | Cdr : ((_, 'cdr) pair * 'rest, 'cdr * 'rest) instr
  (* options *)
  | Cons_some : ('v * 'rest, 'v option * 'rest) instr
  | Cons_none : 'a ty -&gt; ('rest, 'a option * 'rest) instr
  | If_none :
      ('bef, 'aft) descr * ('a * 'bef, 'aft) descr
      -&gt; ('a option * 'bef, 'aft) instr
  (* unions *)
  | Left : ('l * 'rest, ('l, 'r) union * 'rest) instr
  | Right : ('r * 'rest, ('l, 'r) union * 'rest) instr
  | If_left :
      ('l * 'bef, 'aft) descr * ('r * 'bef, 'aft) descr
      -&gt; (('l, 'r) union * 'bef, 'aft) instr
  (* lists *)
  | Cons_list : ('a * ('a list * 'rest), 'a list * 'rest) instr
  | Nil : ('rest, 'a list * 'rest) instr
  | If_cons :
      ('a * ('a list * 'bef), 'aft) descr * ('bef, 'aft) descr
      -&gt; ('a list * 'bef, 'aft) instr
  | List_map :
      ('a * 'rest, 'b * 'rest) descr
      -&gt; ('a list * 'rest, 'b list * 'rest) instr
  | List_iter : ('a * 'rest, 'rest) descr -&gt; ('a list * 'rest, 'rest) instr
  | List_size : ('a list * 'rest, n num * 'rest) instr
  (* sets *)
  | Empty_set : 'a comparable_ty -&gt; ('rest, 'a set * 'rest) instr
  | Set_iter : ('a * 'rest, 'rest) descr -&gt; ('a set * 'rest, 'rest) instr
  | Set_mem : ('elt * ('elt set * 'rest), bool * 'rest) instr
  | Set_update : ('elt * (bool * ('elt set * 'rest)), 'elt set * 'rest) instr
  | Set_size : ('a set * 'rest, n num * 'rest) instr
  (* maps *)
  | Empty_map : 'a comparable_ty * 'v ty -&gt; ('rest, ('a, 'v) map * 'rest) instr
  | Map_map :
      (('a * 'v) * 'rest, 'r * 'rest) descr
      -&gt; (('a, 'v) map * 'rest, ('a, 'r) map * 'rest) instr
  | Map_iter :
      (('a * 'v) * 'rest, 'rest) descr
      -&gt; (('a, 'v) map * 'rest, 'rest) instr
  | Map_mem : ('a * (('a, 'v) map * 'rest), bool * 'rest) instr
  | Map_get : ('a * (('a, 'v) map * 'rest), 'v option * 'rest) instr
  | Map_update
      : ('a * ('v option * (('a, 'v) map * 'rest)), ('a, 'v) map * 'rest) instr
  | Map_size : (('a, 'b) map * 'rest, n num * 'rest) instr
  (* big maps *)
  | Empty_big_map :
      'a comparable_ty * 'v ty
      -&gt; ('rest, ('a, 'v) big_map * 'rest) instr
  | Big_map_mem : ('a * (('a, 'v) big_map * 'rest), bool * 'rest) instr
  | Big_map_get : ('a * (('a, 'v) big_map * 'rest), 'v option * 'rest) instr
  | Big_map_update
      : ( 'key * ('value option * (('key, 'value) big_map * 'rest)),
          ('key, 'value) big_map * 'rest )
        instr
  (* string operations *)
  | Concat_string : (string list * 'rest, string * 'rest) instr
  | Concat_string_pair : (string * (string * 'rest), string * 'rest) instr
  | Slice_string
      : (n num * (n num * (string * 'rest)), string option * 'rest) instr
  | String_size : (string * 'rest, n num * 'rest) instr
  (* bytes operations *)
  | Concat_bytes : (MBytes.t list * 'rest, MBytes.t * 'rest) instr
  | Concat_bytes_pair : (MBytes.t * (MBytes.t * 'rest), MBytes.t * 'rest) instr
  | Slice_bytes
      : (n num * (n num * (MBytes.t * 'rest)), MBytes.t option * 'rest) instr
  | Bytes_size : (MBytes.t * 'rest, n num * 'rest) instr
  (* timestamp operations *)
  | Add_seconds_to_timestamp
      : ( z num * (Script_timestamp.t * 'rest),
          Script_timestamp.t * 'rest )
        instr
  | Add_timestamp_to_seconds
      : ( Script_timestamp.t * (z num * 'rest),
          Script_timestamp.t * 'rest )
        instr
  | Sub_timestamp_seconds
      : ( Script_timestamp.t * (z num * 'rest),
          Script_timestamp.t * 'rest )
        instr
  | Diff_timestamps
      : ( Script_timestamp.t * (Script_timestamp.t * 'rest),
          z num * 'rest )
        instr
  (* tez operations *)
  | Add_tez : (Tez.t * (Tez.t * 'rest), Tez.t * 'rest) instr
  | Sub_tez : (Tez.t * (Tez.t * 'rest), Tez.t * 'rest) instr
  | Mul_teznat : (Tez.t * (n num * 'rest), Tez.t * 'rest) instr
  | Mul_nattez : (n num * (Tez.t * 'rest), Tez.t * 'rest) instr
  | Ediv_teznat
      : (Tez.t * (n num * 'rest), (Tez.t, Tez.t) pair option * 'rest) instr
  | Ediv_tez
      : (Tez.t * (Tez.t * 'rest), (n num, Tez.t) pair option * 'rest) instr
  (* boolean operations *)
  | Or : (bool * (bool * 'rest), bool * 'rest) instr
  | And : (bool * (bool * 'rest), bool * 'rest) instr
  | Xor : (bool * (bool * 'rest), bool * 'rest) instr
  | Not : (bool * 'rest, bool * 'rest) instr
  (* integer operations *)
  | Is_nat : (z num * 'rest, n num option * 'rest) instr
  | Neg_nat : (n num * 'rest, z num * 'rest) instr
  | Neg_int : (z num * 'rest, z num * 'rest) instr
  | Abs_int : (z num * 'rest, n num * 'rest) instr
  | Int_nat : (n num * 'rest, z num * 'rest) instr
  | Add_intint : (z num * (z num * 'rest), z num * 'rest) instr
  | Add_intnat : (z num * (n num * 'rest), z num * 'rest) instr
  | Add_natint : (n num * (z num * 'rest), z num * 'rest) instr
  | Add_natnat : (n num * (n num * 'rest), n num * 'rest) instr
  | Sub_int : ('s num * ('t num * 'rest), z num * 'rest) instr
  | Mul_intint : (z num * (z num * 'rest), z num * 'rest) instr
  | Mul_intnat : (z num * (n num * 'rest), z num * 'rest) instr
  | Mul_natint : (n num * (z num * 'rest), z num * 'rest) instr
  | Mul_natnat : (n num * (n num * 'rest), n num * 'rest) instr
  | Ediv_intint
      : (z num * (z num * 'rest), (z num, n num) pair option * 'rest) instr
  | Ediv_intnat
      : (z num * (n num * 'rest), (z num, n num) pair option * 'rest) instr
  | Ediv_natint
      : (n num * (z num * 'rest), (z num, n num) pair option * 'rest) instr
  | Ediv_natnat
      : (n num * (n num * 'rest), (n num, n num) pair option * 'rest) instr
  | Lsl_nat : (n num * (n num * 'rest), n num * 'rest) instr
  | Lsr_nat : (n num * (n num * 'rest), n num * 'rest) instr
  | Or_nat : (n num * (n num * 'rest), n num * 'rest) instr
  | And_nat : (n num * (n num * 'rest), n num * 'rest) instr
  | And_int_nat : (z num * (n num * 'rest), n num * 'rest) instr
  | Xor_nat : (n num * (n num * 'rest), n num * 'rest) instr
  | Not_nat : (n num * 'rest, z num * 'rest) instr
  | Not_int : (z num * 'rest, z num * 'rest) instr
  (* control *)
  | Seq : ('bef, 'trans) descr * ('trans, 'aft) descr -&gt; ('bef, 'aft) instr
  | If : ('bef, 'aft) descr * ('bef, 'aft) descr -&gt; (bool * 'bef, 'aft) instr
  | Loop : ('rest, bool * 'rest) descr -&gt; (bool * 'rest, 'rest) instr
  | Loop_left :
      ('a * 'rest, ('a, 'b) union * 'rest) descr
      -&gt; (('a, 'b) union * 'rest, 'b * 'rest) instr
  | Dip : ('bef, 'aft) descr -&gt; ('top * 'bef, 'top * 'aft) instr
  | Exec : ('arg * (('arg, 'ret) lambda * 'rest), 'ret * 'rest) instr
  | Apply :
      'arg ty
      -&gt; ( 'arg * (('arg * 'remaining, 'ret) lambda * 'rest),
           ('remaining, 'ret) lambda * 'rest )
         instr
  | Lambda : ('arg, 'ret) lambda -&gt; ('rest, ('arg, 'ret) lambda * 'rest) instr
  | Failwith : 'a ty -&gt; ('a * 'rest, 'aft) instr
  | Nop : ('rest, 'rest) instr
  (* comparison *)
  | Compare : 'a comparable_ty -&gt; ('a * ('a * 'rest), z num * 'rest) instr
  (* comparators *)
  | Eq : (z num * 'rest, bool * 'rest) instr
  | Neq : (z num * 'rest, bool * 'rest) instr
  | Lt : (z num * 'rest, bool * 'rest) instr
  | Gt : (z num * 'rest, bool * 'rest) instr
  | Le : (z num * 'rest, bool * 'rest) instr
  | Ge : (z num * 'rest, bool * 'rest) instr
  (* protocol *)
  | Address : (_ typed_contract * 'rest, address * 'rest) instr
  | Contract :
      'p ty * string
      -&gt; (address * 'rest, 'p typed_contract option * 'rest) instr
  | Transfer_tokens
      : ( 'arg * (Tez.t * ('arg typed_contract * 'rest)),
          operation * 'rest )
        instr
  | Create_account
      : ( public_key_hash * (public_key_hash option * (bool * (Tez.t * 'rest))),
          operation * (address * 'rest) )
        instr
  | Implicit_account
      : (public_key_hash * 'rest, unit typed_contract * 'rest) instr
  | Create_contract :
      'g ty * 'p ty * ('p * 'g, operation list * 'g) lambda * string option
      -&gt; ( public_key_hash
           * (public_key_hash option * (bool * (bool * (Tez.t * ('g * 'rest))))),
           operation * (address * 'rest) )
         instr
  | Create_contract_2 :
      'g ty * 'p ty * ('p * 'g, operation list * 'g) lambda * string option
      -&gt; ( public_key_hash option * (Tez.t * ('g * 'rest)),
           operation * (address * 'rest) )
         instr
  | Set_delegate : (public_key_hash option * 'rest, operation * 'rest) instr
  | Now : ('rest, Script_timestamp.t * 'rest) instr
  | Balance : ('rest, Tez.t * 'rest) instr
  | Check_signature
      : (public_key * (signature * (MBytes.t * 'rest)), bool * 'rest) instr
  | Hash_key : (public_key * 'rest, public_key_hash * 'rest) instr
  | Pack : 'a ty -&gt; ('a * 'rest, MBytes.t * 'rest) instr
  | Unpack : 'a ty -&gt; (MBytes.t * 'rest, 'a option * 'rest) instr
  | Blake2b : (MBytes.t * 'rest, MBytes.t * 'rest) instr
  | Sha256 : (MBytes.t * 'rest, MBytes.t * 'rest) instr
  | Sha512 : (MBytes.t * 'rest, MBytes.t * 'rest) instr
  | Steps_to_quota
      : (* TODO: check that it always returns a nat *)
      ('rest, n num * 'rest) instr
  | Source : ('rest, address * 'rest) instr
  | Sender : ('rest, address * 'rest) instr
  | Self : 'p ty * string -&gt; ('rest, 'p typed_contract * 'rest) instr
  | Amount : ('rest, Tez.t * 'rest) instr
  | Dig :
      int * ('x * 'rest, 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      -&gt; ('bef, 'x * 'aft) instr
  | Dug :
      int * ('rest, 'x * 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      -&gt; ('x * 'bef, 'aft) instr
  | Dipn :
      int
      * ('fbef, 'faft, 'bef, 'aft) stack_prefix_preservation_witness
      * ('fbef, 'faft) descr
      -&gt; ('bef, 'aft) instr
  | Dropn :
      int * ('rest, 'rest, 'bef, _) stack_prefix_preservation_witness
      -&gt; ('bef, 'rest) instr
  | ChainId : ('rest, Chain_id.t * 'rest) instr

(* Type witness for operations that work deep in the stack ignoring
   (and preserving) a prefix.

   The two right parameters are the shape of the stack with the (same)
   prefix before and after the transformation. The two left
   parameters are the shape of the stack without the prefix before and
   after. The inductive definition makes it so by construction. *)
and ('bef, 'aft, 'bef_suffix, 'aft_suffix) stack_prefix_preservation_witness =
  | Prefix :
      ('fbef, 'faft, 'bef, 'aft) stack_prefix_preservation_witness
      -&gt; ('fbef, 'faft, 'x * 'bef, 'x * 'aft) stack_prefix_preservation_witness
  | Rest : ('bef, 'aft, 'bef, 'aft) stack_prefix_preservation_witness

and ('bef, 'aft) descr = {
  loc : Script.location;
  bef : 'bef stack_ty;
  aft : 'aft stack_ty;
  instr : ('bef, 'aft) instr;
}

type ex_big_map = Ex_bm : ('key, 'value) big_map -&gt; ex_big_map
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_typed_ir.ml"><code>Script_typed_ir.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.

Import Alpha_context.

Import Script_int.

Inductive var_annot : Set :=
| Var_annot : string -&gt; var_annot.

Inductive type_annot : Set :=
| Type_annot : string -&gt; type_annot.

Inductive field_annot : Set :=
| Field_annot : string -&gt; field_annot.

Inductive annot : Set :=
| Field_annot : string -&gt; annot
| Var_annot : string -&gt; annot
| Type_annot : string -&gt; annot.

Definition address := Alpha_context.Contract.t * string.

Definition pair (a b : Set) := a * b.

Inductive union (a b : Set) : Set :=
| L : a -&gt; union a b
| R : b -&gt; union a b.

Arguments L {_ _}.
Arguments R {_ _}.

Inductive comb : Set :=
| Comb : comb.

Inductive leaf : Set :=
| Leaf : leaf.

Reserved Notation &quot;'comparable_struct&quot;.

Inductive comparable_struct_gadt : Set :=
| Int_key : option type_annot -&gt; comparable_struct_gadt
| Nat_key : option type_annot -&gt; comparable_struct_gadt
| String_key : option type_annot -&gt; comparable_struct_gadt
| Bytes_key : option type_annot -&gt; comparable_struct_gadt
| Mutez_key : option type_annot -&gt; comparable_struct_gadt
| Bool_key : option type_annot -&gt; comparable_struct_gadt
| Key_hash_key : option type_annot -&gt; comparable_struct_gadt
| Timestamp_key : option type_annot -&gt; comparable_struct_gadt
| Address_key : option type_annot -&gt; comparable_struct_gadt
| Pair_key :
  comparable_struct_gadt * option field_annot -&gt;
  comparable_struct_gadt * option field_annot -&gt; option type_annot -&gt;
  comparable_struct_gadt

where &quot;'comparable_struct&quot; := (fun (_ _ : Set) =&gt; comparable_struct_gadt).

Definition comparable_struct := 'comparable_struct.

Definition comparable_ty (a : Set) := comparable_struct a comb.

Module Boxed_set.
  Record signature {elt OPS_t : Set} := {
    elt := elt;
    elt_ty : comparable_ty elt;
    OPS : S.SET.signature elt OPS_t;
    boxed : OPS.(S.SET.t);
    size : Z;
  }.
  Arguments signature : clear implicits.
End Boxed_set.

Definition set (elt : Set) := {OPS_t : _ &amp; Boxed_set.signature elt OPS_t}.

Module Boxed_map.
  Record signature {key value : Set} {OPS_t : Set -&gt; Set} := {
    key := key;
    value := value;
    key_ty : comparable_ty key;
    OPS : S.MAP.signature key OPS_t;
    boxed : OPS.(S.MAP.t) value * Z;
  }.
  Arguments signature : clear implicits.
End Boxed_map.

Definition map (key value : Set) :=
  {OPS_t : _ &amp; Boxed_map.signature key value OPS_t}.

Definition operation :=
  Alpha_context.packed_internal_operation *
    option Alpha_context.Contract.big_map_diff.

Reserved Notation &quot;'script&quot;.
Reserved Notation &quot;'end_of_stack&quot;.
Reserved Notation &quot;'lambda&quot;.
Reserved Notation &quot;'typed_contract&quot;.
Reserved Notation &quot;'ty&quot;.
Reserved Notation &quot;'stack_ty&quot;.
Reserved Notation &quot;'big_map&quot;.
Reserved Notation &quot;'instr&quot;.
Reserved Notation &quot;'stack_prefix_preservation_witness&quot;.
Reserved Notation &quot;'descr&quot;.

Module descr.
  Record record {loc bef aft instr : Set} := {
    loc : loc;
    bef : bef;
    aft : aft;
    instr : instr }.
  Arguments record : clear implicits.
End descr.
Definition descr_skeleton := descr.record.

Module big_map.
  Record record {id diff key_type value_type : Set} := {
    id : id;
    diff : diff;
    key_type : key_type;
    value_type : value_type }.
  Arguments record : clear implicits.
End big_map.
Definition big_map_skeleton := big_map.record.

Module script.
  Record record {code arg_type storage storage_type root_name : Set} := {
    code : code;
    arg_type : arg_type;
    storage : storage;
    storage_type : storage_type;
    root_name : root_name }.
  Arguments record : clear implicits.
End script.
Definition script_skeleton := script.record.

Inductive lambda_gadt : Set :=
| Lam : forall {arg ret : Set},
  'descr (arg * 'end_of_stack) (ret * 'end_of_stack) -&gt;
  Alpha_context.Script.node -&gt; lambda_gadt

with ty_gadt : Set :=
| Unit_t : option type_annot -&gt; ty_gadt
| Int_t : option type_annot -&gt; ty_gadt
| Nat_t : option type_annot -&gt; ty_gadt
| Signature_t : option type_annot -&gt; ty_gadt
| String_t : option type_annot -&gt; ty_gadt
| Bytes_t : option type_annot -&gt; ty_gadt
| Mutez_t : option type_annot -&gt; ty_gadt
| Key_hash_t : option type_annot -&gt; ty_gadt
| Key_t : option type_annot -&gt; ty_gadt
| Timestamp_t : option type_annot -&gt; ty_gadt
| Address_t : option type_annot -&gt; ty_gadt
| Bool_t : option type_annot -&gt; ty_gadt
| Pair_t :
  ty_gadt * option field_annot * option var_annot -&gt;
  ty_gadt * option field_annot * option var_annot -&gt; option type_annot -&gt;
  bool -&gt; ty_gadt
| Union_t :
  ty_gadt * option field_annot -&gt; ty_gadt * option field_annot -&gt;
  option type_annot -&gt; bool -&gt; ty_gadt
| Lambda_t : ty_gadt -&gt; ty_gadt -&gt; option type_annot -&gt; ty_gadt
| Option_t : ty_gadt -&gt; option type_annot -&gt; bool -&gt; ty_gadt
| List_t : ty_gadt -&gt; option type_annot -&gt; bool -&gt; ty_gadt
| Set_t : forall {v : Set}, comparable_ty v -&gt; option type_annot -&gt; ty_gadt
| Map_t : forall {k : Set},
  comparable_ty k -&gt; ty_gadt -&gt; option type_annot -&gt; bool -&gt; ty_gadt
| Big_map_t : forall {k : Set},
  comparable_ty k -&gt; ty_gadt -&gt; option type_annot -&gt; ty_gadt
| Contract_t : ty_gadt -&gt; option type_annot -&gt; ty_gadt
| Operation_t : option type_annot -&gt; ty_gadt
| Chain_id_t : option type_annot -&gt; ty_gadt

with stack_ty_gadt : Set :=
| Item_t : forall {ty : Set},
  'ty ty -&gt; stack_ty_gadt -&gt; option var_annot -&gt; stack_ty_gadt
| Empty_t : stack_ty_gadt

with instr_gadt : Set :=
| Drop : instr_gadt
| Dup : instr_gadt
| Swap : instr_gadt
| Const : forall {ty : Set}, ty -&gt; instr_gadt
| Cons_pair : instr_gadt
| Car : instr_gadt
| Cdr : instr_gadt
| Cons_some : instr_gadt
| Cons_none : forall {a : Set}, 'ty a -&gt; instr_gadt
| If_none : forall {a aft bef : Set},
  'descr bef aft -&gt; 'descr (a * bef) aft -&gt; instr_gadt
| Left : instr_gadt
| Right : instr_gadt
| If_left : forall {aft bef l r : Set},
  'descr (l * bef) aft -&gt; 'descr (r * bef) aft -&gt; instr_gadt
| Cons_list : instr_gadt
| Nil : instr_gadt
| If_cons : forall {a aft bef : Set},
  'descr (a * (list a * bef)) aft -&gt; 'descr bef aft -&gt; instr_gadt
| List_map : forall {a b rest : Set}, 'descr (a * rest) (b * rest) -&gt; instr_gadt
| List_iter : forall {a rest : Set}, 'descr (a * rest) rest -&gt; instr_gadt
| List_size : instr_gadt
| Empty_set : forall {a : Set}, comparable_ty a -&gt; instr_gadt
| Set_iter : forall {a rest : Set}, 'descr (a * rest) rest -&gt; instr_gadt
| Set_mem : instr_gadt
| Set_update : instr_gadt
| Set_size : instr_gadt
| Empty_map : forall {a v : Set}, comparable_ty a -&gt; 'ty v -&gt; instr_gadt
| Map_map : forall {a r rest v : Set},
  'descr ((a * v) * rest) (r * rest) -&gt; instr_gadt
| Map_iter : forall {a rest v : Set}, 'descr ((a * v) * rest) rest -&gt; instr_gadt
| Map_mem : instr_gadt
| Map_get : instr_gadt
| Map_update : instr_gadt
| Map_size : instr_gadt
| Empty_big_map : forall {a v : Set}, comparable_ty a -&gt; 'ty v -&gt; instr_gadt
| Big_map_mem : instr_gadt
| Big_map_get : instr_gadt
| Big_map_update : instr_gadt
| Concat_string : instr_gadt
| Concat_string_pair : instr_gadt
| Slice_string : instr_gadt
| String_size : instr_gadt
| Concat_bytes : instr_gadt
| Concat_bytes_pair : instr_gadt
| Slice_bytes : instr_gadt
| Bytes_size : instr_gadt
| Add_seconds_to_timestamp : instr_gadt
| Add_timestamp_to_seconds : instr_gadt
| Sub_timestamp_seconds : instr_gadt
| Diff_timestamps : instr_gadt
| Add_tez : instr_gadt
| Sub_tez : instr_gadt
| Mul_teznat : instr_gadt
| Mul_nattez : instr_gadt
| Ediv_teznat : instr_gadt
| Ediv_tez : instr_gadt
| Or : instr_gadt
| And : instr_gadt
| Xor : instr_gadt
| Not : instr_gadt
| Is_nat : instr_gadt
| Neg_nat : instr_gadt
| Neg_int : instr_gadt
| Abs_int : instr_gadt
| Int_nat : instr_gadt
| Add_intint : instr_gadt
| Add_intnat : instr_gadt
| Add_natint : instr_gadt
| Add_natnat : instr_gadt
| Sub_int : instr_gadt
| Mul_intint : instr_gadt
| Mul_intnat : instr_gadt
| Mul_natint : instr_gadt
| Mul_natnat : instr_gadt
| Ediv_intint : instr_gadt
| Ediv_intnat : instr_gadt
| Ediv_natint : instr_gadt
| Ediv_natnat : instr_gadt
| Lsl_nat : instr_gadt
| Lsr_nat : instr_gadt
| Or_nat : instr_gadt
| And_nat : instr_gadt
| And_int_nat : instr_gadt
| Xor_nat : instr_gadt
| Not_nat : instr_gadt
| Not_int : instr_gadt
| Seq : forall {aft bef trans : Set},
  'descr bef trans -&gt; 'descr trans aft -&gt; instr_gadt
| If : forall {aft bef : Set}, 'descr bef aft -&gt; 'descr bef aft -&gt; instr_gadt
| Loop : forall {rest : Set}, 'descr rest (bool * rest) -&gt; instr_gadt
| Loop_left : forall {a b rest : Set},
  'descr (a * rest) (union a b * rest) -&gt; instr_gadt
| Dip : forall {aft bef : Set}, 'descr bef aft -&gt; instr_gadt
| Exec : instr_gadt
| Apply : forall {arg : Set}, 'ty arg -&gt; instr_gadt
| Lambda : forall {arg ret : Set}, 'lambda arg ret -&gt; instr_gadt
| Failwith : forall {a : Set}, 'ty a -&gt; instr_gadt
| Nop : instr_gadt
| Compare : forall {a : Set}, comparable_ty a -&gt; instr_gadt
| Eq : instr_gadt
| Neq : instr_gadt
| Lt : instr_gadt
| Gt : instr_gadt
| Le : instr_gadt
| Ge : instr_gadt
| Address : instr_gadt
| Contract : forall {p : Set}, 'ty p -&gt; string -&gt; instr_gadt
| Transfer_tokens : instr_gadt
| Create_account : instr_gadt
| Implicit_account : instr_gadt
| Create_contract : forall {g p : Set},
  'ty g -&gt; 'ty p -&gt; 'lambda (p * g) (list operation * g) -&gt; option string -&gt;
  instr_gadt
| Create_contract_2 : forall {g p : Set},
  'ty g -&gt; 'ty p -&gt; 'lambda (p * g) (list operation * g) -&gt; option string -&gt;
  instr_gadt
| Set_delegate : instr_gadt
| Now : instr_gadt
| Balance : instr_gadt
| Check_signature : instr_gadt
| Hash_key : instr_gadt
| Pack : forall {a : Set}, 'ty a -&gt; instr_gadt
| Unpack : forall {a : Set}, 'ty a -&gt; instr_gadt
| Blake2b : instr_gadt
| Sha256 : instr_gadt
| Sha512 : instr_gadt
| Steps_to_quota : instr_gadt
| Source : instr_gadt
| Sender : instr_gadt
| Self : forall {p : Set}, 'ty p -&gt; string -&gt; instr_gadt
| Amount : instr_gadt
| Dig : forall {aft bef rest x : Set},
  Z -&gt; 'stack_prefix_preservation_witness (x * rest) rest bef aft -&gt; instr_gadt
| Dug : forall {aft bef rest x : Set},
  Z -&gt; 'stack_prefix_preservation_witness rest (x * rest) bef aft -&gt; instr_gadt
| Dipn : forall {aft bef faft fbef : Set},
  Z -&gt; 'stack_prefix_preservation_witness fbef faft bef aft -&gt;
  'descr fbef faft -&gt; instr_gadt
| Dropn : forall {C bef rest : Set},
  Z -&gt; 'stack_prefix_preservation_witness rest rest bef C -&gt; instr_gadt
| ChainId : instr_gadt

with stack_prefix_preservation_witness_gadt : Set :=
| Prefix :
  stack_prefix_preservation_witness_gadt -&gt;
  stack_prefix_preservation_witness_gadt
| Rest : stack_prefix_preservation_witness_gadt

where &quot;'script&quot; := (fun (arg storage : Set) =&gt;
  script_skeleton ('lambda (pair arg storage) (pair (list operation) storage))
    ('ty arg) storage ('ty storage) (option string))
and &quot;'end_of_stack&quot; := (unit)
and &quot;'lambda&quot; := (fun (arg ret : Set) =&gt; lambda_gadt)
and &quot;'typed_contract&quot; := (fun (arg : Set) =&gt; 'ty arg * address)
and &quot;'ty&quot; := (fun (ty : Set) =&gt; ty_gadt)
and &quot;'stack_ty&quot; := (fun (ty : Set) =&gt; stack_ty_gadt)
and &quot;'big_map&quot; := (fun (key value : Set) =&gt;
  big_map_skeleton (option Z.t) (map key (option value)) ('ty key) ('ty value))
and &quot;'instr&quot; := (fun (bef aft : Set) =&gt; instr_gadt)
and &quot;'stack_prefix_preservation_witness&quot; := (fun
  (bef aft bef_suffix aft_suffix : Set) =&gt;
  stack_prefix_preservation_witness_gadt)
and &quot;'descr&quot; := (fun (bef aft : Set) =&gt;
  descr_skeleton Alpha_context.Script.location ('stack_ty bef) ('stack_ty aft)
    ('instr bef aft)).

Definition script := 'script.
Definition end_of_stack := 'end_of_stack.
Definition lambda := 'lambda.
Definition typed_contract := 'typed_contract.
Definition ty := 'ty.
Definition stack_ty := 'stack_ty.
Definition big_map := 'big_map.
Definition instr := 'instr.
Definition stack_prefix_preservation_witness :=
  'stack_prefix_preservation_witness.
Definition descr := 'descr.

Reserved Notation &quot;'ex_big_map&quot;.

Inductive ex_big_map_gadt : Set :=
| Ex_bm : forall {key value : Set}, big_map key value -&gt; ex_big_map_gadt

where &quot;'ex_big_map&quot; := (ex_big_map_gadt).

Definition ex_big_map := 'ex_big_map.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_repr.ml">
  <div class="col-md-6">
    <a href="#seed_repr.ml"><code>seed_repr.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Random number generation *)

type seed = B of State_hash.t

type t = T of State_hash.t

type sequence = S of State_hash.t

type nonce = MBytes.t

let nonce_encoding = Data_encoding.Fixed.bytes Constants_repr.nonce_length

let init = &quot;Laissez-faire les proprietaires.&quot;

let zero_bytes = MBytes.of_string (String.make Nonce_hash.size '\000')

let state_hash_encoding =
  let open Data_encoding in
  conv
    State_hash.to_bytes
    State_hash.of_bytes_exn
    (Fixed.bytes Nonce_hash.size)

let seed_encoding =
  let open Data_encoding in
  conv (fun (B b) -&gt; b) (fun b -&gt; B b) state_hash_encoding

let empty = B (State_hash.hash_bytes [MBytes.of_string init])

let nonce (B state) nonce =
  B (State_hash.hash_bytes [State_hash.to_bytes state; nonce])

let initialize_new (B state) append =
  T (State_hash.hash_bytes (State_hash.to_bytes state :: zero_bytes :: append))

let xor_higher_bits i b =
  let higher = MBytes.get_int32 b 0 in
  let r = Int32.logxor higher i in
  let res = MBytes.copy b in
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">MBytes.set_int32 res 0 r ; res</abbr>

let sequence (T state) n =
  State_hash.to_bytes state |&gt; xor_higher_bits n
  |&gt; fun b -&gt; S (State_hash.hash_bytes [b])

let take (S state) =
  let b = State_hash.to_bytes state in
  let h = State_hash.hash_bytes [b] in
  (State_hash.to_bytes h, S h)

let take_int32 s bound =
  if Compare.Int32.(bound &lt;= 0l) then invalid_arg &quot;Seed_repr.take_int32&quot;
    (* FIXME *)
  else
    let rec loop s =
      let (bytes, s) = take s in
      let r = Int32.abs (MBytes.get_int32 bytes 0) in
      let drop_if_over =
        Int32.sub Int32.max_int (Int32.rem Int32.max_int bound)
      in
      if Compare.Int32.(r &gt;= drop_if_over) then loop s
      else
        let v = Int32.rem r bound in
        (v, s)
    in
    loop s

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Unexpected_nonce_length</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;unexpected_nonce_length&quot;
    ~title:&quot;Unexpected nonce length&quot;
    ~description:&quot;Nonce length is incorrect.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;Nonce length is not %i bytes long as it should.&quot;
        Constants_repr.nonce_length)
    Data_encoding.empty
    (function Unexpected_nonce_length -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_nonce_length)</abbr>

let make_nonce nonce =
  if Compare.Int.(MBytes.length nonce &lt;&gt; Constants_repr.nonce_length) then
    error <abbr class="mark-error" title="Values of extensible types are not handled">Unexpected_nonce_length</abbr>
  else ok nonce

let hash nonce = Nonce_hash.hash_bytes [nonce]

let check_hash nonce hash =
  Compare.Int.(MBytes.length nonce = Constants_repr.nonce_length)
  &amp;&amp; Nonce_hash.equal (Nonce_hash.hash_bytes [nonce]) hash

let nonce_hash_key_part = Nonce_hash.to_path

let initial_nonce_0 = zero_bytes

let initial_nonce_hash_0 = hash initial_nonce_0

let deterministic_seed seed = nonce seed zero_bytes

let initial_seeds n =
  let rec loop acc elt i =
    if Compare.Int.(i = 1) then List.rev (elt :: acc)
    else loop (elt :: acc) (deterministic_seed elt) (i - 1)
  in
  loop [] (B (State_hash.hash_bytes [])) n
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_repr.ml"><code>Seed_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_repr.
Require Tezos.Nonce_hash.
Require Tezos.State_hash.

Inductive seed : Set :=
| B : State_hash.t -&gt; seed.

Inductive t : Set :=
| T : State_hash.t -&gt; t.

Inductive sequence : Set :=
| S : State_hash.t -&gt; sequence.

Definition nonce := MBytes.t.

Definition nonce_encoding : Data_encoding.encoding MBytes.t :=
  Data_encoding.Fixed.__bytes_value Constants_repr.nonce_length.

Definition init : string := &quot;Laissez-faire les proprietaires.&quot; % string.

Definition zero_bytes : MBytes.t :=
  MBytes.of_string (String.make Nonce_hash.size &quot;000&quot; % char).

Definition state_hash_encoding : Data_encoding.encoding State_hash.t :=
  Data_encoding.conv State_hash.to_bytes State_hash.of_bytes_exn None
    (Data_encoding.Fixed.__bytes_value Nonce_hash.size).

Definition seed_encoding : Data_encoding.encoding seed :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let 'B b := function_parameter in
      b) (fun b =&gt; B b) None state_hash_encoding.

Definition empty : seed :=
  B (State_hash.hash_bytes None (cons (MBytes.of_string init) [])).

Definition nonce (function_parameter : seed) : MBytes.t -&gt; seed :=
  let 'B state := function_parameter in
  fun nonce =&gt;
    B
      (State_hash.hash_bytes None
        (cons (State_hash.to_bytes state) (cons nonce []))).

Definition initialize_new (function_parameter : seed) : list MBytes.t -&gt; t :=
  let 'B state := function_parameter in
  fun append =&gt;
    T
      (State_hash.hash_bytes None
        (cons (State_hash.to_bytes state) (cons zero_bytes append))).

Definition xor_higher_bits (i : int32) (b : MBytes.t) : MBytes.t :=
  let higher := MBytes.get_int32 b 0 in
  let r := Int32.logxor higher i in
  let res := MBytes.copy b in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  res.

Definition sequence (function_parameter : t) : int32 -&gt; sequence :=
  let 'T state := function_parameter in
  fun n =&gt;
    Pervasives.op_pipegt
      (Pervasives.op_pipegt (State_hash.to_bytes state) (xor_higher_bits n))
      (fun b =&gt; S (State_hash.hash_bytes None (cons b []))).

Definition take (function_parameter : sequence) : MBytes.t * sequence :=
  let 'S state := function_parameter in
  let b := State_hash.to_bytes state in
  let h := State_hash.hash_bytes None (cons b []) in
  ((State_hash.to_bytes h), (S h)).

Definition take_int32 (s : sequence) (bound : Compare.Int32.[Compare.S.t])
  : int32 * sequence :=
  if
    Compare.Int32.[Compare.S.op_lteq] bound
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    Pervasives.invalid_arg &quot;Seed_repr.take_int32&quot; % string
  else
    let fix loop (s : sequence) {struct s} : int32 * sequence :=
      let '(__bytes_value, s) := take s in
      let r := Int32.abs (MBytes.get_int32 __bytes_value 0) in
      let drop_if_over :=
        Int32.sub Int32.max_int (Int32.rem Int32.max_int bound) in
      if Compare.Int32.[Compare.S.op_gteq] r drop_if_over then
        loop s
      else
        let v := Int32.rem r bound in
        (v, s) in
    loop s.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition make_nonce (nonce : MBytes.t) : Error_monad.tzresult MBytes.t :=
  if
    Compare.Int.[Compare.S.op_ltgt] (MBytes.length nonce)
      Constants_repr.nonce_length then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok nonce.

Definition __hash_value (nonce : MBytes.t) : Nonce_hash.t :=
  Nonce_hash.hash_bytes None (cons nonce []).

Definition check_hash (nonce : MBytes.t) (__hash_value : Nonce_hash.t) : bool :=
  Pervasives.op_andand
    (Compare.Int.[Compare.S.op_eq] (MBytes.length nonce)
      Constants_repr.nonce_length)
    (Nonce_hash.equal (Nonce_hash.hash_bytes None (cons nonce [])) __hash_value).

Definition nonce_hash_key_part : Nonce_hash.t -&gt; list string -&gt; list string :=
  Nonce_hash.to_path.

Definition initial_nonce_0 : MBytes.t := zero_bytes.

Definition initial_nonce_hash_0 : Nonce_hash.t := __hash_value initial_nonce_0.

Definition deterministic_seed (seed : seed) : seed := nonce seed zero_bytes.

Definition initial_seeds (n : Compare.Int.[Compare.S.t]) : list seed :=
  let fix loop (acc : list seed) (elt : seed) (i : Compare.Int.[Compare.S.t])
    {struct acc} : list seed :=
    if Compare.Int.[Compare.S.op_eq] i 1 then
      List.rev (cons elt acc)
    else
      loop (cons elt acc) (deterministic_seed elt) (Pervasives.op_minus i 1) in
  loop [] (B (State_hash.hash_bytes None [])) n.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_repr.mli">
  <div class="col-md-6">
    <a href="#seed_repr.mli"><code>seed_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Random number generation

    This is not expected to be a good cryptographic random number
    generator. In particular this is supposed to be used in situations
    where the seed is a globaly known information.

    The only expected property is: It should be difficult to find a
    seed such that the generated sequence is a given one. *)

(** {2 Random Generation} *)

(** The state of the random number generator *)
type t

(** A random seed, to derive random sequences from *)
type seed

(** A random sequence, to derive random values from *)
type sequence

(** [initialize_new state ident] returns a new generator *)
val initialize_new : seed -&gt; MBytes.t list -&gt; t

(** [sequence state n] prepares the n-th sequence of a state  *)
val sequence : t -&gt; int32 -&gt; sequence

(** Generates the next random value in the sequence *)
val take : sequence -&gt; MBytes.t * sequence

(** Generates the next random value as a bounded [int32] *)
val take_int32 : sequence -&gt; int32 -&gt; int32 * sequence

(** {2 Predefined seeds} *)

val empty : seed

(** Returns a new seed by hashing the one passed with a constant. *)
val deterministic_seed : seed -&gt; seed

(** [intial_seeds n] generates the first [n] seeds for which there are no nonces.
    The first seed is a constant value. The kth seed is the hash of seed (k-1)
    concatenated with a constant. *)
val initial_seeds : int -&gt; seed list

(** {2 Entropy} *)

(** A nonce for adding entropy to the generator *)
type nonce

(** Add entropy to the seed generator *)
val nonce : seed -&gt; nonce -&gt; seed

(** Use a byte sequence as a nonce *)
val make_nonce : MBytes.t -&gt; nonce tzresult

(** Compute the has of a nonce *)
val hash : nonce -&gt; Nonce_hash.t

(** [check_hash nonce hash] is true if the nonce correspond to the hash *)
val check_hash : nonce -&gt; Nonce_hash.t -&gt; bool

(** For using nonce hashes as keys in the hierarchical database *)
val nonce_hash_key_part : Nonce_hash.t -&gt; string list -&gt; string list

(** {2 Predefined nonce} *)

val initial_nonce_0 : nonce

val initial_nonce_hash_0 : Nonce_hash.t

(** {2 Serializers} *)

val nonce_encoding : nonce Data_encoding.t

val seed_encoding : seed Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_repr.mli"><code>Seed_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Nonce_hash.

Parameter t : Set.

Parameter seed : Set.

Parameter sequence : Set.

Parameter initialize_new : seed -&gt; list MBytes.t -&gt; t.

Parameter sequence : t -&gt; int32 -&gt; sequence.

Parameter take : sequence -&gt; MBytes.t * sequence.

Parameter take_int32 : sequence -&gt; int32 -&gt; int32 * sequence.

Parameter empty : seed.

Parameter deterministic_seed : seed -&gt; seed.

Parameter initial_seeds : Z -&gt; list seed.

Parameter nonce : Set.

Parameter nonce : seed -&gt; nonce -&gt; seed.

Parameter make_nonce : MBytes.t -&gt; Error_monad.tzresult nonce.

Parameter __hash_value : nonce -&gt; Nonce_hash.t.

Parameter check_hash : nonce -&gt; Nonce_hash.t -&gt; bool.

Parameter nonce_hash_key_part : Nonce_hash.t -&gt; list string -&gt; list string.

Parameter initial_nonce_0 : nonce.

Parameter initial_nonce_hash_0 : Nonce_hash.t.

Parameter nonce_encoding : Data_encoding.t nonce.

Parameter seed_encoding : Data_encoding.t seed.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_storage.ml">
  <div class="col-md-6">
    <a href="#seed_storage.ml"><code>seed_storage.ml</code></a>&nbsp;<span class="label label-danger">4 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Misc

<abbr class="mark-error" title="Structure item `typext` not handled.">type error +=
  | Unknown of {
      oldest : Cycle_repr.t;
      cycle : Cycle_repr.t;
      latest : Cycle_repr.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;seed.unknown_seed&quot;
    ~title:&quot;Unknown seed&quot;
    ~description:&quot;The requested seed is not available&quot;
    ~pp:(fun ppf (oldest, cycle, latest) -&gt;
      if Cycle_repr.(cycle &lt; oldest) then
        Format.fprintf
          ppf
          &quot;The seed for cycle %a has been cleared from the context  (oldest \
           known seed is for cycle %a)&quot;
          Cycle_repr.pp
          cycle
          Cycle_repr.pp
          oldest
      else
        Format.fprintf
          ppf
          &quot;The seed for cycle %a has not been computed yet  (latest known \
           seed is for cycle %a)&quot;
          Cycle_repr.pp
          cycle
          Cycle_repr.pp
          latest)
    Data_encoding.(
      obj3
        (req &quot;oldest&quot; Cycle_repr.encoding)
        (req &quot;requested&quot; Cycle_repr.encoding)
        (req &quot;latest&quot; Cycle_repr.encoding))
    (function
      | Unknown {oldest; cycle; latest} -&gt;
          Some (oldest, cycle, latest)
      | _ -&gt;
          None)
    (fun (oldest, cycle, latest) -&gt; Unknown {oldest; cycle; latest})</abbr>

let compute_for_cycle c ~revealed cycle =
  match Cycle_repr.pred cycle with
  | None -&gt;
      <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> (* should not happen *)
  | Some previous_cycle -&gt;
      let levels = Level_storage.levels_with_commitments_in_cycle c revealed in
      let combine (c, random_seed, unrevealed) level =
        Storage.Seed.Nonce.get c level
        &gt;&gt;=? function
        | Revealed nonce -&gt;
            Storage.Seed.Nonce.delete c level
            &gt;&gt;=? fun c -&gt;
            return (c, Seed_repr.nonce random_seed nonce, unrevealed)
        | Unrevealed u -&gt;
            Storage.Seed.Nonce.delete c level
            &gt;&gt;=? fun c -&gt; return (c, random_seed, u :: unrevealed)
      in
      Storage.Seed.For_cycle.get c previous_cycle
      &gt;&gt;=? fun prev_seed -&gt;
      let seed = Seed_repr.deterministic_seed prev_seed in
      fold_left_s combine (c, seed, []) levels
      &gt;&gt;=? fun (c, seed, unrevealed) -&gt;
      Storage.Seed.For_cycle.init c cycle seed
      &gt;&gt;=? fun c -&gt; return (c, unrevealed)

let for_cycle ctxt cycle =
  let preserved = Constants_storage.preserved_cycles ctxt in
  let current_level = Level_storage.current ctxt in
  let current_cycle = current_level.cycle in
  let latest =
    if Cycle_repr.(current_cycle = root) then
      Cycle_repr.add current_cycle (preserved + 1)
    else Cycle_repr.add current_cycle preserved
  in
  let oldest =
    match Cycle_repr.sub current_cycle preserved with
    | None -&gt;
        Cycle_repr.root
    | Some oldest -&gt;
        oldest
  in
  fail_unless
    Cycle_repr.(oldest &lt;= cycle &amp;&amp; cycle &lt;= latest)
    <abbr class="mark-error" title="Values of extensible types are not handled">(Unknown {oldest; cycle; latest})</abbr>
  &gt;&gt;=? fun () -&gt; Storage.Seed.For_cycle.get ctxt cycle

let clear_cycle c cycle = Storage.Seed.For_cycle.delete c cycle

let init ctxt =
  let preserved = Constants_storage.preserved_cycles ctxt in
  List.fold_left2
    (fun ctxt c seed -&gt;
      ctxt
      &gt;&gt;=? fun ctxt -&gt;
      let cycle = Cycle_repr.of_int32_exn (Int32.of_int c) in
      Storage.Seed.For_cycle.init ctxt cycle seed)
    (return ctxt)
    (0 --&gt; (preserved + 1))
    (Seed_repr.initial_seeds (preserved + 2))

let cycle_end ctxt last_cycle =
  let preserved = Constants_storage.preserved_cycles ctxt in
  ( match Cycle_repr.sub last_cycle preserved with
  | None -&gt;
      return ctxt
  | Some cleared_cycle -&gt;
      clear_cycle ctxt cleared_cycle )
  &gt;&gt;=? fun ctxt -&gt;
  match Cycle_repr.pred last_cycle with
  | None -&gt;
      return (ctxt, [])
  | Some revealed -&gt;
      (* cycle with revelations *)
      let inited_seed_cycle = Cycle_repr.add last_cycle (preserved + 1) in
      compute_for_cycle ctxt ~revealed inited_seed_cycle
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_storage.ml"><code>Seed_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_storage.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Storage.

Import Misc.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition compute_for_cycle
  (c : Raw_context.t) (revealed : Cycle_repr.t) (cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult (Raw_context.t * list Storage.Seed.unrevealed_nonce)) :=
  match Cycle_repr.pred cycle with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert false
  | Some previous_cycle =&gt;
    let levels := Level_storage.levels_with_commitments_in_cycle c revealed in
    let combine
      (function_parameter :
        Storage.Seed.Nonce.context * Seed_repr.seed *
          list Storage.Seed.unrevealed_nonce)
      : Level_repr.t -&gt;
      Lwt.t
        (Error_monad.tzresult
          (Raw_context.t * Seed_repr.seed * list Storage.Seed.unrevealed_nonce)) :=
      let '(c, random_seed, unrevealed) := function_parameter in
      fun level =&gt;
        Error_monad.op_gtgteqquestion (Storage.Seed.Nonce.get c level)
          (fun function_parameter =&gt;
            match function_parameter with
            | Storage.Seed.Revealed nonce =&gt;
              Error_monad.op_gtgteqquestion (Storage.Seed.Nonce.delete c level)
                (fun c =&gt;
                  Error_monad.__return
                    (c, (Seed_repr.nonce random_seed nonce), unrevealed))
            | Storage.Seed.Unrevealed u =&gt;
              Error_monad.op_gtgteqquestion (Storage.Seed.Nonce.delete c level)
                (fun c =&gt;
                  Error_monad.__return (c, random_seed, (cons u unrevealed)))
            end) in
    Error_monad.op_gtgteqquestion (Storage.Seed.For_cycle.get c previous_cycle)
      (fun prev_seed =&gt;
        let seed := Seed_repr.deterministic_seed prev_seed in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s combine (c, seed, []) levels)
          (fun function_parameter =&gt;
            let '(c, seed, unrevealed) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Storage.Seed.For_cycle.init c cycle seed)
              (fun c =&gt; Error_monad.__return (c, unrevealed))))
  end.

Definition for_cycle (ctxt : Raw_context.context) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Seed_repr.seed) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let current_level := Level_storage.current ctxt in
  let current_cycle := Level_repr.t.cycle current_level in
  let latest :=
    if Cycle_repr.op_eq current_cycle Cycle_repr.root then
      Cycle_repr.add current_cycle (Pervasives.op_plus preserved 1)
    else
      Cycle_repr.add current_cycle preserved in
  let oldest :=
    match Cycle_repr.sub current_cycle preserved with
    | None =&gt; Cycle_repr.root
    | Some oldest =&gt; oldest
    end in
  Error_monad.op_gtgteqquestion
    (Error_monad.fail_unless
      (Pervasives.op_andand (Cycle_repr.op_lteq oldest cycle)
        (Cycle_repr.op_lteq cycle latest)) extensible_type_value)
    (fun function_parameter =&gt;
      let 'tt := function_parameter in
      Storage.Seed.For_cycle.get ctxt cycle).

Definition clear_cycle (c : Raw_context.t) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Seed.For_cycle.delete c cycle.

Definition init (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  List.fold_left2
    (fun ctxt =&gt;
      fun c =&gt;
        fun seed =&gt;
          Error_monad.op_gtgteqquestion ctxt
            (fun ctxt =&gt;
              let cycle := Cycle_repr.of_int32_exn (Int32.of_int c) in
              Storage.Seed.For_cycle.init ctxt cycle seed))
    (Error_monad.__return ctxt)
    (Misc.op_minusminusgt 0 (Pervasives.op_plus preserved 1))
    (Seed_repr.initial_seeds (Pervasives.op_plus preserved 2)).

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult
      (Raw_context.context * list Storage.Seed.unrevealed_nonce)) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  Error_monad.op_gtgteqquestion
    match Cycle_repr.sub last_cycle preserved with
    | None =&gt; Error_monad.__return ctxt
    | Some cleared_cycle =&gt; clear_cycle ctxt cleared_cycle
    end
    (fun ctxt =&gt;
      match Cycle_repr.pred last_cycle with
      | None =&gt; Error_monad.__return (ctxt, [])
      | Some revealed =&gt;
        let inited_seed_cycle :=
          Cycle_repr.add last_cycle (Pervasives.op_plus preserved 1) in
        compute_for_cycle ctxt revealed inited_seed_cycle
      end).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_storage.mli">
  <div class="col-md-6">
    <a href="#seed_storage.mli"><code>seed_storage.mli</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Extensible types are not handled.">type error +=
  | Unknown of {
      oldest : Cycle_repr.t;
      cycle : Cycle_repr.t;
      latest : Cycle_repr.t;
    }</abbr>

(* `Permanent *)

(** Generates the first [preserved_cycles+2] seeds for which
    there are no nonces. *)
val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val for_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed tzresult Lwt.t

(** If it is the end of the cycle, computes and stores the seed of cycle at
    distance [preserved_cycle+2] in the future using the seed of the previous
    cycle and the revelations of the current one.  *)
val cycle_end :
  Raw_context.t -&gt;
  Cycle_repr.t -&gt;
  (Raw_context.t * Nonce_storage.unrevealed list) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_storage.mli"><code>Seed_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Cycle_repr.
Require Tezos.Nonce_storage.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.

(* extensible_type Tezos_protocol_environment_alpha__Environment.Error_monad.error *)

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter for_cycle :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult Seed_repr.seed).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * list Nonce_storage.unrevealed)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="services_registration.ml">
  <div class="col-md-6">
    <a href="#services_registration.ml"><code>services_registration.ml</code></a>&nbsp;<span class="label label-danger">10 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

type rpc_context = {
  block_hash : Block_hash.t;
  block_header : Block_header.shell_header;
  context : Alpha_context.t;
}

let rpc_init ({block_hash; block_header; context} : Updater.rpc_context) =
  let level = block_header.level in
  let timestamp = block_header.timestamp in
  let fitness = block_header.fitness in
  Alpha_context.prepare
    ~level
    ~predecessor_timestamp:timestamp
    ~timestamp
    ~fitness
    context
  &gt;&gt;=? fun context -&gt; return {block_hash; block_header; context}

let rpc_services =
  ref (RPC_directory.empty : Updater.rpc_context RPC_directory.t)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register0_fullctxt</abbr> s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun ctxt q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt q i)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">opt_register0_fullctxt</abbr> s f =
  rpc_services :=
    RPC_directory.opt_register !rpc_services s (fun ctxt q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt q i)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register0</abbr> s f = register0_fullctxt s (fun {context; _} -&gt; f context)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register0_noctxt</abbr> s f =
  rpc_services := RPC_directory.register !rpc_services s (fun _ q i -&gt; f q i)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register1_fullctxt</abbr> s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun (ctxt, arg) q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt arg q i)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register1</abbr> s f = register1_fullctxt s (fun {context; _} x -&gt; f context x)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register1_noctxt</abbr> s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun (_, arg) q i -&gt; f arg q i)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register2_fullctxt</abbr> s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun ((ctxt, arg1), arg2) q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt arg1 arg2 q i)

let <abbr class="mark-error" title="Polymorphic variant types are not handled">register2</abbr> s f =
  register2_fullctxt s (fun {context; _} a1 a2 q i -&gt; f context a1 a2 q i)

let get_rpc_services () =
  let p =
    RPC_directory.map
      (fun c -&gt;
        rpc_init c
        &gt;&gt;= function Error _ -&gt; <abbr class="mark-error" title="Assert instruction is not handled.">assert false</abbr> | Ok c -&gt; Lwt.return c.context)
      (Storage_description.build_directory Alpha_context.description)
  in
  RPC_directory.register_dynamic_directory
    !rpc_services
    RPC_path.(open_root / &quot;context&quot; / &quot;raw&quot; / &quot;json&quot;)
    (fun _ -&gt; Lwt.return p)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#services_registration.ml"><code>Services_registration.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Storage_description.

Import Alpha_context.

Module rpc_context.
  Record record := {
    block_hash : Block_hash.[S.HASH.t];
    block_header : Alpha_context.Block_header.shell_header;
    context : Alpha_context.t }.
End rpc_context.
Definition rpc_context := rpc_context.record.

Definition rpc_init (function_parameter : Updater.rpc_context)
  : Lwt.t (Error_monad.tzresult rpc_context) :=
  let '{|
    Updater.rpc_context.block_hash := block_hash;
      Updater.rpc_context.block_header := block_header;
      Updater.rpc_context.context := context
      |} := function_parameter in
  let level := Block_header.shell_header.level block_header in
  let timestamp := Block_header.shell_header.timestamp block_header in
  let fitness := Block_header.shell_header.fitness block_header in
  Error_monad.op_gtgteqquestion
    (Alpha_context.prepare context level timestamp timestamp fitness)
    (fun context =&gt;
      Error_monad.__return
        {| rpc_context.block_hash := block_hash;
          rpc_context.block_header := block_header;
          rpc_context.context := context |}).

Definition rpc_services
  : Pervasives.ref (RPC_directory.t Updater.rpc_context) :=
  Pervasives.__ref_value RPC_directory.empty.

Definition register0_fullctxt {A B C : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
      Updater.rpc_context A B C)
  (f : rpc_context -&gt; A -&gt; B -&gt; Lwt.t (Error_monad.tzresult C)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun ctxt =&gt;
        fun q =&gt;
          fun i =&gt;
            Error_monad.op_gtgteqquestion (rpc_init ctxt)
              (fun ctxt =&gt; f ctxt q i))).

Definition opt_register0_fullctxt {A B C : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
      Updater.rpc_context A B C)
  (f : rpc_context -&gt; A -&gt; B -&gt; Lwt.t (Error_monad.tzresult (option C)))
  : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.opt_register (Pervasives.op_exclamation rpc_services) s
      (fun ctxt =&gt;
        fun q =&gt;
          fun i =&gt;
            Error_monad.op_gtgteqquestion (rpc_init ctxt)
              (fun ctxt =&gt; f ctxt q i))).

Definition register0 {A B C : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
      Updater.rpc_context A B C)
  (f : Alpha_context.t -&gt; A -&gt; B -&gt; Lwt.t (Error_monad.tzresult C)) : unit :=
  register0_fullctxt s
    (fun function_parameter =&gt;
      let '{| rpc_context.context := context |} := function_parameter in
      f context).

Definition register0_noctxt {A B C D : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context A B C D)
  (f : B -&gt; C -&gt; Lwt.t (Error_monad.tzresult D)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun q =&gt; fun i =&gt; f q i)).

Definition register1_fullctxt {A B C D : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
      (Updater.rpc_context * A) B C D)
  (f : rpc_context -&gt; A -&gt; B -&gt; C -&gt; Lwt.t (Error_monad.tzresult D)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '(ctxt, arg) := function_parameter in
        fun q =&gt;
          fun i =&gt;
            Error_monad.op_gtgteqquestion (rpc_init ctxt)
              (fun ctxt =&gt; f ctxt arg q i))).

Definition register1 {A B C D : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
      (Updater.rpc_context * A) B C D)
  (f : Alpha_context.t -&gt; A -&gt; B -&gt; C -&gt; Lwt.t (Error_monad.tzresult D))
  : unit :=
  register1_fullctxt s
    (fun function_parameter =&gt;
      let '{| rpc_context.context := context |} := function_parameter in
      fun x =&gt; f context x).

Definition register1_noctxt {A B C D E : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context (A * B) C D E)
  (f : B -&gt; C -&gt; D -&gt; Lwt.t (Error_monad.tzresult E)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '(_, arg) := function_parameter in
        fun q =&gt; fun i =&gt; f arg q i)).

Definition register2_fullctxt {A B C D E : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
      ((Updater.rpc_context * A) * B) C D E)
  (f : rpc_context -&gt; A -&gt; B -&gt; C -&gt; D -&gt; Lwt.t (Error_monad.tzresult E))
  : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '((ctxt, arg1), arg2) := function_parameter in
        fun q =&gt;
          fun i =&gt;
            Error_monad.op_gtgteqquestion (rpc_init ctxt)
              (fun ctxt =&gt; f ctxt arg1 arg2 q i))).

Definition register2 {A B C D E : Set}
  (s :
    RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) Updater.rpc_context
      ((Updater.rpc_context * A) * B) C D E)
  (f : Alpha_context.t -&gt; A -&gt; B -&gt; C -&gt; D -&gt; Lwt.t (Error_monad.tzresult E))
  : unit :=
  register2_fullctxt s
    (fun function_parameter =&gt;
      let '{| rpc_context.context := context |} := function_parameter in
      fun a1 =&gt; fun a2 =&gt; fun q =&gt; fun i =&gt; f context a1 a2 q i).

Definition get_rpc_services (function_parameter : unit)
  : RPC_directory.directory Updater.rpc_context :=
  let 'tt := function_parameter in
  let p :=
    RPC_directory.map
      (fun c =&gt;
        Error_monad.op_gtgteq (rpc_init c)
          (fun function_parameter =&gt;
            match function_parameter with
            | Pervasives.Error _ =&gt;
              (* ‚ùå Assert instruction is not handled. *)
              assert false
            | Pervasives.Ok c =&gt; Lwt.__return (rpc_context.context c)
            end))
      (Storage_description.build_directory Alpha_context.description) in
  RPC_directory.register_dynamic_directory None
    (Pervasives.op_exclamation rpc_services)
    (RPC_path.op_div
      (RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot; % string)
        &quot;raw&quot; % string) &quot;json&quot; % string)
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      Lwt.__return p).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="state_hash.ml">
  <div class="col-md-6">
    <a href="#state_hash.ml"><code>state_hash.ml</code></a>&nbsp;<span class="label label-danger">1 error</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let random_state_hash = &quot;\076\064\204&quot; (* rng(53): never used... *)

module Blake2BModule = Blake2B.Make
          (Base58)
          (struct
            let name = &quot;random&quot;

            let title = &quot;A random generation state&quot;

            let b58check_prefix = random_state_hash

            let size = None
          end)

include Blake2BModule

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () = Base58.check_encoded_prefix b58check_encoding &quot;rng&quot; 53</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#state_hash.ml"><code>State_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition random_state_hash : string := &quot;L@\204&quot; % string.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT _ tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
        |}))
    (let name := &quot;random&quot; % string in
    let title := &quot;A random generation state&quot; % string in
    let b58check_prefix := random_state_hash in
    let size := None in
    existT _ tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
        |}).

Definition t := Blake2BModule.[S.HASH.t].

Definition name := Blake2BModule.[S.HASH.name].

Definition title := Blake2BModule.[S.HASH.title].

Definition pp := Blake2BModule.[S.HASH.pp].

Definition pp_short := Blake2BModule.[S.HASH.pp_short].

Definition op_eq := Blake2BModule.[S.HASH.op_eq].

Definition op_ltgt := Blake2BModule.[S.HASH.op_ltgt].

Definition op_lt := Blake2BModule.[S.HASH.op_lt].

Definition op_lteq := Blake2BModule.[S.HASH.op_lteq].

Definition op_gteq := Blake2BModule.[S.HASH.op_gteq].

Definition op_gt := Blake2BModule.[S.HASH.op_gt].

Definition compare := Blake2BModule.[S.HASH.compare].

Definition equal := Blake2BModule.[S.HASH.equal].

Definition max := Blake2BModule.[S.HASH.max].

Definition min := Blake2BModule.[S.HASH.min].

Definition hash_bytes := Blake2BModule.[S.HASH.hash_bytes].

Definition hash_string := Blake2BModule.[S.HASH.hash_string].

Definition zero := Blake2BModule.[S.HASH.zero].

Definition size := Blake2BModule.[S.HASH.size].

Definition to_bytes := Blake2BModule.[S.HASH.to_bytes].

Definition of_bytes_opt := Blake2BModule.[S.HASH.of_bytes_opt].

Definition of_bytes_exn := Blake2BModule.[S.HASH.of_bytes_exn].

Definition to_b58check := Blake2BModule.[S.HASH.to_b58check].

Definition to_short_b58check := Blake2BModule.[S.HASH.to_short_b58check].

Definition of_b58check_exn := Blake2BModule.[S.HASH.of_b58check_exn].

Definition of_b58check_opt := Blake2BModule.[S.HASH.of_b58check_opt].

Definition b58check_encoding := Blake2BModule.[S.HASH.b58check_encoding].

Definition encoding := Blake2BModule.[S.HASH.encoding].

Definition rpc_arg := Blake2BModule.[S.HASH.rpc_arg].

Definition to_path := Blake2BModule.[S.HASH.to_path].

Definition of_path := Blake2BModule.[S.HASH.of_path].

Definition of_path_exn := Blake2BModule.[S.HASH.of_path_exn].

Definition prefix_path := Blake2BModule.[S.HASH.prefix_path].

Definition path_length := Blake2BModule.[S.HASH.path_length].

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage.ml">
  <div class="col-md-6">
    <a href="#storage.ml"><code>storage.ml</code></a>&nbsp;<span class="label label-danger">98 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Storage_functors

module Int = struct
  type t = int

  let encoding = Data_encoding.uint16
end

module Int32 = struct
  type t = Int32.t

  let encoding = Data_encoding.int32
end

module Z = struct
  include Z

  let encoding = Data_encoding.z
end

module Int_index = struct
  type t = int

  let path_length = 1

  let to_path c l = string_of_int c :: l

  let of_path = function
    | [] | _ :: _ :: _ -&gt;
        None
    | [c] -&gt;
        int_of_string_opt c

  type 'a ipath = 'a * t

  let args =
    Storage_description.One
      {
        rpc_arg = RPC_arg.int;
        encoding = Data_encoding.int31;
        compare = Compare.Int.compare;
      }
end

<abbr class="mark-error" title="Functors are not handled.">module Make_index (H : Storage_description.INDEX) :
  INDEX with type t = H.t and type 'a ipath = 'a * H.t = struct
  include H

  type 'a ipath = 'a * t

  let args = Storage_description.One {rpc_arg; encoding; compare}
end</abbr>

module Block_priority =
  Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
    (struct
      let name = [&quot;block_priority&quot;]
    end)
    (Int)

(** Contracts handling *)

module Contract = struct
  module Raw_context =
    Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;contracts&quot;]
      end)

  module Global_counter =
    Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;global_counter&quot;]
      end)
      (Z)

  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;index&quot;]
         end))
         (Make_index (Contract_repr.Index))

  let fold = Indexed_context.fold_keys

  let list = Indexed_context.keys

  module Balance =
    Indexed_context.Make_map
      (struct
        let name = [&quot;balance&quot;]
      end)
      (Tez_repr)

  module Frozen_balance_index =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Indexed_context.Raw_context</abbr>)
         (struct
           let name = [&quot;frozen_balance&quot;]
         end))
         (Make_index (Cycle_repr.Index))

  module Frozen_deposits =
    Frozen_balance_index.Make_map
      (struct
        let name = [&quot;deposits&quot;]
      end)
      (Tez_repr)

  module Frozen_fees =
    Frozen_balance_index.Make_map
      (struct
        let name = [&quot;fees&quot;]
      end)
      (Tez_repr)

  module Frozen_rewards =
    Frozen_balance_index.Make_map
      (struct
        let name = [&quot;rewards&quot;]
      end)
      (Tez_repr)

  module Manager =
    Indexed_context.Make_map
      (struct
        let name = [&quot;manager&quot;]
      end)
      (Manager_repr)

  module Delegate =
    Indexed_context.Make_map
      (struct
        let name = [&quot;delegate&quot;]
      end)
      (Signature.Public_key_hash)

  module Inactive_delegate =
    Indexed_context.Make_set
      (Registered)
      (struct
        let name = [&quot;inactive_delegate&quot;]
      end)

  module Delegate_desactivation =
    Indexed_context.Make_map
      (struct
        let name = [&quot;delegate_desactivation&quot;]
      end)
      (Cycle_repr)

  module Delegated =
    Make_data_set_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Indexed_context.Raw_context</abbr>)
         (struct
           let name = [&quot;delegated&quot;]
         end))
         (Make_index (Contract_repr.Index))

  module Counter =
    Indexed_context.Make_map
      (struct
        let name = [&quot;counter&quot;]
      end)
      (Z)

  (* Consume gas for serilization and deserialization of expr in this
     module *)
  <abbr class="mark-error" title="Functors are not handled.">module Make_carbonated_map_expr (N : Storage_sigs.NAME) = struct
    module I =
      Indexed_context.Make_carbonated_map
        (N)
        (struct
          type t = Script_repr.lazy_expr

          let encoding = Script_repr.lazy_expr_encoding
        end)

    type context = I.context

    type key = I.key

    type value = I.value

    let mem = I.mem

    let delete = I.delete

    let remove = I.remove

    let consume_deserialize_gas ctxt value =
      Lwt.return
      @@ ( Raw_context.check_enough_gas
             ctxt
             (Script_repr.minimal_deserialize_cost value)
         &gt;&gt;? fun () -&gt;
         Script_repr.force_decode value
         &gt;&gt;? fun (_value, value_cost) -&gt;
         Raw_context.consume_gas ctxt value_cost )

    let consume_serialize_gas ctxt value =
      Lwt.return
      @@ ( Script_repr.force_bytes value
         &gt;&gt;? fun (_value, value_cost) -&gt;
         Raw_context.consume_gas ctxt value_cost )

    let get ctxt contract =
      I.get ctxt contract
      &gt;&gt;=? fun (ctxt, value) -&gt;
      consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value)

    let get_option ctxt contract =
      I.get_option ctxt contract
      &gt;&gt;=? fun (ctxt, value_opt) -&gt;
      match value_opt with
      | None -&gt;
          return (ctxt, None)
      | Some value -&gt;
          consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value_opt)

    let set ctxt contract value =
      consume_serialize_gas ctxt value
      &gt;&gt;=? fun ctxt -&gt; I.set ctxt contract value

    let set_option ctxt contract value_opt =
      match value_opt with
      | None -&gt;
          I.set_option ctxt contract None
      | Some value -&gt;
          consume_serialize_gas ctxt value
          &gt;&gt;=? fun ctxt -&gt; I.set_option ctxt contract value_opt

    let init ctxt contract value =
      consume_serialize_gas ctxt value
      &gt;&gt;=? fun ctxt -&gt; I.init ctxt contract value

    let init_set ctxt contract value =
      consume_serialize_gas ctxt value
      &gt;&gt;=? fun ctxt -&gt; I.init_set ctxt contract value
  end</abbr>

  module Code = Make_carbonated_map_expr (struct
    let name = [&quot;code&quot;]
  end)

  module Storage = Make_carbonated_map_expr (struct
    let name = [&quot;storage&quot;]
  end)

  module Paid_storage_space =
    Indexed_context.Make_map
      (struct
        let name = [&quot;paid_bytes&quot;]
      end)
      (Z)

  module Used_storage_space =
    Indexed_context.Make_map
      (struct
        let name = [&quot;used_bytes&quot;]
      end)
      (Z)

  module Roll_list =
    Indexed_context.Make_map
      (struct
        let name = [&quot;roll_list&quot;]
      end)
      (Roll_repr)

  module Change =
    Indexed_context.Make_map
      (struct
        let name = [&quot;change&quot;]
      end)
      (Tez_repr)
end

(** Big maps handling *)

module Big_map = struct
  module Raw_context =
    Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;big_maps&quot;]
      end)

  module Next = struct
    module Single_data_storage = Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
              (struct
                let name = [&quot;next&quot;]
              end)
              (Z)

    <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; init; set; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">include Single_data_storage</abbr>

    let incr ctxt =
      get ctxt
      &gt;&gt;=? fun i -&gt; set ctxt (Z.succ i) &gt;&gt;=? fun ctxt -&gt; return (ctxt, i)

    let init ctxt = init ctxt Z.zero
  end

  module Index = struct
    type t = Z.t

    let rpc_arg =
      let construct = Z.to_string in
      let destruct hash =
        match Z.of_string hash with
        | exception <abbr class="mark-error" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">_</abbr> -&gt;
            Error &quot;Cannot parse big map id&quot;
        | id -&gt;
            Ok id
      in
      RPC_arg.make
        ~descr:&quot;A big map identifier&quot;
        ~name:&quot;big_map_id&quot;
        ~construct
        ~destruct
        ()

    let encoding =
      Data_encoding.def
        &quot;big_map_id&quot;
        ~title:&quot;Big map identifier&quot;
        ~description:&quot;A big map identifier&quot;
        Z.encoding

    let compare = Compare.Z.compare

    let path_length = 7

    let to_path c l =
      let raw_key = Data_encoding.Binary.to_bytes_exn encoding c in
      let <abbr class="mark-error" title="Patterns on variants are not supported

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">(`Hex index_key)</abbr> = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      String.sub index_key 0 2 :: String.sub index_key 2 2
      :: String.sub index_key 4 2 :: String.sub index_key 6 2
      :: String.sub index_key 8 2 :: String.sub index_key 10 2 :: Z.to_string c
      :: l

    let of_path = function
      | []
      | [_]
      | [_; _]
      | [_; _; _]
      | [_; _; _; _]
      | [_; _; _; _; _]
      | [_; _; _; _; _; _]
      | _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ -&gt;
          None
      | [index1; index2; index3; index4; index5; index6; key] -&gt;
          let c = Z.of_string key in
          let raw_key = Data_encoding.Binary.to_bytes_exn encoding c in
          let <abbr class="mark-error" title="Patterns on variants are not supported

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Patterns on variants are not supported">(`Hex index_key)</abbr> = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
          <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 0 2 = index1)) ;
          </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 2 2 = index2)) ;
          </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 4 2 = index3)) ;
          </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 6 2 = index4)) ;
          </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 8 2 = index5)) ;
          </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 10 2 = index6)) ;
          Some c</abbr>
  end

  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;index&quot;]
         end))
         (Make_index (Index))

  let rpc_arg = Index.rpc_arg

  let fold = Indexed_context.fold_keys

  let list = Indexed_context.keys

  let remove_rec ctxt n = Indexed_context.remove_rec ctxt n

  let copy ctxt ~from ~to_ = Indexed_context.copy ctxt ~from ~to_

  type key = Raw_context.t * Z.t

  module Total_bytes =
    Indexed_context.Make_map
      (struct
        let name = [&quot;total_bytes&quot;]
      end)
      (Z)

  module Key_type =
    Indexed_context.Make_map
      (struct
        let name = [&quot;key_type&quot;]
      end)
      (struct
        type t = Script_repr.expr

        let encoding = Script_repr.expr_encoding
      end)

  module Value_type =
    Indexed_context.Make_map
      (struct
        let name = [&quot;value_type&quot;]
      end)
      (struct
        type t = Script_repr.expr

        let encoding = Script_repr.expr_encoding
      end)

  module Contents = struct
    module I =
      Storage_functors.Make_indexed_carbonated_data_storage
        (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Indexed_context.Raw_context</abbr>)
           (struct
             let name = [&quot;contents&quot;]
           end))
           (Make_index (Script_expr_hash))
           (struct
             type t = Script_repr.expr

             let encoding = Script_repr.expr_encoding
           end)

    <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type context = I.context</abbr>

    <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type key = I.key</abbr>

    <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type value = I.value</abbr>

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">mem</abbr> = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.mem</abbr>

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">delete</abbr> = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.delete</abbr>

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">remove</abbr> = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.remove</abbr>

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">set</abbr> = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.set</abbr>

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">set_option</abbr> = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.set_option</abbr>

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">init</abbr> = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.init</abbr>

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">init_set</abbr> = <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.init_set</abbr>

    let consume_deserialize_gas ctxt value =
      Lwt.return
      @@ Raw_context.consume_gas ctxt (Script_repr.deserialized_cost value)

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">get</abbr> ctxt contract =
      <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.get</abbr> ctxt contract
      &gt;&gt;=? fun (ctxt, value) -&gt;
      consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value)

    let <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">get_option</abbr> ctxt contract =
      <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">I.get_option</abbr> ctxt contract
      &gt;&gt;=? fun (ctxt, value_opt) -&gt;
      match value_opt with
      | None -&gt;
          return (ctxt, None)
      | Some value -&gt;
          consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value_opt)
  end
end

module Delegates =
  Make_data_set_storage
    (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
       (struct
         let name = [&quot;delegates&quot;]
       end))
       (Make_index (Signature.Public_key_hash))

module Active_delegates_with_rolls =
  Make_data_set_storage
    (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
       (struct
         let name = [&quot;active_delegates_with_rolls&quot;]
       end))
       (Make_index (Signature.Public_key_hash))

module Delegates_with_frozen_balance_index =
  Make_indexed_subcontext
    (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
       (struct
         let name = [&quot;delegates_with_frozen_balance&quot;]
       end))
       (Make_index (Cycle_repr.Index))

module Delegates_with_frozen_balance =
  Make_data_set_storage
    (<abbr class="mark-error" title="Polymorphic variant types are not handled">Delegates_with_frozen_balance_index.Raw_context</abbr>)
    (Make_index (Signature.Public_key_hash))

(** Rolls *)

module Cycle = struct
  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;cycle&quot;]
         end))
         (Make_index (Cycle_repr.Index))

  module Last_roll =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Indexed_context.Raw_context</abbr>)
         (struct
           let name = [&quot;last_roll&quot;]
         end))
         (<abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_functors.INDEX, Tezos_raw_protocol_alpha__Storage_functors.INDEX

We were looking for a module signature name for the following shape:
[ path_length; to_path; of_path; args ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_functors.INDEX, Tezos_raw_protocol_alpha__Storage_functors.INDEX

We were looking for a module signature name for the following shape:
[ path_length; to_path; of_path; args ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Int_index</abbr>)
      (Roll_repr)

  module Roll_snapshot =
    Indexed_context.Make_map
      (struct
        let name = [&quot;roll_snapshot&quot;]
      end)
      (Int)

  type unrevealed_nonce = {
    nonce_hash : Nonce_hash.t;
    delegate : Signature.Public_key_hash.t;
    rewards : Tez_repr.t;
    fees : Tez_repr.t;
  }

  type nonce_status =
    | Unrevealed of unrevealed_nonce
    | Revealed of Seed_repr.nonce

  let nonce_status_encoding =
    let open Data_encoding in
    union
      [ case
          (Tag 0)
          ~title:&quot;Unrevealed&quot;
          (tup4
             Nonce_hash.encoding
             Signature.Public_key_hash.encoding
             Tez_repr.encoding
             Tez_repr.encoding)
          (function
            | Unrevealed {nonce_hash; delegate; rewards; fees} -&gt;
                Some (nonce_hash, delegate, rewards, fees)
            | _ -&gt;
                None)
          (fun (nonce_hash, delegate, rewards, fees) -&gt;
            Unrevealed {nonce_hash; delegate; rewards; fees});
        case
          (Tag 1)
          ~title:&quot;Revealed&quot;
          Seed_repr.nonce_encoding
          (function Revealed nonce -&gt; Some nonce | _ -&gt; None)
          (fun nonce -&gt; Revealed nonce) ]

  module Nonce =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Indexed_context.Raw_context</abbr>)
         (struct
           let name = [&quot;nonces&quot;]
         end))
         (Make_index (Raw_level_repr.Index))
         (struct
           type t = nonce_status

           let encoding = nonce_status_encoding
         end)

  module Seed =
    Indexed_context.Make_map
      (struct
        let name = [&quot;random_seed&quot;]
      end)
      (struct
        type t = Seed_repr.seed

        let encoding = Seed_repr.seed_encoding
      end)
end

module Roll = struct
  module Raw_context =
    Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;rolls&quot;]
      end)

  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;index&quot;]
         end))
         (Make_index (Roll_repr.Index))

  module Next =
    Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;next&quot;]
      end)
      (Roll_repr)

  module Limbo =
    Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;limbo&quot;]
      end)
      (Roll_repr)

  module Delegate_roll_list =
    Wrap_indexed_data_storage
      (Contract.Roll_list)
      (<abbr class="mark-error" title="The signature name of this module could not be found

Reason:
Did not find a module signature name for the following shape:
[ wrap; unwrap ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
        type t = Signature.Public_key_hash.t

        let wrap = Contract_repr.implicit_contract

        let unwrap = Contract_repr.is_implicit
      end</abbr>)

  module Successor =
    Indexed_context.Make_map
      (struct
        let name = [&quot;successor&quot;]
      end)
      (Roll_repr)

  module Delegate_change =
    Wrap_indexed_data_storage
      (Contract.Change)
      (<abbr class="mark-error" title="The signature name of this module could not be found

Reason:
Did not find a module signature name for the following shape:
[ wrap; unwrap ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">struct
        type t = Signature.Public_key_hash.t

        let wrap = Contract_repr.implicit_contract

        let unwrap = Contract_repr.is_implicit
      end</abbr>)

  module Snapshoted_owner_index = struct
    type t = Cycle_repr.t * int

    let path_length = Cycle_repr.Index.path_length + 1

    let to_path (c, n) s = Cycle_repr.Index.to_path c (string_of_int n :: s)

    let of_path l =
      match Misc.take Cycle_repr.Index.path_length l with
      | None | Some (_, ([] | _ :: _ :: _)) -&gt;
          None
      | Some (l1, [l2]) -&gt; (
        match (Cycle_repr.Index.of_path l1, int_of_string_opt l2) with
        | (None, _) | (_, None) -&gt;
            None
        | (Some c, Some i) -&gt;
            Some (c, i) )

    type 'a ipath = ('a * Cycle_repr.t) * int

    let left_args =
      Storage_description.One
        {
          rpc_arg = Cycle_repr.rpc_arg;
          encoding = Cycle_repr.encoding;
          compare = Cycle_repr.compare;
        }

    let right_args =
      Storage_description.One
        {
          rpc_arg = RPC_arg.int;
          encoding = Data_encoding.int31;
          compare = Compare.Int.compare;
        }

    let args = Storage_description.(Pair (left_args, right_args))
  end

  module Owner =
    Make_indexed_data_snapshotable_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;owner&quot;]
         end))
         (<abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_functors.INDEX, Tezos_raw_protocol_alpha__Storage_functors.INDEX

We were looking for a module signature name for the following shape:
[ path_length; to_path; of_path; args ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">Snapshoted_owner_index</abbr>)
      (Make_index (Roll_repr.Index))
      (Signature.Public_key)

  module Snapshot_for_cycle = Cycle.Roll_snapshot
  module Last_for_snapshot = Cycle.Last_roll

  let clear = Indexed_context.clear
end

(** Votes *)

module Vote = struct
  module Raw_context =
    Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;votes&quot;]
      end)

  module Current_period_kind =
    Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;current_period_kind&quot;]
      end)
      (struct
        type t = Voting_period_repr.kind

        let encoding = Voting_period_repr.kind_encoding
      end)

  module Participation_ema =
    Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;participation_ema&quot;]
      end)
      (Int32)

  module Current_proposal =
    Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;current_proposal&quot;]
      end)
      (Protocol_hash)

  module Listings_size =
    Make_single_data_storage (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
      (struct
        let name = [&quot;listings_size&quot;]
      end)
      (Int32)

  module Listings =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;listings&quot;]
         end))
         (Make_index (Signature.Public_key_hash))
         (Int32)

  module Proposals =
    Make_data_set_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;proposals&quot;]
         end))
         (Pair
            (Make_index
               (Protocol_hash))
               (Make_index (Signature.Public_key_hash)))

  module Proposals_count =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;proposals_count&quot;]
         end))
         (Make_index (Signature.Public_key_hash))
         (Int)

  module Ballots =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;ballots&quot;]
         end))
         (Make_index (Signature.Public_key_hash))
         (struct
           type t = Vote_repr.ballot

           let encoding = Vote_repr.ballot_encoding
         end)
end

(** Seed *)

module Seed = struct
  type unrevealed_nonce = Cycle.unrevealed_nonce = {
    nonce_hash : Nonce_hash.t;
    delegate : Signature.Public_key_hash.t;
    rewards : Tez_repr.t;
    fees : Tez_repr.t;
  }

  type nonce_status = Cycle.nonce_status =
    | Unrevealed of unrevealed_nonce
    | Revealed of Seed_repr.nonce

  <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">module Nonce = struct
    </abbr><abbr class="mark-error" title="Open not handled in module with a named signature

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">open Level_repr</abbr><abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha__Storage_sigs.Single_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Single_carbonated_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Non_iterable_indexed_carbonated_data_storage

We were looking for a module signature name for the following shape:
[ mem; get; get_option; set; init; init_set; set_option; delete; remove ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">

    type context = Raw_context.t

    let mem ctxt l = Cycle.Nonce.mem (ctxt, l.cycle) l.level

    let get ctxt l = Cycle.Nonce.get (ctxt, l.cycle) l.level

    let get_option ctxt l = Cycle.Nonce.get_option (ctxt, l.cycle) l.level

    let set ctxt l v = Cycle.Nonce.set (ctxt, l.cycle) l.level v

    let init ctxt l v = Cycle.Nonce.init (ctxt, l.cycle) l.level v

    let init_set ctxt l v = Cycle.Nonce.init_set (ctxt, l.cycle) l.level v

    let set_option ctxt l v = Cycle.Nonce.set_option (ctxt, l.cycle) l.level v

    let delete ctxt l = Cycle.Nonce.delete (ctxt, l.cycle) l.level

    let remove ctxt l = Cycle.Nonce.remove (ctxt, l.cycle) l.level
  end</abbr>

  module For_cycle = Cycle.Seed
end

(** Commitments *)

module Commitments =
  Make_indexed_data_storage
    (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
       (struct
         let name = [&quot;commitments&quot;]
       end))
       (Make_index (Blinded_public_key_hash.Index))
       (Tez_repr)

(** Ramp up security deposits... *)

module Ramp_up = struct
  module Rewards =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;ramp_up&quot;; &quot;rewards&quot;]
         end))
         (Make_index (Cycle_repr.Index))
         (struct
           type t = Tez_repr.t * Tez_repr.t

           let encoding =
             Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding
         end)

  module Security_deposits =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (<abbr class="mark-error" title="Polymorphic variant types are not handled">Raw_context</abbr>)
         (struct
           let name = [&quot;ramp_up&quot;; &quot;deposits&quot;]
         end))
         (Make_index (Cycle_repr.Index))
         (struct
           type t = Tez_repr.t * Tez_repr.t

           let encoding =
             Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding
         end)
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage.ml"><code>Storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Misc.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.
Require Tezos.Roll_repr.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Storage_description.
Require Tezos.Storage_functors.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Import Storage_functors.

Module Int.
  Definition t := Z.
  
  Definition encoding : Data_encoding.encoding Z := Data_encoding.uint16.
End Int.

Module Int32.
  Definition t := Int32.t.
  
  Definition encoding : Data_encoding.encoding int32 :=
    Data_encoding.__int32_value.
End Int32.

Module Z.
  Export Z.
  
  Definition encoding : Data_encoding.encoding Z.t := Data_encoding.z.
End Z.

Definition Int_index :=
  let path_length := 1 in
  let to_path (c : Z) (l : list string) : list string :=
    cons (Pervasives.string_of_int c) l in
  let of_path (function_parameter : list string) : option Z :=
    match function_parameter with
    | [] | cons _ (cons _ _) =&gt; None
    | cons c [] =&gt; Pervasives.int_of_string_opt c
    end in
  let args :=
    Storage_description.One
      {| Storage_description.args.One.rpc_arg := RPC_arg.int;
        Storage_description.args.One.encoding := Data_encoding.int31;
        Storage_description.args.One.compare := Compare.Int.[Compare.S.compare]
        |} in
  existT _ tt
    {|
      Storage_functors.INDEX.path_length := path_length;
      Storage_functors.INDEX.to_path := to_path;
      Storage_functors.INDEX.of_path := of_path;
      Storage_functors.INDEX.args {_} := args
      |}.

(* ‚ùå Functors are not handled. *)
(* functor *)

Definition Block_priority :=
  (((Storage_functors.Make_single_data_storage
    (existT _ tt
      {|
        Storage_sigs.REGISTER.ghost :=
          Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
        |}))
    (existT _ _
      {|
        Raw_context.T.mem := Raw_context.mem;
        Raw_context.T.dir_mem := Raw_context.dir_mem;
        Raw_context.T.get := Raw_context.get;
        Raw_context.T.get_option := Raw_context.get_option;
        Raw_context.T.init := Raw_context.init;
        Raw_context.T.set := Raw_context.set;
        Raw_context.T.init_set := Raw_context.init_set;
        Raw_context.T.set_option := Raw_context.set_option;
        Raw_context.T.delete := Raw_context.delete;
        Raw_context.T.remove := Raw_context.remove;
        Raw_context.T.remove_rec := Raw_context.remove_rec;
        Raw_context.T.copy := Raw_context.copy;
        Raw_context.T.fold {_} := Raw_context.fold;
        Raw_context.T.keys := Raw_context.keys;
        Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
        Raw_context.T.project := Raw_context.project;
        Raw_context.T.absolute_key := Raw_context.absolute_key;
        Raw_context.T.consume_gas := Raw_context.consume_gas;
        Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
        Raw_context.T.description := Raw_context.description
        |}))
    (let name := cons &quot;block_priority&quot; % string [] in
    existT _ tt
      {|
        Storage_sigs.NAME.name := name
        |}))
    (existT _ _
      {|
        Storage_sigs.VALUE.encoding := Int.[Storage_sigs.VALUE.encoding]
        |}).

Module Contract.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;contracts&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}).
  
  Definition Global_counter :=
    (((Storage_functors.Make_single_data_storage
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
          Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
          Raw_context.T.get := Raw_context.[Raw_context.T.get];
          Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
          Raw_context.T.init := Raw_context.[Raw_context.T.init];
          Raw_context.T.set := Raw_context.[Raw_context.T.set];
          Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
          Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
          Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
          Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
          Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
          Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
          Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
          Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
          Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
          Raw_context.T.project := Raw_context.[Raw_context.T.project];
          Raw_context.T.absolute_key := Raw_context.[Raw_context.T.absolute_key];
          Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
          Raw_context.T.check_enough_gas :=
            Raw_context.[Raw_context.T.check_enough_gas];
          Raw_context.T.description := Raw_context.[Raw_context.T.description]
          |}))
      (let name := cons &quot;global_counter&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Z.encoding
          |}).
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;index&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Contract_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Contract_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Contract_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Contract_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Contract_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Contract_repr.Index.[Storage_description.INDEX.compare]
            |})).
  
  Definition fold {A : Set}
    : Indexed_context.[Storage_sigs.Indexed_raw_context.context] -&gt; A -&gt;
    (Indexed_context.[Storage_sigs.Indexed_raw_context.key] -&gt; A -&gt; Lwt.t A) -&gt;
    Lwt.t A := Indexed_context.[Storage_sigs.Indexed_raw_context.fold_keys].
  
  Definition __list_value
    : Indexed_context.[Storage_sigs.Indexed_raw_context.context] -&gt;
    Lwt.t (list Indexed_context.[Storage_sigs.Indexed_raw_context.key]) :=
    Indexed_context.[Storage_sigs.Indexed_raw_context.keys].
  
  Definition Balance :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;balance&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
          |}).
  
  Definition Frozen_balance_index :=
    (Storage_functors.Make_indexed_subcontext
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Indexed_context.Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem :=
              Indexed_context.Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Indexed_context.Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option :=
              Indexed_context.Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init :=
              Indexed_context.Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Indexed_context.Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set :=
              Indexed_context.Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option :=
              Indexed_context.Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete :=
              Indexed_context.Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove :=
              Indexed_context.Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec :=
              Indexed_context.Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy :=
              Indexed_context.Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys :=
              Indexed_context.Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project :=
              Indexed_context.Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Indexed_context.Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas :=
              Indexed_context.Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Indexed_context.Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description :=
              Indexed_context.Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;frozen_balance&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Cycle_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Cycle_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Cycle_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Cycle_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Cycle_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Cycle_repr.Index.[Storage_description.INDEX.compare]
            |})).
  
  Definition Frozen_deposits :=
    (Frozen_balance_index.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;deposits&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
          |}).
  
  Definition Frozen_fees :=
    (Frozen_balance_index.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;fees&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
          |}).
  
  Definition Frozen_rewards :=
    (Frozen_balance_index.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;rewards&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
          |}).
  
  Definition Manager :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;manager&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding :=
            Manager_repr.[Storage_sigs.VALUE.encoding]
          |}).
  
  Definition Delegate :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;delegate&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding :=
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
          |}).
  
  Definition Inactive_delegate :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_set]
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (let name := cons &quot;inactive_delegate&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}).
  
  Definition Delegate_desactivation :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;delegate_desactivation&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Cycle_repr.encoding
          |}).
  
  Definition Delegated :=
    (Storage_functors.Make_data_set_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Indexed_context.Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem :=
              Indexed_context.Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Indexed_context.Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option :=
              Indexed_context.Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init :=
              Indexed_context.Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Indexed_context.Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set :=
              Indexed_context.Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option :=
              Indexed_context.Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete :=
              Indexed_context.Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove :=
              Indexed_context.Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec :=
              Indexed_context.Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy :=
              Indexed_context.Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys :=
              Indexed_context.Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project :=
              Indexed_context.Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Indexed_context.Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas :=
              Indexed_context.Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Indexed_context.Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description :=
              Indexed_context.Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;delegated&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Contract_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Contract_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Contract_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Contract_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Contract_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Contract_repr.Index.[Storage_description.INDEX.compare]
            |})).
  
  Definition Counter :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;counter&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Z.encoding
          |}).
  
  (* ‚ùå Functors are not handled. *)
  (* functor *)
  
  Definition Code :=
    Make_carbonated_map_expr
      (let name := cons &quot;code&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}).
  
  Definition Storage :=
    Make_carbonated_map_expr
      (let name := cons &quot;storage&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}).
  
  Definition Paid_storage_space :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;paid_bytes&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Z.encoding
          |}).
  
  Definition Used_storage_space :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;used_bytes&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Z.encoding
          |}).
  
  Definition Roll_list :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;roll_list&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
          |}).
  
  Definition Change :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;change&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
          |}).
End Contract.

Module Big_map.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;big_maps&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}).
  
  Module Next.
    Definition Single_data_storage :=
      (((Storage_functors.Make_single_data_storage
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;next&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |}))
        (existT _ _
          {|
            Storage_sigs.VALUE.encoding := Z.encoding
            |}).
    
    Definition t := Single_data_storage.[Storage_sigs.Single_data_storage.t].
    
    Definition context :=
      Single_data_storage.[Storage_sigs.Single_data_storage.context].
    
    Definition value :=
      Single_data_storage.[Storage_sigs.Single_data_storage.value].
    
    Definition mem := Single_data_storage.[Storage_sigs.Single_data_storage.mem].
    
    Definition get := Single_data_storage.[Storage_sigs.Single_data_storage.get].
    
    Definition get_option :=
      Single_data_storage.[Storage_sigs.Single_data_storage.get_option].
    
    Definition init :=
      Single_data_storage.[Storage_sigs.Single_data_storage.init].
    
    Definition set := Single_data_storage.[Storage_sigs.Single_data_storage.set].
    
    Definition init_set :=
      Single_data_storage.[Storage_sigs.Single_data_storage.init_set].
    
    Definition set_option :=
      Single_data_storage.[Storage_sigs.Single_data_storage.set_option].
    
    Definition delete :=
      Single_data_storage.[Storage_sigs.Single_data_storage.delete].
    
    Definition remove :=
      Single_data_storage.[Storage_sigs.Single_data_storage.remove].
    
    Definition incr (ctxt : context)
      : Lwt.t (Error_monad.tzresult (Raw_context.t * value)) :=
      Error_monad.op_gtgteqquestion (get ctxt)
        (fun i =&gt;
          Error_monad.op_gtgteqquestion (set ctxt (Z.succ i))
            (fun ctxt =&gt; Error_monad.__return (ctxt, i))).
    
    Definition init (ctxt : context)
      : Lwt.t (Error_monad.tzresult Raw_context.t) := init ctxt Z.zero.
  End Next.
  
  Definition Index :=
    let rpc_arg :=
      let construct := Z.to_string in
      let destruct (__hash_value : string) : Pervasives.result Z.t string :=
        let 'id := Z.of_string __hash_value in
        Pervasives.Ok id in
      RPC_arg.make (Some &quot;A big map identifier&quot; % string) &quot;big_map_id&quot; % string
        destruct construct tt in
    let encoding :=
      Data_encoding.def &quot;big_map_id&quot; % string
        (Some &quot;Big map identifier&quot; % string)
        (Some &quot;A big map identifier&quot; % string) Z.encoding in
    let compare := Compare.Z.[Compare.S.compare] in
    let path_length := 7 in
    let to_path (c : Z.t) (l : list string) : list string :=
      let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
      let 'Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      cons (String.sub index_key 0 2)
        (cons (String.sub index_key 2 2)
          (cons (String.sub index_key 4 2)
            (cons (String.sub index_key 6 2)
              (cons (String.sub index_key 8 2)
                (cons (String.sub index_key 10 2) (cons (Z.to_string c) l))))))
      in
    let of_path (function_parameter : list Compare.String.[Compare.S.t])
      : option Z.t :=
      match function_parameter with
      |
        [] | cons _ [] | cons _ (cons _ []) | cons _ (cons _ (cons _ [])) |
        cons _ (cons _ (cons _ (cons _ []))) |
        cons _ (cons _ (cons _ (cons _ (cons _ [])))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ []))))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ _)))))))
        =&gt; None
      |
        cons index1
          (cons index2
            (cons index3 (cons index4 (cons index5 (cons index6 (cons key []))))))
        =&gt;
        let c := Z.of_string key in
        let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
        let 'Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
        (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        Some c
      end in
    existT _ tt
      {|
        Storage_description.INDEX.rpc_arg := rpc_arg;
        Storage_description.INDEX.encoding := encoding;
        Storage_description.INDEX.compare := compare;
        Storage_description.INDEX.path_length := path_length;
        Storage_description.INDEX.to_path := to_path;
        Storage_description.INDEX.of_path := of_path
        |}.
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;index&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Index.[Storage_description.INDEX.compare]
            |})).
  
  Definition rpc_arg : RPC_arg.arg Z.t :=
    Index.[Storage_description.INDEX.rpc_arg].
  
  Definition fold {A : Set}
    : Indexed_context.[Storage_sigs.Indexed_raw_context.context] -&gt; A -&gt;
    (Indexed_context.[Storage_sigs.Indexed_raw_context.key] -&gt; A -&gt; Lwt.t A) -&gt;
    Lwt.t A := Indexed_context.[Storage_sigs.Indexed_raw_context.fold_keys].
  
  Definition __list_value
    : Indexed_context.[Storage_sigs.Indexed_raw_context.context] -&gt;
    Lwt.t (list Indexed_context.[Storage_sigs.Indexed_raw_context.key]) :=
    Indexed_context.[Storage_sigs.Indexed_raw_context.keys].
  
  Definition remove_rec
    (ctxt : Indexed_context.[Storage_sigs.Indexed_raw_context.context])
    (n : Indexed_context.[Storage_sigs.Indexed_raw_context.key])
    : Lwt.t Indexed_context.[Storage_sigs.Indexed_raw_context.context] :=
    Indexed_context.[Storage_sigs.Indexed_raw_context.remove_rec] ctxt n.
  
  Definition copy
    (ctxt : Indexed_context.[Storage_sigs.Indexed_raw_context.context])
    (from : Indexed_context.[Storage_sigs.Indexed_raw_context.key])
    (to_ : Indexed_context.[Storage_sigs.Indexed_raw_context.key])
    : Lwt.t
      (Error_monad.tzresult
        Indexed_context.[Storage_sigs.Indexed_raw_context.context]) :=
    Indexed_context.[Storage_sigs.Indexed_raw_context.copy] ctxt from to_.
  
  Definition key := Raw_context.[Raw_context.T.t] * Z.t.
  
  Definition Total_bytes :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;total_bytes&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Z.encoding
          |}).
  
  Definition Key_type :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;key_type&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (let encoding := Script_repr.expr_encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
  
  Definition Value_type :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;value_type&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (let encoding := Script_repr.expr_encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
  
  Module Contents.
    Definition I :=
      ((Storage_functors.Make_indexed_carbonated_data_storage
        (((Storage_functors.Make_subcontext
          (existT _ tt
            {|
              Storage_sigs.REGISTER.ghost :=
                Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
              |}))
          (existT _ _
            {|
              Raw_context.T.mem :=
                Indexed_context.Raw_context.[Raw_context.T.mem];
              Raw_context.T.dir_mem :=
                Indexed_context.Raw_context.[Raw_context.T.dir_mem];
              Raw_context.T.get :=
                Indexed_context.Raw_context.[Raw_context.T.get];
              Raw_context.T.get_option :=
                Indexed_context.Raw_context.[Raw_context.T.get_option];
              Raw_context.T.init :=
                Indexed_context.Raw_context.[Raw_context.T.init];
              Raw_context.T.set :=
                Indexed_context.Raw_context.[Raw_context.T.set];
              Raw_context.T.init_set :=
                Indexed_context.Raw_context.[Raw_context.T.init_set];
              Raw_context.T.set_option :=
                Indexed_context.Raw_context.[Raw_context.T.set_option];
              Raw_context.T.delete :=
                Indexed_context.Raw_context.[Raw_context.T.delete];
              Raw_context.T.remove :=
                Indexed_context.Raw_context.[Raw_context.T.remove];
              Raw_context.T.remove_rec :=
                Indexed_context.Raw_context.[Raw_context.T.remove_rec];
              Raw_context.T.copy :=
                Indexed_context.Raw_context.[Raw_context.T.copy];
              Raw_context.T.fold {_} :=
                Indexed_context.Raw_context.[Raw_context.T.fold];
              Raw_context.T.keys :=
                Indexed_context.Raw_context.[Raw_context.T.keys];
              Raw_context.T.fold_keys {_} :=
                Indexed_context.Raw_context.[Raw_context.T.fold_keys];
              Raw_context.T.project :=
                Indexed_context.Raw_context.[Raw_context.T.project];
              Raw_context.T.absolute_key :=
                Indexed_context.Raw_context.[Raw_context.T.absolute_key];
              Raw_context.T.consume_gas :=
                Indexed_context.Raw_context.[Raw_context.T.consume_gas];
              Raw_context.T.check_enough_gas :=
                Indexed_context.Raw_context.[Raw_context.T.check_enough_gas];
              Raw_context.T.description :=
                Indexed_context.Raw_context.[Raw_context.T.description]
              |}))
          (let name := cons &quot;contents&quot; % string [] in
          existT _ tt
            {|
              Storage_sigs.NAME.name := name
              |})))
        (Make_index
          (existT _ _
            {|
              Storage_description.INDEX.path_length :=
                Script_expr_hash.path_length;
              Storage_description.INDEX.to_path := Script_expr_hash.to_path;
              Storage_description.INDEX.of_path := Script_expr_hash.of_path;
              Storage_description.INDEX.rpc_arg := Script_expr_hash.rpc_arg;
              Storage_description.INDEX.encoding := Script_expr_hash.encoding;
              Storage_description.INDEX.compare := Script_expr_hash.compare
              |})))
        (let encoding := Script_repr.expr_encoding in
        existT _ _
          {|
            Storage_sigs.VALUE.encoding := encoding
            |}).
    
    Definition context := I.[Storage_sigs.Single_data_storage.context].
    
    Definition key := I.[Storage_sigs.Single_data_storage.key].
    
    Definition value := I.[Storage_sigs.Single_data_storage.value].
    
    Definition mem
      : I.[Storage_sigs.Single_data_storage.context] -&gt;
      I.[Storage_sigs.Single_data_storage.key] -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * bool)) :=
      I.[Storage_sigs.Single_data_storage.mem].
    
    Definition delete
      : I.[Storage_sigs.Single_data_storage.context] -&gt;
      I.[Storage_sigs.Single_data_storage.key] -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z)) :=
      I.[Storage_sigs.Single_data_storage.delete].
    
    Definition remove
      : I.[Storage_sigs.Single_data_storage.context] -&gt;
      I.[Storage_sigs.Single_data_storage.key] -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool)) :=
      I.[Storage_sigs.Single_data_storage.remove].
    
    Definition set
      : I.[Storage_sigs.Single_data_storage.context] -&gt;
      I.[Storage_sigs.Single_data_storage.key] -&gt;
      I.[Storage_sigs.Single_data_storage.value] -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z)) :=
      I.[Storage_sigs.Single_data_storage.set].
    
    Definition set_option
      : I.[Storage_sigs.Single_data_storage.context] -&gt;
      I.[Storage_sigs.Single_data_storage.key] -&gt;
      option I.[Storage_sigs.Single_data_storage.value] -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool)) :=
      I.[Storage_sigs.Single_data_storage.set_option].
    
    Definition init
      : I.[Storage_sigs.Single_data_storage.context] -&gt;
      I.[Storage_sigs.Single_data_storage.key] -&gt;
      I.[Storage_sigs.Single_data_storage.value] -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z)) :=
      I.[Storage_sigs.Single_data_storage.init].
    
    Definition init_set
      : I.[Storage_sigs.Single_data_storage.context] -&gt;
      I.[Storage_sigs.Single_data_storage.key] -&gt;
      I.[Storage_sigs.Single_data_storage.value] -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool)) :=
      I.[Storage_sigs.Single_data_storage.init_set].
    
    Definition consume_deserialize_gas
      (ctxt : Raw_context.[Raw_context.T.context]) (value : Script_repr.expr)
      : Lwt.t (Error_monad.tzresult Raw_context.[Raw_context.T.context]) :=
      Pervasives.op_atat Lwt.__return
        (Raw_context.[Raw_context.T.consume_gas] ctxt
          (Script_repr.deserialized_cost value)).
    
    Definition get
      (ctxt : I.[Storage_sigs.Single_data_storage.context])
      (contract : I.[Storage_sigs.Single_data_storage.key])
      : Lwt.t
        (Error_monad.tzresult
          (Raw_context.[Raw_context.T.context] *
            I.[Storage_sigs.Single_data_storage.value])) :=
      Error_monad.op_gtgteqquestion
        (I.[Storage_sigs.Single_data_storage.get] ctxt contract)
        (fun function_parameter =&gt;
          let '(ctxt, value) := function_parameter in
          Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
            (fun ctxt =&gt; (ctxt, value))).
    
    Definition get_option
      (ctxt : I.[Storage_sigs.Single_data_storage.context])
      (contract : I.[Storage_sigs.Single_data_storage.key])
      : Lwt.t
        (Error_monad.tzresult
          (Raw_context.t * option I.[Storage_sigs.Single_data_storage.value])) :=
      Error_monad.op_gtgteqquestion
        (I.[Storage_sigs.Single_data_storage.get_option] ctxt contract)
        (fun function_parameter =&gt;
          let '(ctxt, value_opt) := function_parameter in
          match value_opt with
          | None =&gt; Error_monad.__return (ctxt, None)
          | Some value =&gt;
            Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
              (fun ctxt =&gt; (ctxt, value_opt))
          end).
  End Contents.
End Big_map.

Definition Delegates :=
  (Storage_functors.Make_data_set_storage
    (((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;delegates&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |})))
    (Make_index
      (existT _ _
        {|
          Storage_description.INDEX.path_length :=
            Signature.Public_key_hash.[S.SPublic_key_hash.path_length];
          Storage_description.INDEX.to_path :=
            Signature.Public_key_hash.[S.SPublic_key_hash.to_path];
          Storage_description.INDEX.of_path :=
            Signature.Public_key_hash.[S.SPublic_key_hash.of_path];
          Storage_description.INDEX.rpc_arg :=
            Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg];
          Storage_description.INDEX.encoding :=
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding];
          Storage_description.INDEX.compare :=
            Signature.Public_key_hash.[S.SPublic_key_hash.compare]
          |})).

Definition Active_delegates_with_rolls :=
  (Storage_functors.Make_data_set_storage
    (((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;active_delegates_with_rolls&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |})))
    (Make_index
      (existT _ _
        {|
          Storage_description.INDEX.path_length :=
            Signature.Public_key_hash.[S.SPublic_key_hash.path_length];
          Storage_description.INDEX.to_path :=
            Signature.Public_key_hash.[S.SPublic_key_hash.to_path];
          Storage_description.INDEX.of_path :=
            Signature.Public_key_hash.[S.SPublic_key_hash.of_path];
          Storage_description.INDEX.rpc_arg :=
            Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg];
          Storage_description.INDEX.encoding :=
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding];
          Storage_description.INDEX.compare :=
            Signature.Public_key_hash.[S.SPublic_key_hash.compare]
          |})).

Definition Delegates_with_frozen_balance_index :=
  (Storage_functors.Make_indexed_subcontext
    (((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;delegates_with_frozen_balance&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |})))
    (Make_index
      (existT _ _
        {|
          Storage_description.INDEX.path_length :=
            Cycle_repr.Index.[Storage_description.INDEX.path_length];
          Storage_description.INDEX.to_path :=
            Cycle_repr.Index.[Storage_description.INDEX.to_path];
          Storage_description.INDEX.of_path :=
            Cycle_repr.Index.[Storage_description.INDEX.of_path];
          Storage_description.INDEX.rpc_arg :=
            Cycle_repr.Index.[Storage_description.INDEX.rpc_arg];
          Storage_description.INDEX.encoding :=
            Cycle_repr.Index.[Storage_description.INDEX.encoding];
          Storage_description.INDEX.compare :=
            Cycle_repr.Index.[Storage_description.INDEX.compare]
          |})).

Definition Delegates_with_frozen_balance :=
  (Storage_functors.Make_data_set_storage
    (existT _ _
      {|
        Raw_context.T.mem :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.mem];
        Raw_context.T.dir_mem :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.dir_mem];
        Raw_context.T.get :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.get];
        Raw_context.T.get_option :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.get_option];
        Raw_context.T.init :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.init];
        Raw_context.T.set :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.set];
        Raw_context.T.init_set :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.init_set];
        Raw_context.T.set_option :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.set_option];
        Raw_context.T.delete :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.delete];
        Raw_context.T.remove :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.remove];
        Raw_context.T.remove_rec :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.remove_rec];
        Raw_context.T.copy :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.copy];
        Raw_context.T.fold {_} :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.fold];
        Raw_context.T.keys :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.keys];
        Raw_context.T.fold_keys {_} :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.fold_keys];
        Raw_context.T.project :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.project];
        Raw_context.T.absolute_key :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.absolute_key];
        Raw_context.T.consume_gas :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.consume_gas];
        Raw_context.T.check_enough_gas :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.check_enough_gas];
        Raw_context.T.description :=
          Delegates_with_frozen_balance_index.Raw_context.[Raw_context.T.description]
        |}))
    (Make_index
      (existT _ _
        {|
          Storage_description.INDEX.path_length :=
            Signature.Public_key_hash.[S.SPublic_key_hash.path_length];
          Storage_description.INDEX.to_path :=
            Signature.Public_key_hash.[S.SPublic_key_hash.to_path];
          Storage_description.INDEX.of_path :=
            Signature.Public_key_hash.[S.SPublic_key_hash.of_path];
          Storage_description.INDEX.rpc_arg :=
            Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg];
          Storage_description.INDEX.encoding :=
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding];
          Storage_description.INDEX.compare :=
            Signature.Public_key_hash.[S.SPublic_key_hash.compare]
          |})).

Module Cycle.
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
            |}))
        (let name := cons &quot;cycle&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Cycle_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Cycle_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Cycle_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Cycle_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Cycle_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Cycle_repr.Index.[Storage_description.INDEX.compare]
            |})).
  
  Definition Last_roll :=
    ((Storage_functors.Make_indexed_data_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Indexed_context.Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem :=
              Indexed_context.Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Indexed_context.Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option :=
              Indexed_context.Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init :=
              Indexed_context.Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Indexed_context.Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set :=
              Indexed_context.Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option :=
              Indexed_context.Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete :=
              Indexed_context.Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove :=
              Indexed_context.Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec :=
              Indexed_context.Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy :=
              Indexed_context.Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys :=
              Indexed_context.Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project :=
              Indexed_context.Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Indexed_context.Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas :=
              Indexed_context.Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Indexed_context.Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description :=
              Indexed_context.Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;last_roll&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (existT _ [_, _]
        {|
          Storage_functors.INDEX.path_length :=
            Int_index.[Storage_functors.INDEX.path_length];
          Storage_functors.INDEX.to_path :=
            Int_index.[Storage_functors.INDEX.to_path];
          Storage_functors.INDEX.of_path :=
            Int_index.[Storage_functors.INDEX.of_path];
          Storage_functors.INDEX.args {_} :=
            Int_index.[Storage_functors.INDEX.args]
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
          |}).
  
  Definition Roll_snapshot :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;roll_snapshot&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Int.[Storage_sigs.VALUE.encoding]
          |}).
  
  Module unrevealed_nonce.
    Record record := {
      nonce_hash : Nonce_hash.t;
      delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
      rewards : Tez_repr.t;
      fees : Tez_repr.t }.
  End unrevealed_nonce.
  Definition unrevealed_nonce := unrevealed_nonce.record.
  
  Inductive nonce_status : Set :=
  | Unrevealed : unrevealed_nonce -&gt; nonce_status
  | Revealed : Seed_repr.nonce -&gt; nonce_status.
  
  Definition nonce_status_encoding : Data_encoding.encoding nonce_status :=
    Data_encoding.union None
      (cons
        (Data_encoding.__case_value &quot;Unrevealed&quot; % string None
          (Data_encoding.Tag 0)
          (Data_encoding.tup4 Nonce_hash.encoding
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding]
            Tez_repr.encoding Tez_repr.encoding)
          (fun function_parameter =&gt;
            match function_parameter with
            |
              Unrevealed {|
                unrevealed_nonce.nonce_hash := nonce_hash;
                  unrevealed_nonce.delegate := delegate;
                  unrevealed_nonce.rewards := rewards;
                  unrevealed_nonce.fees := fees
                  |} =&gt; Some (nonce_hash, delegate, rewards, fees)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(nonce_hash, delegate, rewards, fees) := function_parameter in
            Unrevealed
              {| unrevealed_nonce.nonce_hash := nonce_hash;
                unrevealed_nonce.delegate := delegate;
                unrevealed_nonce.rewards := rewards;
                unrevealed_nonce.fees := fees |}))
        (cons
          (Data_encoding.__case_value &quot;Revealed&quot; % string None
            (Data_encoding.Tag 1) Seed_repr.nonce_encoding
            (fun function_parameter =&gt;
              match function_parameter with
              | Revealed nonce =&gt; Some nonce
              | _ =&gt; None
              end) (fun nonce =&gt; Revealed nonce)) [])).
  
  Definition Nonce :=
    ((Storage_functors.Make_indexed_data_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Indexed_context.Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem :=
              Indexed_context.Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Indexed_context.Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option :=
              Indexed_context.Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init :=
              Indexed_context.Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Indexed_context.Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set :=
              Indexed_context.Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option :=
              Indexed_context.Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete :=
              Indexed_context.Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove :=
              Indexed_context.Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec :=
              Indexed_context.Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy :=
              Indexed_context.Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys :=
              Indexed_context.Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} :=
              Indexed_context.Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project :=
              Indexed_context.Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Indexed_context.Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas :=
              Indexed_context.Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Indexed_context.Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description :=
              Indexed_context.Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;nonces&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Raw_level_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Raw_level_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Raw_level_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Raw_level_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Raw_level_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Raw_level_repr.Index.[Storage_description.INDEX.compare]
            |})))
      (let encoding := nonce_status_encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
  
  Definition Seed :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;random_seed&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (let encoding := Seed_repr.seed_encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
End Cycle.

Module Roll.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;rolls&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}).
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;index&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Roll_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Roll_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Roll_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Roll_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Roll_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Roll_repr.Index.[Storage_description.INDEX.compare]
            |})).
  
  Definition Next :=
    (((Storage_functors.Make_single_data_storage
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
          Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
          Raw_context.T.get := Raw_context.[Raw_context.T.get];
          Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
          Raw_context.T.init := Raw_context.[Raw_context.T.init];
          Raw_context.T.set := Raw_context.[Raw_context.T.set];
          Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
          Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
          Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
          Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
          Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
          Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
          Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
          Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
          Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
          Raw_context.T.project := Raw_context.[Raw_context.T.project];
          Raw_context.T.absolute_key := Raw_context.[Raw_context.T.absolute_key];
          Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
          Raw_context.T.check_enough_gas :=
            Raw_context.[Raw_context.T.check_enough_gas];
          Raw_context.T.description := Raw_context.[Raw_context.T.description]
          |}))
      (let name := cons &quot;next&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
          |}).
  
  Definition Limbo :=
    (((Storage_functors.Make_single_data_storage
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
          Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
          Raw_context.T.get := Raw_context.[Raw_context.T.get];
          Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
          Raw_context.T.init := Raw_context.[Raw_context.T.init];
          Raw_context.T.set := Raw_context.[Raw_context.T.set];
          Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
          Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
          Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
          Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
          Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
          Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
          Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
          Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
          Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
          Raw_context.T.project := Raw_context.[Raw_context.T.project];
          Raw_context.T.absolute_key := Raw_context.[Raw_context.T.absolute_key];
          Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
          Raw_context.T.check_enough_gas :=
            Raw_context.[Raw_context.T.check_enough_gas];
          Raw_context.T.description := Raw_context.[Raw_context.T.description]
          |}))
      (let name := cons &quot;limbo&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
          |}).
  
  Definition Delegate_roll_list :=
    (Storage_functors.Wrap_indexed_data_storage
      (existT _ [_, _, _]
        {|
          Storage_sigs.Indexed_data_storage.mem :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.mem];
          Storage_sigs.Indexed_data_storage.get :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.get];
          Storage_sigs.Indexed_data_storage.get_option :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.get_option];
          Storage_sigs.Indexed_data_storage.set :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.set];
          Storage_sigs.Indexed_data_storage.init :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.init];
          Storage_sigs.Indexed_data_storage.init_set :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.init_set];
          Storage_sigs.Indexed_data_storage.set_option :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.set_option];
          Storage_sigs.Indexed_data_storage.delete :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.delete];
          Storage_sigs.Indexed_data_storage.remove :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.remove];
          Storage_sigs.Indexed_data_storage.clear :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.clear];
          Storage_sigs.Indexed_data_storage.keys :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.keys];
          Storage_sigs.Indexed_data_storage.bindings :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.bindings];
          Storage_sigs.Indexed_data_storage.fold {_} :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.fold];
          Storage_sigs.Indexed_data_storage.fold_keys {_} :=
            Contract.Roll_list.[Storage_sigs.Indexed_data_storage.fold_keys]
          |}))
      (* ‚ùå The signature name of this module could not be found *)
      first_class_module_value_of_unknown_signature.
  
  Definition Successor :=
    (Indexed_context.[Storage_sigs.Indexed_raw_context.Make_map]
      (let name := cons &quot;successor&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
          |}).
  
  Definition Delegate_change :=
    (Storage_functors.Wrap_indexed_data_storage
      (existT _ [_, _, _]
        {|
          Storage_sigs.Indexed_data_storage.mem :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.mem];
          Storage_sigs.Indexed_data_storage.get :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.get];
          Storage_sigs.Indexed_data_storage.get_option :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.get_option];
          Storage_sigs.Indexed_data_storage.set :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.set];
          Storage_sigs.Indexed_data_storage.init :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.init];
          Storage_sigs.Indexed_data_storage.init_set :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.init_set];
          Storage_sigs.Indexed_data_storage.set_option :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.set_option];
          Storage_sigs.Indexed_data_storage.delete :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.delete];
          Storage_sigs.Indexed_data_storage.remove :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.remove];
          Storage_sigs.Indexed_data_storage.clear :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.clear];
          Storage_sigs.Indexed_data_storage.keys :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.keys];
          Storage_sigs.Indexed_data_storage.bindings :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.bindings];
          Storage_sigs.Indexed_data_storage.fold {_} :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.fold];
          Storage_sigs.Indexed_data_storage.fold_keys {_} :=
            Contract.Change.[Storage_sigs.Indexed_data_storage.fold_keys]
          |}))
      (* ‚ùå The signature name of this module could not be found *)
      first_class_module_value_of_unknown_signature.
  
  Module Snapshoted_owner_index.
    Definition t := Cycle_repr.t * Z.
    
    Definition path_length : Z :=
      Pervasives.op_plus
        Cycle_repr.Index.[Storage_description.INDEX.path_length] 1.
    
    Definition to_path
      (function_parameter : Cycle_repr.Index.[Storage_description.INDEX.t] * Z)
      : list string -&gt; list string :=
      let '(c, n) := function_parameter in
      fun s =&gt;
        Cycle_repr.Index.[Storage_description.INDEX.to_path] c
          (cons (Pervasives.string_of_int n) s).
    
    Definition of_path (l : list string)
      : option (Cycle_repr.Index.[Storage_description.INDEX.t] * Z) :=
      match Misc.take Cycle_repr.Index.[Storage_description.INDEX.path_length] l
        with
      | None | Some (_, [] | cons _ (cons _ _)) =&gt; None
      | Some (l1, cons l2 []) =&gt;
        match
          ((Cycle_repr.Index.[Storage_description.INDEX.of_path] l1),
            (Pervasives.int_of_string_opt l2)) with
        | (None, _) | (_, None) =&gt; None
        | (Some c, Some i) =&gt; Some (c, i)
        end
      end.
    
    Definition ipath (a : Set) := (a * Cycle_repr.t) * Z.
    
    Definition left_args {A : Set}
      : Storage_description.args A Cycle_repr.cycle (A * Cycle_repr.cycle) :=
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := Cycle_repr.rpc_arg;
          Storage_description.args.One.encoding := Cycle_repr.encoding;
          Storage_description.args.One.compare := Cycle_repr.compare |}.
    
    Definition right_args {A : Set}
      : Storage_description.args A Compare.Int.[Compare.S.t]
        (A * Compare.Int.[Compare.S.t]) :=
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := RPC_arg.int;
          Storage_description.args.One.encoding := Data_encoding.int31;
          Storage_description.args.One.compare :=
            Compare.Int.[Compare.S.compare] |}.
    
    Definition args {A : Set}
      : Storage_description.args A
        (Cycle_repr.cycle * Compare.Int.[Compare.S.t])
        ((A * Cycle_repr.cycle) * Compare.Int.[Compare.S.t]) :=
      Storage_description.Pair left_args right_args.
  End Snapshoted_owner_index.
  
  Definition Owner :=
    (((Storage_functors.Make_indexed_data_snapshotable_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;owner&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (existT _ [_, _]
        {|
          Storage_functors.INDEX.path_length :=
            Snapshoted_owner_index.path_length;
          Storage_functors.INDEX.to_path := Snapshoted_owner_index.to_path;
          Storage_functors.INDEX.of_path := Snapshoted_owner_index.of_path;
          Storage_functors.INDEX.args {_} := Snapshoted_owner_index.args
          |}))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Roll_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Roll_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Roll_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Roll_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Roll_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Roll_repr.Index.[Storage_description.INDEX.compare]
            |})))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding :=
            Signature.Public_key.[S.SPublic_key.encoding]
          |}).
  
  Definition Snapshot_for_cycle := Cycle.Roll_snapshot.
  
  Definition Last_for_snapshot := Cycle.Last_roll.
  
  Definition clear
    : Indexed_context.[Storage_sigs.Indexed_raw_context.context] -&gt;
    Lwt.t Raw_context.t :=
    Indexed_context.[Storage_sigs.Indexed_raw_context.clear].
End Roll.

Module Vote.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;votes&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}).
  
  Definition Current_period_kind :=
    (((Storage_functors.Make_single_data_storage
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
          Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
          Raw_context.T.get := Raw_context.[Raw_context.T.get];
          Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
          Raw_context.T.init := Raw_context.[Raw_context.T.init];
          Raw_context.T.set := Raw_context.[Raw_context.T.set];
          Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
          Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
          Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
          Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
          Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
          Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
          Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
          Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
          Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
          Raw_context.T.project := Raw_context.[Raw_context.T.project];
          Raw_context.T.absolute_key := Raw_context.[Raw_context.T.absolute_key];
          Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
          Raw_context.T.check_enough_gas :=
            Raw_context.[Raw_context.T.check_enough_gas];
          Raw_context.T.description := Raw_context.[Raw_context.T.description]
          |}))
      (let name := cons &quot;current_period_kind&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (let encoding := Voting_period_repr.kind_encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
  
  Definition Participation_ema :=
    (((Storage_functors.Make_single_data_storage
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
          Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
          Raw_context.T.get := Raw_context.[Raw_context.T.get];
          Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
          Raw_context.T.init := Raw_context.[Raw_context.T.init];
          Raw_context.T.set := Raw_context.[Raw_context.T.set];
          Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
          Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
          Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
          Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
          Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
          Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
          Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
          Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
          Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
          Raw_context.T.project := Raw_context.[Raw_context.T.project];
          Raw_context.T.absolute_key := Raw_context.[Raw_context.T.absolute_key];
          Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
          Raw_context.T.check_enough_gas :=
            Raw_context.[Raw_context.T.check_enough_gas];
          Raw_context.T.description := Raw_context.[Raw_context.T.description]
          |}))
      (let name := cons &quot;participation_ema&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Int32.[Storage_sigs.VALUE.encoding]
          |}).
  
  Definition Current_proposal :=
    (((Storage_functors.Make_single_data_storage
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
          Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
          Raw_context.T.get := Raw_context.[Raw_context.T.get];
          Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
          Raw_context.T.init := Raw_context.[Raw_context.T.init];
          Raw_context.T.set := Raw_context.[Raw_context.T.set];
          Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
          Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
          Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
          Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
          Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
          Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
          Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
          Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
          Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
          Raw_context.T.project := Raw_context.[Raw_context.T.project];
          Raw_context.T.absolute_key := Raw_context.[Raw_context.T.absolute_key];
          Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
          Raw_context.T.check_enough_gas :=
            Raw_context.[Raw_context.T.check_enough_gas];
          Raw_context.T.description := Raw_context.[Raw_context.T.description]
          |}))
      (let name := cons &quot;current_proposal&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Protocol_hash.[S.HASH.encoding]
          |}).
  
  Definition Listings_size :=
    (((Storage_functors.Make_single_data_storage
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
          Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
          Raw_context.T.get := Raw_context.[Raw_context.T.get];
          Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
          Raw_context.T.init := Raw_context.[Raw_context.T.init];
          Raw_context.T.set := Raw_context.[Raw_context.T.set];
          Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
          Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
          Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
          Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
          Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
          Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
          Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
          Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
          Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
          Raw_context.T.project := Raw_context.[Raw_context.T.project];
          Raw_context.T.absolute_key := Raw_context.[Raw_context.T.absolute_key];
          Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
          Raw_context.T.check_enough_gas :=
            Raw_context.[Raw_context.T.check_enough_gas];
          Raw_context.T.description := Raw_context.[Raw_context.T.description]
          |}))
      (let name := cons &quot;listings_size&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |}))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Int32.[Storage_sigs.VALUE.encoding]
          |}).
  
  Definition Listings :=
    ((Storage_functors.Make_indexed_data_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;listings&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Signature.Public_key_hash.[S.SPublic_key_hash.path_length];
            Storage_description.INDEX.to_path :=
              Signature.Public_key_hash.[S.SPublic_key_hash.to_path];
            Storage_description.INDEX.of_path :=
              Signature.Public_key_hash.[S.SPublic_key_hash.of_path];
            Storage_description.INDEX.rpc_arg :=
              Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg];
            Storage_description.INDEX.encoding :=
              Signature.Public_key_hash.[S.SPublic_key_hash.encoding];
            Storage_description.INDEX.compare :=
              Signature.Public_key_hash.[S.SPublic_key_hash.compare]
            |})))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Int32.[Storage_sigs.VALUE.encoding]
          |}).
  
  Definition Proposals :=
    (Storage_functors.Make_data_set_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;proposals&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      ((Storage_functors.Pair
        (Make_index
          (existT _ _
            {|
              Storage_description.INDEX.path_length :=
                Protocol_hash.[S.HASH.path_length];
              Storage_description.INDEX.to_path :=
                Protocol_hash.[S.HASH.to_path];
              Storage_description.INDEX.of_path :=
                Protocol_hash.[S.HASH.of_path];
              Storage_description.INDEX.rpc_arg :=
                Protocol_hash.[S.HASH.rpc_arg];
              Storage_description.INDEX.encoding :=
                Protocol_hash.[S.HASH.encoding];
              Storage_description.INDEX.compare :=
                Protocol_hash.[S.HASH.compare]
              |})))
        (Make_index
          (existT _ _
            {|
              Storage_description.INDEX.path_length :=
                Signature.Public_key_hash.[S.SPublic_key_hash.path_length];
              Storage_description.INDEX.to_path :=
                Signature.Public_key_hash.[S.SPublic_key_hash.to_path];
              Storage_description.INDEX.of_path :=
                Signature.Public_key_hash.[S.SPublic_key_hash.of_path];
              Storage_description.INDEX.rpc_arg :=
                Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg];
              Storage_description.INDEX.encoding :=
                Signature.Public_key_hash.[S.SPublic_key_hash.encoding];
              Storage_description.INDEX.compare :=
                Signature.Public_key_hash.[S.SPublic_key_hash.compare]
              |}))).
  
  Definition Proposals_count :=
    ((Storage_functors.Make_indexed_data_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;proposals_count&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Signature.Public_key_hash.[S.SPublic_key_hash.path_length];
            Storage_description.INDEX.to_path :=
              Signature.Public_key_hash.[S.SPublic_key_hash.to_path];
            Storage_description.INDEX.of_path :=
              Signature.Public_key_hash.[S.SPublic_key_hash.of_path];
            Storage_description.INDEX.rpc_arg :=
              Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg];
            Storage_description.INDEX.encoding :=
              Signature.Public_key_hash.[S.SPublic_key_hash.encoding];
            Storage_description.INDEX.compare :=
              Signature.Public_key_hash.[S.SPublic_key_hash.compare]
            |})))
      (existT _ _
        {|
          Storage_sigs.VALUE.encoding := Int.[Storage_sigs.VALUE.encoding]
          |}).
  
  Definition Ballots :=
    ((Storage_functors.Make_indexed_data_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.[Raw_context.T.mem];
            Raw_context.T.dir_mem := Raw_context.[Raw_context.T.dir_mem];
            Raw_context.T.get := Raw_context.[Raw_context.T.get];
            Raw_context.T.get_option := Raw_context.[Raw_context.T.get_option];
            Raw_context.T.init := Raw_context.[Raw_context.T.init];
            Raw_context.T.set := Raw_context.[Raw_context.T.set];
            Raw_context.T.init_set := Raw_context.[Raw_context.T.init_set];
            Raw_context.T.set_option := Raw_context.[Raw_context.T.set_option];
            Raw_context.T.delete := Raw_context.[Raw_context.T.delete];
            Raw_context.T.remove := Raw_context.[Raw_context.T.remove];
            Raw_context.T.remove_rec := Raw_context.[Raw_context.T.remove_rec];
            Raw_context.T.copy := Raw_context.[Raw_context.T.copy];
            Raw_context.T.fold {_} := Raw_context.[Raw_context.T.fold];
            Raw_context.T.keys := Raw_context.[Raw_context.T.keys];
            Raw_context.T.fold_keys {_} := Raw_context.[Raw_context.T.fold_keys];
            Raw_context.T.project := Raw_context.[Raw_context.T.project];
            Raw_context.T.absolute_key :=
              Raw_context.[Raw_context.T.absolute_key];
            Raw_context.T.consume_gas := Raw_context.[Raw_context.T.consume_gas];
            Raw_context.T.check_enough_gas :=
              Raw_context.[Raw_context.T.check_enough_gas];
            Raw_context.T.description := Raw_context.[Raw_context.T.description]
            |}))
        (let name := cons &quot;ballots&quot; % string [] in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Signature.Public_key_hash.[S.SPublic_key_hash.path_length];
            Storage_description.INDEX.to_path :=
              Signature.Public_key_hash.[S.SPublic_key_hash.to_path];
            Storage_description.INDEX.of_path :=
              Signature.Public_key_hash.[S.SPublic_key_hash.of_path];
            Storage_description.INDEX.rpc_arg :=
              Signature.Public_key_hash.[S.SPublic_key_hash.rpc_arg];
            Storage_description.INDEX.encoding :=
              Signature.Public_key_hash.[S.SPublic_key_hash.encoding];
            Storage_description.INDEX.compare :=
              Signature.Public_key_hash.[S.SPublic_key_hash.compare]
            |})))
      (let encoding := Vote_repr.ballot_encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
End Vote.

Module Seed.
  Module unrevealed_nonce.
    Record record := {
      nonce_hash : Nonce_hash.t;
      delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
      rewards : Tez_repr.t;
      fees : Tez_repr.t }.
  End unrevealed_nonce.
  Definition unrevealed_nonce := unrevealed_nonce.record.
  
  Inductive nonce_status : Set :=
  | Unrevealed : unrevealed_nonce -&gt; nonce_status
  | Revealed : Seed_repr.nonce -&gt; nonce_status.
  
  Definition Nonce :=
    (* ‚ùå open *)
    let mem
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t) : Lwt.t bool :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.mem]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) in
    let get
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t)
      : Lwt.t
        (Error_monad.tzresult
          Cycle.Nonce.[Storage_sigs.Indexed_data_storage.value]) :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.get]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) in
    let get_option
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t)
      : Lwt.t
        (Error_monad.tzresult
          (option Cycle.Nonce.[Storage_sigs.Indexed_data_storage.value])) :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.get_option]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) in
    let set
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t)
      (v : Cycle.Nonce.[Storage_sigs.Indexed_data_storage.value])
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.set]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) v in
    let init
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t)
      (v : Cycle.Nonce.[Storage_sigs.Indexed_data_storage.value])
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.init]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) v in
    let init_set
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t)
      (v : Cycle.Nonce.[Storage_sigs.Indexed_data_storage.value])
      : Lwt.t Raw_context.t :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.init_set]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) v in
    let set_option
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t)
      (v : option Cycle.Nonce.[Storage_sigs.Indexed_data_storage.value])
      : Lwt.t Raw_context.t :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.set_option]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) v in
    let delete
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.delete]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) in
    let remove
      (ctxt : Cycle.Indexed_context.[Storage_sigs.Indexed_raw_context.t])
      (l : Level_repr.t) : Lwt.t Raw_context.t :=
      Cycle.Nonce.[Storage_sigs.Indexed_data_storage.remove]
        (ctxt, (Level_repr.t.cycle l)) (Level_repr.t.level l) in
    existT _ tt
      {|
        Storage_sigs.Single_data_storage.mem := mem;
        Storage_sigs.Single_data_storage.get := get;
        Storage_sigs.Single_data_storage.get_option := get_option;
        Storage_sigs.Single_data_storage.set := set;
        Storage_sigs.Single_data_storage.init := init;
        Storage_sigs.Single_data_storage.init_set := init_set;
        Storage_sigs.Single_data_storage.set_option := set_option;
        Storage_sigs.Single_data_storage.delete := delete;
        Storage_sigs.Single_data_storage.remove := remove
        |}.
  
  Definition For_cycle := Cycle.Seed.
End Seed.

Definition Commitments :=
  ((Storage_functors.Make_indexed_data_storage
    (((Storage_functors.Make_subcontext
      (existT _ tt
        {|
          Storage_sigs.REGISTER.ghost :=
            Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
          |}))
      (existT _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
          |}))
      (let name := cons &quot;commitments&quot; % string [] in
      existT _ tt
        {|
          Storage_sigs.NAME.name := name
          |})))
    (Make_index
      (existT _ _
        {|
          Storage_description.INDEX.path_length :=
            Blinded_public_key_hash.Index.[Storage_description.INDEX.path_length];
          Storage_description.INDEX.to_path :=
            Blinded_public_key_hash.Index.[Storage_description.INDEX.to_path];
          Storage_description.INDEX.of_path :=
            Blinded_public_key_hash.Index.[Storage_description.INDEX.of_path];
          Storage_description.INDEX.rpc_arg :=
            Blinded_public_key_hash.Index.[Storage_description.INDEX.rpc_arg];
          Storage_description.INDEX.encoding :=
            Blinded_public_key_hash.Index.[Storage_description.INDEX.encoding];
          Storage_description.INDEX.compare :=
            Blinded_public_key_hash.Index.[Storage_description.INDEX.compare]
          |})))
    (existT _ _
      {|
        Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).

Module Ramp_up.
  Definition Rewards :=
    ((Storage_functors.Make_indexed_data_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
            |}))
        (let name := cons &quot;ramp_up&quot; % string (cons &quot;rewards&quot; % string []) in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Cycle_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Cycle_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Cycle_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Cycle_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Cycle_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Cycle_repr.Index.[Storage_description.INDEX.compare]
            |})))
      (let encoding := Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
  
  Definition Security_deposits :=
    ((Storage_functors.Make_indexed_data_storage
      (((Storage_functors.Make_subcontext
        (existT _ tt
          {|
            Storage_sigs.REGISTER.ghost :=
              Storage_functors.Registered.[Storage_sigs.REGISTER.ghost]
            |}))
        (existT _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
            |}))
        (let name := cons &quot;ramp_up&quot; % string (cons &quot;deposits&quot; % string []) in
        existT _ tt
          {|
            Storage_sigs.NAME.name := name
            |})))
      (Make_index
        (existT _ _
          {|
            Storage_description.INDEX.path_length :=
              Cycle_repr.Index.[Storage_description.INDEX.path_length];
            Storage_description.INDEX.to_path :=
              Cycle_repr.Index.[Storage_description.INDEX.to_path];
            Storage_description.INDEX.of_path :=
              Cycle_repr.Index.[Storage_description.INDEX.of_path];
            Storage_description.INDEX.rpc_arg :=
              Cycle_repr.Index.[Storage_description.INDEX.rpc_arg];
            Storage_description.INDEX.encoding :=
              Cycle_repr.Index.[Storage_description.INDEX.encoding];
            Storage_description.INDEX.compare :=
              Cycle_repr.Index.[Storage_description.INDEX.compare]
            |})))
      (let encoding := Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding in
      existT _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
          |}).
End Ramp_up.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage.mli">
  <div class="col-md-6">
    <a href="#storage.mli"><code>storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Typed storage

    This module hides the hierarchical (key x value) database under
    pre-allocated typed accessors for all persistent entities of the
    tezos context.

    This interface enforces no invariant on the contents of the
    database. Its goal is to centralize all accessors in order to have
    a complete view over the database contents and avoid key
    collisions. *)

open Storage_sigs

module Block_priority : sig
  val get : Raw_context.t -&gt; int tzresult Lwt.t

  val set : Raw_context.t -&gt; int -&gt; Raw_context.t tzresult Lwt.t

  val init : Raw_context.t -&gt; int -&gt; Raw_context.t tzresult Lwt.t
end

module Roll : sig
  (** Storage from this submodule must only be accessed through the
      module `Roll`. *)

  module Owner :
    Indexed_data_snapshotable_storage
      with type key = Roll_repr.t
       and type snapshot = Cycle_repr.t * int
       and type value = Signature.Public_key.t
       and type t := Raw_context.t

  val clear : Raw_context.t -&gt; Raw_context.t Lwt.t

  (** The next roll to be allocated. *)
  module Next :
    Single_data_storage
      with type value = Roll_repr.t
       and type t := Raw_context.t

  (** Rolls linked lists represent both account owned and free rolls.
      All rolls belongs either to the limbo list or to an owned list. *)

  (** Head of the linked list of rolls in limbo *)
  module Limbo :
    Single_data_storage
      with type value = Roll_repr.t
       and type t := Raw_context.t

  (** Rolls associated to contracts, a linked list per contract *)
  module Delegate_roll_list :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Roll_repr.t
       and type t := Raw_context.t

  (** Use this to iter on a linked list of rolls *)
  module Successor :
    Indexed_data_storage
      with type key = Roll_repr.t
       and type value = Roll_repr.t
       and type t := Raw_context.t

  (** The tez of a contract that are not assigned to rolls *)
  module Delegate_change :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Tez_repr.t
       and type t := Raw_context.t

  (** Index of the randomly selected roll snapshot of a given cycle. *)
  module Snapshot_for_cycle :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = int
       and type t := Raw_context.t

  (** Last roll in the snapshoted roll allocation of a given cycle. *)
  module Last_for_snapshot :
    Indexed_data_storage
      with type key = int
       and type value = Roll_repr.t
       and type t = Raw_context.t * Cycle_repr.t
end

module Contract : sig
  (** Storage from this submodule must only be accessed through the
      module `Contract`. *)

  module Global_counter : sig
    val get : Raw_context.t -&gt; Z.t tzresult Lwt.t

    val set : Raw_context.t -&gt; Z.t -&gt; Raw_context.t tzresult Lwt.t

    val init : Raw_context.t -&gt; Z.t -&gt; Raw_context.t tzresult Lwt.t
  end

  (** The domain of alive contracts *)
  val fold :
    Raw_context.t -&gt;
    init:'a -&gt;
    f:(Contract_repr.t -&gt; 'a -&gt; 'a Lwt.t) -&gt;
    'a Lwt.t

  val list : Raw_context.t -&gt; Contract_repr.t list Lwt.t

  (** All the tez possesed by a contract, including rolls and change *)
  module Balance :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Tez_repr.t
       and type t := Raw_context.t

  (** Frozen balance, see 'delegate_storage.mli' for more explanation.
      Always update `Delegates_with_frozen_balance` accordingly. *)
  module Frozen_deposits :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t

  module Frozen_fees :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t

  module Frozen_rewards :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t

  (** The manager of a contract *)
  module Manager :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Manager_repr.t
       and type t := Raw_context.t

  (** The delegate of a contract, if any. *)
  module Delegate :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Signature.Public_key_hash.t
       and type t := Raw_context.t

  (** All contracts (implicit and originated) that are delegated, if any  *)
  module Delegated :
    Data_set_storage
      with type elt = Contract_repr.t
       and type t = Raw_context.t * Contract_repr.t

  module Inactive_delegate :
    Data_set_storage with type elt = Contract_repr.t and type t = Raw_context.t

  (** The cycle where the delegate should be desactivated. *)
  module Delegate_desactivation :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Cycle_repr.t
       and type t := Raw_context.t

  module Counter :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t

  module Code :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Contract_repr.t
       and type value = Script_repr.lazy_expr
       and type t := Raw_context.t

  module Storage :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Contract_repr.t
       and type value = Script_repr.lazy_expr
       and type t := Raw_context.t

  (** Current storage space in bytes.
      Includes code, global storage and big map elements. *)
  module Used_storage_space :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t

  (** Maximal space available without needing to burn new fees. *)
  module Paid_storage_space :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t
end

module Big_map : sig
  module Next : sig
    val incr : Raw_context.t -&gt; (Raw_context.t * Z.t) tzresult Lwt.t

    val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t
  end

  (** The domain of alive big maps *)
  val fold : Raw_context.t -&gt; init:'a -&gt; f:(Z.t -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val list : Raw_context.t -&gt; Z.t list Lwt.t

  val remove_rec : Raw_context.t -&gt; Z.t -&gt; Raw_context.t Lwt.t

  val copy :
    Raw_context.t -&gt; from:Z.t -&gt; to_:Z.t -&gt; Raw_context.t tzresult Lwt.t

  type key = Raw_context.t * Z.t

  val rpc_arg : Z.t RPC_arg.t

  module Contents :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Script_expr_hash.t
       and type value = Script_repr.expr
       and type t := key

  module Total_bytes :
    Indexed_data_storage
      with type key = Z.t
       and type value = Z.t
       and type t := Raw_context.t

  module Key_type :
    Indexed_data_storage
      with type key = Z.t
       and type value = Script_repr.expr
       and type t := Raw_context.t

  module Value_type :
    Indexed_data_storage
      with type key = Z.t
       and type value = Script_repr.expr
       and type t := Raw_context.t
end

(** Set of all registered delegates. *)
module Delegates :
  Data_set_storage
    with type t := Raw_context.t
     and type elt = Signature.Public_key_hash.t

(** Set of all active delegates with rolls. *)
module Active_delegates_with_rolls :
  Data_set_storage
    with type t := Raw_context.t
     and type elt = Signature.Public_key_hash.t

(** Set of all the delegates with frozen rewards/bonds/fees for a given cycle. *)
module Delegates_with_frozen_balance :
  Data_set_storage
    with type t = Raw_context.t * Cycle_repr.t
     and type elt = Signature.Public_key_hash.t

(** Votes *)

module Vote : sig
  module Current_period_kind :
    Single_data_storage
      with type value = Voting_period_repr.kind
       and type t := Raw_context.t

  (** Participation exponential moving average, in centile of percentage *)
  module Participation_ema :
    Single_data_storage with type value = int32 and type t := Raw_context.t

  module Current_proposal :
    Single_data_storage
      with type value = Protocol_hash.t
       and type t := Raw_context.t

  (** Sum of all rolls of all delegates. *)
  module Listings_size :
    Single_data_storage with type value = int32 and type t := Raw_context.t

  (** Contains all delegates with their assigned number of rolls. *)
  module Listings :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = int32
       and type t := Raw_context.t

  (** Set of protocol proposal with corresponding proposer delegate *)
  module Proposals :
    Data_set_storage
      with type elt = Protocol_hash.t * Signature.Public_key_hash.t
       and type t := Raw_context.t

  (** Keeps for each delegate the number of proposed protocols *)
  module Proposals_count :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = int
       and type t := Raw_context.t

  (** Contains for each delegate its ballot *)
  module Ballots :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Vote_repr.ballot
       and type t := Raw_context.t
end

(** Seed *)

module Seed : sig
  (** Storage from this submodule must only be accessed through the
      module `Seed`. *)

  type unrevealed_nonce = {
    nonce_hash : Nonce_hash.t;
    delegate : Signature.Public_key_hash.t;
    rewards : Tez_repr.t;
    fees : Tez_repr.t;
  }

  type nonce_status =
    | Unrevealed of unrevealed_nonce
    | Revealed of Seed_repr.nonce

  module Nonce :
    Non_iterable_indexed_data_storage
      with type key := Level_repr.t
       and type value := nonce_status
       and type t := Raw_context.t

  module For_cycle : sig
    val init :
      Raw_context.t -&gt;
      Cycle_repr.t -&gt;
      Seed_repr.seed -&gt;
      Raw_context.t tzresult Lwt.t

    val get : Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed tzresult Lwt.t

    val delete : Raw_context.t -&gt; Cycle_repr.t -&gt; Raw_context.t tzresult Lwt.t
  end
end

(** Commitments *)

module Commitments :
  Indexed_data_storage
    with type key = Blinded_public_key_hash.t
     and type value = Tez_repr.t
     and type t := Raw_context.t

(** Ramp up security deposits... *)

module Ramp_up : sig
  module Rewards :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t * Tez_repr.t
      (* baking * endorsement *)
       and type t := Raw_context.t

  module Security_deposits :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t * Tez_repr.t
      (* baking * endorsement *)
       and type t := Raw_context.t
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage.mli"><code>Storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Module Block_priority.
  Parameter get : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Z).
  
  Parameter set :
    Raw_context.t -&gt; Z -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter init :
    Raw_context.t -&gt; Z -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
End Block_priority.

Module Roll.
  Parameter Owner :
    {_ : unit &amp;
      Indexed_data_snapshotable_storage.signature (Cycle_repr.t * Z) Roll_repr.t
        Raw_context.t Signature.Public_key.[S.SPublic_key.t]}.
  
  Parameter clear : Raw_context.t -&gt; Lwt.t Raw_context.t.
  
  Parameter Next :
    {_ : unit &amp; Single_data_storage.signature Raw_context.t Roll_repr.t}.
  
  Parameter Limbo :
    {_ : unit &amp; Single_data_storage.signature Raw_context.t Roll_repr.t}.
  
  Parameter Delegate_roll_list :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t
        Signature.Public_key_hash.[S.SPublic_key_hash.t] Roll_repr.t}.
  
  Parameter Successor :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Roll_repr.t Roll_repr.t}.
  
  Parameter Delegate_change :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t
        Signature.Public_key_hash.[S.SPublic_key_hash.t] Tez_repr.t}.
  
  Parameter Snapshot_for_cycle :
    {_ : unit &amp; Indexed_data_storage.signature Raw_context.t Cycle_repr.t Z}.
  
  Parameter Last_for_snapshot :
    {_ : unit &amp;
      Indexed_data_storage.signature (Raw_context.t * Cycle_repr.t) Z
        Roll_repr.t}.
End Roll.

Module Contract.
  Module Global_counter.
    Parameter get : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Z.t).
    
    Parameter set :
      Raw_context.t -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
    
    Parameter init :
      Raw_context.t -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  End Global_counter.
  
  Parameter fold : forall {a : Set},
    Raw_context.t -&gt; a -&gt; (Contract_repr.t -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter __list_value : Raw_context.t -&gt; Lwt.t (list Contract_repr.t).
  
  Parameter Balance :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Contract_repr.t Tez_repr.t}.
  
  Parameter Frozen_deposits :
    {_ : unit &amp;
      Indexed_data_storage.signature (Raw_context.t * Contract_repr.t)
        Cycle_repr.t Tez_repr.t}.
  
  Parameter Frozen_fees :
    {_ : unit &amp;
      Indexed_data_storage.signature (Raw_context.t * Contract_repr.t)
        Cycle_repr.t Tez_repr.t}.
  
  Parameter Frozen_rewards :
    {_ : unit &amp;
      Indexed_data_storage.signature (Raw_context.t * Contract_repr.t)
        Cycle_repr.t Tez_repr.t}.
  
  Parameter Manager :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Contract_repr.t
        Manager_repr.[Storage_sigs.VALUE.t]}.
  
  Parameter Delegate :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Contract_repr.t
        Signature.Public_key_hash.[S.SPublic_key_hash.t]}.
  
  Parameter Delegated :
    {_ : unit &amp;
      Data_set_storage.signature (Raw_context.t * Contract_repr.t)
        Contract_repr.t}.
  
  Parameter Inactive_delegate :
    {_ : unit &amp; Data_set_storage.signature Raw_context.t Contract_repr.t}.
  
  Parameter Delegate_desactivation :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Contract_repr.t Cycle_repr.t}.
  
  Parameter Counter :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Contract_repr.t Z.t}.
  
  Parameter Code :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature Raw_context.t
        Contract_repr.t Script_repr.lazy_expr}.
  
  Parameter Storage :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature Raw_context.t
        Contract_repr.t Script_repr.lazy_expr}.
  
  Parameter Used_storage_space :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Contract_repr.t Z.t}.
  
  Parameter Paid_storage_space :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Contract_repr.t Z.t}.
End Contract.

Module Big_map.
  Module Next.
    Parameter incr :
      Raw_context.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t)).
    
    Parameter init :
      Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  End Next.
  
  Parameter fold : forall {a : Set},
    Raw_context.t -&gt; a -&gt; (Z.t -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter __list_value : Raw_context.t -&gt; Lwt.t (list Z.t).
  
  Parameter remove_rec : Raw_context.t -&gt; Z.t -&gt; Lwt.t Raw_context.t.
  
  Parameter copy :
    Raw_context.t -&gt; Z.t -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Definition key := Raw_context.t * Z.t.
  
  Parameter rpc_arg : RPC_arg.t Z.t.
  
  Parameter Contents :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature key
        Script_expr_hash.t Script_repr.expr}.
  
  Parameter Total_bytes :
    {_ : unit &amp; Indexed_data_storage.signature Raw_context.t Z.t Z.t}.
  
  Parameter Key_type :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Z.t Script_repr.expr}.
  
  Parameter Value_type :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Z.t Script_repr.expr}.
End Big_map.

Parameter Delegates :
  {_ : unit &amp;
    Data_set_storage.signature Raw_context.t
      Signature.Public_key_hash.[S.SPublic_key_hash.t]}.

Parameter Active_delegates_with_rolls :
  {_ : unit &amp;
    Data_set_storage.signature Raw_context.t
      Signature.Public_key_hash.[S.SPublic_key_hash.t]}.

Parameter Delegates_with_frozen_balance :
  {_ : unit &amp;
    Data_set_storage.signature (Raw_context.t * Cycle_repr.t)
      Signature.Public_key_hash.[S.SPublic_key_hash.t]}.

Module Vote.
  Parameter Current_period_kind :
    {_ : unit &amp;
      Single_data_storage.signature Raw_context.t Voting_period_repr.kind}.
  
  Parameter Participation_ema :
    {_ : unit &amp; Single_data_storage.signature Raw_context.t int32}.
  
  Parameter Current_proposal :
    {_ : unit &amp;
      Single_data_storage.signature Raw_context.t Protocol_hash.[S.HASH.t]}.
  
  Parameter Listings_size :
    {_ : unit &amp; Single_data_storage.signature Raw_context.t int32}.
  
  Parameter Listings :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t
        Signature.Public_key_hash.[S.SPublic_key_hash.t] int32}.
  
  Parameter Proposals :
    {_ : unit &amp;
      Data_set_storage.signature Raw_context.t
        (Protocol_hash.[S.HASH.t] *
          Signature.Public_key_hash.[S.SPublic_key_hash.t])}.
  
  Parameter Proposals_count :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t
        Signature.Public_key_hash.[S.SPublic_key_hash.t] Z}.
  
  Parameter Ballots :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t
        Signature.Public_key_hash.[S.SPublic_key_hash.t] Vote_repr.ballot}.
End Vote.

Module Seed.
  Module unrevealed_nonce.
    Record record := {
      nonce_hash : Nonce_hash.t;
      delegate : Signature.Public_key_hash.[S.SPublic_key_hash.t];
      rewards : Tez_repr.t;
      fees : Tez_repr.t }.
  End unrevealed_nonce.
  Definition unrevealed_nonce := unrevealed_nonce.record.
  
  Inductive nonce_status : Set :=
  | Unrevealed : unrevealed_nonce -&gt; nonce_status
  | Revealed : Seed_repr.nonce -&gt; nonce_status.
  
  Parameter Nonce :
    {_ : unit &amp;
      Non_iterable_indexed_data_storage.signature Raw_context.t Level_repr.t
        nonce_status}.
  
  Module For_cycle.
    Parameter init :
      Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed -&gt;
      Lwt.t (Error_monad.tzresult Raw_context.t).
    
    Parameter get :
      Raw_context.t -&gt; Cycle_repr.t -&gt;
      Lwt.t (Error_monad.tzresult Seed_repr.seed).
    
    Parameter delete :
      Raw_context.t -&gt; Cycle_repr.t -&gt;
      Lwt.t (Error_monad.tzresult Raw_context.t).
  End For_cycle.
End Seed.

Parameter Commitments :
  {_ : unit &amp;
    Indexed_data_storage.signature Raw_context.t Blinded_public_key_hash.t
      Tez_repr.t}.

Module Ramp_up.
  Parameter Rewards :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Cycle_repr.t
        (Tez_repr.t * Tez_repr.t)}.
  
  Parameter Security_deposits :
    {_ : unit &amp;
      Indexed_data_storage.signature Raw_context.t Cycle_repr.t
        (Tez_repr.t * Tez_repr.t)}.
End Ramp_up.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_description.ml">
  <div class="col-md-6">
    <a href="#storage_description.ml"><code>storage_description.ml</code></a>&nbsp;<span class="label label-danger">8 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module StringMap = Map.Make (String)

type 'key description =
  | Empty : 'key description
  | Value : {
      get : 'key -&gt; 'a option tzresult Lwt.t;
      encoding : 'a Data_encoding.t;
    }
      -&gt; 'key description
  | NamedDir : 'key t StringMap.t -&gt; 'key description
  | IndexedDir : {
      arg : 'a RPC_arg.t;
      arg_encoding : 'a Data_encoding.t;
      list : 'key -&gt; 'a list tzresult Lwt.t;
      subdir : ('key * 'a) t;
    }
      -&gt; 'key description

and 'key t = 'key description ref

let rec register_named_subcontext : type r. r t -&gt; string list -&gt; r t =
 fun dir names -&gt;
  match (!dir, names) with
  | (_, []) -&gt;
      dir
  | (Value _, _) -&gt;
      invalid_arg &quot;&quot;
  | (IndexedDir _, _) -&gt;
      invalid_arg &quot;&quot;
  | (Empty, name :: names) -&gt;
      let subdir = ref Empty in
      <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">dir := NamedDir (StringMap.singleton name subdir) ;
      register_named_subcontext subdir names</abbr>
  | (NamedDir map, name :: names) -&gt;
      let subdir =
        match StringMap.find_opt name map with
        | Some subdir -&gt;
            subdir
        | None -&gt;
            let subdir = ref Empty in
            <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">dir := NamedDir (StringMap.add name subdir map) ;
            subdir</abbr>
      in
      register_named_subcontext subdir names

type (_, _, _) args =
  | One : {
      rpc_arg : 'a RPC_arg.t;
      encoding : 'a Data_encoding.t;
      compare : 'a -&gt; 'a -&gt; int;
    }
      -&gt; ('key, 'a, 'key * 'a) args
  | Pair :
      ('key, 'a, 'inter_key) args * ('inter_key, 'b, 'sub_key) args
      -&gt; ('key, 'a * 'b, 'sub_key) args

let rec unpack : type a b c. (a, b, c) args -&gt; c -&gt; a * b = function
  | One _ -&gt;
      fun x -&gt; x
  | Pair (l, r) -&gt;
      let unpack_l = unpack l in
      let unpack_r = unpack r in
      fun x -&gt;
        let (c, d) = unpack_r x in
        let (b, a) = unpack_l c in
        (b, (a, d))

let rec pack : type a b c. (a, b, c) args -&gt; a -&gt; b -&gt; c = function
  | One _ -&gt;
      fun b a -&gt; (b, a)
  | Pair (l, r) -&gt;
      let pack_l = pack l in
      let pack_r = pack r in
      fun b (a, d) -&gt;
        let c = pack_l b a in
        pack_r c d

let rec compare : type a b c. (a, b, c) args -&gt; b -&gt; b -&gt; int = function
  | One {compare; _} -&gt;
      compare
  | Pair (l, r) -&gt; (
      let compare_l = compare l in
      let compare_r = compare r in
      fun (a1, b1) (a2, b2) -&gt;
        match compare_l a1 a2 with 0 -&gt; compare_r b1 b2 | x -&gt; x )

let destutter equal l =
  match l with
  | [] -&gt;
      []
  | (i, _) :: l -&gt;
      let rec loop acc i = function
        | [] -&gt;
            acc
        | (j, _) :: l -&gt;
            if equal i j then loop acc i l else loop (j :: acc) j l
      in
      loop [i] i l

let rec register_indexed_subcontext :
    type r a b.
    r t -&gt; list:(r -&gt; a list tzresult Lwt.t) -&gt; (r, a, b) args -&gt; b t =
 fun dir ~list path -&gt;
  match path with
  | Pair (left, right) -&gt;
      let compare_left = compare left in
      let equal_left x y = Compare.Int.(compare_left x y = 0) in
      let list_left r = list r &gt;&gt;=? fun l -&gt; return (destutter equal_left l) in
      let list_right r =
        let (a, k) = unpack left r in
        list a
        &gt;&gt;=? fun l -&gt;
        return (List.map snd (List.filter (fun (x, _) -&gt; equal_left x k) l))
      in
      register_indexed_subcontext
        (register_indexed_subcontext dir ~list:list_left left)
        ~list:list_right
        right
  | One {rpc_arg = arg; encoding = arg_encoding; _} -&gt; (
    match !dir with
    | Value _ -&gt;
        invalid_arg &quot;&quot;
    | NamedDir _ -&gt;
        invalid_arg &quot;&quot;
    | Empty -&gt;
        let subdir = ref Empty in
        <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">dir := IndexedDir {arg; arg_encoding; list; subdir} ;
        subdir</abbr>
    | IndexedDir {arg = inner_arg; subdir; _} -&gt; (
      match RPC_arg.eq arg inner_arg with
      | None -&gt;
          invalid_arg &quot;&quot;
      | Some RPC_arg.Eq -&gt;
          subdir ) )

let register_value :
    type a b.
    a t -&gt; get:(a -&gt; b option tzresult Lwt.t) -&gt; b Data_encoding.t -&gt; unit =
 fun dir ~get encoding -&gt;
  match !dir with Empty -&gt; dir := Value {get; encoding} | _ -&gt; invalid_arg &quot;&quot;

let create () = ref Empty

let rec pp : type a. Format.formatter -&gt; a t -&gt; unit =
 fun ppf dir -&gt;
  match !dir with
  | Empty -&gt;
      Format.fprintf ppf &quot;EMPTY&quot;
  | Value _e -&gt;
      Format.fprintf ppf &quot;Value&quot;
  | NamedDir map -&gt;
      Format.fprintf
        ppf
        &quot;@[&lt;v&gt;%a@]&quot;
        (Format.pp_print_list pp_item)
        (StringMap.bindings map)
  | IndexedDir {arg; subdir; _} -&gt;
      let name = Format.asprintf &quot;&lt;%s&gt;&quot; (RPC_arg.descr arg).name in
      pp_item ppf (name, subdir)

and pp_item : type a. Format.formatter -&gt; string * a t -&gt; unit =
 fun ppf (name, dir) -&gt; Format.fprintf ppf &quot;@[&lt;v 2&gt;%s@ %a@]&quot; name pp dir

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  val rpc_arg : t RPC_arg.t

  val encoding : t Data_encoding.t

  val compare : t -&gt; t -&gt; int
end

type _ handler =
  | Handler : {
      encoding : 'a Data_encoding.t;
      get : 'key -&gt; int -&gt; 'a tzresult Lwt.t;
    }
      -&gt; 'key handler

type _ opt_handler =
  | Opt_handler : {
      encoding : 'a Data_encoding.t;
      get : 'key -&gt; int -&gt; 'a option tzresult Lwt.t;
    }
      -&gt; 'key opt_handler

let rec combine_object = function
  | [] -&gt;
      Handler {encoding = Data_encoding.unit; get = (fun _ _ -&gt; return_unit)}
  | (name, Opt_handler handler) :: fields -&gt;
      let (Handler handlers) = combine_object fields in
      Handler
        {
          encoding =
            Data_encoding.merge_objs
              Data_encoding.(obj1 (opt name (dynamic_size handler.encoding)))
              handlers.encoding;
          get =
            (fun k i -&gt;
              handler.get k i
              &gt;&gt;=? fun v1 -&gt; handlers.get k i &gt;&gt;=? fun v2 -&gt; return (v1, v2));
        }

type query = {depth : int}

let depth_query =
  let open RPC_query in
  query (fun depth -&gt; {depth})
  |+ field &quot;depth&quot; RPC_arg.int 0 (fun t -&gt; t.depth)
  |&gt; seal

let build_directory : type key. key t -&gt; key RPC_directory.t =
 fun dir -&gt;
  let rpc_dir = ref (RPC_directory.empty : key RPC_directory.t) in
  let register : type ikey. (key, ikey) RPC_path.t -&gt; ikey opt_handler -&gt; unit
      =
   fun path (Opt_handler {encoding; get}) -&gt;
    let service =
      RPC_service.get_service ~query:depth_query ~output:encoding path
    in
    rpc_dir :=
      RPC_directory.register !rpc_dir service (fun k q () -&gt;
          get k (q.depth + 1)
          &gt;&gt;=? function None -&gt; raise <abbr class="mark-error" title="Values of extensible types are not handled">Not_found</abbr> | Some x -&gt; return x)
  in
  let rec build_handler :
      type ikey. ikey t -&gt; (key, ikey) RPC_path.t -&gt; ikey opt_handler =
   fun dir path -&gt;
    match !dir with
    | Empty -&gt;
        Opt_handler
          {encoding = Data_encoding.unit; get = (fun _ _ -&gt; return_none)}
    | Value {get; encoding} -&gt;
        let handler =
          Opt_handler
            {
              encoding;
              get =
                (fun k i -&gt; if Compare.Int.(i &lt; 0) then return_none else get k);
            }
        in
        <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register path handler ; handler</abbr>
    | NamedDir map -&gt;
        let fields = StringMap.bindings map in
        let fields =
          List.map
            (fun (name, dir) -&gt;
              (name, build_handler dir RPC_path.(path / name)))
            fields
        in
        let (Handler handler) = combine_object fields in
        let handler =
          Opt_handler
            {
              encoding = handler.encoding;
              get =
                (fun k i -&gt;
                  if Compare.Int.(i &lt; 0) then return_none
                  else handler.get k (i - 1) &gt;&gt;=? fun v -&gt; return_some v);
            }
        in
        <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register path handler ; handler</abbr>
    | IndexedDir {arg; arg_encoding; list; subdir} -&gt;
        let (Opt_handler handler) =
          build_handler subdir RPC_path.(path /: arg)
        in
        let encoding =
          let open Data_encoding in
          union
            [ case
                (Tag 0)
                ~title:&quot;Leaf&quot;
                (dynamic_size arg_encoding)
                (function (key, None) -&gt; Some key | _ -&gt; None)
                (fun key -&gt; (key, None));
              case
                (Tag 1)
                ~title:&quot;Dir&quot;
                (tup2
                   (dynamic_size arg_encoding)
                   (dynamic_size handler.encoding))
                (function (key, Some value) -&gt; Some (key, value) | _ -&gt; None)
                (fun (key, value) -&gt; (key, Some value)) ]
        in
        let get k i =
          if Compare.Int.(i &lt; 0) then return_none
          else if Compare.Int.(i = 0) then return_some []
          else
            list k
            &gt;&gt;=? fun keys -&gt;
            map_s
              (fun key -&gt;
                if Compare.Int.(i = 1) then return (key, None)
                else
                  handler.get (k, key) (i - 1)
                  &gt;&gt;=? fun value -&gt; return (key, value))
              keys
            &gt;&gt;=? fun values -&gt; return_some values
        in
        let handler =
          Opt_handler
            {encoding = Data_encoding.(list (dynamic_size encoding)); get}
        in
        <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register path handler ; handler</abbr>
  in
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">ignore (build_handler dir RPC_path.open_root : key opt_handler) ;
  !rpc_dir</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_description.ml"><code>Storage_description.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition StringMap :=
  Map.Make
    (existT _ _
      {|
        Compare.COMPARABLE.compare := String.compare
        |}).

Module description.
  Module Value.
    Record record {get encoding : Set} := {
      get : get;
      encoding : encoding }.
    Arguments record : clear implicits.
  End Value.
  Definition Value := Value.record.
  
  Module IndexedDir.
    Record record {arg arg_encoding list subdir : Set} := {
      arg : arg;
      arg_encoding : arg_encoding;
      list : list;
      subdir : subdir }.
    Arguments record : clear implicits.
  End IndexedDir.
  Definition IndexedDir := IndexedDir.record.
End description.

Reserved Notation &quot;'description&quot;.
Reserved Notation &quot;'t&quot;.

Inductive description_gadt : Set :=
| Empty : description_gadt
| Value : forall {a key : Set},
  description.Value (key -&gt; Lwt.t (Error_monad.tzresult (option a)))
    (Data_encoding.t a) -&gt; description_gadt
| NamedDir : forall {key : Set},
  StringMap.[S.MAP.t] ('t key) -&gt; description_gadt
| IndexedDir : forall {a key : Set},
  description.IndexedDir (RPC_arg.t a) (Data_encoding.t a)
    (key -&gt; Lwt.t (Error_monad.tzresult (list a))) ('t (key * a)) -&gt;
  description_gadt

where &quot;'description&quot; := (fun (key : Set) =&gt; description_gadt)
and &quot;'t&quot; := (fun (key : Set) =&gt; Pervasives.ref ('description key)).

Definition description := 'description.
Definition t := 't.

Fixpoint register_named_subcontext {r : Set} (dir : t r) (names : list string)
  {struct dir} : t r :=
  match ((Pervasives.op_exclamation dir), names) with
  | (_, []) =&gt; dir
  | (Value _, _) =&gt; Pervasives.invalid_arg &quot;&quot; % string
  | (IndexedDir _, _) =&gt; Pervasives.invalid_arg &quot;&quot; % string
  | (Empty, cons name names) =&gt;
    let subdir := Pervasives.__ref_value Empty in
    (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    register_named_subcontext subdir names
  | (NamedDir map, cons name names) =&gt;
    let subdir :=
      match StringMap.[S.MAP.find_opt] name map with
      | Some subdir =&gt; subdir
      | None =&gt;
        let subdir := Pervasives.__ref_value Empty in
        (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        subdir
      end in
    register_named_subcontext subdir names
  end.

Module args.
  Module One.
    Record record {rpc_arg encoding compare : Set} := {
      rpc_arg : rpc_arg;
      encoding : encoding;
      compare : compare }.
    Arguments record : clear implicits.
  End One.
  Definition One := One.record.
End args.

Reserved Notation &quot;'args&quot;.

Inductive args_gadt : Set :=
| One : forall {a : Set},
  args.One (RPC_arg.t a) (Data_encoding.t a) (a -&gt; a -&gt; Z) -&gt; args_gadt
| Pair : args_gadt -&gt; args_gadt -&gt; args_gadt

where &quot;'args&quot; := (fun (_ _ _ : Set) =&gt; args_gadt).

Definition args := 'args.

Fixpoint unpack {a b c : Set} (function_parameter : args a b c)
  {struct function_parameter} : c -&gt; a * b :=
  match function_parameter with
  | One _ =&gt; fun x =&gt; x
  | Pair l r =&gt;
    let unpack_l := unpack l in
    let unpack_r := unpack r in
    fun x =&gt;
      let '(c, d) := unpack_r x in
      let '(b, a) := unpack_l c in
      (b, (a, d))
  end.

Fixpoint pack {a b c : Set} (function_parameter : args a b c)
  {struct function_parameter} : a -&gt; b -&gt; c :=
  match function_parameter with
  | One _ =&gt; fun b =&gt; fun a =&gt; (b, a)
  | Pair l r =&gt;
    let pack_l := pack l in
    let pack_r := pack r in
    fun b =&gt;
      fun function_parameter =&gt;
        let '(a, d) := function_parameter in
        let c := pack_l b a in
        pack_r c d
  end.

Fixpoint compare {a b c : Set} (function_parameter : args a b c)
  {struct function_parameter} : b -&gt; b -&gt; Z :=
  match function_parameter with
  | One {| args.One.compare := compare |} =&gt; compare
  | Pair l r =&gt;
    let compare_l := compare l in
    let compare_r := compare r in
    fun function_parameter =&gt;
      let '(a1, b1) := function_parameter in
      fun function_parameter =&gt;
        let '(a2, b2) := function_parameter in
        match compare_l a1 a2 with
        | 0 =&gt; compare_r b1 b2
        | x =&gt; x
        end
  end.

Definition destutter {A B : Set} (equal : A -&gt; A -&gt; bool) (l : list (A * B))
  : list A :=
  match l with
  | [] =&gt; []
  | cons (i, _) l =&gt;
    let fix loop {C : Set}
      (acc : list A) (i : A) (function_parameter : list (A * C)) {struct acc}
      : list A :=
      match function_parameter with
      | [] =&gt; acc
      | cons (j, _) l =&gt;
        if equal i j then
          loop acc i l
        else
          loop (cons j acc) j l
      end in
    loop (cons i []) i l
  end.

Fixpoint register_indexed_subcontext {a b r : Set}
  (dir : t r) (__list_value : r -&gt; Lwt.t (Error_monad.tzresult (list a)))
  (path : args r a b) {struct dir} : t b :=
  match path with
  | Pair left right =&gt;
    let compare_left := compare left in
    let equal_left (x : op_dollar0) (y : op_dollar0) : bool :=
      Compare.Int.[Compare.S.op_eq] (compare_left x y) 0 in
    let list_left (r : r) : Lwt.t (Error_monad.tzresult (list op_dollar0)) :=
      Error_monad.op_gtgteqquestion (__list_value r)
        (fun l =&gt; Error_monad.__return (destutter equal_left l)) in
    let list_right (r : op_dollarPair_'inter_key)
      : Lwt.t (Error_monad.tzresult (list op_dollar1)) :=
      let '(a, k) := unpack left r in
      Error_monad.op_gtgteqquestion (__list_value a)
        (fun l =&gt;
          Error_monad.__return
            (List.map Pervasives.snd
              (List.filter
                (fun function_parameter =&gt;
                  let '(x, _) := function_parameter in
                  equal_left x k) l))) in
    register_indexed_subcontext (register_indexed_subcontext dir list_left left)
      list_right right
  | One {| args.One.rpc_arg := arg; args.One.encoding := arg_encoding |} =&gt;
    match Pervasives.op_exclamation dir with
    | Value _ =&gt; Pervasives.invalid_arg &quot;&quot; % string
    | NamedDir _ =&gt; Pervasives.invalid_arg &quot;&quot; % string
    | Empty =&gt;
      let subdir := Pervasives.__ref_value Empty in
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      subdir
    |
      IndexedDir {|
        description.IndexedDir.arg := inner_arg;
          description.IndexedDir.subdir := subdir
          |} =&gt;
      match RPC_arg.__eq_value arg inner_arg with
      | None =&gt; Pervasives.invalid_arg &quot;&quot; % string
      | Some RPC_arg.Eq =&gt; subdir
      end
    end
  end.

Definition register_value {a b : Set}
  (dir : t a) (get : a -&gt; Lwt.t (Error_monad.tzresult (option b)))
  (encoding : Data_encoding.t b) : unit :=
  match Pervasives.op_exclamation dir with
  | Empty =&gt;
    Pervasives.op_coloneq dir
      (Value
        {| description.Value.get := get; description.Value.encoding := encoding
          |})
  | _ =&gt; Pervasives.invalid_arg &quot;&quot; % string
  end.

Definition create {A : Set} (function_parameter : unit)
  : Pervasives.ref (description A) :=
  let 'tt := function_parameter in
  Pervasives.__ref_value Empty.

Fixpoint pp {a : Set} (ppf : Format.formatter) (dir : t a) {struct ppf}
  : unit :=
  match Pervasives.op_exclamation dir with
  | Empty =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;EMPTY&quot; % string
          CamlinternalFormatBasics.End_of_format) &quot;EMPTY&quot; % string)
  | Value _e =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Value&quot; % string
          CamlinternalFormatBasics.End_of_format) &quot;Value&quot; % string)
  | NamedDir map =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal &quot;&lt;v&gt;&quot; % string
                CamlinternalFormatBasics.End_of_format) &quot;&lt;v&gt;&quot; % string))
          (CamlinternalFormatBasics.Alpha
            (CamlinternalFormatBasics.Formatting_lit
              CamlinternalFormatBasics.Close_box
              CamlinternalFormatBasics.End_of_format))) &quot;@[&lt;v&gt;%a@]&quot; % string)
      (Format.pp_print_list None pp_item) (StringMap.[S.MAP.bindings] map)
  |
    IndexedDir {|
      description.IndexedDir.arg := arg;
        description.IndexedDir.subdir := subdir
        |} =&gt;
    let name :=
      Format.asprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;&lt;&quot; % char
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;&gt;&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;&lt;%s&gt;&quot; % string)
        (RPC_arg.descr.name (RPC_arg.__descr_value arg)) in
    pp_item ppf (name, subdir)
  end

with pp_item {a : Set}
  (ppf : Format.formatter) (function_parameter : string * t a) {struct ppf}
  : unit :=
  let '(name, dir) := function_parameter in
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Formatting_gen
        (CamlinternalFormatBasics.Open_box
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;&lt;v 2&gt;&quot; % string
              CamlinternalFormatBasics.End_of_format) &quot;&lt;v 2&gt;&quot; % string))
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.Formatting_lit
            (CamlinternalFormatBasics.Break &quot;@ &quot; % string 1 0)
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format)))))
      &quot;@[&lt;v 2&gt;%s@ %a@]&quot; % string) name pp dir.

Module INDEX.
  Record signature {t : Set} := {
    t := t;
    path_length : Z;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    rpc_arg : RPC_arg.t t;
    encoding : Data_encoding.t t;
    compare : t -&gt; t -&gt; Z;
  }.
  Arguments signature : clear implicits.
End INDEX.

Module handler.
  Module Handler.
    Record record {encoding get : Set} := {
      encoding : encoding;
      get : get }.
    Arguments record : clear implicits.
  End Handler.
  Definition Handler := Handler.record.
End handler.

Reserved Notation &quot;'handler&quot;.

Inductive handler_gadt : Set :=
| Handler : forall {a key : Set},
  handler.Handler (Data_encoding.t a)
    (key -&gt; Z -&gt; Lwt.t (Error_monad.tzresult a)) -&gt; handler_gadt

where &quot;'handler&quot; := (fun (_ : Set) =&gt; handler_gadt).

Definition handler := 'handler.

Module opt_handler.
  Module Opt_handler.
    Record record {encoding get : Set} := {
      encoding : encoding;
      get : get }.
    Arguments record : clear implicits.
  End Opt_handler.
  Definition Opt_handler := Opt_handler.record.
End opt_handler.

Reserved Notation &quot;'opt_handler&quot;.

Inductive opt_handler_gadt : Set :=
| Opt_handler : forall {a key : Set},
  opt_handler.Opt_handler (Data_encoding.t a)
    (key -&gt; Z -&gt; Lwt.t (Error_monad.tzresult (option a))) -&gt; opt_handler_gadt

where &quot;'opt_handler&quot; := (fun (_ : Set) =&gt; opt_handler_gadt).

Definition opt_handler := 'opt_handler.

Fixpoint combine_object {A : Set}
  (function_parameter : list (string * opt_handler A))
  {struct function_parameter} : handler A :=
  match function_parameter with
  | [] =&gt;
    Handler
      {| handler.Handler.encoding := Data_encoding.__unit_value;
        handler.Handler.get :=
          fun function_parameter =&gt;
            let '_ := function_parameter in
            fun function_parameter =&gt;
              let '_ := function_parameter in
              Error_monad.return_unit |}
  | cons (name, Opt_handler handler) fields =&gt;
    let 'Handler handlers := combine_object fields in
    Handler
      {|
        handler.Handler.encoding :=
          Data_encoding.merge_objs
            (Data_encoding.obj1
              (Data_encoding.opt None None name
                (Data_encoding.dynamic_size None
                  (opt_handler.Opt_handler.encoding handler))))
            (handler.Handler.encoding handlers);
        handler.Handler.get :=
          fun k =&gt;
            fun i =&gt;
              Error_monad.op_gtgteqquestion
                ((opt_handler.Opt_handler.get handler) k i)
                (fun v1 =&gt;
                  Error_monad.op_gtgteqquestion
                    ((handler.Handler.get handlers) k i)
                    (fun v2 =&gt; Error_monad.__return (v1, v2))) |}
  end.

Module query.
  Record record := {
    depth : Z }.
End query.
Definition query := query.record.

Definition depth_query : RPC_query.t query :=
  Pervasives.op_pipegt
    (RPC_query.op_pipeplus
      (RPC_query.__query_value (fun depth =&gt; {| query.depth := depth |}))
      (RPC_query.__field_value None &quot;depth&quot; % string RPC_arg.int 0
        (fun t =&gt; query.depth t))) RPC_query.seal.

Definition build_directory {key : Set} (dir : t key) : RPC_directory.t key :=
  let rpc_dir := Pervasives.__ref_value RPC_directory.empty in
  let register {ikey : Set}
    (path : RPC_path.t key ikey) (function_parameter : opt_handler ikey)
    : unit :=
    let
      'Opt_handler {|
        opt_handler.Opt_handler.encoding := encoding;
          opt_handler.Opt_handler.get := get
          |} := function_parameter in
    let service := RPC_service.get_service None depth_query encoding path in
    Pervasives.op_coloneq rpc_dir
      (RPC_directory.register (Pervasives.op_exclamation rpc_dir) service
        (fun k =&gt;
          fun q =&gt;
            fun function_parameter =&gt;
              let 'tt := function_parameter in
              Error_monad.op_gtgteqquestion
                (get k (Pervasives.op_plus (query.depth q) 1))
                (fun function_parameter =&gt;
                  match function_parameter with
                  | None =&gt; Pervasives.raise extensible_type_value
                  | Some x =&gt; Error_monad.__return x
                  end))) in
  let fix build_handler {ikey : Set} (dir : t ikey) (path : RPC_path.t key ikey)
    {struct dir} : opt_handler ikey :=
    match Pervasives.op_exclamation dir with
    | Empty =&gt;
      Opt_handler
        {| opt_handler.Opt_handler.encoding := Data_encoding.__unit_value;
          opt_handler.Opt_handler.get :=
            fun function_parameter =&gt;
              let '_ := function_parameter in
              fun function_parameter =&gt;
                let '_ := function_parameter in
                Error_monad.return_none |}
    |
      Value {|
        description.Value.get := get;
          description.Value.encoding := encoding
          |} =&gt;
      let handler :=
        Opt_handler
          {| opt_handler.Opt_handler.encoding := encoding;
            opt_handler.Opt_handler.get :=
              fun k =&gt;
                fun i =&gt;
                  if Compare.Int.[Compare.S.op_lt] i 0 then
                    Error_monad.return_none
                  else
                    get k |} in
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      handler
    | NamedDir map =&gt;
      let fields := StringMap.[S.MAP.bindings] map in
      let fields :=
        List.map
          (fun function_parameter =&gt;
            let '(name, dir) := function_parameter in
            (name, (build_handler dir (RPC_path.op_div path name)))) fields in
      let 'Handler handler := combine_object fields in
      let handler :=
        Opt_handler
          {|
            opt_handler.Opt_handler.encoding := handler.Handler.encoding handler;
            opt_handler.Opt_handler.get :=
              fun k =&gt;
                fun i =&gt;
                  if Compare.Int.[Compare.S.op_lt] i 0 then
                    Error_monad.return_none
                  else
                    Error_monad.op_gtgteqquestion
                      ((handler.Handler.get handler) k (Pervasives.op_minus i 1))
                      (fun v =&gt; Error_monad.return_some v) |} in
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      handler
    |
      IndexedDir {|
        description.IndexedDir.arg := arg;
          description.IndexedDir.arg_encoding := arg_encoding;
          description.IndexedDir.list := __list_value;
          description.IndexedDir.subdir := subdir
          |} =&gt;
      let 'Opt_handler handler :=
        build_handler subdir (RPC_path.op_divcolon path arg) in
      let encoding :=
        Data_encoding.union None
          (cons
            (Data_encoding.__case_value &quot;Leaf&quot; % string None
              (Data_encoding.Tag 0)
              (Data_encoding.dynamic_size None arg_encoding)
              (fun function_parameter =&gt;
                match function_parameter with
                | (key, None) =&gt; Some key
                | _ =&gt; None
                end) (fun key =&gt; (key, None)))
            (cons
              (Data_encoding.__case_value &quot;Dir&quot; % string None
                (Data_encoding.Tag 1)
                (Data_encoding.tup2
                  (Data_encoding.dynamic_size None arg_encoding)
                  (Data_encoding.dynamic_size None
                    (opt_handler.Opt_handler.encoding handler)))
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (key, Some value) =&gt; Some (key, value)
                  | _ =&gt; None
                  end)
                (fun function_parameter =&gt;
                  let '(key, value) := function_parameter in
                  (key, (Some value)))) [])) in
      let get (k : ikey) (i : Compare.Int.[Compare.S.t])
        : Lwt.t
          (Error_monad.tzresult
            (option
              (list (op_dollarIndexedDir_'a * option op_dollarOpt_handler_'a1)))) :=
        if Compare.Int.[Compare.S.op_lt] i 0 then
          Error_monad.return_none
        else
          if Compare.Int.[Compare.S.op_eq] i 0 then
            Error_monad.return_some []
          else
            Error_monad.op_gtgteqquestion (__list_value k)
              (fun keys =&gt;
                Error_monad.op_gtgteqquestion
                  (Error_monad.map_s
                    (fun key =&gt;
                      if Compare.Int.[Compare.S.op_eq] i 1 then
                        Error_monad.__return (key, None)
                      else
                        Error_monad.op_gtgteqquestion
                          ((opt_handler.Opt_handler.get handler) (k, key)
                            (Pervasives.op_minus i 1))
                          (fun value =&gt; Error_monad.__return (key, value))) keys)
                  (fun values =&gt; Error_monad.return_some values)) in
      let handler :=
        Opt_handler
          {|
            opt_handler.Opt_handler.encoding :=
              Data_encoding.__list_value None
                (Data_encoding.dynamic_size None encoding);
            opt_handler.Opt_handler.get := get |} in
      (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      handler
    end in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Pervasives.op_exclamation rpc_dir.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_description.mli">
  <div class="col-md-6">
    <a href="#storage_description.mli"><code>storage_description.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Typed description of the key-value context. *)
type 'key t

(** Trivial display of the key-value context layout. *)
val pp : Format.formatter -&gt; 'key t -&gt; unit

(** Export an RPC hierarchy for querying the context. There is one service
    by possible path in the context. Services for &quot;directory&quot; are able to
    aggregate in one JSON object the whole subtree. *)
val build_directory : 'key t -&gt; 'key RPC_directory.t

(** Create a empty context description,
    keys will be registred by side effects. *)
val create : unit -&gt; 'key t

(** Register a single key accessor at a given path. *)
val register_value :
  'key t -&gt;
  get:('key -&gt; 'a option tzresult Lwt.t) -&gt;
  'a Data_encoding.t -&gt;
  unit

(** Return a description for a prefixed fragment of the given context.
    All keys registred in the subcontext will be shared by the external
    context *)
val register_named_subcontext : 'key t -&gt; string list -&gt; 'key t

(** Description of an index as a sequence of `RPC_arg.t`. *)
type (_, _, _) args =
  | One : {
      rpc_arg : 'a RPC_arg.t;
      encoding : 'a Data_encoding.t;
      compare : 'a -&gt; 'a -&gt; int;
    }
      -&gt; ('key, 'a, 'key * 'a) args
  | Pair :
      ('key, 'a, 'inter_key) args * ('inter_key, 'b, 'sub_key) args
      -&gt; ('key, 'a * 'b, 'sub_key) args

(** Return a description for a indexed sub-context.
    All keys registred in the subcontext will be shared by the external
    context. One should provide a function to list all the registred
    index in the context. *)
val register_indexed_subcontext :
  'key t -&gt;
  list:('key -&gt; 'arg list tzresult Lwt.t) -&gt;
  ('key, 'arg, 'sub_key) args -&gt;
  'sub_key t

(** Helpers for manipulating and defining indexes. *)

val pack : ('key, 'a, 'sub_key) args -&gt; 'key -&gt; 'a -&gt; 'sub_key

val unpack : ('key, 'a, 'sub_key) args -&gt; 'sub_key -&gt; 'key * 'a

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  val rpc_arg : t RPC_arg.t

  val encoding : t Data_encoding.t

  val compare : t -&gt; t -&gt; int
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_description.mli"><code>Storage_description_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Parameter t : forall (key : Set), Set.

Parameter pp : forall {key : Set}, Format.formatter -&gt; t key -&gt; unit.

Parameter build_directory : forall {key : Set}, t key -&gt; RPC_directory.t key.

Parameter create : forall {key : Set}, unit -&gt; t key.

Parameter register_value : forall {a key : Set},
  t key -&gt; (key -&gt; Lwt.t (Error_monad.tzresult (option a))) -&gt;
  Data_encoding.t a -&gt; unit.

Parameter register_named_subcontext : forall {key : Set},
  t key -&gt; list string -&gt; t key.

Module args.
  Module One.
    Record record {rpc_arg encoding compare : Set} := {
      rpc_arg : rpc_arg;
      encoding : encoding;
      compare : compare }.
    Arguments record : clear implicits.
  End One.
  Definition One := One.record.
End args.

Reserved Notation &quot;'args&quot;.

Inductive args_gadt : Set :=
| One : forall {a : Set},
  args.One (RPC_arg.t a) (Data_encoding.t a) (a -&gt; a -&gt; Z) -&gt; args_gadt
| Pair : args_gadt -&gt; args_gadt -&gt; args_gadt

where &quot;'args&quot; := (fun (_ _ _ : Set) =&gt; args_gadt).

Definition args := 'args.

Parameter register_indexed_subcontext : forall {arg key sub_key : Set},
  t key -&gt; (key -&gt; Lwt.t (Error_monad.tzresult (list arg))) -&gt;
  args key arg sub_key -&gt; t sub_key.

Parameter pack : forall {a key sub_key : Set},
  args key a sub_key -&gt; key -&gt; a -&gt; sub_key.

Parameter unpack : forall {a key sub_key : Set},
  args key a sub_key -&gt; sub_key -&gt; key * a.

Module INDEX.
  Record signature {t : Set} := {
    t := t;
    path_length : Z;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    rpc_arg : RPC_arg.t t;
    encoding : Data_encoding.t t;
    compare : t -&gt; t -&gt; Z;
  }.
  Arguments signature : clear implicits.
End INDEX.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_functors.ml">
  <div class="col-md-6">
    <a href="#storage_functors.ml"><code>storage_functors.ml</code></a>&nbsp;<span class="label label-danger">17 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Storage_sigs

module Registered = struct
  let ghost = false
end

module Ghost = struct
  let ghost = true
end

<abbr class="mark-error" title="Functors are not handled.">module Make_encoder (V : VALUE) = struct
  let of_bytes ~key b =
    match Data_encoding.Binary.of_bytes V.encoding b with
    | None -&gt;
        error (Raw_context.Storage_error (Corrupted_data key))
    | Some v -&gt;
        Ok v

  let to_bytes v =
    match Data_encoding.Binary.to_bytes V.encoding v with
    | Some b -&gt;
        b
    | None -&gt;
        MBytes.create 0
end</abbr>

let len_name = &quot;len&quot;

let data_name = &quot;data&quot;

let encode_len_value bytes =
  let length = MBytes.length bytes in
  Data_encoding.(Binary.to_bytes_exn int31) length

let decode_len_value key len =
  match Data_encoding.(Binary.of_bytes int31) len with
  | None -&gt;
      fail <abbr class="mark-error" title="Values of extensible types are not handled">(Raw_context.Storage_error (Corrupted_data key))</abbr>
  | Some len -&gt;
      return len

let <abbr class="mark-error" title="Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">map_key</abbr> f = function <abbr class="mark-error" title="Patterns on variants are not supported">`Key k</abbr> -&gt; <abbr class="mark-error" title="Variants not supported">`Key (f k)</abbr> | <abbr class="mark-error" title="Patterns on variants are not supported">`Dir k</abbr> -&gt; <abbr class="mark-error" title="Variants not supported">`Dir (f k)</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Make_subcontext (R : REGISTER) (C : Raw_context.T) (N : NAME) :
  Raw_context.T with type t = C.t = struct
  type t = C.t

  type context = t

  let name_length = List.length N.name

  let to_key k = N.name @ k

  let of_key k = Misc.remove_elem_from_list name_length k

  let mem t k = C.mem t (to_key k)

  let dir_mem t k = C.dir_mem t (to_key k)

  let get t k = C.get t (to_key k)

  let get_option t k = C.get_option t (to_key k)

  let init t k v = C.init t (to_key k) v

  let set t k v = C.set t (to_key k) v

  let init_set t k v = C.init_set t (to_key k) v

  let set_option t k v = C.set_option t (to_key k) v

  let delete t k = C.delete t (to_key k)

  let remove t k = C.remove t (to_key k)

  let remove_rec t k = C.remove_rec t (to_key k)

  let copy t ~from ~to_ = C.copy t ~from:(to_key from) ~to_:(to_key to_)

  let fold t k ~init ~f =
    C.fold t (to_key k) ~init ~f:(fun k acc -&gt; f (map_key of_key k) acc)

  let keys t k = C.keys t (to_key k) &gt;|= fun keys -&gt; List.map of_key keys

  let fold_keys t k ~init ~f =
    C.fold_keys t (to_key k) ~init ~f:(fun k acc -&gt; f (of_key k) acc)

  let project = C.project

  let absolute_key c k = C.absolute_key c (to_key k)

  let consume_gas = C.consume_gas

  let check_enough_gas = C.check_enough_gas

  let description =
    let description =
      if R.ghost then Storage_description.create () else C.description
    in
    Storage_description.register_named_subcontext description N.name
end</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Make_single_data_storage
    (R : REGISTER)
    (C : Raw_context.T)
    (N : NAME)
    (V : VALUE) : Single_data_storage with type t = C.t and type value = V.t =
struct
  type t = C.t

  type context = t

  type value = V.t

  let mem t = C.mem t N.name

  include Make_encoder (V)

  let get t =
    C.get t N.name
    &gt;&gt;=? fun b -&gt;
    let key = C.absolute_key t N.name in
    Lwt.return (of_bytes ~key b)

  let get_option t =
    C.get_option t N.name
    &gt;&gt;= function
    | None -&gt;
        return_none
    | Some b -&gt; (
        let key = C.absolute_key t N.name in
        match of_bytes ~key b with
        | Ok v -&gt;
            return_some v
        | Error _ as err -&gt;
            Lwt.return err )

  let init t v =
    C.init t N.name (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let set t v = C.set t N.name (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let init_set t v =
    C.init_set t N.name (to_bytes v) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let set_option t v =
    C.set_option t N.name (Option.map ~f:to_bytes v)
    &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let remove t = C.remove t N.name &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let delete t = C.delete t N.name &gt;&gt;=? fun t -&gt; return (C.project t)

  let () =
    let open Storage_description in
    let description =
      if R.ghost then Storage_description.create () else C.description
    in
    register_value
      ~get:get_option
      (register_named_subcontext description N.name)
      V.encoding
end</abbr>

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  type 'a ipath

  val args : ('a, t, 'a ipath) Storage_description.args
end

<abbr class="mark-error" title="Functors are not handled.">module Pair (I1 : INDEX) (I2 : INDEX) : INDEX with type t = I1.t * I2.t =
struct
  type t = I1.t * I2.t

  let path_length = I1.path_length + I2.path_length

  let to_path (x, y) l = I1.to_path x (I2.to_path y l)

  let of_path l =
    match Misc.take I1.path_length l with
    | None -&gt;
        None
    | Some (l1, l2) -&gt; (
      match (I1.of_path l1, I2.of_path l2) with
      | (Some x, Some y) -&gt;
          Some (x, y)
      | _ -&gt;
          None )

  type 'a ipath = 'a I1.ipath I2.ipath

  let args = Storage_description.Pair (I1.args, I2.args)
end</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Make_data_set_storage (C : Raw_context.T) (I : INDEX) :
  Data_set_storage with type t = C.t and type elt = I.t = struct
  type t = C.t

  type context = t

  type elt = I.t

  let inited = MBytes.of_string &quot;inited&quot;

  let mem s i = C.mem s (I.to_path i [])

  let add s i =
    C.init_set s (I.to_path i []) inited &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let del s i =
    C.remove s (I.to_path i []) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let set s i = function true -&gt; add s i | false -&gt; del s i

  let clear s = C.remove_rec s [] &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let fold s ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 1) then
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir _ -&gt;
                Lwt.return acc
            | `Key file -&gt; (
              match I.of_path file with
              | None -&gt;
                  assert false
              | Some p -&gt;
                  f p acc ))
      else
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let elements s = fold s ~init:[] ~f:(fun p acc -&gt; Lwt.return (p :: acc))

  let () =
    let open Storage_description in
    let unpack = unpack I.args in
    register_value (* TODO fixme 'elements...' *)
      ~get:(fun c -&gt;
        let (c, k) = unpack c in
        mem c k &gt;&gt;= function true -&gt; return_some true | false -&gt; return_none)
      (register_indexed_subcontext
         ~list:(fun c -&gt; elements c &gt;&gt;= return)
         C.description
         I.args)
      Data_encoding.bool
end</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Make_indexed_data_storage (C : Raw_context.T) (I : INDEX) (V : VALUE) :
  Indexed_data_storage
    with type t = C.t
     and type key = I.t
     and type value = V.t = struct
  type t = C.t

  type context = t

  type key = I.t

  type value = V.t

  include Make_encoder (V)

  let mem s i = C.mem s (I.to_path i [])

  let get s i =
    C.get s (I.to_path i [])
    &gt;&gt;=? fun b -&gt;
    let key = C.absolute_key s (I.to_path i []) in
    Lwt.return (of_bytes ~key b)

  let get_option s i =
    C.get_option s (I.to_path i [])
    &gt;&gt;= function
    | None -&gt;
        return_none
    | Some b -&gt; (
        let key = C.absolute_key s (I.to_path i []) in
        match of_bytes ~key b with
        | Ok v -&gt;
            return_some v
        | Error _ as err -&gt;
            Lwt.return err )

  let set s i v =
    C.set s (I.to_path i []) (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let init s i v =
    C.init s (I.to_path i []) (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let init_set s i v =
    C.init_set s (I.to_path i []) (to_bytes v)
    &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let set_option s i v =
    C.set_option s (I.to_path i []) (Option.map ~f:to_bytes v)
    &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let remove s i =
    C.remove s (I.to_path i []) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let delete s i =
    C.delete s (I.to_path i []) &gt;&gt;=? fun t -&gt; return (C.project t)

  let clear s = C.remove_rec s [] &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let fold_keys s ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 1) then
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir _ -&gt;
                Lwt.return acc
            | `Key file -&gt; (
              match I.of_path file with
              | None -&gt;
                  assert false
              | Some path -&gt;
                  f path acc ))
      else
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let fold s ~init ~f =
    let f path acc =
      get s path
      &gt;&gt;= function
      | Error _ -&gt;
          (* FIXME: silently ignore unparsable data *)
          Lwt.return acc
      | Ok v -&gt;
          f path v acc
    in
    fold_keys s ~init ~f

  let bindings s =
    fold s ~init:[] ~f:(fun p v acc -&gt; Lwt.return ((p, v) :: acc))

  let keys s = fold_keys s ~init:[] ~f:(fun p acc -&gt; Lwt.return (p :: acc))

  let () =
    let open Storage_description in
    let unpack = unpack I.args in
    register_value
      ~get:(fun c -&gt;
        let (c, k) = unpack c in
        get_option c k)
      (register_indexed_subcontext
         ~list:(fun c -&gt; keys c &gt;&gt;= return)
         C.description
         I.args)
      V.encoding
end</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Make_indexed_carbonated_data_storage
    (C : Raw_context.T)
    (I : INDEX)
    (V : VALUE) :
  Non_iterable_indexed_carbonated_data_storage
    with type t = C.t
     and type key = I.t
     and type value = V.t = struct
  type t = C.t

  type context = t

  type key = I.t

  type value = V.t

  include Make_encoder (V)

  let data_key i = I.to_path i [data_name]

  let len_key i = I.to_path i [len_name]

  let consume_mem_gas c =
    Lwt.return (C.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero))

  let existing_size c i =
    C.get_option c (len_key i)
    &gt;&gt;= function
    | None -&gt;
        return (0, false)
    | Some len -&gt;
        decode_len_value (len_key i) len &gt;&gt;=? fun len -&gt; return (len, true)

  let consume_read_gas get c i =
    get c (len_key i)
    &gt;&gt;=? fun len -&gt;
    decode_len_value (len_key i) len
    &gt;&gt;=? fun len -&gt;
    Lwt.return
      (C.consume_gas c (Gas_limit_repr.read_bytes_cost (Z.of_int len)))

  let consume_serialize_write_gas set c i v =
    let bytes = to_bytes v in
    let len = MBytes.length bytes in
    Lwt.return (C.consume_gas c (Gas_limit_repr.alloc_mbytes_cost len))
    &gt;&gt;=? fun c -&gt;
    Lwt.return
      (C.consume_gas c (Gas_limit_repr.write_bytes_cost (Z.of_int len)))
    &gt;&gt;=? fun c -&gt;
    set c (len_key i) (encode_len_value bytes) &gt;&gt;=? fun c -&gt; return (c, bytes)

  let consume_remove_gas del c i =
    Lwt.return (C.consume_gas c (Gas_limit_repr.write_bytes_cost Z.zero))
    &gt;&gt;=? fun c -&gt; del c (len_key i)

  let mem s i =
    consume_mem_gas s
    &gt;&gt;=? fun s -&gt;
    C.mem s (data_key i) &gt;&gt;= fun exists -&gt; return (C.project s, exists)

  let get s i =
    consume_read_gas C.get s i
    &gt;&gt;=? fun s -&gt;
    C.get s (data_key i)
    &gt;&gt;=? fun b -&gt;
    let key = C.absolute_key s (data_key i) in
    Lwt.return (of_bytes ~key b) &gt;&gt;=? fun v -&gt; return (C.project s, v)

  let get_option s i =
    consume_mem_gas s
    &gt;&gt;=? fun s -&gt;
    C.mem s (data_key i)
    &gt;&gt;= fun exists -&gt;
    if exists then get s i &gt;&gt;=? fun (s, v) -&gt; return (s, Some v)
    else return (C.project s, None)

  let set s i v =
    existing_size s i
    &gt;&gt;=? fun (prev_size, _) -&gt;
    consume_serialize_write_gas C.set s i v
    &gt;&gt;=? fun (s, bytes) -&gt;
    C.set s (data_key i) bytes
    &gt;&gt;=? fun t -&gt;
    let size_diff = MBytes.length bytes - prev_size in
    return (C.project t, size_diff)

  let init s i v =
    consume_serialize_write_gas C.init s i v
    &gt;&gt;=? fun (s, bytes) -&gt;
    C.init s (data_key i) bytes
    &gt;&gt;=? fun t -&gt;
    let size = MBytes.length bytes in
    return (C.project t, size)

  let init_set s i v =
    let init_set s i v = C.init_set s i v &gt;&gt;= return in
    existing_size s i
    &gt;&gt;=? fun (prev_size, existed) -&gt;
    consume_serialize_write_gas init_set s i v
    &gt;&gt;=? fun (s, bytes) -&gt;
    init_set s (data_key i) bytes
    &gt;&gt;=? fun t -&gt;
    let size_diff = MBytes.length bytes - prev_size in
    return (C.project t, size_diff, existed)

  let remove s i =
    let remove s i = C.remove s i &gt;&gt;= return in
    existing_size s i
    &gt;&gt;=? fun (prev_size, existed) -&gt;
    consume_remove_gas remove s i
    &gt;&gt;=? fun s -&gt;
    remove s (data_key i) &gt;&gt;=? fun t -&gt; return (C.project t, prev_size, existed)

  let delete s i =
    existing_size s i
    &gt;&gt;=? fun (prev_size, _) -&gt;
    consume_remove_gas C.delete s i
    &gt;&gt;=? fun s -&gt;
    C.delete s (data_key i) &gt;&gt;=? fun t -&gt; return (C.project t, prev_size)

  let set_option s i v =
    match v with None -&gt; remove s i | Some v -&gt; init_set s i v

  let fold_keys_unaccounted s ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 0) then
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir _ -&gt;
                Lwt.return acc
            | `Key file -&gt; (
              match List.rev file with
              | last :: _ when Compare.String.(last = len_name) -&gt;
                  Lwt.return acc
              | last :: rest when Compare.String.(last = data_name) -&gt; (
                  let file = List.rev rest in
                  match I.of_path file with
                  | None -&gt;
                      assert false
                  | Some path -&gt;
                      f path acc )
              | _ -&gt;
                  assert false ))
      else
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let keys_unaccounted s =
    fold_keys_unaccounted s ~init:[] ~f:(fun p acc -&gt; Lwt.return (p :: acc))

  let () =
    let open Storage_description in
    let unpack = unpack I.args in
    register_value (* TODO export consumed gas ?? *)
      ~get:(fun c -&gt;
        let (c, k) = unpack c in
        get_option c k &gt;&gt;=? fun (_, v) -&gt; return v)
      (register_indexed_subcontext
         ~list:(fun c -&gt; keys_unaccounted c &gt;&gt;= return)
         C.description
         I.args)
      V.encoding
end</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Make_indexed_data_snapshotable_storage
    (C : Raw_context.T)
    (Snapshot_index : INDEX)
    (I : INDEX)
    (V : VALUE) :
  Indexed_data_snapshotable_storage
    with type t = C.t
     and type snapshot = Snapshot_index.t
     and type key = I.t
     and type value = V.t = struct
  type snapshot = Snapshot_index.t

  let data_name = [&quot;current&quot;]

  let snapshot_name = [&quot;snapshot&quot;]

  module C_data =
    Make_subcontext (Registered) (C)
      (struct
        let name = data_name
      end)

  module C_snapshot =
    Make_subcontext (Registered) (C)
      (struct
        let name = snapshot_name
      end)

  include Make_indexed_data_storage (C_data) (I) (V)
  module Snapshot =
    Make_indexed_data_storage (C_snapshot) (Pair (Snapshot_index) (I)) (V)

  let snapshot_path id = snapshot_name @ Snapshot_index.to_path id []

  let snapshot_exists s id = C.dir_mem s (snapshot_path id)

  let snapshot s id =
    C.copy s ~from:data_name ~to_:(snapshot_path id)
    &gt;&gt;=? fun t -&gt; return (C.project t)

  let delete_snapshot s id =
    C.remove_rec s (snapshot_path id) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)
end</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Make_indexed_subcontext (C : Raw_context.T) (I : INDEX) :
  Indexed_raw_context
    with type t = C.t
     and type key = I.t
     and type 'a ipath = 'a I.ipath = struct
  type t = C.t

  type context = t

  type key = I.t

  type 'a ipath = 'a I.ipath

  let clear t = C.remove_rec t [] &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let fold_keys t ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 0) then
        match I.of_path path with
        | None -&gt;
            assert false
        | Some path -&gt;
            f path acc
      else
        C.fold t path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let keys t = fold_keys t ~init:[] ~f:(fun i acc -&gt; Lwt.return (i :: acc))

  let list t k = C.fold t k ~init:[] ~f:(fun k acc -&gt; Lwt.return (k :: acc))

  let remove_rec t k = C.remove_rec t (I.to_path k [])

  let copy t ~from ~to_ =
    C.copy t ~from:(I.to_path from []) ~to_:(I.to_path to_ [])

  let description =
    Storage_description.register_indexed_subcontext
      ~list:(fun c -&gt; keys c &gt;&gt;= return)
      C.description
      I.args

  let unpack = Storage_description.unpack I.args

  let pack = Storage_description.pack I.args

  module Raw_context = struct
    type t = C.t I.ipath

    type context = t

    let to_key i k = I.to_path i k

    let of_key k = Misc.remove_elem_from_list I.path_length k

    let mem c k =
      let (t, i) = unpack c in
      C.mem t (to_key i k)

    let dir_mem c k =
      let (t, i) = unpack c in
      C.dir_mem t (to_key i k)

    let get c k =
      let (t, i) = unpack c in
      C.get t (to_key i k)

    let get_option c k =
      let (t, i) = unpack c in
      C.get_option t (to_key i k)

    let init c k v =
      let (t, i) = unpack c in
      C.init t (to_key i k) v &gt;&gt;=? fun t -&gt; return (pack t i)

    let set c k v =
      let (t, i) = unpack c in
      C.set t (to_key i k) v &gt;&gt;=? fun t -&gt; return (pack t i)

    let init_set c k v =
      let (t, i) = unpack c in
      C.init_set t (to_key i k) v &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let set_option c k v =
      let (t, i) = unpack c in
      C.set_option t (to_key i k) v &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let delete c k =
      let (t, i) = unpack c in
      C.delete t (to_key i k) &gt;&gt;=? fun t -&gt; return (pack t i)

    let remove c k =
      let (t, i) = unpack c in
      C.remove t (to_key i k) &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let remove_rec c k =
      let (t, i) = unpack c in
      C.remove_rec t (to_key i k) &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let copy c ~from ~to_ =
      let (t, i) = unpack c in
      C.copy t ~from:(to_key i from) ~to_:(to_key i to_)
      &gt;&gt;=? fun t -&gt; return (pack t i)

    let fold c k ~init ~f =
      let (t, i) = unpack c in
      C.fold t (to_key i k) ~init ~f:(fun k acc -&gt; f (map_key of_key k) acc)

    let keys c k =
      let (t, i) = unpack c in
      C.keys t (to_key i k) &gt;|= fun keys -&gt; List.map of_key keys

    let fold_keys c k ~init ~f =
      let (t, i) = unpack c in
      C.fold_keys t (to_key i k) ~init ~f:(fun k acc -&gt; f (of_key k) acc)

    let project c =
      let (t, _) = unpack c in
      C.project t

    let absolute_key c k =
      let (t, i) = unpack c in
      C.absolute_key t (to_key i k)

    let consume_gas c g =
      let (t, i) = unpack c in
      C.consume_gas t g &gt;&gt;? fun t -&gt; ok (pack t i)

    let check_enough_gas c g =
      let (t, _i) = unpack c in
      C.check_enough_gas t g

    let description = description
  end

  let resolve t prefix =
    let rec loop i prefix = function
      | [] when Compare.Int.(i = I.path_length) -&gt; (
        match I.of_path prefix with
        | None -&gt;
            assert false
        | Some path -&gt;
            Lwt.return [path] )
      | [] -&gt;
          list t prefix
          &gt;&gt;= fun prefixes -&gt;
          Lwt_list.map_s
            (function `Key prefix | `Dir prefix -&gt; loop (i + 1) prefix [])
            prefixes
          &gt;|= List.flatten
      | [d] when Compare.Int.(i = I.path_length - 1) -&gt;
          if Compare.Int.(i &gt;= I.path_length) then invalid_arg &quot;IO.resolve&quot; ;
          list t prefix
          &gt;&gt;= fun prefixes -&gt;
          Lwt_list.map_s
            (function
              | `Key prefix | `Dir prefix -&gt; (
                match
                  Misc.remove_prefix ~prefix:d (List.hd (List.rev prefix))
                with
                | None -&gt;
                    Lwt.return_nil
                | Some _ -&gt;
                    loop (i + 1) prefix [] ))
            prefixes
          &gt;|= List.flatten
      | &quot;&quot; :: ds -&gt;
          list t prefix
          &gt;&gt;= fun prefixes -&gt;
          Lwt_list.map_s
            (function `Key prefix | `Dir prefix -&gt; loop (i + 1) prefix ds)
            prefixes
          &gt;|= List.flatten
      | d :: ds -&gt; (
          if Compare.Int.(i &gt;= I.path_length) then invalid_arg &quot;IO.resolve&quot; ;
          C.dir_mem t (prefix @ [d])
          &gt;&gt;= function
          | true -&gt; loop (i + 1) (prefix @ [d]) ds | false -&gt; Lwt.return_nil )
    in
    loop 0 [] prefix

  module Make_set (R : REGISTER) (N : NAME) = struct
    type t = C.t

    type context = t

    type elt = I.t

    let inited = MBytes.of_string &quot;inited&quot;

    let mem s i = Raw_context.mem (pack s i) N.name

    let add s i =
      Raw_context.init_set (pack s i) N.name inited
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let del s i =
      Raw_context.remove (pack s i) N.name
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let set s i = function true -&gt; add s i | false -&gt; del s i

    let clear s =
      fold_keys s ~init:s ~f:(fun i s -&gt;
          Raw_context.remove (pack s i) N.name
          &gt;&gt;= fun c -&gt;
          let (s, _) = unpack c in
          Lwt.return s)
      &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

    let fold s ~init ~f =
      fold_keys s ~init ~f:(fun i acc -&gt;
          mem s i &gt;&gt;= function true -&gt; f i acc | false -&gt; Lwt.return acc)

    let elements s = fold s ~init:[] ~f:(fun p acc -&gt; Lwt.return (p :: acc))

    let () =
      let open Storage_description in
      let unpack = unpack I.args in
      let description =
        if R.ghost then Storage_description.create ()
        else Raw_context.description
      in
      register_value
        ~get:(fun c -&gt;
          let (c, k) = unpack c in
          mem c k
          &gt;&gt;= function true -&gt; return_some true | false -&gt; return_none)
        (register_named_subcontext description N.name)
        Data_encoding.bool
  end

  module Make_map (N : NAME) (V : VALUE) = struct
    type t = C.t

    type context = t

    type key = I.t

    type value = V.t

    include Make_encoder (V)

    let mem s i = Raw_context.mem (pack s i) N.name

    let get s i =
      Raw_context.get (pack s i) N.name
      &gt;&gt;=? fun b -&gt;
      let key = Raw_context.absolute_key (pack s i) N.name in
      Lwt.return (of_bytes ~key b)

    let get_option s i =
      Raw_context.get_option (pack s i) N.name
      &gt;&gt;= function
      | None -&gt;
          return_none
      | Some b -&gt; (
          let key = Raw_context.absolute_key (pack s i) N.name in
          match of_bytes ~key b with
          | Ok v -&gt;
              return_some v
          | Error _ as err -&gt;
              Lwt.return err )

    let set s i v =
      Raw_context.set (pack s i) N.name (to_bytes v)
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      return (C.project s)

    let init s i v =
      Raw_context.init (pack s i) N.name (to_bytes v)
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      return (C.project s)

    let init_set s i v =
      Raw_context.init_set (pack s i) N.name (to_bytes v)
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let set_option s i v =
      Raw_context.set_option (pack s i) N.name (Option.map ~f:to_bytes v)
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let remove s i =
      Raw_context.remove (pack s i) N.name
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let delete s i =
      Raw_context.delete (pack s i) N.name
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      return (C.project s)

    let clear s =
      fold_keys s ~init:s ~f:(fun i s -&gt;
          Raw_context.remove (pack s i) N.name
          &gt;&gt;= fun c -&gt;
          let (s, _) = unpack c in
          Lwt.return s)
      &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

    let fold s ~init ~f =
      fold_keys s ~init ~f:(fun i acc -&gt;
          get s i &gt;&gt;= function Error _ -&gt; Lwt.return acc | Ok v -&gt; f i v acc)

    let bindings s =
      fold s ~init:[] ~f:(fun p v acc -&gt; Lwt.return ((p, v) :: acc))

    let fold_keys s ~init ~f =
      fold_keys s ~init ~f:(fun i acc -&gt;
          mem s i &gt;&gt;= function false -&gt; Lwt.return acc | true -&gt; f i acc)

    let keys s = fold_keys s ~init:[] ~f:(fun p acc -&gt; Lwt.return (p :: acc))

    let () =
      let open Storage_description in
      let unpack = unpack I.args in
      register_value
        ~get:(fun c -&gt;
          let (c, k) = unpack c in
          get_option c k)
        (register_named_subcontext Raw_context.description N.name)
        V.encoding
  end

  module Make_carbonated_map (N : NAME) (V : VALUE) = struct
    type t = C.t

    type context = t

    type key = I.t

    type value = V.t

    include Make_encoder (V)

    let len_name = len_name :: N.name

    let data_name = data_name :: N.name

    let consume_mem_gas c =
      Lwt.return
        (Raw_context.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero))

    let existing_size c =
      Raw_context.get_option c len_name
      &gt;&gt;= function
      | None -&gt;
          return (0, false)
      | Some len -&gt;
          decode_len_value len_name len &gt;&gt;=? fun len -&gt; return (len, true)

    let consume_read_gas get c =
      get c len_name
      &gt;&gt;=? fun len -&gt;
      decode_len_value len_name len
      &gt;&gt;=? fun len -&gt;
      Lwt.return
        (Raw_context.consume_gas
           c
           (Gas_limit_repr.read_bytes_cost (Z.of_int len)))

    let consume_write_gas set c v =
      let bytes = to_bytes v in
      let len = MBytes.length bytes in
      Lwt.return
        (Raw_context.consume_gas
           c
           (Gas_limit_repr.write_bytes_cost (Z.of_int len)))
      &gt;&gt;=? fun c -&gt;
      set c len_name (encode_len_value bytes) &gt;&gt;=? fun c -&gt; return (c, bytes)

    let consume_remove_gas del c =
      Lwt.return
        (Raw_context.consume_gas c (Gas_limit_repr.write_bytes_cost Z.zero))
      &gt;&gt;=? fun c -&gt; del c len_name

    let mem s i =
      consume_mem_gas (pack s i)
      &gt;&gt;=? fun c -&gt;
      Raw_context.mem c data_name
      &gt;&gt;= fun res -&gt; return (Raw_context.project c, res)

    let get s i =
      consume_read_gas Raw_context.get (pack s i)
      &gt;&gt;=? fun c -&gt;
      Raw_context.get c data_name
      &gt;&gt;=? fun b -&gt;
      let key = Raw_context.absolute_key c data_name in
      Lwt.return (of_bytes ~key b)
      &gt;&gt;=? fun v -&gt; return (Raw_context.project c, v)

    let get_option s i =
      consume_mem_gas (pack s i)
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      Raw_context.mem (pack s i) data_name
      &gt;&gt;= fun exists -&gt;
      if exists then get s i &gt;&gt;=? fun (s, v) -&gt; return (s, Some v)
      else return (C.project s, None)

    let set s i v =
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, _) -&gt;
      consume_write_gas Raw_context.set (pack s i) v
      &gt;&gt;=? fun (c, bytes) -&gt;
      Raw_context.set c data_name bytes
      &gt;&gt;=? fun c -&gt;
      let size_diff = MBytes.length bytes - prev_size in
      return (Raw_context.project c, size_diff)

    let init s i v =
      consume_write_gas Raw_context.init (pack s i) v
      &gt;&gt;=? fun (c, bytes) -&gt;
      Raw_context.init c data_name bytes
      &gt;&gt;=? fun c -&gt;
      let size = MBytes.length bytes in
      return (Raw_context.project c, size)

    let init_set s i v =
      let init_set c k v = Raw_context.init_set c k v &gt;&gt;= return in
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, existed) -&gt;
      consume_write_gas init_set (pack s i) v
      &gt;&gt;=? fun (c, bytes) -&gt;
      init_set c data_name bytes
      &gt;&gt;=? fun c -&gt;
      let size_diff = MBytes.length bytes - prev_size in
      return (Raw_context.project c, size_diff, existed)

    let remove s i =
      let remove c k = Raw_context.remove c k &gt;&gt;= return in
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, existed) -&gt;
      consume_remove_gas remove (pack s i)
      &gt;&gt;=? fun c -&gt;
      remove c data_name
      &gt;&gt;=? fun c -&gt; return (Raw_context.project c, prev_size, existed)

    let delete s i =
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, _) -&gt;
      consume_remove_gas Raw_context.delete (pack s i)
      &gt;&gt;=? fun c -&gt;
      Raw_context.delete c data_name
      &gt;&gt;=? fun c -&gt; return (Raw_context.project c, prev_size)

    let set_option s i v =
      match v with None -&gt; remove s i | Some v -&gt; init_set s i v

    let () =
      let open Storage_description in
      let unpack = unpack I.args in
      register_value
        ~get:(fun c -&gt;
          let (c, k) = unpack c in
          get_option c k &gt;&gt;=? fun (_, v) -&gt; return v)
        (register_named_subcontext Raw_context.description N.name)
        V.encoding
  end
end</abbr>

<abbr class="mark-error" title="Functors are not handled.">module Wrap_indexed_data_storage
    (C : Indexed_data_storage) (K : sig
      type t

      val wrap : t -&gt; C.key

      val unwrap : C.key -&gt; t option
    end) =
struct
  type t = C.t

  type context = C.t

  type key = K.t

  type value = C.value

  let mem ctxt k = C.mem ctxt (K.wrap k)

  let get ctxt k = C.get ctxt (K.wrap k)

  let get_option ctxt k = C.get_option ctxt (K.wrap k)

  let set ctxt k v = C.set ctxt (K.wrap k) v

  let init ctxt k v = C.init ctxt (K.wrap k) v

  let init_set ctxt k v = C.init_set ctxt (K.wrap k) v

  let set_option ctxt k v = C.set_option ctxt (K.wrap k) v

  let delete ctxt k = C.delete ctxt (K.wrap k)

  let remove ctxt k = C.remove ctxt (K.wrap k)

  let clear ctxt = C.clear ctxt

  let fold ctxt ~init ~f =
    C.fold ctxt ~init ~f:(fun k v acc -&gt;
        match K.unwrap k with None -&gt; Lwt.return acc | Some k -&gt; f k v acc)

  let bindings s =
    fold s ~init:[] ~f:(fun p v acc -&gt; Lwt.return ((p, v) :: acc))

  let fold_keys s ~init ~f =
    C.fold_keys s ~init ~f:(fun k acc -&gt;
        match K.unwrap k with None -&gt; Lwt.return acc | Some k -&gt; f k acc)

  let keys s = fold_keys s ~init:[] ~f:(fun p acc -&gt; Lwt.return (p :: acc))
end</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_functors.ml"><code>Storage_functors.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Storage_description.
Require Tezos.Storage_sigs.

Import Storage_sigs.

Definition Registered :=
  let ghost := false in
  existT _ tt
    {|
      Storage_sigs.REGISTER.ghost := ghost
      |}.

Definition Ghost :=
  let ghost := true in
  existT _ tt
    {|
      Storage_sigs.REGISTER.ghost := ghost
      |}.

(* ‚ùå Functors are not handled. *)
(* functor *)

Definition len_name : string := &quot;len&quot; % string.

Definition data_name : string := &quot;data&quot; % string.

Definition encode_len_value (__bytes_value : MBytes.t) : MBytes.t :=
  let length := MBytes.length __bytes_value in
  (Data_encoding.Binary.to_bytes_exn Data_encoding.int31) length.

Definition decode_len_value (key : list string) (len : MBytes.t)
  : Lwt.t (Error_monad.tzresult Z) :=
  match (Data_encoding.Binary.of_bytes Data_encoding.int31) len with
  | None =&gt; Error_monad.fail extensible_type_value
  | Some len =&gt; Error_monad.__return len
  end.

Definition map_key {A B : Set} (f : A -&gt; B) (function_parameter : (* `Key *) A)
  : (* `Key *) B :=
  match function_parameter with
  | Key k =&gt;
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Key *)
    f k
  | Dir k =&gt;
    (* ‚ùå Variants not supported *)
    (* ‚ùå `Dir *)
    f k
  end.

(* ‚ùå Functors are not handled. *)
(* functor *)

(* ‚ùå Functors are not handled. *)
(* functor *)

Module INDEX.
  Record signature {t : Set} {ipath : Set -&gt; Set} := {
    t := t;
    path_length : Z;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    ipath := ipath;
    args : forall {a : Set}, Storage_description.args a t (ipath a);
  }.
  Arguments signature : clear implicits.
End INDEX.

(* ‚ùå Functors are not handled. *)
(* functor *)

(* ‚ùå Functors are not handled. *)
(* functor *)

(* ‚ùå Functors are not handled. *)
(* functor *)

(* ‚ùå Functors are not handled. *)
(* functor *)

(* ‚ùå Functors are not handled. *)
(* functor *)

(* ‚ùå Functors are not handled. *)
(* functor *)

(* ‚ùå Functors are not handled. *)
(* functor *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_functors.mli">
  <div class="col-md-6">
    <a href="#storage_functors.mli"><code>storage_functors.mli</code></a>&nbsp;<span class="label label-danger">7 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Typed storage builders. *)

open Storage_sigs

module Registered : REGISTER

module Ghost : REGISTER

module Make_subcontext (R : REGISTER) (C : Raw_context.T) (N : NAME) :
  Raw_context.T with type t = C.t

module Make_single_data_storage
    (R : REGISTER)
    (C : Raw_context.T)
    (N : NAME)
    (V : VALUE) : Single_data_storage with type t = C.t and <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_sigs.VALUE, Tezos_raw_protocol_alpha__Storage_sigs.VALUE

We were looking for a module signature name for the following shape:
[ encoding ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type value = V.t</abbr>

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  type 'a ipath

  val args : ('a, t, 'a ipath) Storage_description.args
end

module Pair (I1 : INDEX) (I2 : INDEX) : INDEX with type t = I1.t * I2.t

module Make_data_set_storage (C : Raw_context.T) (I : INDEX) :
  Data_set_storage with type t = C.t and type elt = I.t

module Make_indexed_data_storage (C : Raw_context.T) (I : INDEX) (V : VALUE) :
  Indexed_data_storage
    with type t = C.t
     and type key = I.t
     and <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_sigs.VALUE, Tezos_raw_protocol_alpha__Storage_sigs.VALUE

We were looking for a module signature name for the following shape:
[ encoding ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type value = V.t</abbr>

module Make_indexed_carbonated_data_storage
    (C : Raw_context.T)
    (I : INDEX)
    (V : VALUE) :
  Non_iterable_indexed_carbonated_data_storage
    with type t = C.t
     and type key = I.t
     and <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_sigs.VALUE, Tezos_raw_protocol_alpha__Storage_sigs.VALUE

We were looking for a module signature name for the following shape:
[ encoding ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type value = V.t</abbr>

module Make_indexed_data_snapshotable_storage
    (C : Raw_context.T)
    (Snapshot : INDEX)
    (I : INDEX)
    (V : VALUE) :
  Indexed_data_snapshotable_storage
    with type t = C.t
     and type snapshot = Snapshot.t
     and type key = I.t
     and <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_sigs.VALUE, Tezos_raw_protocol_alpha__Storage_sigs.VALUE

We were looking for a module signature name for the following shape:
[ encoding ]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type value = V.t</abbr>

module Make_indexed_subcontext (C : Raw_context.T) (I : INDEX) :
  Indexed_raw_context
    with type t = C.t
     and type key = I.t
     and type 'a ipath = 'a I.ipath

module Wrap_indexed_data_storage
    (C : Indexed_data_storage) (K : <abbr class="mark-error" title="Anonymous definition of signatures is not handled">sig
      type t

      val wrap : t -&gt; C.key

      val unwrap : C.key -&gt; t option
    end</abbr>) :
  Indexed_data_storage
    with <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_sigs.Indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Indexed_data_storage

We were looking for a module signature name for the following shape:
[
  mem;
  get;
  get_option;
  set;
  init;
  init_set;
  set_option;
  delete;
  remove;
  clear;
  keys;
  bindings;
  fold;
  fold_keys
]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type t = C.t</abbr>
     and type key = K.t
     and <abbr class="mark-error" title="It is unclear which first-class module this projection is from. At least two similar
module signatures found, namely:
Tezos_raw_protocol_alpha.Storage_sigs.Indexed_data_storage, Tezos_raw_protocol_alpha__Storage_sigs.Indexed_data_storage

We were looking for a module signature name for the following shape:
[
  mem;
  get;
  get_option;
  set;
  init;
  init_set;
  set_option;
  delete;
  remove;
  clear;
  keys;
  bindings;
  fold;
  fold_keys
]
(a shape is a list of names of values)

We use the concept of shape to find the name of a signature for Coq.">type value = C.value</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_functors.mli"><code>Storage_functors_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Raw_context.
Require Tezos.Storage_description.
Require Tezos.Storage_sigs.

Parameter Registered : {_ : unit &amp; REGISTER.signature }.

Parameter Ghost : {_ : unit &amp; REGISTER.signature }.

Parameter Make_subcontext :
  forall (R : {_ : unit &amp; REGISTER.signature }),
    (forall (C : {t : _ &amp; Raw_context.T.signature t}),
      (forall (N : {_ : unit &amp; NAME.signature }),
        {_ : unit &amp; Raw_context.T.signature C.[Raw_context.T.t]})).

Parameter Make_single_data_storage :
  forall (R : {_ : unit &amp; REGISTER.signature }),
    (forall (C : {t : _ &amp; Raw_context.T.signature t}),
      (forall (N : {_ : unit &amp; NAME.signature }),
        (forall (V : {t : _ &amp; VALUE.signature t}),
          {_ : unit &amp;
            Single_data_storage.signature C.[Raw_context.T.t]
              V.[Storage_sigs.VALUE.t]}))).

Module INDEX.
  Record signature {t : Set} {ipath : Set -&gt; Set} := {
    t := t;
    path_length : Z;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    ipath := ipath;
    args : forall {a : Set}, Storage_description.args a t (ipath a);
  }.
  Arguments signature : clear implicits.
End INDEX.

Parameter Pair :
  forall (I1 : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
    (forall (I2 : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
      {ipath : _ &amp; INDEX.signature (I1.[INDEX.t] * I2.[INDEX.t]) ipath}).

Parameter Make_data_set_storage :
  forall (C : {t : _ &amp; Raw_context.T.signature t}),
    (forall (I : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
      {_ : unit &amp; Data_set_storage.signature C.[Raw_context.T.t] I.[INDEX.t]}).

Parameter Make_indexed_data_storage :
  forall (C : {t : _ &amp; Raw_context.T.signature t}),
    (forall (I : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
      (forall (V : {t : _ &amp; VALUE.signature t}),
        {_ : unit &amp;
          Indexed_data_storage.signature C.[Raw_context.T.t] I.[INDEX.t]
            V.[Storage_sigs.VALUE.t]})).

Parameter Make_indexed_carbonated_data_storage :
  forall (C : {t : _ &amp; Raw_context.T.signature t}),
    (forall (I : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
      (forall (V : {t : _ &amp; VALUE.signature t}),
        {_ : unit &amp;
          Non_iterable_indexed_carbonated_data_storage.signature
            C.[Raw_context.T.t] I.[INDEX.t] V.[Storage_sigs.VALUE.t]})).

Parameter Make_indexed_data_snapshotable_storage :
  forall (C : {t : _ &amp; Raw_context.T.signature t}),
    (forall (Snapshot : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
      (forall (I : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
        (forall (V : {t : _ &amp; VALUE.signature t}),
          {_ : unit &amp;
            Indexed_data_snapshotable_storage.signature Snapshot.[INDEX.t]
              I.[INDEX.t] C.[Raw_context.T.t] V.[Storage_sigs.VALUE.t]}))).

Parameter Make_indexed_subcontext :
  forall (C : {t : _ &amp; Raw_context.T.signature t}),
    (forall (I : {'[t, ipath] : _ &amp; INDEX.signature t ipath}),
      {_ : unit &amp;
        Indexed_raw_context.signature C.[Raw_context.T.t] I.[INDEX.t]
          (I.[INDEX.ipath] a)}).

Parameter Wrap_indexed_data_storage :
  forall (C :
    {'[t, key, value] : _ &amp; Indexed_data_storage.signature t key value}),
    (forall (K : signature),
      {_ : unit &amp;
        Indexed_data_storage.signature C.[Storage_sigs.Indexed_data_storage.t]
          K.t C.[Storage_sigs.Indexed_data_storage.value]}).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_sigs.ml">
  <div class="col-md-6">
    <a href="#storage_sigs.ml"><code>storage_sigs.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** {1 Entity Accessor Signatures} *)

(** The generic signature of a single data accessor (a single value
    bound to a specific key in the hierarchical (key x value)
    database). *)
module type Single_data_storage = sig
  type t

  type context = t

  (** The type of the value *)
  type value

  (** Tells if the data is already defined *)
  val mem : context -&gt; bool Lwt.t

  (** Retrieve the value from the storage bucket ; returns a
      {!Storage_error} if the key is not set or if the deserialisation
      fails *)
  val get : context -&gt; value tzresult Lwt.t

  (** Retrieves the value from the storage bucket ; returns [None] if
      the data is not initialized, or {!Storage_helpers.Storage_error}
      if the deserialisation fails *)
  val get_option : context -&gt; value option tzresult Lwt.t

  (** Allocates the storage bucket and initializes it ; returns a
      {!Storage_error Existing_key} if the bucket exists *)
  val init : context -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Updates the content of the bucket ; returns a {!Storage_Error
      Missing_key} if the value does not exists *)
  val set : context -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Allocates the data and initializes it with a value ; just
      updates it if the bucket exists *)
  val init_set : context -&gt; value -&gt; Raw_context.t Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists. *)
  val set_option : context -&gt; value option -&gt; Raw_context.t Lwt.t

  (** Delete the storage bucket ; returns a {!Storage_error
      Missing_key} if the bucket does not exists *)
  val delete : context -&gt; Raw_context.t tzresult Lwt.t

  (** Removes the storage bucket and its contents ; does nothing if
      the bucket does not exists *)
  val remove : context -&gt; Raw_context.t Lwt.t
end

(** Variant of {!Single_data_storage} with gas accounting. *)
module type Single_carbonated_data_storage = sig
  type t

  type context = t

  (** The type of the value *)
  type value

  (** Tells if the data is already defined.
      Consumes [Gas_repr.read_bytes_cost Z.zero]. *)
  val mem : context -&gt; (Raw_context.t * bool) tzresult Lwt.t

  (** Retrieve the value from the storage bucket ; returns a
      {!Storage_error} if the key is not set or if the deserialisation
      fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;]. *)
  val get : context -&gt; (Raw_context.t * value) tzresult Lwt.t

  (** Retrieves the value from the storage bucket ; returns [None] if
      the data is not initialized, or {!Storage_helpers.Storage_error}
      if the deserialisation fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;] if present
      or [Gas_repr.read_bytes_cost Z.zero]. *)
  val get_option : context -&gt; (Raw_context.t * value option) tzresult Lwt.t

  (** Allocates the storage bucket and initializes it ; returns a
      {!Storage_error Missing_key} if the bucket exists.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the value&gt;].
      Returns the size. *)
  val init : context -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Updates the content of the bucket ; returns a {!Storage_Error
      Existing_key} if the value does not exists.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old to the new size. *)
  val set : context -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Allocates the data and initializes it with a value ; just
      updates it if the bucket exists.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val init_set :
    context -&gt; value -&gt; (Raw_context.t * int * bool) tzresult Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists.
      Consumes the same gas cost as either {!remove} or {!init_set}.
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val set_option :
    context -&gt; value option -&gt; (Raw_context.t * int * bool) tzresult Lwt.t

  (** Delete the storage bucket ; returns a {!Storage_error
      Missing_key} if the bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size. *)
  val delete : context -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Removes the storage bucket and its contents ; does nothing if
      the bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size, and a boolean
      indicating if a value was already associated to this key. *)
  val remove : context -&gt; (Raw_context.t * int * bool) tzresult Lwt.t
end

(** Restricted version of {!Indexed_data_storage} w/o iterators. *)
module type Non_iterable_indexed_data_storage = sig
  type t

  type context = t

  (** An abstract type for keys *)
  type key

  (** The type of values *)
  type value

  (** Tells if a given key is already bound to a storage bucket *)
  val mem : context -&gt; key -&gt; bool Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns {!Storage_error Missing_key} if the key is not set ;
      returns {!Storage_error Corrupted_data} if the deserialisation
      fails. *)
  val get : context -&gt; key -&gt; value tzresult Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns [None] if the value is not set ; returns {!Storage_error
      Corrupted_data} if the deserialisation fails. *)
  val get_option : context -&gt; key -&gt; value option tzresult Lwt.t

  (** Updates the content of a bucket ; returns A {!Storage_Error
      Missing_key} if the value does not exists. *)
  val set : context -&gt; key -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it ;
      returns a {!Storage_error Existing_key} if the bucket exists. *)
  val init : context -&gt; key -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it
      with a value ; just updates it if the bucket exists. *)
  val init_set : context -&gt; key -&gt; value -&gt; Raw_context.t Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists. *)
  val set_option : context -&gt; key -&gt; value option -&gt; Raw_context.t Lwt.t

  (** Delete a storage bucket and its contents ; returns a
      {!Storage_error Missing_key} if the bucket does not exists. *)
  val delete : context -&gt; key -&gt; Raw_context.t tzresult Lwt.t

  (** Removes a storage bucket and its contents ; does nothing if the
      bucket does not exists. *)
  val remove : context -&gt; key -&gt; Raw_context.t Lwt.t
end

(** Variant of {!Non_iterable_indexed_data_storage} with gas accounting. *)
module type Non_iterable_indexed_carbonated_data_storage = sig
  type t

  type context = t

  (** An abstract type for keys *)
  type key

  (** The type of values *)
  type value

  (** Tells if a given key is already bound to a storage bucket.
      Consumes [Gas_repr.read_bytes_cost Z.zero]. *)
  val mem : context -&gt; key -&gt; (Raw_context.t * bool) tzresult Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns {!Storage_error Missing_key} if the key is not set ;
      returns {!Storage_error Corrupted_data} if the deserialisation
      fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;]. *)
  val get : context -&gt; key -&gt; (Raw_context.t * value) tzresult Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns [None] if the value is not set ; returns {!Storage_error
      Corrupted_data} if the deserialisation fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;] if present
      or [Gas_repr.read_bytes_cost Z.zero]. *)
  val get_option :
    context -&gt; key -&gt; (Raw_context.t * value option) tzresult Lwt.t

  (** Updates the content of a bucket ; returns A {!Storage_Error
      Missing_key} if the value does not exists.
      Consumes serialization cost.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old to the new size. *)
  val set : context -&gt; key -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it ;
      returns a {!Storage_error Existing_key} if the bucket exists.
      Consumes serialization cost.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the value&gt;].
      Returns the size. *)
  val init : context -&gt; key -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it
      with a value ; just updates it if the bucket exists.
      Consumes serialization cost.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val init_set :
    context -&gt; key -&gt; value -&gt; (Raw_context.t * int * bool) tzresult Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists.
      Consumes serialization cost.
      Consumes the same gas cost as either {!remove} or {!init_set}.
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val set_option :
    context -&gt;
    key -&gt;
    value option -&gt;
    (Raw_context.t * int * bool) tzresult Lwt.t

  (** Delete a storage bucket and its contents ; returns a
      {!Storage_error Missing_key} if the bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size. *)
  val delete : context -&gt; key -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Removes a storage bucket and its contents ; does nothing if the
      bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size, and a boolean
      indicating if a value was already associated to this key. *)
  val remove : context -&gt; key -&gt; (Raw_context.t * int * bool) tzresult Lwt.t
end

(** The generic signature of indexed data accessors (a set of values
    of the same type indexed by keys of the same form in the
    hierarchical (key x value) database). *)
module type Indexed_data_storage = sig
  include Non_iterable_indexed_data_storage

  (** Empties all the keys and associated data. *)
  val clear : context -&gt; Raw_context.t Lwt.t

  (** Lists all the keys. *)
  val keys : context -&gt; key list Lwt.t

  (** Lists all the keys and associated data. *)
  val bindings : context -&gt; (key * value) list Lwt.t

  (** Iterates over all the keys and associated data. *)
  val fold :
    context -&gt; init:'a -&gt; f:(key -&gt; value -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  (** Iterate over all the keys. *)
  val fold_keys : context -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t
end

module type Indexed_data_snapshotable_storage = sig
  type snapshot

  type key

  include Indexed_data_storage with type key := key

  module Snapshot :
    Indexed_data_storage
      with type key = snapshot * key
       and type value = value
       and type t = t

  val snapshot_exists : context -&gt; snapshot -&gt; bool Lwt.t

  val snapshot : context -&gt; snapshot -&gt; Raw_context.t tzresult Lwt.t

  val delete_snapshot : context -&gt; snapshot -&gt; Raw_context.t Lwt.t
end

(** The generic signature of a data set accessor (a set of values
    bound to a specific key prefix in the hierarchical (key x value)
    database). *)
module type Data_set_storage = sig
  type t

  type context = t

  (** The type of elements. *)
  type elt

  (** Tells if a elt is a member of the set *)
  val mem : context -&gt; elt -&gt; bool Lwt.t

  (** Adds a elt is a member of the set *)
  val add : context -&gt; elt -&gt; Raw_context.t Lwt.t

  (** Removes a elt of the set ; does nothing if not a member *)
  val del : context -&gt; elt -&gt; Raw_context.t Lwt.t

  (** Adds/Removes a elt of the set *)
  val set : context -&gt; elt -&gt; bool -&gt; Raw_context.t Lwt.t

  (** Returns the elements of the set, deserialized in a list in no
      particular order. *)
  val elements : context -&gt; elt list Lwt.t

  (** Iterates over the elements of the set. *)
  val fold : context -&gt; init:'a -&gt; f:(elt -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  (** Removes all elements in the set *)
  val clear : context -&gt; Raw_context.t Lwt.t
end

module type NAME = sig
  val name : Raw_context.key
end

module type VALUE = sig
  type t

  val encoding : t Data_encoding.t
end

module type REGISTER = sig
  val ghost : bool
end

module type Indexed_raw_context = sig
  type t

  type context = t

  type key

  type 'a ipath

  val clear : context -&gt; Raw_context.t Lwt.t

  val fold_keys : context -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val keys : context -&gt; key list Lwt.t

  val resolve : context -&gt; string list -&gt; key list Lwt.t

  val remove_rec : context -&gt; key -&gt; context Lwt.t

  val copy : context -&gt; from:key -&gt; to_:key -&gt; context tzresult Lwt.t

  module Make_set (R : REGISTER) (N : NAME) :
    Data_set_storage with type t = t and type elt = key

  module Make_map (N : NAME) (V : VALUE) :
    Indexed_data_storage
      with type t = t
       and type key = key
       and type value = V.t

  module Make_carbonated_map (N : NAME) (V : VALUE) :
    Non_iterable_indexed_carbonated_data_storage
      with type t = t
       and type key = key
       and type value = V.t

  module Raw_context : Raw_context.T with type t = t ipath
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_sigs.ml"><code>Storage_sigs.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Raw_context.

Module Single_data_storage.
  Record signature {t value : Set} := {
    t := t;
    context := t;
    value := value;
    mem : context -&gt; Lwt.t bool;
    get : context -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; Lwt.t (Error_monad.tzresult (option value));
    init : context -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    set : context -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Single_data_storage.

Module Single_carbonated_data_storage.
  Record signature {t value : Set} := {
    t := t;
    context := t;
    value := value;
    mem : context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * bool));
    get : context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * value));
    get_option :
      context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * option value));
    init : context -&gt; value -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z));
    set : context -&gt; value -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z));
    init_set :
      context -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool));
    set_option :
      context -&gt; option value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool));
    delete : context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z));
    remove : context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool));
  }.
  Arguments signature : clear implicits.
End Single_carbonated_data_storage.

Module Non_iterable_indexed_data_storage.
  Record signature {t key value : Set} := {
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (option value));
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; key -&gt; Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Non_iterable_indexed_data_storage.

Module Non_iterable_indexed_carbonated_data_storage.
  Record signature {t key value : Set} := {
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * bool));
    get :
      context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * value));
    get_option :
      context -&gt; key -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * option value));
    set :
      context -&gt; key -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z));
    init :
      context -&gt; key -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z));
    init_set :
      context -&gt; key -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool));
    set_option :
      context -&gt; key -&gt; option value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool));
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z));
    remove :
      context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z * bool));
  }.
  Arguments signature : clear implicits.
End Non_iterable_indexed_carbonated_data_storage.

Module Indexed_data_storage.
  Record signature {t key value : Set} := {
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (option value));
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; key -&gt; Lwt.t Raw_context.t;
    clear : context -&gt; Lwt.t Raw_context.t;
    keys : context -&gt; Lwt.t (list key);
    bindings : context -&gt; Lwt.t (list (key * value));
    fold : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; value -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    fold_keys : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
  }.
  Arguments signature : clear implicits.
End Indexed_data_storage.

Module Indexed_data_snapshotable_storage.
  Record signature {snapshot key t value : Set} := {
    snapshot := snapshot;
    key := key;
    t := t;
    context := t;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (option value));
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; key -&gt; Lwt.t Raw_context.t;
    clear : context -&gt; Lwt.t Raw_context.t;
    keys : context -&gt; Lwt.t (list key);
    bindings : context -&gt; Lwt.t (list (key * value));
    fold : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; value -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    fold_keys : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    Snapshot : Indexed_data_storage.signature t (snapshot * key) value;
    snapshot_exists : context -&gt; snapshot -&gt; Lwt.t bool;
    snapshot :
      context -&gt; snapshot -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    delete_snapshot : context -&gt; snapshot -&gt; Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Indexed_data_snapshotable_storage.

Module Data_set_storage.
  Record signature {t elt : Set} := {
    t := t;
    context := t;
    elt := elt;
    mem : context -&gt; elt -&gt; Lwt.t bool;
    add : context -&gt; elt -&gt; Lwt.t Raw_context.t;
    del : context -&gt; elt -&gt; Lwt.t Raw_context.t;
    set : context -&gt; elt -&gt; bool -&gt; Lwt.t Raw_context.t;
    elements : context -&gt; Lwt.t (list elt);
    fold : forall {a : Set}, context -&gt; a -&gt; (elt -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    clear : context -&gt; Lwt.t Raw_context.t;
  }.
  Arguments signature : clear implicits.
End Data_set_storage.

Module NAME.
  Record signature := {
    name : Raw_context.key;
  }.
End NAME.

Module VALUE.
  Record signature {t : Set} := {
    t := t;
    encoding : Data_encoding.t t;
  }.
  Arguments signature : clear implicits.
End VALUE.

Module REGISTER.
  Record signature := {
    ghost : bool;
  }.
End REGISTER.

Module Indexed_raw_context.
  Record signature {t key : Set} {ipath : Set -&gt; Set} := {
    t := t;
    context := t;
    key := key;
    ipath := ipath;
    clear : context -&gt; Lwt.t Raw_context.t;
    fold_keys : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    keys : context -&gt; Lwt.t (list key);
    resolve : context -&gt; list string -&gt; Lwt.t (list key);
    remove_rec : context -&gt; key -&gt; Lwt.t context;
    copy : context -&gt; key -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    Make_set :
      forall (R : REGISTER.signature ),
        forall (N : NAME.signature ), Data_set_storage.signature t key;
    Make_map :
      forall (N : NAME.signature ),
        forall (V : VALUE.signature Make_map_t),
          Indexed_data_storage.signature t key V.(VALUE.t);
    Make_carbonated_map :
      forall (N : NAME.signature ),
        forall (V : VALUE.signature Make_carbonated_map_t),
          Non_iterable_indexed_carbonated_data_storage.signature t key
            V.(VALUE.t);
    Raw_context : Raw_context.T.signature (ipath t);
  }.
  Arguments signature : clear implicits.
End Indexed_raw_context.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="tez_repr.ml">
  <div class="col-md-6">
    <a href="#tez_repr.ml"><code>tez_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module QtyModule = Qty_repr.Make (struct
  let id = &quot;tez&quot;
end)

include QtyModule

type t = qty

type tez = qty

let encoding = Data_encoding.def &quot;mutez&quot; @@ encoding
</pre>
  </div>
  <div class="col-md-6">
    <a href="#tez_repr.ml"><code>Tez_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Qty_repr.

Definition QtyModule :=
  Qty_repr.Make
    (let id := &quot;tez&quot; % string in
    existT _ tt
      {|
        Qty_repr.QTY.id := id
        |}).

Definition qty := QtyModule.[Qty_repr.S.qty].

Definition id := QtyModule.[Qty_repr.S.id].

Definition zero := QtyModule.[Qty_repr.S.zero].

Definition one_mutez := QtyModule.[Qty_repr.S.one_mutez].

Definition one_cent := QtyModule.[Qty_repr.S.one_cent].

Definition fifty_cents := QtyModule.[Qty_repr.S.fifty_cents].

Definition one := QtyModule.[Qty_repr.S.one].

Definition op_minusquestion := QtyModule.[Qty_repr.S.op_minusquestion].

Definition op_plusquestion := QtyModule.[Qty_repr.S.op_plusquestion].

Definition op_starquestion := QtyModule.[Qty_repr.S.op_starquestion].

Definition op_divquestion := QtyModule.[Qty_repr.S.op_divquestion].

Definition to_mutez := QtyModule.[Qty_repr.S.to_mutez].

Definition of_mutez := QtyModule.[Qty_repr.S.of_mutez].

Definition of_mutez_exn := QtyModule.[Qty_repr.S.of_mutez_exn].

Definition add_exn := QtyModule.[Qty_repr.S.add_exn].

Definition mul_exn := QtyModule.[Qty_repr.S.mul_exn].

Definition encoding := QtyModule.[Qty_repr.S.encoding].

Definition to_int64 := QtyModule.[Qty_repr.S.to_int64].

Definition op_eq := QtyModule.[Qty_repr.S.op_eq].

Definition op_ltgt := QtyModule.[Qty_repr.S.op_ltgt].

Definition op_lt := QtyModule.[Qty_repr.S.op_lt].

Definition op_lteq := QtyModule.[Qty_repr.S.op_lteq].

Definition op_gteq := QtyModule.[Qty_repr.S.op_gteq].

Definition op_gt := QtyModule.[Qty_repr.S.op_gt].

Definition compare := QtyModule.[Qty_repr.S.compare].

Definition equal := QtyModule.[Qty_repr.S.equal].

Definition max := QtyModule.[Qty_repr.S.max].

Definition min := QtyModule.[Qty_repr.S.min].

Definition pp := QtyModule.[Qty_repr.S.pp].

Definition of_string := QtyModule.[Qty_repr.S.of_string].

Definition to_string := QtyModule.[Qty_repr.S.to_string].

Definition t := qty.

Definition tez := qty.

Definition encoding : Data_encoding.encoding qty :=
  Pervasives.op_atat
    (let arg := Data_encoding.def &quot;mutez&quot; % string in
    fun eta =&gt; arg None None eta) encoding.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="tez_repr.mli">
  <div class="col-md-6">
    <a href="#tez_repr.mli"><code>tez_repr.mli</code></a>&nbsp;<span class="label label-danger">5 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

type tez = t

<abbr class="mark-error" title="Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled">include Qty_repr.S with type qty := t</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#tez_repr.mli"><code>Tez_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Qty_repr.

Parameter t : Set.

Definition tez := t.

Parameter Included_S : {_ : unit &amp; Qty_repr.S.signature t}.

Definition id := Included_S.[Qty_repr.S.id].

Definition zero := Included_S.[Qty_repr.S.zero].

Definition one_mutez := Included_S.[Qty_repr.S.one_mutez].

Definition one_cent := Included_S.[Qty_repr.S.one_cent].

Definition fifty_cents := Included_S.[Qty_repr.S.fifty_cents].

Definition one := Included_S.[Qty_repr.S.one].

Definition op_minusquestion := Included_S.[Qty_repr.S.op_minusquestion].

Definition op_plusquestion := Included_S.[Qty_repr.S.op_plusquestion].

Definition op_starquestion := Included_S.[Qty_repr.S.op_starquestion].

Definition op_divquestion := Included_S.[Qty_repr.S.op_divquestion].

Definition to_mutez := Included_S.[Qty_repr.S.to_mutez].

Definition of_mutez := Included_S.[Qty_repr.S.of_mutez].

Definition of_mutez_exn := Included_S.[Qty_repr.S.of_mutez_exn].

Definition add_exn := Included_S.[Qty_repr.S.add_exn].

Definition mul_exn := Included_S.[Qty_repr.S.mul_exn].

Definition encoding := Included_S.[Qty_repr.S.encoding].

Definition to_int64 := Included_S.[Qty_repr.S.to_int64].

Definition op_eq := Included_S.[Qty_repr.S.op_eq].

Definition op_ltgt := Included_S.[Qty_repr.S.op_ltgt].

Definition op_lt := Included_S.[Qty_repr.S.op_lt].

Definition op_lteq := Included_S.[Qty_repr.S.op_lteq].

Definition op_gteq := Included_S.[Qty_repr.S.op_gteq].

Definition op_gt := Included_S.[Qty_repr.S.op_gt].

Definition compare := Included_S.[Qty_repr.S.compare].

Definition equal := Included_S.[Qty_repr.S.equal].

Definition max := Included_S.[Qty_repr.S.max].

Definition min := Included_S.[Qty_repr.S.min].

Definition pp := Included_S.[Qty_repr.S.pp].

Definition of_string := Included_S.[Qty_repr.S.of_string].

Definition to_string := Included_S.[Qty_repr.S.to_string].
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="time_repr.ml">
  <div class="col-md-6">
    <a href="#time_repr.ml"><code>time_repr.ml</code></a>&nbsp;<span class="label label-danger">6 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

include Time

type time = t

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Timestamp_add</abbr> (* `Permanent *)

<abbr class="mark-error" title="Structure item `typext` not handled.">type error += Timestamp_sub</abbr> (* `Permanent *)

<abbr class="mark-error" title="Top-level evaluations are considered as an error as sources of side-effects">let () =
  register_error_kind
    `Permanent
    ~id:&quot;timestamp_add&quot;
    ~title:&quot;Timestamp add&quot;
    ~description:&quot;Overflow when adding timestamps.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Overflow when adding timestamps.&quot;)
    Data_encoding.empty
    (function Timestamp_add -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Timestamp_add) ;
  register_error_kind
    `Permanent
    ~id:&quot;timestamp_sub&quot;
    ~title:&quot;Timestamp sub&quot;
    ~description:&quot;Substracting timestamps resulted in negative period.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;Substracting timestamps resulted in negative period.&quot;)
    Data_encoding.empty
    (function Timestamp_sub -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Timestamp_sub)</abbr>

let of_seconds s = <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (of_seconds (Int64.of_string s)) with _ -&gt; None</abbr>

let to_seconds = to_seconds

let to_seconds_string s = Int64.to_string (to_seconds s)

let pp = pp_hum

let ( +? ) x y =
  <abbr class="mark-error" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try ok (add x (Period_repr.to_seconds y)) with _exn -&gt; error Timestamp_add</abbr>

let ( -? ) x y = record_trace <abbr class="mark-error" title="Values of extensible types are not handled">Timestamp_sub</abbr> (Period_repr.of_seconds (diff x y))
</pre>
  </div>
  <div class="col-md-6">
    <a href="#time_repr.ml"><code>Time_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Period_repr.

Export Time.

Definition time := t.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are considered as an error as sources of side-effects *)
(* top_level_evaluation *)

Definition of_seconds (s : string) : option t :=
  (* ‚ùå Try-with are not handled *)
  try (Some (of_seconds (Int64.of_string s))).

Definition to_seconds : t -&gt; int64 := to_seconds.

Definition to_seconds_string (s : t) : string := Int64.to_string (to_seconds s).

Definition pp : Format.formatter -&gt; t -&gt; unit := pp_hum.

Definition op_plusquestion (x : t) (y : Period_repr.period)
  : Error_monad.tzresult t :=
  (* ‚ùå Try-with are not handled *)
  try (Error_monad.ok (add x (Period_repr.to_seconds y))).

Definition op_minusquestion (x : t) (y : t)
  : Error_monad.tzresult Period_repr.period :=
  Error_monad.record_trace extensible_type_value
    (Period_repr.of_seconds (diff x y)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="time_repr.mli">
  <div class="col-md-6">
    <a href="#time_repr.mli"><code>time_repr.mli</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-error" title="Name for the included signature not found">include </abbr><abbr class="mark-error" title="Name for the included signature not found

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

The typeof in module types is not handled">module type of struct
  include Time
end</abbr>

type time = t

val pp : Format.formatter -&gt; t -&gt; unit

val of_seconds : string -&gt; time option

val to_seconds_string : time -&gt; string

val ( +? ) : time -&gt; Period_repr.t -&gt; time tzresult

val ( -? ) : time -&gt; time -&gt; Period_repr.t tzresult
</pre>
  </div>
  <div class="col-md-6">
    <a href="#time_repr.mli"><code>Time_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Period_repr.

Definition time := t.

Parameter pp : Format.formatter -&gt; t -&gt; unit.

Parameter of_seconds : string -&gt; option time.

Parameter to_seconds_string : time -&gt; string.

Parameter op_plusquestion : time -&gt; Period_repr.t -&gt; Error_monad.tzresult time.

Parameter op_minusquestion : time -&gt; time -&gt; Error_monad.tzresult Period_repr.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_repr.ml">
  <div class="col-md-6">
    <a href="#vote_repr.ml"><code>vote_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type proposal = Protocol_hash.t

type ballot = Yay | Nay | Pass

let ballot_encoding =
  let of_int8 = function
    | 0 -&gt;
        Yay
    | 1 -&gt;
        Nay
    | 2 -&gt;
        Pass
    | _ -&gt;
        invalid_arg &quot;ballot_of_int8&quot;
  in
  let to_int8 = function Yay -&gt; 0 | Nay -&gt; 1 | Pass -&gt; 2 in
  let open Data_encoding in
  (* union *)
  splitted
    ~binary:(conv to_int8 of_int8 int8)
    ~json:(string_enum [(&quot;yay&quot;, Yay); (&quot;nay&quot;, Nay); (&quot;pass&quot;, Pass)])
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_repr.ml"><code>Vote_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition proposal := Protocol_hash.[S.HASH.t].

Inductive ballot : Set :=
| Yay : ballot
| Nay : ballot
| Pass : ballot.

Definition ballot_encoding : Data_encoding.encoding ballot :=
  let of_int8 (function_parameter : Z) : ballot :=
    match function_parameter with
    | 0 =&gt; Yay
    | 1 =&gt; Nay
    | 2 =&gt; Pass
    | _ =&gt; Pervasives.invalid_arg &quot;ballot_of_int8&quot; % string
    end in
  let to_int8 (function_parameter : ballot) : Z :=
    match function_parameter with
    | Yay =&gt; 0
    | Nay =&gt; 1
    | Pass =&gt; 2
    end in
  Data_encoding.splitted
    (Data_encoding.string_enum
      (cons (&quot;yay&quot; % string, Yay)
        (cons (&quot;nay&quot; % string, Nay) (cons (&quot;pass&quot; % string, Pass) []))))
    (Data_encoding.conv to_int8 of_int8 None Data_encoding.int8).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_repr.mli">
  <div class="col-md-6">
    <a href="#vote_repr.mli"><code>vote_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** a protocol change proposal *)
type proposal = Protocol_hash.t

(** votes can be for, against or neutral.
    Neutral serves to count towards a quorum *)
type ballot = Yay | Nay | Pass

val ballot_encoding : ballot Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_repr.mli"><code>Vote_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition proposal := Protocol_hash.[S.HASH.t].

Inductive ballot : Set :=
| Yay : ballot
| Nay : ballot
| Pass : ballot.

Parameter ballot_encoding : Data_encoding.t ballot.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_storage.ml">
  <div class="col-md-6">
    <a href="#vote_storage.ml"><code>vote_storage.ml</code></a>&nbsp;<span class="label label-danger">3 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let recorded_proposal_count_for_delegate ctxt proposer =
  Storage.Vote.Proposals_count.get_option ctxt proposer
  &gt;&gt;=? function None -&gt; return 0 | Some count -&gt; return count

let record_proposal ctxt proposal proposer =
  recorded_proposal_count_for_delegate ctxt proposer
  &gt;&gt;=? fun count -&gt;
  Storage.Vote.Proposals_count.init_set ctxt proposer (count + 1)
  &gt;&gt;= fun ctxt -&gt;
  Storage.Vote.Proposals.add ctxt (proposal, proposer)
  &gt;&gt;= fun ctxt -&gt; return ctxt

let get_proposals ctxt =
  Storage.Vote.Proposals.fold
    ctxt
    ~init:(ok Protocol_hash.Map.empty)
    ~f:(fun (proposal, delegate) acc -&gt;
      (* Assuming the same listings is used at votings *)
      Storage.Vote.Listings.get ctxt delegate
      &gt;&gt;=? fun weight -&gt;
      Lwt.return
        ( acc
        &gt;&gt;? fun acc -&gt;
        let previous =
          match Protocol_hash.Map.find_opt proposal acc with
          | None -&gt;
              0l
          | Some x -&gt;
              x
        in
        ok (Protocol_hash.Map.add proposal (Int32.add weight previous) acc) ))

let clear_proposals ctxt =
  Storage.Vote.Proposals_count.clear ctxt
  &gt;&gt;= fun ctxt -&gt; Storage.Vote.Proposals.clear ctxt

type ballots = {yay : int32; nay : int32; pass : int32}

let ballots_encoding =
  let open Data_encoding in
  conv
    (fun {yay; nay; pass} -&gt; (yay, nay, pass))
    (fun (yay, nay, pass) -&gt; {yay; nay; pass})
  @@ obj3 (req &quot;yay&quot; int32) (req &quot;nay&quot; int32) (req &quot;pass&quot; int32)

let has_recorded_ballot = Storage.Vote.Ballots.mem

let record_ballot = Storage.Vote.Ballots.init

let get_ballots ctxt =
  Storage.Vote.Ballots.fold
    ctxt
    ~f:(fun delegate ballot (ballots : ballots tzresult) -&gt;
      (* Assuming the same listings is used at votings *)
      Storage.Vote.Listings.get ctxt delegate
      &gt;&gt;=? fun weight -&gt;
      let count = Int32.add weight in
      Lwt.return
        ( ballots
        &gt;&gt;? fun ballots -&gt;
        match ballot with
        | Yay -&gt;
            ok <abbr class="mark-error" title="Record substitution not handled">{ballots with yay = count ballots.yay}</abbr>
        | Nay -&gt;
            ok <abbr class="mark-error" title="Record substitution not handled">{ballots with nay = count ballots.nay}</abbr>
        | Pass -&gt;
            ok <abbr class="mark-error" title="Record substitution not handled">{ballots with pass = count ballots.pass}</abbr> ))
    ~init:(ok {yay = 0l; nay = 0l; pass = 0l})

let get_ballot_list = Storage.Vote.Ballots.bindings

let clear_ballots = Storage.Vote.Ballots.clear

let listings_encoding =
  Data_encoding.(
    list
      (obj2 (req &quot;pkh&quot; Signature.Public_key_hash.encoding) (req &quot;rolls&quot; int32)))

let freeze_listings ctxt =
  Roll_storage.fold ctxt (ctxt, 0l) ~f:(fun _roll delegate (ctxt, total) -&gt;
      (* TODO use snapshots *)
      let delegate = Signature.Public_key.hash delegate in
      Storage.Vote.Listings.get_option ctxt delegate
      &gt;&gt;=? (function None -&gt; return 0l | Some count -&gt; return count)
      &gt;&gt;=? fun count -&gt;
      Storage.Vote.Listings.init_set ctxt delegate (Int32.succ count)
      &gt;&gt;= fun ctxt -&gt; return (ctxt, Int32.succ total))
  &gt;&gt;=? fun (ctxt, total) -&gt;
  Storage.Vote.Listings_size.init ctxt total &gt;&gt;=? fun ctxt -&gt; return ctxt

let listing_size = Storage.Vote.Listings_size.get

let in_listings = Storage.Vote.Listings.mem

let get_listings = Storage.Vote.Listings.bindings

let clear_listings ctxt =
  Storage.Vote.Listings.clear ctxt
  &gt;&gt;= fun ctxt -&gt;
  Storage.Vote.Listings_size.remove ctxt &gt;&gt;= fun ctxt -&gt; return ctxt

let get_current_period_kind = Storage.Vote.Current_period_kind.get

let set_current_period_kind = Storage.Vote.Current_period_kind.set

let get_current_quorum ctxt =
  Storage.Vote.Participation_ema.get ctxt
  &gt;&gt;=? fun participation_ema -&gt;
  let quorum_min = Constants_storage.quorum_min ctxt in
  let quorum_max = Constants_storage.quorum_max ctxt in
  let quorum_diff = Int32.sub quorum_max quorum_min in
  return
    Int32.(add quorum_min (div (mul participation_ema quorum_diff) 100_00l))

let get_participation_ema = Storage.Vote.Participation_ema.get

let set_participation_ema = Storage.Vote.Participation_ema.set

let get_current_proposal = Storage.Vote.Current_proposal.get

let init_current_proposal = Storage.Vote.Current_proposal.init

let clear_current_proposal = Storage.Vote.Current_proposal.delete

let init ctxt =
  (* participation EMA is in centile of a percentage *)
  let participation_ema = Constants_storage.quorum_max ctxt in
  Storage.Vote.Participation_ema.init ctxt participation_ema
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Vote.Current_period_kind.init ctxt Proposal
  &gt;&gt;=? fun ctxt -&gt; return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_storage.ml"><code>Vote_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Constants_storage.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Storage.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Definition recorded_proposal_count_for_delegate
  (ctxt : Storage.Vote.Proposals_count.context)
  (proposer : Storage.Vote.Proposals_count.key)
  : Lwt.t (Error_monad.tzresult Storage.Vote.Proposals_count.value) :=
  Error_monad.op_gtgteqquestion
    (Storage.Vote.Proposals_count.get_option ctxt proposer)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; Error_monad.__return 0
      | Some count =&gt; Error_monad.__return count
      end).

Definition record_proposal
  (ctxt : Storage.Vote.Proposals_count.context)
  (proposal : Protocol_hash.[S.HASH.t])
  (proposer : Storage.Vote.Proposals_count.key)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion
    (recorded_proposal_count_for_delegate ctxt proposer)
    (fun count =&gt;
      Error_monad.op_gtgteq
        (Storage.Vote.Proposals_count.init_set ctxt proposer
          (Pervasives.op_plus count 1))
        (fun ctxt =&gt;
          Error_monad.op_gtgteq
            (Storage.Vote.Proposals.add ctxt (proposal, proposer))
            (fun ctxt =&gt; Error_monad.__return ctxt))).

Definition get_proposals (ctxt : Storage.Vote.Proposals.context)
  : Lwt.t
    (Error_monad.tzresult (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.t) int32)) :=
  Storage.Vote.Proposals.fold ctxt
    (Error_monad.ok Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.empty))
    (fun function_parameter =&gt;
      let '(proposal, delegate) := function_parameter in
      fun acc =&gt;
        Error_monad.op_gtgteqquestion (Storage.Vote.Listings.get ctxt delegate)
          (fun weight =&gt;
            Lwt.__return
              (Error_monad.op_gtgtquestion acc
                (fun acc =&gt;
                  let previous :=
                    match
                      Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.find_opt)
                        proposal acc with
                    | None =&gt;
                      (* ‚ùå Constant of type int32 is converted to int *)
                      0
                    | Some x =&gt; x
                    end in
                  Error_monad.ok
                    (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.add) proposal
                      (Int32.add weight previous) acc))))).

Definition clear_proposals (ctxt : Storage.Vote.Proposals_count.context)
  : Lwt.t Raw_context.t :=
  Error_monad.op_gtgteq (Storage.Vote.Proposals_count.clear ctxt)
    (fun ctxt =&gt; Storage.Vote.Proposals.clear ctxt).

Module ballots.
  Record record := {
    yay : int32;
    nay : int32;
    pass : int32 }.
End ballots.
Definition ballots := ballots.record.

Definition ballots_encoding : Data_encoding.encoding ballots :=
  Pervasives.op_atat
    (let arg :=
      Data_encoding.conv
        (fun function_parameter =&gt;
          let '{|
            ballots.yay := yay; ballots.nay := nay; ballots.pass := pass |} :=
            function_parameter in
          (yay, nay, pass))
        (fun function_parameter =&gt;
          let '(yay, nay, pass) := function_parameter in
          {| ballots.yay := yay; ballots.nay := nay; ballots.pass := pass |}) in
    fun eta =&gt; arg None eta)
    (Data_encoding.obj3
      (Data_encoding.req None None &quot;yay&quot; % string Data_encoding.__int32_value)
      (Data_encoding.req None None &quot;nay&quot; % string Data_encoding.__int32_value)
      (Data_encoding.req None None &quot;pass&quot; % string Data_encoding.__int32_value)).

Definition has_recorded_ballot
  : Storage.Vote.Ballots.context -&gt; Storage.Vote.Ballots.key -&gt; Lwt.t bool :=
  Storage.Vote.Ballots.mem.

Definition record_ballot
  : Storage.Vote.Ballots.context -&gt; Storage.Vote.Ballots.key -&gt;
  Storage.Vote.Ballots.value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Vote.Ballots.init.

Definition get_ballots (ctxt : Storage.Vote.Ballots.context)
  : Lwt.t (Error_monad.tzresult ballots) :=
  Storage.Vote.Ballots.fold ctxt
    (Error_monad.ok
      {|
        ballots.yay :=
          (* ‚ùå Constant of type int32 is converted to int *)
          0;
        ballots.nay :=
          (* ‚ùå Constant of type int32 is converted to int *)
          0;
        ballots.pass :=
          (* ‚ùå Constant of type int32 is converted to int *)
          0 |})
    (fun delegate =&gt;
      fun ballot =&gt;
        fun ballots =&gt;
          Error_monad.op_gtgteqquestion
            (Storage.Vote.Listings.get ctxt delegate)
            (fun weight =&gt;
              let count := Int32.add weight in
              Lwt.__return
                (Error_monad.op_gtgtquestion ballots
                  (fun ballots =&gt;
                    match ballot with
                    | Vote_repr.Yay =&gt;
                      Error_monad.ok
                        (* ‚ùå Record substitution not handled *)
                        record_substitution
                    | Vote_repr.Nay =&gt;
                      Error_monad.ok
                        (* ‚ùå Record substitution not handled *)
                        record_substitution
                    | Vote_repr.Pass =&gt;
                      Error_monad.ok
                        (* ‚ùå Record substitution not handled *)
                        record_substitution
                    end)))).

Definition get_ballot_list
  : Storage.Vote.Ballots.context -&gt;
  Lwt.t (list (Storage.Vote.Ballots.key * Storage.Vote.Ballots.value)) :=
  Storage.Vote.Ballots.bindings.

Definition clear_ballots
  : Storage.Vote.Ballots.context -&gt; Lwt.t Raw_context.t :=
  Storage.Vote.Ballots.clear.

Definition listings_encoding
  : Data_encoding.encoding
    (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * int32)) :=
  Data_encoding.__list_value None
    (Data_encoding.obj2
      (Data_encoding.req None None &quot;pkh&quot; % string
        Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
      (Data_encoding.req None None &quot;rolls&quot; % string Data_encoding.__int32_value)).

Definition freeze_listings (ctxt : Raw_context.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteqquestion
    (Roll_storage.fold ctxt
      (fun _roll =&gt;
        fun delegate =&gt;
          fun function_parameter =&gt;
            let '(ctxt, total) := function_parameter in
            let delegate :=
              Signature.Public_key.[S.SPublic_key.__hash_value] delegate in
            Error_monad.op_gtgteqquestion
              (Error_monad.op_gtgteqquestion
                (Storage.Vote.Listings.get_option ctxt delegate)
                (fun function_parameter =&gt;
                  match function_parameter with
                  | None =&gt;
                    Error_monad.__return
                      (* ‚ùå Constant of type int32 is converted to int *)
                      0
                  | Some count =&gt; Error_monad.__return count
                  end))
              (fun count =&gt;
                Error_monad.op_gtgteq
                  (Storage.Vote.Listings.init_set ctxt delegate
                    (Int32.succ count))
                  (fun ctxt =&gt; Error_monad.__return (ctxt, (Int32.succ total)))))
      (ctxt,
        (* ‚ùå Constant of type int32 is converted to int *)
        0))
    (fun function_parameter =&gt;
      let '(ctxt, total) := function_parameter in
      Error_monad.op_gtgteqquestion (Storage.Vote.Listings_size.init ctxt total)
        (fun ctxt =&gt; Error_monad.__return ctxt)).

Definition listing_size
  : Storage.Vote.Listings_size.context -&gt;
  Lwt.t (Error_monad.tzresult Storage.Vote.Listings_size.value) :=
  Storage.Vote.Listings_size.get.

Definition in_listings
  : Storage.Vote.Listings.context -&gt; Storage.Vote.Listings.key -&gt; Lwt.t bool :=
  Storage.Vote.Listings.mem.

Definition get_listings
  : Storage.Vote.Listings.context -&gt;
  Lwt.t (list (Storage.Vote.Listings.key * Storage.Vote.Listings.value)) :=
  Storage.Vote.Listings.bindings.

Definition clear_listings (ctxt : Storage.Vote.Listings.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Error_monad.op_gtgteq (Storage.Vote.Listings.clear ctxt)
    (fun ctxt =&gt;
      Error_monad.op_gtgteq (Storage.Vote.Listings_size.remove ctxt)
        (fun ctxt =&gt; Error_monad.__return ctxt)).

Definition get_current_period_kind
  : Storage.Vote.Current_period_kind.context -&gt;
  Lwt.t (Error_monad.tzresult Storage.Vote.Current_period_kind.value) :=
  Storage.Vote.Current_period_kind.get.

Definition set_current_period_kind
  : Storage.Vote.Current_period_kind.context -&gt;
  Storage.Vote.Current_period_kind.value -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Vote.Current_period_kind.set.

Definition get_current_quorum (ctxt : Storage.Vote.Participation_ema.context)
  : Lwt.t (Error_monad.tzresult int32) :=
  Error_monad.op_gtgteqquestion (Storage.Vote.Participation_ema.get ctxt)
    (fun participation_ema =&gt;
      let quorum_min := Constants_storage.quorum_min ctxt in
      let quorum_max := Constants_storage.quorum_max ctxt in
      let quorum_diff := Int32.sub quorum_max quorum_min in
      Error_monad.__return
        (Int32.add quorum_min
          (Int32.div (Int32.mul participation_ema quorum_diff)
            (* ‚ùå Constant of type int32 is converted to int *)
            10000))).

Definition get_participation_ema
  : Storage.Vote.Participation_ema.context -&gt;
  Lwt.t (Error_monad.tzresult Storage.Vote.Participation_ema.value) :=
  Storage.Vote.Participation_ema.get.

Definition set_participation_ema
  : Storage.Vote.Participation_ema.context -&gt;
  Storage.Vote.Participation_ema.value -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Vote.Participation_ema.set.

Definition get_current_proposal
  : Storage.Vote.Current_proposal.context -&gt;
  Lwt.t (Error_monad.tzresult Storage.Vote.Current_proposal.value) :=
  Storage.Vote.Current_proposal.get.

Definition init_current_proposal
  : Storage.Vote.Current_proposal.context -&gt;
  Storage.Vote.Current_proposal.value -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Vote.Current_proposal.init.

Definition clear_current_proposal
  : Storage.Vote.Current_proposal.context -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Vote.Current_proposal.delete.

Definition init (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let participation_ema := Constants_storage.quorum_max ctxt in
  Error_monad.op_gtgteqquestion
    (Storage.Vote.Participation_ema.init ctxt participation_ema)
    (fun ctxt =&gt;
      Error_monad.op_gtgteqquestion
        (Storage.Vote.Current_period_kind.init ctxt Voting_period_repr.Proposal)
        (fun ctxt =&gt; Error_monad.__return ctxt)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_storage.mli">
  <div class="col-md-6">
    <a href="#vote_storage.mli"><code>vote_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Manages all the voting related storage in Storage.Vote.  *)

(** Records a protocol proposal with the delegate that proposed it. *)
val record_proposal :
  Raw_context.t -&gt;
  Protocol_hash.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Raw_context.t tzresult Lwt.t

val recorded_proposal_count_for_delegate :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; int tzresult Lwt.t

(** Computes for each proposal how many delegates proposed it. *)
val get_proposals : Raw_context.t -&gt; int32 Protocol_hash.Map.t tzresult Lwt.t

val clear_proposals : Raw_context.t -&gt; Raw_context.t Lwt.t

(** Counts of the votes *)
type ballots = {yay : int32; nay : int32; pass : int32}

val ballots_encoding : ballots Data_encoding.t

val has_recorded_ballot :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool Lwt.t

(** Records a vote for a delegate, returns a {!Storage_error Existing_key} if
    the vote was already registered *)
val record_ballot :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Vote_repr.ballot -&gt;
  Raw_context.t tzresult Lwt.t

(** Computes the sum of the current ballots weighted by stake. *)
val get_ballots : Raw_context.t -&gt; ballots tzresult Lwt.t

val get_ballot_list :
  Raw_context.t -&gt; (Signature.Public_key_hash.t * Vote_repr.ballot) list Lwt.t

val clear_ballots : Raw_context.t -&gt; Raw_context.t Lwt.t

val listings_encoding :
  (Signature.Public_key_hash.t * int32) list Data_encoding.t

(** Populates [!Storage.Vote.Listings] using the currently existing rolls and
    sets Listings_size. Delegates without rolls are not included in the listing. *)
val freeze_listings : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val clear_listings : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

(** Returns the sum of all rolls of all delegates. *)
val listing_size : Raw_context.t -&gt; int32 tzresult Lwt.t

(** Verifies the presence of a delegate in the listing. *)
val in_listings : Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool Lwt.t

val get_listings :
  Raw_context.t -&gt; (Signature.Public_key_hash.t * int32) list Lwt.t

val get_current_quorum : Raw_context.t -&gt; int32 tzresult Lwt.t

val get_participation_ema : Raw_context.t -&gt; int32 tzresult Lwt.t

val set_participation_ema :
  Raw_context.t -&gt; int32 -&gt; Raw_context.t tzresult Lwt.t

val get_current_period_kind :
  Raw_context.t -&gt; Voting_period_repr.kind tzresult Lwt.t

val set_current_period_kind :
  Raw_context.t -&gt; Voting_period_repr.kind -&gt; Raw_context.t tzresult Lwt.t

val get_current_proposal : Raw_context.t -&gt; Protocol_hash.t tzresult Lwt.t

val init_current_proposal :
  Raw_context.t -&gt; Protocol_hash.t -&gt; Raw_context.t tzresult Lwt.t

val clear_current_proposal : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

(** Sets the initial quorum to 80% and period kind to proposal. *)
val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_storage.mli"><code>Vote_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Raw_context.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Parameter record_proposal :
  Raw_context.t -&gt; Protocol_hash.[S.HASH.t] -&gt;
  Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter recorded_proposal_count_for_delegate :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t (Error_monad.tzresult Z).

Parameter get_proposals :
  Raw_context.t -&gt;
  Lwt.t
    (Error_monad.tzresult (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.t) int32)).

Parameter clear_proposals : Raw_context.t -&gt; Lwt.t Raw_context.t.

Module ballots.
  Record record := {
    yay : int32;
    nay : int32;
    pass : int32 }.
End ballots.
Definition ballots := ballots.record.

Parameter ballots_encoding : Data_encoding.t ballots.

Parameter has_recorded_ballot :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t bool.

Parameter record_ballot :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Vote_repr.ballot -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_ballots : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult ballots).

Parameter get_ballot_list :
  Raw_context.t -&gt;
  Lwt.t
    (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * Vote_repr.ballot)).

Parameter clear_ballots : Raw_context.t -&gt; Lwt.t Raw_context.t.

Parameter listings_encoding :
  Data_encoding.t
    (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * int32)).

Parameter freeze_listings :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter clear_listings :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter listing_size : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int32).

Parameter in_listings :
  Raw_context.t -&gt; Signature.Public_key_hash.[S.SPublic_key_hash.t] -&gt;
  Lwt.t bool.

Parameter get_listings :
  Raw_context.t -&gt;
  Lwt.t (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * int32)).

Parameter get_current_quorum :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int32).

Parameter get_participation_ema :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int32).

Parameter set_participation_ema :
  Raw_context.t -&gt; int32 -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_current_period_kind :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Voting_period_repr.kind).

Parameter set_current_period_kind :
  Raw_context.t -&gt; Voting_period_repr.kind -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_current_proposal :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Protocol_hash.[S.HASH.t]).

Parameter init_current_proposal :
  Raw_context.t -&gt; Protocol_hash.[S.HASH.t] -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter clear_current_proposal :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_period_repr.ml">
  <div class="col-md-6">
    <a href="#voting_period_repr.ml"><code>voting_period_repr.ml</code></a>&nbsp;<span class="label label-danger">2 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = int32

type voting_period = t

include (Compare.Int32 : Compare.S with type t := t)

let encoding = Data_encoding.int32

let pp ppf level = Format.fprintf ppf &quot;%ld&quot; level

let rpc_arg =
  let construct voting_period = Int32.to_string voting_period in
  let destruct str =
    match Int32.of_string str with
    | exception <abbr class="mark-error" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">_</abbr> -&gt;
        Error &quot;Cannot parse voting period&quot;
    | voting_period -&gt;
        Ok voting_period
  in
  RPC_arg.make
    ~descr:&quot;A voting period&quot;
    ~name:&quot;voting_period&quot;
    ~construct
    ~destruct
    ()

let root = 0l

let succ = Int32.succ

let to_int32 l = l

let of_int32_exn l =
  if Compare.Int32.(l &gt;= 0l) then l
  else invalid_arg &quot;Voting_period_repr.of_int32&quot;

type kind = Proposal | Testing_vote | Testing | Promotion_vote

let kind_encoding =
  let open Data_encoding in
  union
    ~tag_size:<abbr class="mark-error" title="Variants not supported">`Uint8</abbr>
    [ case
        (Tag 0)
        ~title:&quot;Proposal&quot;
        (constant &quot;proposal&quot;)
        (function Proposal -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Proposal);
      case
        (Tag 1)
        ~title:&quot;Testing_vote&quot;
        (constant &quot;testing_vote&quot;)
        (function Testing_vote -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Testing_vote);
      case
        (Tag 2)
        ~title:&quot;Testing&quot;
        (constant &quot;testing&quot;)
        (function Testing -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Testing);
      case
        (Tag 3)
        ~title:&quot;Promotion_vote&quot;
        (constant &quot;promotion_vote&quot;)
        (function Promotion_vote -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Promotion_vote) ]
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_period_repr.ml"><code>Voting_period_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Definition t := int32.

Definition voting_period := t.

Definition op_eq := Compare.Int32.[Compare.S.op_eq].

Definition op_ltgt := Compare.Int32.[Compare.S.op_ltgt].

Definition op_lt := Compare.Int32.[Compare.S.op_lt].

Definition op_lteq := Compare.Int32.[Compare.S.op_lteq].

Definition op_gteq := Compare.Int32.[Compare.S.op_gteq].

Definition op_gt := Compare.Int32.[Compare.S.op_gt].

Definition compare := Compare.Int32.[Compare.S.compare].

Definition equal := Compare.Int32.[Compare.S.equal].

Definition max := Compare.Int32.[Compare.S.max].

Definition min := Compare.Int32.[Compare.S.min].

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition pp (ppf : Format.formatter) (level : int32) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%ld&quot; % string) level.

Definition rpc_arg : RPC_arg.arg int32 :=
  let construct (voting_period : int32) : string :=
    Int32.to_string voting_period in
  let destruct (str : string) : Pervasives.result int32 string :=
    let 'voting_period := Int32.of_string str in
    Pervasives.Ok voting_period in
  RPC_arg.make (Some &quot;A voting period&quot; % string) &quot;voting_period&quot; % string
    destruct construct tt.

Definition root : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ : int32 -&gt; int32 := Int32.succ.

Definition to_int32 {A : Set} (l : A) : A := l.

Definition of_int32_exn (l : Compare.Int32.[Compare.S.t])
  : Compare.Int32.[Compare.S.t] :=
  if
    Compare.Int32.[Compare.S.op_gteq] l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    l
  else
    Pervasives.invalid_arg &quot;Voting_period_repr.of_int32&quot; % string.

Inductive kind : Set :=
| Proposal : kind
| Testing_vote : kind
| Testing : kind
| Promotion_vote : kind.

Definition kind_encoding : Data_encoding.encoding kind :=
  Data_encoding.union
    (Some
      (* ‚ùå Variants not supported *)
      (* ‚ùå `Uint8 *)
      tt)
    (cons
      (Data_encoding.__case_value &quot;Proposal&quot; % string None (Data_encoding.Tag 0)
        (Data_encoding.constant &quot;proposal&quot; % string)
        (fun function_parameter =&gt;
          match function_parameter with
          | Proposal =&gt; Some tt
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let 'tt := function_parameter in
          Proposal))
      (cons
        (Data_encoding.__case_value &quot;Testing_vote&quot; % string None
          (Data_encoding.Tag 1) (Data_encoding.constant &quot;testing_vote&quot; % string)
          (fun function_parameter =&gt;
            match function_parameter with
            | Testing_vote =&gt; Some tt
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let 'tt := function_parameter in
            Testing_vote))
        (cons
          (Data_encoding.__case_value &quot;Testing&quot; % string None
            (Data_encoding.Tag 2) (Data_encoding.constant &quot;testing&quot; % string)
            (fun function_parameter =&gt;
              match function_parameter with
              | Testing =&gt; Some tt
              | _ =&gt; None
              end)
            (fun function_parameter =&gt;
              let 'tt := function_parameter in
              Testing))
          (cons
            (Data_encoding.__case_value &quot;Promotion_vote&quot; % string None
              (Data_encoding.Tag 3)
              (Data_encoding.constant &quot;promotion_vote&quot; % string)
              (fun function_parameter =&gt;
                match function_parameter with
                | Promotion_vote =&gt; Some tt
                | _ =&gt; None
                end)
              (fun function_parameter =&gt;
                let 'tt := function_parameter in
                Promotion_vote)) [])))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_period_repr.mli">
  <div class="col-md-6">
    <a href="#voting_period_repr.mli"><code>voting_period_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** A voting period can be of 4 kinds and is uniquely identified as a counter
    since the root. *)

type t

type voting_period = t

val encoding : voting_period Data_encoding.t

val rpc_arg : voting_period RPC_arg.arg

val pp : Format.formatter -&gt; voting_period -&gt; unit

include Compare.S with type t := voting_period

val to_int32 : voting_period -&gt; int32

val of_int32_exn : int32 -&gt; voting_period

val root : voting_period

val succ : voting_period -&gt; voting_period

type kind =
  | Proposal  (** protocols can be proposed *)
  | Testing_vote  (** a proposal can be voted *)
  | Testing  (** winning proposal is forked on a testnet *)
  | Promotion_vote  (** activation can be voted *)

val kind_encoding : kind Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_period_repr.mli"><code>Voting_period_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.

Parameter t : Set.

Definition voting_period := t.

Parameter encoding : Data_encoding.t voting_period.

Parameter rpc_arg : RPC_arg.arg voting_period.

Parameter pp : Format.formatter -&gt; voting_period -&gt; unit.

Parameter Included_S : {_ : unit &amp; Compare.S.signature voting_period}.

Definition op_eq := Included_S.[Compare.S.op_eq].

Definition op_ltgt := Included_S.[Compare.S.op_ltgt].

Definition op_lt := Included_S.[Compare.S.op_lt].

Definition op_lteq := Included_S.[Compare.S.op_lteq].

Definition op_gteq := Included_S.[Compare.S.op_gteq].

Definition op_gt := Included_S.[Compare.S.op_gt].

Definition compare := Included_S.[Compare.S.compare].

Definition equal := Included_S.[Compare.S.equal].

Definition max := Included_S.[Compare.S.max].

Definition min := Included_S.[Compare.S.min].

Parameter to_int32 : voting_period -&gt; int32.

Parameter of_int32_exn : int32 -&gt; voting_period.

Parameter root : voting_period.

Parameter succ : voting_period -&gt; voting_period.

Inductive kind : Set :=
| Proposal : kind
| Testing_vote : kind
| Testing : kind
| Promotion_vote : kind.

Parameter kind_encoding : Data_encoding.t kind.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_services.ml">
  <div class="col-md-6">
    <a href="#voting_services.ml"><code>voting_services.ml</code></a>&nbsp;<span class="label label-danger">104 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

module S = struct
  let path = RPC_path.(open_root / &quot;votes&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">ballots</abbr> =
    RPC_service.get_service
      ~description:&quot;Sum of ballots casted so far during a voting period.&quot;
      ~query:RPC_query.empty
      ~output:Vote.ballots_encoding
      RPC_path.(path / &quot;ballots&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">ballot_list</abbr> =
    RPC_service.get_service
      ~description:&quot;Ballots casted so far during a voting period.&quot;
      ~query:RPC_query.empty
      ~output:
        Data_encoding.(
          list
            (obj2
               (req &quot;pkh&quot; Signature.Public_key_hash.encoding)
               (req &quot;ballot&quot; Vote.ballot_encoding)))
      RPC_path.(path / &quot;ballot_list&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">current_period_kind</abbr> =
    RPC_service.get_service
      ~description:&quot;Current period kind.&quot;
      ~query:RPC_query.empty
      ~output:Voting_period.kind_encoding
      RPC_path.(path / &quot;current_period_kind&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">current_quorum</abbr> =
    RPC_service.get_service
      ~description:&quot;Current expected quorum.&quot;
      ~query:RPC_query.empty
      ~output:Data_encoding.int32
      RPC_path.(path / &quot;current_quorum&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">listings</abbr> =
    RPC_service.get_service
      ~description:
        &quot;List of delegates with their voting weight, in number of rolls.&quot;
      ~query:RPC_query.empty
      ~output:Vote.listings_encoding
      RPC_path.(path / &quot;listings&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">proposals</abbr> =
    RPC_service.get_service
      ~description:&quot;List of proposals with number of supporters.&quot;
      ~query:RPC_query.empty
      ~output:(Protocol_hash.Map.encoding Data_encoding.int32)
      RPC_path.(path / &quot;proposals&quot;)

  let <abbr class="mark-error" title="Polymorphic variant types are not handled">current_proposal</abbr> =
    RPC_service.get_service
      ~description:&quot;Current proposal under evaluation.&quot;
      ~query:RPC_query.empty
      ~output:(Data_encoding.option Protocol_hash.encoding)
      RPC_path.(path / &quot;current_proposal&quot;)
end

let register () =
  let open Services_registration in
  <abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.ballots (fun ctxt () () -&gt; Vote.get_ballots ctxt) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.ballot_list (fun ctxt () () -&gt; Vote.get_ballot_list ctxt &gt;|= ok) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.current_period_kind (fun ctxt () () -&gt;
      Vote.get_current_period_kind ctxt) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.current_quorum (fun ctxt () () -&gt; Vote.get_current_quorum ctxt) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.proposals (fun ctxt () () -&gt; Vote.get_proposals ctxt) ;
  </abbr><abbr class="mark-error" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.listings (fun ctxt () () -&gt; Vote.get_listings ctxt &gt;|= ok) ;
  register0 S.current_proposal (fun ctxt () () -&gt;
      (* this would be better implemented using get_option in get_current_proposal *)
      Vote.get_current_proposal ctxt
      &gt;&gt;= function
      | Ok p -&gt;
          return_some p
      | Error (Raw_context.Storage_error (Missing_key _) :: _) -&gt;
          return_none
      | Error _ as e -&gt;
          Lwt.return e)</abbr>

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">ballots</abbr> ctxt block = RPC_context.make_call0 S.ballots ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">ballot_list</abbr> ctxt block =
  RPC_context.make_call0 S.ballot_list ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">current_period_kind</abbr> ctxt block =
  RPC_context.make_call0 S.current_period_kind ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">current_quorum</abbr> ctxt block =
  RPC_context.make_call0 S.current_quorum ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">listings</abbr> ctxt block = RPC_context.make_call0 S.listings ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">proposals</abbr> ctxt block = RPC_context.make_call0 S.proposals ctxt block () ()

let <abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">current_proposal</abbr> ctxt block =
  RPC_context.make_call0 S.current_proposal ctxt block () ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_services.ml"><code>Voting_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Raw_context.
Require Tezos.Services_registration.

Import Alpha_context.

Module S.
  Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
    RPC_path.op_div RPC_path.open_root &quot;votes&quot; % string.
  
  Definition ballots
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context unit unit Alpha_context.Vote.ballots :=
    RPC_service.get_service
      (Some &quot;Sum of ballots casted so far during a voting period.&quot; % string)
      RPC_query.empty Alpha_context.Vote.ballots_encoding
      (RPC_path.op_div path &quot;ballots&quot; % string).
  
  Definition ballot_list
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context unit unit
      (list
        (Signature.Public_key_hash.[S.SPublic_key_hash.t] *
          Alpha_context.Vote.ballot)) :=
    RPC_service.get_service
      (Some &quot;Ballots casted so far during a voting period.&quot; % string)
      RPC_query.empty
      (Data_encoding.__list_value None
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;pkh&quot; % string
            Signature.Public_key_hash.[S.SPublic_key_hash.encoding])
          (Data_encoding.req None None &quot;ballot&quot; % string
            Alpha_context.Vote.ballot_encoding)))
      (RPC_path.op_div path &quot;ballot_list&quot; % string).
  
  Definition current_period_kind
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context unit unit Alpha_context.Voting_period.kind :=
    RPC_service.get_service (Some &quot;Current period kind.&quot; % string)
      RPC_query.empty Alpha_context.Voting_period.kind_encoding
      (RPC_path.op_div path &quot;current_period_kind&quot; % string).
  
  Definition current_quorum
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context unit unit int32 :=
    RPC_service.get_service (Some &quot;Current expected quorum.&quot; % string)
      RPC_query.empty Data_encoding.__int32_value
      (RPC_path.op_div path &quot;current_quorum&quot; % string).
  
  Definition listings
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context unit unit
      (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * int32)) :=
    RPC_service.get_service
      (Some
        &quot;List of delegates with their voting weight, in number of rolls.&quot; %
          string) RPC_query.empty Alpha_context.Vote.listings_encoding
      (RPC_path.op_div path &quot;listings&quot; % string).
  
  Definition proposals
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context unit unit
      (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.t) int32) :=
    RPC_service.get_service
      (Some &quot;List of proposals with number of supporters.&quot; % string)
      RPC_query.empty
      (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.encoding)
        Data_encoding.__int32_value) (RPC_path.op_div path &quot;proposals&quot; % string).
  
  Definition current_proposal
    : RPC_service.service (* `GET *) unit Updater.rpc_context
      Updater.rpc_context unit unit (option Protocol_hash.[S.HASH.t]) :=
    RPC_service.get_service (Some &quot;Current proposal under evaluation.&quot; % string)
      RPC_query.empty
      (Data_encoding.__option_value Protocol_hash.[S.HASH.encoding])
      (RPC_path.op_div path &quot;current_proposal&quot; % string).
End S.

Definition register (function_parameter : unit) : unit :=
  let 'tt := function_parameter in
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register0 S.current_proposal
    (fun ctxt =&gt;
      fun function_parameter =&gt;
        let 'tt := function_parameter in
        fun function_parameter =&gt;
          let 'tt := function_parameter in
          Error_monad.op_gtgteq (Alpha_context.Vote.get_current_proposal ctxt)
            (fun function_parameter =&gt;
              match function_parameter with
              | Pervasives.Ok p =&gt; Error_monad.return_some p
              |
                Pervasives.Error
                  (cons
                    (Error_monad.Storage_error (Raw_context.Missing_key _ _)) _)
                =&gt; Error_monad.return_none
              | (Pervasives.Error _) as e =&gt; Lwt.__return e
              end)).

Definition ballots {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Vote.ballots) :=
  RPC_context.make_call0 S.ballots ctxt block tt tt.

Definition ballot_list {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t
    (Error_monad.shell_tzresult
      (list
        (Signature.Public_key_hash.[S.SPublic_key_hash.t] *
          Alpha_context.Vote.ballot))) :=
  RPC_context.make_call0 S.ballot_list ctxt block tt tt.

Definition current_period_kind {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Voting_period.kind) :=
  RPC_context.make_call0 S.current_period_kind ctxt block tt tt.

Definition current_quorum {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t (Error_monad.shell_tzresult int32) :=
  RPC_context.make_call0 S.current_quorum ctxt block tt tt.

Definition listings {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t
    (Error_monad.shell_tzresult
      (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * int32))) :=
  RPC_context.make_call0 S.listings ctxt block tt tt.

Definition proposals {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t
    (Error_monad.shell_tzresult
      (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.t) int32)) :=
  RPC_context.make_call0 S.proposals ctxt block tt tt.

Definition current_proposal {D E G I K L a b c i o q : Set}
  (ctxt :
    (((RPC_service.t
      ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
        (* `POST *) unit + (* `PUT *) unit) RPC_context.t RPC_context.t q i o -&gt;
    D -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
      (((RPC_service.t
        ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
          (* `POST *) unit + (* `PUT *) unit) RPC_context.t (RPC_context.t * a)
        q i o -&gt; D -&gt; a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
        (G * a * q * i * o)) *
        (((RPC_service.t
          ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
            (* `POST *) unit + (* `PUT *) unit) RPC_context.t
          ((RPC_context.t * a) * b) q i o -&gt; D -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (I * a * b * q * i * o)) *
          (((RPC_service.t
            ((* `DELETE *) unit + (* `GET *) unit + (* `PATCH *) unit +
              (* `POST *) unit + (* `PUT *) unit) RPC_context.t
            (((RPC_context.t * a) * b) * c) q i o -&gt; D -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o)) *
            (K * a * b * c * q * i * o)) * L)))) * L * D) (block : D)
  : Lwt.t (Error_monad.shell_tzresult (option Protocol_hash.[S.HASH.t])) :=
  RPC_context.make_call0 S.current_proposal ctxt block tt tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_services.mli">
  <div class="col-md-6">
    <a href="#voting_services.mli"><code>voting_services.mli</code></a>&nbsp;<span class="label label-danger">91 errors</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val ballots : 'a #RPC_context.simple -&gt; 'a -&gt; Vote.ballots shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val ballot_list :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  (Signature.Public_key_hash.t * Vote.ballot) list shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val current_period_kind :
  'a #RPC_context.simple -&gt; 'a -&gt; Voting_period.kind shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val current_quorum :
  'a #RPC_context.simple -&gt; 'a -&gt; Int32.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val listings :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  (Signature.Public_key_hash.t * int32) list shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val proposals :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Int32.t Protocol_hash.Map.t shell_tzresult Lwt.t</abbr>

<abbr class="mark-error" title="Object types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Field types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Forall quantifier is not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Polymorphic variant types are not handled">val current_proposal :
  'a #RPC_context.simple -&gt; 'a -&gt; Protocol_hash.t option shell_tzresult Lwt.t</abbr>

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_services.mli"><code>Voting_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.

Parameter ballots : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Vote.ballots).

Parameter ballot_list : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list
        (Signature.Public_key_hash.[S.SPublic_key_hash.t] *
          Alpha_context.Vote.ballot))).

Parameter current_period_kind : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Voting_period.kind).

Parameter current_quorum : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt; Lwt.t (Error_monad.shell_tzresult Int32.t).

Parameter listings : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list (Signature.Public_key_hash.[S.SPublic_key_hash.t] * int32))).

Parameter proposals : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (Protocol_hash.[S.HASH.Map].(S.INDEXES_Map.t) Int32.t)).

Parameter current_proposal : forall {E F H J K a b c i o q : Set},
  (((RPC_service.t
    ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit +
      (* `PATCH *) unit) RPC_context.t RPC_context.t q i o -&gt; a -&gt; q -&gt; i -&gt;
  Lwt.t (Error_monad.shell_tzresult o)) * (E * q * i * o)) *
    (((RPC_service.t
      ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit + (* `POST *) unit
        + (* `PATCH *) unit) RPC_context.t (RPC_context.t * a) q i o -&gt; a -&gt;
    a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o)) * (F * a * q * i * o))
      *
      (((RPC_service.t
        ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
          (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
        ((RPC_context.t * a) * b) q i o -&gt; a -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
      Lwt.t (Error_monad.shell_tzresult o)) * (H * a * b * q * i * o)) *
        (((RPC_service.t
          ((* `PUT *) unit + (* `GET *) unit + (* `DELETE *) unit +
            (* `POST *) unit + (* `PATCH *) unit) RPC_context.t
          (((RPC_context.t * a) * b) * c) q i o -&gt; a -&gt; a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
        Lwt.t (Error_monad.shell_tzresult o)) * (J * a * b * c * q * i * o)) * K))))
    * K * a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Protocol_hash.[S.HASH.t])).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

      </div>
      <hr/>
      <div class="footer" style="margin-bottom: 40px;">
        <p class="text-center">
          <small>Sources are on <a href="https://github.com/clarus/coq-of-ocaml">GitHub</a>. ¬© Guillaume Claret.</small>
        </p>
      </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/favicon.js"></script>
  </body>
</html>

