<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>coq-of-ocaml – Examples</title>
    <link rel="shortcut icon" href="../img/favicon.ico">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/custom.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container-fluid" style="overflow: hidden;">
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-list" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../">
              <img alt="logo" height="24px" src="../img/favicon.ico" />
              coq-of-ocaml <span class="hidden-xs">- Examples</span></a>
          </div>

          <div class="collapse navbar-collapse" id="navbar-collapse-list">
            <ul class="nav navbar-nav">
              <li class="active"><a href="../kernel/">Kernel of Coq</a></li>
              <li ><a href="../tezos/">Protocol of Tezos</a></li>
              <li ><a href="../tezos-interface/">Interface of Tezos</a></li>
              <li><a href="https://clarus.github.io/coq-of-ocaml/">Home</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="article">

<div class="row center-block not-full-width">
  <div class="col-md-12">
        <h2>
      Kernel of Coq in&nbsp;Coq
      <small>
      <span class="label label-danger">Does not compile</span>
      </small>
    </h2>
    <p>This is a demo of the current development version of <a href="https://github.com/clarus/coq-of-ocaml">coq-of-ocaml</a> on the <a href="https://github.com/coq/coq/tree/master/kernel">kernel</a> of <a =href="https://coq.inria.fr/">Coq</a>. Coq is written in <a =href="https://ocaml.org/">OCaml</a>.</p>
    

    <p>We show the original&nbsp;<a href="https://ocaml.org/">OCaml</a> code on the left and the imported&nbsp;<a href="https://coq.inria.fr/">Coq</a> code on the right. The imported code does not necessarily compile. Warnings reported on the&nbsp;OCaml side are due to either various incompleteness in our tool, or to side-effects in the source code. Go on the <a href="https://gitter.im/clarus/coq-of-ocaml">Gitter chat</a> for more information. Work currently made at <a href="https://www.nomadic-labs.com/">Nomadic Labs</a>.</p>
    <p>To install the latest development version of <a href="https://clarus.github.io/coq-of-ocaml/">coq-of-ocaml</a> with <a href="https://opam.ocaml.org/">opam</a>:</p>
    <pre><code>opam repo add coq-released https://coq.inria.fr/opam/released
opam pin add https://github.com/clarus/coq-of-ocaml.git#master</code></pre>
    <ul>
      <li>OCaml size: 30556 lines</li>
      <li>Coq size: 41317 lines (+35% compared to&nbsp;OCaml)</li>
      <li>Warnings from coq-of-ocaml: 1359</li>
    </ul>
    
  </div>
</div>

<hr />
<div class="row" style="margin: 20px;">
  <h3>List of files</h3>
  <p>We add the warnings from coq-of-ocaml as annotations. They are not necessarly related to compilation bugs of the generated Coq files. These warnings are either due to unsupported features in coq-of-ocaml or to side-effects in the source code.</p>
  
  
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#cClosure.ml">cClosure.ml</a>&nbsp;<span class="label label-warning">124</span>
      </li>
      
      <li>
        <a href="#cClosure.mli">cClosure.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#cPrimitives.ml">cPrimitives.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#cPrimitives.mli">cPrimitives.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#cbytecodes.ml">cbytecodes.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#cbytecodes.mli">cbytecodes.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#cbytegen.ml">cbytegen.ml</a>&nbsp;<span class="label label-warning">44</span>
      </li>
      
      <li>
        <a href="#cbytegen.mli">cbytegen.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#cemitcodes.ml">cemitcodes.ml</a>&nbsp;<span class="label label-warning">92</span>
      </li>
      
      <li>
        <a href="#cemitcodes.mli">cemitcodes.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#clambda.ml">clambda.ml</a>&nbsp;<span class="label label-warning">43</span>
      </li>
      
      <li>
        <a href="#clambda.mli">clambda.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#constr.mli">constr.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#context.ml">context.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#context.mli">context.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#conv_oracle.ml">conv_oracle.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#conv_oracle.mli">conv_oracle.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#cooking.ml">cooking.ml</a>&nbsp;<span class="label label-warning">21</span>
      </li>
      
      <li>
        <a href="#cooking.mli">cooking.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#copcodes.ml">copcodes.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#csymtable.ml">csymtable.ml</a>&nbsp;<span class="label label-warning">29</span>
      </li>
      
      <li>
        <a href="#csymtable.mli">csymtable.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#declarations.ml">declarations.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#declareops.ml">declareops.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#declareops.mli">declareops.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#entries.ml">entries.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#environ.ml">environ.ml</a>&nbsp;<span class="label label-warning">14</span>
      </li>
      
      <li>
        <a href="#environ.mli">environ.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#esubst.ml">esubst.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#esubst.mli">esubst.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#evar.ml">evar.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#evar.mli">evar.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#genOpcodeFiles.ml">genOpcodeFiles.ml</a>&nbsp;<span class="label label-warning">9</span>
      </li>
      
      <li>
        <a href="#indTyping.ml">indTyping.ml</a>&nbsp;<span class="label label-warning">14</span>
      </li>
      
    </ul>
  </div>
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#indTyping.mli">indTyping.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#indtypes.ml">indtypes.ml</a>&nbsp;<span class="label label-warning">28</span>
      </li>
      
      <li>
        <a href="#indtypes.mli">indtypes.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#inductive.ml">inductive.ml</a>&nbsp;<span class="label label-warning">87</span>
      </li>
      
      <li>
        <a href="#inductive.mli">inductive.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#mod_subst.ml">mod_subst.ml</a>&nbsp;<span class="label label-warning">26</span>
      </li>
      
      <li>
        <a href="#mod_subst.mli">mod_subst.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#mod_typing.ml">mod_typing.ml</a>&nbsp;<span class="label label-warning">13</span>
      </li>
      
      <li>
        <a href="#mod_typing.mli">mod_typing.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#modops.ml">modops.ml</a>&nbsp;<span class="label label-warning">20</span>
      </li>
      
      <li>
        <a href="#modops.mli">modops.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#names.ml">names.ml</a>&nbsp;<span class="label label-warning">31</span>
      </li>
      
      <li>
        <a href="#names.mli">names.mli</a>&nbsp;<span class="label label-warning">11</span>
      </li>
      
      <li>
        <a href="#nativecode.ml">nativecode.ml</a>&nbsp;<span class="label label-warning">150</span>
      </li>
      
      <li>
        <a href="#nativecode.mli">nativecode.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#nativeconv.ml">nativeconv.ml</a>&nbsp;<span class="label label-warning">21</span>
      </li>
      
      <li>
        <a href="#nativeconv.mli">nativeconv.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#nativelambda.ml">nativelambda.ml</a>&nbsp;<span class="label label-warning">26</span>
      </li>
      
      <li>
        <a href="#nativelambda.mli">nativelambda.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#nativelib.ml">nativelib.ml</a>&nbsp;<span class="label label-warning">12</span>
      </li>
      
      <li>
        <a href="#nativelib.mli">nativelib.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#nativelibrary.ml">nativelibrary.ml</a>&nbsp;<span class="label label-warning">8</span>
      </li>
      
      <li>
        <a href="#nativelibrary.mli">nativelibrary.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#nativevalues.ml">nativevalues.ml</a>&nbsp;<span class="label label-warning">8</span>
      </li>
      
      <li>
        <a href="#nativevalues.mli">nativevalues.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#opaqueproof.ml">opaqueproof.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#opaqueproof.mli">opaqueproof.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#primred.ml">primred.ml</a>&nbsp;<span class="label label-warning">8</span>
      </li>
      
      <li>
        <a href="#primred.mli">primred.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#reduction.ml">reduction.ml</a>&nbsp;<span class="label label-warning">76</span>
      </li>
      
      <li>
        <a href="#reduction.mli">reduction.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#retroknowledge.ml">retroknowledge.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#retroknowledge.mli">retroknowledge.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#retypeops.ml">retypeops.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
    </ul>
  </div>
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#retypeops.mli">retypeops.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#safe_typing.ml">safe_typing.ml</a>&nbsp;<span class="label label-warning">95</span>
      </li>
      
      <li>
        <a href="#safe_typing.mli">safe_typing.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#sorts.ml">sorts.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#sorts.mli">sorts.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#subtyping.ml">subtyping.ml</a>&nbsp;<span class="label label-warning">15</span>
      </li>
      
      <li>
        <a href="#subtyping.mli">subtyping.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#term.ml">term.ml</a>&nbsp;<span class="label label-warning">8</span>
      </li>
      
      <li>
        <a href="#term.mli">term.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#term_typing.ml">term_typing.ml</a>&nbsp;<span class="label label-warning">25</span>
      </li>
      
      <li>
        <a href="#term_typing.mli">term_typing.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#transparentState.ml">transparentState.ml</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#transparentState.mli">transparentState.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#type_errors.ml">type_errors.ml</a>&nbsp;<span class="label label-warning">22</span>
      </li>
      
      <li>
        <a href="#type_errors.mli">type_errors.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#typeops.ml">typeops.ml</a>&nbsp;<span class="label label-warning">36</span>
      </li>
      
      <li>
        <a href="#typeops.mli">typeops.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#uGraph.ml">uGraph.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#uGraph.mli">uGraph.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#uint63.ml">uint63.ml</a>&nbsp;<span class="label label-warning">16</span>
      </li>
      
      <li>
        <a href="#uint63.mli">uint63.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#uint63_amd64.ml">uint63_amd64.ml</a>&nbsp;<span class="label label-warning">16</span>
      </li>
      
      <li>
        <a href="#uint63_x86.ml">uint63_x86.ml</a>&nbsp;<span class="label label-warning">24</span>
      </li>
      
      <li>
        <a href="#univ.ml">univ.ml</a>&nbsp;<span class="label label-warning">22</span>
      </li>
      
      <li>
        <a href="#univ.mli">univ.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#vars.ml">vars.ml</a>&nbsp;<span class="label label-warning">25</span>
      </li>
      
      <li>
        <a href="#vars.mli">vars.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#vconv.ml">vconv.ml</a>&nbsp;<span class="label label-warning">25</span>
      </li>
      
      <li>
        <a href="#vconv.mli">vconv.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#vm.ml">vm.ml</a>&nbsp;<span class="label label-warning">25</span>
      </li>
      
      <li>
        <a href="#vm.mli">vm.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#vmvalues.ml">vmvalues.ml</a>&nbsp;<span class="label label-warning">40</span>
      </li>
      
      <li>
        <a href="#vmvalues.mli">vmvalues.mli</a>&nbsp;<span class="label label-success">✓</span>
      </li>
      
      <li>
        <a href="#write_uint63.ml">write_uint63.ml</a>&nbsp;<span class="label label-warning">8</span>
      </li>
      
    </ul>
  </div>
  
</div>


<hr />
<div class="row conversion-row" id="cClosure.ml">
  <div style="margin: 20px;">
    <h3>CClosure</h3>
    <ul>
      <li>OCaml size: 1333 lines</li>
      <li>Coq size: 2015 lines (+51% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cClosure.ml"><code>cClosure.ml</code></a>&nbsp;<span class="label label-warning">124 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras with Benjamin Werner's account to implement
   a call-by-value conversion algorithm and a lazy reduction machine
   with sharing, Nov 1996 *)
(* Addition of zeta-reduction (let-in contraction) by Hugo Herbelin, Oct 2000 *)
(* Call-by-value machine moved to cbv.ml, Mar 01 *)
(* Additional tools for module subtyping by Jacek Chrzaszcz, Aug 2002 *)
(* Extension with closure optimization by Bruno Barras, Aug 2003 *)
(* Support for evar reduction by Bruno Barras, Feb 2009 *)
(* Miscellaneous other improvements by Bruno Barras, 1997-2009 *)

(* This file implements a lazy reduction for the Calculus of Inductive
   Constructions *)

[@@@ocaml.warning &quot;+4&quot;]

open CErrors
open Util
open Pp
open Names
open Constr
open Declarations
open Context
open Environ
open Vars
open Esubst

let stats = ref false

(* Profiling *)
let beta = ref 0
let delta = ref 0
let eta = ref 0
let zeta = ref 0
let evar = ref 0
let nb_match = ref 0
let fix = ref 0
let cofix = ref 0
let prune = ref 0

let reset () =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">beta := 0; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">delta := 0; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">zeta := 0; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">evar := 0; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">nb_match := 0; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fix := 0;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">cofix := 0; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">evar := 0; prune := 0</abbr>

let stop() =
  Feedback.msg_debug (str &quot;[Reds: beta=&quot; ++ int !beta ++ str&quot; delta=&quot; ++ int !delta ++
         str &quot; eta=&quot; ++ int !eta ++ str&quot; zeta=&quot; ++ int !zeta ++ str&quot; evar=&quot; ++
         int !evar ++ str&quot; match=&quot; ++ int !nb_match ++ str&quot; fix=&quot; ++ int !fix ++
         str &quot; cofix=&quot; ++ int !cofix ++ str&quot; prune=&quot; ++ int !prune ++
         str&quot;]&quot;)

let incr_cnt red cnt =
  if red then <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
    if !stats then incr cnt;
    true
  end</abbr> else
    false

let with_stats c =
  if !stats then <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
    reset();
    let r = Lazy.force c in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">stop();
    r</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  end</abbr> else
    Lazy.force c

let all_opaque = TransparentState.empty
let all_transparent = TransparentState.full

module type RedFlagsSig = sig
  type reds
  type red_kind
  val fBETA : red_kind
  val fDELTA : red_kind
  val fETA : red_kind
  val fMATCH : red_kind
  val fFIX : red_kind
  val fCOFIX : red_kind
  val fZETA : red_kind
  val fCONST : Constant.t -&gt; red_kind
  val fVAR : Id.t -&gt; red_kind
  val no_red : reds
  val red_add : reds -&gt; red_kind -&gt; reds
  val red_sub : reds -&gt; red_kind -&gt; reds
  val red_add_transparent : reds -&gt; TransparentState.t -&gt; reds
  val red_transparent : reds -&gt; TransparentState.t
  val mkflags : red_kind list -&gt; reds
  val red_set : reds -&gt; red_kind -&gt; bool
  val red_projection : reds -&gt; Projection.t -&gt; bool
end

module RedFlags : RedFlagsSig = struct

  (* [r_const=(true,cl)] means all constants but those in [cl] *)
  (* [r_const=(false,cl)] means only those in [cl] *)
  (* [r_delta=true] just mean [r_const=(true,[])] *)

  <abbr class="mark-warning" title="Open not handled in module with a named signature">open TransparentState</abbr>

  <abbr class="mark-warning" title="Only type synonyms are handled here">type reds = {
    r_beta : bool;
    r_delta : bool;
    r_eta : bool;
    r_const : TransparentState.t;
    r_zeta : bool;
    r_match : bool;
    r_fix : bool;
    r_cofix : bool }</abbr>

  <abbr class="mark-warning" title="Only type synonyms are handled here">type red_kind = BETA | DELTA | ETA | MATCH | FIX
              | COFIX | ZETA
              | CONST of Constant.t | VAR of Id.t</abbr>
  let fBETA = BETA
  let fDELTA = DELTA
  let fETA = ETA
  let fMATCH = MATCH
  let fFIX = FIX
  let fCOFIX = COFIX
  let fZETA = ZETA
  let fCONST kn  = CONST kn
  let fVAR id  = VAR id
  let no_red = {
    r_beta = false;
    r_delta = false;
    r_eta = false;
    r_const = all_opaque;
    r_zeta = false;
    r_match = false;
    r_fix = false;
    r_cofix = false }

  let red_add red = function
    | BETA -&gt; { red with r_beta = true }
    | ETA -&gt; { red with r_eta = true }
    | DELTA -&gt; { red with r_delta = true; r_const = all_transparent }
    | CONST kn -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_cst = Cpred.add kn r.tr_cst } }
    | MATCH -&gt; { red with r_match = true }
    | FIX -&gt; { red with r_fix = true }
    | COFIX -&gt; { red with r_cofix = true }
    | ZETA -&gt; { red with r_zeta = true }
    | VAR id -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_var = Id.Pred.add id r.tr_var } }

  let red_sub red = function
    | BETA -&gt; { red with r_beta = false }
    | ETA -&gt; { red with r_eta = false }
    | DELTA -&gt; { red with r_delta = false }
    | CONST kn -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_cst = Cpred.remove kn r.tr_cst } }
    | MATCH -&gt; { red with r_match = false }
    | FIX -&gt; { red with r_fix = false }
    | COFIX -&gt; { red with r_cofix = false }
    | ZETA -&gt; { red with r_zeta = false }
    | VAR id -&gt;
      let r = red.r_const in
      { red with r_const = { r with tr_var = Id.Pred.remove id r.tr_var } }

  let red_transparent red = red.r_const

  let red_add_transparent red tr =
    { red with r_const = tr }

  let mkflags = List.fold_left red_add no_red

  let red_set red = function
    | BETA -&gt; incr_cnt red.r_beta beta
    | ETA -&gt; incr_cnt red.r_eta eta
    | CONST kn -&gt;
      let c = is_transparent_constant red.r_const kn in
        incr_cnt c delta
    | VAR id -&gt; (* En attendant d'avoir des kn pour les Var *)
      let c = is_transparent_variable red.r_const id in
        incr_cnt c delta
    | ZETA -&gt; incr_cnt red.r_zeta zeta
    | MATCH -&gt; incr_cnt red.r_match nb_match
    | FIX -&gt; incr_cnt red.r_fix fix
    | COFIX -&gt; incr_cnt red.r_cofix cofix
    | DELTA -&gt; (* Used for Rel/Var defined in context *)
        incr_cnt red.r_delta delta

  let red_projection red p =
    if Projection.unfolded p then true
    else red_set red (fCONST (Projection.constant p))

end

open RedFlags

let all = mkflags [fBETA;fDELTA;fZETA;fMATCH;fFIX;fCOFIX]
let allnolet = mkflags [fBETA;fDELTA;fMATCH;fFIX;fCOFIX]
let beta = mkflags [fBETA]
let betadeltazeta = mkflags [fBETA;fDELTA;fZETA]
let betaiota = mkflags [fBETA;fMATCH;fFIX;fCOFIX]
let betaiotazeta = mkflags [fBETA;fMATCH;fFIX;fCOFIX;fZETA]
let betazeta = mkflags [fBETA;fZETA]
let delta = mkflags [fDELTA]
let zeta = mkflags [fZETA]
let nored = no_red

(* Removing fZETA for finer behaviour would break many developments *)
let unfold_side_flags = [fBETA;fMATCH;fFIX;fCOFIX;fZETA]
let unfold_side_red = mkflags [fBETA;fMATCH;fFIX;fCOFIX;fZETA]
let unfold_red kn =
  let flag = match kn with
    | EvalVarRef id -&gt; fVAR id
    | EvalConstRef kn -&gt; fCONST kn in
  mkflags (flag::unfold_side_flags)

(* Flags of reduction and cache of constants: 'a is a type that may be
 * mapped to constr. 'a infos implements a cache for constants and
 * abstractions, storing a representation (of type 'a) of the body of
 * this constant or abstraction.
 *  * i_tab is the cache table of the results
 *
 * ref_value_cache searches in the tab, otherwise uses i_repr to
 * compute the result and store it in the table. If the constant can't
 * be unfolded, returns None, but does not store this failure.  * This
 * doesn't take the RESET into account. You mustn't keep such a table
 * after a Reset.  * This type is not exported. Only its two
 * instantiations (cbv or lazy) are.
 *)

type table_key = Constant.t Univ.puniverses tableKey

let eq_pconstant_key (c,u) (c',u') =
  eq_constant_key c c' &amp;&amp; Univ.Instance.equal u u'

module IdKeyHash =
struct
  open Hashset.Combine
  type t = table_key
  let equal = Names.eq_table_key eq_pconstant_key
  let hash = function
  | ConstKey (c, _) -&gt; combinesmall 1 (Constant.UserOrd.hash c)
  | VarKey id -&gt; combinesmall 2 (Id.hash id)
  | RelKey i -&gt; combinesmall 3 (Int.hash i)
end

module KeyTable = Hashtbl.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">IdKeyHash</abbr>)

open Context.Named.Declaration

let assoc_defined id env = match Environ.lookup_named id env with
| LocalDef (_, c, _) -&gt; c
| LocalAssum _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

(**********************************************************************)
(* Lazy reduction: the one used in kernel operations                  *)

(* type of shared terms. fconstr and frterm are mutually recursive.
 * Clone of the constr structure, but completely mutable, and
 * annotated with reduction state (reducible or not).
 *  - FLIFT is a delayed shift; allows sharing between 2 lifted copies
 *    of a given term.
 *  - FCLOS is a delayed substitution applied to a constr
 *  - FLOCKED is used to erase the content of a reference that must
 *    be updated. This is to allow the garbage collector to work
 *    before the term is computed.
 *)

(* Norm means the term is fully normalized and cannot create a redex
     when substituted
   Cstr means the term is in head normal form and that it can
     create a redex when substituted (i.e. constructor, fix, lambda)
   Whnf means we reached the head normal form and that it cannot
     create a redex when substituted
   Red is used for terms that might be reduced
*)
type red_state = Norm | Cstr | Whnf | Red

let neutr = function
  | Whnf|Norm -&gt; Whnf
  | Red|Cstr -&gt; Red

type optrel = Unknown | KnownR | KnownI

let opt_of_rel = function
  | Sorts.Relevant -&gt; KnownR
  | Sorts.Irrelevant -&gt; KnownI

module Mark : sig

  type t

  val mark : red_state -&gt; optrel -&gt; t
  val relevance : t -&gt; optrel
  val red_state : t -&gt; red_state

  val neutr : t -&gt; t

  val set_norm : t -&gt; t

end = struct
  type t = int

  let[@inline] of_state = function
    | Norm -&gt; 0b00 | Cstr -&gt; 0b01 | Whnf -&gt; 0b10 | Red -&gt; 0b11

  let[@inline] of_relevance = function
    | Unknown -&gt; 0
    | KnownR -&gt; 0b01
    | KnownI -&gt; 0b10

  let[@inline] mark state relevance = (of_state state) * 4 + (of_relevance relevance)

  let[@inline] relevance x = match x land 0b11 with
    | 0b00 -&gt; Unknown
    | 0b01 -&gt; KnownR
    | 0b10 -&gt; KnownI
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

  let[@inline] red_state x = match x land 0b1100 with
    | 0b0000 -&gt; Norm
    | 0b0100 -&gt; Cstr
    | 0b1000 -&gt; Whnf
    | 0b1100 -&gt; Red
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

  let[@inline] neutr x = x lor 0b1000 (* Whnf|Norm -&gt; Whnf | Red|Cstr -&gt; Red *)

  let[@inline] set_norm x = x land 0b0011
end
let mark = Mark.mark

type fconstr = {
  mutable mark : Mark.t;
  mutable term: fterm;
}

and fterm =
  | FRel of int
  | FAtom of constr (* Metas and Sorts *)
  | FFlex of table_key
  | FInd of pinductive
  | FConstruct of pconstructor
  | FApp of fconstr * fconstr array
  | FProj of Projection.t * fconstr
  | FFix of fixpoint * fconstr subs
  | FCoFix of cofixpoint * fconstr subs
  | FCaseT of case_info * constr * fconstr * constr array * fconstr subs (* predicate and branches are closures *)
  | FLambda of int * (Name.t Context.binder_annot * constr) list * constr * fconstr subs
  | FProd of Name.t Context.binder_annot * fconstr * constr * fconstr subs
  | FLetIn of Name.t Context.binder_annot * fconstr * fconstr * constr * fconstr subs
  | FEvar of existential * fconstr subs
  | FInt of Uint63.t
  | FLIFT of int * fconstr
  | FCLOS of constr * fconstr subs
  | FLOCKED

let fterm_of v = v.term
let set_norm v = <abbr class="mark-warning" title="Set record field not handled.">v.mark &lt;- Mark.set_norm v.mark</abbr>
let is_val v = match Mark.red_state v.mark with Norm -&gt; true | Cstr | Whnf | Red -&gt; false

let mk_atom c = {mark=mark Norm Unknown;term=FAtom c}
let mk_red f = {mark=mark Red Unknown;term=f}

(* Could issue a warning if no is still Red, pointing out that we loose
   sharing. *)
let update ~share v1 mark t =
  if share then
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(v1.mark &lt;- mark;
     </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">v1.term &lt;- t;
     v1</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)</abbr>
  else {mark;term=t;}

(** Reduction cache *)

type infos_cache = {
  i_env : env;
  i_sigma : existential -&gt; constr option;
  i_share : bool;
}

type clos_infos = {
  i_flags : reds;
  i_cache : infos_cache }

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">type clos_tab = fconstr constant_def KeyTable.t</abbr>

let info_flags info = info.i_flags
let info_env info = info.i_cache.i_env

(**********************************************************************)
(* The type of (machine) stacks (= lambda-bar-calculus' contexts)     *)
type 'a next_native_args = (CPrimitives.arg_kind * 'a) list

type stack_member =
  | Zapp of fconstr array
  | ZcaseT of case_info * constr * constr array * fconstr subs
  | Zproj of Projection.Repr.t
  | Zfix of fconstr * stack
  | Zprimitive of CPrimitives.t * pconstant * fconstr list * fconstr next_native_args
       (* operator, constr def, arguments already seen (in rev order), next arguments *)
  | Zshift of int
  | Zupdate of fconstr

and stack = stack_member list

let empty_stack = []
let append_stack v s =
  if Int.equal (Array.length v) 0 then s else
  match s with
  | Zapp l :: s -&gt; Zapp (Array.append v l) :: s
  | (ZcaseT _ | Zproj _ | Zfix _ | Zshift _ | Zupdate _ | Zprimitive _) :: _ | [] -&gt;
    Zapp v :: s

(* Collapse the shifts in the stack *)
let zshift n s =
  match (n,s) with
      (0,_) -&gt; s
    | (_,Zshift(k)::s) -&gt; Zshift(n+k)::s
    | (_,(ZcaseT _ | Zproj _ | Zfix _ | Zapp _ | Zupdate _ | Zprimitive _) :: _) | _,[] -&gt; Zshift(n)::s

let rec stack_args_size = function
  | Zapp v :: s -&gt; Array.length v + stack_args_size s
  | Zshift(_)::s -&gt; stack_args_size s
  | Zupdate(_)::s -&gt; stack_args_size s
  | (ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | [] -&gt; 0

(* Lifting. Preserves sharing (useful only for cell with norm=Red).
   lft_fconstr always create a new cell, while lift_fconstr avoids it
   when the lift is 0. *)
let rec lft_fconstr n ft =
  let r = Mark.relevance ft.mark in
  match ft.term with
    | (FInd _|FConstruct _|FFlex(ConstKey _|VarKey _)|FInt _) -&gt; ft
    | FRel i -&gt; {mark=mark Norm r;term=FRel(i+n)}
    | FLambda(k,tys,f,e) -&gt; {mark=mark Cstr r; term=FLambda(k,tys,f,subs_shft(n,e))}
    | FFix(fx,e) -&gt;
      {mark=mark Cstr r; term=FFix(fx,subs_shft(n,e))}
    | FCoFix(cfx,e) -&gt;
      {mark=mark Cstr r; term=FCoFix(cfx,subs_shft(n,e))}
    | FLIFT(k,m) -&gt; lft_fconstr (n+k) m
    | FLOCKED -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    | FFlex (RelKey _) | FAtom _ | FApp _ | FProj _ | FCaseT _ | FProd _
      | FLetIn _ | FEvar _ | FCLOS _ -&gt; {mark=ft.mark; term=FLIFT(n,ft)}
let lift_fconstr k f =
  if Int.equal k 0 then f else lft_fconstr k f
let lift_fconstr_vect k v =
  if Int.equal k 0 then v else Array.Fun1.map lft_fconstr k v

let clos_rel e i =
  match expand_rel i e with
    | Inl(n,mt) -&gt; lift_fconstr n mt
    | Inr(k,None) -&gt; {mark=mark Norm Unknown; term= FRel k}
    | Inr(k,Some p) -&gt;
        lift_fconstr (k-p) {mark=mark Red Unknown;term=FFlex(RelKey p)}

(* since the head may be reducible, we might introduce lifts of 0 *)
let compact_stack head stk =
  let rec strip_rec depth = function
    | Zshift(k)::s -&gt; strip_rec (depth+k) s
    | Zupdate(m)::s -&gt;
        (* Be sure to create a new cell otherwise sharing would be
           lost by the update operation *)
        let h' = lft_fconstr depth head in
        (** The stack contains [Zupdate] marks only if in sharing mode *)
        let _ = update ~share:true m h'.mark h'.term in
        strip_rec depth s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zapp _ | Zprimitive _) :: _ | []) as stk -&gt; zshift depth stk
  in
  strip_rec 0 stk

(* Put an update mark in the stack, only if needed *)
let zupdate info m s =
  let share = info.i_cache.i_share in
  if share &amp;&amp; begin match Mark.red_state m.mark with Red -&gt; true  | Norm | Whnf | Cstr -&gt; false end
  then
    let s' = compact_stack m s in
    let _ = <abbr class="mark-warning" title="Set record field not handled.">m.term &lt;- FLOCKED</abbr> in
    Zupdate(m)::s'
  else s

let mk_lambda env t =
  let (rvars,t') = Term.decompose_lam t in
  FLambda(List.length rvars, List.rev rvars, t', env)

let destFLambda clos_fun t =
  match [@ocaml.warning &quot;-4&quot;] t.term with
      FLambda(_,[(na,ty)],b,e) -&gt; (na,clos_fun e ty,clos_fun (subs_lift e) b)
    | FLambda(n,(na,ty)::tys,b,e) -&gt;
        (na,clos_fun e ty,{mark=t.mark;term=FLambda(n-1,tys,b,subs_lift e)})
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
        (* t must be a FLambda and binding list cannot be empty *)

(* Optimization: do not enclose variables in a closure.
   Makes variable access much faster *)
let mk_clos e t =
  match kind t with
    | Rel i -&gt; clos_rel e i
    | Var x -&gt; {mark = mark Red Unknown; term = FFlex (VarKey x) }
    | Const c -&gt; {mark = mark Red Unknown; term = FFlex (ConstKey c) }
    | Meta _ | Sort _ -&gt;  {mark = mark Norm KnownR; term = FAtom t }
    | Ind kn -&gt; {mark = mark Norm KnownR; term = FInd kn }
    | Construct kn -&gt; {mark = mark Cstr Unknown; term = FConstruct kn }
    | Int i -&gt; {mark = mark Cstr Unknown; term = FInt i}
    | (CoFix _|Lambda _|Fix _|Prod _|Evar _|App _|Case _|Cast _|LetIn _|Proj _) -&gt;
        {mark = mark Red Unknown; term = FCLOS(t,e)}

let inject c = mk_clos (subs_id 0) c

(** Hand-unrolling of the map function to bypass the call to the generic array
    allocation *)
let mk_clos_vect env v = match v with
| <abbr class="mark-warning" title="Patterns on array are not supported">[||]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|v0|]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[|mk_clos env v0|]</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|v0; v1|]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[|mk_clos env v0; mk_clos env v1|]</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|v0; v1; v2|]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[|mk_clos env v0; mk_clos env v1; mk_clos env v2|]</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|v0; v1; v2; v3|]</abbr> -&gt;
  <abbr class="mark-warning" title="Arrays not handled.">[|mk_clos env v0; mk_clos env v1; mk_clos env v2; mk_clos env v3|]</abbr>
| v -&gt; Array.Fun1.map mk_clos env v

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ref_value_cache</abbr> ({ i_cache = cache; _ }) tab ref =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">KeyTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> tab ref
  with Not_found -&gt;
    let v =
      try
        let body =
          match ref with
          | RelKey n -&gt;
            let open! Context.Rel.Declaration in
            let i = n - 1 in
            let (d, _) =
              try Range.get cache.i_env.env_rel_context.env_rel_map i
              with Invalid_argument _ -&gt; raise Not_found
            in
            begin match d with
              | LocalAssum _ -&gt; raise Not_found
              | LocalDef (_, t, _) -&gt; lift n t
            end
          | VarKey id -&gt; assoc_defined id cache.i_env
          | ConstKey cst -&gt; constant_value_in cache.i_env cst
        in
        Def (inject body)
      with
      | NotEvaluableConst (IsPrimitive op) (* Const *) -&gt; Primitive op
      | Not_found (* List.assoc *)
      | NotEvaluableConst _ (* Const *)
        -&gt; Undef None
    in
    KeyTable.add tab ref v; v</abbr>

(* The inverse of mk_clos: move back to constr *)
let rec to_constr lfts v =
  match v.term with
    | FRel i -&gt; mkRel (reloc_rel i lfts)
    | FFlex (RelKey p) -&gt; mkRel (reloc_rel p lfts)
    | FFlex (VarKey x) -&gt; mkVar x
    | FAtom c -&gt; exliftn lfts c
    | FFlex (ConstKey op) -&gt; mkConstU op
    | FInd op -&gt; mkIndU op
    | FConstruct op -&gt; mkConstructU op
    | FCaseT (ci,p,c,ve,env) -&gt;
      if is_subs_id env &amp;&amp; is_lift_id lfts then
        mkCase (ci, p, to_constr lfts c, ve)
      else
        let subs = comp_subs lfts env in
        mkCase (ci, subst_constr subs p,
            to_constr lfts c,
            Array.map (fun b -&gt; subst_constr subs b) ve)
    | FFix ((op,(lna,tys,bds)) as fx, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        mkFix fx
      else
        let n = Array.length bds in
        let subs_ty = comp_subs lfts e in
        let subs_bd = comp_subs (el_liftn n lfts) (subs_liftn n e) in
        let tys = Array.Fun1.map subst_constr subs_ty tys in
        let bds = Array.Fun1.map subst_constr subs_bd bds in
        mkFix (op, (lna, tys, bds))
    | FCoFix ((op,(lna,tys,bds)) as cfx, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        mkCoFix cfx
      else
        let n = Array.length bds in
        let subs_ty = comp_subs lfts e in
        let subs_bd = comp_subs (el_liftn n lfts) (subs_liftn n e) in
        let tys = Array.Fun1.map subst_constr subs_ty tys in
        let bds = Array.Fun1.map subst_constr subs_bd bds in
        mkCoFix (op, (lna, tys, bds))
    | FApp (f,ve) -&gt;
        mkApp (to_constr lfts f,
               Array.Fun1.map to_constr lfts ve)
    | FProj (p,c) -&gt;
        mkProj (p,to_constr lfts c)

    | FLambda (len, tys, f, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        Term.compose_lam (List.rev tys) f
      else
        let subs = comp_subs lfts e in
        let tys = List.mapi (fun i (na, c) -&gt; na, subst_constr (subs_liftn i subs) c) tys in
        let f = subst_constr (subs_liftn len subs) f in
        Term.compose_lam (List.rev tys) f
    | FProd (n, t, c, e) -&gt;
      if is_subs_id e &amp;&amp; is_lift_id lfts then
        mkProd (n, to_constr lfts t, c)
      else
        let subs' = comp_subs lfts e in
        mkProd (n, to_constr lfts t, subst_constr (subs_lift subs') c)
    | FLetIn (n,b,t,f,e) -&gt;
      let subs = comp_subs (el_lift lfts) (subs_lift e) in
        mkLetIn (n, to_constr lfts b,
                    to_constr lfts t,
                    subst_constr subs f)
    | FEvar ((ev,args),env) -&gt;
      let subs = comp_subs lfts env in
        mkEvar(ev,Array.map (fun a -&gt; subst_constr subs a) args)
    | FLIFT (k,a) -&gt; to_constr (el_shft k lfts) a

    | FInt i -&gt;
       Constr.mkInt i

    | FCLOS (t,env) -&gt;
      if is_subs_id env &amp;&amp; is_lift_id lfts then t
      else
        let subs = comp_subs lfts env in
        subst_constr subs t
    | FLOCKED -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (*mkVar(Id.of_string&quot;_LOCK_&quot;)*)

and subst_constr subst c = match [@ocaml.warning &quot;-4&quot;] Constr.kind c with
| Rel i -&gt;
  begin match expand_rel i subst with
  | Inl (k, <abbr class="mark-warning" title="Lazy patterns are not supported">lazy v</abbr>) -&gt; Vars.lift k v
  | Inr (m, _) -&gt; mkRel m
  end
| _ -&gt;
  Constr.map_with_binders Esubst.subs_lift subst_constr subst c

and comp_subs el s =
  Esubst.lift_subst (fun el c -&gt; <abbr class="mark-warning" title="Lazy expressions are not handled">lazy (to_constr el c)</abbr>) el s

(* This function defines the correspondence between constr and
   fconstr. When we find a closure whose substitution is the identity,
   then we directly return the constr to avoid possibly huge
   reallocation. *)
let term_of_fconstr c = to_constr el_id c

(* fstrong applies unfreeze_fun recursively on the (freeze) term and
 * yields a term.  Assumes that the unfreeze_fun never returns a
 * FCLOS term.
let rec fstrong unfreeze_fun lfts v =
  to_constr (fstrong unfreeze_fun) lfts (unfreeze_fun v)
*)

let rec zip m stk =
  match stk with
    | [] -&gt; m
    | Zapp args :: s -&gt; zip {mark=Mark.neutr m.mark; term=FApp(m, args)} s
    | ZcaseT(ci,p,br,e)::s -&gt;
        let t = FCaseT(ci, p, m, br, e) in
        let mark = mark (neutr (Mark.red_state m.mark)) Unknown  in
        zip {mark; term=t} s
    | Zproj p :: s -&gt;
        let mark = mark (neutr (Mark.red_state m.mark)) Unknown in
        zip {mark; term=FProj(Projection.make p true,m)} s
    | Zfix(fx,par)::s -&gt;
        zip fx (par @ append_stack <abbr class="mark-warning" title="Arrays not handled.">[|m|]</abbr> s)
    | Zshift(n)::s -&gt;
        zip (lift_fconstr n m) s
    | Zupdate(rf)::s -&gt;
      (** The stack contains [Zupdate] marks only if in sharing mode *)
        zip (update ~share:true rf m.mark m.term) s
    | Zprimitive(_op,c,rargs,kargs)::s -&gt;
      let args = List.rev_append rargs (m::List.map snd kargs) in
      let f = {mark = mark Red Unknown;term = FFlex (ConstKey c)} in
      zip {mark=mark (neutr (Mark.red_state m.mark)) KnownR; term = FApp (f, Array.of_list args)} s

let fapp_stack (m,stk) = zip m stk

(*********************************************************************)

(* The assertions in the functions below are granted because they are
   called only when m is a constructor, a cofix
   (strip_update_shift_app), a fix (get_nth_arg) or an abstraction
   (strip_update_shift, through get_arg). *)

(* optimised for the case where there are no shifts... *)
let strip_update_shift_app_red head stk =
  let rec strip_rec rstk h depth = function
    | Zshift(k) as e :: s -&gt;
        strip_rec (e::rstk) (lift_fconstr k h) (depth+k) s
    | (Zapp args :: s) -&gt;
        strip_rec (Zapp args :: rstk)
          {mark=h.mark;term=FApp(h,args)} depth s
    | Zupdate(m)::s -&gt;
      (** The stack contains [Zupdate] marks only if in sharing mode *)
        strip_rec rstk (update ~share:true m h.mark h.term) depth s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | []) as stk -&gt;
      (depth,List.rev rstk, stk)
  in
  strip_rec [] head 0 stk

let strip_update_shift_app head stack =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (match Mark.red_state head.mark with Red -&gt; false | Norm | Cstr | Whnf -&gt; true);
  strip_update_shift_app_red head stack</abbr>

let get_nth_arg head n stk =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (match Mark.red_state head.mark with Red -&gt; false | Norm | Cstr | Whnf -&gt; true);
  let rec strip_rec rstk h n = function
    | Zshift(k) as e :: s -&gt;
        strip_rec (e::rstk) (lift_fconstr k h) n s
    | Zapp args::s' -&gt;
        let q = Array.length args in
        if n &gt;= q
        then
          strip_rec (Zapp args::rstk) {mark=h.mark;term=FApp(h,args)} (n-q) s'
        else
          let bef = Array.sub args 0 n in
          let aft = Array.sub args (n+1) (q-n-1) in
          let stk' =
            List.rev (if Int.equal n 0 then rstk else (Zapp bef :: rstk)) in
          (Some (stk', args.(n)), append_stack aft s')
    | Zupdate(m)::s -&gt;
        (** The stack contains [Zupdate] mark only if in sharing mode *)
        strip_rec rstk (update ~share:true m h.mark h.term) n s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | []) as s -&gt; (None, List.rev rstk @ s) in
  strip_rec [] head n stk</abbr>

(* Beta reduction: look for an applied argument in the stack.
   Since the encountered update marks are removed, h must be a whnf *)
let rec get_args n tys f e = function
    | Zupdate r :: s -&gt;
        (** The stack contains [Zupdate] mark only if in sharing mode *)
        let _hd = update ~share:true r (mark Cstr (Mark.relevance r.mark)) (FLambda(n,tys,f,e)) in
        get_args n tys f e s
    | Zshift k :: s -&gt;
        get_args n tys f (subs_shft (k,e)) s
    | Zapp l :: s -&gt;
        let na = Array.length l in
        if n == na then (Inl (subs_cons(l,e)),s)
        else if n &lt; na then (* more arguments *)
          let args = Array.sub l 0 n in
          let eargs = Array.sub l n (na-n) in
          (Inl (subs_cons(args,e)), Zapp eargs :: s)
        else (* more lambdas *)
          let etys = List.skipn na tys in
          get_args (n-na) etys f (subs_cons(l,e)) s
    | ((ZcaseT _ | Zproj _ | Zfix _ | Zprimitive _) :: _ | []) as stk -&gt;
      (Inr {mark=mark Cstr Unknown;term=FLambda(n,tys,f,e)}, stk)

(* Eta expansion: add a reference to implicit surrounding lambda at end of stack *)
let rec eta_expand_stack = function
  | (Zapp _ | Zfix _ | ZcaseT _ | Zproj _
        | Zshift _ | Zupdate _ | Zprimitive _ as e) :: s -&gt;
      e :: eta_expand_stack s
  | [] -&gt;
      [Zshift 1; Zapp <abbr class="mark-warning" title="Arrays not handled.">[|{mark=mark Norm Unknown; term= FRel 1}|]</abbr>]

(* Get the arguments of a native operator *)
let rec skip_native_args rargs nargs =
  match nargs with
  | (kd, a) :: nargs' -&gt;
      if kd = CPrimitives.Kwhnf then rargs, nargs
      else skip_native_args (a::rargs) nargs'
  | [] -&gt; rargs, []

let get_native_args op c stk =
  let kargs = CPrimitives.kind op in
  let rec get_args rnargs kargs args =
    match kargs, args with
    | kd::kargs, a::args -&gt; get_args ((kd,a)::rnargs) kargs args
    | _, _ -&gt; rnargs, kargs, args in
  let rec strip_rec rnargs h depth kargs = function
    | Zshift k :: s -&gt;
      strip_rec (List.map (fun (kd,f) -&gt; kd,lift_fconstr k f) rnargs)
        (lift_fconstr k h) (depth+k) kargs s
    | Zapp args :: s' -&gt;
      begin match get_args rnargs kargs (Array.to_list args) with
        | rnargs, [], [] -&gt;
          (skip_native_args [] (List.rev rnargs), s')
        | rnargs, [], eargs -&gt;
          (skip_native_args [] (List.rev rnargs),
           Zapp (Array.of_list eargs) :: s')
        | rnargs, kargs, _ -&gt;
          strip_rec rnargs {mark = h.mark;term=FApp(h, args)} depth kargs s'
      end
    | Zupdate(m) :: s -&gt;
      strip_rec rnargs (update ~share:true m h.mark h.term) depth  kargs s
    | (Zprimitive _ | ZcaseT _ | Zproj _ | Zfix _) :: _ | [] -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in strip_rec [] {mark = mark Red Unknown;term = FFlex(ConstKey c)} 0 kargs stk

let get_native_args1 op c stk =
  match get_native_args op c stk with
  | ((rargs, (kd,a):: nargs), stk) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (kd = CPrimitives.Kwhnf);
      (rargs, a, nargs, stk)</abbr>
  | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let check_native_args op stk =
  let nargs = CPrimitives.arity op in
  let rargs = stack_args_size stk in
  nargs &lt;= rargs


(* Iota reduction: extract the arguments to be passed to the Case
   branches *)
let rec reloc_rargs_rec depth = function
  | Zapp args :: s -&gt;
    Zapp (lift_fconstr_vect depth args) :: reloc_rargs_rec depth s
  | Zshift(k)::s -&gt; if Int.equal k depth then s else reloc_rargs_rec (depth-k) s
  | ((ZcaseT _ | Zproj _ | Zfix _ | Zupdate _ | Zprimitive _) :: _ | []) as stk -&gt; stk

let reloc_rargs depth stk =
  if Int.equal depth 0 then stk else reloc_rargs_rec depth stk

let rec try_drop_parameters depth n = function
    | Zapp args::s -&gt;
        let q = Array.length args in
        if n &gt; q then try_drop_parameters depth (n-q) s
        else if Int.equal n q then reloc_rargs depth s
        else
          let aft = Array.sub args n (q-n) in
          reloc_rargs depth (append_stack aft s)
    | Zshift(k)::s -&gt; try_drop_parameters (depth-k) n s
    | [] -&gt;
        if Int.equal n 0 then []
        else raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>
    | (ZcaseT _ | Zproj _ | Zfix _ | Zupdate _ | Zprimitive _) :: _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
        (* strip_update_shift_app only produces Zapp and Zshift items *)

let drop_parameters depth n argstk =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try try_drop_parameters depth n argstk
  with Not_found -&gt;
  (* we know that n &lt; stack_args_size(argstk) (if well-typed term) *)
  anomaly (Pp.str &quot;ill-typed term: found a match on a partially applied constructor.&quot;)</abbr>

(** [eta_expand_ind_stack env ind c s t] computes stacks corresponding
    to the conversion of the eta expansion of t, considered as an inhabitant
    of ind, and the Constructor c of this inductive type applied to arguments
    s.
    @assumes [t] is an irreducible term, and not a constructor. [ind] is the inductive
    of the constructor term [c]
    @raise Not_found if the inductive is not a primitive record, or if the
    constructor is partially applied.
 *)
let eta_expand_ind_stack env ind m s (f, s') =
  let open Declarations in
  let mib = lookup_mind (fst ind) env in
  (* disallow eta-exp for non-primitive records *)
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (mib.mind_finite == BiFinite) then raise Not_found;
  match Declareops.inductive_make_projections ind mib with
  | Some projs -&gt;
    (* (Construct, pars1 .. parsm :: arg1...argn :: []) ~= (f, s') -&gt;
           arg1..argn ~= (proj1 t...projn t) where t = zip (f,s') *)
    let pars = mib.Declarations.mind_nparams in
    let right = fapp_stack (f, s') in
    let (depth, args, _s) = strip_update_shift_app m s in
    (** Try to drop the params, might fail on partially applied constructors. *)
    let argss = try_drop_parameters depth pars args in
    let hstack = Array.map (fun p -&gt;
        { mark = mark Red Unknown; (* right can't be a constructor though *)
          term = FProj (Projection.make p true, right) })
        projs
    in
    argss, [Zapp hstack]
  | None -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">Not_found</abbr> (* disallow eta-exp for non-primitive records *)

let rec project_nth_arg n = function
  | Zapp args :: s -&gt;
      let q = Array.length args in
        if n &gt;= q then project_nth_arg (n - q) s
        else (* n &lt; q *) args.(n)
  | (ZcaseT _ | Zproj _ | Zfix _ | Zupdate _ | Zshift _ | Zprimitive _) :: _ | [] -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
      (* After drop_parameters we have a purely applicative stack *)


(* Iota reduction: expansion of a fixpoint.
 * Given a fixpoint and a substitution, returns the corresponding
 * fixpoint body, and the substitution in which it should be
 * evaluated: its first variables are the fixpoint bodies
 *
 * FCLOS(fix Fi {F0 := T0 .. Fn-1 := Tn-1}, S)
 *    -&gt; (S. FCLOS(F0,S) . ... . FCLOS(Fn-1,S), Ti)
 *)
(* does not deal with FLIFT *)
let contract_fix_vect fix =
  let (thisbody, make_body, env, nfix) =
    match [@ocaml.warning &quot;-4&quot;] fix with
      | FFix (((reci,i),(nas,_,bds as rdcl)),env) -&gt;
          (bds.(i),
           (fun j -&gt; { mark = mark Cstr (opt_of_rel nas.(j).binder_relevance);
                       term = FFix (((reci,j),rdcl),env) }),
           env, Array.length bds)
      | FCoFix ((i,(nas,_,bds as rdcl)),env) -&gt;
          (bds.(i),
           (fun j -&gt; { mark = mark Cstr (opt_of_rel nas.(j).binder_relevance);
                       term = FCoFix ((j,rdcl),env) }),
           env, Array.length bds)
      | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in
  (subs_cons(Array.init nfix make_body, env), thisbody)

let unfold_projection info p =
  if red_projection info.i_flags p
  then
    Some (Zproj (Projection.repr p))
  else None

(*********************************************************************)
(* A machine that inspects the head of a term until it finds an
   atom or a subterm that may produce a redex (abstraction,
   constructor, cofix, letin, constant), or a neutral term (product,
   inductive) *)
let rec knh info m stk =
  match m.term with
    | FLIFT(k,a) -&gt; knh info a (zshift k stk)
    | FCLOS(t,e) -&gt; knht info e t (zupdate info m stk)
    | FLOCKED -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    | FApp(a,b) -&gt; knh info a (append_stack b (zupdate info m stk))
    | FCaseT(ci,p,t,br,e) -&gt; knh info t (ZcaseT(ci,p,br,e)::zupdate info m stk)
    | FFix(((ri,n),_),_) -&gt;
        (match get_nth_arg m ri.(n) stk with
             (Some(pars,arg),stk') -&gt; knh info arg (Zfix(m,pars)::stk')
           | (None, stk') -&gt; (m,stk'))
    | FProj (p,c) -&gt;
      (match unfold_projection info p with
       | None -&gt; (m, stk)
       | Some s -&gt; knh info c (s :: zupdate info m stk))

(* cases where knh stops *)
    | (FFlex _|FLetIn _|FConstruct _|FEvar _|
       FCoFix _|FLambda _|FRel _|FAtom _|FInd _|FProd _|FInt _) -&gt;
        (m, stk)

(* The same for pure terms *)
and knht info e t stk =
  match kind t with
    | App(a,b) -&gt;
        knht info e a (append_stack (mk_clos_vect e b) stk)
    | Case(ci,p,t,br) -&gt;
        knht info e t (ZcaseT(ci, p, br, e)::stk)
    | Fix fx -&gt; knh info { mark = mark Cstr Unknown; term = FFix (fx, e) } stk
    | Cast(a,_,_) -&gt; knht info e a stk
    | Rel n -&gt; knh info (clos_rel e n) stk
    | Proj (p, c) -&gt; knh info { mark = mark Red Unknown; term = FProj (p, mk_clos e c) } stk
    | (Ind _|Const _|Construct _|Var _|Meta _ | Sort _ | Int _) -&gt; (mk_clos e t, stk)
    | CoFix cfx -&gt; { mark = mark Cstr Unknown; term = FCoFix (cfx,e) }, stk
    | Lambda _ -&gt; { mark = mark Cstr Unknown; term = mk_lambda e t }, stk
    | Prod (n, t, c) -&gt;
      { mark = mark Whnf KnownR; term = FProd (n, mk_clos e t, c, e) }, stk
    | LetIn (n,b,t,c) -&gt;
      { mark = mark Red Unknown; term = FLetIn (n, mk_clos e b, mk_clos e t, c, e) }, stk
    | Evar ev -&gt; { mark = mark Red Unknown; term = FEvar (ev, e) }, stk

let inject c = mk_clos (subs_id 0) c

(************************************************************************)
(* Reduction of Native operators                                        *)

open Primred

module FNativeEntries =
  struct
    type elem = fconstr
    type args = fconstr array
    type evd = unit

    let get = Array.get

    let get_int () e =
      match [@ocaml.warning &quot;-4&quot;] e.term with
      | FInt i -&gt; i
      | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Primred.NativeDestKO</abbr>

    let dummy = {mark = mark Norm KnownR; term = FRel 0}

    let current_retro = ref Retroknowledge.empty
    let defined_int = ref false
    let fint = ref dummy

    let init_int retro =
      match retro.Retroknowledge.retro_int63 with
      | Some c -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">defined_int := true;
        fint := { mark = mark Norm KnownR; term = FFlex (ConstKey (Univ.in_punivs c)) }</abbr>
      | None -&gt; defined_int := false

    let defined_bool = ref false
    let ftrue = ref dummy
    let ffalse = ref dummy

    let init_bool retro =
      match retro.Retroknowledge.retro_bool with
      | Some (ct,cf) -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">defined_bool := true;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">ftrue := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs ct) };
        ffalse := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cf) }</abbr>
      | None -&gt; defined_bool :=false

    let defined_carry = ref false
    let fC0 = ref dummy
    let fC1 = ref dummy

    let init_carry retro =
      match retro.Retroknowledge.retro_carry with
      | Some(c0,c1) -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">defined_carry := true;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fC0 := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs c0) };
        fC1 := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs c1) }</abbr>
      | None -&gt; defined_carry := false

    let defined_pair = ref false
    let fPair = ref dummy

    let init_pair retro =
      match retro.Retroknowledge.retro_pair with
      | Some c -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">defined_pair := true;
        fPair := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs c) }</abbr>
      | None -&gt; defined_pair := false

    let defined_cmp = ref false
    let fEq = ref dummy
    let fLt = ref dummy
    let fGt = ref dummy

    let init_cmp retro =
      match retro.Retroknowledge.retro_cmp with
      | Some (cEq, cLt, cGt) -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">defined_cmp := true;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fEq := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cEq) };
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fLt := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cLt) };
        fGt := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs cGt) }</abbr>
      | None -&gt; defined_cmp := false

    let defined_refl = ref false

    let frefl = ref dummy

    let init_refl retro =
      match retro.Retroknowledge.retro_refl with
      | Some crefl -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">defined_refl := true;
        frefl := { mark = mark Cstr KnownR; term = FConstruct (Univ.in_punivs crefl) }</abbr>
      | None -&gt; defined_refl := false

    let init env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">current_retro := env.retroknowledge;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">init_int !current_retro;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">init_bool !current_retro;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">init_carry !current_retro;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">init_pair !current_retro;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">init_cmp !current_retro;
      init_refl !current_retro</abbr>

    let check_env env =
      if not (!current_retro == env.retroknowledge) then init env

    let check_int env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_env env;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert (!defined_int)</abbr>

    let check_bool env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_env env;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert (!defined_bool)</abbr>

    let check_carry env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_env env;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert (!defined_carry &amp;&amp; !defined_int)</abbr>

    let check_pair env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_env env;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert (!defined_pair &amp;&amp; !defined_int)</abbr>

    let check_cmp env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_env env;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert (!defined_cmp)</abbr>

    let mkInt env i =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_int env;
      { mark = mark Cstr KnownR; term = FInt i }</abbr>

    let mkBool env b =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_bool env;
      if b then !ftrue else !ffalse</abbr>

    let mkCarry env b e =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_carry env;
      {mark = mark Cstr KnownR;
       term = FApp ((if b then !fC1 else !fC0),</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|!fint;e|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)}</abbr>

    let mkIntPair env e1 e2 =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_pair env;
      { mark = mark Cstr KnownR; term = FApp(!fPair, </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|!fint;!fint;e1;e2|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">) }</abbr>

    let mkLt env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_cmp env;
      !fLt</abbr>

    let mkEq env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_cmp env;
      !fEq</abbr>

    let mkGt env =
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_cmp env;
      !fGt</abbr>

  end

module FredNative = RedNative(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Primred.RedNativeEntries, Primred.RedNativeEntries

We were looking for a module signature name for the following shape:
[ get; get_int; mkInt; mkBool; mkCarry; mkIntPair; mkLt; mkEq; mkGt ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">FNativeEntries</abbr>)

(************************************************************************)

(* Computes a weak head normal form from the result of knh. *)
let rec <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">knr</abbr> info tab m stk =
  match m.term with
  | FLambda(n,tys,f,e) when red_set info.i_flags fBETA -&gt;
      (match get_args n tys f e stk with
          Inl e', s -&gt; knit info tab e' f s
        | Inr lam, s -&gt; (lam,s))
  | FFlex(ConstKey (kn,_ as c)) when red_set info.i_flags (fCONST kn) -&gt;
      (match ref_value_cache info tab (ConstKey c) with
        | Def v -&gt; kni info tab v stk
        | Primitive op when check_native_args op stk -&gt;
          let rargs, a, nargs, stk = get_native_args1 op c stk in
          kni info tab a (Zprimitive(op,c,rargs,nargs)::stk)
        | Undef _ | OpaqueDef _ | Primitive _ -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(set_norm m; (m,stk))</abbr>)
  | FFlex(VarKey id) when red_set info.i_flags (fVAR id) -&gt;
      (match ref_value_cache info tab (VarKey id) with
        | Def v -&gt; kni info tab v stk
        | Primitive _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
        | OpaqueDef _ | Undef _ -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(set_norm m; (m,stk))</abbr>)
  | FFlex(RelKey k) when red_set info.i_flags fDELTA -&gt;
      (match ref_value_cache info tab (RelKey k) with
        | Def v -&gt; kni info tab v stk
        | Primitive _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
        | OpaqueDef _ | Undef _ -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(set_norm m; (m,stk))</abbr>)
  | FConstruct((_ind,c),_u) -&gt;
     let use_match = red_set info.i_flags fMATCH in
     let use_fix = red_set info.i_flags fFIX in
     if use_match || use_fix then
      (match [@ocaml.warning &quot;-4&quot;] strip_update_shift_app m stk with
        | (depth, args, ZcaseT(ci,_,br,e)::s) when use_match -&gt;
            <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (ci.ci_npar&gt;=0);
            let rargs = drop_parameters depth ci.ci_npar args in
            knit info tab e br.(c-1) (rargs@s)</abbr>
        | (_, cargs, Zfix(fx,par)::s) when use_fix -&gt;
            let rarg = fapp_stack(m,cargs) in
            let stk' = par @ append_stack <abbr class="mark-warning" title="Arrays not handled.">[|rarg|]</abbr> s in
            let (fxe,fxbd) = contract_fix_vect fx.term in
            knit info tab fxe fxbd stk'
        | (depth, args, Zproj p::s) when use_match -&gt;
            let rargs = drop_parameters depth (Projection.Repr.npars p) args in
            let rarg = project_nth_arg (Projection.Repr.arg p) rargs in
            kni info tab rarg s
        | (_,args,s) -&gt; (m,args@s))
     else (m,stk)
  | FCoFix _ when red_set info.i_flags fCOFIX -&gt;
      (match strip_update_shift_app m stk with
        | (_, args, (((ZcaseT _|Zproj _)::_) as stk')) -&gt;
            let (fxe,fxbd) = contract_fix_vect m.term in
            knit info tab fxe fxbd (args@stk')
        | (_,args, ((Zapp _ | Zfix _ | Zshift _ | Zupdate _ | Zprimitive _) :: _ | [] as s)) -&gt; (m,args@s))
  | FLetIn (_,v,_,bd,e) when red_set info.i_flags fZETA -&gt;
      knit info tab (subs_cons(<abbr class="mark-warning" title="Arrays not handled.">[|v|]</abbr>,e)) bd stk
  | FEvar(ev,env) -&gt;
      (match info.i_cache.i_sigma ev with
          Some c -&gt; knit info tab env c stk
        | None -&gt; (m,stk))
  | FInt _ -&gt;
    (match [@ocaml.warning &quot;-4&quot;] strip_update_shift_app m stk with
     | (_, _, Zprimitive(op,c,rargs,nargs)::s) -&gt;
       let (rargs, nargs) = skip_native_args (m::rargs) nargs in
       begin match nargs with
         | [] -&gt;
           let args = Array.of_list (List.rev rargs) in
           begin match <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Primred.RedNative, Primred.RedNative

We were looking for a module signature name for the following shape:
[ red_prim ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">FredNative.red_prim</abbr> (info_env info) () op args with
             | Some m -&gt; kni info tab m s
             | None -&gt;
               let f = {mark = mark Whnf KnownR; term = FFlex (ConstKey c)} in
               let m = {mark = mark Whnf KnownR; term = FApp(f,args)} in
               (m,s)
           end
         | (kd,a)::nargs -&gt;
           <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (kd = CPrimitives.Kwhnf);
           kni info tab a (Zprimitive(op,c,rargs,nargs)::s)</abbr>
             end
     | (_, _, s) -&gt; (m, s))
  | FLOCKED | FRel _ | FAtom _ | FFlex (RelKey _ | ConstKey _ | VarKey _) | FInd _ | FApp _ | FProj _
    | FFix _ | FCoFix _ | FCaseT _ | FLambda _ | FProd _ | FLetIn _ | FLIFT _
    | FCLOS _ -&gt; (m, stk)


(* Computes the weak head normal form of a term *)
and <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">kni</abbr> info tab m stk =
  let (hm,s) = knh info m stk in
  knr info tab hm s
and <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">knit</abbr> info tab e t stk =
  let (ht,s) = knht info e t stk in
  knr info tab ht s

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">kh</abbr> info tab v stk = fapp_stack(kni info tab v stk)

(************************************************************************)

let rec zip_term zfun m stk =
  match stk with
    | [] -&gt; m
    | Zapp args :: s -&gt;
        zip_term zfun (mkApp(m, Array.map zfun args)) s
    | ZcaseT(ci,p,br,e)::s -&gt;
        let t = mkCase(ci, zfun (mk_clos e p), m,
                       Array.map (fun b -&gt; zfun (mk_clos e b)) br) in
        zip_term zfun t s
    | Zproj p::s -&gt;
        let t = mkProj (Projection.make p true, m) in
        zip_term zfun t s
    | Zfix(fx,par)::s -&gt;
        let h = mkApp(zip_term zfun (zfun fx) par,<abbr class="mark-warning" title="Arrays not handled.">[|m|]</abbr>) in
        zip_term zfun h s
    | Zshift(n)::s -&gt;
        zip_term zfun (lift n m) s
    | Zupdate(_rf)::s -&gt;
        zip_term zfun m s
    | Zprimitive(_,c,rargs, kargs)::s -&gt;
        let kargs = List.map (fun (_,a) -&gt; zfun a) kargs in
        let args =
          List.fold_left (fun args a -&gt; zfun a ::args) (m::kargs) rargs in
        let h = mkApp (mkConstU c, Array.of_list args) in
        zip_term zfun h s

(* Computes the strong normal form of a term.
   1- Calls kni
   2- tries to rebuild the term. If a closure still has to be computed,
      calls itself recursively. *)
let rec <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">kl</abbr> info tab m =
  let share = info.i_cache.i_share in
  if is_val m then <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(incr prune; term_of_fconstr m)</abbr>
  else
    let (nm,s) = kni info tab m [] in
    let () = if share then ignore (fapp_stack (nm, s)) in (* to unlock Zupdates! *)
    zip_term (kl info tab) (norm_head info tab nm) s

(* no redex: go up for atoms and already normalized terms, go down
   otherwise. *)
and <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">norm_head</abbr> info tab m =
  if is_val m then <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(incr prune; term_of_fconstr m)</abbr> else
    match m.term with
      | FLambda(_n,tys,f,e) -&gt;
        let (e',info,rvtys) =
          List.fold_left (fun (e,info,ctxt) (na,ty) -&gt;
              (subs_lift e, info, (na,kl info tab (mk_clos e ty))::ctxt))
            (e,info,[]) tys in
        let bd = kl info tab (mk_clos e' f) in
        List.fold_left (fun b (na,ty) -&gt; mkLambda(na,ty,b)) bd rvtys
      | FLetIn(na,a,b,f,e) -&gt;
          let c = mk_clos (subs_lift e) f in
          mkLetIn(na, kl info tab a, kl info tab b, kl info tab c)
      | FProd(na,dom,rng,e) -&gt;
          mkProd(na, kl info tab dom, kl info tab (mk_clos (subs_lift e) rng))
      | FCoFix((n,(na,tys,bds)),e) -&gt;
          let ftys = Array.Fun1.map mk_clos e tys in
          let fbds =
            Array.Fun1.map mk_clos (subs_liftn (Array.length na) e) bds in
          mkCoFix(n,(na, CArray.map (kl info tab) ftys, CArray.map (kl info tab) fbds))
      | FFix((n,(na,tys,bds)),e) -&gt;
          let ftys = Array.Fun1.map mk_clos e tys in
          let fbds =
            Array.Fun1.map mk_clos (subs_liftn (Array.length na) e) bds in
          mkFix(n,(na, CArray.map (kl info tab) ftys, CArray.map (kl info tab) fbds))
      | FEvar((i,args),env) -&gt;
          mkEvar(i, Array.map (fun a -&gt; kl info tab (mk_clos env a)) args)
      | FProj (p,c) -&gt;
          mkProj (p, kl info tab c)
      | FLOCKED | FRel _ | FAtom _ | FFlex _ | FInd _ | FConstruct _
        | FApp _ | FCaseT _ | FLIFT _ | FCLOS _ | FInt _ -&gt; term_of_fconstr m

(* Initialization and then normalization *)

(* weak reduction *)
let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">whd_val</abbr> info tab v =
  with_stats <abbr class="mark-warning" title="Lazy expressions are not handled">(lazy (term_of_fconstr (kh info tab v [])))</abbr>

(* strong reduction *)
let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">norm_val</abbr> info tab v =
  with_stats <abbr class="mark-warning" title="Lazy expressions are not handled">(lazy (kl info tab v))</abbr>

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">whd_stack</abbr> infos tab m stk = match Mark.red_state m.mark with
| Whnf | Norm -&gt;
  (** No need to perform [kni] nor to unlock updates because
      every head subterm of [m] is [Whnf] or [Norm] *)
  knh infos m stk
| Red | Cstr -&gt;
  let k = kni infos tab m stk in
  let () = if infos.i_cache.i_share then ignore (fapp_stack k) in (* to unlock Zupdates! *)
  k

let create_clos_infos ?(evars=fun _ -&gt; None) flgs env =
  let share = (Environ.typing_flags env).Declarations.share_reduction in
  let cache = {
    i_env = env;
    i_sigma = evars;
    i_share = share;
  } in
  { i_flags = flgs; i_cache = cache }

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">create_tab</abbr> () = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">KeyTable.create</abbr> 17

let oracle_of_infos infos = Environ.oracle infos.i_cache.i_env

let infos_with_reds infos reds =
  { infos with i_flags = reds }

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">unfold_reference</abbr> info tab key =
  match key with
  | ConstKey (kn,_) -&gt;
    if red_set info.i_flags (fCONST kn) then
      ref_value_cache info tab key
    else Undef None
  | VarKey i -&gt;
    if red_set info.i_flags (fVAR i) then
      ref_value_cache info tab key
    else Undef None
  | RelKey _ -&gt; ref_value_cache info tab key

let relevance_of f = Mark.relevance f.mark
let set_relevance r f = <abbr class="mark-warning" title="Set record field not handled.">f.mark &lt;- Mark.mark (Mark.red_state f.mark) (opt_of_rel r)</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cClosure.ml"><code>CClosure.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Util.

Import Pp.

Import Names.

Import Constr.

Import Declarations.

Import Context.

Import Environ.

Import Vars.

Import Esubst.

Definition stats : Stdlib.ref bool := Stdlib.__ref_value false.

Definition beta : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition delta : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition eta : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition zeta : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition evar : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition nb_match : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition fix : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition cofix : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition prune : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition reset (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.op_coloneq prune 0.

Definition stop (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  Feedback.msg_debug None
    (op_plusplus
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus
                (op_plusplus
                  (op_plusplus
                    (op_plusplus
                      (op_plusplus
                        (op_plusplus
                          (op_plusplus
                            (op_plusplus
                              (op_plusplus
                                (op_plusplus
                                  (op_plusplus
                                    (op_plusplus
                                      (op_plusplus (str &quot;[Reds: beta=&quot;)
                                        (int (Stdlib.op_exclamation beta)))
                                      (str &quot; delta=&quot;))
                                    (int (Stdlib.op_exclamation delta)))
                                  (str &quot; eta=&quot;))
                                (int (Stdlib.op_exclamation eta)))
                              (str &quot; zeta=&quot;)) (int (Stdlib.op_exclamation zeta)))
                          (str &quot; evar=&quot;)) (int (Stdlib.op_exclamation evar)))
                      (str &quot; match=&quot;)) (int (Stdlib.op_exclamation nb_match)))
                  (str &quot; fix=&quot;)) (int (Stdlib.op_exclamation fix)))
              (str &quot; cofix=&quot;)) (int (Stdlib.op_exclamation cofix)))
          (str &quot; prune=&quot;)) (int (Stdlib.op_exclamation prune))) (str &quot;]&quot;)).

Definition incr_cnt (red : bool) (cnt : Stdlib.ref Z) : bool :=
  if red then
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    true
  else
    false.

Definition with_stats {A : Set} (c : Stdlib.Lazy.t A) : A :=
  if Stdlib.op_exclamation stats then
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let r := Lazy.force c in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    r
  else
    Lazy.force c.

Definition all_opaque : TransparentState.t := TransparentState.empty.

Definition all_transparent : TransparentState.t := TransparentState.full.

Module RedFlagsSig.
  Record signature {reds red_kind : Set} := {
    reds := reds;
    red_kind := red_kind;
    fBETA : red_kind;
    fDELTA : red_kind;
    fETA : red_kind;
    fMATCH : red_kind;
    fFIX : red_kind;
    fCOFIX : red_kind;
    fZETA : red_kind;
    fCONST : Names.Constant.t -&gt; red_kind;
    fVAR : Names.Id.t -&gt; red_kind;
    no_red : reds;
    red_add : reds -&gt; red_kind -&gt; reds;
    red_sub : reds -&gt; red_kind -&gt; reds;
    red_add_transparent : reds -&gt; TransparentState.t -&gt; reds;
    red_transparent : reds -&gt; TransparentState.t;
    mkflags : list red_kind -&gt; reds;
    red_set : reds -&gt; red_kind -&gt; bool;
    red_projection : reds -&gt; Names.Projection.t -&gt; bool;
  }.
  Arguments signature : clear implicits.
End RedFlagsSig.

Definition RedFlags :=
  (* ❌ open *)
  (* ❌ typ_definition *)
  (* ❌ typ_definition *)
  let fBETA := BETA in
  let fDELTA := DELTA in
  let fETA := ETA in
  let fMATCH := MATCH in
  let fFIX := FIX in
  let fCOFIX := COFIX in
  let fZETA := ZETA in
  let fCONST (kn : Names.Constant.t) : red_kind :=
    CONST kn in
  let fVAR (id : Names.Id.t) : red_kind :=
    VAR id in
  let no_red :=
    {| reds.r_beta := false; reds.r_delta := false; reds.r_eta := false;
      reds.r_const := all_opaque; reds.r_zeta := false; reds.r_match := false;
      reds.r_fix := false; reds.r_cofix := false |} in
  let red_add (red : reds) (function_parameter : red_kind) : reds :=
    match function_parameter with
    | BETA =&gt; reds.with_r_beta red true
    | ETA =&gt; reds.with_r_eta red true
    | DELTA =&gt; reds.with_r_const (reds.with_r_delta red true) all_transparent
    | CONST kn =&gt;
      let r := reds.r_const red in
      reds.with_r_const red
        (TransparentState.t.with_tr_cst r
          (Cpred.add kn (TransparentState.t.tr_cst r)))
    | MATCH =&gt; reds.with_r_match red true
    | FIX =&gt; reds.with_r_fix red true
    | COFIX =&gt; reds.with_r_cofix red true
    | ZETA =&gt; reds.with_r_zeta red true
    | VAR id =&gt;
      let r := reds.r_const red in
      reds.with_r_const red
        (TransparentState.t.with_tr_var r
          (Id.Pred.add id (TransparentState.t.tr_var r)))
    end in
  let red_sub (red : reds) (function_parameter : red_kind) : reds :=
    match function_parameter with
    | BETA =&gt; reds.with_r_beta red false
    | ETA =&gt; reds.with_r_eta red false
    | DELTA =&gt; reds.with_r_delta red false
    | CONST kn =&gt;
      let r := reds.r_const red in
      reds.with_r_const red
        (TransparentState.t.with_tr_cst r
          (Cpred.remove kn (TransparentState.t.tr_cst r)))
    | MATCH =&gt; reds.with_r_match red false
    | FIX =&gt; reds.with_r_fix red false
    | COFIX =&gt; reds.with_r_cofix red false
    | ZETA =&gt; reds.with_r_zeta red false
    | VAR id =&gt;
      let r := reds.r_const red in
      reds.with_r_const red
        (TransparentState.t.with_tr_var r
          (Id.Pred.remove id (TransparentState.t.tr_var r)))
    end in
  let red_transparent (red : reds) : TransparentState.t :=
    reds.r_const red in
  let red_add_transparent (red : reds) (tr : TransparentState.t) : reds :=
    reds.with_r_const red tr in
  let mkflags := (|Util.List|).(CList.ExtS.fold_left) red_add no_red in
  let red_set (red : reds) (function_parameter : red_kind) : bool :=
    match function_parameter with
    | BETA =&gt; incr_cnt (reds.r_beta red) beta
    | ETA =&gt; incr_cnt (reds.r_eta red) eta
    | CONST kn =&gt;
      let c := is_transparent_constant (reds.r_const red) kn in
      incr_cnt c delta
    | VAR id =&gt;
      let c := is_transparent_variable (reds.r_const red) id in
      incr_cnt c delta
    | ZETA =&gt; incr_cnt (reds.r_zeta red) zeta
    | MATCH =&gt; incr_cnt (reds.r_match red) nb_match
    | FIX =&gt; incr_cnt (reds.r_fix red) fix
    | COFIX =&gt; incr_cnt (reds.r_cofix red) cofix
    | DELTA =&gt; incr_cnt (reds.r_delta red) delta
    end in
  let red_projection (red : reds) (p : Names.Projection.t) : bool :=
    if Projection.unfolded p then
      true
    else
      red_set red (fCONST (Projection.constant p)) in
  existT _ [_, _]
    {|
      RedFlagsSig.fBETA := fBETA;
      RedFlagsSig.fDELTA := fDELTA;
      RedFlagsSig.fETA := fETA;
      RedFlagsSig.fMATCH := fMATCH;
      RedFlagsSig.fFIX := fFIX;
      RedFlagsSig.fCOFIX := fCOFIX;
      RedFlagsSig.fZETA := fZETA;
      RedFlagsSig.fCONST := fCONST;
      RedFlagsSig.fVAR := fVAR;
      RedFlagsSig.no_red := no_red;
      RedFlagsSig.red_add := red_add;
      RedFlagsSig.red_sub := red_sub;
      RedFlagsSig.red_add_transparent := red_add_transparent;
      RedFlagsSig.red_transparent := red_transparent;
      RedFlagsSig.mkflags := mkflags;
      RedFlagsSig.red_set := red_set;
      RedFlagsSig.red_projection := red_projection
    |}.

Import RedFlags.

Definition all : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags)
    [
      (|RedFlags|).(RedFlagsSig.fBETA);
      (|RedFlags|).(RedFlagsSig.fDELTA);
      (|RedFlags|).(RedFlagsSig.fZETA);
      (|RedFlags|).(RedFlagsSig.fMATCH);
      (|RedFlags|).(RedFlagsSig.fFIX);
      (|RedFlags|).(RedFlagsSig.fCOFIX)
    ].

Definition allnolet : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags)
    [
      (|RedFlags|).(RedFlagsSig.fBETA);
      (|RedFlags|).(RedFlagsSig.fDELTA);
      (|RedFlags|).(RedFlagsSig.fMATCH);
      (|RedFlags|).(RedFlagsSig.fFIX);
      (|RedFlags|).(RedFlagsSig.fCOFIX)
    ].

Definition beta : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags) [ (|RedFlags|).(RedFlagsSig.fBETA) ].

Definition betadeltazeta : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags)
    [
      (|RedFlags|).(RedFlagsSig.fBETA);
      (|RedFlags|).(RedFlagsSig.fDELTA);
      (|RedFlags|).(RedFlagsSig.fZETA)
    ].

Definition betaiota : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags)
    [
      (|RedFlags|).(RedFlagsSig.fBETA);
      (|RedFlags|).(RedFlagsSig.fMATCH);
      (|RedFlags|).(RedFlagsSig.fFIX);
      (|RedFlags|).(RedFlagsSig.fCOFIX)
    ].

Definition betaiotazeta : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags)
    [
      (|RedFlags|).(RedFlagsSig.fBETA);
      (|RedFlags|).(RedFlagsSig.fMATCH);
      (|RedFlags|).(RedFlagsSig.fFIX);
      (|RedFlags|).(RedFlagsSig.fCOFIX);
      (|RedFlags|).(RedFlagsSig.fZETA)
    ].

Definition betazeta : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags)
    [ (|RedFlags|).(RedFlagsSig.fBETA); (|RedFlags|).(RedFlagsSig.fZETA) ].

Definition delta : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags) [ (|RedFlags|).(RedFlagsSig.fDELTA) ].

Definition zeta : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags) [ (|RedFlags|).(RedFlagsSig.fZETA) ].

Definition nored : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.no_red).

Definition unfold_side_flags : list (|RedFlags|).(RedFlagsSig.red_kind) :=
  [
    (|RedFlags|).(RedFlagsSig.fBETA);
    (|RedFlags|).(RedFlagsSig.fMATCH);
    (|RedFlags|).(RedFlagsSig.fFIX);
    (|RedFlags|).(RedFlagsSig.fCOFIX);
    (|RedFlags|).(RedFlagsSig.fZETA)
  ].

Definition unfold_side_red : (|RedFlags|).(RedFlagsSig.reds) :=
  (|RedFlags|).(RedFlagsSig.mkflags)
    [
      (|RedFlags|).(RedFlagsSig.fBETA);
      (|RedFlags|).(RedFlagsSig.fMATCH);
      (|RedFlags|).(RedFlagsSig.fFIX);
      (|RedFlags|).(RedFlagsSig.fCOFIX);
      (|RedFlags|).(RedFlagsSig.fZETA)
    ].

Definition unfold_red (kn : Names.evaluable_global_reference)
  : (|RedFlags|).(RedFlagsSig.reds) :=
  let flag :=
    match kn with
    | Names.EvalVarRef id =&gt; (|RedFlags|).(RedFlagsSig.fVAR) id
    | Names.EvalConstRef kn =&gt; (|RedFlags|).(RedFlagsSig.fCONST) kn
    end in
  (|RedFlags|).(RedFlagsSig.mkflags) (cons flag unfold_side_flags).

Definition table_key := Names.tableKey (Univ.puniverses Names.Constant.t).

Definition eq_pconstant_key
  (function_parameter : Names.Constant.t * Univ.Instance.t)
  : Names.Constant.t * Univ.Instance.t -&gt; bool :=
  let '(c, u) := function_parameter in
  fun function_parameter =&gt;
    let '(c', u') := function_parameter in
    andb (eq_constant_key c c') (Univ.Instance.equal u u').

Module IdKeyHash.
  Import Hashset.Combine.
  
  Definition t := table_key.
  
  Definition equal
    : Names.tableKey (Names.Constant.t * Univ.Instance.t) -&gt;
    Names.tableKey (Names.Constant.t * Univ.Instance.t) -&gt; bool :=
    Names.eq_table_key eq_pconstant_key.
  
  Definition hash {A : Set}
    (function_parameter : Names.tableKey (Names.Constant.t * A)) : Z :=
    match function_parameter with
    | Names.ConstKey (c, _) =&gt; combinesmall 1 (Constant.UserOrd.hash c)
    | Names.VarKey id =&gt; combinesmall 2 (Id.hash id)
    | Names.RelKey i =&gt; combinesmall 3 (Int.hash i)
    end.
End IdKeyHash.

Definition KeyTable :=
  Hashtbl.Make
    (existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal :=
          (|IdKeyHash|).(Stdlib__hashtbl.HashedType.equal);
        Stdlib__hashtbl.HashedType.hash :=
          (|IdKeyHash|).(Stdlib__hashtbl.HashedType.hash)
      |}).

Import Context.Named.Declaration.

Definition assoc_defined (id : Names.variable) (env : Environ.env)
  : Constr.constr :=
  match Environ.lookup_named id env with
  | Context.Named.Declaration.LocalDef _ c _ =&gt; c
  | Context.Named.Declaration.LocalAssum _ _ =&gt;
    Stdlib.raise extensible_type_value
  end.

Inductive red_state : Set :=
| Norm : red_state
| Cstr : red_state
| Whnf : red_state
| Red : red_state.

Definition neutr (function_parameter : red_state) : red_state :=
  match function_parameter with
  | Whnf | Norm =&gt; Whnf
  | Red | Cstr =&gt; Red
  end.

Inductive optrel : Set :=
| Unknown : optrel
| KnownR : optrel
| KnownI : optrel.

Definition opt_of_rel (function_parameter : Sorts.relevance) : optrel :=
  match function_parameter with
  | Sorts.Relevant =&gt; KnownR
  | Sorts.Irrelevant =&gt; KnownI
  end.

Module Mark.
  Definition t := Z.
  
  Definition of_state (function_parameter : red_state) : Z :=
    match function_parameter with
    | Norm =&gt; 0
    | Cstr =&gt; 1
    | Whnf =&gt; 2
    | Red =&gt; 3
    end.
  
  Definition of_relevance (function_parameter : optrel) : Z :=
    match function_parameter with
    | Unknown =&gt; 0
    | KnownR =&gt; 1
    | KnownI =&gt; 2
    end.
  
  Definition mark (state : red_state) (relevance : optrel) : Z :=
    Z.add (Z.mul (of_state state) 4) (of_relevance relevance).
  
  Definition relevance (x : Z) : optrel :=
    match Z.land x 3 with
    | 0 =&gt; Unknown
    | 1 =&gt; KnownR
    | 2 =&gt; KnownI
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end.
  
  Definition red_state (x : Z) : red_state :=
    match Z.land x 12 with
    | 0 =&gt; Norm
    | 4 =&gt; Cstr
    | 8 =&gt; Whnf
    | 12 =&gt; Red
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end.
  
  Definition neutr (x : Z) : Z := Z.lor x 8.
  
  Definition set_norm (x : Z) : Z := Z.land x 3.
End Mark.

Definition mark : red_state -&gt; optrel -&gt; Mark.t := Mark.mark.

Reserved Notation &quot;'fconstr&quot;.

Module fconstr.
  Record record {mark term : Set} := {
    mark : mark;
    term : term }.
  Arguments record : clear implicits.
  Definition with_mark {mark_type term_type : Set}
    (r : record mark_type term_type) mark : record mark_type term_type :=
    {| mark := mark; term := term r |}.
  Definition with_term {mark_type term_type : Set}
    (r : record mark_type term_type) term : record mark_type term_type :=
    {| mark := mark r; term := term |}.
End fconstr.
Definition fconstr_skeleton := fconstr.record.

Inductive fterm : Set :=
| FRel : Z -&gt; fterm
| FAtom : Constr.constr -&gt; fterm
| FFlex : table_key -&gt; fterm
| FInd : Constr.pinductive -&gt; fterm
| FConstruct : Constr.pconstructor -&gt; fterm
| FApp : 'fconstr -&gt; array 'fconstr -&gt; fterm
| FProj : Names.Projection.t -&gt; 'fconstr -&gt; fterm
| FFix : Constr.fixpoint -&gt; Esubst.subs 'fconstr -&gt; fterm
| FCoFix : Constr.cofixpoint -&gt; Esubst.subs 'fconstr -&gt; fterm
| FCaseT :
  Constr.case_info -&gt; Constr.constr -&gt; 'fconstr -&gt; array Constr.constr -&gt;
  Esubst.subs 'fconstr -&gt; fterm
| FLambda :
  Z -&gt; list (Context.binder_annot Names.Name.t * Constr.constr) -&gt;
  Constr.constr -&gt; Esubst.subs 'fconstr -&gt; fterm
| FProd :
  Context.binder_annot Names.Name.t -&gt; 'fconstr -&gt; Constr.constr -&gt;
  Esubst.subs 'fconstr -&gt; fterm
| FLetIn :
  Context.binder_annot Names.Name.t -&gt; 'fconstr -&gt; 'fconstr -&gt; Constr.constr -&gt;
  Esubst.subs 'fconstr -&gt; fterm
| FEvar : Constr.existential -&gt; Esubst.subs 'fconstr -&gt; fterm
| FInt : Uint63.t -&gt; fterm
| FLIFT : Z -&gt; 'fconstr -&gt; fterm
| FCLOS : Constr.constr -&gt; Esubst.subs 'fconstr -&gt; fterm
| FLOCKED : fterm

where &quot;'fconstr&quot; := (fconstr_skeleton Mark.t fterm).

Definition fconstr := 'fconstr.

Definition fterm_of (v : fconstr) : fterm := fconstr.term v.

Definition set_norm (v : fconstr) : unit :=
  (* ❌ Set record field not handled. *)
  set_record_field v &quot;mark&quot; (Mark.set_norm (fconstr.mark v)).

Definition is_val (v : fconstr) : bool :=
  match Mark.red_state (fconstr.mark v) with
  | Norm =&gt; true
  | Cstr | Whnf | Red =&gt; false
  end.

Definition mk_atom (c : Constr.constr) : fconstr :=
  {| fconstr.mark := mark Norm Unknown; fconstr.term := FAtom c |}.

Definition mk_red (f : fterm) : fconstr :=
  {| fconstr.mark := mark Red Unknown; fconstr.term := f |}.

Definition update (share : bool) (v1 : fconstr) (mark : Mark.t) (t : fterm)
  : fconstr :=
  if share then
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    v1
  else
    {| fconstr.mark := mark; fconstr.term := t |}.

Module infos_cache.
  Record record := {
    i_env : Environ.env;
    i_sigma : Constr.existential -&gt; option Constr.constr;
    i_share : bool }.
  Definition with_i_env (r : record) i_env : record :=
    {| i_env := i_env; i_sigma := i_sigma r; i_share := i_share r |}.
  Definition with_i_sigma (r : record) i_sigma : record :=
    {| i_env := i_env r; i_sigma := i_sigma; i_share := i_share r |}.
  Definition with_i_share (r : record) i_share : record :=
    {| i_env := i_env r; i_sigma := i_sigma r; i_share := i_share |}.
End infos_cache.
Definition infos_cache := infos_cache.record.

Module clos_infos.
  Record record := {
    i_flags : (|RedFlags|).(RedFlagsSig.reds);
    i_cache : infos_cache }.
  Definition with_i_flags (r : record) i_flags : record :=
    {| i_flags := i_flags; i_cache := i_cache r |}.
  Definition with_i_cache (r : record) i_cache : record :=
    {| i_flags := i_flags r; i_cache := i_cache |}.
End clos_infos.
Definition clos_infos := clos_infos.record.

Definition clos_tab :=
  (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr).

Definition info_flags (info : clos_infos) : (|RedFlags|).(RedFlagsSig.reds) :=
  clos_infos.i_flags info.

Definition info_env (info : clos_infos) : Environ.env :=
  infos_cache.i_env (clos_infos.i_cache info).

Definition next_native_args (a : Set) := list (CPrimitives.arg_kind * a).

Reserved Notation &quot;'stack&quot;.

Inductive stack_member : Set :=
| Zapp : array fconstr -&gt; stack_member
| ZcaseT :
  Constr.case_info -&gt; Constr.constr -&gt; array Constr.constr -&gt;
  Esubst.subs fconstr -&gt; stack_member
| Zproj : Names.Projection.Repr.t -&gt; stack_member
| Zfix : fconstr -&gt; 'stack -&gt; stack_member
| Zprimitive :
  CPrimitives.t -&gt; Constr.pconstant -&gt; list fconstr -&gt;
  next_native_args fconstr -&gt; stack_member
| Zshift : Z -&gt; stack_member
| Zupdate : fconstr -&gt; stack_member

where &quot;'stack&quot; := (list stack_member).

Definition stack := 'stack.

Definition empty_stack {A : Set} : list A := [].

Definition append_stack (v : array fconstr) (s : list stack_member)
  : list stack_member :=
  if Int.equal ((|Util.Array|).(CArray.ExtS.length) v) 0 then
    s
  else
    match s with
    | cons (Zapp l) s =&gt; cons (Zapp ((|Util.Array|).(CArray.ExtS.append) v l)) s
    |
      cons
        (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zshift _ | Zupdate _ |
        Zprimitive _ _ _ _) _ | [] =&gt; cons (Zapp v) s
    end.

Definition zshift (n : Z) (s : list stack_member) : list stack_member :=
  match (n, s) with
  | (0, _) =&gt; s
  | (_, cons (Zshift k) s) =&gt; cons (Zshift (Z.add n k)) s
  |
    (_,
      cons
        (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zapp _ | Zupdate _ |
        Zprimitive _ _ _ _) _) | (_, []) =&gt; cons (Zshift n) s
  end.

Fixpoint stack_args_size (function_parameter : list stack_member)
  {struct function_parameter} : Z :=
  match function_parameter with
  | cons (Zapp v) s =&gt;
    Z.add ((|Util.Array|).(CArray.ExtS.length) v) (stack_args_size s)
  | cons (Zshift _) s =&gt; stack_args_size s
  | cons (Zupdate _) s =&gt; stack_args_size s
  | cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | [] =&gt; 0
  end.

Fixpoint lft_fconstr (n : Z) (ft : fconstr) {struct n} : fconstr :=
  let r := Mark.relevance (fconstr.mark ft) in
  match fconstr.term ft with
  | FInd _ | FConstruct _ | FFlex (Names.ConstKey _ | Names.VarKey _) | FInt _
    =&gt; ft
  | FRel i =&gt;
    {| fconstr.mark := mark Norm r; fconstr.term := FRel (Z.add i n) |}
  | FLambda k tys f e =&gt;
    {| fconstr.mark := mark Cstr r;
      fconstr.term := FLambda k tys f (subs_shft (n, e)) |}
  | FFix fx e =&gt;
    {| fconstr.mark := mark Cstr r; fconstr.term := FFix fx (subs_shft (n, e))
      |}
  | FCoFix cfx e =&gt;
    {| fconstr.mark := mark Cstr r;
      fconstr.term := FCoFix cfx (subs_shft (n, e)) |}
  | FLIFT k m =&gt; lft_fconstr (Z.add n k) m
  | FLOCKED =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  |
    FFlex (Names.RelKey _) | FAtom _ | FApp _ _ | FProj _ _ | FCaseT _ _ _ _ _ |
    FProd _ _ _ _ | FLetIn _ _ _ _ _ | FEvar _ _ | FCLOS _ _ =&gt;
    {| fconstr.mark := fconstr.mark ft; fconstr.term := FLIFT n ft |}
  end.

Definition lift_fconstr (k : Int.t) (f : fconstr) : fconstr :=
  if Int.equal k 0 then
    f
  else
    lft_fconstr k f.

Definition lift_fconstr_vect (k : Int.t) (v : array fconstr) : array fconstr :=
  if Int.equal k 0 then
    v
  else
    Array.Fun1.map lft_fconstr k v.

Definition clos_rel (e : Esubst.subs fconstr) (i : Z) : fconstr :=
  match expand_rel i e with
  | Util.Inl (n, mt) =&gt; lift_fconstr n mt
  | Util.Inr (k, None) =&gt;
    {| fconstr.mark := mark Norm Unknown; fconstr.term := FRel k |}
  | Util.Inr (k, Some p) =&gt;
    lift_fconstr (Z.sub k p)
      {| fconstr.mark := mark Red Unknown;
        fconstr.term := FFlex (Names.RelKey p) |}
  end.

Definition compact_stack (head : fconstr) (stk : list stack_member)
  : list stack_member :=
  let fix strip_rec (depth : Z) (function_parameter : list stack_member)
    {struct depth} : list stack_member :=
    match function_parameter with
    | cons (Zshift k) s =&gt; strip_rec (Z.add depth k) s
    | cons (Zupdate m) s =&gt;
      let h' := lft_fconstr depth head in
      let '_ := update true m (fconstr.mark h') (fconstr.term h') in
      strip_rec depth s
    |
      (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zapp _ | Zprimitive _ _ _ _)
        _ | []) as stk =&gt; zshift depth stk
    end in
  strip_rec 0 stk.

Definition zupdate (info : clos_infos) (m : fconstr) (s : list stack_member)
  : list stack_member :=
  let share := infos_cache.i_share (clos_infos.i_cache info) in
  if
    andb share
      match Mark.red_state (fconstr.mark m) with
      | Red =&gt; true
      | Norm | Whnf | Cstr =&gt; false
      end then
    let s' := compact_stack m s in
    let '_ :=
      (* ❌ Set record field not handled. *)
      set_record_field m &quot;term&quot; FLOCKED in
    cons (Zupdate m) s'
  else
    s.

Definition mk_lambda (env : Esubst.subs fconstr) (t : Constr.constr) : fterm :=
  let '(rvars, t') := Term.decompose_lam t in
  FLambda ((|Util.List|).(CList.ExtS.length) rvars)
    ((|Util.List|).(CList.ExtS.rev) rvars) t' env.

Definition destFLambda
  (clos_fun : Esubst.subs fconstr -&gt; Constr.constr -&gt; fconstr) (t : fconstr)
  : Context.binder_annot Names.Name.t * fconstr * fconstr :=
  match fconstr.term t with
  | FLambda _ (cons (na, ty) []) b e =&gt;
    (na, (clos_fun e ty), (clos_fun (subs_lift e) b))
  | FLambda n (cons (na, ty) tys) b e =&gt;
    (na, (clos_fun e ty),
      {| fconstr.mark := fconstr.mark t;
        fconstr.term := FLambda (Z.sub n 1) tys b (subs_lift e) |})
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition mk_clos (e : Esubst.subs fconstr) (t : Constr.constr) : fconstr :=
  match kind t with
  | Constr.Rel i =&gt; clos_rel e i
  | Constr.Var x =&gt;
    {| fconstr.mark := mark Red Unknown; fconstr.term := FFlex (Names.VarKey x)
      |}
  | Constr.Const c =&gt;
    {| fconstr.mark := mark Red Unknown;
      fconstr.term := FFlex (Names.ConstKey c) |}
  | Constr.Meta _ | Constr.Sort _ =&gt;
    {| fconstr.mark := mark Norm KnownR; fconstr.term := FAtom t |}
  | Constr.Ind kn =&gt;
    {| fconstr.mark := mark Norm KnownR; fconstr.term := FInd kn |}
  | Constr.Construct kn =&gt;
    {| fconstr.mark := mark Cstr Unknown; fconstr.term := FConstruct kn |}
  | Constr.Int i =&gt;
    {| fconstr.mark := mark Cstr Unknown; fconstr.term := FInt i |}
  |
    Constr.CoFix _ | Constr.Lambda _ _ _ | Constr.Fix _ | Constr.Prod _ _ _ |
    Constr.Evar _ | Constr.App _ _ | Constr.Case _ _ _ _ | Constr.Cast _ _ _ |
    Constr.LetIn _ _ _ _ | Constr.Proj _ _ =&gt;
    {| fconstr.mark := mark Red Unknown; fconstr.term := FCLOS t e |}
  end.

Definition inject (c : Constr.constr) : fconstr := mk_clos (subs_id 0) c.

Definition mk_clos_vect (env : Esubst.subs fconstr) (v : array Constr.constr)
  : array fconstr :=
  match v with
  | tt =&gt;
    (* ❌ Arrays not handled. *)
    [ ]
  | (v0) =&gt;
    (* ❌ Arrays not handled. *)
    [ mk_clos env v0 ]
  | (v0, v1) =&gt;
    (* ❌ Arrays not handled. *)
    [ mk_clos env v0; mk_clos env v1 ]
  | (v0, v1, v2) =&gt;
    (* ❌ Arrays not handled. *)
    [ mk_clos env v0; mk_clos env v1; mk_clos env v2 ]
  | (v0, v1, v2, v3) =&gt;
    (* ❌ Arrays not handled. *)
    [ mk_clos env v0; mk_clos env v1; mk_clos env v2; mk_clos env v3 ]
  | v =&gt; Array.Fun1.map mk_clos env v
  end.

Definition ref_value_cache (function_parameter : clos_infos)
  : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr) -&gt;
  (|KeyTable|).(Stdlib__hashtbl.S.key) -&gt; Declarations.constant_def fconstr :=
  let '{| clos_infos.i_cache := cache |} := function_parameter in
  fun tab =&gt;
    fun __ref_value =&gt;
      (* ❌ Try-with are not handled *)
      try ((|KeyTable|).(Stdlib__hashtbl.S.find) tab __ref_value).

Fixpoint to_constr (lfts : Esubst.lift) (v : fconstr) {struct lfts}
  : Constr.constr :=
  match fconstr.term v with
  | FRel i =&gt; mkRel (reloc_rel i lfts)
  | FFlex (Names.RelKey p) =&gt; mkRel (reloc_rel p lfts)
  | FFlex (Names.VarKey x) =&gt; mkVar x
  | FAtom c =&gt; exliftn lfts c
  | FFlex (Names.ConstKey op) =&gt; mkConstU op
  | FInd op =&gt; mkIndU op
  | FConstruct op =&gt; mkConstructU op
  | FCaseT ci p c ve env =&gt;
    if andb (is_subs_id env) (is_lift_id lfts) then
      mkCase (ci, p, (to_constr lfts c), ve)
    else
      let subs := comp_subs lfts env in
      mkCase
        (ci, (subst_constr subs p), (to_constr lfts c),
          ((|Util.Array|).(CArray.ExtS.map) (fun b =&gt; subst_constr subs b) ve))
  | FFix ((op, (lna, tys, bds)) as fx) e =&gt;
    if andb (is_subs_id e) (is_lift_id lfts) then
      mkFix fx
    else
      let n := (|Util.Array|).(CArray.ExtS.length) bds in
      let subs_ty := comp_subs lfts e in
      let subs_bd := comp_subs (el_liftn n lfts) (subs_liftn n e) in
      let tys := Array.Fun1.map subst_constr subs_ty tys in
      let bds := Array.Fun1.map subst_constr subs_bd bds in
      mkFix (op, (lna, tys, bds))
  | FCoFix ((op, (lna, tys, bds)) as cfx) e =&gt;
    if andb (is_subs_id e) (is_lift_id lfts) then
      mkCoFix cfx
    else
      let n := (|Util.Array|).(CArray.ExtS.length) bds in
      let subs_ty := comp_subs lfts e in
      let subs_bd := comp_subs (el_liftn n lfts) (subs_liftn n e) in
      let tys := Array.Fun1.map subst_constr subs_ty tys in
      let bds := Array.Fun1.map subst_constr subs_bd bds in
      mkCoFix (op, (lna, tys, bds))
  | FApp f ve =&gt; mkApp ((to_constr lfts f), (Array.Fun1.map to_constr lfts ve))
  | FProj p c =&gt; mkProj (p, (to_constr lfts c))
  | FLambda len tys f e =&gt;
    if andb (is_subs_id e) (is_lift_id lfts) then
      Term.compose_lam ((|Util.List|).(CList.ExtS.rev) tys) f
    else
      let subs := comp_subs lfts e in
      let tys :=
        (|Util.List|).(CList.ExtS.mapi)
          (fun i =&gt;
            fun function_parameter =&gt;
              let '(na, c) := function_parameter in
              (na, (subst_constr (subs_liftn i subs) c))) tys in
      let f := subst_constr (subs_liftn len subs) f in
      Term.compose_lam ((|Util.List|).(CList.ExtS.rev) tys) f
  | FProd n t c e =&gt;
    if andb (is_subs_id e) (is_lift_id lfts) then
      mkProd (n, (to_constr lfts t), c)
    else
      let subs' := comp_subs lfts e in
      mkProd (n, (to_constr lfts t), (subst_constr (subs_lift subs') c))
  | FLetIn n b t f e =&gt;
    let subs := comp_subs (el_lift lfts) (subs_lift e) in
    mkLetIn (n, (to_constr lfts b), (to_constr lfts t), (subst_constr subs f))
  | FEvar (ev, args) env =&gt;
    let subs := comp_subs lfts env in
    mkEvar
      (ev,
        ((|Util.Array|).(CArray.ExtS.map) (fun a =&gt; subst_constr subs a) args))
  | FLIFT k a =&gt; to_constr (el_shft k lfts) a
  | FInt i =&gt; Constr.mkInt i
  | FCLOS t env =&gt;
    if andb (is_subs_id env) (is_lift_id lfts) then
      t
    else
      let subs := comp_subs lfts env in
      subst_constr subs t
  | FLOCKED =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end

with subst_constr
  (subst : Esubst.subs (lazy_t Constr.constr)) (c : Constr.constr)
  {struct subst} : Constr.constr :=
  match Constr.kind c with
  | Constr.Rel i =&gt;
    match expand_rel i subst with
    | Util.Inl (k, v) =&gt; Vars.lift k v
    | Util.Inr (m, _) =&gt; mkRel m
    end
  | _ =&gt; Constr.map_with_binders Esubst.subs_lift subst_constr subst c
  end

with comp_subs (el : Esubst.lift) (s : Esubst.subs fconstr) {struct el}
  : Esubst.subs (lazy_t Constr.constr) :=
  Esubst.lift_subst
    (fun el =&gt;
      fun c =&gt;
        (* ❌ Lazy expressions are not handled *)
        lazy (to_constr el c)) el s.

Definition term_of_fconstr (c : fconstr) : Constr.constr := to_constr el_id c.

Fixpoint zip (m : fconstr) (stk : list stack_member) {struct m} : fconstr :=
  match stk with
  | [] =&gt; m
  | cons (Zapp args) s =&gt;
    zip
      {| fconstr.mark := Mark.neutr (fconstr.mark m);
        fconstr.term := FApp m args |} s
  | cons (ZcaseT ci p br e) s =&gt;
    let t := FCaseT ci p m br e in
    let mark := mark (neutr (Mark.red_state (fconstr.mark m))) Unknown in
    zip {| fconstr.mark := mark; fconstr.term := t |} s
  | cons (Zproj p) s =&gt;
    let mark := mark (neutr (Mark.red_state (fconstr.mark m))) Unknown in
    zip
      {| fconstr.mark := mark; fconstr.term := FProj (Projection.make p true) m
        |} s
  | cons (Zfix fx par) s =&gt;
    zip fx
      (op_at par
        (append_stack
          (* ❌ Arrays not handled. *)
          [ m ] s))
  | cons (Zshift n) s =&gt; zip (lift_fconstr n m) s
  | cons (Zupdate rf) s =&gt;
    zip (update true rf (fconstr.mark m) (fconstr.term m)) s
  | cons (Zprimitive _op c rargs kargs) s =&gt;
    let args :=
      (|Util.List|).(CList.ExtS.rev_append) rargs
        (cons m ((|Util.List|).(CList.ExtS.map) snd kargs)) in
    let f :=
      {| fconstr.mark := mark Red Unknown;
        fconstr.term := FFlex (Names.ConstKey c) |} in
    zip
      {| fconstr.mark := mark (neutr (Mark.red_state (fconstr.mark m))) KnownR;
        fconstr.term := FApp f ((|Util.Array|).(CArray.ExtS.of_list) args) |} s
  end.

Definition fapp_stack (function_parameter : fconstr * list stack_member)
  : fconstr :=
  let '(m, stk) := function_parameter in
  zip m stk.

Definition strip_update_shift_app_red (head : fconstr) (stk : list stack_member)
  : Z * list stack_member * list stack_member :=
  let fix strip_rec
    (rstk : list stack_member) (h : fconstr) (depth : Z)
    (function_parameter : list stack_member) {struct rstk}
    : Z * list stack_member * list stack_member :=
    match function_parameter with
    | cons ((Zshift k) as e) s =&gt;
      strip_rec (cons e rstk) (lift_fconstr k h) (Z.add depth k) s
    | cons (Zapp args) s =&gt;
      strip_rec (cons (Zapp args) rstk)
        {| fconstr.mark := fconstr.mark h; fconstr.term := FApp h args |} depth
        s
    | cons (Zupdate m) s =&gt;
      strip_rec rstk (update true m (fconstr.mark h) (fconstr.term h)) depth s
    |
      (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | [])
        as stk =&gt; (depth, ((|Util.List|).(CList.ExtS.rev) rstk), stk)
    end in
  strip_rec [] head 0 stk.

Definition strip_update_shift_app (head : fconstr) (stack : list stack_member)
  : Z * list stack_member * list stack_member :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  strip_update_shift_app_red head stack.

Definition get_nth_arg (head : fconstr) (n : Int.t) (stk : list stack_member)
  : option (list stack_member * fconstr) * list stack_member :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fix strip_rec
    (rstk : list stack_member) (h : fconstr) (n : Int.t)
    (function_parameter : list stack_member) {struct rstk}
    : option (list stack_member * fconstr) * list stack_member :=
    match function_parameter with
    | cons ((Zshift k) as e) s =&gt; strip_rec (cons e rstk) (lift_fconstr k h) n s
    | cons (Zapp args) s' =&gt;
      let q := (|Util.Array|).(CArray.ExtS.length) args in
      if OCaml.Stdlib.ge n q then
        strip_rec (cons (Zapp args) rstk)
          {| fconstr.mark := fconstr.mark h; fconstr.term := FApp h args |}
          (Z.sub n q) s'
      else
        let bef := (|Util.Array|).(CArray.ExtS.sub) args 0 n in
        let aft :=
          (|Util.Array|).(CArray.ExtS.sub) args (Z.add n 1)
            (Z.sub (Z.sub q n) 1) in
        let stk' :=
          (|Util.List|).(CList.ExtS.rev)
            (if Int.equal n 0 then
              rstk
            else
              cons (Zapp bef) rstk) in
        ((Some (stk', ((|Util.Array|).(CArray.ExtS.get) args n))),
          (append_stack aft s'))
    | cons (Zupdate m) s =&gt;
      strip_rec rstk (update true m (fconstr.mark h) (fconstr.term h)) n s
    |
      (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | [])
        as s =&gt; (None, (op_at ((|Util.List|).(CList.ExtS.rev) rstk) s))
    end in
  strip_rec [] head n stk.

Fixpoint get_args
  (n : Z) (tys : list (Context.binder_annot Names.Name.t * Constr.constr))
  (f : Constr.constr) (e : Esubst.subs fconstr)
  (function_parameter : list stack_member) {struct n}
  : Util.union (Esubst.subs fconstr) fconstr * list stack_member :=
  match function_parameter with
  | cons (Zupdate r) s =&gt;
    let _hd :=
      update true r (mark Cstr (Mark.relevance (fconstr.mark r)))
        (FLambda n tys f e) in
    get_args n tys f e s
  | cons (Zshift k) s =&gt; get_args n tys f (subs_shft (k, e)) s
  | cons (Zapp l) s =&gt;
    let na := (|Util.Array|).(CArray.ExtS.length) l in
    if Stdlib.op_eqeq n na then
      ((Util.Inl (subs_cons (l, e))), s)
    else
      if OCaml.Stdlib.lt n na then
        let args := (|Util.Array|).(CArray.ExtS.sub) l 0 n in
        let eargs := (|Util.Array|).(CArray.ExtS.sub) l n (Z.sub na n) in
        ((Util.Inl (subs_cons (args, e))), (cons (Zapp eargs) s))
      else
        let etys := (|Util.List|).(CList.ExtS.skipn) na tys in
        get_args (Z.sub n na) etys f (subs_cons (l, e)) s
  |
    (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zprimitive _ _ _ _) _ | []) as
      stk =&gt;
    ((Util.Inr
      {| fconstr.mark := mark Cstr Unknown; fconstr.term := FLambda n tys f e |}),
      stk)
  end.

Fixpoint eta_expand_stack (function_parameter : list stack_member)
  {struct function_parameter} : list stack_member :=
  match function_parameter with
  |
    cons
      ((Zapp _ | Zfix _ _ | ZcaseT _ _ _ _ | Zproj _ | Zshift _ | Zupdate _ |
      Zprimitive _ _ _ _) as e) s =&gt; cons e (eta_expand_stack s)
  | [] =&gt;
    [
      Zshift 1;
      Zapp
        (* ❌ Arrays not handled. *)
        [ {| fconstr.mark := mark Norm Unknown; fconstr.term := FRel 1 |} ]
    ]
  end.

Fixpoint skip_native_args {A : Set}
  (rargs : list A) (nargs : list (CPrimitives.arg_kind * A)) {struct rargs}
  : list A * list (CPrimitives.arg_kind * A) :=
  match nargs with
  | cons (kd, a) nargs' =&gt;
    if equiv_decb kd CPrimitives.Kwhnf then
      (rargs, nargs)
    else
      skip_native_args (cons a rargs) nargs'
  | [] =&gt; (rargs, [])
  end.

Definition get_native_args
  (op : CPrimitives.t) (c : Univ.puniverses Names.Constant.t)
  (stk : list stack_member)
  : (list fconstr * list (CPrimitives.arg_kind * fconstr)) * list stack_member :=
  let kargs := CPrimitives.kind op in
  let fix get_args {A B : Set}
    (rnargs : list (A * B)) (kargs : list A) (args : list B) {struct rnargs}
    : list (A * B) * list A * list B :=
    match (kargs, args) with
    | (cons kd kargs, cons a args) =&gt; get_args (cons (kd, a) rnargs) kargs args
    | (_, _) =&gt; (rnargs, kargs, args)
    end in
  let fix strip_rec
    (rnargs : list (CPrimitives.arg_kind * fconstr)) (h : fconstr) (depth : Z)
    (kargs : list CPrimitives.arg_kind) (function_parameter : list stack_member)
    {struct rnargs}
    : (list fconstr * list (CPrimitives.arg_kind * fconstr)) * list stack_member :=
    match function_parameter with
    | cons (Zshift k) s =&gt;
      strip_rec
        ((|Util.List|).(CList.ExtS.map)
          (fun function_parameter =&gt;
            let '(kd, f) := function_parameter in
            (kd, (lift_fconstr k f))) rnargs) (lift_fconstr k h) (Z.add depth k)
        kargs s
    | cons (Zapp args) s' =&gt;
      match get_args rnargs kargs ((|Util.Array|).(CArray.ExtS.to_list) args)
        with
      | (rnargs, [], []) =&gt;
        ((skip_native_args [] ((|Util.List|).(CList.ExtS.rev) rnargs)), s')
      | (rnargs, [], eargs) =&gt;
        ((skip_native_args [] ((|Util.List|).(CList.ExtS.rev) rnargs)),
          (cons (Zapp ((|Util.Array|).(CArray.ExtS.of_list) eargs)) s'))
      | (rnargs, kargs, _) =&gt;
        strip_rec rnargs
          {| fconstr.mark := fconstr.mark h; fconstr.term := FApp h args |}
          depth kargs s'
      end
    | cons (Zupdate m) s =&gt;
      strip_rec rnargs (update true m (fconstr.mark h) (fconstr.term h)) depth
        kargs s
    | cons (Zprimitive _ _ _ _ | ZcaseT _ _ _ _ | Zproj _ | Zfix _ _) _ | [] =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  strip_rec []
    {| fconstr.mark := mark Red Unknown;
      fconstr.term := FFlex (Names.ConstKey c) |} 0 kargs stk.

Definition get_native_args1
  (op : CPrimitives.t) (c : Univ.puniverses Names.Constant.t)
  (stk : list stack_member)
  : list fconstr * fconstr * list (CPrimitives.arg_kind * fconstr) *
    list stack_member :=
  match get_native_args op c stk with
  | ((rargs, cons (kd, a) nargs), stk) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (rargs, a, nargs, stk)
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition check_native_args (op : CPrimitives.t) (stk : list stack_member)
  : bool :=
  let nargs := CPrimitives.arity op in
  let rargs := stack_args_size stk in
  OCaml.Stdlib.le nargs rargs.

Fixpoint reloc_rargs_rec
  (depth : Int.t) (function_parameter : list stack_member) {struct depth}
  : list stack_member :=
  match function_parameter with
  | cons (Zapp args) s =&gt;
    cons (Zapp (lift_fconstr_vect depth args)) (reloc_rargs_rec depth s)
  | cons (Zshift k) s =&gt;
    if Int.equal k depth then
      s
    else
      reloc_rargs_rec (Z.sub depth k) s
  |
    (cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zupdate _ | Zprimitive _ _ _ _)
      _ | []) as stk =&gt; stk
  end.

Definition reloc_rargs (depth : Int.t) (stk : list stack_member)
  : list stack_member :=
  if Int.equal depth 0 then
    stk
  else
    reloc_rargs_rec depth stk.

Fixpoint try_drop_parameters
  (depth : Int.t) (n : Int.t) (function_parameter : list stack_member)
  {struct depth} : list stack_member :=
  match function_parameter with
  | cons (Zapp args) s =&gt;
    let q := (|Util.Array|).(CArray.ExtS.length) args in
    if OCaml.Stdlib.gt n q then
      try_drop_parameters depth (Z.sub n q) s
    else
      if Int.equal n q then
        reloc_rargs depth s
      else
        let aft := (|Util.Array|).(CArray.ExtS.sub) args n (Z.sub q n) in
        reloc_rargs depth (append_stack aft s)
  | cons (Zshift k) s =&gt; try_drop_parameters (Z.sub depth k) n s
  | [] =&gt;
    if Int.equal n 0 then
      []
    else
      Stdlib.raise extensible_type_value
  |
    cons (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zupdate _ | Zprimitive _ _ _ _)
      _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition drop_parameters
  (depth : Int.t) (n : Int.t) (argstk : list stack_member)
  : list stack_member :=
  (* ❌ Try-with are not handled *)
  try (try_drop_parameters depth n argstk).

Definition eta_expand_ind_stack
  (env : Environ.env) (ind : Names.inductive) (m : fconstr)
  (s : list stack_member) (function_parameter : fconstr * list stack_member)
  : list stack_member * list stack_member :=
  let '(f, s') := function_parameter in
  let mib := lookup_mind (fst ind) env in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  match Declareops.inductive_make_projections ind mib with
  | Some projs =&gt;
    let pars := Declarations.mutual_inductive_body.mind_nparams mib in
    let __right := fapp_stack (f, s') in
    let '(depth, args, _s) := strip_update_shift_app m s in
    let argss := try_drop_parameters depth pars args in
    let hstack :=
      (|Util.Array|).(CArray.ExtS.map)
        (fun p =&gt;
          {| fconstr.mark := mark Red Unknown;
            fconstr.term := FProj (Projection.make p true) __right |}) projs in
    (argss, [ Zapp hstack ])
  | None =&gt; Stdlib.raise extensible_type_value
  end.

Fixpoint project_nth_arg (n : Z) (function_parameter : list stack_member)
  {struct n} : fconstr :=
  match function_parameter with
  | cons (Zapp args) s =&gt;
    let q := (|Util.Array|).(CArray.ExtS.length) args in
    if OCaml.Stdlib.ge n q then
      project_nth_arg (Z.sub n q) s
    else
      (|Util.Array|).(CArray.ExtS.get) args n
  |
    cons
      (ZcaseT _ _ _ _ | Zproj _ | Zfix _ _ | Zupdate _ | Zshift _ |
      Zprimitive _ _ _ _) _ | [] =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition contract_fix_vect (fix : fterm)
  : Esubst.subs fconstr * Constr.constr :=
  let '(thisbody, make_body, env, nfix) :=
    match fix with
    | FFix ((reci, i), (nas, _, bds) as rdcl) env =&gt;
      (((|Util.Array|).(CArray.ExtS.get) bds i),
        (fun j =&gt;
          {|
            fconstr.mark :=
              mark Cstr
                (opt_of_rel
                  (Context.binder_annot.binder_relevance
                    ((|Util.Array|).(CArray.ExtS.get) nas j)));
            fconstr.term := FFix ((reci, j), rdcl) env |}), env,
        ((|Util.Array|).(CArray.ExtS.length) bds))
    | FCoFix (i, (nas, _, bds) as rdcl) env =&gt;
      (((|Util.Array|).(CArray.ExtS.get) bds i),
        (fun j =&gt;
          {|
            fconstr.mark :=
              mark Cstr
                (opt_of_rel
                  (Context.binder_annot.binder_relevance
                    ((|Util.Array|).(CArray.ExtS.get) nas j)));
            fconstr.term := FCoFix (j, rdcl) env |}), env,
        ((|Util.Array|).(CArray.ExtS.length) bds))
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  ((subs_cons (((|Util.Array|).(CArray.ExtS.init) nfix make_body), env)),
    thisbody).

Definition unfold_projection (info : clos_infos) (p : Names.Projection.t)
  : option stack_member :=
  if (|RedFlags|).(RedFlagsSig.red_projection) (clos_infos.i_flags info) p then
    Some (Zproj (Projection.repr p))
  else
    None.

Fixpoint knh (info : clos_infos) (m : fconstr) (stk : list stack_member)
  {struct info} : fconstr * list stack_member :=
  match fconstr.term m with
  | FLIFT k a =&gt; knh info a (zshift k stk)
  | FCLOS t e =&gt; knht info e t (zupdate info m stk)
  | FLOCKED =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | FApp a b =&gt; knh info a (append_stack b (zupdate info m stk))
  | FCaseT ci p t br e =&gt;
    knh info t (cons (ZcaseT ci p br e) (zupdate info m stk))
  | FFix ((ri, n), _) _ =&gt;
    match get_nth_arg m ((|Util.Array|).(CArray.ExtS.get) ri n) stk with
    | (Some (pars, arg), stk') =&gt; knh info arg (cons (Zfix m pars) stk')
    | (None, stk') =&gt; (m, stk')
    end
  | FProj p c =&gt;
    match unfold_projection info p with
    | None =&gt; (m, stk)
    | Some s =&gt; knh info c (cons s (zupdate info m stk))
    end
  |
    FFlex _ | FLetIn _ _ _ _ _ | FConstruct _ | FEvar _ _ | FCoFix _ _ |
    FLambda _ _ _ _ | FRel _ | FAtom _ | FInd _ | FProd _ _ _ _ | FInt _ =&gt;
    (m, stk)
  end

with knht
  (info : clos_infos) (e : Esubst.subs fconstr) (t : Constr.constr)
  (stk : list stack_member) {struct info} : fconstr * list stack_member :=
  match kind t with
  | Constr.App a b =&gt; knht info e a (append_stack (mk_clos_vect e b) stk)
  | Constr.Case ci p t br =&gt; knht info e t (cons (ZcaseT ci p br e) stk)
  | Constr.Fix fx =&gt;
    knh info {| fconstr.mark := mark Cstr Unknown; fconstr.term := FFix fx e |}
      stk
  | Constr.Cast a _ _ =&gt; knht info e a stk
  | Constr.Rel n =&gt; knh info (clos_rel e n) stk
  | Constr.Proj p c =&gt;
    knh info
      {| fconstr.mark := mark Red Unknown; fconstr.term := FProj p (mk_clos e c)
        |} stk
  |
    Constr.Ind _ | Constr.Const _ | Constr.Construct _ | Constr.Var _ |
    Constr.Meta _ | Constr.Sort _ | Constr.Int _ =&gt; ((mk_clos e t), stk)
  | Constr.CoFix cfx =&gt;
    ({| fconstr.mark := mark Cstr Unknown; fconstr.term := FCoFix cfx e |}, stk)
  | Constr.Lambda _ _ _ =&gt;
    ({| fconstr.mark := mark Cstr Unknown; fconstr.term := mk_lambda e t |}, stk)
  | Constr.Prod n t c =&gt;
    ({| fconstr.mark := mark Whnf KnownR;
      fconstr.term := FProd n (mk_clos e t) c e |}, stk)
  | Constr.LetIn n b t c =&gt;
    ({| fconstr.mark := mark Red Unknown;
      fconstr.term := FLetIn n (mk_clos e b) (mk_clos e t) c e |}, stk)
  | Constr.Evar ev =&gt;
    ({| fconstr.mark := mark Red Unknown; fconstr.term := FEvar ev e |}, stk)
  end.

Definition inject (c : Constr.constr) : fconstr := mk_clos (subs_id 0) c.

Import Primred.

Module FNativeEntries.
  Definition elem := fconstr.
  
  Definition args := array fconstr.
  
  Definition evd := unit.
  
  Definition get {A : Set} : array A -&gt; Z -&gt; A :=
    (|Util.Array|).(CArray.ExtS.get).
  
  Definition get_int (function_parameter : unit) : fconstr -&gt; Uint63.t :=
    let '_ := function_parameter in
    fun e =&gt;
      match fconstr.term e with
      | FInt i =&gt; i
      | _ =&gt; Stdlib.raise extensible_type_value
      end.
  
  Definition dummy : fconstr :=
    {| fconstr.mark := mark Norm KnownR; fconstr.term := FRel 0 |}.
  
  Definition current_retro : Stdlib.ref Retroknowledge.retroknowledge :=
    Stdlib.__ref_value Retroknowledge.empty.
  
  Definition defined_int : Stdlib.ref bool := Stdlib.__ref_value false.
  
  Definition fint : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition init_int (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retroknowledge.retro_int63 retro with
    | Some c =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Stdlib.op_coloneq fint
        {| fconstr.mark := mark Norm KnownR;
          fconstr.term := FFlex (Names.ConstKey (Univ.in_punivs c)) |}
    | None =&gt; Stdlib.op_coloneq defined_int false
    end.
  
  Definition defined_bool : Stdlib.ref bool := Stdlib.__ref_value false.
  
  Definition ftrue : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition ffalse : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition init_bool (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retroknowledge.retro_bool retro with
    | Some (ct, cf) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Stdlib.op_coloneq ffalse
        {| fconstr.mark := mark Cstr KnownR;
          fconstr.term := FConstruct (Univ.in_punivs cf) |}
    | None =&gt; Stdlib.op_coloneq defined_bool false
    end.
  
  Definition defined_carry : Stdlib.ref bool := Stdlib.__ref_value false.
  
  Definition fC0 : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition fC1 : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition init_carry (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retroknowledge.retro_carry retro with
    | Some (c0, c1) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Stdlib.op_coloneq fC1
        {| fconstr.mark := mark Cstr KnownR;
          fconstr.term := FConstruct (Univ.in_punivs c1) |}
    | None =&gt; Stdlib.op_coloneq defined_carry false
    end.
  
  Definition defined_pair : Stdlib.ref bool := Stdlib.__ref_value false.
  
  Definition fPair : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition init_pair (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retroknowledge.retro_pair retro with
    | Some c =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Stdlib.op_coloneq fPair
        {| fconstr.mark := mark Cstr KnownR;
          fconstr.term := FConstruct (Univ.in_punivs c) |}
    | None =&gt; Stdlib.op_coloneq defined_pair false
    end.
  
  Definition defined_cmp : Stdlib.ref bool := Stdlib.__ref_value false.
  
  Definition fEq : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition fLt : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition fGt : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition init_cmp (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retroknowledge.retro_cmp retro with
    | Some (cEq, cLt, cGt) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Stdlib.op_coloneq fGt
        {| fconstr.mark := mark Cstr KnownR;
          fconstr.term := FConstruct (Univ.in_punivs cGt) |}
    | None =&gt; Stdlib.op_coloneq defined_cmp false
    end.
  
  Definition defined_refl : Stdlib.ref bool := Stdlib.__ref_value false.
  
  Definition frefl : Stdlib.ref fconstr := Stdlib.__ref_value dummy.
  
  Definition init_refl (retro : Retroknowledge.retroknowledge) : unit :=
    match Retroknowledge.retroknowledge.retro_refl retro with
    | Some crefl =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Stdlib.op_coloneq frefl
        {| fconstr.mark := mark Cstr KnownR;
          fconstr.term := FConstruct (Univ.in_punivs crefl) |}
    | None =&gt; Stdlib.op_coloneq defined_refl false
    end.
  
  Definition init (env : Environ.env) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    init_refl (Stdlib.op_exclamation current_retro).
  
  Definition check_env (env : Environ.env) : unit :=
    if
      negb
        (Stdlib.op_eqeq (Stdlib.op_exclamation current_retro)
          (Environ.env.retroknowledge env)) then
      init env
    else
      tt.
  
  Definition check_int (env : Environ.env) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Assert instruction is not handled. *)
    assert (Stdlib.op_exclamation defined_int).
  
  Definition check_bool (env : Environ.env) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Assert instruction is not handled. *)
    assert (Stdlib.op_exclamation defined_bool).
  
  Definition check_carry (env : Environ.env) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Assert instruction is not handled. *)
    assert
      (andb (Stdlib.op_exclamation defined_carry)
        (Stdlib.op_exclamation defined_int)).
  
  Definition check_pair (env : Environ.env) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Assert instruction is not handled. *)
    assert
      (andb (Stdlib.op_exclamation defined_pair)
        (Stdlib.op_exclamation defined_int)).
  
  Definition check_cmp (env : Environ.env) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Assert instruction is not handled. *)
    assert (Stdlib.op_exclamation defined_cmp).
  
  Definition mkInt (env : Environ.env) (i : Uint63.t) : fconstr :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    {| fconstr.mark := mark Cstr KnownR; fconstr.term := FInt i |}.
  
  Definition mkBool (env : Environ.env) (b : bool) : fconstr :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    if b then
      Stdlib.op_exclamation ftrue
    else
      Stdlib.op_exclamation ffalse.
  
  Definition mkCarry (env : Environ.env) (b : bool) (e : fconstr) : fconstr :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    {| fconstr.mark := mark Cstr KnownR;
      fconstr.term :=
        FApp
          (if b then
            Stdlib.op_exclamation fC1
          else
            Stdlib.op_exclamation fC0)
          (* ❌ Arrays not handled. *)
          [ Stdlib.op_exclamation fint; e ] |}.
  
  Definition mkIntPair (env : Environ.env) (e1 : fconstr) (e2 : fconstr)
    : fconstr :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    {| fconstr.mark := mark Cstr KnownR;
      fconstr.term :=
        FApp (Stdlib.op_exclamation fPair)
          (* ❌ Arrays not handled. *)
          [ Stdlib.op_exclamation fint; Stdlib.op_exclamation fint; e1; e2 ] |}.
  
  Definition mkLt (env : Environ.env) : fconstr :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.op_exclamation fLt.
  
  Definition mkEq (env : Environ.env) : fconstr :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.op_exclamation fEq.
  
  Definition mkGt (env : Environ.env) : fconstr :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.op_exclamation fGt.
End FNativeEntries.

Definition FredNative :=
  RedNative
    (existT _ [_, _, _]
      {|
        Primred.RedNativeEntries.get := FNativeEntries.get;
        Primred.RedNativeEntries.get_int := FNativeEntries.get_int;
        Primred.RedNativeEntries.mkInt := FNativeEntries.mkInt;
        Primred.RedNativeEntries.mkBool := FNativeEntries.mkBool;
        Primred.RedNativeEntries.mkCarry := FNativeEntries.mkCarry;
        Primred.RedNativeEntries.mkIntPair := FNativeEntries.mkIntPair;
        Primred.RedNativeEntries.mkLt := FNativeEntries.mkLt;
        Primred.RedNativeEntries.mkEq := FNativeEntries.mkEq;
        Primred.RedNativeEntries.mkGt := FNativeEntries.mkGt
      |}).

Fixpoint knr
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (m : fconstr) (stk : list stack_member) {struct info}
  : fconstr * list stack_member :=
  match
    ((fconstr.term m),
      match fconstr.term m with
      | FLambda n tys f e =&gt;
        (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
          (|RedFlags|).(RedFlagsSig.fBETA)
      | _ =&gt; false
      end,
      match fconstr.term m with
      | FFlex (Names.ConstKey ((kn, _) as c)) =&gt;
        (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
          ((|RedFlags|).(RedFlagsSig.fCONST) kn)
      | _ =&gt; false
      end,
      match fconstr.term m with
      | FFlex (Names.VarKey id) =&gt;
        (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
          ((|RedFlags|).(RedFlagsSig.fVAR) id)
      | _ =&gt; false
      end,
      match fconstr.term m with
      | FFlex (Names.RelKey k) =&gt;
        (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
          (|RedFlags|).(RedFlagsSig.fDELTA)
      | _ =&gt; false
      end,
      match fconstr.term m with
      | FCoFix _ _ =&gt;
        (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
          (|RedFlags|).(RedFlagsSig.fCOFIX)
      | _ =&gt; false
      end,
      match fconstr.term m with
      | FLetIn _ v _ bd e =&gt;
        (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
          (|RedFlags|).(RedFlagsSig.fZETA)
      | _ =&gt; false
      end) with
  | (FLambda n tys f e, true, _, _, _, _, _) =&gt;
    match get_args n tys f e stk with
    | (Util.Inl e', s) =&gt; knit info tab e' f s
    | (Util.Inr lam, s) =&gt; (lam, s)
    end
  | (FFlex (Names.ConstKey ((kn, _) as c)), _, true, _, _, _, _) =&gt;
    match
      ((ref_value_cache info tab (Names.ConstKey c)),
        match ref_value_cache info tab (Names.ConstKey c) with
        | Declarations.Primitive op =&gt; check_native_args op stk
        | _ =&gt; false
        end) with
    | (Declarations.Def v, _) =&gt; kni info tab v stk
    | (Declarations.Primitive op, true) =&gt;
      let '(rargs, a, nargs, stk) := get_native_args1 op c stk in
      kni info tab a (cons (Zprimitive op c rargs nargs) stk)
    |
      (Declarations.Undef _ | Declarations.OpaqueDef _ |
      Declarations.Primitive _, _) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (m, stk)
    end
  | (FFlex (Names.VarKey id), _, _, true, _, _, _) =&gt;
    match ref_value_cache info tab (Names.VarKey id) with
    | Declarations.Def v =&gt; kni info tab v stk
    | Declarations.Primitive _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    | Declarations.OpaqueDef _ | Declarations.Undef _ =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (m, stk)
    end
  | (FFlex (Names.RelKey k), _, _, _, true, _, _) =&gt;
    match ref_value_cache info tab (Names.RelKey k) with
    | Declarations.Def v =&gt; kni info tab v stk
    | Declarations.Primitive _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    | Declarations.OpaqueDef _ | Declarations.Undef _ =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (m, stk)
    end
  | (FConstruct ((_ind, c), _u), _, _, _, _, _, _) =&gt;
    let use_match :=
      (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
        (|RedFlags|).(RedFlagsSig.fMATCH) in
    let use_fix :=
      (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
        (|RedFlags|).(RedFlagsSig.fFIX) in
    if orb use_match use_fix then
      match
        ((strip_update_shift_app m stk),
          match strip_update_shift_app m stk with
          | (depth, args, cons (ZcaseT ci _ br e) s) =&gt; use_match
          | _ =&gt; false
          end,
          match strip_update_shift_app m stk with
          | (_, cargs, cons (Zfix fx par) s) =&gt; use_fix
          | _ =&gt; false
          end,
          match strip_update_shift_app m stk with
          | (depth, args, cons (Zproj p) s) =&gt; use_match
          | _ =&gt; false
          end) with
      | ((depth, args, cons (ZcaseT ci _ br e) s), true, _, _) =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let rargs := drop_parameters depth (Constr.case_info.ci_npar ci) args in
        knit info tab e ((|Util.Array|).(CArray.ExtS.get) br (Z.sub c 1))
          (op_at rargs s)
      | ((_, cargs, cons (Zfix fx par) s), _, true, _) =&gt;
        let rarg := fapp_stack (m, cargs) in
        let stk' :=
          op_at par
            (append_stack
              (* ❌ Arrays not handled. *)
              [ rarg ] s) in
        let '(fxe, fxbd) := contract_fix_vect (fconstr.term fx) in
        knit info tab fxe fxbd stk'
      | ((depth, args, cons (Zproj p) s), _, _, true) =&gt;
        let rargs := drop_parameters depth (Projection.Repr.npars p) args in
        let rarg := project_nth_arg (Projection.Repr.arg p) rargs in
        kni info tab rarg s
      | ((_, args, s), _, _, _) =&gt; (m, (op_at args s))
      end
    else
      (m, stk)
  | (FCoFix _ _, _, _, _, _, true, _) =&gt;
    match strip_update_shift_app m stk with
    | (_, args, (cons (ZcaseT _ _ _ _ | Zproj _) _) as stk') =&gt;
      let '(fxe, fxbd) := contract_fix_vect (fconstr.term m) in
      knit info tab fxe fxbd (op_at args stk')
    |
      (_, args,
        (cons (Zapp _ | Zfix _ _ | Zshift _ | Zupdate _ | Zprimitive _ _ _ _) _
        | []) as s) =&gt; (m, (op_at args s))
    end
  | (FLetIn _ v _ bd e, _, _, _, _, _, true) =&gt;
    knit info tab
      (subs_cons
        ((* ❌ Arrays not handled. *)
        [ v ], e)) bd stk
  | (FEvar ev env, _, _, _, _, _, _) =&gt;
    match (infos_cache.i_sigma (clos_infos.i_cache info)) ev with
    | Some c =&gt; knit info tab env c stk
    | None =&gt; (m, stk)
    end
  | (FInt _, _, _, _, _, _, _) =&gt;
    match strip_update_shift_app m stk with
    | (_, _, cons (Zprimitive op c rargs nargs) s) =&gt;
      let '(rargs, nargs) := skip_native_args (cons m rargs) nargs in
      match nargs with
      | [] =&gt;
        let args :=
          (|Util.Array|).(CArray.ExtS.of_list)
            ((|Util.List|).(CList.ExtS.rev) rargs) in
        match
          (|FredNative|).(Primred.RedNative.red_prim) (info_env info) tt op args
          with
        | Some m =&gt; kni info tab m s
        | None =&gt;
          let f :=
            {| fconstr.mark := mark Whnf KnownR;
              fconstr.term := FFlex (Names.ConstKey c) |} in
          let m :=
            {| fconstr.mark := mark Whnf KnownR; fconstr.term := FApp f args |}
            in
          (m, s)
        end
      | cons (kd, a) nargs =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        kni info tab a (cons (Zprimitive op c rargs nargs) s)
      end
    | (_, _, s) =&gt; (m, s)
    end
  |
    (FLOCKED | FRel _ | FAtom _ |
    FFlex (Names.RelKey _ | Names.ConstKey _ | Names.VarKey _) | FInd _ |
    FApp _ _ | FProj _ _ | FFix _ _ | FCoFix _ _ | FCaseT _ _ _ _ _ |
    FLambda _ _ _ _ | FProd _ _ _ _ | FLetIn _ _ _ _ _ | FLIFT _ _ | FCLOS _ _,
      _, _, _, _, _, _) =&gt; (m, stk)
  end

with kni
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (m : fconstr) (stk : list stack_member) {struct info}
  : fconstr * list stack_member :=
  let '(hm, s) := knh info m stk in
  knr info tab hm s

with knit
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (e : Esubst.subs fconstr) (t : Constr.constr) (stk : list stack_member)
  {struct info} : fconstr * list stack_member :=
  let '(ht, s) := knht info e t stk in
  knr info tab ht s.

Definition kh
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (v : fconstr) (stk : list stack_member) : fconstr :=
  fapp_stack (kni info tab v stk).

Fixpoint zip_term
  (zfun : fconstr -&gt; Constr.constr) (m : Constr.constr) (stk : stack)
  {struct zfun} : Constr.constr :=
  match stk with
  | [] =&gt; m
  | cons (Zapp args) s =&gt;
    zip_term zfun (mkApp (m, ((|Util.Array|).(CArray.ExtS.map) zfun args))) s
  | cons (ZcaseT ci p br e) s =&gt;
    let t :=
      mkCase
        (ci, (zfun (mk_clos e p)), m,
          ((|Util.Array|).(CArray.ExtS.map) (fun b =&gt; zfun (mk_clos e b)) br))
      in
    zip_term zfun t s
  | cons (Zproj p) s =&gt;
    let t := mkProj ((Projection.make p true), m) in
    zip_term zfun t s
  | cons (Zfix fx par) s =&gt;
    let h :=
      mkApp
        ((zip_term zfun (zfun fx) par),
          (* ❌ Arrays not handled. *)
          [ m ]) in
    zip_term zfun h s
  | cons (Zshift n) s =&gt; zip_term zfun (lift n m) s
  | cons (Zupdate _rf) s =&gt; zip_term zfun m s
  | cons (Zprimitive _ c rargs kargs) s =&gt;
    let kargs :=
      (|Util.List|).(CList.ExtS.map)
        (fun function_parameter =&gt;
          let '(_, a) := function_parameter in
          zfun a) kargs in
    let args :=
      (|Util.List|).(CList.ExtS.fold_left)
        (fun args =&gt; fun a =&gt; cons (zfun a) args) (cons m kargs) rargs in
    let h := mkApp ((mkConstU c), ((|Util.Array|).(CArray.ExtS.of_list) args))
      in
    zip_term zfun h s
  end.

Fixpoint kl
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (m : fconstr) {struct info} : Constr.constr :=
  let share := infos_cache.i_share (clos_infos.i_cache info) in
  if is_val m then
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    term_of_fconstr m
  else
    let '(nm, s) := kni info tab m [] in
    let '_ :=
      if share then
        OCaml.Stdlib.ignore (fapp_stack (nm, s))
      else
        tt in
    zip_term (kl info tab) (norm_head info tab nm) s

with norm_head
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (m : fconstr) {struct info} : Constr.constr :=
  if is_val m then
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    term_of_fconstr m
  else
    match fconstr.term m with
    | FLambda _n tys f e =&gt;
      let '(e', info, rvtys) :=
        (|Util.List|).(CList.ExtS.fold_left)
          (fun function_parameter =&gt;
            let '(e, info, ctxt) := function_parameter in
            fun function_parameter =&gt;
              let '(na, ty) := function_parameter in
              ((subs_lift e), info,
                (cons (na, (kl info tab (mk_clos e ty))) ctxt))) (e, info, [])
          tys in
      let bd := kl info tab (mk_clos e' f) in
      (|Util.List|).(CList.ExtS.fold_left)
        (fun b =&gt;
          fun function_parameter =&gt;
            let '(na, ty) := function_parameter in
            mkLambda (na, ty, b)) bd rvtys
    | FLetIn na a b f e =&gt;
      let c := mk_clos (subs_lift e) f in
      mkLetIn (na, (kl info tab a), (kl info tab b), (kl info tab c))
    | FProd na dom rng e =&gt;
      mkProd (na, (kl info tab dom), (kl info tab (mk_clos (subs_lift e) rng)))
    | FCoFix (n, (na, tys, bds)) e =&gt;
      let ftys := Array.Fun1.map mk_clos e tys in
      let fbds :=
        Array.Fun1.map mk_clos
          (subs_liftn ((|Util.Array|).(CArray.ExtS.length) na) e) bds in
      mkCoFix
        (n,
          (na, ((|CArray|).(CArray.ExtS.map) (kl info tab) ftys),
            ((|CArray|).(CArray.ExtS.map) (kl info tab) fbds)))
    | FFix (n, (na, tys, bds)) e =&gt;
      let ftys := Array.Fun1.map mk_clos e tys in
      let fbds :=
        Array.Fun1.map mk_clos
          (subs_liftn ((|Util.Array|).(CArray.ExtS.length) na) e) bds in
      mkFix
        (n,
          (na, ((|CArray|).(CArray.ExtS.map) (kl info tab) ftys),
            ((|CArray|).(CArray.ExtS.map) (kl info tab) fbds)))
    | FEvar (i, args) env =&gt;
      mkEvar
        (i,
          ((|Util.Array|).(CArray.ExtS.map)
            (fun a =&gt; kl info tab (mk_clos env a)) args))
    | FProj p c =&gt; mkProj (p, (kl info tab c))
    |
      FLOCKED | FRel _ | FAtom _ | FFlex _ | FInd _ | FConstruct _ | FApp _ _ |
      FCaseT _ _ _ _ _ | FLIFT _ _ | FCLOS _ _ | FInt _ =&gt; term_of_fconstr m
    end.

Definition whd_val
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (v : fconstr) : Constr.constr :=
  with_stats
    (* ❌ Lazy expressions are not handled *)
    (lazy (term_of_fconstr (kh info tab v []))).

Definition norm_val
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (v : fconstr) : Constr.constr :=
  with_stats
    (* ❌ Lazy expressions are not handled *)
    (lazy (kl info tab v)).

Definition whd_stack
  (infos : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (m : fconstr) (stk : list stack_member) : fconstr * list stack_member :=
  match Mark.red_state (fconstr.mark m) with
  | Whnf | Norm =&gt; knh infos m stk
  | Red | Cstr =&gt;
    let k := kni infos tab m stk in
    let '_ :=
      if infos_cache.i_share (clos_infos.i_cache infos) then
        OCaml.Stdlib.ignore (fapp_stack k)
      else
        tt in
    k
  end.

Definition create_clos_infos
  (op_staroptstar : option (Constr.existential -&gt; option Constr.constr))
  : (|RedFlags|).(RedFlagsSig.reds) -&gt; Environ.env -&gt; clos_infos :=
  let evars :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        None
    end in
  fun flgs =&gt;
    fun env =&gt;
      let share :=
        Declarations.typing_flags.share_reduction (Environ.typing_flags env) in
      let cache :=
        {| infos_cache.i_env := env; infos_cache.i_sigma := evars;
          infos_cache.i_share := share |} in
      {| clos_infos.i_flags := flgs; clos_infos.i_cache := cache |}.

Definition create_tab {A : Set} (function_parameter : unit)
  : (|KeyTable|).(Stdlib__hashtbl.S.t) A :=
  let '_ := function_parameter in
  (|KeyTable|).(Stdlib__hashtbl.S.create) 17.

Definition oracle_of_infos (infos : clos_infos) : Conv_oracle.oracle :=
  Environ.oracle (infos_cache.i_env (clos_infos.i_cache infos)).

Definition infos_with_reds
  (infos : clos_infos) (reds : (|RedFlags|).(RedFlagsSig.reds)) : clos_infos :=
  clos_infos.with_i_flags infos reds.

Definition unfold_reference
  (info : clos_infos)
  (tab : (|KeyTable|).(Stdlib__hashtbl.S.t) (Declarations.constant_def fconstr))
  (key : (|KeyTable|).(Stdlib__hashtbl.S.key))
  : Declarations.constant_def fconstr :=
  match key with
  | Names.ConstKey (kn, _) =&gt;
    if
      (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
        ((|RedFlags|).(RedFlagsSig.fCONST) kn) then
      ref_value_cache info tab key
    else
      Declarations.Undef None
  | Names.VarKey i =&gt;
    if
      (|RedFlags|).(RedFlagsSig.red_set) (clos_infos.i_flags info)
        ((|RedFlags|).(RedFlagsSig.fVAR) i) then
      ref_value_cache info tab key
    else
      Declarations.Undef None
  | Names.RelKey _ =&gt; ref_value_cache info tab key
  end.

Definition relevance_of (f : fconstr) : optrel :=
  Mark.relevance (fconstr.mark f).

Definition set_relevance (r : Sorts.relevance) (f : fconstr) : unit :=
  (* ❌ Set record field not handled. *)
  set_record_field f &quot;mark&quot;
    (Mark.mark (Mark.red_state (fconstr.mark f)) (opt_of_rel r)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cClosure.mli">
  <div style="margin: 20px;">
    <h3>CClosure_mli</h3>
    <ul>
      <li>OCaml size: 235 lines</li>
      <li>Coq size: 212 lines (-10% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cClosure.mli"><code>cClosure.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Declarations
open Environ
open Esubst

(** Flags for profiling reductions. *)
val stats : bool ref

val with_stats: 'a Lazy.t -&gt; 'a

(** {6 ... } *)
(** Delta implies all consts (both global (= by
  [kernel_name]) and local (= by [Rel] or [Var])), all evars, and letin's.
  Rem: reduction of a Rel/Var bound to a term is Delta, but reduction of
  a LetIn expression is Letin reduction *)

(** Sets of reduction kinds. *)
module type RedFlagsSig = sig
  type reds
  type red_kind

  (** {7 The different kinds of reduction } *)

  val fBETA : red_kind
  val fDELTA : red_kind
  val fETA : red_kind
  (** The fETA flag is never used by the kernel reduction but pretyping does *)
  val fMATCH : red_kind
  val fFIX : red_kind
  val fCOFIX : red_kind
  val fZETA : red_kind
  val fCONST : Constant.t -&gt; red_kind
  val fVAR : Id.t -&gt; red_kind

  (** No reduction at all *)
  val no_red : reds

  (** Adds a reduction kind to a set *)
  val red_add : reds -&gt; red_kind -&gt; reds

  (** Removes a reduction kind to a set *)
  val red_sub : reds -&gt; red_kind -&gt; reds

  (** Adds a reduction kind to a set *)
  val red_add_transparent : reds -&gt; TransparentState.t -&gt; reds

  (** Retrieve the transparent state of the reduction flags *)
  val red_transparent : reds -&gt; TransparentState.t

  (** Build a reduction set from scratch = iter [red_add] on [no_red] *)
  val mkflags : red_kind list -&gt; reds

  (** Tests if a reduction kind is set *)
  val red_set : reds -&gt; red_kind -&gt; bool

  (** This tests if the projection is in unfolded state already or
      is unfodable due to delta. *)
  val red_projection : reds -&gt; Projection.t -&gt; bool
end

module RedFlags : RedFlagsSig
open RedFlags

(* These flags do not contain eta *)
val all               : reds
val allnolet          : reds
val beta              : reds
val betadeltazeta     : reds
val betaiota          : reds
val betaiotazeta      : reds
val betazeta          : reds
val delta             : reds
val zeta              : reds
val nored             : reds


val unfold_side_red : reds
val unfold_red : evaluable_global_reference -&gt; reds

(***********************************************************************)
type table_key = Constant.t Univ.puniverses tableKey

module KeyTable : Hashtbl.S with type key = table_key

(***********************************************************************
  s Lazy reduction. *)

(** [fconstr] is the type of frozen constr *)

type fconstr

(** [fconstr] can be accessed by using the function [fterm_of] and by
   matching on type [fterm] *)

type fterm =
  | FRel of int
  | FAtom of constr (** Metas and Sorts *)
  | FFlex of table_key
  | FInd of inductive Univ.puniverses
  | FConstruct of constructor Univ.puniverses
  | FApp of fconstr * fconstr array
  | FProj of Projection.t * fconstr
  | FFix of fixpoint * fconstr subs
  | FCoFix of cofixpoint * fconstr subs
  | FCaseT of case_info * constr * fconstr * constr array * fconstr subs (* predicate and branches are closures *)
  | FLambda of int * (Name.t Context.binder_annot * constr) list * constr * fconstr subs
  | FProd of Name.t Context.binder_annot * fconstr * constr * fconstr subs
  | FLetIn of Name.t Context.binder_annot * fconstr * fconstr * constr * fconstr subs
  | FEvar of existential * fconstr subs
  | FInt of Uint63.t
  | FLIFT of int * fconstr
  | FCLOS of constr * fconstr subs
  | FLOCKED

(***********************************************************************
  s A [stack] is a context of arguments, arguments are pushed by
   [append_stack] one array at a time *)
type 'a next_native_args = (CPrimitives.arg_kind * 'a) list

type stack_member =
  | Zapp of fconstr array
  | ZcaseT of case_info * constr * constr array * fconstr subs
  | Zproj of Projection.Repr.t
  | Zfix of fconstr * stack
  | Zprimitive of CPrimitives.t * pconstant * fconstr list * fconstr next_native_args
       (* operator, constr def, reduced arguments rev, next arguments *)
  | Zshift of int
  | Zupdate of fconstr

and stack = stack_member list

val empty_stack : stack
val append_stack : fconstr array -&gt; stack -&gt; stack

val check_native_args : CPrimitives.t -&gt; stack -&gt; bool
val get_native_args1 : CPrimitives.t -&gt; pconstant -&gt; stack -&gt;
  fconstr list * fconstr * fconstr next_native_args * stack

val stack_args_size : stack -&gt; int
val eta_expand_stack : stack -&gt; stack

(** To lazy reduce a constr, create a [clos_infos] with
   [create_clos_infos], inject the term to reduce with [inject]; then use
   a reduction function *)

val inject : constr -&gt; fconstr

(** mk_atom: prevents a term from being evaluated *)
val mk_atom : constr -&gt; fconstr

(** mk_red: makes a reducible term (used in newring) *)
val mk_red : fterm -&gt; fconstr

val fterm_of : fconstr -&gt; fterm
val term_of_fconstr : fconstr -&gt; constr
val destFLambda :
  (fconstr subs -&gt; constr -&gt; fconstr) -&gt; fconstr -&gt; Name.t Context.binder_annot * fconstr * fconstr

type optrel = Unknown | KnownR | KnownI

val relevance_of : fconstr -&gt; optrel
val set_relevance : Sorts.relevance -&gt; fconstr -&gt; unit

(** Global and local constant cache *)
type clos_infos
type clos_tab
val create_clos_infos :
  ?evars:(existential-&gt;constr option) -&gt; reds -&gt; env -&gt; clos_infos
val oracle_of_infos : clos_infos -&gt; Conv_oracle.oracle

val create_tab : unit -&gt; clos_tab

val info_env : clos_infos -&gt; env
val info_flags: clos_infos -&gt; reds
val unfold_projection : clos_infos -&gt; Projection.t -&gt; stack_member option

val infos_with_reds : clos_infos -&gt; reds -&gt; clos_infos

(** Reduction function *)

(** [norm_val] is for strong normalization *)
val norm_val : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; constr

(** [whd_val] is for weak head normalization *)
val whd_val : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; constr

(** [whd_stack] performs weak head normalization in a given stack. It
   stops whenever a reduction is blocked. *)
val whd_stack :
  clos_infos -&gt; clos_tab -&gt; fconstr -&gt; stack -&gt; fconstr * stack

(** [eta_expand_ind_stack env ind c s t] computes stacks corresponding
    to the conversion of the eta expansion of t, considered as an inhabitant
    of ind, and the Constructor c of this inductive type applied to arguments
    s.
    @assumes [t] is a rigid term, and not a constructor. [ind] is the inductive
    of the constructor term [c]
    @raise Not_found if the inductive is not a primitive record, or if the
    constructor is partially applied.
 *)
val eta_expand_ind_stack : env -&gt; inductive -&gt; fconstr -&gt; stack -&gt;
   (fconstr * stack) -&gt; stack * stack

(** Conversion auxiliary functions to do step by step normalisation *)

(** [unfold_reference] unfolds references in a [fconstr] *)
val unfold_reference : clos_infos -&gt; clos_tab -&gt; table_key -&gt; fconstr constant_def

(***********************************************************************
  i This is for lazy debug *)

val lift_fconstr      : int -&gt; fconstr -&gt; fconstr
val lift_fconstr_vect : int -&gt; fconstr array -&gt; fconstr array

val mk_clos      : fconstr subs -&gt; constr -&gt; fconstr
val mk_clos_vect : fconstr subs -&gt; constr array -&gt; fconstr array

val kni: clos_infos -&gt; clos_tab -&gt; fconstr -&gt; stack -&gt; fconstr * stack
val knr: clos_infos -&gt; clos_tab -&gt; fconstr -&gt; stack -&gt; fconstr * stack
val kl : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; constr

val to_constr : lift -&gt; fconstr -&gt; constr

(** End of cbn debug section i*)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cClosure.mli"><code>CClosure_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter stats : Stdlib.ref bool.

Parameter with_stats : forall {a : Set}, Stdlib.Lazy.t a -&gt; a.

Module RedFlagsSig.
  Record signature {reds red_kind : Set} := {
    reds := reds;
    red_kind := red_kind;
    fBETA : red_kind;
    fDELTA : red_kind;
    fETA : red_kind;
    fMATCH : red_kind;
    fFIX : red_kind;
    fCOFIX : red_kind;
    fZETA : red_kind;
    fCONST : Names.Constant.t -&gt; red_kind;
    fVAR : Names.Id.t -&gt; red_kind;
    no_red : reds;
    red_add : reds -&gt; red_kind -&gt; reds;
    red_sub : reds -&gt; red_kind -&gt; reds;
    red_add_transparent : reds -&gt; TransparentState.t -&gt; reds;
    red_transparent : reds -&gt; TransparentState.t;
    mkflags : list red_kind -&gt; reds;
    red_set : reds -&gt; red_kind -&gt; bool;
    red_projection : reds -&gt; Names.Projection.t -&gt; bool;
  }.
  Arguments signature : clear implicits.
End RedFlagsSig.

Parameter RedFlags :
  {'[reds, red_kind] : _ &amp; RedFlagsSig.signature reds red_kind}.

Parameter all : (|RedFlags|).(RedFlagsSig.reds).

Parameter allnolet : (|RedFlags|).(RedFlagsSig.reds).

Parameter beta : (|RedFlags|).(RedFlagsSig.reds).

Parameter betadeltazeta : (|RedFlags|).(RedFlagsSig.reds).

Parameter betaiota : (|RedFlags|).(RedFlagsSig.reds).

Parameter betaiotazeta : (|RedFlags|).(RedFlagsSig.reds).

Parameter betazeta : (|RedFlags|).(RedFlagsSig.reds).

Parameter delta : (|RedFlags|).(RedFlagsSig.reds).

Parameter zeta : (|RedFlags|).(RedFlagsSig.reds).

Parameter nored : (|RedFlags|).(RedFlagsSig.reds).

Parameter unfold_side_red : (|RedFlags|).(RedFlagsSig.reds).

Parameter unfold_red :
  Names.evaluable_global_reference -&gt; (|RedFlags|).(RedFlagsSig.reds).

Definition table_key := Names.tableKey (Univ.puniverses Names.Constant.t).

Parameter KeyTable : {t : _ &amp; Hashtbl.S.signature table_key t}.

Parameter fconstr : Set.

Inductive fterm : Set :=
| FRel : Z -&gt; fterm
| FAtom : Constr.constr -&gt; fterm
| FFlex : table_key -&gt; fterm
| FInd : Univ.puniverses Names.inductive -&gt; fterm
| FConstruct : Univ.puniverses Names.constructor -&gt; fterm
| FApp : fconstr -&gt; array fconstr -&gt; fterm
| FProj : Names.Projection.t -&gt; fconstr -&gt; fterm
| FFix : Constr.fixpoint -&gt; Esubst.subs fconstr -&gt; fterm
| FCoFix : Constr.cofixpoint -&gt; Esubst.subs fconstr -&gt; fterm
| FCaseT :
  Constr.case_info -&gt; Constr.constr -&gt; fconstr -&gt; array Constr.constr -&gt;
  Esubst.subs fconstr -&gt; fterm
| FLambda :
  Z -&gt; list (Context.binder_annot Names.Name.t * Constr.constr) -&gt;
  Constr.constr -&gt; Esubst.subs fconstr -&gt; fterm
| FProd :
  Context.binder_annot Names.Name.t -&gt; fconstr -&gt; Constr.constr -&gt;
  Esubst.subs fconstr -&gt; fterm
| FLetIn :
  Context.binder_annot Names.Name.t -&gt; fconstr -&gt; fconstr -&gt; Constr.constr -&gt;
  Esubst.subs fconstr -&gt; fterm
| FEvar : Constr.existential -&gt; Esubst.subs fconstr -&gt; fterm
| FInt : Uint63.t -&gt; fterm
| FLIFT : Z -&gt; fconstr -&gt; fterm
| FCLOS : Constr.constr -&gt; Esubst.subs fconstr -&gt; fterm
| FLOCKED : fterm.

Definition next_native_args (a : Set) := list (CPrimitives.arg_kind * a).

Reserved Notation &quot;'stack&quot;.

Inductive stack_member : Set :=
| Zapp : array fconstr -&gt; stack_member
| ZcaseT :
  Constr.case_info -&gt; Constr.constr -&gt; array Constr.constr -&gt;
  Esubst.subs fconstr -&gt; stack_member
| Zproj : Names.Projection.Repr.t -&gt; stack_member
| Zfix : fconstr -&gt; 'stack -&gt; stack_member
| Zprimitive :
  CPrimitives.t -&gt; Constr.pconstant -&gt; list fconstr -&gt;
  next_native_args fconstr -&gt; stack_member
| Zshift : Z -&gt; stack_member
| Zupdate : fconstr -&gt; stack_member

where &quot;'stack&quot; := (list stack_member).

Definition stack := 'stack.

Parameter empty_stack : stack.

Parameter append_stack : array fconstr -&gt; stack -&gt; stack.

Parameter check_native_args : CPrimitives.t -&gt; stack -&gt; bool.

Parameter get_native_args1 :
  CPrimitives.t -&gt; Constr.pconstant -&gt; stack -&gt;
  list fconstr * fconstr * next_native_args fconstr * stack.

Parameter stack_args_size : stack -&gt; Z.

Parameter eta_expand_stack : stack -&gt; stack.

Parameter inject : Constr.constr -&gt; fconstr.

Parameter mk_atom : Constr.constr -&gt; fconstr.

Parameter mk_red : fterm -&gt; fconstr.

Parameter fterm_of : fconstr -&gt; fterm.

Parameter term_of_fconstr : fconstr -&gt; Constr.constr.

Parameter destFLambda :
  (Esubst.subs fconstr -&gt; Constr.constr -&gt; fconstr) -&gt; fconstr -&gt;
  Context.binder_annot Names.Name.t * fconstr * fconstr.

Inductive optrel : Set :=
| Unknown : optrel
| KnownR : optrel
| KnownI : optrel.

Parameter relevance_of : fconstr -&gt; optrel.

Parameter set_relevance : Sorts.relevance -&gt; fconstr -&gt; unit.

Parameter clos_infos : Set.

Parameter clos_tab : Set.

Parameter create_clos_infos :
  option (Constr.existential -&gt; option Constr.constr) -&gt;
  (|RedFlags|).(RedFlagsSig.reds) -&gt; Environ.env -&gt; clos_infos.

Parameter oracle_of_infos : clos_infos -&gt; Conv_oracle.oracle.

Parameter create_tab : unit -&gt; clos_tab.

Parameter info_env : clos_infos -&gt; Environ.env.

Parameter info_flags : clos_infos -&gt; (|RedFlags|).(RedFlagsSig.reds).

Parameter unfold_projection :
  clos_infos -&gt; Names.Projection.t -&gt; option stack_member.

Parameter infos_with_reds :
  clos_infos -&gt; (|RedFlags|).(RedFlagsSig.reds) -&gt; clos_infos.

Parameter norm_val : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; Constr.constr.

Parameter whd_val : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; Constr.constr.

Parameter whd_stack :
  clos_infos -&gt; clos_tab -&gt; fconstr -&gt; stack -&gt; fconstr * stack.

Parameter eta_expand_ind_stack :
  Environ.env -&gt; Names.inductive -&gt; fconstr -&gt; stack -&gt; fconstr * stack -&gt;
  stack * stack.

Parameter unfold_reference :
  clos_infos -&gt; clos_tab -&gt; table_key -&gt; Declarations.constant_def fconstr.

Parameter lift_fconstr : Z -&gt; fconstr -&gt; fconstr.

Parameter lift_fconstr_vect : Z -&gt; array fconstr -&gt; array fconstr.

Parameter mk_clos : Esubst.subs fconstr -&gt; Constr.constr -&gt; fconstr.

Parameter mk_clos_vect :
  Esubst.subs fconstr -&gt; array Constr.constr -&gt; array fconstr.

Parameter kni : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; stack -&gt; fconstr * stack.

Parameter knr : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; stack -&gt; fconstr * stack.

Parameter kl : clos_infos -&gt; clos_tab -&gt; fconstr -&gt; Constr.constr.

Parameter to_constr : Esubst.lift -&gt; fconstr -&gt; Constr.constr.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cPrimitives.ml">
  <div style="margin: 20px;">
    <h3>CPrimitives</h3>
    <ul>
      <li>OCaml size: 155 lines</li>
      <li>Coq size: 154 lines (-1% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cPrimitives.ml"><code>cPrimitives.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t =
  | Int63head0
  | Int63tail0
  | Int63add
  | Int63sub
  | Int63mul
  | Int63div
  | Int63mod
  | Int63lsr
  | Int63lsl
  | Int63land
  | Int63lor
  | Int63lxor
  | Int63addc
  | Int63subc
  | Int63addCarryC
  | Int63subCarryC
  | Int63mulc
  | Int63diveucl
  | Int63div21
  | Int63addMulDiv
  | Int63eq
  | Int63lt
  | Int63le
  | Int63compare

let equal (p1 : t) (p2 : t) =
  p1 == p2

let hash = function
  | Int63head0 -&gt; 1
  | Int63tail0 -&gt; 2
  | Int63add -&gt; 3
  | Int63sub -&gt; 4
  | Int63mul -&gt; 5
  | Int63div -&gt; 6
  | Int63mod -&gt; 7
  | Int63lsr -&gt; 8
  | Int63lsl -&gt; 9
  | Int63land -&gt; 10
  | Int63lor -&gt; 11
  | Int63lxor -&gt; 12
  | Int63addc -&gt; 13
  | Int63subc -&gt; 14
  | Int63addCarryC -&gt; 15
  | Int63subCarryC -&gt; 16
  | Int63mulc -&gt; 17
  | Int63diveucl -&gt; 18
  | Int63div21 -&gt; 19
  | Int63addMulDiv -&gt; 20
  | Int63eq -&gt; 21
  | Int63lt -&gt; 22
  | Int63le -&gt; 23
  | Int63compare -&gt; 24

(* Should match names in nativevalues.ml *)
let to_string = function
  | Int63head0 -&gt; &quot;head0&quot;
  | Int63tail0 -&gt; &quot;tail0&quot;
  | Int63add -&gt; &quot;add&quot;
  | Int63sub -&gt; &quot;sub&quot;
  | Int63mul -&gt; &quot;mul&quot;
  | Int63div -&gt; &quot;div&quot;
  | Int63mod -&gt; &quot;rem&quot;
  | Int63lsr -&gt; &quot;l_sr&quot;
  | Int63lsl -&gt; &quot;l_sl&quot;
  | Int63land -&gt; &quot;l_and&quot;
  | Int63lor -&gt; &quot;l_or&quot;
  | Int63lxor -&gt; &quot;l_xor&quot;
  | Int63addc -&gt; &quot;addc&quot;
  | Int63subc -&gt; &quot;subc&quot;
  | Int63addCarryC -&gt; &quot;addCarryC&quot;
  | Int63subCarryC -&gt; &quot;subCarryC&quot;
  | Int63mulc -&gt; &quot;mulc&quot;
  | Int63diveucl -&gt; &quot;diveucl&quot;
  | Int63div21 -&gt; &quot;div21&quot;
  | Int63addMulDiv -&gt; &quot;addMulDiv&quot;
  | Int63eq -&gt; &quot;eq&quot;
  | Int63lt -&gt; &quot;lt&quot;
  | Int63le -&gt; &quot;le&quot;
  | Int63compare -&gt; &quot;compare&quot;

type arg_kind =
  | Kparam (* not needed for the evaluation of the primitive when it reduces *)
  | Kwhnf  (* need to be reduced in whnf before reducing the primitive *)
  | Karg   (* no need to be reduced in whnf. example: [v] in [Array.set t i v] *)

type args_red = arg_kind list

(* Invariant only argument of type int63 or an inductive can
   have kind Kwhnf *)

let kind = function
  | Int63head0 | Int63tail0 -&gt; [Kwhnf]

  | Int63add | Int63sub | Int63mul
  | Int63div | Int63mod
  | Int63lsr | Int63lsl
  | Int63land | Int63lor | Int63lxor
  | Int63addc | Int63subc
  | Int63addCarryC | Int63subCarryC  | Int63mulc | Int63diveucl
  | Int63eq | Int63lt | Int63le | Int63compare -&gt; [Kwhnf; Kwhnf]

  | Int63div21 | Int63addMulDiv -&gt; [Kwhnf; Kwhnf; Kwhnf]

let arity = function
  | Int63head0 | Int63tail0 -&gt; 1
  | Int63add | Int63sub | Int63mul
  | Int63div | Int63mod
  | Int63lsr | Int63lsl
  | Int63land | Int63lor | Int63lxor
  | Int63addc | Int63subc
  | Int63addCarryC | Int63subCarryC | Int63mulc | Int63diveucl
  | Int63eq | Int63lt | Int63le
  | Int63compare -&gt; 2

  | Int63div21 | Int63addMulDiv -&gt; 3

(** Special Entries for Register **)

type prim_ind =
  | PIT_bool
  | PIT_carry
  | PIT_pair
  | PIT_cmp

type prim_type =
  | PT_int63

type op_or_type =
  | OT_op of t
  | OT_type of prim_type

let prim_ind_to_string = function
  | PIT_bool -&gt; &quot;bool&quot;
  | PIT_carry -&gt; &quot;carry&quot;
  | PIT_pair -&gt; &quot;pair&quot;
  | PIT_cmp -&gt; &quot;cmp&quot;

let prim_type_to_string = function
  | PT_int63 -&gt; &quot;int63_type&quot;

let op_or_type_to_string = function
  | OT_op op -&gt; to_string op
  | OT_type t -&gt; prim_type_to_string t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cPrimitives.ml"><code>CPrimitives.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Inductive t : Set :=
| Int63head0 : t
| Int63tail0 : t
| Int63add : t
| Int63sub : t
| Int63mul : t
| Int63div : t
| Int63mod : t
| Int63lsr : t
| Int63lsl : t
| Int63land : t
| Int63lor : t
| Int63lxor : t
| Int63addc : t
| Int63subc : t
| Int63addCarryC : t
| Int63subCarryC : t
| Int63mulc : t
| Int63diveucl : t
| Int63div21 : t
| Int63addMulDiv : t
| Int63eq : t
| Int63lt : t
| Int63le : t
| Int63compare : t.

Definition equal (p1 : t) (p2 : t) : bool := Stdlib.op_eqeq p1 p2.

Definition hash (function_parameter : t) : Z :=
  match function_parameter with
  | Int63head0 =&gt; 1
  | Int63tail0 =&gt; 2
  | Int63add =&gt; 3
  | Int63sub =&gt; 4
  | Int63mul =&gt; 5
  | Int63div =&gt; 6
  | Int63mod =&gt; 7
  | Int63lsr =&gt; 8
  | Int63lsl =&gt; 9
  | Int63land =&gt; 10
  | Int63lor =&gt; 11
  | Int63lxor =&gt; 12
  | Int63addc =&gt; 13
  | Int63subc =&gt; 14
  | Int63addCarryC =&gt; 15
  | Int63subCarryC =&gt; 16
  | Int63mulc =&gt; 17
  | Int63diveucl =&gt; 18
  | Int63div21 =&gt; 19
  | Int63addMulDiv =&gt; 20
  | Int63eq =&gt; 21
  | Int63lt =&gt; 22
  | Int63le =&gt; 23
  | Int63compare =&gt; 24
  end.

Definition to_string (function_parameter : t) : string :=
  match function_parameter with
  | Int63head0 =&gt; &quot;head0&quot;
  | Int63tail0 =&gt; &quot;tail0&quot;
  | Int63add =&gt; &quot;add&quot;
  | Int63sub =&gt; &quot;sub&quot;
  | Int63mul =&gt; &quot;mul&quot;
  | Int63div =&gt; &quot;div&quot;
  | Int63mod =&gt; &quot;rem&quot;
  | Int63lsr =&gt; &quot;l_sr&quot;
  | Int63lsl =&gt; &quot;l_sl&quot;
  | Int63land =&gt; &quot;l_and&quot;
  | Int63lor =&gt; &quot;l_or&quot;
  | Int63lxor =&gt; &quot;l_xor&quot;
  | Int63addc =&gt; &quot;addc&quot;
  | Int63subc =&gt; &quot;subc&quot;
  | Int63addCarryC =&gt; &quot;addCarryC&quot;
  | Int63subCarryC =&gt; &quot;subCarryC&quot;
  | Int63mulc =&gt; &quot;mulc&quot;
  | Int63diveucl =&gt; &quot;diveucl&quot;
  | Int63div21 =&gt; &quot;div21&quot;
  | Int63addMulDiv =&gt; &quot;addMulDiv&quot;
  | Int63eq =&gt; &quot;eq&quot;
  | Int63lt =&gt; &quot;lt&quot;
  | Int63le =&gt; &quot;le&quot;
  | Int63compare =&gt; &quot;compare&quot;
  end.

Inductive arg_kind : Set :=
| Kparam : arg_kind
| Kwhnf : arg_kind
| Karg : arg_kind.

Definition args_red := list arg_kind.

Definition kind (function_parameter : t) : list arg_kind :=
  match function_parameter with
  | Int63head0 | Int63tail0 =&gt; [ Kwhnf ]
  |
    Int63add | Int63sub | Int63mul | Int63div | Int63mod | Int63lsr | Int63lsl |
    Int63land | Int63lor | Int63lxor | Int63addc | Int63subc | Int63addCarryC |
    Int63subCarryC | Int63mulc | Int63diveucl | Int63eq | Int63lt | Int63le |
    Int63compare =&gt; [ Kwhnf; Kwhnf ]
  | Int63div21 | Int63addMulDiv =&gt; [ Kwhnf; Kwhnf; Kwhnf ]
  end.

Definition arity (function_parameter : t) : Z :=
  match function_parameter with
  | Int63head0 | Int63tail0 =&gt; 1
  |
    Int63add | Int63sub | Int63mul | Int63div | Int63mod | Int63lsr | Int63lsl |
    Int63land | Int63lor | Int63lxor | Int63addc | Int63subc | Int63addCarryC |
    Int63subCarryC | Int63mulc | Int63diveucl | Int63eq | Int63lt | Int63le |
    Int63compare =&gt; 2
  | Int63div21 | Int63addMulDiv =&gt; 3
  end.

Inductive prim_ind : Set :=
| PIT_bool : prim_ind
| PIT_carry : prim_ind
| PIT_pair : prim_ind
| PIT_cmp : prim_ind.

Inductive prim_type : Set :=
| PT_int63 : prim_type.

Inductive op_or_type : Set :=
| OT_op : t -&gt; op_or_type
| OT_type : prim_type -&gt; op_or_type.

Definition prim_ind_to_string (function_parameter : prim_ind) : string :=
  match function_parameter with
  | PIT_bool =&gt; &quot;bool&quot;
  | PIT_carry =&gt; &quot;carry&quot;
  | PIT_pair =&gt; &quot;pair&quot;
  | PIT_cmp =&gt; &quot;cmp&quot;
  end.

Definition prim_type_to_string (function_parameter : prim_type) : string :=
  let 'PT_int63 := function_parameter in
  &quot;int63_type&quot;.

Definition op_or_type_to_string (function_parameter : op_or_type) : string :=
  match function_parameter with
  | OT_op op =&gt; to_string op
  | OT_type t =&gt; prim_type_to_string t
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cPrimitives.mli">
  <div style="margin: 20px;">
    <h3>CPrimitives_mli</h3>
    <ul>
      <li>OCaml size: 70 lines</li>
      <li>Coq size: 70 lines (+0% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cPrimitives.mli"><code>cPrimitives.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t =
  | Int63head0
  | Int63tail0
  | Int63add
  | Int63sub
  | Int63mul
  | Int63div
  | Int63mod
  | Int63lsr
  | Int63lsl
  | Int63land
  | Int63lor
  | Int63lxor
  | Int63addc
  | Int63subc
  | Int63addCarryC
  | Int63subCarryC
  | Int63mulc
  | Int63diveucl
  | Int63div21
  | Int63addMulDiv
  | Int63eq
  | Int63lt
  | Int63le
  | Int63compare

val equal : t -&gt; t -&gt; bool

type arg_kind =
  | Kparam (* not needed for the elavuation of the primitive*)
  | Kwhnf  (* need to be reduced in whnf before reducing the primitive *)
  | Karg   (* no need to be reduced in whnf *)

type args_red = arg_kind list

val hash : t -&gt; int

val to_string : t -&gt; string

val arity : t -&gt; int

val kind : t -&gt; args_red

(** Special Entries for Register **)

type prim_ind =
  | PIT_bool
  | PIT_carry
  | PIT_pair
  | PIT_cmp

type prim_type =
  | PT_int63

type op_or_type =
  | OT_op of t
  | OT_type of prim_type

val prim_ind_to_string : prim_ind -&gt; string
val op_or_type_to_string : op_or_type -&gt; string
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cPrimitives.mli"><code>CPrimitives_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Inductive t : Set :=
| Int63head0 : t
| Int63tail0 : t
| Int63add : t
| Int63sub : t
| Int63mul : t
| Int63div : t
| Int63mod : t
| Int63lsr : t
| Int63lsl : t
| Int63land : t
| Int63lor : t
| Int63lxor : t
| Int63addc : t
| Int63subc : t
| Int63addCarryC : t
| Int63subCarryC : t
| Int63mulc : t
| Int63diveucl : t
| Int63div21 : t
| Int63addMulDiv : t
| Int63eq : t
| Int63lt : t
| Int63le : t
| Int63compare : t.

Parameter equal : t -&gt; t -&gt; bool.

Inductive arg_kind : Set :=
| Kparam : arg_kind
| Kwhnf : arg_kind
| Karg : arg_kind.

Definition args_red := list arg_kind.

Parameter hash : t -&gt; Z.

Parameter to_string : t -&gt; string.

Parameter arity : t -&gt; Z.

Parameter kind : t -&gt; args_red.

Inductive prim_ind : Set :=
| PIT_bool : prim_ind
| PIT_carry : prim_ind
| PIT_pair : prim_ind
| PIT_cmp : prim_ind.

Inductive prim_type : Set :=
| PT_int63 : prim_type.

Inductive op_or_type : Set :=
| OT_op : t -&gt; op_or_type
| OT_type : prim_type -&gt; op_or_type.

Parameter prim_ind_to_string : prim_ind -&gt; string.

Parameter op_or_type_to_string : op_or_type -&gt; string.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cbytecodes.ml">
  <div style="margin: 20px;">
    <h3>Cbytecodes</h3>
    <ul>
      <li>OCaml size: 161 lines</li>
      <li>Coq size: 197 lines (+22% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cbytecodes.ml"><code>cbytecodes.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras for Benjamin GrÃ©goire as part of the
   bytecode-based reduction machine, Oct 2004 *)
(* Support for native arithmetics by Arnaud Spiwack, May 2007 *)

(* This file defines the type of bytecode instructions *)

open Names
open Vmvalues
open Constr

module Label =
  struct
    type t = int
    let no = -1
    let counter = ref no
    let create () = <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr counter; !counter</abbr>
    let reset_label_counter () = counter := no
  end

type instruction =
  | Klabel of Label.t
  | Kacc of int
  | Kenvacc of int
  | Koffsetclosure of int
  | Kpush
  | Kpop of int
  | Kpush_retaddr of Label.t
  | Kapply of int
  | Kappterm of int * int
  | Kreturn of int
  | Kjump
  | Krestart
  | Kgrab of int
  | Kgrabrec of int
  | Kclosure of Label.t * int
  | Kclosurerec of int * int * Label.t array * Label.t array
  | Kclosurecofix of int * int * Label.t array * Label.t array
                   (* nb fv, init, lbl types, lbl bodies *)
  | Kgetglobal of Constant.t
  | Kconst of structured_constant
  | Kmakeblock of int * tag
  | Kmakeprod
  | Kmakeswitchblock of Label.t * Label.t * annot_switch * int
  | Kswitch of Label.t array * Label.t array
  | Kpushfields of int
  | Kfield of int
  | Ksetfield of int
  | Kstop
  | Ksequence of bytecodes * bytecodes
  | Kproj of Projection.Repr.t
  | Kensurestackcapacity of int
  | Kbranch of Label.t                  (* jump to label *)
  | Kprim of CPrimitives.t * pconstant option
  | Kareint of int

and bytecodes = instruction list

type fv_elem =
  | FVnamed of Id.t
  | FVrel of int
  | FVuniv_var of int
  | FVevar of Evar.t

type fv = fv_elem array

(* --- Pretty print *)
open Pp
open Util

let pp_lbl lbl = str &quot;L&quot; ++ int lbl

let pp_fv_elem = function
  | FVnamed id -&gt; str &quot;FVnamed(&quot; ++ Id.print id ++ str &quot;)&quot;
  | FVrel i -&gt; str &quot;Rel(&quot; ++ int i ++ str &quot;)&quot;
  | FVuniv_var v -&gt; str &quot;FVuniv(&quot; ++ int v ++ str &quot;)&quot;
  | FVevar e -&gt; str &quot;FVevar(&quot; ++ int (Evar.repr e) ++ str &quot;)&quot;

let rec pp_instr i =
  match i with
  | Klabel _   | Ksequence _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Kacc n -&gt; str &quot;acc &quot; ++ int n
  | Kenvacc n -&gt; str &quot;envacc &quot; ++ int n
  | Koffsetclosure n -&gt; str &quot;offsetclosure &quot; ++ int n
  | Kpush -&gt; str &quot;push&quot;
  | Kpop n -&gt; str &quot;pop &quot; ++ int n
  | Kpush_retaddr lbl -&gt; str &quot;push_retaddr &quot; ++ pp_lbl lbl
  | Kapply n -&gt; str &quot;apply &quot; ++ int n
  | Kappterm(n, m) -&gt;
      str &quot;appterm &quot; ++ int n ++ str &quot;, &quot; ++ int m
  | Kreturn n -&gt; str &quot;return &quot; ++ int n
  | Kjump -&gt; str &quot;jump&quot;
  | Krestart -&gt; str &quot;restart&quot;
  | Kgrab n -&gt; str &quot;grab &quot; ++ int n
  | Kgrabrec n -&gt; str &quot;grabrec &quot; ++ int n
  | Kclosure(lbl, n) -&gt;
      str &quot;closure &quot; ++ pp_lbl lbl ++ str &quot;, &quot; ++ int n
  | Kclosurerec(fv,init,lblt,lblb) -&gt;
      h 1 (str &quot;closurerec &quot; ++
             int fv ++ str &quot;, &quot; ++ int init ++
             str &quot; types = &quot; ++
             prlist_with_sep spc pp_lbl (Array.to_list lblt) ++
             str &quot; bodies = &quot; ++
             prlist_with_sep spc pp_lbl (Array.to_list lblb))
  | Kclosurecofix (fv,init,lblt,lblb) -&gt;
      h 1 (str &quot;closurecofix &quot; ++
             int fv ++ str &quot;, &quot; ++ int init ++
             str &quot; types = &quot; ++
             prlist_with_sep spc pp_lbl (Array.to_list lblt) ++
             str &quot; bodies = &quot; ++
             prlist_with_sep spc pp_lbl (Array.to_list lblb))
  | Kgetglobal idu -&gt; str &quot;getglobal &quot; ++ Constant.print idu
  | Kconst sc -&gt;
      str &quot;const &quot; ++ pp_struct_const sc
  | Kmakeblock(n, m) -&gt;
      str &quot;makeblock &quot; ++ int n ++ str &quot;, &quot; ++ int m
  | Kmakeprod -&gt; str &quot;makeprod&quot;
  | Kmakeswitchblock(lblt,lbls,_,sz) -&gt;
      str &quot;makeswitchblock &quot; ++ pp_lbl lblt ++ str &quot;, &quot; ++
        pp_lbl lbls ++ str &quot;, &quot; ++ int sz
  | Kswitch(lblc,lblb) -&gt;
      h 1 (str &quot;switch &quot; ++
             prlist_with_sep spc pp_lbl (Array.to_list lblc) ++
             str &quot; | &quot; ++
             prlist_with_sep spc pp_lbl (Array.to_list lblb))
  | Kpushfields n -&gt; str &quot;pushfields &quot; ++ int n
  | Kfield n -&gt; str &quot;field &quot; ++ int n
  | Ksetfield n -&gt; str &quot;setfield &quot; ++ int n

  | Kstop -&gt; str &quot;stop&quot;

  | Kbranch lbl -&gt; str &quot;branch &quot; ++ pp_lbl lbl

  | Kproj p -&gt; str &quot;proj &quot; ++ Projection.Repr.print p

  | Kensurestackcapacity size -&gt; str &quot;growstack &quot; ++ int size

  | Kprim (op, id) -&gt; str (CPrimitives.to_string op) ++ str &quot; &quot; ++
        (match id with Some (id,_u) -&gt; Constant.print id | None -&gt; str &quot;&quot;)

  | Kareint n -&gt; str &quot;areint &quot; ++ int n

and pp_bytecodes c =
  match c with
  | [] -&gt; str &quot;&quot;
  | Klabel lbl :: c -&gt;
        str &quot;L&quot; ++ int lbl ++ str &quot;:&quot; ++ fnl () ++
        pp_bytecodes c
  | Ksequence (l1, l2) :: c -&gt;
      pp_bytecodes l1 ++ pp_bytecodes l2 ++  pp_bytecodes c
  | i :: c -&gt;
      pp_instr i ++ fnl () ++ pp_bytecodes c
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cbytecodes.ml"><code>Cbytecodes.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Vmvalues.

Import Constr.

Module Label.
  Definition t := Z.
  
  Definition no : Z := (-1).
  
  Definition counter : Stdlib.ref Z := Stdlib.__ref_value no.
  
  Definition create (function_parameter : unit) : Z :=
    let '_ := function_parameter in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.op_exclamation counter.
  
  Definition reset_label_counter (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Stdlib.op_coloneq counter no.
End Label.

Reserved Notation &quot;'bytecodes&quot;.

Inductive instruction : Set :=
| Klabel : Label.t -&gt; instruction
| Kacc : Z -&gt; instruction
| Kenvacc : Z -&gt; instruction
| Koffsetclosure : Z -&gt; instruction
| Kpush : instruction
| Kpop : Z -&gt; instruction
| Kpush_retaddr : Label.t -&gt; instruction
| Kapply : Z -&gt; instruction
| Kappterm : Z -&gt; Z -&gt; instruction
| Kreturn : Z -&gt; instruction
| Kjump : instruction
| Krestart : instruction
| Kgrab : Z -&gt; instruction
| Kgrabrec : Z -&gt; instruction
| Kclosure : Label.t -&gt; Z -&gt; instruction
| Kclosurerec : Z -&gt; Z -&gt; array Label.t -&gt; array Label.t -&gt; instruction
| Kclosurecofix : Z -&gt; Z -&gt; array Label.t -&gt; array Label.t -&gt; instruction
| Kgetglobal : Names.Constant.t -&gt; instruction
| Kconst : Vmvalues.structured_constant -&gt; instruction
| Kmakeblock : Z -&gt; Vmvalues.tag -&gt; instruction
| Kmakeprod : instruction
| Kmakeswitchblock :
  Label.t -&gt; Label.t -&gt; Vmvalues.annot_switch -&gt; Z -&gt; instruction
| Kswitch : array Label.t -&gt; array Label.t -&gt; instruction
| Kpushfields : Z -&gt; instruction
| Kfield : Z -&gt; instruction
| Ksetfield : Z -&gt; instruction
| Kstop : instruction
| Ksequence : 'bytecodes -&gt; 'bytecodes -&gt; instruction
| Kproj : Names.Projection.Repr.t -&gt; instruction
| Kensurestackcapacity : Z -&gt; instruction
| Kbranch : Label.t -&gt; instruction
| Kprim : CPrimitives.t -&gt; option Constr.pconstant -&gt; instruction
| Kareint : Z -&gt; instruction

where &quot;'bytecodes&quot; := (list instruction).

Definition bytecodes := 'bytecodes.

Inductive fv_elem : Set :=
| FVnamed : Names.Id.t -&gt; fv_elem
| FVrel : Z -&gt; fv_elem
| FVuniv_var : Z -&gt; fv_elem
| FVevar : Evar.t -&gt; fv_elem.

Definition fv := array fv_elem.

Import Pp.

Import Util.

Definition pp_lbl (lbl : Z) : Pp.t := op_plusplus (str &quot;L&quot;) (int lbl).

Definition pp_fv_elem (function_parameter : fv_elem) : Pp.t :=
  match function_parameter with
  | FVnamed id =&gt;
    op_plusplus (op_plusplus (str &quot;FVnamed(&quot;) (Id.print id)) (str &quot;)&quot;)
  | FVrel i =&gt; op_plusplus (op_plusplus (str &quot;Rel(&quot;) (int i)) (str &quot;)&quot;)
  | FVuniv_var v =&gt; op_plusplus (op_plusplus (str &quot;FVuniv(&quot;) (int v)) (str &quot;)&quot;)
  | FVevar e =&gt;
    op_plusplus (op_plusplus (str &quot;FVevar(&quot;) (int (Evar.repr e))) (str &quot;)&quot;)
  end.

Fixpoint pp_instr (i : instruction) {struct i} : Pp.t :=
  match i with
  | Klabel _ | Ksequence _ _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Kacc n =&gt; op_plusplus (str &quot;acc &quot;) (int n)
  | Kenvacc n =&gt; op_plusplus (str &quot;envacc &quot;) (int n)
  | Koffsetclosure n =&gt; op_plusplus (str &quot;offsetclosure &quot;) (int n)
  | Kpush =&gt; str &quot;push&quot;
  | Kpop n =&gt; op_plusplus (str &quot;pop &quot;) (int n)
  | Kpush_retaddr lbl =&gt; op_plusplus (str &quot;push_retaddr &quot;) (pp_lbl lbl)
  | Kapply n =&gt; op_plusplus (str &quot;apply &quot;) (int n)
  | Kappterm n m =&gt;
    op_plusplus (op_plusplus (op_plusplus (str &quot;appterm &quot;) (int n)) (str &quot;, &quot;))
      (int m)
  | Kreturn n =&gt; op_plusplus (str &quot;return &quot;) (int n)
  | Kjump =&gt; str &quot;jump&quot;
  | Krestart =&gt; str &quot;restart&quot;
  | Kgrab n =&gt; op_plusplus (str &quot;grab &quot;) (int n)
  | Kgrabrec n =&gt; op_plusplus (str &quot;grabrec &quot;) (int n)
  | Kclosure lbl n =&gt;
    op_plusplus
      (op_plusplus (op_plusplus (str &quot;closure &quot;) (pp_lbl lbl)) (str &quot;, &quot;))
      (int n)
  | Kclosurerec fv init lblt lblb =&gt;
    h 1
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus
                (op_plusplus (op_plusplus (str &quot;closurerec &quot;) (int fv))
                  (str &quot;, &quot;)) (int init)) (str &quot; types = &quot;))
            (prlist_with_sep spc pp_lbl
              ((|Util.Array|).(CArray.ExtS.to_list) lblt))) (str &quot; bodies = &quot;))
        (prlist_with_sep spc pp_lbl ((|Util.Array|).(CArray.ExtS.to_list) lblb)))
  | Kclosurecofix fv init lblt lblb =&gt;
    h 1
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus
                (op_plusplus (op_plusplus (str &quot;closurecofix &quot;) (int fv))
                  (str &quot;, &quot;)) (int init)) (str &quot; types = &quot;))
            (prlist_with_sep spc pp_lbl
              ((|Util.Array|).(CArray.ExtS.to_list) lblt))) (str &quot; bodies = &quot;))
        (prlist_with_sep spc pp_lbl ((|Util.Array|).(CArray.ExtS.to_list) lblb)))
  | Kgetglobal idu =&gt; op_plusplus (str &quot;getglobal &quot;) (Constant.print idu)
  | Kconst sc =&gt; op_plusplus (str &quot;const &quot;) (pp_struct_const sc)
  | Kmakeblock n m =&gt;
    op_plusplus
      (op_plusplus (op_plusplus (str &quot;makeblock &quot;) (int n)) (str &quot;, &quot;)) (int m)
  | Kmakeprod =&gt; str &quot;makeprod&quot;
  | Kmakeswitchblock lblt lbls _ sz =&gt;
    op_plusplus
      (op_plusplus
        (op_plusplus
          (op_plusplus (op_plusplus (str &quot;makeswitchblock &quot;) (pp_lbl lblt))
            (str &quot;, &quot;)) (pp_lbl lbls)) (str &quot;, &quot;)) (int sz)
  | Kswitch lblc lblb =&gt;
    h 1
      (op_plusplus
        (op_plusplus
          (op_plusplus (str &quot;switch &quot;)
            (prlist_with_sep spc pp_lbl
              ((|Util.Array|).(CArray.ExtS.to_list) lblc))) (str &quot; | &quot;))
        (prlist_with_sep spc pp_lbl ((|Util.Array|).(CArray.ExtS.to_list) lblb)))
  | Kpushfields n =&gt; op_plusplus (str &quot;pushfields &quot;) (int n)
  | Kfield n =&gt; op_plusplus (str &quot;field &quot;) (int n)
  | Ksetfield n =&gt; op_plusplus (str &quot;setfield &quot;) (int n)
  | Kstop =&gt; str &quot;stop&quot;
  | Kbranch lbl =&gt; op_plusplus (str &quot;branch &quot;) (pp_lbl lbl)
  | Kproj p =&gt; op_plusplus (str &quot;proj &quot;) (Projection.Repr.print p)
  | Kensurestackcapacity size =&gt; op_plusplus (str &quot;growstack &quot;) (int size)
  | Kprim op id =&gt;
    op_plusplus (op_plusplus (str (CPrimitives.to_string op)) (str &quot; &quot;))
      match id with
      | Some (id, _u) =&gt; Constant.print id
      | None =&gt; str &quot;&quot;
      end
  | Kareint n =&gt; op_plusplus (str &quot;areint &quot;) (int n)
  end

with pp_bytecodes (c : bytecodes) {struct c} : Pp.t :=
  match c with
  | [] =&gt; str &quot;&quot;
  | cons (Klabel lbl) c =&gt;
    op_plusplus
      (op_plusplus (op_plusplus (op_plusplus (str &quot;L&quot;) (int lbl)) (str &quot;:&quot;))
        (fnl tt)) (pp_bytecodes c)
  | cons (Ksequence l1 l2) c =&gt;
    op_plusplus (op_plusplus (pp_bytecodes l1) (pp_bytecodes l2))
      (pp_bytecodes c)
  | cons i c =&gt; op_plusplus (op_plusplus (pp_instr i) (fnl tt)) (pp_bytecodes c)
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cbytecodes.mli">
  <div style="margin: 20px;">
    <h3>Cbytecodes_mli</h3>
    <ul>
      <li>OCaml size: 78 lines</li>
      <li>Coq size: 74 lines (-6% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cbytecodes.mli"><code>cbytecodes.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* $Id$ *)

open Names
open Vmvalues
open Constr

module Label :
  sig
    type t = int
    val no : t
    val create : unit -&gt; t
    val reset_label_counter : unit -&gt; unit
  end

type instruction =
  | Klabel of Label.t
  | Kacc of int                         (** accu = sp[n] *)
  | Kenvacc of int                      (** accu = coq_env[n] *)
  | Koffsetclosure of int               (** accu = &amp;coq_env[n] *)
  | Kpush                               (** sp = accu :: sp *)
  | Kpop of int                         (** sp = skipn n sp *)
  | Kpush_retaddr of Label.t            (** sp = pc :: coq_env :: coq_extra_args :: sp ; coq_extra_args = 0 *)
  | Kapply of int                       (** number of arguments (arguments on top of stack) *)
  | Kappterm of int * int               (** number of arguments, slot size *)
  | Kreturn of int                      (** slot size *)
  | Kjump
  | Krestart
  | Kgrab of int                        (** number of arguments *)
  | Kgrabrec of int                     (** rec arg *)
  | Kclosure of Label.t * int           (** label, number of free variables *)
  | Kclosurerec of int * int * Label.t array * Label.t array
                   (** nb fv, init, lbl types, lbl bodies *)
  | Kclosurecofix of int * int * Label.t array * Label.t array
                   (** nb fv, init, lbl types, lbl bodies *)
  | Kgetglobal of Constant.t
  | Kconst of structured_constant
  | Kmakeblock of (* size: *) int * tag (** allocate an ocaml block. Index 0
                                         ** is accu, all others are popped from
                                         ** the top of the stack  *)
  | Kmakeprod
  | Kmakeswitchblock of Label.t * Label.t * annot_switch * int
  | Kswitch of Label.t array * Label.t array (** consts,blocks *)
  | Kpushfields of int
  | Kfield of int                       (** accu = accu[n] *)
  | Ksetfield of int                    (** accu[n] = sp[0] ; sp = pop sp *)
  | Kstop
  | Ksequence of bytecodes * bytecodes
  | Kproj of Projection.Repr.t
  | Kensurestackcapacity of int

  | Kbranch of Label.t                  (** jump to label, is it needed ? *)
  | Kprim of CPrimitives.t * pconstant option

  | Kareint of int

and bytecodes = instruction list

val pp_bytecodes : bytecodes -&gt; Pp.t

type fv_elem =
  FVnamed of Id.t
| FVrel of int
| FVuniv_var of int
| FVevar of Evar.t

type fv = fv_elem array

val pp_fv_elem : fv_elem -&gt; Pp.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cbytecodes.mli"><code>Cbytecodes_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Module Label.
  Definition t := Z.
  
  Parameter no : t.
  
  Parameter create : unit -&gt; t.
  
  Parameter reset_label_counter : unit -&gt; unit.
End Label.

Reserved Notation &quot;'bytecodes&quot;.

Inductive instruction : Set :=
| Klabel : Label.t -&gt; instruction
| Kacc : Z -&gt; instruction
| Kenvacc : Z -&gt; instruction
| Koffsetclosure : Z -&gt; instruction
| Kpush : instruction
| Kpop : Z -&gt; instruction
| Kpush_retaddr : Label.t -&gt; instruction
| Kapply : Z -&gt; instruction
| Kappterm : Z -&gt; Z -&gt; instruction
| Kreturn : Z -&gt; instruction
| Kjump : instruction
| Krestart : instruction
| Kgrab : Z -&gt; instruction
| Kgrabrec : Z -&gt; instruction
| Kclosure : Label.t -&gt; Z -&gt; instruction
| Kclosurerec : Z -&gt; Z -&gt; array Label.t -&gt; array Label.t -&gt; instruction
| Kclosurecofix : Z -&gt; Z -&gt; array Label.t -&gt; array Label.t -&gt; instruction
| Kgetglobal : Names.Constant.t -&gt; instruction
| Kconst : Vmvalues.structured_constant -&gt; instruction
| Kmakeblock : Z -&gt; Vmvalues.tag -&gt; instruction
| Kmakeprod : instruction
| Kmakeswitchblock :
  Label.t -&gt; Label.t -&gt; Vmvalues.annot_switch -&gt; Z -&gt; instruction
| Kswitch : array Label.t -&gt; array Label.t -&gt; instruction
| Kpushfields : Z -&gt; instruction
| Kfield : Z -&gt; instruction
| Ksetfield : Z -&gt; instruction
| Kstop : instruction
| Ksequence : 'bytecodes -&gt; 'bytecodes -&gt; instruction
| Kproj : Names.Projection.Repr.t -&gt; instruction
| Kensurestackcapacity : Z -&gt; instruction
| Kbranch : Label.t -&gt; instruction
| Kprim : CPrimitives.t -&gt; option Constr.pconstant -&gt; instruction
| Kareint : Z -&gt; instruction

where &quot;'bytecodes&quot; := (list instruction).

Definition bytecodes := 'bytecodes.

Parameter pp_bytecodes : bytecodes -&gt; Pp.t.

Inductive fv_elem : Set :=
| FVnamed : Names.Id.t -&gt; fv_elem
| FVrel : Z -&gt; fv_elem
| FVuniv_var : Z -&gt; fv_elem
| FVevar : Evar.t -&gt; fv_elem.

Definition fv := array fv_elem.

Parameter pp_fv_elem : fv_elem -&gt; Pp.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cbytegen.ml">
  <div style="margin: 20px;">
    <h3>Cbytegen</h3>
    <ul>
      <li>OCaml size: 896 lines</li>
      <li>Coq size: 892 lines (-1% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cbytegen.ml"><code>cbytegen.ml</code></a>&nbsp;<span class="label label-warning">44 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Author: Benjamin GrÃ©goire as part of the bytecode-based virtual reduction
   machine, Oct 2004 *)
(* Extension: Arnaud Spiwack (support for native arithmetic), May 2005 *)

open Util
open Names
open Vmvalues
open Cbytecodes
open Cemitcodes
open Clambda
open Constr
open Declarations
open Environ


(* Compilation of variables + computing free variables                    *)

(* The virtual machine doesn't distinguish closures and their environment *)

(* Representation of function environments :                              *)
(*        [clos_t | code | fv1 | fv2 | ... | fvn ]                        *)
(*                ^                                                       *)
(*  The offset for accessing free variables is 1 (we must skip the code   *)
(*  pointer).                                                             *)
(*  While compiling, free variables are stored in [in_env] in order       *)
(*  opposite to machine representation, so we can add new free variables  *)
(*  easily (i.e. without changing the position of previous variables)     *)
(* Function arguments are on the stack in the same order as the           *)
(* application :  f arg1 ... argn                                         *)
(*   - the stack is then :                                                *)
(*        arg1 : ... argn : extra args : return addr : ...                *)
(* In the function body [arg1] is represented by de Bruijn [n], and       *)
(* [argn] by de Bruijn [1]                                                *)

(* Representation of environments of mutual fixpoints :                  *)
(* [t1|C1| ... |tc|Cc| ... |t(nbr)|C(nbr)| fv1 | fv2 | .... | fvn | type] *)
(*                ^&lt;----------offset---------&gt;                            *)
(* type = [Ct1 | .... | Ctn]                                              *)
(* Ci is the code pointer of the i-th body                                *)
(* At runtime, a fixpoint environment (which is the same as the fixpoint  *)
(* itself) is a pointer to the field holding its code pointer.            *)
(* In each fixpoint body, de Bruijn [nbr] represents the first fixpoint   *)
(* and de Bruijn [1] the last one.                                        *)
(* Access to these variables is performed by the [Koffsetclosure n]       *)
(* instruction that shifts the environment pointer of [n] fields.         *)

(* This allows representing mutual fixpoints in just one block.           *)
(* [Ct1 | ... | Ctn] is an array holding code pointers of the fixpoint    *)
(* types. They are used in conversion tests (which requires that          *)
(* fixpoint types must be convertible). Their environment is the one of   *)
(* the last fixpoint :                                                    *)
(* [t1|C1| ... |tc|Cc| ... |t(nbr)|C(nbr)| fv1 | fv2 | .... | fvn | type] *)
(*                                ^                                       *)

(* Representation of mutual cofix :                                       *)
(*  a1 =   [A_t | accumulate | [Cfx_t | fcofix1 ] ]                       *)
(*                ...                                                     *)
(*  anbr = [A_t | accumulate | [Cfx_t | fcofixnbr ] ]                     *)
(*                                                                        *)
(*  fcofix1 = [clos_t   | code1   | a1 |...| anbr | fv1 |...| fvn | type] *)
(*                      ^                                                 *)
(*                ...                                                     *)
(*  fcofixnbr = [clos_t | codenbr | a1 |...| anbr | fv1 |...| fvn | type] *)
(*                      ^                                                 *)
(* The [ai] blocks are functions that accumulate their arguments:         *)
(*           ai arg1  argp ---&gt;                                           *)
(*    ai' = [A_t | accumulate | [Cfx_t | fcofixi] | arg1 | ... | argp ]   *)
(* If such a block is matched against, we have to force evaluation,       *)
(* function [fcofixi] is then applied to [ai'] [arg1] ... [argp]          *)
(* (note that [ai'] is a pointer to the closure, passed as argument)      *)
(* Once evaluation is completed [ai'] is updated with the result:         *)
(*  ai' &lt;--                                                               *)
(*   [A_t | accumulate | [Cfxe_t |fcofixi|result] | arg1 | ... | argp ]   *)
(* This representation is nice because the application of the cofix is    *)
(* evaluated only once (it simulates a lazy evaluation)                   *)
(* Moreover, when cofix don't have arguments, it is possible to create    *)
(* a cycle, e.g.:                                                         *)
(*   cofix one := cons 1 one                                              *)
(*   a1 = [A_t | accumulate | [Cfx_t|fcofix1] ]                           *)
(*   fcofix1 = [clos_t | code | a1]                                       *)
(* The result of evaluating [a1] is [cons_t | 1 | a1].                    *)
(* When [a1] is updated :                                                 *)
(*  a1 = [A_t | accumulate | [Cfxe_t | fcofix1 | [cons_t | 1 | a1]] ]     *)
(* The cycle is created ...                                               *)
(*                                                                        *)
(* In Cfxe_t accumulators, we need to store [fcofixi] for testing         *)
(* conversion of cofixpoints (which is intentional).                      *)

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module Fv_elem =
struct
type t = fv_elem

let compare e1 e2 = match e1, e2 with
| FVnamed id1, FVnamed id2 -&gt; Id.compare id1 id2
| FVnamed _, (FVrel _ | FVuniv_var _ | FVevar _) -&gt; -1
| FVrel _, FVnamed _ -&gt; 1
| FVrel r1, FVrel r2 -&gt; Int.compare r1 r2
| FVrel _, (FVuniv_var _ | FVevar _) -&gt; -1
| FVuniv_var i1, FVuniv_var i2 -&gt; Int.compare i1 i2
| FVuniv_var _, (FVnamed _ | FVrel _) -&gt; 1
| FVuniv_var _, FVevar _ -&gt; -1
| FVevar _, (FVnamed _ | FVrel _ | FVuniv_var _) -&gt; 1
| FVevar e1, FVevar e2 -&gt; Evar.compare e1 e2

end</abbr>

module FvMap = Map.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Fv_elem</abbr>)

(*spiwack: both type have been moved from Cbytegen because I needed then
  for the retroknowledge *)
type vm_env = {
    size : int;              (* longueur de la liste [n] *)
    fv_rev : fv_elem list;   (* [fvn; ... ;fv1] *)
    fv_fwd : int FvMap.t;    (* reverse mapping *)
  }


type comp_env = {
    arity : int;                 (* arity of the current function, 0 if none *)
    nb_uni_stack : int ;         (* number of universes on the stack,      *)
                                 (* universes are always at the bottom.    *)
    nb_stack : int;              (* number of variables on the stack       *)
    in_stack : int list;         (* position in the stack                  *)
    nb_rec : int;                (* number of mutually recursive functions *)
    pos_rec  : instruction list; (* instruction d'acces pour les variables *)
                                 (*  de point fix ou de cofix              *)
    offset : int;
    in_env : vm_env ref          (* The free variables of the expression   *)
  }

module Config = struct
  let stack_threshold = 256 (* see byterun/coq_memory.h *)
  let stack_safety_margin = 15
end

type argument = ArgLambda of lambda | ArgUniv of Univ.Level.t

let empty_fv = { size= 0;  fv_rev = []; fv_fwd = FvMap.empty }
let push_fv d e = {
  size = e.size + 1;
  fv_rev = d :: e.fv_rev;
  fv_fwd = FvMap.add d e.size e.fv_fwd;
}

let fv r = !(r.in_env)

let empty_comp_env ()=
  { arity = 0;
    nb_uni_stack = 0;
    nb_stack = 0;
    in_stack = [];
    nb_rec = 0;
    pos_rec = [];
    offset = 0;
    in_env = ref empty_fv
  }

(* Maximal stack size reached during the current function body. Used to
   reallocate the stack if we lack space. *)
let max_stack_size = ref 0

let set_max_stack_size stack_size =
  if stack_size &gt; !max_stack_size then
    max_stack_size := stack_size

let ensure_stack_capacity f x =
  let old = !max_stack_size in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">max_stack_size := 0;
  let code = f x in
  let used_safe =
    !max_stack_size + Config.stack_safety_margin
  in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">max_stack_size := old;
  if used_safe &gt; Config.stack_threshold then
    Kensurestackcapacity used_safe :: code
  else code</abbr>

(*i Creation functions for comp_env *)

let rec add_param n sz l =
  if Int.equal n 0 then l else add_param (n - 1) sz (n+sz::l)

let comp_env_fun ?(univs=0) arity =
  { arity;
    nb_uni_stack = univs ;
    nb_stack = arity;
    in_stack = add_param arity 0 [];
    nb_rec = 0;
    pos_rec = [];
    offset = 1;
    in_env = ref empty_fv
  }


let comp_env_fix_type  rfv =
  { arity = 0;
    nb_uni_stack = 0;
    nb_stack = 0;
    in_stack = [];
    nb_rec = 0;
    pos_rec = [];
    offset = 1;
    in_env = rfv
  }

let comp_env_fix ndef curr_pos arity rfv =
   let prec = ref [] in
   <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = ndef downto 1 do
     prec := Koffsetclosure (2 * (ndef - curr_pos - i)) :: !prec
   done;
   { arity;
     nb_uni_stack = 0;
     nb_stack = arity;
     in_stack = add_param arity 0 [];
     nb_rec = ndef;
     pos_rec = !prec;
     offset = 2 * (ndef - curr_pos - 1)+1;
     in_env = rfv
   }</abbr>

let comp_env_cofix_type ndef rfv =
  { arity = 0;
    nb_uni_stack = 0;
    nb_stack = 0;
    in_stack = [];
    nb_rec = 0;
    pos_rec = [];
    offset = 1+ndef;
    in_env = rfv
  }

let comp_env_cofix ndef arity rfv =
   let prec = ref [] in
   <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 1 to ndef do
     prec := Kenvacc i :: !prec
   done;
   { arity;
     nb_uni_stack = 0;
     nb_stack = arity;
     in_stack = add_param arity 0 [];
     nb_rec = ndef;
     pos_rec = !prec;
     offset = ndef+1;
     in_env = rfv
   }</abbr>

(* [push_param ] add function parameters on the stack *)
let push_param n sz r =
  { r with
    nb_stack = r.nb_stack + n;
    in_stack = add_param n sz r.in_stack }

(* [push_local sz r] add a new variable on the stack at position [sz] *)
let push_local sz r =
  { r with
    nb_stack = r.nb_stack + 1;
    in_stack = (sz + 1) :: r.in_stack }

(*i Compilation of variables *)
let find_at fv env = FvMap.find fv env.fv_fwd

let pos_named id r =
  let env = !(r.in_env) in
  let cid = FVnamed id in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Kenvacc(r.offset + find_at cid env)
  with Not_found -&gt;
    let pos = env.size in
    r.in_env := push_fv cid env;
    Kenvacc (r.offset + pos)</abbr>

let pos_rel i r sz =
  if i &lt;= r.nb_stack then
    Kacc(sz - (List.nth r.in_stack (i-1)))
  else
    let i = i - r.nb_stack in
    if i &lt;= r.nb_rec then
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try List.nth r.pos_rec (i-1)
      with (Failure _|Invalid_argument _) -&gt; assert false</abbr>
    else
      let i = i - r.nb_rec in
      let db = FVrel(i) in
      let env = !(r.in_env) in
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Kenvacc(r.offset + find_at db env)
      with Not_found -&gt;
        let pos = env.size in
        r.in_env := push_fv db env;
        Kenvacc(r.offset + pos)</abbr>

let pos_universe_var i r sz =
  (* Compilation of a universe variable can happen either at toplevel (the
  current closure correspond to a constant and has local universes) or in a
  local closure (which has no local universes). *)
  if r.nb_uni_stack != 0 then
    (* Universe variables are represented by De Bruijn levels (not indices),
    starting at 0. The shape of the stack will be [v1|..|vn|u1..up|arg1..argq]
    with size = n + p + q, and q = r.arity. So Kacc (sz - r.arity - 1) will access
    the last universe. *)
    Kacc (sz - r.arity - (r.nb_uni_stack - i))
  else
    let env = !(r.in_env) in
    let db = FVuniv_var i in
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Kenvacc (r.offset + find_at db env)
    with Not_found -&gt;
      let pos = env.size in
      r.in_env := push_fv db env;
      Kenvacc(r.offset + pos)</abbr>

let pos_evar evk r =
  let env = !(r.in_env) in
  let cid = FVevar evk in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Kenvacc(r.offset + find_at cid env)
  with Not_found -&gt;
    let pos = env.size in
    r.in_env := push_fv cid env;
    Kenvacc (r.offset + pos)</abbr>

(*i  Examination of the continuation *)

(* Discard all instructions up to the next label.                        *)
(* This function is to be applied to the continuation before adding a    *)
(* non-terminating instruction (branch, raise, return, appterm)          *)
(* in front of it.                                                       *)

let discard_dead_code cont = cont
(*function
    [] -&gt; []
  | (Klabel _ | Krestart ) :: _ as cont -&gt; cont
  | _ :: cont -&gt; discard_dead_code cont
*)

(* Return a label to the beginning of the given continuation.            *)
(*   If the sequence starts with a branch, use the target of that branch *)
(*   as the label, thus avoiding a jump to a jump.                       *)

let label_code = function
  | Klabel lbl :: _ as cont -&gt; (lbl, cont)
  | Kbranch lbl :: _ as cont -&gt; (lbl, cont)
  | cont -&gt; let lbl = Label.create() in (lbl, Klabel lbl :: cont)

(* Return a branch to the continuation. That is, an instruction that,
   when executed, branches to the continuation or performs what the
   continuation performs. We avoid generating branches to returns. *)
(* spiwack: make_branch was only used once. Changed it back to the ZAM
      one to match the appropriate semantics (old one avoided the
      introduction of an unconditional branch operation, which seemed
      appropriate for the 31-bit integers' code). As a memory, I leave
      the former version in this comment.
let make_branch cont =
  match cont with
  | (Kreturn _ as return) :: cont' -&gt; return, cont'
  | Klabel lbl as b :: _ -&gt; b, cont
  | _ -&gt; let b = Klabel(Label.create()) in b,b::cont
*)

let rec make_branch_2 lbl n cont =
  function
    Kreturn m :: _ -&gt; (Kreturn (n + m), cont)
  | Klabel _ :: c  -&gt; make_branch_2 lbl n cont c
  | Kpop m :: c    -&gt; make_branch_2 lbl (n + m) cont c
  | _              -&gt;
      match lbl with
        Some lbl -&gt; (Kbranch lbl, cont)
      | None     -&gt; let lbl = Label.create() in (Kbranch lbl, Klabel lbl :: cont)

let make_branch cont =
  match cont with
    (Kbranch _ as branch) :: _ -&gt; (branch, cont)
  | (Kreturn _ as return) :: _ -&gt; (return, cont)
  | Klabel lbl :: _ -&gt; make_branch_2 (Some lbl) 0 cont cont
  | _ -&gt;  make_branch_2 (None) 0 cont cont

(* Check if we're in tailcall position *)

let rec is_tailcall = function
  | Kreturn k :: _ -&gt; Some k
  | Klabel _ :: c -&gt; is_tailcall c
  | _ -&gt; None

(* Extension of the continuation *)

(* Add a Kpop n instruction in front of a continuation *)
let rec add_pop n = function
  | Kpop m :: cont -&gt; add_pop (n+m) cont
  | Kreturn m:: cont -&gt; Kreturn (n+m) ::cont
  | cont -&gt; if Int.equal n 0 then cont else Kpop n :: cont

let add_grab arity lbl cont =
  if Int.equal arity 1 then Klabel lbl :: cont
  else Krestart :: Klabel lbl :: Kgrab (arity - 1) :: cont

let add_grabrec rec_arg arity lbl cont =
  if Int.equal arity 1 &amp;&amp; rec_arg &lt; arity then
    Klabel lbl :: Kgrabrec 0 :: Krestart :: cont
  else
    Krestart :: Klabel lbl :: Kgrabrec rec_arg ::
    Krestart :: Kgrab (arity - 1) :: cont

(* continuation of a cofix *)

let cont_cofix arity =
    (* accu = res                                                         *)
    (* stk  = ai::args::ra::...                                           *)
    (* ai   = [At|accumulate|[Cfx_t|fcofix]|args]                         *)
  [ Kpush;
    Kpush;        (*                 stk = res::res::ai::args::ra::...    *)
    Kacc 2;
    Kfield 1;
    Kfield 0;
    Kmakeblock(2, cofix_evaluated_tag);
    Kpush;        (*  stk = [Cfxe_t|fcofix|res]::res::ai::args::ra::...*)
    Kacc 2;
    Ksetfield 1;  (*   ai = [At|accumulate|[Cfxe_t|fcofix|res]|args]      *)
                  (*  stk = res::ai::args::ra::...                        *)
    Kacc 0;       (* accu = res                                           *)
    Kreturn (arity+2) ]


(* Code of closures *)
let fun_code = ref []

let init_fun_code () = fun_code := []

(* Compilation of constructors and inductive types *)


(*
If [tag] hits the OCaml limitation for non constant constructors, we switch to
another representation for the remaining constructors:
[last_variant_tag|tag - Obj.last_non_constant_constructor_tag|args]

We subtract Obj.last_non_constant_constructor_tag for efficiency of match interpretation.
 *)

let nest_block tag arity cont =
  Kconst (Const_b0 (tag - Obj.last_non_constant_constructor_tag)) ::
    Kmakeblock(arity+1, Obj.last_non_constant_constructor_tag) :: cont

let code_makeblock ~stack_size ~arity ~tag cont =
  if tag &lt; Obj.last_non_constant_constructor_tag then
    Kmakeblock(arity, tag) :: cont
  else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
    set_max_stack_size (stack_size + 1);
    Kpush :: nest_block tag arity cont
  end</abbr>

let compile_structured_constant _cenv sc sz cont =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size sz;
  Kconst sc :: cont</abbr>

(* compiling application *)
let comp_args comp_expr cenv args sz cont =
  let nargs_m_1 = Array.length args - 1 in
  let c = ref (comp_expr cenv args.(0) (sz + nargs_m_1) cont) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 1 to nargs_m_1 do
    c := comp_expr cenv args.(i) (sz + nargs_m_1 - i) (Kpush :: !c)
  done;
  !c</abbr>

let comp_app comp_fun comp_arg cenv f args sz cont =
  let nargs = Array.length args in
  if Int.equal nargs 0 then comp_fun cenv f sz cont
  else
  match is_tailcall cont with
  | Some k -&gt;
      comp_args comp_arg cenv args sz
        (Kpush ::
         comp_fun cenv f (sz + nargs)
           (Kappterm(nargs, k + nargs) :: (discard_dead_code cont)))
  | None -&gt;
      if nargs &lt;= 4 then
        comp_args comp_arg cenv args sz
          (Kpush :: (comp_fun cenv f (sz+nargs) (Kapply nargs :: cont)))
      else
        let lbl,cont1 = label_code cont in
        Kpush_retaddr lbl ::
        (comp_args comp_arg cenv args (sz + 3)
           (Kpush :: (comp_fun cenv f (sz+3+nargs) (Kapply nargs :: cont1))))

(* Compiling free variables *)

let compile_fv_elem cenv fv sz cont =
  match fv with
  | FVrel i -&gt; pos_rel i cenv sz :: cont
  | FVnamed id -&gt; pos_named id cenv :: cont
  | FVuniv_var i -&gt; pos_universe_var i cenv sz :: cont
  | FVevar evk -&gt; pos_evar evk cenv :: cont

let rec compile_fv cenv l sz cont =
  match l with
  | [] -&gt; cont
  | [fvn] -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size (sz + 1); compile_fv_elem cenv fvn sz cont</abbr>
  | fvn :: tl -&gt;
      compile_fv_elem cenv fvn sz
        (Kpush :: compile_fv cenv tl (sz + 1) cont)


(* Compiling constants *)

let rec get_alias env kn =
  let cb = lookup_constant kn env in
  let tps = cb.const_body_code in
    match tps with
    | None -&gt; kn
    | Some tps -&gt;
       (match Cemitcodes.force tps with
        | BCalias kn' -&gt; get_alias env kn'
        | _ -&gt; kn)

(* sz is the size of the local stack *)
let rec compile_lam env cenv lam sz cont =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size sz;
  match lam with
  | Lrel(_, i) -&gt; pos_rel i cenv sz :: cont

  | Lint i -&gt; compile_structured_constant cenv (Const_b0 i) sz cont

  | Lval v -&gt; compile_structured_constant cenv (Const_val v) sz cont

  | Luint i -&gt; compile_structured_constant cenv (Const_uint i) sz cont

  | Lproj (p,arg) -&gt;
     compile_lam env cenv arg sz (Kproj p :: cont)

  | Lvar id -&gt; pos_named id cenv :: cont

  | Levar (evk, args) -&gt;
      if Array.is_empty args then
        compile_fv_elem cenv (FVevar evk) sz cont
      else
        (** Arguments are reversed in evar instances *)
        let args = Array.copy args in
        let () = Array.rev args in
        comp_app compile_fv_elem (compile_lam env) cenv (FVevar evk) args sz cont

  | Lconst (kn,u) -&gt; compile_constant env cenv kn u </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[||]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> sz cont

  | Lind (ind,u) -&gt;
    if Univ.Instance.is_empty u then
      compile_structured_constant cenv (Const_ind ind) sz cont
    else comp_app compile_structured_constant compile_universe cenv
        (Const_ind ind) (Univ.Instance.to_array u) sz cont

  | Lsort (Sorts.SProp | Sorts.Prop | Sorts.Set as s) -&gt;
    compile_structured_constant cenv (Const_sort s) sz cont
  | Lsort (Sorts.Type u) -&gt;
    (* We represent universes as a global constant with local universes
       &quot;compacted&quot;, i.e. as [u arg0 ... argn] where we will substitute (after
       evaluation) [Var 0,...,Var n] with values of [arg0,...,argn] *)
    let u,s = Univ.compact_univ u in
    let compile_get_univ cenv idx sz cont =
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size sz;
      compile_fv_elem cenv (FVuniv_var idx) sz cont</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
    in
    if List.is_empty s then
      compile_structured_constant cenv (Const_sort (Sorts.sort_of_univ u)) sz cont
    else
      comp_app compile_structured_constant compile_get_univ cenv
        (Const_sort (Sorts.sort_of_univ u)) (Array.of_list s) sz cont

  | Llet (_id,def,body) -&gt;
      compile_lam env cenv def sz
        (Kpush ::
         compile_lam env (push_local sz cenv) body (sz+1) (add_pop 1 cont))

  | Lprod (dom,codom) -&gt;
     let cont1 =
       Kpush :: compile_lam env cenv dom (sz+1) (Kmakeprod :: cont) in
     compile_lam env cenv codom sz cont1

  | Llam (ids,body) -&gt;
     let arity = Array.length ids in
     let r_fun = comp_env_fun arity in
     let lbl_fun = Label.create() in
     let cont_fun =
       ensure_stack_capacity (compile_lam env r_fun body arity) [Kreturn arity]
     in
     </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fun_code := [Ksequence(add_grab arity lbl_fun cont_fun,!fun_code)];
     let fv = fv r_fun in
     compile_fv cenv fv.fv_rev sz (Kclosure(lbl_fun,fv.size) :: cont)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

  | Lapp (f, args) -&gt;
    begin match f with
    | Lconst (kn,u) -&gt; compile_constant env cenv kn u args sz cont
    | _ -&gt; comp_app (compile_lam env) (compile_lam env) cenv f args sz cont
    end

  | Lfix ((rec_args, init), (_decl, types, bodies)) -&gt;
      let ndef = Array.length types in
      let rfv = ref empty_fv in
      let lbl_types = Array.make ndef Label.no in
      let lbl_bodies = Array.make ndef Label.no in
      (* Compiling types *)
      let env_type = comp_env_fix_type rfv in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to ndef - 1 do
        let fcode =
          ensure_stack_capacity (compile_lam env env_type types.(i) 0) [Kstop]
        in
        let lbl,fcode = label_code fcode in
        lbl_types.(i) &lt;- lbl;
        fun_code := [Ksequence(fcode,!fun_code)]
      done;
      (* Compiling bodies *)
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to ndef - 1 do
        let params,body = decompose_Llam bodies.(i) in
        let arity = Array.length params in
        let env_body = comp_env_fix ndef i arity rfv in
        let cont1 =
          ensure_stack_capacity (compile_lam env env_body body arity) [Kreturn arity]
        in
        let lbl = Label.create () in
        lbl_bodies.(i) &lt;- lbl;
        let fcode =  add_grabrec rec_args.(i) arity lbl cont1 in
        fun_code := [Ksequence(fcode,!fun_code)]
      done;
      let fv = !rfv in
      compile_fv cenv fv.fv_rev sz
        (Kclosurerec(fv.size,init,lbl_types,lbl_bodies) :: cont)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">


  | Lcofix(init, (_decl,types,bodies)) -&gt;
      let ndef = Array.length types in
      let lbl_types = Array.make ndef Label.no in
      let lbl_bodies = Array.make ndef Label.no in
      (* Compiling types *)
      let rfv = ref empty_fv in
      let env_type = comp_env_cofix_type ndef rfv in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to ndef - 1 do
        let fcode =
          ensure_stack_capacity (compile_lam env env_type types.(i) 0) [Kstop]
        in
        let lbl,fcode = label_code fcode in
        lbl_types.(i) &lt;- lbl;
        fun_code := [Ksequence(fcode,!fun_code)]
      done;
      (* Compiling bodies *)
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to ndef - 1 do
        let params,body = decompose_Llam bodies.(i) in
        let arity = Array.length params in
        let env_body = comp_env_cofix ndef arity rfv in
        let lbl = Label.create () in
        let comp arity =
          (* 4 stack slots are needed to update the cofix when forced *)
          set_max_stack_size (arity + 4);
          compile_lam env env_body body (arity+1) (cont_cofix arity)
        in
        let cont = ensure_stack_capacity comp arity in
        lbl_bodies.(i) &lt;- lbl;
        fun_code := [Ksequence(add_grab (arity+1) lbl cont,!fun_code)];
      done;
      let fv = !rfv in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size (sz + fv.size + ndef + 2);
      compile_fv cenv fv.fv_rev sz
        (Kclosurecofix(fv.size, init, lbl_types, lbl_bodies) :: cont)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

  | Lif(t, bt, bf) -&gt;
      let branch, cont = make_branch cont in
      let lbl_true =  Label.create() in
      let lbl_false = Label.create() in
      compile_lam env cenv t sz
        (Kswitch(</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|lbl_true;lbl_false|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">,</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[||]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">) ::
         Klabel lbl_false ::
         compile_lam env cenv bf sz
           (branch ::
            Klabel lbl_true ::
            compile_lam env cenv bt sz cont))

  | Lcase(ci,rtbl,t,a,branches) -&gt;
      let ind = ci.ci_ind in
      let mib = lookup_mind (fst ind) env in
      let oib = mib.mind_packets.(snd ind) in
      let lbl_consts = Array.make oib.mind_nb_constant Label.no in
      let nallblock = oib.mind_nb_args + 1 in (* +1 : accumulate *)
      let nconst = Array.length branches.constant_branches in
      let nblock = min nallblock (Obj.last_non_constant_constructor_tag + 1) in
      let lbl_blocks = Array.make nblock Label.no in
      let neblock = max 0 (nallblock - Obj.last_non_constant_constructor_tag) in
      let lbl_eblocks = Array.make neblock Label.no in
      let branch1, cont = make_branch cont in
      (* Compilation of the return type *)
      let fcode =
        ensure_stack_capacity (compile_lam env cenv t sz) [Kpop sz; Kstop]
      in
      let lbl_typ,fcode = label_code fcode in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fun_code := [Ksequence(fcode,!fun_code)];
      (* Compilation of the branches *)
      let lbl_sw = Label.create () in
      let sz_b,branch,is_tailcall =
        match branch1 with
        | Kreturn k -&gt;
          </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Int.equal k sz) ;
          sz, branch1, true</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
        | Kbranch _ -&gt; sz+3, Kjump, false
        | _ -&gt; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert false</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
      in

      let c = ref cont in
      (* Perform the extra match if needed (too many block constructors) *)
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if neblock &lt;&gt; 0 then begin
        let lbl_b, code_b =
          label_code (
            Kpush :: Kfield 0 :: Kswitch(lbl_eblocks, [||]) :: !c) in
        lbl_blocks.(Obj.last_non_constant_constructor_tag) &lt;- lbl_b;
        c := code_b
      end;

      (* Compilation of constant branches *)
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = nconst - 1 downto 0 do
        let aux =
          compile_lam env cenv branches.constant_branches.(i) sz_b (branch::!c)
        in
        let lbl_b,code_b = label_code aux in
        lbl_consts.(i) &lt;- lbl_b;
        c := code_b
      done;
      (* -1 for accu branch *)
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = nallblock - 2 downto 0 do
        let tag = i + 1 in
        let (ids, body) = branches.nonconstant_branches.(i) in
        let arity = Array.length ids in
        let code_b =
          compile_lam env (push_param arity sz_b cenv)
            body (sz_b+arity) (add_pop arity (branch::!c)) in
        let code_b =
            if tag &lt; Obj.last_non_constant_constructor_tag then begin
                set_max_stack_size (sz_b + arity);
                Kpushfields arity :: code_b
              end
            else begin
                set_max_stack_size (sz_b + arity + 1);
                Kacc 0::Kpop 1::Kpushfields(arity+1)::Kpop 1::code_b
              end
        in
        let lbl_b, code_b = label_code code_b in
        if tag &lt; Obj.last_non_constant_constructor_tag then lbl_blocks.(tag) &lt;- lbl_b
          else lbl_eblocks.(tag - Obj.last_non_constant_constructor_tag) &lt;- lbl_b;
        c := code_b
      done;

      let annot =
        {ci = ci; rtbl = rtbl; tailcall = is_tailcall;
         max_stack_size = !max_stack_size - sz}
      in

     (* Compiling branch for accumulators *)
      let lbl_accu, code_accu =
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size (sz+3);
        label_code(Kmakeswitchblock(lbl_typ,lbl_sw,annot,sz) :: branch :: !c)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
      in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">lbl_blocks.(0) &lt;- lbl_accu;

      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">c := Klabel lbl_sw :: Kswitch(lbl_consts,lbl_blocks) :: code_accu;
      let code_sw =
        match branch1 with
        (* spiwack : branch1 can't be a lbl anymore it's a Branch instead
        | Klabel lbl -&gt; Kpush_retaddr lbl ::  !c *)
        | Kbranch lbl -&gt; Kpush_retaddr lbl ::  !c
        | _ -&gt; !c
      in
      compile_lam env cenv a sz code_sw</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

  | Lmakeblock (tag,args) -&gt;
    let arity = Array.length args in
    let cont = code_makeblock ~stack_size:(sz+arity-1) ~arity ~tag cont in
    comp_args (compile_lam env) cenv args sz cont

  | Lprim (kn, op, args) -&gt;
    comp_args (compile_lam env) cenv args sz (Kprim(op, kn)::cont)</abbr>

and compile_get_global cenv (kn,u) sz cont =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size sz;
  if Univ.Instance.is_empty u then
    Kgetglobal kn :: cont
  else
    comp_app (fun _ _ _ cont -&gt; Kgetglobal kn :: cont)
      compile_universe cenv () (Univ.Instance.to_array u) sz cont</abbr>

and compile_universe cenv uni sz cont =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size sz;
  match Univ.Level.var_index uni with
  | None -&gt; compile_structured_constant cenv (Const_univ_level uni) sz cont
  | Some idx -&gt; pos_universe_var idx cenv sz :: cont</abbr>

and compile_constant env cenv kn u args sz cont =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_max_stack_size sz;
  if Univ.Instance.is_empty u then
    (* normal compilation *)
    comp_app (fun _ _ sz cont -&gt;
        compile_get_global cenv (kn,u) sz cont)
      (compile_lam env) cenv () args sz cont
  else
    let compile_arg cenv constr_or_uni sz cont =
      match constr_or_uni with
      | ArgLambda t -&gt; compile_lam env cenv t sz cont
      | ArgUniv uni -&gt; compile_universe cenv uni sz cont
    in
    let u = Univ.Instance.to_array u in
    let lu = Array.length u in
    let all =
      Array.init (lu + Array.length args)
        (fun i -&gt; if i &lt; lu then ArgUniv u.(i) else ArgLambda args.(i-lu))
    in
    comp_app (fun _ _ _ cont -&gt; Kgetglobal kn :: cont)
      compile_arg cenv () all sz cont</abbr>

let is_univ_copy max u =
  let u = Univ.Instance.to_array u in
  if Array.length u = max then
    Array.fold_left_i (fun i acc u -&gt;
        if acc then
          match Univ.Level.var_index u with
          | None -&gt; false
          | Some l -&gt; l = i
        else false) true u
  else
    false

let dump_bytecode = ref false

let dump_bytecodes init code fvs =
  let open Pp in
    (str &quot;code =&quot; ++ fnl () ++
     pp_bytecodes init ++ fnl () ++
     pp_bytecodes code ++ fnl () ++
     str &quot;fv = &quot; ++
     prlist_with_sep (fun () -&gt; str &quot;; &quot;) pp_fv_elem fvs ++
     fnl ())

let compile ~fail_on_error ?universes:(universes=0) env c =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">init_fun_code ();
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Label.reset_label_counter ();
  let cont = [Kstop] in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let cenv, init_code =
      if Int.equal universes 0 then
        let lam = lambda_of_constr ~optimize:true env c in
        let cenv = empty_comp_env () in
        cenv, ensure_stack_capacity (compile_lam env cenv lam 0) cont
      else
        (* We are going to generate a lambda, but merge the universe closure
         * with the function closure if it exists.
         *)
        let lam = lambda_of_constr ~optimize:true env c in
        let params, body = decompose_Llam lam in
        let arity = Array.length params in
        let cenv = empty_comp_env () in
        let full_arity = arity + universes in
        let r_fun = comp_env_fun ~univs:universes arity in
        let lbl_fun = Label.create () in
        let cont_fun =
          ensure_stack_capacity (compile_lam env r_fun body full_arity)
                         [Kreturn full_arity]
        in
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fun_code := [Ksequence(add_grab full_arity lbl_fun cont_fun,!fun_code)];
        let fv = fv r_fun in
        let init_code =
          ensure_stack_capacity (compile_fv cenv fv.fv_rev 0)
                         (Kclosure(lbl_fun,fv.size) :: cont)
        in
        cenv, init_code</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
    in
    let fv = List.rev (!(cenv.in_env).fv_rev) in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(if !dump_bytecode then
      Feedback.msg_debug (dump_bytecodes init_code !fun_code fv)) ;
    Some (init_code,!fun_code, Array.of_list fv)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
  with TooLargeInductive msg -&gt;
    let fn = if fail_on_error then CErrors.user_err ?loc:None ~hdr:&quot;compile&quot; else
        (fun x -&gt; Feedback.msg_warning x) in
    fn msg; None</abbr>

let compile_constant_body ~fail_on_error env univs = function
  | Undef _ | OpaqueDef _ | Primitive _ -&gt; Some BCconstant
  | Def sb -&gt;
      let body = Mod_subst.force_constr sb in
      let instance_size = Univ.AUContext.size (Declareops.universes_context univs) in
      match kind body with
        | Const (kn',u) when is_univ_copy instance_size u -&gt;
            (* we use the canonical name of the constant*)
            let con= Constant.make1 (Constant.canonical kn') in
              Some (BCalias (get_alias env con))
        | _ -&gt;
            let res = compile ~fail_on_error ~universes:instance_size env body in
              Option.map (fun x -&gt; BCdefined (to_memory x)) res

(* Shortcut of the previous function used during module strengthening *)

let compile_alias kn = BCalias (Constant.make1 (Constant.canonical kn))
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cbytegen.ml"><code>Cbytegen.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Vmvalues.

Import Cbytecodes.

Import Cemitcodes.

Import Clambda.

Import Constr.

Import Declarations.

Import Environ.

Definition Fv_elem :=
  let t := Cbytecodes.fv_elem in
  let compare (e1 : Cbytecodes.fv_elem) (e2 : Cbytecodes.fv_elem) : Z :=
    match (e1, e2) with
    | (Cbytecodes.FVnamed id1, Cbytecodes.FVnamed id2) =&gt; Id.compare id1 id2
    |
      (Cbytecodes.FVnamed _,
        Cbytecodes.FVrel _ | Cbytecodes.FVuniv_var _ | Cbytecodes.FVevar _) =&gt;
      (-1)
    | (Cbytecodes.FVrel _, Cbytecodes.FVnamed _) =&gt; 1
    | (Cbytecodes.FVrel r1, Cbytecodes.FVrel r2) =&gt; Int.compare r1 r2
    | (Cbytecodes.FVrel _, Cbytecodes.FVuniv_var _ | Cbytecodes.FVevar _) =&gt;
      (-1)
    | (Cbytecodes.FVuniv_var i1, Cbytecodes.FVuniv_var i2) =&gt; Int.compare i1 i2
    | (Cbytecodes.FVuniv_var _, Cbytecodes.FVnamed _ | Cbytecodes.FVrel _) =&gt; 1
    | (Cbytecodes.FVuniv_var _, Cbytecodes.FVevar _) =&gt; (-1)
    |
      (Cbytecodes.FVevar _,
        Cbytecodes.FVnamed _ | Cbytecodes.FVrel _ | Cbytecodes.FVuniv_var _) =&gt;
      1
    | (Cbytecodes.FVevar e1, Cbytecodes.FVevar e2) =&gt; Evar.compare e1 e2
    end in
  existT (fun _ =&gt; _) tt
    {|
      Util.__Set.OrderedType.compare := compare
    |}.

Definition FvMap :=
  Map.Make
    (existT _ _
      {|
        Stdlib__map.OrderedType.compare :=
          (|Fv_elem|).(Util.__Set.OrderedType.compare)
      |}).

Module vm_env.
  Record record := {
    size : Z;
    fv_rev : list Cbytecodes.fv_elem;
    fv_fwd : FvMap.t Z }.
  Definition with_size (r : record) size : record :=
    {| size := size; fv_rev := fv_rev r; fv_fwd := fv_fwd r |}.
  Definition with_fv_rev (r : record) fv_rev : record :=
    {| size := size r; fv_rev := fv_rev; fv_fwd := fv_fwd r |}.
  Definition with_fv_fwd (r : record) fv_fwd : record :=
    {| size := size r; fv_rev := fv_rev r; fv_fwd := fv_fwd |}.
End vm_env.
Definition vm_env := vm_env.record.

Module comp_env.
  Record record := {
    arity : Z;
    nb_uni_stack : Z;
    nb_stack : Z;
    in_stack : list Z;
    nb_rec : Z;
    pos_rec : list Cbytecodes.instruction;
    offset : Z;
    in_env : Stdlib.ref vm_env }.
  Definition with_arity (r : record) arity : record :=
    {| arity := arity; nb_uni_stack := nb_uni_stack r; nb_stack := nb_stack r;
      in_stack := in_stack r; nb_rec := nb_rec r; pos_rec := pos_rec r;
      offset := offset r; in_env := in_env r |}.
  Definition with_nb_uni_stack (r : record) nb_uni_stack : record :=
    {| arity := arity r; nb_uni_stack := nb_uni_stack; nb_stack := nb_stack r;
      in_stack := in_stack r; nb_rec := nb_rec r; pos_rec := pos_rec r;
      offset := offset r; in_env := in_env r |}.
  Definition with_nb_stack (r : record) nb_stack : record :=
    {| arity := arity r; nb_uni_stack := nb_uni_stack r; nb_stack := nb_stack;
      in_stack := in_stack r; nb_rec := nb_rec r; pos_rec := pos_rec r;
      offset := offset r; in_env := in_env r |}.
  Definition with_in_stack (r : record) in_stack : record :=
    {| arity := arity r; nb_uni_stack := nb_uni_stack r; nb_stack := nb_stack r;
      in_stack := in_stack; nb_rec := nb_rec r; pos_rec := pos_rec r;
      offset := offset r; in_env := in_env r |}.
  Definition with_nb_rec (r : record) nb_rec : record :=
    {| arity := arity r; nb_uni_stack := nb_uni_stack r; nb_stack := nb_stack r;
      in_stack := in_stack r; nb_rec := nb_rec; pos_rec := pos_rec r;
      offset := offset r; in_env := in_env r |}.
  Definition with_pos_rec (r : record) pos_rec : record :=
    {| arity := arity r; nb_uni_stack := nb_uni_stack r; nb_stack := nb_stack r;
      in_stack := in_stack r; nb_rec := nb_rec r; pos_rec := pos_rec;
      offset := offset r; in_env := in_env r |}.
  Definition with_offset (r : record) offset : record :=
    {| arity := arity r; nb_uni_stack := nb_uni_stack r; nb_stack := nb_stack r;
      in_stack := in_stack r; nb_rec := nb_rec r; pos_rec := pos_rec r;
      offset := offset; in_env := in_env r |}.
  Definition with_in_env (r : record) in_env : record :=
    {| arity := arity r; nb_uni_stack := nb_uni_stack r; nb_stack := nb_stack r;
      in_stack := in_stack r; nb_rec := nb_rec r; pos_rec := pos_rec r;
      offset := offset r; in_env := in_env |}.
End comp_env.
Definition comp_env := comp_env.record.

Module Config.
  Definition stack_threshold : Z := 256.
  
  Definition stack_safety_margin : Z := 15.
End Config.

Inductive argument : Set :=
| ArgLambda : Clambda.lambda -&gt; argument
| ArgUniv : Univ.Level.t -&gt; argument.

Definition empty_fv : vm_env :=
  {| vm_env.size := 0; vm_env.fv_rev := []; vm_env.fv_fwd := FvMap.empty |}.

Definition push_fv (d : FvMap.key) (e : vm_env) : vm_env :=
  {| vm_env.size := Z.add (vm_env.size e) 1;
    vm_env.fv_rev := cons d (vm_env.fv_rev e);
    vm_env.fv_fwd := FvMap.add d (vm_env.size e) (vm_env.fv_fwd e) |}.

Definition fv (r : comp_env) : vm_env :=
  Stdlib.op_exclamation (comp_env.in_env r).

Definition empty_comp_env (function_parameter : unit) : comp_env :=
  let '_ := function_parameter in
  {| comp_env.arity := 0; comp_env.nb_uni_stack := 0; comp_env.nb_stack := 0;
    comp_env.in_stack := []; comp_env.nb_rec := 0; comp_env.pos_rec := [];
    comp_env.offset := 0; comp_env.in_env := Stdlib.__ref_value empty_fv |}.

Definition max_stack_size : Stdlib.ref Z := Stdlib.__ref_value 0.

Definition set_max_stack_size (stack_size : Z) : unit :=
  if OCaml.Stdlib.gt stack_size (Stdlib.op_exclamation max_stack_size) then
    Stdlib.op_coloneq max_stack_size stack_size
  else
    tt.

Definition ensure_stack_capacity {A : Set}
  (f : A -&gt; list Cbytecodes.instruction) (x : A)
  : list Cbytecodes.instruction :=
  let old := Stdlib.op_exclamation max_stack_size in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let code := f x in
  let used_safe :=
    Z.add (Stdlib.op_exclamation max_stack_size) Config.stack_safety_margin in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  if OCaml.Stdlib.gt used_safe Config.stack_threshold then
    cons (Cbytecodes.Kensurestackcapacity used_safe) code
  else
    code.

Fixpoint add_param (n : Int.t) (sz : Z) (l : list Z) {struct n} : list Z :=
  if Int.equal n 0 then
    l
  else
    add_param (Z.sub n 1) sz (cons (Z.add n sz) l).

Definition comp_env_fun (op_staroptstar : option Z) : Int.t -&gt; comp_env :=
  let univs :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; 0
    end in
  fun arity =&gt;
    {| comp_env.arity := arity; comp_env.nb_uni_stack := univs;
      comp_env.nb_stack := arity; comp_env.in_stack := add_param arity 0 [];
      comp_env.nb_rec := 0; comp_env.pos_rec := []; comp_env.offset := 1;
      comp_env.in_env := Stdlib.__ref_value empty_fv |}.

Definition comp_env_fix_type (rfv : Stdlib.ref vm_env) : comp_env :=
  {| comp_env.arity := 0; comp_env.nb_uni_stack := 0; comp_env.nb_stack := 0;
    comp_env.in_stack := []; comp_env.nb_rec := 0; comp_env.pos_rec := [];
    comp_env.offset := 1; comp_env.in_env := rfv |}.

Definition comp_env_fix
  (ndef : Z) (curr_pos : Z) (arity : Int.t) (rfv : Stdlib.ref vm_env)
  : comp_env :=
  let prec := Stdlib.__ref_value [] in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  {| comp_env.arity := arity; comp_env.nb_uni_stack := 0;
    comp_env.nb_stack := arity; comp_env.in_stack := add_param arity 0 [];
    comp_env.nb_rec := ndef; comp_env.pos_rec := Stdlib.op_exclamation prec;
    comp_env.offset := Z.add (Z.mul 2 (Z.sub (Z.sub ndef curr_pos) 1)) 1;
    comp_env.in_env := rfv |}.

Definition comp_env_cofix_type (ndef : Z) (rfv : Stdlib.ref vm_env)
  : comp_env :=
  {| comp_env.arity := 0; comp_env.nb_uni_stack := 0; comp_env.nb_stack := 0;
    comp_env.in_stack := []; comp_env.nb_rec := 0; comp_env.pos_rec := [];
    comp_env.offset := Z.add 1 ndef; comp_env.in_env := rfv |}.

Definition comp_env_cofix (ndef : Z) (arity : Int.t) (rfv : Stdlib.ref vm_env)
  : comp_env :=
  let prec := Stdlib.__ref_value [] in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  {| comp_env.arity := arity; comp_env.nb_uni_stack := 0;
    comp_env.nb_stack := arity; comp_env.in_stack := add_param arity 0 [];
    comp_env.nb_rec := ndef; comp_env.pos_rec := Stdlib.op_exclamation prec;
    comp_env.offset := Z.add ndef 1; comp_env.in_env := rfv |}.

Definition push_param (n : Int.t) (sz : Z) (r : comp_env) : comp_env :=
  comp_env.with_in_stack
    (comp_env.with_nb_stack r (Z.add (comp_env.nb_stack r) n))
    (add_param n sz (comp_env.in_stack r)).

Definition push_local (sz : Z) (r : comp_env) : comp_env :=
  comp_env.with_in_stack
    (comp_env.with_nb_stack r (Z.add (comp_env.nb_stack r) 1))
    (cons (Z.add sz 1) (comp_env.in_stack r)).

Definition find_at (fv : FvMap.key) (env : vm_env) : Z :=
  FvMap.find fv (vm_env.fv_fwd env).

Definition pos_named (id : Names.Id.t) (r : comp_env)
  : Cbytecodes.instruction :=
  let env := Stdlib.op_exclamation (comp_env.in_env r) in
  let cid := Cbytecodes.FVnamed id in
  (* ❌ Try-with are not handled *)
  try (Cbytecodes.Kenvacc (Z.add (comp_env.offset r) (find_at cid env))).

Definition pos_rel (i : Z) (r : comp_env) (sz : Z) : Cbytecodes.instruction :=
  if OCaml.Stdlib.le i (comp_env.nb_stack r) then
    Cbytecodes.Kacc
      (Z.sub sz
        ((|Util.List|).(CList.ExtS.nth) (comp_env.in_stack r) (Z.sub i 1)))
  else
    let i := Z.sub i (comp_env.nb_stack r) in
    if OCaml.Stdlib.le i (comp_env.nb_rec r) then
      (* ❌ Try-with are not handled *)
      try ((|Util.List|).(CList.ExtS.nth) (comp_env.pos_rec r) (Z.sub i 1))
    else
      let i := Z.sub i (comp_env.nb_rec r) in
      let db := Cbytecodes.FVrel i in
      let env := Stdlib.op_exclamation (comp_env.in_env r) in
      (* ❌ Try-with are not handled *)
      try (Cbytecodes.Kenvacc (Z.add (comp_env.offset r) (find_at db env))).

Definition pos_universe_var (i : Z) (r : comp_env) (sz : Z)
  : Cbytecodes.instruction :=
  if Stdlib.op_exclamationeq (comp_env.nb_uni_stack r) 0 then
    Cbytecodes.Kacc
      (Z.sub (Z.sub sz (comp_env.arity r)) (Z.sub (comp_env.nb_uni_stack r) i))
  else
    let env := Stdlib.op_exclamation (comp_env.in_env r) in
    let db := Cbytecodes.FVuniv_var i in
    (* ❌ Try-with are not handled *)
    try (Cbytecodes.Kenvacc (Z.add (comp_env.offset r) (find_at db env))).

Definition pos_evar (evk : Evar.t) (r : comp_env) : Cbytecodes.instruction :=
  let env := Stdlib.op_exclamation (comp_env.in_env r) in
  let cid := Cbytecodes.FVevar evk in
  (* ❌ Try-with are not handled *)
  try (Cbytecodes.Kenvacc (Z.add (comp_env.offset r) (find_at cid env))).

Definition discard_dead_code {A : Set} (cont : A) : A := cont.

Definition label_code (function_parameter : list Cbytecodes.instruction)
  : Cbytecodes.Label.t * list Cbytecodes.instruction :=
  match function_parameter with
  | (cons (Cbytecodes.Klabel lbl) _) as cont =&gt; (lbl, cont)
  | (cons (Cbytecodes.Kbranch lbl) _) as cont =&gt; (lbl, cont)
  | cont =&gt;
    let lbl := Label.create tt in
    (lbl, (cons (Cbytecodes.Klabel lbl) cont))
  end.

Fixpoint make_branch_2
  (lbl : option Cbytecodes.Label.t) (n : Z) (cont : list Cbytecodes.instruction)
  (function_parameter : list Cbytecodes.instruction) {struct lbl}
  : Cbytecodes.instruction * list Cbytecodes.instruction :=
  match function_parameter with
  | cons (Cbytecodes.Kreturn m) _ =&gt; ((Cbytecodes.Kreturn (Z.add n m)), cont)
  | cons (Cbytecodes.Klabel _) c =&gt; make_branch_2 lbl n cont c
  | cons (Cbytecodes.Kpop m) c =&gt; make_branch_2 lbl (Z.add n m) cont c
  | _ =&gt;
    match lbl with
    | Some lbl =&gt; ((Cbytecodes.Kbranch lbl), cont)
    | None =&gt;
      let lbl := Label.create tt in
      ((Cbytecodes.Kbranch lbl), (cons (Cbytecodes.Klabel lbl) cont))
    end
  end.

Definition make_branch (cont : list Cbytecodes.instruction)
  : Cbytecodes.instruction * list Cbytecodes.instruction :=
  match cont with
  | cons ((Cbytecodes.Kbranch _) as branch) _ =&gt; (branch, cont)
  | cons ((Cbytecodes.Kreturn _) as __return) _ =&gt; (__return, cont)
  | cons (Cbytecodes.Klabel lbl) _ =&gt; make_branch_2 (Some lbl) 0 cont cont
  | _ =&gt; make_branch_2 None 0 cont cont
  end.

Fixpoint is_tailcall (function_parameter : list Cbytecodes.instruction)
  {struct function_parameter} : option Z :=
  match function_parameter with
  | cons (Cbytecodes.Kreturn k) _ =&gt; Some k
  | cons (Cbytecodes.Klabel _) c =&gt; is_tailcall c
  | _ =&gt; None
  end.

Fixpoint add_pop (n : Int.t) (function_parameter : list Cbytecodes.instruction)
  {struct n} : list Cbytecodes.instruction :=
  match function_parameter with
  | cons (Cbytecodes.Kpop m) cont =&gt; add_pop (Z.add n m) cont
  | cons (Cbytecodes.Kreturn m) cont =&gt;
    cons (Cbytecodes.Kreturn (Z.add n m)) cont
  | cont =&gt;
    if Int.equal n 0 then
      cont
    else
      cons (Cbytecodes.Kpop n) cont
  end.

Definition add_grab
  (arity : Int.t) (lbl : Cbytecodes.Label.t)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  if Int.equal arity 1 then
    cons (Cbytecodes.Klabel lbl) cont
  else
    cons Cbytecodes.Krestart
      (cons (Cbytecodes.Klabel lbl)
        (cons (Cbytecodes.Kgrab (Z.sub arity 1)) cont)).

Definition add_grabrec
  (rec_arg : Int.t) (arity : Int.t) (lbl : Cbytecodes.Label.t)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  if andb (Int.equal arity 1) (OCaml.Stdlib.lt rec_arg arity) then
    cons (Cbytecodes.Klabel lbl)
      (cons (Cbytecodes.Kgrabrec 0) (cons Cbytecodes.Krestart cont))
  else
    cons Cbytecodes.Krestart
      (cons (Cbytecodes.Klabel lbl)
        (cons (Cbytecodes.Kgrabrec rec_arg)
          (cons Cbytecodes.Krestart
            (cons (Cbytecodes.Kgrab (Z.sub arity 1)) cont)))).

Definition cont_cofix (arity : Z) : list Cbytecodes.instruction :=
  [
    Cbytecodes.Kpush;
    Cbytecodes.Kpush;
    Cbytecodes.Kacc 2;
    Cbytecodes.Kfield 1;
    Cbytecodes.Kfield 0;
    Cbytecodes.Kmakeblock 2 cofix_evaluated_tag;
    Cbytecodes.Kpush;
    Cbytecodes.Kacc 2;
    Cbytecodes.Ksetfield 1;
    Cbytecodes.Kacc 0;
    Cbytecodes.Kreturn (Z.add arity 2)
  ].

Definition fun_code : Stdlib.ref (list Cbytecodes.instruction) :=
  Stdlib.__ref_value [].

Definition init_fun_code (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  Stdlib.op_coloneq fun_code [].

Definition nest_block (tag : Z) (arity : Z) (cont : list Cbytecodes.instruction)
  : list Cbytecodes.instruction :=
  cons
    (Cbytecodes.Kconst
      (Vmvalues.Const_b0 (Z.sub tag Obj.last_non_constant_constructor_tag)))
    (cons
      (Cbytecodes.Kmakeblock (Z.add arity 1)
        Obj.last_non_constant_constructor_tag) cont).

Definition code_makeblock
  (stack_size : Z) (arity : Z) (tag : Vmvalues.tag)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  if OCaml.Stdlib.lt tag Obj.last_non_constant_constructor_tag then
    cons (Cbytecodes.Kmakeblock arity tag) cont
  else
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    cons Cbytecodes.Kpush (nest_block tag arity cont).

Definition compile_structured_constant {A : Set}
  (_cenv : A) (sc : Vmvalues.structured_constant) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  cons (Cbytecodes.Kconst sc) cont.

Definition comp_args {A B : Set}
  (comp_expr :
    A -&gt; B -&gt; Z -&gt; list Cbytecodes.instruction -&gt; list Cbytecodes.instruction)
  (cenv : A) (args : array B) (sz : Z) (cont : list Cbytecodes.instruction)
  : list Cbytecodes.instruction :=
  let nargs_m_1 := Z.sub ((|Util.Array|).(CArray.ExtS.length) args) 1 in
  let c :=
    Stdlib.__ref_value
      (comp_expr cenv ((|Util.Array|).(CArray.ExtS.get) args 0)
        (Z.add sz nargs_m_1) cont) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.op_exclamation c.

Definition comp_app {A B C : Set}
  (comp_fun :
    A -&gt; B -&gt; Z -&gt; list Cbytecodes.instruction -&gt; list Cbytecodes.instruction)
  (comp_arg :
    A -&gt; C -&gt; Z -&gt; list Cbytecodes.instruction -&gt; list Cbytecodes.instruction)
  (cenv : A) (f : B) (args : array C) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  let nargs := (|Util.Array|).(CArray.ExtS.length) args in
  if Int.equal nargs 0 then
    comp_fun cenv f sz cont
  else
    match is_tailcall cont with
    | Some k =&gt;
      comp_args comp_arg cenv args sz
        (cons Cbytecodes.Kpush
          (comp_fun cenv f (Z.add sz nargs)
            (cons (Cbytecodes.Kappterm nargs (Z.add k nargs))
              (discard_dead_code cont))))
    | None =&gt;
      if OCaml.Stdlib.le nargs 4 then
        comp_args comp_arg cenv args sz
          (cons Cbytecodes.Kpush
            (comp_fun cenv f (Z.add sz nargs)
              (cons (Cbytecodes.Kapply nargs) cont)))
      else
        let '(lbl, cont1) := label_code cont in
        cons (Cbytecodes.Kpush_retaddr lbl)
          (comp_args comp_arg cenv args (Z.add sz 3)
            (cons Cbytecodes.Kpush
              (comp_fun cenv f (Z.add (Z.add sz 3) nargs)
                (cons (Cbytecodes.Kapply nargs) cont1))))
    end.

Definition compile_fv_elem
  (cenv : comp_env) (fv : Cbytecodes.fv_elem) (sz : Z)
  (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
  match fv with
  | Cbytecodes.FVrel i =&gt; cons (pos_rel i cenv sz) cont
  | Cbytecodes.FVnamed id =&gt; cons (pos_named id cenv) cont
  | Cbytecodes.FVuniv_var i =&gt; cons (pos_universe_var i cenv sz) cont
  | Cbytecodes.FVevar evk =&gt; cons (pos_evar evk cenv) cont
  end.

Fixpoint compile_fv
  (cenv : comp_env) (l : list Cbytecodes.fv_elem) (sz : Z)
  (cont : list Cbytecodes.instruction) {struct cenv}
  : list Cbytecodes.instruction :=
  match l with
  | [] =&gt; cont
  | cons fvn [] =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    compile_fv_elem cenv fvn sz cont
  | cons fvn tl =&gt;
    compile_fv_elem cenv fvn sz
      (cons Cbytecodes.Kpush (compile_fv cenv tl (Z.add sz 1) cont))
  end.

Fixpoint get_alias (env : Environ.env) (kn : Names.Constant.t) {struct env}
  : Names.Constant.t :=
  let cb := lookup_constant kn env in
  let tps := Declarations.constant_body.const_body_code cb in
  match tps with
  | None =&gt; kn
  | Some tps =&gt;
    match Cemitcodes.force tps with
    | Cemitcodes.BCalias kn' =&gt; get_alias env kn'
    | _ =&gt; kn
    end
  end.

Fixpoint compile_lam
  (env : Environ.env) (cenv : comp_env) (lam : Clambda.lambda) (sz : Z)
  (cont : list Cbytecodes.instruction) {struct env}
  : list Cbytecodes.instruction :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  match lam with
  | Clambda.Lrel _ i =&gt; cons (pos_rel i cenv sz) cont
  | Clambda.Lint i =&gt;
    compile_structured_constant cenv (Vmvalues.Const_b0 i) sz cont
  | Clambda.Lval v =&gt;
    compile_structured_constant cenv (Vmvalues.Const_val v) sz cont
  | Clambda.Luint i =&gt;
    compile_structured_constant cenv (Vmvalues.Const_uint i) sz cont
  | Clambda.Lproj p arg =&gt;
    compile_lam env cenv arg sz (cons (Cbytecodes.Kproj p) cont)
  | Clambda.Lvar id =&gt; cons (pos_named id cenv) cont
  | Clambda.Levar evk args =&gt;
    if (|Util.Array|).(CArray.ExtS.is_empty) args then
      compile_fv_elem cenv (Cbytecodes.FVevar evk) sz cont
    else
      let args := (|Util.Array|).(CArray.ExtS.copy) args in
      let '_ := (|Util.Array|).(CArray.ExtS.rev) args in
      comp_app compile_fv_elem (compile_lam env) cenv (Cbytecodes.FVevar evk)
        args sz cont
  | Clambda.Lconst (kn, u) =&gt;
    compile_constant env cenv kn u
      (* ❌ Arrays not handled. *)
      [ ] sz cont
  | Clambda.Lind (ind, u) =&gt;
    if Univ.Instance.is_empty u then
      compile_structured_constant cenv (Vmvalues.Const_ind ind) sz cont
    else
      comp_app compile_structured_constant compile_universe cenv
        (Vmvalues.Const_ind ind) (Univ.Instance.to_array u) sz cont
  | Clambda.Lsort ((Sorts.SProp | Sorts.Prop | Sorts.__Set) as s) =&gt;
    compile_structured_constant cenv (Vmvalues.Const_sort s) sz cont
  | Clambda.Lsort (Sorts.Type u) =&gt;
    let '(u, s) := Univ.compact_univ u in
    let compile_get_univ
      (cenv : comp_env) (idx : Z) (sz : Z) (cont : list Cbytecodes.instruction)
      : list Cbytecodes.instruction :=
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      compile_fv_elem cenv (Cbytecodes.FVuniv_var idx) sz cont in
    if (|Util.List|).(CList.ExtS.is_empty) s then
      compile_structured_constant cenv
        (Vmvalues.Const_sort (Sorts.sort_of_univ u)) sz cont
    else
      comp_app compile_structured_constant compile_get_univ cenv
        (Vmvalues.Const_sort (Sorts.sort_of_univ u))
        ((|Util.Array|).(CArray.ExtS.of_list) s) sz cont
  | Clambda.Llet _id def body =&gt;
    compile_lam env cenv def sz
      (cons Cbytecodes.Kpush
        (compile_lam env (push_local sz cenv) body (Z.add sz 1) (add_pop 1 cont)))
  | Clambda.Lprod dom codom =&gt;
    let cont1 :=
      cons Cbytecodes.Kpush
        (compile_lam env cenv dom (Z.add sz 1) (cons Cbytecodes.Kmakeprod cont))
      in
    compile_lam env cenv codom sz cont1
  | Clambda.Llam ids body =&gt;
    let arity := (|Util.Array|).(CArray.ExtS.length) ids in
    let r_fun := comp_env_fun None arity in
    let lbl_fun := Label.create tt in
    let cont_fun :=
      ensure_stack_capacity (compile_lam env r_fun body arity)
        [ Cbytecodes.Kreturn arity ] in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let fv := fv r_fun in
    compile_fv cenv (vm_env.fv_rev fv) sz
      (cons (Cbytecodes.Kclosure lbl_fun (vm_env.size fv)) cont)
  | Clambda.Lapp f args =&gt;
    match f with
    | Clambda.Lconst (kn, u) =&gt; compile_constant env cenv kn u args sz cont
    | _ =&gt; comp_app (compile_lam env) (compile_lam env) cenv f args sz cont
    end
  | Clambda.Lfix (rec_args, init) (_decl, types, bodies) =&gt;
    let ndef := (|Util.Array|).(CArray.ExtS.length) types in
    let rfv := Stdlib.__ref_value empty_fv in
    let lbl_types := (|Util.Array|).(CArray.ExtS.make) ndef Label.no in
    let lbl_bodies := (|Util.Array|).(CArray.ExtS.make) ndef Label.no in
    let env_type := comp_env_fix_type rfv in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let fv := Stdlib.op_exclamation rfv in
    compile_fv cenv (vm_env.fv_rev fv) sz
      (cons (Cbytecodes.Kclosurerec (vm_env.size fv) init lbl_types lbl_bodies)
        cont)
  | Clambda.Lcofix init (_decl, types, bodies) =&gt;
    let ndef := (|Util.Array|).(CArray.ExtS.length) types in
    let lbl_types := (|Util.Array|).(CArray.ExtS.make) ndef Label.no in
    let lbl_bodies := (|Util.Array|).(CArray.ExtS.make) ndef Label.no in
    let rfv := Stdlib.__ref_value empty_fv in
    let env_type := comp_env_cofix_type ndef rfv in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let fv := Stdlib.op_exclamation rfv in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    compile_fv cenv (vm_env.fv_rev fv) sz
      (cons
        (Cbytecodes.Kclosurecofix (vm_env.size fv) init lbl_types lbl_bodies)
        cont)
  | Clambda.Lif t bt bf =&gt;
    let '(branch, cont) := make_branch cont in
    let lbl_true := Label.create tt in
    let lbl_false := Label.create tt in
    compile_lam env cenv t sz
      (cons
        (Cbytecodes.Kswitch
          (* ❌ Arrays not handled. *)
          [ lbl_true; lbl_false ]
          (* ❌ Arrays not handled. *)
          [ ])
        (cons (Cbytecodes.Klabel lbl_false)
          (compile_lam env cenv bf sz
            (cons branch
              (cons (Cbytecodes.Klabel lbl_true)
                (compile_lam env cenv bt sz cont))))))
  | Clambda.Lcase ci rtbl t a branches =&gt;
    let ind := Constr.case_info.ci_ind ci in
    let mib := lookup_mind (fst ind) env in
    let oib :=
      (|Util.Array|).(CArray.ExtS.get)
        (Declarations.mutual_inductive_body.mind_packets mib) (snd ind) in
    let lbl_consts :=
      (|Util.Array|).(CArray.ExtS.make)
        (Declarations.one_inductive_body.mind_nb_constant oib) Label.no in
    let nallblock := Z.add (Declarations.one_inductive_body.mind_nb_args oib) 1
      in
    let nconst :=
      (|Util.Array|).(CArray.ExtS.length)
        (Clambda.lam_branches.constant_branches branches) in
    let nblock :=
      OCaml.Stdlib.min nallblock (Z.add Obj.last_non_constant_constructor_tag 1)
      in
    let lbl_blocks := (|Util.Array|).(CArray.ExtS.make) nblock Label.no in
    let neblock :=
      OCaml.Stdlib.max 0 (Z.sub nallblock Obj.last_non_constant_constructor_tag)
      in
    let lbl_eblocks := (|Util.Array|).(CArray.ExtS.make) neblock Label.no in
    let '(branch1, cont) := make_branch cont in
    let fcode :=
      ensure_stack_capacity (compile_lam env cenv t sz)
        [ Cbytecodes.Kpop sz; Cbytecodes.Kstop ] in
    let '(lbl_typ, fcode) := label_code fcode in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let lbl_sw := Label.create tt in
    let '(sz_b, branch, is_tailcall) :=
      match branch1 with
      | Cbytecodes.Kreturn k =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (sz, branch1, true)
      | Cbytecodes.Kbranch _ =&gt; ((Z.add sz 3), Cbytecodes.Kjump, false)
      | _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end in
    let c := Stdlib.__ref_value cont in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let annot :=
      {| Vmvalues.annot_switch.ci := ci; Vmvalues.annot_switch.rtbl := rtbl;
        Vmvalues.annot_switch.tailcall := is_tailcall;
        Vmvalues.annot_switch.max_stack_size :=
          Z.sub (Stdlib.op_exclamation max_stack_size) sz |} in
    let '(lbl_accu, code_accu) :=
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      label_code
        (cons (Cbytecodes.Kmakeswitchblock lbl_typ lbl_sw annot sz)
          (cons branch (Stdlib.op_exclamation c))) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let code_sw :=
      match branch1 with
      | Cbytecodes.Kbranch lbl =&gt;
        cons (Cbytecodes.Kpush_retaddr lbl) (Stdlib.op_exclamation c)
      | _ =&gt; Stdlib.op_exclamation c
      end in
    compile_lam env cenv a sz code_sw
  | Clambda.Lmakeblock tag args =&gt;
    let arity := (|Util.Array|).(CArray.ExtS.length) args in
    let cont := code_makeblock (Z.sub (Z.add sz arity) 1) arity tag cont in
    comp_args (compile_lam env) cenv args sz cont
  | Clambda.Lprim kn op args =&gt;
    comp_args (compile_lam env) cenv args sz
      (cons (Cbytecodes.Kprim op kn) cont)
  end

with compile_get_global
  (cenv : comp_env) (function_parameter : Names.Constant.t * Univ.Instance.t)
  {struct cenv}
  : Z -&gt; list Cbytecodes.instruction -&gt; list Cbytecodes.instruction :=
  let '(kn, u) := function_parameter in
  fun sz =&gt;
    fun cont =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      if Univ.Instance.is_empty u then
        cons (Cbytecodes.Kgetglobal kn) cont
      else
        comp_app
          (fun function_parameter =&gt;
            let '_ := function_parameter in
            fun function_parameter =&gt;
              let '_ := function_parameter in
              fun function_parameter =&gt;
                let '_ := function_parameter in
                fun cont =&gt; cons (Cbytecodes.Kgetglobal kn) cont)
          compile_universe cenv tt (Univ.Instance.to_array u) sz cont

with compile_universe
  (cenv : comp_env) (uni : Univ.Level.t) (sz : Z)
  (cont : list Cbytecodes.instruction) {struct cenv}
  : list Cbytecodes.instruction :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  match Univ.Level.var_index uni with
  | None =&gt;
    compile_structured_constant cenv (Vmvalues.Const_univ_level uni) sz cont
  | Some idx =&gt; cons (pos_universe_var idx cenv sz) cont
  end

with compile_constant
  (env : Environ.env) (cenv : comp_env) (kn : Names.Constant.t)
  (u : Univ.Instance.t) (args : array Clambda.lambda) (sz : Z)
  (cont : list Cbytecodes.instruction) {struct env}
  : list Cbytecodes.instruction :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  if Univ.Instance.is_empty u then
    comp_app
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          fun sz =&gt; fun cont =&gt; compile_get_global cenv (kn, u) sz cont)
      (compile_lam env) cenv tt args sz cont
  else
    let compile_arg
      (cenv : comp_env) (constr_or_uni : argument) (sz : Z)
      (cont : list Cbytecodes.instruction) : list Cbytecodes.instruction :=
      match constr_or_uni with
      | ArgLambda t =&gt; compile_lam env cenv t sz cont
      | ArgUniv uni =&gt; compile_universe cenv uni sz cont
      end in
    let u := Univ.Instance.to_array u in
    let lu := (|Util.Array|).(CArray.ExtS.length) u in
    let all :=
      (|Util.Array|).(CArray.ExtS.init)
        (Z.add lu ((|Util.Array|).(CArray.ExtS.length) args))
        (fun i =&gt;
          if OCaml.Stdlib.lt i lu then
            ArgUniv ((|Util.Array|).(CArray.ExtS.get) u i)
          else
            ArgLambda ((|Util.Array|).(CArray.ExtS.get) args (Z.sub i lu))) in
    comp_app
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          fun function_parameter =&gt;
            let '_ := function_parameter in
            fun cont =&gt; cons (Cbytecodes.Kgetglobal kn) cont) compile_arg cenv
      tt all sz cont.

Definition is_univ_copy (max : Z) (u : Univ.Instance.t) : bool :=
  let u := Univ.Instance.to_array u in
  if equiv_decb ((|Util.Array|).(CArray.ExtS.length) u) max then
    (|Util.Array|).(CArray.ExtS.fold_left_i)
      (fun i =&gt;
        fun acc =&gt;
          fun u =&gt;
            if acc then
              match Univ.Level.var_index u with
              | None =&gt; false
              | Some l =&gt; equiv_decb l i
              end
            else
              false) true u
  else
    false.

Definition dump_bytecode : Stdlib.ref bool := Stdlib.__ref_value false.

Definition dump_bytecodes
  (init : Cbytecodes.bytecodes) (code : Cbytecodes.bytecodes)
  (fvs : list Cbytecodes.fv_elem) : Pp.t :=
  op_plusplus
    (op_plusplus
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus (op_plusplus (str &quot;code =&quot;) (fnl tt))
                (pp_bytecodes init)) (fnl tt)) (pp_bytecodes code)) (fnl tt))
        (str &quot;fv = &quot;))
      (prlist_with_sep
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          str &quot;; &quot;) pp_fv_elem fvs)) (fnl tt).

Definition compile (fail_on_error : bool) (op_staroptstar : option Int.t)
  : Environ.env -&gt; Constr.t -&gt;
  option
    (list Cbytecodes.instruction * list Cbytecodes.instruction *
      array Cbytecodes.fv_elem) :=
  let universes :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; 0
    end in
  fun env =&gt;
    fun c =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let cont := [ Cbytecodes.Kstop ] in
      (* ❌ Try-with are not handled *)
      try
        (let '(cenv, init_code) :=
          if Int.equal universes 0 then
            let lam := lambda_of_constr true env c in
            let cenv := empty_comp_env tt in
            (cenv, (ensure_stack_capacity (compile_lam env cenv lam 0) cont))
          else
            let lam := lambda_of_constr true env c in
            let '(params, body) := decompose_Llam lam in
            let arity := (|Util.Array|).(CArray.ExtS.length) params in
            let cenv := empty_comp_env tt in
            let full_arity := Z.add arity universes in
            let r_fun := comp_env_fun (Some universes) arity in
            let lbl_fun := Label.create tt in
            let cont_fun :=
              ensure_stack_capacity (compile_lam env r_fun body full_arity)
                [ Cbytecodes.Kreturn full_arity ] in
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            let fv := fv r_fun in
            let init_code :=
              ensure_stack_capacity (compile_fv cenv (vm_env.fv_rev fv) 0)
                (cons (Cbytecodes.Kclosure lbl_fun (vm_env.size fv)) cont) in
            (cenv, init_code) in
        let fv :=
          (|Util.List|).(CList.ExtS.rev)
            (vm_env.fv_rev (Stdlib.op_exclamation (comp_env.in_env cenv))) in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        Some
          (init_code, (Stdlib.op_exclamation fun_code),
            ((|Util.Array|).(CArray.ExtS.of_list) fv))).

Definition compile_constant_body
  (fail_on_error : bool) (env : Environ.env) (univs : Declarations.universes)
  (function_parameter :
    Declarations.constant_def (Mod_subst.substituted Constr.constr))
  : option Cemitcodes.body_code :=
  match function_parameter with
  | Declarations.Undef _ | Declarations.OpaqueDef _ | Declarations.Primitive _
    =&gt; Some Cemitcodes.BCconstant
  | Declarations.Def sb =&gt;
    let body := Mod_subst.force_constr sb in
    let instance_size :=
      Univ.AUContext.size (Declareops.universes_context univs) in
    match
      ((kind body),
        match kind body with
        | Constr.Const (kn', u) =&gt; is_univ_copy instance_size u
        | _ =&gt; false
        end) with
    | (Constr.Const (kn', u), true) =&gt;
      let con := Constant.make1 (Constant.canonical kn') in
      Some (Cemitcodes.BCalias (get_alias env con))
    | (_, _) =&gt;
      let res := compile fail_on_error (Some instance_size) env body in
      Option.map (fun x =&gt; Cemitcodes.BCdefined (to_memory x)) res
    end
  end.

Definition compile_alias (kn : Names.Constant.t) : Cemitcodes.body_code :=
  Cemitcodes.BCalias (Constant.make1 (Constant.canonical kn)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cbytegen.mli">
  <div style="margin: 20px;">
    <h3>Cbytegen_mli</h3>
    <ul>
      <li>OCaml size: 31 lines</li>
      <li>Coq size: 23 lines (-26% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cbytegen.mli"><code>cbytegen.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Cbytecodes
open Cemitcodes
open Constr
open Declarations
open Environ

(** Should only be used for monomorphic terms *)
val compile : fail_on_error:bool -&gt;
              ?universes:int -&gt; env -&gt; constr -&gt; (bytecodes * bytecodes * fv) option
(** init, fun, fv *)

val compile_constant_body : fail_on_error:bool -&gt;
  env -&gt; universes -&gt; Constr.t Mod_subst.substituted constant_def -&gt;
  body_code option

(** Shortcut of the previous function used during module strengthening *)

val compile_alias : Names.Constant.t -&gt; body_code

(** Dump the bytecode after compilation (for debugging purposes) *)
val dump_bytecode : bool ref
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cbytegen.mli"><code>Cbytegen_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter compile :
  bool -&gt; option Z -&gt; Environ.env -&gt; Constr.constr -&gt;
  option (Cbytecodes.bytecodes * Cbytecodes.bytecodes * Cbytecodes.fv).

Parameter compile_constant_body :
  bool -&gt; Environ.env -&gt; Declarations.universes -&gt;
  Declarations.constant_def (Mod_subst.substituted Constr.t) -&gt;
  option Cemitcodes.body_code.

Parameter compile_alias : Names.Constant.t -&gt; Cemitcodes.body_code.

Parameter dump_bytecode : Stdlib.ref bool.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cemitcodes.ml">
  <div style="margin: 20px;">
    <h3>Cemitcodes</h3>
    <ul>
      <li>OCaml size: 461 lines</li>
      <li>Coq size: 652 lines (+41% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cemitcodes.ml"><code>cemitcodes.ml</code></a>&nbsp;<span class="label label-warning">92 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Author: Benjamin GrÃ©goire as part of the bytecode-based virtual reduction
   machine, Oct 2004 *)
(* Extension: Arnaud Spiwack (support for native arithmetic), May 2005 *)

open Names
open Constr
open Vmvalues
open Cbytecodes
open Copcodes
open Mod_subst
open CPrimitives

type emitcodes = String.t

external tcode_of_code : Bytes.t -&gt; Vmvalues.tcode = &quot;coq_tcode_of_code&quot;

(* Relocation information *)
type reloc_info =
  | Reloc_annot of annot_switch
  | Reloc_const of structured_constant
  | Reloc_getglobal of Names.Constant.t
  | Reloc_proj_name of Projection.Repr.t

let eq_reloc_info r1 r2 = match r1, r2 with
| Reloc_annot sw1, Reloc_annot sw2 -&gt; eq_annot_switch sw1 sw2
| Reloc_annot _, _ -&gt; false
| Reloc_const c1, Reloc_const c2 -&gt; eq_structured_constant c1 c2
| Reloc_const _, _ -&gt; false
| Reloc_getglobal c1, Reloc_getglobal c2 -&gt; Constant.equal c1 c2
| Reloc_getglobal _, _ -&gt; false
| Reloc_proj_name p1, Reloc_proj_name p2 -&gt; Projection.Repr.equal p1 p2
| Reloc_proj_name _, _ -&gt; false

let hash_reloc_info r =
  let open Hashset.Combine in
  match r with
  | Reloc_annot sw -&gt; combinesmall 1 (hash_annot_switch sw)
  | Reloc_const c -&gt; combinesmall 2 (hash_structured_constant c)
  | Reloc_getglobal c -&gt; combinesmall 3 (Constant.hash c)
  | Reloc_proj_name p -&gt; combinesmall 4 (Projection.Repr.hash p)

module RelocTable = Hashtbl.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">struct
  type t = reloc_info
  let equal = eq_reloc_info
  let hash = hash_reloc_info
end</abbr>)

(** We use arrays for on-disk representation. On 32-bit machines, this means we
    can only have a maximum amount of about 4.10^6 relocations, which seems
    quite a lot, but potentially reachable if e.g. compiling big proofs. This
    would prevent VM computing with these terms on 32-bit architectures. Maybe
    we should use a more robust data structure? *)
type patches = {
  reloc_infos : (reloc_info * int array) array;
}

let patch_char4 buff pos c1 c2 c3 c4 =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Bytes.unsafe_set buff pos       c1;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Bytes.unsafe_set buff (pos + 1) c2;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Bytes.unsafe_set buff (pos + 2) c3;
  Bytes.unsafe_set buff (pos + 3) c4</abbr>

let patch1 buff pos n =
  patch_char4 buff pos
    (Char.unsafe_chr n) (Char.unsafe_chr (n asr 8))  (Char.unsafe_chr (n asr 16))
    (Char.unsafe_chr (n asr 24))

let patch_int buff reloc =
  (* copy code *before* patching because of nested evaluations:
     the code we are patching might be called (and thus &quot;concurrently&quot; patched)
     and results in wrong results. Side-effects... *)
  let buff = Bytes.of_string buff in
  let iter (reloc, npos) = Array.iter (fun pos -&gt; patch1 buff pos reloc) npos in
  let () = CArray.iter iter reloc in
  buff

let patch buff pl f =
  (** Order seems important here? *)
  let reloc = CArray.map (fun (r, pos) -&gt; (f r, pos)) pl.reloc_infos in
  let buff = patch_int buff reloc in
  tcode_of_code buff

(* Buffering of bytecode *)

type label_definition =
    Label_defined of int
  | Label_undefined of (int * int) list

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">type env = {
  mutable out_buffer : Bytes.t;
  mutable out_position : int;
  mutable label_table : label_definition array;
  (* le ieme element de la table = Label_defined n signifie que l'on a
    deja rencontrer le label i et qu'il est a l'offset n.
                                = Label_undefined l signifie que l'on a
    pas encore rencontrer ce label, le premier entier indique ou est l'entier
    a patcher dans la string, le deuxieme son origine  *)
  reloc_info : int list RelocTable.t;
}</abbr>

let out_word env b1 b2 b3 b4 =
  let p = env.out_position in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if p &gt;= Bytes.length env.out_buffer then begin
    let len = Bytes.length env.out_buffer in
    let new_len =
      if len &lt;= Sys.max_string_length / 2
      then 2 * len
      else
        if len = Sys.max_string_length
        then invalid_arg &quot;String.create&quot;  (* Pas la bonne exception .... *)
        else Sys.max_string_length in
    let new_buffer = Bytes.create new_len in
    Bytes.blit env.out_buffer 0 new_buffer 0 len;
    env.out_buffer &lt;- new_buffer
  end;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">patch_char4 env.out_buffer p (Char.unsafe_chr b1)
   (Char.unsafe_chr b2) (Char.unsafe_chr b3) (Char.unsafe_chr b4);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Set record field not handled.">env.out_position &lt;- p + 4</abbr>

let out env opcode =
  out_word env opcode 0 0 0

let is_immed i = Uint63.le (Uint63.of_int i) Uint63.maxuint31

let out_int env n =
  out_word env n (n asr 8) (n asr 16) (n asr 24)

(* Handling of local labels and backpatching *)

let extend_label_table env needed =
  let new_size = ref(Array.length env.label_table) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">while needed &gt;= !new_size do new_size := 2 * !new_size done;
  let new_table = Array.make !new_size (Label_undefined []) in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.blit env.label_table 0 new_table 0 (Array.length env.label_table);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Set record field not handled.">env.label_table &lt;- new_table</abbr>

let backpatch env (pos, orig) =
  let displ = (env.out_position - orig) asr 2 in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Bytes.set env.out_buffer  pos    @@ Char.unsafe_chr displ;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Bytes.set env.out_buffer (pos+1) @@ Char.unsafe_chr (displ asr 8);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Bytes.set env.out_buffer (pos+2) @@ Char.unsafe_chr (displ asr 16);
  Bytes.set env.out_buffer (pos+3) @@ Char.unsafe_chr (displ asr 24)</abbr>

let define_label env lbl =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if lbl &gt;= Array.length env.label_table then extend_label_table env lbl;
  match (env.label_table).(lbl) with
    Label_defined _ -&gt;
      raise</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">(Failure &quot;CEmitcode.define_label&quot;)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  | Label_undefined patchlist -&gt;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">List.iter (fun p -&gt; backpatch env p) patchlist;
      (env.label_table).(lbl) &lt;- Label_defined env.out_position</abbr>

let out_label_with_orig env orig lbl =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if lbl &gt;= Array.length env.label_table then extend_label_table env lbl;
  match (env.label_table).(lbl) with
    Label_defined def -&gt;
      out_int env ((def - orig) asr 2)
  | Label_undefined patchlist -&gt;
      (* spiwack: patchlist is supposed to be non-empty all the time
         thus I commented that out. If there is no problem I suggest
         removing it for next release (cur: 8.1) *)
      (*if patchlist = [] then *)
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(env.label_table).(lbl) &lt;-
          Label_undefined((env.out_position, orig) :: patchlist);
      out_int env 0</abbr>

let out_label env l = out_label_with_orig env env.out_position l

(* Relocation information *)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">enter</abbr> env info =
  let pos = env.out_position in
  let old = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RelocTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> env.reloc_info info with Not_found -&gt; []</abbr> in
  <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RelocTable.replace</abbr> env.reloc_info info (pos :: old)

let slot_for_const env c =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">enter env (Reloc_const c);
  out_int env 0</abbr>

let slot_for_annot env a =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">enter env (Reloc_annot a);
  out_int env 0</abbr>

let slot_for_getglobal env p =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">enter env (Reloc_getglobal p);
  out_int env 0</abbr>

let slot_for_proj_name env p =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">enter env (Reloc_proj_name p);
  out_int env 0</abbr>

(* Emission of one instruction *)

let nocheck_prim_op = function
  | Int63add -&gt; opADDINT63
  | Int63sub -&gt; opSUBINT63
  | Int63lt  -&gt; opLTINT63
  | Int63le  -&gt; opLEINT63
  | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>


let check_prim_op = function
  | Int63head0     -&gt; opCHECKHEAD0INT63
  | Int63tail0     -&gt; opCHECKTAIL0INT63
  | Int63add       -&gt; opCHECKADDINT63
  | Int63sub       -&gt; opCHECKSUBINT63
  | Int63mul       -&gt; opCHECKMULINT63
  | Int63div       -&gt; opCHECKDIVINT63
  | Int63mod       -&gt; opCHECKMODINT63
  | Int63lsr       -&gt; opCHECKLSRINT63
  | Int63lsl       -&gt; opCHECKLSLINT63
  | Int63land      -&gt; opCHECKLANDINT63
  | Int63lor       -&gt; opCHECKLORINT63
  | Int63lxor      -&gt; opCHECKLXORINT63
  | Int63addc      -&gt; opCHECKADDCINT63
  | Int63subc      -&gt; opCHECKSUBCINT63
  | Int63addCarryC -&gt; opCHECKADDCARRYCINT63
  | Int63subCarryC -&gt; opCHECKSUBCARRYCINT63
  | Int63mulc      -&gt; opCHECKMULCINT63
  | Int63diveucl   -&gt; opCHECKDIVEUCLINT63
  | Int63div21     -&gt; opCHECKDIV21INT63
  | Int63addMulDiv -&gt; opCHECKADDMULDIVINT63
  | Int63eq        -&gt; opCHECKEQINT63
  | Int63lt        -&gt; opCHECKLTINT63
  | Int63le        -&gt; opCHECKLEINT63
  | Int63compare   -&gt; opCHECKCOMPAREINT63

let emit_instr env = function
  | Klabel lbl -&gt; define_label env lbl
  | Kacc n -&gt;
      if n &lt; 8 then out env(opACC0 + n) else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opACC; out_int env n)</abbr>
  | Kenvacc n -&gt;
      if n &gt;= 1 &amp;&amp; n &lt;= 4
      then out env(opENVACC1 + n - 1)
      else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opENVACC; out_int env n)</abbr>
  | Koffsetclosure ofs -&gt;
      if Int.equal ofs (-2) || Int.equal ofs 0 || Int.equal ofs 2
      then out env (opOFFSETCLOSURE0 + ofs / 2)
      else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opOFFSETCLOSURE; out_int env ofs)</abbr>
  | Kpush -&gt;
      out env opPUSH
  | Kpop n -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opPOP; out_int env n</abbr>
  | Kpush_retaddr lbl -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opPUSH_RETADDR; out_label env lbl</abbr>
  | Kapply n -&gt;
      if n &lt;= 4 then out env(opAPPLY1 + n - 1) else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opAPPLY; out_int env n)</abbr>
  | Kappterm(n, sz) -&gt;
      if n &lt; 4 then <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env(opAPPTERM1 + n - 1); out_int env sz)</abbr>
               else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opAPPTERM; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env n; out_int env sz</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)</abbr>
  | Kreturn n -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opRETURN; out_int env n</abbr>
  | Kjump -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opRETURN; out_int env 0</abbr>
  | Krestart -&gt;
      out env opRESTART
  | Kgrab n -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opGRAB; out_int env n</abbr>
  | Kgrabrec(rec_arg) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opGRABREC; out_int env rec_arg</abbr>
  | Kclosure(lbl, n) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opCLOSURE; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env n; out_label env lbl</abbr>
  | Kclosurerec(nfv,init,lbl_types,lbl_bodies) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opCLOSUREREC;</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env (Array.length lbl_bodies);
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env nfv; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env init;
      let org = env.out_position in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (out_label_with_orig env org) lbl_types;
      let org = env.out_position in
      Array.iter (out_label_with_orig env org) lbl_bodies</abbr>
  | Kclosurecofix(nfv,init,lbl_types,lbl_bodies) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opCLOSURECOFIX;</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env (Array.length lbl_bodies);
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env nfv; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env init;
      let org = env.out_position in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (out_label_with_orig env org) lbl_types;
      let org = env.out_position in
      Array.iter (out_label_with_orig env org) lbl_bodies</abbr>
  | Kgetglobal q -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opGETGLOBAL; slot_for_getglobal env q</abbr>
  | Kconst (Const_b0 i) when is_immed i -&gt;
      if i &gt;= 0 &amp;&amp; i &lt;= 3
          then out env (opCONST0 + i)
          else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opCONSTINT; out_int env i)</abbr>
  | Kconst c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opGETGLOBAL; slot_for_const env c</abbr>
  | Kmakeblock(n, t) -&gt;
      if Int.equal n 0 then invalid_arg &quot;emit_instr : block size = 0&quot;
      else if n &lt; 4 then <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env(opMAKEBLOCK1 + n - 1); out_int env t)</abbr>
      else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opMAKEBLOCK; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env n; out_int env t</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)</abbr>
  | Kmakeprod -&gt;
      out env opMAKEPROD
  | Kmakeswitchblock(typlbl,swlbl,annot,sz) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opMAKESWITCHBLOCK;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_label env typlbl; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_label env swlbl;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">slot_for_annot env annot;out_int env sz</abbr>
  | Kswitch (tbl_const, tbl_block) -&gt;
      let lenb = Array.length tbl_block in
      let lenc = Array.length tbl_const in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (lenb &lt; 0x100 &amp;&amp; lenc &lt; 0x1000000);
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opSWITCH;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_word env lenc (lenc asr 8) (lenc asr 16) (lenb);
(*      out_int env (Array.length tbl_const + (Array.length tbl_block lsl 23)); *)
      let org = env.out_position in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (out_label_with_orig env org) tbl_const;
      Array.iter (out_label_with_orig env org) tbl_block</abbr>
  | Kpushfields n -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opPUSHFIELDS;out_int env n</abbr>
  | Kfield n -&gt;
      if n &lt;= 1 then out env (opGETFIELD0+n)
      else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opGETFIELD;out_int env n)</abbr>
  | Ksetfield n -&gt;
      if n &lt;= 1 then out env (opSETFIELD0+n)
      else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(out env opSETFIELD;out_int env n)</abbr>
  | Ksequence _ -&gt; invalid_arg &quot;Cemitcodes.emit_instr&quot;
  | Kproj p -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opPROJ; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env (Projection.Repr.arg p); slot_for_proj_name env p</abbr>
  | Kensurestackcapacity size -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opENSURESTACKCAPACITY; out_int env size</abbr>
  | Kbranch lbl -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opBRANCH; out_label env lbl</abbr>
  | Kprim (op,None) -&gt;
      out env (nocheck_prim_op op)

  | Kprim(op,Some (q,_u)) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env (check_prim_op op);
      slot_for_getglobal env q</abbr>

  | Kareint 1 -&gt; out env opISINT
  | Kareint 2 -&gt; out env opAREINT2;

  | Kstop -&gt; out env opSTOP

  | Kareint _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

(* Emission of a current list and remaining lists of instructions. Include some peephole optimization. *)

let rec emit env insns remaining = match insns with
  | [] -&gt;
     (match remaining with
       [] -&gt; ()
     | (first::rest) -&gt; emit env first rest)
  (* Peephole optimizations *)
  | Kpush :: Kacc n :: c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if n &lt; 8 then out env(opPUSHACC0 + n) else (out env opPUSHACC; out_int env n);
      emit env c remaining</abbr>
  | Kpush :: Kenvacc n :: c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if n &gt;= 1 &amp;&amp; n &lt;= 4
      then out env(opPUSHENVACC1 + n - 1)
      else (out env opPUSHENVACC; out_int env n);
      emit env c remaining</abbr>
  | Kpush :: Koffsetclosure ofs :: c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int.equal ofs (-2) || Int.equal ofs 0 || Int.equal ofs 2
      then out env(opPUSHOFFSETCLOSURE0 + ofs / 2)
      else (out env opPUSHOFFSETCLOSURE; out_int env ofs);
      emit env c remaining</abbr>
  | Kpush :: Kgetglobal id :: c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opPUSHGETGLOBAL; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">slot_for_getglobal env id; emit env c remaining</abbr>
  | Kpush :: Kconst (Const_b0 i) :: c when is_immed i -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if i &gt;= 0 &amp;&amp; i &lt;= 3
      then out env (opPUSHCONST0 + i)
      else (out env opPUSHCONSTINT; out_int env i);
      emit env c remaining</abbr>
  | Kpush :: Kconst const :: c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opPUSHGETGLOBAL; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">slot_for_const env const;
      emit env c remaining</abbr>
  | Kpop n :: Kjump :: c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out env opRETURN; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">out_int env n; emit env c remaining</abbr>
  | Ksequence(c1,c2)::c -&gt;
      emit env c1 (c2::c::remaining)
  (* Default case *)
  | instr :: c -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">emit_instr env instr; emit env c remaining</abbr>

(* Initialization *)

type to_patch = emitcodes * patches * fv

(* Substitution *)
let subst_strcst s sc =
  match sc with
  | Const_sort _ | Const_b0 _ | Const_univ_level _ | Const_val _ | Const_uint _ -&gt; sc
  | Const_ind ind -&gt; let kn,i = ind in Const_ind (subst_mind s kn, i)

let subst_reloc s ri =
  match ri with
  | Reloc_annot a -&gt;
      let (kn,i) = a.ci.ci_ind in
      let ci = {a.ci with ci_ind = (subst_mind s kn,i)} in
      Reloc_annot {a with ci = ci}
  | Reloc_const sc -&gt; Reloc_const (subst_strcst s sc)
  | Reloc_getglobal kn -&gt; Reloc_getglobal (subst_constant s kn)
  | Reloc_proj_name p -&gt; Reloc_proj_name (subst_proj_repr s p)

let subst_patches subst p =
  let infos = CArray.map (fun (r, pos) -&gt; (subst_reloc subst r, pos)) p.reloc_infos in
  { reloc_infos = infos; }

let subst_to_patch s (code,pl,fv) =
  code, subst_patches s pl, fv

type body_code =
  | BCdefined of to_patch
  | BCalias of Names.Constant.t
  | BCconstant

type to_patch_substituted =
| PBCdefined of to_patch substituted
| PBCalias of Names.Constant.t substituted
| PBCconstant

let from_val = function
| BCdefined tp -&gt; PBCdefined (from_val tp)
| BCalias cu -&gt; PBCalias (from_val cu)
| BCconstant -&gt; PBCconstant

let force = function
| PBCdefined tp -&gt; BCdefined (force subst_to_patch tp)
| PBCalias cu -&gt; BCalias (force subst_constant cu)
| PBCconstant -&gt; BCconstant

let subst_to_patch_subst s = function
| PBCdefined tp -&gt; PBCdefined (subst_substituted s tp)
| PBCalias cu -&gt; PBCalias (subst_substituted s cu)
| PBCconstant -&gt; PBCconstant

let repr_body_code = function
| PBCdefined tp -&gt;
  let (s, tp) = repr_substituted tp in
  (s, BCdefined tp)
| PBCalias cu -&gt;
  let (s, cu) = repr_substituted cu in
  (s, BCalias cu)
| PBCconstant -&gt; (None, BCconstant)

let to_memory (init_code, fun_code, fv) =
  let env = {
    out_buffer = Bytes.create 1024;
    out_position = 0;
    label_table = Array.make 16 (Label_undefined []);
    reloc_info = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RelocTable.create</abbr> 91;
  } in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">emit env init_code [];
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">emit env fun_code [];
  (** Later uses of this string are all purely functional *)
  let code = Bytes.sub_string env.out_buffer 0 env.out_position in
  let code = CString.hcons code in
  let fold reloc npos accu = (reloc, Array.of_list npos) :: accu in
  let reloc = </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RelocTable.fold</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> fold env.reloc_info [] in
  let reloc = { reloc_infos = CArray.of_list reloc } in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (fun lbl -&gt;
    (match lbl with
      Label_defined _ -&gt; assert true
    | Label_undefined patchlist -&gt;
        assert (patchlist = []))) env.label_table;
  (code, reloc, fv)</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cemitcodes.ml"><code>Cemitcodes.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Constr.

Import Vmvalues.

Import Cbytecodes.

Import Copcodes.

Import Mod_subst.

Import CPrimitives.

Definition emitcodes := Stdlib.String.t.

Parameter tcode_of_code : Stdlib.Bytes.t -&gt; Vmvalues.tcode.

Inductive reloc_info : Set :=
| Reloc_annot : Vmvalues.annot_switch -&gt; reloc_info
| Reloc_const : Vmvalues.structured_constant -&gt; reloc_info
| Reloc_getglobal : Names.Constant.t -&gt; reloc_info
| Reloc_proj_name : Names.Projection.Repr.t -&gt; reloc_info.

Definition eq_reloc_info (r1 : reloc_info) (r2 : reloc_info) : bool :=
  match (r1, r2) with
  | (Reloc_annot sw1, Reloc_annot sw2) =&gt; eq_annot_switch sw1 sw2
  | (Reloc_annot _, _) =&gt; false
  | (Reloc_const c1, Reloc_const c2) =&gt; eq_structured_constant c1 c2
  | (Reloc_const _, _) =&gt; false
  | (Reloc_getglobal c1, Reloc_getglobal c2) =&gt; Constant.equal c1 c2
  | (Reloc_getglobal _, _) =&gt; false
  | (Reloc_proj_name p1, Reloc_proj_name p2) =&gt; Projection.Repr.equal p1 p2
  | (Reloc_proj_name _, _) =&gt; false
  end.

Definition hash_reloc_info (r : reloc_info) : Z :=
  match r with
  | Reloc_annot sw =&gt; combinesmall 1 (hash_annot_switch sw)
  | Reloc_const c =&gt; combinesmall 2 (hash_structured_constant c)
  | Reloc_getglobal c =&gt; combinesmall 3 (Constant.hash c)
  | Reloc_proj_name p =&gt; combinesmall 4 (Projection.Repr.hash p)
  end.

Definition RelocTable :=
  Hashtbl.Make
    (let t := reloc_info in
    let equal := eq_reloc_info in
    let hash := hash_reloc_info in
    existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal := equal;
        Stdlib__hashtbl.HashedType.hash := hash
      |}).

Module patches.
  Record record := {
    reloc_infos : array (reloc_info * array Z) }.
  Definition with_reloc_infos (r : record) reloc_infos : record :=
    {| reloc_infos := reloc_infos |}.
End patches.
Definition patches := patches.record.

Definition patch_char4
  (buff : string) (pos : Z) (c1 : ascii) (c2 : ascii) (c3 : ascii) (c4 : ascii)
  : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.Bytes.unsafe_set buff (Z.add pos 3) c4.

Definition patch1 (buff : string) (pos : Z) (n : Z) : unit :=
  patch_char4 buff pos (Char.unsafe_chr n) (Char.unsafe_chr (Stdlib.asr n 8))
    (Char.unsafe_chr (Stdlib.asr n 16)) (Char.unsafe_chr (Stdlib.asr n 24)).

Definition patch_int (buff : string) (reloc : array (Z * array Z)) : string :=
  let buff := Stdlib.Bytes.of_string buff in
  let iter (function_parameter : Z * array Z) : unit :=
    let '(reloc, npos) := function_parameter in
    (|Stdlib.Array|).(CArray.S.iter) (fun pos =&gt; patch1 buff pos reloc) npos in
  let '_ := (|CArray|).(CArray.ExtS.iter) iter reloc in
  buff.

Definition patch (buff : string) (pl : patches) (f : reloc_info -&gt; Z)
  : Vmvalues.tcode :=
  let reloc :=
    (|CArray|).(CArray.ExtS.map)
      (fun function_parameter =&gt;
        let '(r, pos) := function_parameter in
        ((f r), pos)) (patches.reloc_infos pl) in
  let buff := patch_int buff reloc in
  tcode_of_code buff.

Inductive label_definition : Set :=
| Label_defined : Z -&gt; label_definition
| Label_undefined : list (Z * Z) -&gt; label_definition.

Module env.
  Record record := {
    out_buffer : Stdlib.Bytes.t;
    out_position : Z;
    label_table : array label_definition;
    reloc_info : (|RelocTable|).(Stdlib__hashtbl.S.t) (list Z) }.
  Definition with_out_buffer (r : record) out_buffer : record :=
    {| out_buffer := out_buffer; out_position := out_position r;
      label_table := label_table r; reloc_info := reloc_info r |}.
  Definition with_out_position (r : record) out_position : record :=
    {| out_buffer := out_buffer r; out_position := out_position;
      label_table := label_table r; reloc_info := reloc_info r |}.
  Definition with_label_table (r : record) label_table : record :=
    {| out_buffer := out_buffer r; out_position := out_position r;
      label_table := label_table; reloc_info := reloc_info r |}.
  Definition with_reloc_info (r : record) reloc_info : record :=
    {| out_buffer := out_buffer r; out_position := out_position r;
      label_table := label_table r; reloc_info := reloc_info |}.
End env.
Definition env := env.record.

Definition out_word (env : env) (b1 : Z) (b2 : Z) (b3 : Z) (b4 : Z) : unit :=
  let p := env.out_position env in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Set record field not handled. *)
  set_record_field env &quot;out_position&quot; (Z.add p 4).

Definition out (env : env) (opcode : Z) : unit := out_word env opcode 0 0 0.

Definition is_immed (i : Z) : bool :=
  Uint63.le (Uint63.of_int i) Uint63.maxuint31.

Definition out_int (env : env) (n : Z) : unit :=
  out_word env n (Stdlib.asr n 8) (Stdlib.asr n 16) (Stdlib.asr n 24).

Definition extend_label_table (env : env) (needed : Z) : unit :=
  let new_size :=
    Stdlib.__ref_value
      ((|Stdlib.Array|).(CArray.S.length) (env.label_table env)) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let new_table :=
    (|Stdlib.Array|).(CArray.S.make) (Stdlib.op_exclamation new_size)
      (Label_undefined []) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Set record field not handled. *)
  set_record_field env &quot;label_table&quot; new_table.

Definition backpatch (env : env) (function_parameter : Z * Z) : unit :=
  let '(pos, orig) := function_parameter in
  let displ := Stdlib.asr (Z.sub (env.out_position env) orig) 2 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  apply (Stdlib.Bytes.set (env.out_buffer env) (Z.add pos 3))
    (Char.unsafe_chr (Stdlib.asr displ 24)).

Definition define_label (env : env) (lbl : Z) : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  match (|Stdlib.Array|).(CArray.S.get) (env.label_table env) lbl with
  | Label_defined _ =&gt; Stdlib.raise extensible_type_value
  | Label_undefined patchlist =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Stdlib.Array|).(CArray.S.set) (env.label_table env) lbl
      (Label_defined (env.out_position env))
  end.

Definition out_label_with_orig (env : env) (orig : Z) (lbl : Z) : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  match (|Stdlib.Array|).(CArray.S.get) (env.label_table env) lbl with
  | Label_defined def =&gt; out_int env (Stdlib.asr (Z.sub def orig) 2)
  | Label_undefined patchlist =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env 0
  end.

Definition out_label (env : env) (l : Z) : unit :=
  out_label_with_orig env (env.out_position env) l.

Definition enter (env : env) (info : (|RelocTable|).(Stdlib__hashtbl.S.key))
  : unit :=
  let pos := env.out_position env in
  let old :=
    (* ❌ Try-with are not handled *)
    try ((|RelocTable|).(Stdlib__hashtbl.S.find) (env.reloc_info env) info) in
  (|RelocTable|).(Stdlib__hashtbl.S.replace) (env.reloc_info env) info
    (cons pos old).

Definition slot_for_const (env : env) (c : Vmvalues.structured_constant)
  : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  out_int env 0.

Definition slot_for_annot (env : env) (a : Vmvalues.annot_switch) : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  out_int env 0.

Definition slot_for_getglobal (env : env) (p : Names.Constant.t) : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  out_int env 0.

Definition slot_for_proj_name (env : env) (p : Names.Projection.Repr.t)
  : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  out_int env 0.

Definition nocheck_prim_op (function_parameter : CPrimitives.t) : Z :=
  match function_parameter with
  | CPrimitives.Int63add =&gt; opADDINT63
  | CPrimitives.Int63sub =&gt; opSUBINT63
  | CPrimitives.Int63lt =&gt; opLTINT63
  | CPrimitives.Int63le =&gt; opLEINT63
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition check_prim_op (function_parameter : CPrimitives.t) : Z :=
  match function_parameter with
  | CPrimitives.Int63head0 =&gt; opCHECKHEAD0INT63
  | CPrimitives.Int63tail0 =&gt; opCHECKTAIL0INT63
  | CPrimitives.Int63add =&gt; opCHECKADDINT63
  | CPrimitives.Int63sub =&gt; opCHECKSUBINT63
  | CPrimitives.Int63mul =&gt; opCHECKMULINT63
  | CPrimitives.Int63div =&gt; opCHECKDIVINT63
  | CPrimitives.Int63mod =&gt; opCHECKMODINT63
  | CPrimitives.Int63lsr =&gt; opCHECKLSRINT63
  | CPrimitives.Int63lsl =&gt; opCHECKLSLINT63
  | CPrimitives.Int63land =&gt; opCHECKLANDINT63
  | CPrimitives.Int63lor =&gt; opCHECKLORINT63
  | CPrimitives.Int63lxor =&gt; opCHECKLXORINT63
  | CPrimitives.Int63addc =&gt; opCHECKADDCINT63
  | CPrimitives.Int63subc =&gt; opCHECKSUBCINT63
  | CPrimitives.Int63addCarryC =&gt; opCHECKADDCARRYCINT63
  | CPrimitives.Int63subCarryC =&gt; opCHECKSUBCARRYCINT63
  | CPrimitives.Int63mulc =&gt; opCHECKMULCINT63
  | CPrimitives.Int63diveucl =&gt; opCHECKDIVEUCLINT63
  | CPrimitives.Int63div21 =&gt; opCHECKDIV21INT63
  | CPrimitives.Int63addMulDiv =&gt; opCHECKADDMULDIVINT63
  | CPrimitives.Int63eq =&gt; opCHECKEQINT63
  | CPrimitives.Int63lt =&gt; opCHECKLTINT63
  | CPrimitives.Int63le =&gt; opCHECKLEINT63
  | CPrimitives.Int63compare =&gt; opCHECKCOMPAREINT63
  end.

Definition emit_instr (env : env) (function_parameter : Cbytecodes.instruction)
  : unit :=
  match
    (function_parameter,
      match function_parameter with
      | Cbytecodes.Kconst (Vmvalues.Const_b0 i) =&gt; is_immed i
      | _ =&gt; false
      end) with
  | (Cbytecodes.Klabel lbl, _) =&gt; define_label env lbl
  | (Cbytecodes.Kacc n, _) =&gt;
    if OCaml.Stdlib.lt n 8 then
      out env (Z.add opACC0 n)
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env n
  | (Cbytecodes.Kenvacc n, _) =&gt;
    if andb (OCaml.Stdlib.ge n 1) (OCaml.Stdlib.le n 4) then
      out env (Z.sub (Z.add opENVACC1 n) 1)
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env n
  | (Cbytecodes.Koffsetclosure ofs, _) =&gt;
    if orb (Int.equal ofs (-2)) (orb (Int.equal ofs 0) (Int.equal ofs 2)) then
      out env (Z.add opOFFSETCLOSURE0 (Z.div ofs 2))
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env ofs
  | (Cbytecodes.Kpush, _) =&gt; out env opPUSH
  | (Cbytecodes.Kpop n, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env n
  | (Cbytecodes.Kpush_retaddr lbl, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_label env lbl
  | (Cbytecodes.Kapply n, _) =&gt;
    if OCaml.Stdlib.le n 4 then
      out env (Z.sub (Z.add opAPPLY1 n) 1)
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env n
  | (Cbytecodes.Kappterm n sz, _) =&gt;
    if OCaml.Stdlib.lt n 4 then
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env sz
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env sz
  | (Cbytecodes.Kreturn n, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env n
  | (Cbytecodes.Kjump, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env 0
  | (Cbytecodes.Krestart, _) =&gt; out env opRESTART
  | (Cbytecodes.Kgrab n, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env n
  | (Cbytecodes.Kgrabrec rec_arg, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env rec_arg
  | (Cbytecodes.Kclosure lbl n, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_label env lbl
  | (Cbytecodes.Kclosurerec nfv init lbl_types lbl_bodies, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let org := env.out_position env in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let org := env.out_position env in
    (|Stdlib.Array|).(CArray.S.iter) (out_label_with_orig env org) lbl_bodies
  | (Cbytecodes.Kclosurecofix nfv init lbl_types lbl_bodies, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let org := env.out_position env in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let org := env.out_position env in
    (|Stdlib.Array|).(CArray.S.iter) (out_label_with_orig env org) lbl_bodies
  | (Cbytecodes.Kgetglobal q, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    slot_for_getglobal env q
  | (Cbytecodes.Kconst (Vmvalues.Const_b0 i), true) =&gt;
    if andb (OCaml.Stdlib.ge i 0) (OCaml.Stdlib.le i 3) then
      out env (Z.add opCONST0 i)
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env i
  | (Cbytecodes.Kconst c, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    slot_for_const env c
  | (Cbytecodes.Kmakeblock n t, _) =&gt;
    if Int.equal n 0 then
      OCaml.Stdlib.invalid_arg &quot;emit_instr : block size = 0&quot;
    else
      if OCaml.Stdlib.lt n 4 then
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        out_int env t
      else
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        out_int env t
  | (Cbytecodes.Kmakeprod, _) =&gt; out env opMAKEPROD
  | (Cbytecodes.Kmakeswitchblock typlbl swlbl annot sz, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env sz
  | (Cbytecodes.Kswitch tbl_const tbl_block, _) =&gt;
    let lenb := (|Stdlib.Array|).(CArray.S.length) tbl_block in
    let lenc := (|Stdlib.Array|).(CArray.S.length) tbl_const in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let org := env.out_position env in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Stdlib.Array|).(CArray.S.iter) (out_label_with_orig env org) tbl_block
  | (Cbytecodes.Kpushfields n, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env n
  | (Cbytecodes.Kfield n, _) =&gt;
    if OCaml.Stdlib.le n 1 then
      out env (Z.add opGETFIELD0 n)
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env n
  | (Cbytecodes.Ksetfield n, _) =&gt;
    if OCaml.Stdlib.le n 1 then
      out env (Z.add opSETFIELD0 n)
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      out_int env n
  | (Cbytecodes.Ksequence _ _, _) =&gt;
    OCaml.Stdlib.invalid_arg &quot;Cemitcodes.emit_instr&quot;
  | (Cbytecodes.Kproj p, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    slot_for_proj_name env p
  | (Cbytecodes.Kensurestackcapacity size, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_int env size
  | (Cbytecodes.Kbranch lbl, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    out_label env lbl
  | (Cbytecodes.Kprim op None, _) =&gt; out env (nocheck_prim_op op)
  | (Cbytecodes.Kprim op (Some (q, _u)), _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    slot_for_getglobal env q
  | (Cbytecodes.Kareint 1, _) =&gt; out env opISINT
  | (Cbytecodes.Kareint 2, _) =&gt; out env opAREINT2
  | (Cbytecodes.Kstop, _) =&gt; out env opSTOP
  | (Cbytecodes.Kareint _, _) =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Fixpoint emit
  (env : env) (insns : Cbytecodes.bytecodes)
  (remaining : list Cbytecodes.bytecodes) {struct env} : unit :=
  match
    (insns,
      match insns with
      | cons Cbytecodes.Kpush (cons (Cbytecodes.Kconst (Vmvalues.Const_b0 i)) c)
        =&gt; is_immed i
      | _ =&gt; false
      end) with
  | ([], _) =&gt;
    match remaining with
    | [] =&gt; tt
    | cons first rest =&gt; emit env first rest
    end
  | (cons Cbytecodes.Kpush (cons (Cbytecodes.Kacc n) c), _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  | (cons Cbytecodes.Kpush (cons (Cbytecodes.Kenvacc n) c), _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  | (cons Cbytecodes.Kpush (cons (Cbytecodes.Koffsetclosure ofs) c), _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  | (cons Cbytecodes.Kpush (cons (Cbytecodes.Kgetglobal id) c), _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  |
    (cons Cbytecodes.Kpush (cons (Cbytecodes.Kconst (Vmvalues.Const_b0 i)) c),
      true) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  | (cons Cbytecodes.Kpush (cons (Cbytecodes.Kconst const) c), _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  | (cons (Cbytecodes.Kpop n) (cons Cbytecodes.Kjump c), _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  | (cons (Cbytecodes.Ksequence c1 c2) c, _) =&gt;
    emit env c1 (cons c2 (cons c remaining))
  | (cons instr c, _) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    emit env c remaining
  end.

Definition to_patch := emitcodes * patches * Cbytecodes.fv.

Definition subst_strcst
  (s : Mod_subst.substitution) (sc : Vmvalues.structured_constant)
  : Vmvalues.structured_constant :=
  match sc with
  |
    Vmvalues.Const_sort _ | Vmvalues.Const_b0 _ | Vmvalues.Const_univ_level _ |
    Vmvalues.Const_val _ | Vmvalues.Const_uint _ =&gt; sc
  | Vmvalues.Const_ind ind =&gt;
    let '(kn, i) := ind in
    Vmvalues.Const_ind ((subst_mind s kn), i)
  end.

Definition subst_reloc (s : Mod_subst.substitution) (ri : reloc_info)
  : reloc_info :=
  match ri with
  | Reloc_annot a =&gt;
    let '(kn, i) := Constr.case_info.ci_ind (Vmvalues.annot_switch.ci a) in
    let ci :=
      Constr.case_info.with_ci_ind (Vmvalues.annot_switch.ci a)
        ((subst_mind s kn), i) in
    Reloc_annot (Vmvalues.annot_switch.with_ci a ci)
  | Reloc_const sc =&gt; Reloc_const (subst_strcst s sc)
  | Reloc_getglobal kn =&gt; Reloc_getglobal (subst_constant s kn)
  | Reloc_proj_name p =&gt; Reloc_proj_name (subst_proj_repr s p)
  end.

Definition subst_patches (subst : Mod_subst.substitution) (p : patches)
  : patches :=
  let infos :=
    (|CArray|).(CArray.ExtS.map)
      (fun function_parameter =&gt;
        let '(r, pos) := function_parameter in
        ((subst_reloc subst r), pos)) (patches.reloc_infos p) in
  {| patches.reloc_infos := infos |}.

Definition subst_to_patch {A B : Set}
  (s : Mod_subst.substitution) (function_parameter : A * patches * B)
  : A * patches * B :=
  let '(code, pl, fv) := function_parameter in
  (code, (subst_patches s pl), fv).

Inductive body_code : Set :=
| BCdefined : to_patch -&gt; body_code
| BCalias : Names.Constant.t -&gt; body_code
| BCconstant : body_code.

Inductive to_patch_substituted : Set :=
| PBCdefined : Mod_subst.substituted to_patch -&gt; to_patch_substituted
| PBCalias : Mod_subst.substituted Names.Constant.t -&gt; to_patch_substituted
| PBCconstant : to_patch_substituted.

Definition from_val (function_parameter : body_code) : to_patch_substituted :=
  match function_parameter with
  | BCdefined tp =&gt; PBCdefined (from_val tp)
  | BCalias cu =&gt; PBCalias (from_val cu)
  | BCconstant =&gt; PBCconstant
  end.

Definition force (function_parameter : to_patch_substituted) : body_code :=
  match function_parameter with
  | PBCdefined tp =&gt; BCdefined (force subst_to_patch tp)
  | PBCalias cu =&gt; BCalias (force subst_constant cu)
  | PBCconstant =&gt; BCconstant
  end.

Definition subst_to_patch_subst
  (s : Mod_subst.substitution) (function_parameter : to_patch_substituted)
  : to_patch_substituted :=
  match function_parameter with
  | PBCdefined tp =&gt; PBCdefined (subst_substituted s tp)
  | PBCalias cu =&gt; PBCalias (subst_substituted s cu)
  | PBCconstant =&gt; PBCconstant
  end.

Definition repr_body_code (function_parameter : to_patch_substituted)
  : option (list Mod_subst.substitution) * body_code :=
  match function_parameter with
  | PBCdefined tp =&gt;
    let '(s, tp) := repr_substituted tp in
    (s, (BCdefined tp))
  | PBCalias cu =&gt;
    let '(s, cu) := repr_substituted cu in
    (s, (BCalias cu))
  | PBCconstant =&gt; (None, BCconstant)
  end.

Definition to_memory {A : Set}
  (function_parameter : Cbytecodes.bytecodes * Cbytecodes.bytecodes * A)
  : string * patches * A :=
  let '(init_code, fun_code, fv) := function_parameter in
  let env :=
    {| env.out_buffer := Stdlib.Bytes.create 1024; env.out_position := 0;
      env.label_table :=
        (|Stdlib.Array|).(CArray.S.make) 16 (Label_undefined []);
      env.reloc_info := (|RelocTable|).(Stdlib__hashtbl.S.create) 91 |} in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let code :=
    Stdlib.Bytes.sub_string (env.out_buffer env) 0 (env.out_position env) in
  let code := (|CString|).(CString.ExtS.hcons) code in
  let fold {B C : Set} (reloc : B) (npos : list C) (accu : list (B * array C))
    : list (B * array C) :=
    cons (reloc, ((|Stdlib.Array|).(CArray.S.of_list) npos)) accu in
  let reloc :=
    (|RelocTable|).(Stdlib__hashtbl.S.fold) fold (env.reloc_info env) [] in
  let reloc :=
    {| patches.reloc_infos := (|CArray|).(CArray.ExtS.of_list) reloc |} in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (code, reloc, fv).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cemitcodes.mli">
  <div style="margin: 20px;">
    <h3>Cemitcodes_mli</h3>
    <ul>
      <li>OCaml size: 43 lines</li>
      <li>Coq size: 44 lines (+2% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cemitcodes.mli"><code>cemitcodes.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
(* &lt;O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2017     *)
(*   \VV/  **************************************************************)
(*    //   *      This file is distributed under the terms of the       *)
(*         *       GNU Lesser General Public License Version 2.1        *)
(************************************************************************)
open Names
open Vmvalues
open Cbytecodes

type reloc_info =
  | Reloc_annot of annot_switch
  | Reloc_const of structured_constant
  | Reloc_getglobal of Constant.t
  | Reloc_proj_name of Projection.Repr.t

type patches
type emitcodes

val patch : emitcodes -&gt; patches -&gt; (reloc_info -&gt; int) -&gt; Vmvalues.tcode

type to_patch = emitcodes * patches * fv

type body_code =
  | BCdefined of to_patch
  | BCalias of Constant.t
  | BCconstant


type to_patch_substituted

val from_val : body_code -&gt; to_patch_substituted

val force : to_patch_substituted -&gt; body_code

val subst_to_patch_subst : Mod_subst.substitution -&gt; to_patch_substituted -&gt; to_patch_substituted

val repr_body_code :
  to_patch_substituted -&gt; Mod_subst.substitution list option * body_code

val to_memory : bytecodes * bytecodes * fv -&gt; to_patch
               (** init code, fun code, fv *)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cemitcodes.mli"><code>Cemitcodes_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Inductive reloc_info : Set :=
| Reloc_annot : Vmvalues.annot_switch -&gt; reloc_info
| Reloc_const : Vmvalues.structured_constant -&gt; reloc_info
| Reloc_getglobal : Names.Constant.t -&gt; reloc_info
| Reloc_proj_name : Names.Projection.Repr.t -&gt; reloc_info.

Parameter patches : Set.

Parameter emitcodes : Set.

Parameter patch : emitcodes -&gt; patches -&gt; (reloc_info -&gt; Z) -&gt; Vmvalues.tcode.

Definition to_patch := emitcodes * patches * Cbytecodes.fv.

Inductive body_code : Set :=
| BCdefined : to_patch -&gt; body_code
| BCalias : Names.Constant.t -&gt; body_code
| BCconstant : body_code.

Parameter to_patch_substituted : Set.

Parameter from_val : body_code -&gt; to_patch_substituted.

Parameter force : to_patch_substituted -&gt; body_code.

Parameter subst_to_patch_subst :
  Mod_subst.substitution -&gt; to_patch_substituted -&gt; to_patch_substituted.

Parameter repr_body_code :
  to_patch_substituted -&gt; option (list Mod_subst.substitution) * body_code.

Parameter to_memory :
  Cbytecodes.bytecodes * Cbytecodes.bytecodes * Cbytecodes.fv -&gt; to_patch.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="clambda.ml">
  <div style="margin: 20px;">
    <h3>Clambda</h3>
    <ul>
      <li>OCaml size: 815 lines</li>
      <li>Coq size: 1107 lines (+35% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#clambda.ml"><code>clambda.ml</code></a>&nbsp;<span class="label label-warning">43 warnings</span>
    
    <pre>open Util
open Names
open Esubst
open Term
open Constr
open Declarations
open Vmvalues
open Environ
open Pp

let pr_con sp = str(Names.Label.to_string (Constant.label sp))

type lambda =
  | Lrel          of Name.t * int
  | Lvar          of Id.t
  | Levar         of Evar.t * lambda array
  | Lprod         of lambda * lambda
  | Llam          of Name.t Context.binder_annot array * lambda
  | Llet          of Name.t Context.binder_annot * lambda * lambda
  | Lapp          of lambda * lambda array
  | Lconst        of pconstant
  | Lprim         of pconstant option * CPrimitives.t * lambda array
        (* No check if None *)
  | Lcase         of case_info * reloc_table * lambda * lambda * lam_branches
  | Lif           of lambda * lambda * lambda
  | Lfix          of (int array * int) * fix_decl
  | Lcofix        of int * fix_decl
  | Lint          of int
  | Lmakeblock    of int * lambda array
  | Luint         of Uint63.t
  | Lval          of structured_values
  | Lsort         of Sorts.t
  | Lind          of pinductive
  | Lproj         of Projection.Repr.t * lambda

(* We separate branches for constant and non-constant constructors. If the OCaml
   limitation on non-constant constructors is reached, remaining branches are
   stored in [extra_branches]. *)
and lam_branches =
  { constant_branches : lambda array;
    nonconstant_branches : (Name.t Context.binder_annot array * lambda) array }
(*    extra_branches : (name array * lambda) array } *)

and fix_decl =  Name.t Context.binder_annot array * lambda array * lambda array

(** Printing **)

let pr_annot x = Name.print x.Context.binder_name

let pp_names ids =
  prlist_with_sep (fun _ -&gt; brk(1,1)) pr_annot (Array.to_list ids)

let pp_rel name n =
  Name.print name ++  str &quot;##&quot; ++ int n

let pp_sort s =
  match Sorts.family s with
  | InSet -&gt; str &quot;Set&quot;
  | InProp -&gt; str &quot;Prop&quot;
  | InSProp -&gt; str &quot;SProp&quot;
  | InType -&gt; str &quot;Type&quot;

let rec pp_lam lam =
  match lam with
  | Lrel (id,n) -&gt; pp_rel id n
  | Lvar id -&gt; Id.print id
  | Levar (evk, args) -&gt;
    hov 1 (str &quot;evar(&quot; ++ Evar.print evk ++ str &quot;,&quot; ++ spc () ++
      prlist_with_sep spc pp_lam (Array.to_list args) ++ str &quot;)&quot;)
  | Lprod(dom,codom) -&gt; hov 1
                          (str &quot;forall(&quot; ++
                           pp_lam dom ++
                           str &quot;,&quot; ++ spc() ++
                           pp_lam codom ++
                           str &quot;)&quot;)
  | Llam(ids,body) -&gt; hov 1
                        (str &quot;(fun &quot; ++
                         pp_names ids ++
                         str &quot; =&gt;&quot; ++
                         spc() ++
                         pp_lam body ++
                         str &quot;)&quot;)
  | Llet(id,def,body) -&gt; hov 0
                           (str &quot;let &quot; ++
                            pr_annot id ++
                            str &quot;:=&quot; ++
                            pp_lam def  ++
                            str &quot; in&quot; ++
                            spc() ++
                            pp_lam body)
  | Lapp(f, args) -&gt; hov 1
                       (str &quot;(&quot; ++ pp_lam f ++ spc() ++
                        prlist_with_sep spc pp_lam (Array.to_list args) ++
                        str&quot;)&quot;)
  | Lconst (kn,_) -&gt; pr_con kn
  | Lcase(_ci, _rtbl, t, a, branches) -&gt;
    let ic = ref (-1) in
    let ib = ref 0 in
    v 0 (str&quot;&lt;&quot; ++ pp_lam t ++ str&quot;&gt;&quot; ++ cut() ++
         str &quot;Case&quot; ++ spc () ++ pp_lam a ++ spc() ++ str &quot;of&quot; ++ cut() ++
         v 0
           ((prlist_with_sep (fun _ -&gt; str &quot;&quot;)
               (fun c -&gt;
                  cut () ++ str &quot;| &quot; ++
                  int <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(incr ic; !ic)</abbr> ++ str &quot; =&gt; &quot; ++ pp_lam c)
               (Array.to_list branches.constant_branches)) ++
            (prlist_with_sep (fun _ -&gt; str &quot;&quot;)
               (fun (ids,c) -&gt;
                  cut () ++ str &quot;| &quot; ++
                  int <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(incr ib; !ib)</abbr> ++ str &quot; &quot; ++
                  pp_names ids ++ str &quot; =&gt; &quot; ++ pp_lam c)
               (Array.to_list branches.nonconstant_branches)))
         ++ cut() ++ str &quot;end&quot;)
  | Lif (t, bt, bf) -&gt;
      v 0 (str &quot;(if &quot; ++ pp_lam t ++
             cut () ++ str &quot;then &quot; ++ pp_lam bt ++
             cut() ++ str &quot;else &quot; ++ pp_lam bf ++ str &quot;)&quot;)
  | Lfix((t,i),(lna,tl,bl)) -&gt;
    let fixl = Array.mapi (fun i id -&gt; (id,t.(i),tl.(i),bl.(i))) lna in
    hov 1
      (str&quot;fix &quot; ++ int i ++ spc() ++  str&quot;{&quot; ++
       v 0
         (prlist_with_sep spc
            (fun (na,i,ty,bd) -&gt;
               pr_annot na ++ str&quot;/&quot; ++ int i ++ str&quot;:&quot; ++
               pp_lam ty ++ cut() ++ str&quot;:=&quot; ++
               pp_lam bd) (Array.to_list fixl)) ++
       str&quot;}&quot;)

  | Lcofix (i,(lna,tl,bl)) -&gt;
    let fixl = Array.mapi (fun i na -&gt; (na,tl.(i),bl.(i))) lna in
    hov 1
      (str&quot;cofix &quot; ++ int i ++ spc() ++  str&quot;{&quot; ++
       v 0
         (prlist_with_sep spc
            (fun (na,ty,bd) -&gt;
               pr_annot na ++ str&quot;:&quot; ++ pp_lam ty ++
               cut() ++ str&quot;:=&quot; ++ pp_lam bd) (Array.to_list fixl)) ++
       str&quot;}&quot;)
  | Lmakeblock(tag, args) -&gt;
    hov 1
      (str &quot;(makeblock &quot; ++ int tag ++ spc() ++
       prlist_with_sep spc pp_lam (Array.to_list args) ++
       str&quot;)&quot;)
  | Luint i -&gt; str (Uint63.to_string i)
  | Lval _ -&gt; str &quot;values&quot;
  | Lsort s -&gt; pp_sort s
  | Lind ((mind,i), _) -&gt; MutInd.print mind ++ str&quot;#&quot; ++ int i
  | Lprim(Some (kn,_u),_op,args) -&gt;
     hov 1
         (str &quot;(PRIM &quot; ++ pr_con kn ++  spc() ++
            prlist_with_sep spc pp_lam  (Array.to_list args) ++
            str&quot;)&quot;)
  | Lprim(None,op,args) -&gt;
     hov 1
         (str &quot;(PRIM_NC &quot; ++ str (CPrimitives.to_string op) ++  spc() ++
            prlist_with_sep spc pp_lam (Array.to_list args) ++
            str&quot;)&quot;)
  | Lproj(p,arg) -&gt;
    hov 1
      (str &quot;(proj &quot; ++ Projection.Repr.print p ++ str &quot;(&quot; ++ pp_lam arg
       ++ str &quot;)&quot;)
  | Lint i -&gt;
    Pp.(str &quot;(int:&quot; ++ int i ++ str &quot;)&quot;)

(*s Constructors *)

let mkLapp f args =
  if Array.length args = 0 then f
  else
    match f with
    | Lapp(f', args') -&gt; Lapp (f', Array.append args' args)
    | _ -&gt; Lapp(f, args)

let mkLlam ids body =
  if Array.length ids = 0 then body
  else
    match body with
    | Llam(ids', body) -&gt; Llam(Array.append ids ids', body)
    | _ -&gt; Llam(ids, body)

let decompose_Llam lam =
  match lam with
  | Llam(ids,body) -&gt; ids, body
  | _ -&gt; <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>, lam

(*s Operators on substitution *)
let subst_id = subs_id 0
let lift = subs_lift
let liftn = subs_liftn
let cons v subst = subs_cons(<abbr class="mark-warning" title="Arrays not handled.">[|v|]</abbr>, subst)
let shift subst = subs_shft (1, subst)

(* A generic map function *)

let map_lam_with_binders g f n lam =
  match lam with
  | Lrel _ | Lvar _  | Lconst _ | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _ -&gt; lam
  | Levar (evk, args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Levar (evk, args')
  | Lprod(dom,codom) -&gt;
    let dom' = f n dom in
    let codom' = f n codom in
    if dom == dom' &amp;&amp; codom == codom' then lam else Lprod(dom',codom')
  | Llam(ids,body) -&gt;
    let body' = f (g (Array.length ids) n) body in
    if body == body' then lam else mkLlam ids body'
  | Llet(id,def,body) -&gt;
    let def' = f n def in
    let body' = f (g 1 n) body in
    if body == body' &amp;&amp; def == def' then lam else Llet(id,def',body')
  | Lapp(fct,args) -&gt;
    let fct' = f n fct in
    let args' = Array.Smart.map (f n) args in
    if fct == fct' &amp;&amp; args == args' then lam else mkLapp fct' args'
  | Lcase(ci,rtbl,t,a,branches) -&gt;
    let const = branches.constant_branches in
    let nonconst = branches.nonconstant_branches in
    let t' = f n t in
    let a' = f n a in
    let const' = Array.Smart.map (f n) const in
    let on_b b =
      let (ids,body) = b in
      let body' = f (g (Array.length ids) n) body in
      if body == body' then b else (ids,body') in
    let nonconst' = Array.Smart.map on_b nonconst in
    let branches' =
      if const == const' &amp;&amp; nonconst == nonconst' then
        branches
      else
        { constant_branches = const';
          nonconstant_branches = nonconst' }
    in
    if t == t' &amp;&amp; a == a' &amp;&amp; branches == branches' then lam else
      Lcase(ci,rtbl,t',a',branches')
  | Lif(t,bt,bf) -&gt;
      let t' = f n t in
      let bt' = f n bt in
      let bf' = f n bf in
      if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam else Lif(t',bt',bf')
  | Lfix(init,(ids,ltypes,lbodies)) -&gt;
    let ltypes' = Array.Smart.map (f n) ltypes in
    let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
    if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
    else Lfix(init,(ids,ltypes',lbodies'))
  | Lcofix(init,(ids,ltypes,lbodies)) -&gt;
    let ltypes' = Array.Smart.map (f n) ltypes in
    let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
    if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
    else Lcofix(init,(ids,ltypes',lbodies'))
  | Lmakeblock(tag,args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Lmakeblock(tag,args')
  | Lprim(kn,op,args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Lprim(kn,op,args')
  | Lproj(p,arg) -&gt;
    let arg' = f n arg in
    if arg == arg' then lam else Lproj(p,arg')

(*s Lift and substitution *)


let rec lam_exlift el lam =
  match lam with
  | Lrel(id,i) -&gt;
    let i' = reloc_rel i el in
    if i == i' then lam else Lrel(id,i')
  | _ -&gt; map_lam_with_binders el_liftn lam_exlift el lam

let lam_lift k lam =
  if k = 0 then lam
  else lam_exlift (el_shft k el_id) lam

let lam_subst_rel lam id n subst =
  match expand_rel n subst with
  | Inl(k,v) -&gt; lam_lift k v
  | Inr(n',_) -&gt;
    if n == n' then lam
    else Lrel(id, n')

let rec lam_exsubst subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst
  | _ -&gt; map_lam_with_binders liftn lam_exsubst subst lam

let lam_subst_args subst args =
  if is_subs_id subst then args
  else Array.Smart.map (lam_exsubst subst) args

(** Simplification of lambda expression *)

(* [simplify subst lam] simplify the expression [lam_subst subst lam] *)
(* that is :                                                          *)
(* - Reduce [let] is the definition can be substituted i.e:           *)
(*    - a variable (rel or identifier)                                *)
(*    - a constant                                                    *)
(*    - a structured constant                                         *)
(*    - a function                                                    *)
(* - Transform beta redex into [let] expression                       *)
(* - Move arguments under [let]                                       *)
(* Invariant : Terms in [subst] are already simplified and can be     *)
(*             substituted                                            *)

let can_subst lam =
  match lam with
  | Lrel _ | Lvar _ | Lconst _ | Luint _
  | Lval _ | Lsort _ | Lind _ -&gt; true
  | _ -&gt; false


let can_merge_if bt bf =
  match bt, bf with
  | Llam(_idst,_), Llam(_idsf,_) -&gt; true
  | _ -&gt; false

let merge_if t bt bf =
  let (idst,bodyt) = decompose_Llam bt in
  let (idsf,bodyf) = decompose_Llam bf in
  let nt = Array.length idst in
  let nf = Array.length idsf in
  let common,idst,idsf =
    if nt = nf then idst, <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>, <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>
    else
      if nt &lt; nf then idst,<abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>, Array.sub idsf nt (nf - nt)
      else idsf, Array.sub idst nf (nt - nf), <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr> in
  Llam(common,
       Lif(lam_lift (Array.length common) t,
           mkLlam idst bodyt,
           mkLlam idsf bodyf))


let rec simplify subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst

  | Llet(id,def,body) -&gt;
      let def' = simplify subst def in
      if can_subst def' then simplify (cons def' subst) body
      else
        let body' = simplify (lift subst) body in
        if def == def' &amp;&amp; body == body' then lam
        else Llet(id,def',body')

  | Lapp(f,args) -&gt;
      begin match simplify_app subst f subst args with
      | Lapp(f',args') when f == f' &amp;&amp; args == args' -&gt; lam
      | lam' -&gt; lam'
      end

  | Lif(t,bt,bf) -&gt;
      let t' = simplify subst t in
      let bt' = simplify subst bt in
      let bf' = simplify subst bf in
      if can_merge_if bt' bf' then merge_if t' bt' bf'
      else
        if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam
        else Lif(t',bt',bf')
  | _ -&gt; map_lam_with_binders liftn simplify subst lam

and simplify_app substf f substa args =
  match f with
  | Lrel(id, i) -&gt;
    begin match lam_subst_rel f id i substf with
      | Llam(ids, body) -&gt;
        reduce_lapp
          subst_id (Array.to_list ids) body
          substa (Array.to_list args)
      | f' -&gt; mkLapp f' (simplify_args substa args)
    end
  | Llam(ids, body) -&gt;
    reduce_lapp substf (Array.to_list ids) body substa (Array.to_list args)
  | Llet(id, def, body) -&gt;
    let def' = simplify substf def in
    if can_subst def' then
      simplify_app (cons def' substf) body substa args
    else
      Llet(id, def', simplify_app (lift substf) body (shift substa) args)
  | Lapp(f, args') -&gt;
    let args = Array.append
        (lam_subst_args substf args') (lam_subst_args substa args) in
    simplify_app substf f subst_id args
  | _ -&gt; mkLapp (simplify substf f) (simplify_args substa args)

and simplify_args subst args = Array.Smart.map (simplify subst) args

and reduce_lapp substf lids body substa largs =
  match lids, largs with
  | id::lids, a::largs -&gt;
    let a = simplify substa a in
    if can_subst a then
      reduce_lapp (cons a substf) lids body substa largs
    else
      let body = reduce_lapp (lift substf) lids body (shift substa) largs in
      Llet(id, a, body)
  | [], [] -&gt; simplify substf body
  | _::_, _ -&gt;
    Llam(Array.of_list lids, simplify (liftn (List.length lids) substf) body)
  | [], _ -&gt; simplify_app substf body substa (Array.of_list largs)




(* [occurrence kind k lam]:
   If [kind] is [true] return [true] if the variable [k] does not appear in
   [lam], return [false] if the variable appear one time and not
   under a lambda, a fixpoint, a cofixpoint; else raise Not_found.
   If [kind] is [false] return [false] if the variable does not appear in [lam]
   else raise [Not_found]
*)

let rec occurrence k kind lam =
  match lam with
  | Lrel (_,n) -&gt;
    if n = k then
      if kind then false else raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>
    else kind
  | Lvar _  | Lconst _  | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _ -&gt; kind
  | Levar (_, args) -&gt;
    occurrence_args k kind args
  | Lprod(dom, codom) -&gt;
    occurrence k (occurrence k kind dom) codom
  | Llam(ids,body) -&gt;
    let _ = occurrence (k+Array.length ids) false body in kind
  | Llet(_,def,body) -&gt;
    occurrence (k+1) (occurrence k kind def) body
  | Lapp(f, args) -&gt;
    occurrence_args k (occurrence k kind f) args
  | Lprim(_,_,args) | Lmakeblock(_,args) -&gt;
    occurrence_args k kind args
  | Lcase(_ci,_rtbl,t,a,branches) -&gt;
    let kind = occurrence k (occurrence k kind t) a in
    let r = ref kind in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (fun c -&gt; r := occurrence k kind c  &amp;&amp; !r) branches.constant_branches;
    let on_b (ids,c) =
      r := occurrence (k+Array.length ids) kind c &amp;&amp; !r
    in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter on_b branches.nonconstant_branches;
    !r</abbr>
  | Lif (t, bt, bf) -&gt;
      let kind = occurrence k kind t in
      kind &amp;&amp; occurrence k kind bt &amp;&amp; occurrence k kind bf
  | Lfix(_,(ids,ltypes,lbodies))
  | Lcofix(_,(ids,ltypes,lbodies)) -&gt;
    let kind = occurrence_args k kind ltypes in
    let _ = occurrence_args (k+Array.length ids) false lbodies in
    kind
  | Lproj(_,arg) -&gt;
    occurrence k kind arg

and occurrence_args k kind args =
  Array.fold_left (occurrence k) kind args

let occur_once lam =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try let _ = occurrence 1 true lam in true
  with Not_found -&gt; false</abbr>

(* [remove_let lam] remove let expression in [lam] if the variable is *)
(* used at most once time in the body, and does not appear under      *)
(* a lambda or a fix or a cofix                                       *)

let rec remove_let subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst
  | Llet(id,def,body) -&gt;
    let def' = remove_let subst def in
    if occur_once body then remove_let (cons def' subst) body
    else
      let body' = remove_let (lift subst) body in
      if def == def' &amp;&amp; body == body' then lam else Llet(id,def',body')
  | _ -&gt; map_lam_with_binders liftn remove_let subst lam


(*s Translation from [constr] to [lambda] *)

(* Translation of constructor *)

(* Limitation due to OCaml's representation of non-constant
  constructors: limited to 245 + 1 (0 tag) cases. *)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception TooLargeInductive of Pp.t</abbr>

let max_nb_const = 0x1000000
let max_nb_block = 0x1000000 + Obj.last_non_constant_constructor_tag - 1

let str_max_constructors =
  Format.sprintf
    &quot; which has more than %i constant constructors or more than %i non-constant constructors&quot; max_nb_const max_nb_block

let check_compilable ib =

  if not (ib.mind_nb_args &lt;= max_nb_block &amp;&amp; ib.mind_nb_constant &lt;= max_nb_const) then
    let msg =
      Pp.(str &quot;Cannot compile code for virtual machine as it uses inductive &quot;
          ++ Id.print ib.mind_typename ++ str str_max_constructors)
    in
    raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TooLargeInductive msg)</abbr>

let is_value lc =
  match lc with
  | Lval _ | Lint _ | Luint _ -&gt; true
  | _ -&gt; false

let get_value lc =
  match lc with
  | Luint i -&gt; val_of_uint i
  | Lval v -&gt; v
  | Lint i -&gt; val_of_int i
  | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

let make_args start _end =
  Array.init (start - _end + 1) (fun i -&gt; Lrel (Anonymous, start - i))

(* Translation of constructors *)
let expand_constructor tag nparams arity =
  let anon = Context.make_annot Anonymous Sorts.Relevant in (* TODO relevance *)
  let ids = Array.make (nparams + arity) anon in
  if arity = 0 then mkLlam ids (Lint tag)
  else
    let args = make_args arity 1 in
    Llam(ids, Lmakeblock (tag, args))

let makeblock tag nparams arity args =
  let nargs = Array.length args in
  if nparams &gt; 0 || nargs &lt; arity then
    mkLapp (expand_constructor tag nparams arity) args
  else
    (* The constructor is fully applied *)
  if arity = 0 then Lint tag
  else
  if Array.for_all is_value args then
    if tag &lt; Obj.last_non_constant_constructor_tag then
      Lval(val_of_block tag (Array.map get_value args))
    else
      let args = Array.map get_value args in
      let args = Array.append <abbr class="mark-warning" title="Arrays not handled.">[| val_of_int (tag - Obj.last_non_constant_constructor_tag) |]</abbr> args in
      Lval(val_of_block Obj.last_non_constant_constructor_tag args)
  else Lmakeblock(tag, args)


(* Compiling constants *)

let rec get_alias env kn =
  let cb = lookup_constant kn env in
  let tps = cb.const_body_code in
  match tps with
  | None -&gt; kn
  | Some tps -&gt;
    (match Cemitcodes.force tps with
     | Cemitcodes.BCalias kn' -&gt; get_alias env kn'
     | _ -&gt; kn)

(* Compilation of primitive *)

let prim kn p args =
  Lprim(Some kn, p, args)

let expand_prim kn op arity =
  (* primitives are always Relevant *)
  let ids = Array.make arity Context.anonR in
  let args = make_args arity 1 in
  Llam(ids, prim kn op args)

let lambda_of_prim kn op args =
  let arity = CPrimitives.arity op in
  if Array.length args &gt;= arity then prim kn op args
  else mkLapp (expand_prim kn op arity) args

(*i Global environment *)

let get_names decl =
  let decl = Array.of_list decl in
  Array.map fst decl


(* Rel Environment *)
module Vect =
struct
  type 'a t = {
    mutable elems : 'a array;
    mutable size : int;
  }

  let make n a = {
    elems = Array.make n a;
    size = 0;
  }

  let extend (v : 'a t) =
    if v.size = Array.length v.elems then
      let new_size = min (2*v.size) Sys.max_array_length in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if new_size &lt;= v.size then raise (Invalid_argument &quot;Vect.extend&quot;);
      let new_elems = Array.make new_size v.elems.(0) in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.blit v.elems 0 new_elems 0 (v.size);
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Set record field not handled.">v.elems &lt;- new_elems</abbr>

  let push v a =
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">extend v;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">v.elems.(v.size) &lt;- a;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Set record field not handled.">v.size &lt;- v.size + 1</abbr>

  let popn (v : 'a t) n =
    <abbr class="mark-warning" title="Set record field not handled.">v.size &lt;- max 0 (v.size - n)</abbr>

  let pop v = popn v 1

  let get_last (v : 'a t) n =
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if v.size &lt;= n then raise
        (Invalid_argument &quot;Vect.get:index out of bounds&quot;);
    v.elems.(v.size - n - 1)</abbr>

end

let dummy_lambda = Lrel(Anonymous, 0)

let empty_args = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

module Renv =
struct

  type constructor_info = tag * int * int (* nparam nrealargs *)

  type t = {
    global_env : env;
    name_rel : Name.t Vect.t;
    construct_tbl : (constructor, constructor_info) Hashtbl.t;
  }

  let make env = {
    global_env = env;
    name_rel = Vect.make 16 Anonymous;
    construct_tbl = Hashtbl.create 111
  }

  let push_rel env id = Vect.push env.name_rel id.Context.binder_name

  let push_rels env ids =
    Array.iter (push_rel env) ids

  let pop env = Vect.pop env.name_rel

  let popn env n =
    <abbr class="mark-warning" title="For loops not handled.">for _i = 1 to n do pop env done</abbr>

  let get env n =
    Lrel (Vect.get_last env.name_rel (n-1), n)

  let get_construct_info env c =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Hashtbl.find env.construct_tbl c
    with Not_found -&gt;
      let ((mind,j), i) = c in
      let oib = lookup_mind mind env.global_env in
      let oip = oib.mind_packets.(j) in
      check_compilable oip;
      let tag,arity = oip.mind_reloc_tbl.(i-1) in
      let nparams = oib.mind_nparams in
      let r = (tag, nparams, arity) in
      Hashtbl.add env.construct_tbl c r;
      r</abbr>
end

open Renv

let rec lambda_of_constr env c =
  match Constr.kind c with
  | Meta _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">(Invalid_argument &quot;Cbytegen.lambda_of_constr: Meta&quot;)</abbr>
  | Evar (evk, args) -&gt;
    let args = lambda_of_args env 0 args in
    Levar (evk, args)

  | Cast (c, _, _) -&gt; lambda_of_constr env c

  | Rel i -&gt; Renv.get env i

  | Var id -&gt; Lvar id

  | Sort s -&gt; Lsort s
  | Ind ind -&gt; Lind ind

  | Prod(id, dom, codom) -&gt;
    let ld = lambda_of_constr env dom in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.push_rel env id;
    let lc = lambda_of_constr env codom in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.pop env;
    Lprod(ld, Llam(</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|id|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">, lc))</abbr>

  | Lambda _ -&gt;
    let params, body = decompose_lam c in
    let ids = get_names (List.rev params) in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.push_rels env ids;
    let lb = lambda_of_constr env body in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.popn env (Array.length ids);
    mkLlam ids lb</abbr>

  | LetIn(id, def, _, body) -&gt;
    let ld = lambda_of_constr env def in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.push_rel env id;
    let lb = lambda_of_constr env body in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.pop env;
    Llet(id, ld, lb)</abbr>

  | App(f, args) -&gt; lambda_of_app env f args

  | Const _ -&gt; lambda_of_app env c empty_args

  | Construct _ -&gt;  lambda_of_app env c empty_args

  | Case(ci,t,a,branches) -&gt;
    let ind = ci.ci_ind in
    let mib = lookup_mind (fst ind) env.global_env in
    let oib = mib.mind_packets.(snd ind) in
    let () = check_compilable oib in
    let rtbl = oib.mind_reloc_tbl in


    (* translation of the argument *)
    let la = lambda_of_constr env a in
    (* translation of the type *)
    let lt = lambda_of_constr env t in
    (* translation of branches *)
    let consts = Array.make oib.mind_nb_constant dummy_lambda in
    let blocks = Array.make oib.mind_nb_args (<abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>,dummy_lambda) in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to Array.length rtbl - 1 do
      let tag, arity = rtbl.(i) in
      let b = lambda_of_constr env branches.(i) in
      if arity = 0 then consts.(tag) &lt;- b
      else
        let b =
          match b with
          | Llam(ids, body) when Array.length ids = arity -&gt; (ids, body)
          | _ -&gt;
            let anon = Context.make_annot Anonymous Sorts.Relevant in (* TODO relevance *)
            let ids = Array.make arity anon in
            let args = make_args arity 1 in
            let ll = lam_lift arity b in
            (ids, mkLapp  ll args)
        in blocks.(tag-1) &lt;- b
    done;
    let branches =
      { constant_branches = consts;
        nonconstant_branches = blocks }
    in
    Lcase(ci, rtbl, lt, la, branches)</abbr>

  | Fix(rec_init,(names,type_bodies,rec_bodies)) -&gt;
    let ltypes = lambda_of_args env 0 type_bodies in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.push_rels env names;
    let lbodies = lambda_of_args env 0 rec_bodies in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.popn env (Array.length names);
    Lfix(rec_init, (names, ltypes, lbodies))</abbr>

  | CoFix(init,(names,type_bodies,rec_bodies)) -&gt;
    let rec_bodies = Array.map2 (Reduction.eta_expand env.global_env) rec_bodies type_bodies in
    let ltypes = lambda_of_args env 0 type_bodies in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.push_rels env names;
    let lbodies = lambda_of_args env 0 rec_bodies in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.popn env (Array.length names);
    Lcofix(init, (names, ltypes, lbodies))</abbr>

  | Proj (p,c) -&gt;
    let lc = lambda_of_constr env c in
    Lproj (Projection.repr p,lc)

  | Int i -&gt; Luint i

and lambda_of_app env f args =
  match Constr.kind f with
  | Const (kn,u as c) -&gt;
      let kn = get_alias env.global_env kn in
      let cb = lookup_constant kn env.global_env in
      begin match cb.const_body with
      | Primitive op -&gt; lambda_of_prim (kn,u) op (lambda_of_args env 0 args)
      | Def csubst when cb.const_inline_code -&gt;
          lambda_of_app env (Mod_subst.force_constr csubst) args
      | Def _ | OpaqueDef _ | Undef _ -&gt; mkLapp (Lconst c) (lambda_of_args env 0 args)
      end
  | Construct (c,_) -&gt;
      let tag, nparams, arity = Renv.get_construct_info env c in
      let nargs = Array.length args in
      if nparams &lt; nargs then (* got all parameters *)
        let args = lambda_of_args env nparams args in
        makeblock tag 0 arity args
      else makeblock tag (nparams - nargs) arity empty_args
  | _ -&gt;
      let f = lambda_of_constr env f in
      let args = lambda_of_args env 0 args in
      mkLapp f args

and lambda_of_args env start args =
  let nargs = Array.length args in
  if start &lt; nargs then
    Array.init (nargs - start)
      (fun i -&gt; lambda_of_constr env args.(start + i))
  else empty_args




(*********************************)
let dump_lambda = ref false

let optimize_lambda lam =
  let lam = simplify subst_id lam in
  remove_let subst_id lam

let lambda_of_constr ~optimize genv c =
  let env = Renv.make genv in
  let ids = List.rev_map Context.Rel.Declaration.get_annot (rel_context genv) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Renv.push_rels env (Array.of_list ids);
  let lam = lambda_of_constr env c in
  let lam = if optimize then optimize_lambda lam else lam in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !dump_lambda then
    Feedback.msg_debug (pp_lam lam);
  lam</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#clambda.ml"><code>Clambda.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Esubst.

Import Term.

Import Constr.

Import Declarations.

Import Vmvalues.

Import Environ.

Import Pp.

Definition pr_con (sp : Names.Constant.t) : Pp.t :=
  str (Names.Label.to_string (Constant.label sp)).

Reserved Notation &quot;'lam_branches&quot;.
Reserved Notation &quot;'fix_decl&quot;.

Module lam_branches.
  Record record {constant_branches nonconstant_branches : Set} := {
    constant_branches : constant_branches;
    nonconstant_branches : nonconstant_branches }.
  Arguments record : clear implicits.
  Definition with_constant_branches
    {constant_branches_type nonconstant_branches_type : Set}
    (r : record constant_branches_type nonconstant_branches_type)
    constant_branches
    : record constant_branches_type nonconstant_branches_type :=
    {| constant_branches := constant_branches;
      nonconstant_branches := nonconstant_branches r |}.
  Definition with_nonconstant_branches
    {constant_branches_type nonconstant_branches_type : Set}
    (r : record constant_branches_type nonconstant_branches_type)
    nonconstant_branches
    : record constant_branches_type nonconstant_branches_type :=
    {| constant_branches := constant_branches r;
      nonconstant_branches := nonconstant_branches |}.
End lam_branches.
Definition lam_branches_skeleton := lam_branches.record.

Inductive lambda : Set :=
| Lrel : Names.Name.t -&gt; Z -&gt; lambda
| Lvar : Names.Id.t -&gt; lambda
| Levar : Evar.t -&gt; array lambda -&gt; lambda
| Lprod : lambda -&gt; lambda -&gt; lambda
| Llam : array (Context.binder_annot Names.Name.t) -&gt; lambda -&gt; lambda
| Llet : Context.binder_annot Names.Name.t -&gt; lambda -&gt; lambda -&gt; lambda
| Lapp : lambda -&gt; array lambda -&gt; lambda
| Lconst : Constr.pconstant -&gt; lambda
| Lprim : option Constr.pconstant -&gt; CPrimitives.t -&gt; array lambda -&gt; lambda
| Lcase :
  Constr.case_info -&gt; Vmvalues.reloc_table -&gt; lambda -&gt; lambda -&gt;
  'lam_branches -&gt; lambda
| Lif : lambda -&gt; lambda -&gt; lambda -&gt; lambda
| Lfix : array Z * Z -&gt; 'fix_decl -&gt; lambda
| Lcofix : Z -&gt; 'fix_decl -&gt; lambda
| Lint : Z -&gt; lambda
| Lmakeblock : Z -&gt; array lambda -&gt; lambda
| Luint : Uint63.t -&gt; lambda
| Lval : Vmvalues.structured_values -&gt; lambda
| Lsort : Sorts.t -&gt; lambda
| Lind : Constr.pinductive -&gt; lambda
| Lproj : Names.Projection.Repr.t -&gt; lambda -&gt; lambda

where &quot;'lam_branches&quot; :=
  (lam_branches_skeleton (array lambda)
    (array (array (Context.binder_annot Names.Name.t) * lambda)))
and &quot;'fix_decl&quot; :=
  (array (Context.binder_annot Names.Name.t) * array lambda * array lambda).

Definition lam_branches := 'lam_branches.
Definition fix_decl := 'fix_decl.

Definition pr_annot (x : Context.binder_annot Names.Name.t) : Pp.t :=
  Name.print (Context.binder_annot.binder_name x).

Definition pp_names (ids : array (Context.binder_annot Names.Name.t)) : Pp.t :=
  prlist_with_sep
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      brk (1, 1)) pr_annot ((|Util.Array|).(CArray.ExtS.to_list) ids).

Definition pp_rel (name : Names.Name.t) (n : Z) : Pp.t :=
  op_plusplus (op_plusplus (Name.print name) (str &quot;##&quot;)) (int n).

Definition pp_sort (s : Sorts.t) : Pp.t :=
  match Sorts.family s with
  | Term.InSet =&gt; str &quot;Set&quot;
  | Term.InProp =&gt; str &quot;Prop&quot;
  | Term.InSProp =&gt; str &quot;SProp&quot;
  | Term.InType =&gt; str &quot;Type&quot;
  end.

Fixpoint pp_lam (lam : lambda) {struct lam} : Pp.t :=
  match lam with
  | Lrel id n =&gt; pp_rel id n
  | Lvar id =&gt; Id.print id
  | Levar evk args =&gt;
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus (op_plusplus (str &quot;evar(&quot;) (Evar.print evk)) (str &quot;,&quot;))
            (spc tt))
          (prlist_with_sep spc pp_lam
            ((|Util.Array|).(CArray.ExtS.to_list) args))) (str &quot;)&quot;))
  | Lprod dom codom =&gt;
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus (op_plusplus (str &quot;forall(&quot;) (pp_lam dom)) (str &quot;,&quot;))
            (spc tt)) (pp_lam codom)) (str &quot;)&quot;))
  | Llam ids body =&gt;
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus (op_plusplus (str &quot;(fun &quot;) (pp_names ids)) (str &quot; =&gt;&quot;))
            (spc tt)) (pp_lam body)) (str &quot;)&quot;))
  | Llet id def body =&gt;
    hov 0
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus (op_plusplus (str &quot;let &quot;) (pr_annot id)) (str &quot;:=&quot;))
              (pp_lam def)) (str &quot; in&quot;)) (spc tt)) (pp_lam body))
  | Lapp f args =&gt;
    hov 1
      (op_plusplus
        (op_plusplus (op_plusplus (op_plusplus (str &quot;(&quot;) (pp_lam f)) (spc tt))
          (prlist_with_sep spc pp_lam
            ((|Util.Array|).(CArray.ExtS.to_list) args))) (str &quot;)&quot;))
  | Lconst (kn, _) =&gt; pr_con kn
  | Lcase _ci _rtbl t a branches =&gt;
    let ic := Stdlib.__ref_value (-1) in
    let ib := Stdlib.__ref_value 0 in
    v 0
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus
                (op_plusplus
                  (op_plusplus
                    (op_plusplus
                      (op_plusplus
                        (op_plusplus
                          (op_plusplus (op_plusplus (str &quot;&lt;&quot;) (pp_lam t))
                            (str &quot;&gt;&quot;)) (cut tt)) (str &quot;Case&quot;)) (spc tt))
                    (pp_lam a)) (spc tt)) (str &quot;of&quot;)) (cut tt))
            (v 0
              (op_plusplus
                (prlist_with_sep
                  (fun function_parameter =&gt;
                    let '_ := function_parameter in
                    str &quot;&quot;)
                  (fun c =&gt;
                    op_plusplus
                      (op_plusplus
                        (op_plusplus (op_plusplus (cut tt) (str &quot;| &quot;))
                          (int
                            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
                            (* ❌ instruction_sequence &quot;;&quot; *)
                            (Stdlib.op_exclamation ic))) (str &quot; =&gt; &quot;))
                      (pp_lam c))
                  ((|Util.Array|).(CArray.ExtS.to_list)
                    (lam_branches.constant_branches branches)))
                (prlist_with_sep
                  (fun function_parameter =&gt;
                    let '_ := function_parameter in
                    str &quot;&quot;)
                  (fun function_parameter =&gt;
                    let '(ids, c) := function_parameter in
                    op_plusplus
                      (op_plusplus
                        (op_plusplus
                          (op_plusplus
                            (op_plusplus (op_plusplus (cut tt) (str &quot;| &quot;))
                              (int
                                (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
                                (* ❌ instruction_sequence &quot;;&quot; *)
                                (Stdlib.op_exclamation ib))) (str &quot; &quot;))
                          (pp_names ids)) (str &quot; =&gt; &quot;)) (pp_lam c))
                  ((|Util.Array|).(CArray.ExtS.to_list)
                    (lam_branches.nonconstant_branches branches)))))) (cut tt))
        (str &quot;end&quot;))
  | Lif t bt bf =&gt;
    v 0
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus
                (op_plusplus
                  (op_plusplus (op_plusplus (str &quot;(if &quot;) (pp_lam t)) (cut tt))
                  (str &quot;then &quot;)) (pp_lam bt)) (cut tt)) (str &quot;else &quot;))
          (pp_lam bf)) (str &quot;)&quot;))
  | Lfix (t, i) (lna, tl, bl) =&gt;
    let fixl :=
      (|Util.Array|).(CArray.ExtS.mapi)
        (fun i =&gt;
          fun id =&gt;
            (id, ((|Util.Array|).(CArray.ExtS.get) t i),
              ((|Util.Array|).(CArray.ExtS.get) tl i),
              ((|Util.Array|).(CArray.ExtS.get) bl i))) lna in
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus (op_plusplus (op_plusplus (str &quot;fix &quot;) (int i)) (spc tt))
            (str &quot;{&quot;))
          (v 0
            (prlist_with_sep spc
              (fun function_parameter =&gt;
                let '(na, i, ty, bd) := function_parameter in
                op_plusplus
                  (op_plusplus
                    (op_plusplus
                      (op_plusplus
                        (op_plusplus
                          (op_plusplus (op_plusplus (pr_annot na) (str &quot;/&quot;))
                            (int i)) (str &quot;:&quot;)) (pp_lam ty)) (cut tt))
                    (str &quot;:=&quot;)) (pp_lam bd))
              ((|Util.Array|).(CArray.ExtS.to_list) fixl)))) (str &quot;}&quot;))
  | Lcofix i (lna, tl, bl) =&gt;
    let fixl :=
      (|Util.Array|).(CArray.ExtS.mapi)
        (fun i =&gt;
          fun na =&gt;
            (na, ((|Util.Array|).(CArray.ExtS.get) tl i),
              ((|Util.Array|).(CArray.ExtS.get) bl i))) lna in
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus (op_plusplus (str &quot;cofix &quot;) (int i)) (spc tt))
            (str &quot;{&quot;))
          (v 0
            (prlist_with_sep spc
              (fun function_parameter =&gt;
                let '(na, ty, bd) := function_parameter in
                op_plusplus
                  (op_plusplus
                    (op_plusplus
                      (op_plusplus (op_plusplus (pr_annot na) (str &quot;:&quot;))
                        (pp_lam ty)) (cut tt)) (str &quot;:=&quot;)) (pp_lam bd))
              ((|Util.Array|).(CArray.ExtS.to_list) fixl)))) (str &quot;}&quot;))
  | Lmakeblock tag args =&gt;
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus (op_plusplus (str &quot;(makeblock &quot;) (int tag)) (spc tt))
          (prlist_with_sep spc pp_lam
            ((|Util.Array|).(CArray.ExtS.to_list) args))) (str &quot;)&quot;))
  | Luint i =&gt; str (Uint63.to_string i)
  | Lval _ =&gt; str &quot;values&quot;
  | Lsort s =&gt; pp_sort s
  | Lind ((mind, i), _) =&gt;
    op_plusplus (op_plusplus (MutInd.print mind) (str &quot;#&quot;)) (int i)
  | Lprim (Some (kn, _u)) _op args =&gt;
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus (op_plusplus (str &quot;(PRIM &quot;) (pr_con kn)) (spc tt))
          (prlist_with_sep spc pp_lam
            ((|Util.Array|).(CArray.ExtS.to_list) args))) (str &quot;)&quot;))
  | Lprim None op args =&gt;
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus (str &quot;(PRIM_NC &quot;) (str (CPrimitives.to_string op)))
            (spc tt))
          (prlist_with_sep spc pp_lam
            ((|Util.Array|).(CArray.ExtS.to_list) args))) (str &quot;)&quot;))
  | Lproj p arg =&gt;
    hov 1
      (op_plusplus
        (op_plusplus
          (op_plusplus (op_plusplus (str &quot;(proj &quot;) (Projection.Repr.print p))
            (str &quot;(&quot;)) (pp_lam arg)) (str &quot;)&quot;))
  | Lint i =&gt; op_plusplus (op_plusplus (str &quot;(int:&quot;) (int i)) (str &quot;)&quot;)
  end.

Definition mkLapp (f : lambda) (args : array lambda) : lambda :=
  if equiv_decb ((|Util.Array|).(CArray.ExtS.length) args) 0 then
    f
  else
    match f with
    | Lapp f' args' =&gt; Lapp f' ((|Util.Array|).(CArray.ExtS.append) args' args)
    | _ =&gt; Lapp f args
    end.

Definition mkLlam
  (ids : array (Context.binder_annot Names.Name.t)) (body : lambda) : lambda :=
  if equiv_decb ((|Util.Array|).(CArray.ExtS.length) ids) 0 then
    body
  else
    match body with
    | Llam ids' body =&gt; Llam ((|Util.Array|).(CArray.ExtS.append) ids ids') body
    | _ =&gt; Llam ids body
    end.

Definition decompose_Llam (lam : lambda)
  : array (Context.binder_annot Names.Name.t) * lambda :=
  match lam with
  | Llam ids body =&gt; (ids, body)
  | _ =&gt;
    ((* ❌ Arrays not handled. *)
    [ ], lam)
  end.

Definition subst_id : Esubst.subs lambda := subs_id 0.

Definition lift {A : Set} : Esubst.subs A -&gt; Esubst.subs A := subs_lift.

Definition liftn {A : Set} : Z -&gt; Esubst.subs A -&gt; Esubst.subs A := subs_liftn.

Definition cons {A : Set} (v : A) (subst : Esubst.subs A) : Esubst.subs A :=
  subs_cons
    ((* ❌ Arrays not handled. *)
    [ v ], subst).

Definition shift {A : Set} (subst : Esubst.subs A) : Esubst.subs A :=
  subs_shft (1, subst).

Definition map_lam_with_binders {A : Set}
  (g : Z -&gt; A -&gt; A) (f : A -&gt; lambda -&gt; lambda) (n : A) (lam : lambda)
  : lambda :=
  match lam with
  | Lrel _ _ | Lvar _ | Lconst _ | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _
    =&gt; lam
  | Levar evk args =&gt;
    let args' := Array.Smart.map (f n) args in
    if Stdlib.op_eqeq args args' then
      lam
    else
      Levar evk args'
  | Lprod dom codom =&gt;
    let dom' := f n dom in
    let codom' := f n codom in
    if andb (Stdlib.op_eqeq dom dom') (Stdlib.op_eqeq codom codom') then
      lam
    else
      Lprod dom' codom'
  | Llam ids body =&gt;
    let body' := f (g ((|Util.Array|).(CArray.ExtS.length) ids) n) body in
    if Stdlib.op_eqeq body body' then
      lam
    else
      mkLlam ids body'
  | Llet id def body =&gt;
    let def' := f n def in
    let body' := f (g 1 n) body in
    if andb (Stdlib.op_eqeq body body') (Stdlib.op_eqeq def def') then
      lam
    else
      Llet id def' body'
  | Lapp fct args =&gt;
    let fct' := f n fct in
    let args' := Array.Smart.map (f n) args in
    if andb (Stdlib.op_eqeq fct fct') (Stdlib.op_eqeq args args') then
      lam
    else
      mkLapp fct' args'
  | Lcase ci rtbl t a branches =&gt;
    let const := lam_branches.constant_branches branches in
    let nonconst := lam_branches.nonconstant_branches branches in
    let t' := f n t in
    let a' := f n a in
    let const' := Array.Smart.map (f n) const in
    let on_b {B : Set} (b : array B * lambda) : array B * lambda :=
      let '(ids, body) := b in
      let body' := f (g ((|Util.Array|).(CArray.ExtS.length) ids) n) body in
      if Stdlib.op_eqeq body body' then
        b
      else
        (ids, body') in
    let nonconst' := Array.Smart.map on_b nonconst in
    let branches' :=
      if andb (Stdlib.op_eqeq const const') (Stdlib.op_eqeq nonconst nonconst')
        then
        branches
      else
        {| lam_branches.constant_branches := const';
          lam_branches.nonconstant_branches := nonconst' |} in
    if
      andb (Stdlib.op_eqeq t t')
        (andb (Stdlib.op_eqeq a a') (Stdlib.op_eqeq branches branches')) then
      lam
    else
      Lcase ci rtbl t' a' branches'
  | Lif t bt bf =&gt;
    let t' := f n t in
    let bt' := f n bt in
    let bf' := f n bf in
    if
      andb (Stdlib.op_eqeq t t')
        (andb (Stdlib.op_eqeq bt bt') (Stdlib.op_eqeq bf bf')) then
      lam
    else
      Lif t' bt' bf'
  | Lfix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Array.Smart.map (f (g ((|Util.Array|).(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eqeq ltypes ltypes') (Stdlib.op_eqeq lbodies lbodies')
      then
      lam
    else
      Lfix init (ids, ltypes', lbodies')
  | Lcofix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Array.Smart.map (f (g ((|Util.Array|).(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eqeq ltypes ltypes') (Stdlib.op_eqeq lbodies lbodies')
      then
      lam
    else
      Lcofix init (ids, ltypes', lbodies')
  | Lmakeblock tag args =&gt;
    let args' := Array.Smart.map (f n) args in
    if Stdlib.op_eqeq args args' then
      lam
    else
      Lmakeblock tag args'
  | Lprim kn op args =&gt;
    let args' := Array.Smart.map (f n) args in
    if Stdlib.op_eqeq args args' then
      lam
    else
      Lprim kn op args'
  | Lproj p arg =&gt;
    let arg' := f n arg in
    if Stdlib.op_eqeq arg arg' then
      lam
    else
      Lproj p arg'
  end.

Fixpoint lam_exlift (el : Esubst.lift) (lam : lambda) {struct el} : lambda :=
  match lam with
  | Lrel id i =&gt;
    let i' := reloc_rel i el in
    if Stdlib.op_eqeq i i' then
      lam
    else
      Lrel id i'
  | _ =&gt; map_lam_with_binders el_liftn lam_exlift el lam
  end.

Definition lam_lift (k : Z) (lam : lambda) : lambda :=
  if equiv_decb k 0 then
    lam
  else
    lam_exlift (el_shft k el_id) lam.

Definition lam_subst_rel
  (lam : lambda) (id : Names.Name.t) (n : Z) (subst : Esubst.subs lambda)
  : lambda :=
  match expand_rel n subst with
  | Util.Inl (k, v) =&gt; lam_lift k v
  | Util.Inr (n', _) =&gt;
    if Stdlib.op_eqeq n n' then
      lam
    else
      Lrel id n'
  end.

Fixpoint lam_exsubst (subst : Esubst.subs lambda) (lam : lambda) {struct subst}
  : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | _ =&gt; map_lam_with_binders liftn lam_exsubst subst lam
  end.

Definition lam_subst_args (subst : Esubst.subs lambda) (args : array lambda)
  : array lambda :=
  if is_subs_id subst then
    args
  else
    Array.Smart.map (lam_exsubst subst) args.

Definition can_subst (lam : lambda) : bool :=
  match lam with
  | Lrel _ _ | Lvar _ | Lconst _ | Luint _ | Lval _ | Lsort _ | Lind _ =&gt; true
  | _ =&gt; false
  end.

Definition can_merge_if (bt : lambda) (bf : lambda) : bool :=
  match (bt, bf) with
  | (Llam _idst _, Llam _idsf _) =&gt; true
  | _ =&gt; false
  end.

Definition merge_if (t : lambda) (bt : lambda) (bf : lambda) : lambda :=
  let '(idst, bodyt) := decompose_Llam bt in
  let '(idsf, bodyf) := decompose_Llam bf in
  let nt := (|Util.Array|).(CArray.ExtS.length) idst in
  let nf := (|Util.Array|).(CArray.ExtS.length) idsf in
  let '(common, idst, idsf) :=
    if equiv_decb nt nf then
      (idst,
        (* ❌ Arrays not handled. *)
        [ ],
        (* ❌ Arrays not handled. *)
        [ ])
    else
      if OCaml.Stdlib.lt nt nf then
        (idst,
          (* ❌ Arrays not handled. *)
          [ ], ((|Util.Array|).(CArray.ExtS.sub) idsf nt (Z.sub nf nt)))
      else
        (idsf, ((|Util.Array|).(CArray.ExtS.sub) idst nf (Z.sub nt nf)),
          (* ❌ Arrays not handled. *)
          [ ]) in
  Llam common
    (Lif (lam_lift ((|Util.Array|).(CArray.ExtS.length) common) t)
      (mkLlam idst bodyt) (mkLlam idsf bodyf)).

Fixpoint simplify (subst : Esubst.subs lambda) (lam : lambda) {struct subst}
  : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | Llet id def body =&gt;
    let def' := simplify subst def in
    if can_subst def' then
      simplify (cons def' subst) body
    else
      let body' := simplify (lift subst) body in
      if andb (Stdlib.op_eqeq def def') (Stdlib.op_eqeq body body') then
        lam
      else
        Llet id def' body'
  | Lapp f args =&gt;
    match
      ((simplify_app subst f subst args),
        match simplify_app subst f subst args with
        | Lapp f' args' =&gt;
          andb (Stdlib.op_eqeq f f') (Stdlib.op_eqeq args args')
        | _ =&gt; false
        end) with
    | (Lapp f' args', true) =&gt; lam
    | (lam', _) =&gt; lam'
    end
  | Lif t bt bf =&gt;
    let t' := simplify subst t in
    let bt' := simplify subst bt in
    let bf' := simplify subst bf in
    if can_merge_if bt' bf' then
      merge_if t' bt' bf'
    else
      if
        andb (Stdlib.op_eqeq t t')
          (andb (Stdlib.op_eqeq bt bt') (Stdlib.op_eqeq bf bf')) then
        lam
      else
        Lif t' bt' bf'
  | _ =&gt; map_lam_with_binders liftn simplify subst lam
  end

with simplify_app
  (substf : Esubst.subs lambda) (f : lambda) (substa : Esubst.subs lambda)
  (args : array lambda) {struct substf} : lambda :=
  match f with
  | Lrel id i =&gt;
    match lam_subst_rel f id i substf with
    | Llam ids body =&gt;
      reduce_lapp subst_id ((|Util.Array|).(CArray.ExtS.to_list) ids) body
        substa ((|Util.Array|).(CArray.ExtS.to_list) args)
    | f' =&gt; mkLapp f' (simplify_args substa args)
    end
  | Llam ids body =&gt;
    reduce_lapp substf ((|Util.Array|).(CArray.ExtS.to_list) ids) body substa
      ((|Util.Array|).(CArray.ExtS.to_list) args)
  | Llet id def body =&gt;
    let def' := simplify substf def in
    if can_subst def' then
      simplify_app (cons def' substf) body substa args
    else
      Llet id def' (simplify_app (lift substf) body (shift substa) args)
  | Lapp f args' =&gt;
    let args :=
      (|Util.Array|).(CArray.ExtS.append) (lam_subst_args substf args')
        (lam_subst_args substa args) in
    simplify_app substf f subst_id args
  | _ =&gt; mkLapp (simplify substf f) (simplify_args substa args)
  end

with simplify_args (subst : Esubst.subs lambda) (args : array lambda)
  {struct subst} : array lambda := Array.Smart.map (simplify subst) args

with reduce_lapp
  (substf : Esubst.subs lambda)
  (lids : list (Context.binder_annot Names.Name.t)) (body : lambda)
  (substa : Esubst.subs lambda) (largs : list lambda) {struct substf}
  : lambda :=
  match (lids, largs) with
  | (cons id lids, cons a largs) =&gt;
    let a := simplify substa a in
    if can_subst a then
      reduce_lapp (cons a substf) lids body substa largs
    else
      let body := reduce_lapp (lift substf) lids body (shift substa) largs in
      Llet id a body
  | ([], []) =&gt; simplify substf body
  | (cons _ _, _) =&gt;
    Llam ((|Util.Array|).(CArray.ExtS.of_list) lids)
      (simplify (liftn ((|Util.List|).(CList.ExtS.length) lids) substf) body)
  | ([], _) =&gt;
    simplify_app substf body substa ((|Util.Array|).(CArray.ExtS.of_list) largs)
  end.

Fixpoint occurrence (k : Z) (kind : bool) (lam : lambda) {struct k} : bool :=
  match lam with
  | Lrel _ n =&gt;
    if equiv_decb n k then
      if kind then
        false
      else
        Stdlib.raise extensible_type_value
    else
      kind
  | Lvar _ | Lconst _ | Lval _ | Lsort _ | Lind _ | Lint _ | Luint _ =&gt; kind
  | Levar _ args =&gt; occurrence_args k kind args
  | Lprod dom codom =&gt; occurrence k (occurrence k kind dom) codom
  | Llam ids body =&gt;
    let '_ :=
      occurrence (Z.add k ((|Util.Array|).(CArray.ExtS.length) ids)) false body
      in
    kind
  | Llet _ def body =&gt; occurrence (Z.add k 1) (occurrence k kind def) body
  | Lapp f args =&gt; occurrence_args k (occurrence k kind f) args
  | Lprim _ _ args | Lmakeblock _ args =&gt; occurrence_args k kind args
  | Lcase _ci _rtbl t a branches =&gt;
    let kind := occurrence k (occurrence k kind t) a in
    let r := Stdlib.__ref_value kind in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let on_b {A : Set} (function_parameter : array A * lambda) : unit :=
      let '(ids, c) := function_parameter in
      Stdlib.op_coloneq r
        (andb
          (occurrence (Z.add k ((|Util.Array|).(CArray.ExtS.length) ids)) kind c)
          (Stdlib.op_exclamation r)) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.op_exclamation r
  | Lif t bt bf =&gt;
    let kind := occurrence k kind t in
    andb kind (andb (occurrence k kind bt) (occurrence k kind bf))
  | Lfix _ (ids, ltypes, lbodies) | Lcofix _ (ids, ltypes, lbodies) =&gt;
    let kind := occurrence_args k kind ltypes in
    let '_ :=
      occurrence_args (Z.add k ((|Util.Array|).(CArray.ExtS.length) ids)) false
        lbodies in
    kind
  | Lproj _ arg =&gt; occurrence k kind arg
  end

with occurrence_args (k : Z) (kind : bool) (args : array lambda) {struct k}
  : bool := (|Util.Array|).(CArray.ExtS.fold_left) (occurrence k) kind args.

Definition occur_once (lam : lambda) : bool :=
  (* ❌ Try-with are not handled *)
  try
    (let '_ := occurrence 1 true lam in
    true).

Fixpoint remove_let (subst : Esubst.subs lambda) (lam : lambda) {struct subst}
  : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | Llet id def body =&gt;
    let def' := remove_let subst def in
    if occur_once body then
      remove_let (cons def' subst) body
    else
      let body' := remove_let (lift subst) body in
      if andb (Stdlib.op_eqeq def def') (Stdlib.op_eqeq body body') then
        lam
      else
        Llet id def' body'
  | _ =&gt; map_lam_with_binders liftn remove_let subst lam
  end.

(* ❌ The definition of exceptions is not handled. *)
(* exception TooLargeInductive *)

Definition max_nb_const : Z := 16777216.

Definition max_nb_block : Z :=
  Z.sub (Z.add 16777216 Obj.last_non_constant_constructor_tag) 1.

Definition str_max_constructors : string :=
  Format.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot; which has more than &quot;
        (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          (CamlinternalFormatBasics.String_literal
            &quot; constant constructors or more than &quot;
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              (CamlinternalFormatBasics.String_literal
                &quot; non-constant constructors&quot;
                CamlinternalFormatBasics.End_of_format)))))
      &quot; which has more than %i constant constructors or more than %i non-constant constructors&quot;)
    max_nb_const max_nb_block.

Definition check_compilable (ib : Declarations.one_inductive_body) : unit :=
  if
    negb
      (andb
        (OCaml.Stdlib.le (Declarations.one_inductive_body.mind_nb_args ib)
          max_nb_block)
        (OCaml.Stdlib.le (Declarations.one_inductive_body.mind_nb_constant ib)
          max_nb_const)) then
    let msg :=
      op_plusplus
        (op_plusplus
          (str &quot;Cannot compile code for virtual machine as it uses inductive &quot;)
          (Id.print (Declarations.one_inductive_body.mind_typename ib)))
        (str str_max_constructors) in
    Stdlib.raise extensible_type_value
  else
    tt.

Definition is_value (lc : lambda) : bool :=
  match lc with
  | Lval _ | Lint _ | Luint _ =&gt; true
  | _ =&gt; false
  end.

Definition get_value (lc : lambda) : Vmvalues.structured_values :=
  match lc with
  | Luint i =&gt; val_of_uint i
  | Lval v =&gt; v
  | Lint i =&gt; val_of_int i
  | _ =&gt; Stdlib.raise extensible_type_value
  end.

Definition make_args (start : Z) (_end : Z) : array lambda :=
  (|Util.Array|).(CArray.ExtS.init) (Z.add (Z.sub start _end) 1)
    (fun i =&gt; Lrel Names.Anonymous (Z.sub start i)).

Definition expand_constructor (tag : Z) (nparams : Z) (arity : Z) : lambda :=
  let anon := Context.make_annot Names.Anonymous Sorts.Relevant in
  let ids := (|Util.Array|).(CArray.ExtS.make) (Z.add nparams arity) anon in
  if equiv_decb arity 0 then
    mkLlam ids (Lint tag)
  else
    let args := make_args arity 1 in
    Llam ids (Lmakeblock tag args).

Definition makeblock
  (tag : Vmvalues.tag) (nparams : Z) (arity : Z) (args : array lambda)
  : lambda :=
  let nargs := (|Util.Array|).(CArray.ExtS.length) args in
  if orb (OCaml.Stdlib.gt nparams 0) (OCaml.Stdlib.lt nargs arity) then
    mkLapp (expand_constructor tag nparams arity) args
  else
    if equiv_decb arity 0 then
      Lint tag
    else
      if (|Util.Array|).(CArray.ExtS.for_all) is_value args then
        if OCaml.Stdlib.lt tag Obj.last_non_constant_constructor_tag then
          Lval
            (val_of_block tag ((|Util.Array|).(CArray.ExtS.map) get_value args))
        else
          let args := (|Util.Array|).(CArray.ExtS.map) get_value args in
          let args :=
            (|Util.Array|).(CArray.ExtS.append)
              (* ❌ Arrays not handled. *)
              [ val_of_int (Z.sub tag Obj.last_non_constant_constructor_tag) ]
              args in
          Lval (val_of_block Obj.last_non_constant_constructor_tag args)
      else
        Lmakeblock tag args.

Fixpoint get_alias (env : Environ.env) (kn : Names.Constant.t) {struct env}
  : Names.Constant.t :=
  let cb := lookup_constant kn env in
  let tps := Declarations.constant_body.const_body_code cb in
  match tps with
  | None =&gt; kn
  | Some tps =&gt;
    match Cemitcodes.force tps with
    | Cemitcodes.BCalias kn' =&gt; get_alias env kn'
    | _ =&gt; kn
    end
  end.

Definition prim
  (kn : Constr.pconstant) (p : CPrimitives.t) (args : array lambda) : lambda :=
  Lprim (Some kn) p args.

Definition expand_prim (kn : Constr.pconstant) (op : CPrimitives.t) (arity : Z)
  : lambda :=
  let ids := (|Util.Array|).(CArray.ExtS.make) arity Context.anonR in
  let args := make_args arity 1 in
  Llam ids (prim kn op args).

Definition lambda_of_prim
  (kn : Constr.pconstant) (op : CPrimitives.t) (args : array lambda) : lambda :=
  let arity := CPrimitives.arity op in
  if OCaml.Stdlib.ge ((|Util.Array|).(CArray.ExtS.length) args) arity then
    prim kn op args
  else
    mkLapp (expand_prim kn op arity) args.

Definition get_names {A B : Set} (decl : list (A * B)) : array A :=
  let decl := (|Util.Array|).(CArray.ExtS.of_list) decl in
  (|Util.Array|).(CArray.ExtS.map) fst decl.

Module Vect.
  Module t.
    Record record {a : Set} := {
      elems : array a;
      size : Z }.
    Arguments record : clear implicits.
    Definition with_elems {a_type : Set} (r : record a_type) elems
      : record a_type :=
      {| elems := elems; size := size r |}.
    Definition with_size {a_type : Set} (r : record a_type) size
      : record a_type :=
      {| elems := elems r; size := size |}.
  End t.
  Definition t := t.record.
  
  Definition make {A : Set} (n : Z) (a : A) : t A :=
    {| t.elems := (|Util.Array|).(CArray.ExtS.make) n a; t.size := 0 |}.
  
  Definition extend {a : Set} (v : t a) : unit :=
    if equiv_decb (t.size v) ((|Util.Array|).(CArray.ExtS.length) (t.elems v))
      then
      let new_size := OCaml.Stdlib.min (Z.mul 2 (t.size v)) Sys.max_array_length
        in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let new_elems :=
        (|Util.Array|).(CArray.ExtS.make) new_size
          ((|Util.Array|).(CArray.ExtS.get) (t.elems v) 0) in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Set record field not handled. *)
      set_record_field v &quot;elems&quot; new_elems
    else
      tt.
  
  Definition push {A : Set} (v : t A) (a : A) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Set record field not handled. *)
    set_record_field v &quot;size&quot; (Z.add (t.size v) 1).
  
  Definition popn {a : Set} (v : t a) (n : Z) : unit :=
    (* ❌ Set record field not handled. *)
    set_record_field v &quot;size&quot; (OCaml.Stdlib.max 0 (Z.sub (t.size v) n)).
  
  Definition pop {A : Set} (v : t A) : unit := popn v 1.
  
  Definition get_last {a : Set} (v : t a) (n : Z) : a :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Util.Array|).(CArray.ExtS.get) (t.elems v) (Z.sub (Z.sub (t.size v) n) 1).
End Vect.

Definition dummy_lambda : lambda := Lrel Names.Anonymous 0.

Definition empty_args {A : Set} : array A :=
  (* ❌ Arrays not handled. *)
  [ ].

Module Renv.
  Definition constructor_info := Vmvalues.tag * Z * Z.
  
  Module t.
    Record record := {
      global_env : Environ.env;
      name_rel : Vect.t Names.Name.t;
      construct_tbl : Stdlib.Hashtbl.t Names.constructor constructor_info }.
    Definition with_global_env (r : record) global_env : record :=
      {| global_env := global_env; name_rel := name_rel r;
        construct_tbl := construct_tbl r |}.
    Definition with_name_rel (r : record) name_rel : record :=
      {| global_env := global_env r; name_rel := name_rel;
        construct_tbl := construct_tbl r |}.
    Definition with_construct_tbl (r : record) construct_tbl : record :=
      {| global_env := global_env r; name_rel := name_rel r;
        construct_tbl := construct_tbl |}.
  End t.
  Definition t := t.record.
  
  Definition make (env : Environ.env) : t :=
    {| t.global_env := env; t.name_rel := Vect.make 16 Names.Anonymous;
      t.construct_tbl := Hashtbl.create None 111 |}.
  
  Definition push_rel (env : t) (id : Context.binder_annot Names.Name.t)
    : unit := Vect.push (t.name_rel env) (Context.binder_annot.binder_name id).
  
  Definition push_rels
    (env : t) (ids : array (Context.binder_annot Names.Name.t)) : unit :=
    (|Util.Array|).(CArray.ExtS.iter) (push_rel env) ids.
  
  Definition pop (env : t) : unit := Vect.pop (t.name_rel env).
  
  Definition popn (env : t) (n : Z) : unit :=
    (* ❌ For loops not handled. *)
    for.
  
  Definition get (env : t) (n : Z) : lambda :=
    Lrel (Vect.get_last (t.name_rel env) (Z.sub n 1)) n.
  
  Definition get_construct_info (env : t) (c : Names.constructor)
    : constructor_info :=
    (* ❌ Try-with are not handled *)
    try (Hashtbl.find (t.construct_tbl env) c).
End Renv.

Import Renv.

Fixpoint lambda_of_constr (env : Renv.t) (c : Constr.constr) {struct env}
  : lambda :=
  match Constr.kind c with
  | Constr.Meta _ =&gt; Stdlib.raise extensible_type_value
  | Constr.Evar (evk, args) =&gt;
    let args := lambda_of_args env 0 args in
    Levar evk args
  | Constr.Cast c _ _ =&gt; lambda_of_constr env c
  | Constr.Rel i =&gt; Renv.get env i
  | Constr.Var id =&gt; Lvar id
  | Constr.Sort s =&gt; Lsort s
  | Constr.Ind ind =&gt; Lind ind
  | Constr.Prod id dom codom =&gt;
    let ld := lambda_of_constr env dom in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let lc := lambda_of_constr env codom in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Lprod ld
      (Llam
        (* ❌ Arrays not handled. *)
        [ id ] lc)
  | Constr.Lambda _ _ _ =&gt;
    let '(params, body) := decompose_lam c in
    let ids := get_names ((|Util.List|).(CList.ExtS.rev) params) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let lb := lambda_of_constr env body in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    mkLlam ids lb
  | Constr.LetIn id def _ body =&gt;
    let ld := lambda_of_constr env def in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let lb := lambda_of_constr env body in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Llet id ld lb
  | Constr.App f args =&gt; lambda_of_app env f args
  | Constr.Const _ =&gt; lambda_of_app env c empty_args
  | Constr.Construct _ =&gt; lambda_of_app env c empty_args
  | Constr.Case ci t a branches =&gt;
    let ind := Constr.case_info.ci_ind ci in
    let mib := lookup_mind (fst ind) (Renv.t.global_env env) in
    let oib :=
      (|Util.Array|).(CArray.ExtS.get)
        (Declarations.mutual_inductive_body.mind_packets mib) (snd ind) in
    let '_ := check_compilable oib in
    let rtbl := Declarations.one_inductive_body.mind_reloc_tbl oib in
    let la := lambda_of_constr env a in
    let lt := lambda_of_constr env t in
    let consts :=
      (|Util.Array|).(CArray.ExtS.make)
        (Declarations.one_inductive_body.mind_nb_constant oib) dummy_lambda in
    let blocks :=
      (|Util.Array|).(CArray.ExtS.make)
        (Declarations.one_inductive_body.mind_nb_args oib)
        ((* ❌ Arrays not handled. *)
        [ ], dummy_lambda) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let branches :=
      {| lam_branches.constant_branches := consts;
        lam_branches.nonconstant_branches := blocks |} in
    Lcase ci rtbl lt la branches
  | Constr.Fix (rec_init, (names, type_bodies, rec_bodies)) =&gt;
    let ltypes := lambda_of_args env 0 type_bodies in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let lbodies := lambda_of_args env 0 rec_bodies in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Lfix rec_init (names, ltypes, lbodies)
  | Constr.CoFix (init, (names, type_bodies, rec_bodies)) =&gt;
    let rec_bodies :=
      (|Util.Array|).(CArray.ExtS.map2)
        (Reduction.eta_expand (Renv.t.global_env env)) rec_bodies type_bodies in
    let ltypes := lambda_of_args env 0 type_bodies in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let lbodies := lambda_of_args env 0 rec_bodies in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Lcofix init (names, ltypes, lbodies)
  | Constr.Proj p c =&gt;
    let lc := lambda_of_constr env c in
    Lproj (Projection.repr p) lc
  | Constr.Int i =&gt; Luint i
  end

with lambda_of_app
  (env : Renv.t) (f : Constr.constr) (args : array Constr.constr) {struct env}
  : lambda :=
  match Constr.kind f with
  | Constr.Const ((kn, u) as c) =&gt;
    let kn := get_alias (Renv.t.global_env env) kn in
    let cb := lookup_constant kn (Renv.t.global_env env) in
    match
      ((Declarations.constant_body.const_body cb),
        match Declarations.constant_body.const_body cb with
        | Declarations.Def csubst =&gt;
          Declarations.constant_body.const_inline_code cb
        | _ =&gt; false
        end) with
    | (Declarations.Primitive op, _) =&gt;
      lambda_of_prim (kn, u) op (lambda_of_args env 0 args)
    | (Declarations.Def csubst, true) =&gt;
      lambda_of_app env (Mod_subst.force_constr csubst) args
    | (Declarations.Def _ | Declarations.OpaqueDef _ | Declarations.Undef _, _)
      =&gt; mkLapp (Lconst c) (lambda_of_args env 0 args)
    end
  | Constr.Construct (c, _) =&gt;
    let '(tag, nparams, arity) := Renv.get_construct_info env c in
    let nargs := (|Util.Array|).(CArray.ExtS.length) args in
    if OCaml.Stdlib.lt nparams nargs then
      let args := lambda_of_args env nparams args in
      makeblock tag 0 arity args
    else
      makeblock tag (Z.sub nparams nargs) arity empty_args
  | _ =&gt;
    let f := lambda_of_constr env f in
    let args := lambda_of_args env 0 args in
    mkLapp f args
  end

with lambda_of_args (env : Renv.t) (start : Z) (args : array Constr.constr)
  {struct env} : array lambda :=
  let nargs := (|Util.Array|).(CArray.ExtS.length) args in
  if OCaml.Stdlib.lt start nargs then
    (|Util.Array|).(CArray.ExtS.init) (Z.sub nargs start)
      (fun i =&gt;
        lambda_of_constr env
          ((|Util.Array|).(CArray.ExtS.get) args (Z.add start i)))
  else
    empty_args.

Definition dump_lambda : Stdlib.ref bool := Stdlib.__ref_value false.

Definition optimize_lambda (lam : lambda) : lambda :=
  let lam := simplify subst_id lam in
  remove_let subst_id lam.

Definition lambda_of_constr
  (optimize : bool) (genv : Environ.env) (c : Constr.constr) : lambda :=
  let env := Renv.make genv in
  let ids :=
    (|Util.List|).(CList.ExtS.rev_map) Context.Rel.Declaration.get_annot
      (rel_context genv) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let lam := lambda_of_constr env c in
  let lam :=
    if optimize then
      optimize_lambda lam
    else
      lam in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  lam.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="clambda.mli">
  <div style="margin: 20px;">
    <h3>Clambda_mli</h3>
    <ul>
      <li>OCaml size: 44 lines</li>
      <li>Coq size: 79 lines (+79% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#clambda.mli"><code>clambda.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>open Names
open Constr
open Vmvalues
open Environ

type lambda =
  | Lrel          of Name.t * int
  | Lvar          of Id.t
  | Levar         of Evar.t * lambda array
  | Lprod         of lambda * lambda
  | Llam          of Name.t Context.binder_annot array * lambda
  | Llet          of Name.t Context.binder_annot * lambda * lambda
  | Lapp          of lambda * lambda array
  | Lconst        of pconstant
  | Lprim         of pconstant option * CPrimitives.t * lambda array
        (* No check if None *)
  | Lcase         of case_info * reloc_table * lambda * lambda * lam_branches
  | Lif           of lambda * lambda * lambda
  | Lfix          of (int array * int) * fix_decl
  | Lcofix        of int * fix_decl
  | Lint          of int
  | Lmakeblock    of int * lambda array
  | Luint         of Uint63.t
  | Lval          of structured_values
  | Lsort         of Sorts.t
  | Lind          of pinductive
  | Lproj         of Projection.Repr.t * lambda

and lam_branches =
  { constant_branches : lambda array;
    nonconstant_branches : (Name.t Context.binder_annot array * lambda) array }

and fix_decl =  Name.t Context.binder_annot array * lambda array * lambda array

<abbr class="mark-warning" title="Signature item `exception` not handled">exception TooLargeInductive of Pp.t</abbr>

val lambda_of_constr : optimize:bool -&gt; env -&gt; Constr.t -&gt; lambda

val decompose_Llam : lambda -&gt; Name.t Context.binder_annot array * lambda

val get_alias : env -&gt; Constant.t -&gt; Constant.t

(** Dump the VM lambda code after compilation (for debugging purposes) *)
val dump_lambda : bool ref
</pre>
  </div>
  <div class="col-md-6">
    <a href="#clambda.mli"><code>Clambda_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Reserved Notation &quot;'lam_branches&quot;.
Reserved Notation &quot;'fix_decl&quot;.

Module lam_branches.
  Record record {constant_branches nonconstant_branches : Set} := {
    constant_branches : constant_branches;
    nonconstant_branches : nonconstant_branches }.
  Arguments record : clear implicits.
  Definition with_constant_branches
    {constant_branches_type nonconstant_branches_type : Set}
    (r : record constant_branches_type nonconstant_branches_type)
    constant_branches
    : record constant_branches_type nonconstant_branches_type :=
    {| constant_branches := constant_branches;
      nonconstant_branches := nonconstant_branches r |}.
  Definition with_nonconstant_branches
    {constant_branches_type nonconstant_branches_type : Set}
    (r : record constant_branches_type nonconstant_branches_type)
    nonconstant_branches
    : record constant_branches_type nonconstant_branches_type :=
    {| constant_branches := constant_branches r;
      nonconstant_branches := nonconstant_branches |}.
End lam_branches.
Definition lam_branches_skeleton := lam_branches.record.

Inductive lambda : Set :=
| Lrel : Names.Name.t -&gt; Z -&gt; lambda
| Lvar : Names.Id.t -&gt; lambda
| Levar : Evar.t -&gt; array lambda -&gt; lambda
| Lprod : lambda -&gt; lambda -&gt; lambda
| Llam : array (Context.binder_annot Names.Name.t) -&gt; lambda -&gt; lambda
| Llet : Context.binder_annot Names.Name.t -&gt; lambda -&gt; lambda -&gt; lambda
| Lapp : lambda -&gt; array lambda -&gt; lambda
| Lconst : Constr.pconstant -&gt; lambda
| Lprim : option Constr.pconstant -&gt; CPrimitives.t -&gt; array lambda -&gt; lambda
| Lcase :
  Constr.case_info -&gt; Vmvalues.reloc_table -&gt; lambda -&gt; lambda -&gt;
  'lam_branches -&gt; lambda
| Lif : lambda -&gt; lambda -&gt; lambda -&gt; lambda
| Lfix : array Z * Z -&gt; 'fix_decl -&gt; lambda
| Lcofix : Z -&gt; 'fix_decl -&gt; lambda
| Lint : Z -&gt; lambda
| Lmakeblock : Z -&gt; array lambda -&gt; lambda
| Luint : Uint63.t -&gt; lambda
| Lval : Vmvalues.structured_values -&gt; lambda
| Lsort : Sorts.t -&gt; lambda
| Lind : Constr.pinductive -&gt; lambda
| Lproj : Names.Projection.Repr.t -&gt; lambda -&gt; lambda

where &quot;'lam_branches&quot; :=
  (lam_branches_skeleton (array lambda)
    (array (array (Context.binder_annot Names.Name.t) * lambda)))
and &quot;'fix_decl&quot; :=
  (array (Context.binder_annot Names.Name.t) * array lambda * array lambda).

Definition lam_branches := 'lam_branches.
Definition fix_decl := 'fix_decl.

(* exception TooLargeInductive *)

Parameter lambda_of_constr : bool -&gt; Environ.env -&gt; Constr.t -&gt; lambda.

Parameter decompose_Llam :
  lambda -&gt; array (Context.binder_annot Names.Name.t) * lambda.

Parameter get_alias : Environ.env -&gt; Names.Constant.t -&gt; Names.Constant.t.

Parameter dump_lambda : Stdlib.ref bool.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constr.mli">
  <div style="margin: 20px;">
    <h3>Constr_mli</h3>
    <ul>
      <li>OCaml size: 612 lines</li>
      <li>Coq size: 443 lines (-28% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#constr.mli"><code>constr.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** This file defines the most important datatype of Coq, namely kernel terms,
    as well as a handful of generic manipulation functions. *)

open Names

(** {6 Simply type aliases } *)
type pconstant = Constant.t Univ.puniverses
type pinductive = inductive Univ.puniverses
type pconstructor = constructor Univ.puniverses

(** {6 Existential variables } *)
type metavariable = int

(** {6 Case annotation } *)
type case_style = LetStyle | IfStyle | LetPatternStyle | MatchStyle
  | RegularStyle (** infer printing form from number of constructor *)
type case_printing =
  { ind_tags : bool list; (** tell whether letin or lambda in the arity of the inductive type *)
    cstr_tags : bool list array; (** tell whether letin or lambda in the signature of each constructor *)
    style     : case_style }

(* INVARIANT:
 * - Array.length ci_cstr_ndecls = Array.length ci_cstr_nargs
 * - forall (i : 0 .. pred (Array.length ci_cstr_ndecls)),
 *          ci_cstr_ndecls.(i) &gt;= ci_cstr_nargs.(i)
 *)
type case_info =
  { ci_ind        : inductive;      (* inductive type to which belongs the value that is being matched *)
    ci_npar       : int;            (* number of parameters of the above inductive type *)
    ci_cstr_ndecls : int array;     (* For each constructor, the corresponding integer determines
                                       the number of values that can be bound in a match-construct.
                                       NOTE: parameters of the inductive type are therefore excluded from the count *)
    ci_cstr_nargs : int array;      (* for each constructor, the corresponding integers determines
                                       the number of values that can be applied to the constructor,
                                       in addition to the parameters of the related inductive type
                                       NOTE: &quot;lets&quot; are therefore excluded from the count
                                       NOTE: parameters of the inductive type are also excluded from the count *)
    ci_relevance : Sorts.relevance; (* relevance of the predicate (not of the inductive!) *)
    ci_pp_info    : case_printing   (* not interpreted by the kernel *)
  }

(** {6 The type of constructions } *)

type t
type constr = t
(** [types] is the same as [constr] but is intended to be used for
   documentation to indicate that such or such function specifically works
   with {e types} (i.e. terms of type a sort).
   (Rem:plurial form since [type] is a reserved ML keyword) *)

type types = constr

(** {5 Functions for dealing with constr terms. }
  The following functions are intended to simplify and to uniform the
  manipulation of terms. Some of these functions may be overlapped with
  previous ones. *)

(** {6 Term constructors. } *)

(** Constructs a de Bruijn index (DB indices begin at 1) *)
val mkRel : int -&gt; constr

(** Constructs a Variable *)
val mkVar : Id.t -&gt; constr

(** Constructs a machine integer *)
val mkInt : Uint63.t -&gt; constr

(** Constructs an patvar named &quot;?n&quot; *)
val mkMeta : metavariable -&gt; constr

(** Constructs an existential variable *)
type existential = Evar.t * constr array
val mkEvar : existential -&gt; constr

(** Construct a sort *)
val mkSort : Sorts.t -&gt; types
val mkSProp : types
val mkProp : types
val mkSet  : types
val mkType : Univ.Universe.t -&gt; types


(** This defines the strategy to use for verifiying a Cast *)
type cast_kind = VMcast | NATIVEcast | DEFAULTcast | REVERTcast

(** Constructs the term [t1::t2], i.e. the term t{_ 1} casted with the
   type t{_ 2} (that means t2 is declared as the type of t1). *)
val mkCast : constr * cast_kind * constr -&gt; constr

(** Constructs the product [(x:t1)t2] *)
val mkProd : Name.t Context.binder_annot * types * types -&gt; types

(** Constructs the abstraction \[x:t{_ 1}\]t{_ 2} *)
val mkLambda : Name.t Context.binder_annot * types * constr -&gt; constr

(** Constructs the product [let x = t1 : t2 in t3] *)
val mkLetIn : Name.t Context.binder_annot * constr * types * constr -&gt; constr

(** [mkApp (f, [|t1; ...; tN|]] constructs the application
    {%html:(f t&lt;sub&gt;1&lt;/sub&gt; ... t&lt;sub&gt;n&lt;/sub&gt;)%}
    {%latex:$(f~t_1\dots f_n)$%}. *)
val mkApp : constr * constr array -&gt; constr

val map_puniverses : ('a -&gt; 'b) -&gt; 'a Univ.puniverses -&gt; 'b Univ.puniverses

(** Constructs a Constant.t *)
val mkConst : Constant.t -&gt; constr
val mkConstU : pconstant -&gt; constr

(** Constructs a projection application *)
val mkProj : (Projection.t * constr) -&gt; constr

(** Inductive types *)

(** Constructs the ith (co)inductive type of the block named kn *)
val mkInd : inductive -&gt; constr
val mkIndU : pinductive -&gt; constr

(** Constructs the jth constructor of the ith (co)inductive type of the
   block named kn. *)
val mkConstruct : constructor -&gt; constr
val mkConstructU : pconstructor -&gt; constr
val mkConstructUi : pinductive * int -&gt; constr

(** Make a constant, inductive, constructor or variable. *)
val mkRef : GlobRef.t Univ.puniverses -&gt; constr

(** Constructs a destructor of inductive type.

    [mkCase ci p c ac] stand for match [c] as [x] in [I args] return [p] with [ac]
    presented as describe in [ci].

    [p] structure is [fun args x -&gt; &quot;return clause&quot;]

    [ac]{^ ith} element is ith constructor case presented as
    {e lambda construct_args (without params). case_term } *)
val mkCase : case_info * constr * constr * constr array -&gt; constr

(** If [recindxs = [|i1,...in|]]
      [funnames = [|f1,.....fn|]]
      [typarray = [|t1,...tn|]]
      [bodies   = [|b1,.....bn|]]
   then [mkFix ((recindxs,i), funnames, typarray, bodies) ]
   constructs the {% $ %}i{% $ %}th function of the block (counting from 0)

    [Fixpoint f1 [ctx1] = b1
     with     f2 [ctx2] = b2
     ...
     with     fn [ctxn] = bn.]

   where the length of the {% $ %}j{% $ %}th context is {% $ %}ij{% $ %}.
*)
type ('constr, 'types) prec_declaration =
    Name.t Context.binder_annot array * 'types array * 'constr array
type ('constr, 'types) pfixpoint =
    (int array * int) * ('constr, 'types) prec_declaration
  (* The array of [int]'s tells for each component of the array of
     mutual fixpoints the number of lambdas to skip before finding the
     recursive argument (e.g., value is 2 in &quot;fix f (x:A) (y:=t) (z:B)
     (v:=u) (w:I) {struct w}&quot;), telling to skip x and z and that w is
     the recursive argument);
     The second component [int] tells which component of the block is
     returned *)

type ('constr, 'types) pcofixpoint =
    int * ('constr, 'types) prec_declaration
  (* The component [int] tells which component of the block of
     cofixpoint is returned *)

type rec_declaration = (constr, types) prec_declaration

type fixpoint = (constr, types) pfixpoint
val mkFix : fixpoint -&gt; constr

(** If [funnames = [|f1,.....fn|]]
      [typarray = [|t1,...tn|]]
      [bodies   = [b1,.....bn]]
   then [mkCoFix (i, (funnames, typarray, bodies))]
   constructs the ith function of the block

    [CoFixpoint f1 = b1
     with       f2 = b2
     ...
     with       fn = bn.]
 *)
type cofixpoint = (constr, types) pcofixpoint
val mkCoFix : cofixpoint -&gt; constr


(** {6 Concrete type for making pattern-matching. } *)

(** [constr array] is an instance matching definitional [named_context] in
   the same order (i.e. last argument first) *)
type 'constr pexistential = Evar.t * 'constr array

type ('constr, 'types, 'sort, 'univs) kind_of_term =
  | Rel       of int                                  (** Gallina-variable introduced by [forall], [fun], [let-in], [fix], or [cofix]. *)

  | Var       of Id.t                                 (** Gallina-variable that was introduced by Vernacular-command that extends
                                                          the local context of the currently open section
                                                          (i.e. [Variable] or [Let]). *)

  | Meta      of metavariable
  | Evar      of 'constr pexistential
  | Sort      of 'sort
  | Cast      of 'constr * cast_kind * 'types
  | Prod      of Name.t Context.binder_annot * 'types * 'types             (** Concrete syntax [&quot;forall A:B,C&quot;] is represented as [Prod (A,B,C)]. *)
  | Lambda    of Name.t Context.binder_annot * 'types * 'constr            (** Concrete syntax [&quot;fun A:B =&gt; C&quot;] is represented as [Lambda (A,B,C)].  *)
  | LetIn     of Name.t Context.binder_annot * 'constr * 'types * 'constr  (** Concrete syntax [&quot;let A:C := B in D&quot;] is represented as [LetIn (A,B,C,D)]. *)
  | App       of 'constr * 'constr array              (** Concrete syntax [&quot;(F P1 P2 ...  Pn)&quot;] is represented as [App (F, [|P1; P2; ...; Pn|])].

                                                          The {!mkApp} constructor also enforces the following invariant:
                                                          - [F] itself is not {!App}
                                                          - and [[|P1;..;Pn|]] is not empty. *)

  | Const     of (Constant.t * 'univs)                  (** Gallina-variable that was introduced by Vernacular-command that extends the global environment
                                                          (i.e. [Parameter], or [Axiom], or [Definition], or [Theorem] etc.) *)

  | Ind       of (inductive * 'univs)                 (** A name of an inductive type defined by [Variant], [Inductive] or [Record] Vernacular-commands. *)
  | Construct of (constructor * 'univs)              (** A constructor of an inductive type defined by [Variant], [Inductive] or [Record] Vernacular-commands. *)
  | Case      of case_info * 'constr * 'constr * 'constr array
  | Fix       of ('constr, 'types) pfixpoint
  | CoFix     of ('constr, 'types) pcofixpoint
  | Proj      of Projection.t * 'constr
  | Int       of Uint63.t

(** User view of [constr]. For [App], it is ensured there is at
   least one argument and the function is not itself an applicative
   term *)

val kind : constr -&gt; (constr, types, Sorts.t, Univ.Instance.t) kind_of_term
val of_kind : (constr, types, Sorts.t, Univ.Instance.t) kind_of_term -&gt; constr

val kind_nocast_gen : ('v -&gt; ('v, 'v, 'sort, 'univs) kind_of_term) -&gt;
  ('v -&gt; ('v, 'v, 'sort, 'univs) kind_of_term)

val kind_nocast : constr -&gt; (constr, types, Sorts.t, Univ.Instance.t) kind_of_term

(** {6 Simple case analysis} *)
val isRel  : constr -&gt; bool
val isRelN : int -&gt; constr -&gt; bool
val isVar  : constr -&gt; bool
val isVarId : Id.t -&gt; constr -&gt; bool
val isInd  : constr -&gt; bool
val isEvar : constr -&gt; bool
val isMeta : constr -&gt; bool
val isEvar_or_Meta : constr -&gt; bool
val isSort : constr -&gt; bool
val isCast : constr -&gt; bool
val isApp : constr -&gt; bool
val isLambda : constr -&gt; bool
val isLetIn : constr -&gt; bool
val isProd : constr -&gt; bool
val isConst : constr -&gt; bool
val isConstruct : constr -&gt; bool
val isFix : constr -&gt; bool
val isCoFix : constr -&gt; bool
val isCase : constr -&gt; bool
val isProj : constr -&gt; bool

val is_Prop : constr -&gt; bool
val is_Set  : constr -&gt; bool
val isprop : constr -&gt; bool
val is_Type : constr -&gt; bool
val iskind : constr -&gt; bool
val is_small : Sorts.t -&gt; bool

(** {6 Term destructors } *)
(** Destructor operations are partial functions and
    @raise DestKO if the term has not the expected form. *)

<abbr class="mark-warning" title="Signature item `exception` not handled">exception DestKO</abbr>

(** Destructs a de Bruijn index *)
val destRel : constr -&gt; int

(** Destructs an existential variable *)
val destMeta : constr -&gt; metavariable

(** Destructs a variable *)
val destVar : constr -&gt; Id.t

(** Destructs a sort. [is_Prop] recognizes the sort [Prop], whether
   [isprop] recognizes both [Prop] and [Set]. *)
val destSort : constr -&gt; Sorts.t

(** Destructs a casted term *)
val destCast : constr -&gt; constr * cast_kind * constr

(** Destructs the product {% $ %}(x:t_1)t_2{% $ %} *)
val destProd : types -&gt; Name.t Context.binder_annot * types * types

(** Destructs the abstraction {% $ %}[x:t_1]t_2{% $ %} *)
val destLambda : constr -&gt; Name.t Context.binder_annot * types * constr

(** Destructs the let {% $ %}[x:=b:t_1]t_2{% $ %} *)
val destLetIn : constr -&gt; Name.t Context.binder_annot * constr * types * constr

(** Destructs an application *)
val destApp : constr -&gt; constr * constr array

(** Decompose any term as an applicative term; the list of args can be empty *)
val decompose_app : constr -&gt; constr * constr list

(** Same as [decompose_app], but returns an array. *)
val decompose_appvect : constr -&gt; constr * constr array

(** Destructs a constant *)
val destConst : constr -&gt; Constant.t Univ.puniverses

(** Destructs an existential variable *)
val destEvar : constr -&gt; existential

(** Destructs a (co)inductive type *)
val destInd : constr -&gt; inductive Univ.puniverses

(** Destructs a constructor *)
val destConstruct : constr -&gt; constructor Univ.puniverses

(** Destructs a [match c as x in I args return P with ... |
Ci(...yij...) =&gt; ti | ... end] (or [let (..y1i..) := c as x in I args
return P in t1], or [if c then t1 else t2])
@return [(info,c,fun args x =&gt; P,[|...|fun yij =&gt; ti| ...|])]
where [info] is pretty-printing information *)
val destCase : constr -&gt; case_info * constr * constr * constr array

(** Destructs a projection *)
val destProj : constr -&gt; Projection.t * constr

(** Destructs the {% $ %}i{% $ %}th function of the block
   [Fixpoint f{_ 1} ctx{_ 1} = b{_ 1}
    with    f{_ 2} ctx{_ 2} = b{_ 2}
    ...
    with    f{_ n} ctx{_ n} = b{_ n}],
   where the length of the {% $ %}j{% $ %}th context is {% $ %}ij{% $ %}.
*)
val destFix : constr -&gt; fixpoint

val destCoFix : constr -&gt; cofixpoint

val destRef : constr -&gt; GlobRef.t Univ.puniverses

(** {6 Equality} *)

(** [equal a b] is true if [a] equals [b] modulo alpha, casts,
   and application grouping *)
val equal : constr -&gt; constr -&gt; bool

(** [eq_constr_univs u a b] is [true] if [a] equals [b] modulo alpha, casts,
   application grouping and the universe equalities in [u]. *)
val eq_constr_univs : constr UGraph.check_function

(** [leq_constr_univs u a b] is [true] if [a] is convertible to [b] modulo
    alpha, casts, application grouping and the universe inequalities in [u]. *)
val leq_constr_univs : constr UGraph.check_function

(** [eq_constr_univs u a b] is [true] if [a] equals [b] modulo alpha, casts,
   application grouping and the universe equalities in [u]. *)
val eq_constr_univs_infer : UGraph.t -&gt; constr -&gt; constr -&gt; bool Univ.constrained

(** [leq_constr_univs u a b] is [true] if [a] is convertible to [b] modulo
    alpha, casts, application grouping and the universe inequalities in [u]. *)
val leq_constr_univs_infer : UGraph.t -&gt; constr -&gt; constr -&gt; bool Univ.constrained

(** [eq_constr_univs a b] [true, c] if [a] equals [b] modulo alpha, casts,
   application grouping and ignoring universe instances. *)
val eq_constr_nounivs : constr -&gt; constr -&gt; bool

(** Total ordering compatible with [equal] *)
val compare : constr -&gt; constr -&gt; int

(** {6 Extension of Context with declarations on constr} *)

type rel_declaration = (constr, types) Context.Rel.Declaration.pt
type named_declaration = (constr, types) Context.Named.Declaration.pt
type compacted_declaration = (constr, types) Context.Compacted.Declaration.pt
type rel_context = rel_declaration list
type named_context = named_declaration list
type compacted_context = compacted_declaration list

(** {6 Relocation and substitution } *)

(** [exliftn el c] lifts [c] with lifting [el] *)
val exliftn : Esubst.lift -&gt; constr -&gt; constr

(** [liftn n k c] lifts by [n] indexes above or equal to [k] in [c] *)
val liftn : int -&gt; int -&gt; constr -&gt; constr

(** [lift n c] lifts by [n] the positive indexes in [c] *)
val lift : int -&gt; constr -&gt; constr

(** {6 Functionals working on expressions canonically abstracted over
       a local context (possibly with let-ins)} *)

(** [map_under_context f l c] maps [f] on the immediate subterms of a
    term abstracted over a context of length [n] (local definitions
    are counted) *)

val map_under_context : (constr -&gt; constr) -&gt; int -&gt; constr -&gt; constr

(** [map_branches f br] maps [f] on the immediate subterms of an array
   of &quot;match&quot; branches [br] in canonical eta-let-expanded form; it is
   not recursive and the order with which subterms are processed is
   not specified; it preserves sharing; the immediate subterms are the
   types and possibly terms occurring in the context of each branch as
   well as the body of each branch *)

val map_branches : (constr -&gt; constr) -&gt; case_info -&gt; constr array -&gt; constr array

(** [map_return_predicate f p] maps [f] on the immediate subterms of a
   return predicate of a &quot;match&quot; in canonical eta-let-expanded form;
   it is not recursive and the order with which subterms are processed
   is not specified; it preserves sharing; the immediate subterms are
   the types and possibly terms occurring in the context of each
   branch as well as the body of the predicate *)

val map_return_predicate : (constr -&gt; constr) -&gt; case_info -&gt; constr -&gt; constr

(** [map_under_context_with_binders g f n l c] maps [f] on the
    immediate subterms of a term abstracted over a context of length
    [n] (local definitions are counted); it preserves sharing; it
    carries an extra data [n] (typically a lift index) which is
    processed by [g] (which typically add 1 to [n]) at each binder
    traversal *)

val map_under_context_with_binders : ('a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; constr) -&gt; 'a -&gt; int -&gt; constr -&gt; constr

(** [map_branches_with_binders f br] maps [f] on the immediate
   subterms of an array of &quot;match&quot; branches [br] in canonical
   eta-let-expanded form; it carries an extra data [n] (typically a
   lift index) which is processed by [g] (which typically adds 1 to
   [n]) at each binder traversal; it is not recursive and the order
   with which subterms are processed is not specified; it preserves
   sharing; the immediate subterms are the types and possibly terms
   occurring in the context of the branch as well as the body of the
   branch *)

val map_branches_with_binders : ('a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; constr) -&gt; 'a -&gt; case_info -&gt; constr array -&gt; constr array

(** [map_return_predicate_with_binders f p] maps [f] on the immediate
   subterms of a return predicate of a &quot;match&quot; in canonical
   eta-let-expanded form; it carries an extra data [n] (typically a
   lift index) which is processed by [g] (which typically adds 1 to
   [n]) at each binder traversal; it is not recursive and the order
   with which subterms are processed is not specified; it preserves
   sharing; the immediate subterms are the types and possibly terms
   occurring in the context of each branch as well as the body of the
   predicate *)

val map_return_predicate_with_binders : ('a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; constr) -&gt; 'a -&gt; case_info -&gt; constr -&gt; constr

(** [map_under_context_with_full_binders g f n l c] is similar to
    [map_under_context_with_binders] except that [g] takes also a full
    binder as argument and that only the number of binders (and not
    their signature) is required *)

val map_under_context_with_full_binders : ((constr, constr) Context.Rel.Declaration.pt -&gt; 'a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; constr) -&gt; 'a -&gt; int -&gt; constr -&gt; constr

(** [map_branches_with_full_binders g f l br] is equivalent to
   [map_branches_with_binders] but using
   [map_under_context_with_full_binders] *)

val map_branches_with_full_binders : ((constr, constr) Context.Rel.Declaration.pt -&gt; 'a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; constr) -&gt; 'a -&gt; case_info -&gt; constr array -&gt; constr array

(** [map_return_predicate_with_full_binders g f l p] is equivalent to
   [map_return_predicate_with_binders] but using
   [map_under_context_with_full_binders] *)

val map_return_predicate_with_full_binders : ((constr, constr) Context.Rel.Declaration.pt -&gt; 'a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; constr) -&gt; 'a -&gt; case_info -&gt; constr -&gt; constr

(** {6 Functionals working on the immediate subterm of a construction } *)

(** [fold f acc c] folds [f] on the immediate subterms of [c]
   starting from [acc] and proceeding from left to right according to
   the usual representation of the constructions; it is not recursive *)

val fold : ('a -&gt; constr -&gt; 'a) -&gt; 'a -&gt; constr -&gt; 'a

val fold_with_full_binders :
  (rel_declaration -&gt; 'a -&gt; 'a) -&gt; ('a -&gt; 'b -&gt; constr -&gt; 'b) -&gt;
    'a -&gt; 'b -&gt; constr -&gt; 'b

(** [map f c] maps [f] on the immediate subterms of [c]; it is
   not recursive and the order with which subterms are processed is
   not specified *)

val map : (constr -&gt; constr) -&gt; constr -&gt; constr

(** [map_user_view f c] maps [f] on the immediate subterms of [c]; it
   differs from [map f c] in that the typing context and body of the
   return predicate and of the branches of a [match] are considered as
   immediate subterm of a [match] *)

val map_user_view : (constr -&gt; constr) -&gt; constr -&gt; constr

(** Like {!map}, but also has an additional accumulator. *)

val fold_map : ('a -&gt; constr -&gt; 'a * constr) -&gt; 'a -&gt; constr -&gt; 'a * constr

(** [map_with_binders g f n c] maps [f n] on the immediate
   subterms of [c]; it carries an extra data [n] (typically a lift
   index) which is processed by [g] (which typically add 1 to [n]) at
   each binder traversal; it is not recursive and the order with which
   subterms are processed is not specified *)

val map_with_binders :
  ('a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; constr) -&gt; 'a -&gt; constr -&gt; constr

(** [iter f c] iters [f] on the immediate subterms of [c]; it is
   not recursive and the order with which subterms are processed is
   not specified *)

val iter : (constr -&gt; unit) -&gt; constr -&gt; unit

(** [iter_with_binders g f n c] iters [f n] on the immediate
   subterms of [c]; it carries an extra data [n] (typically a lift
   index) which is processed by [g] (which typically add 1 to [n]) at
   each binder traversal; it is not recursive and the order with which
   subterms are processed is not specified *)

val iter_with_binders :
  ('a -&gt; 'a) -&gt; ('a -&gt; constr -&gt; unit) -&gt; 'a -&gt; constr -&gt; unit

(** [iter_with_binders g f n c] iters [f n] on the immediate
   subterms of [c]; it carries an extra data [n] (typically a lift
   index) which is processed by [g] (which typically add 1 to [n]) at
   each binder traversal; it is not recursive and the order with which
   subterms are processed is not specified *)

val fold_constr_with_binders :
  ('a -&gt; 'a) -&gt; ('a -&gt; 'b -&gt; constr -&gt; 'b) -&gt; 'a -&gt; 'b -&gt; constr -&gt; 'b

type 'constr constr_compare_fn = int -&gt; 'constr -&gt; 'constr -&gt; bool

(** [compare_head f c1 c2] compare [c1] and [c2] using [f] to compare
   the immediate subterms of [c1] of [c2] if needed; Cast's, binders
   name and Cases annotations are not taken into account *)

val compare_head : constr constr_compare_fn -&gt; constr constr_compare_fn

(** Convert a global reference applied to 2 instances. The int says
   how many arguments are given (as we can only use cumulativity for
   fully applied inductives/constructors) .*)
type 'univs instance_compare_fn = GlobRef.t -&gt; int -&gt;
  'univs -&gt; 'univs -&gt; bool

(** [compare_head_gen u s f c1 c2] compare [c1] and [c2] using [f] to
   compare the immediate subterms of [c1] of [c2] if needed, [u] to
   compare universe instances, [s] to compare sorts; Cast's, binders
   name and Cases annotations are not taken into account *)

val compare_head_gen : Univ.Instance.t instance_compare_fn -&gt;
  (Sorts.t -&gt; Sorts.t -&gt; bool) -&gt;
  constr constr_compare_fn -&gt;
  constr constr_compare_fn

val compare_head_gen_leq_with :
  ('v -&gt; ('v, 'v, 'sort, 'univs) kind_of_term) -&gt;
  ('v -&gt; ('v, 'v, 'sort, 'univs) kind_of_term) -&gt;
  'univs instance_compare_fn -&gt;
  ('sort -&gt; 'sort -&gt; bool) -&gt;
  'v constr_compare_fn -&gt;
  'v constr_compare_fn -&gt;
  'v constr_compare_fn

(** [compare_head_gen_with k1 k2 u s f c1 c2] compares [c1] and [c2]
    like [compare_head_gen u s f c1 c2], except that [k1] (resp. [k2])
    is used,rather than {!kind}, to expose the immediate subterms of
    [c1] (resp. [c2]). *)
val compare_head_gen_with :
  ('v -&gt; ('v, 'v, 'sort, 'univs) kind_of_term) -&gt;
  ('v -&gt; ('v, 'v, 'sort, 'univs) kind_of_term) -&gt;
  'univs instance_compare_fn -&gt;
  ('sort -&gt; 'sort -&gt; bool) -&gt;
  'v constr_compare_fn -&gt;
  'v constr_compare_fn

(** [compare_head_gen_leq u s f fle c1 c2] compare [c1] and [c2] using
    [f] to compare the immediate subterms of [c1] of [c2] for
    conversion, [fle] for cumulativity, [u] to compare universe
    instances (the first boolean tells if they belong to a Constant.t),
    [s] to compare sorts for for subtyping; Cast's, binders name and
    Cases annotations are not taken into account *)

val compare_head_gen_leq : Univ.Instance.t instance_compare_fn -&gt;
  (Sorts.t -&gt; Sorts.t -&gt; bool) -&gt;
  constr constr_compare_fn -&gt;
  constr constr_compare_fn -&gt;
  constr constr_compare_fn

(** {6 Hashconsing} *)

val hash : constr -&gt; int
val case_info_hash : case_info -&gt; int

(*********************************************************************)

val hcons : constr -&gt; constr

val debug_print : constr -&gt; Pp.t
val debug_print_fix : ('a -&gt; Pp.t) -&gt; ('a, 'a) pfixpoint -&gt; Pp.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constr.mli"><code>Constr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition pconstant := Univ.puniverses Names.Constant.t.

Definition pinductive := Univ.puniverses Names.inductive.

Definition pconstructor := Univ.puniverses Names.constructor.

Definition metavariable := Z.

Inductive case_style : Set :=
| LetStyle : case_style
| IfStyle : case_style
| LetPatternStyle : case_style
| MatchStyle : case_style
| RegularStyle : case_style.

Module case_printing.
  Record record := {
    ind_tags : list bool;
    cstr_tags : array (list bool);
    style : case_style }.
  Definition with_ind_tags (r : record) ind_tags : record :=
    {| ind_tags := ind_tags; cstr_tags := cstr_tags r; style := style r |}.
  Definition with_cstr_tags (r : record) cstr_tags : record :=
    {| ind_tags := ind_tags r; cstr_tags := cstr_tags; style := style r |}.
  Definition with_style (r : record) style : record :=
    {| ind_tags := ind_tags r; cstr_tags := cstr_tags r; style := style |}.
End case_printing.
Definition case_printing := case_printing.record.

Module case_info.
  Record record := {
    ci_ind : Names.inductive;
    ci_npar : Z;
    ci_cstr_ndecls : array Z;
    ci_cstr_nargs : array Z;
    ci_relevance : Sorts.relevance;
    ci_pp_info : case_printing }.
  Definition with_ci_ind (r : record) ci_ind : record :=
    {| ci_ind := ci_ind; ci_npar := ci_npar r;
      ci_cstr_ndecls := ci_cstr_ndecls r; ci_cstr_nargs := ci_cstr_nargs r;
      ci_relevance := ci_relevance r; ci_pp_info := ci_pp_info r |}.
  Definition with_ci_npar (r : record) ci_npar : record :=
    {| ci_ind := ci_ind r; ci_npar := ci_npar;
      ci_cstr_ndecls := ci_cstr_ndecls r; ci_cstr_nargs := ci_cstr_nargs r;
      ci_relevance := ci_relevance r; ci_pp_info := ci_pp_info r |}.
  Definition with_ci_cstr_ndecls (r : record) ci_cstr_ndecls : record :=
    {| ci_ind := ci_ind r; ci_npar := ci_npar r;
      ci_cstr_ndecls := ci_cstr_ndecls; ci_cstr_nargs := ci_cstr_nargs r;
      ci_relevance := ci_relevance r; ci_pp_info := ci_pp_info r |}.
  Definition with_ci_cstr_nargs (r : record) ci_cstr_nargs : record :=
    {| ci_ind := ci_ind r; ci_npar := ci_npar r;
      ci_cstr_ndecls := ci_cstr_ndecls r; ci_cstr_nargs := ci_cstr_nargs;
      ci_relevance := ci_relevance r; ci_pp_info := ci_pp_info r |}.
  Definition with_ci_relevance (r : record) ci_relevance : record :=
    {| ci_ind := ci_ind r; ci_npar := ci_npar r;
      ci_cstr_ndecls := ci_cstr_ndecls r; ci_cstr_nargs := ci_cstr_nargs r;
      ci_relevance := ci_relevance; ci_pp_info := ci_pp_info r |}.
  Definition with_ci_pp_info (r : record) ci_pp_info : record :=
    {| ci_ind := ci_ind r; ci_npar := ci_npar r;
      ci_cstr_ndecls := ci_cstr_ndecls r; ci_cstr_nargs := ci_cstr_nargs r;
      ci_relevance := ci_relevance r; ci_pp_info := ci_pp_info |}.
End case_info.
Definition case_info := case_info.record.

Parameter t : Set.

Definition constr := t.

Definition types := constr.

Parameter mkRel : Z -&gt; constr.

Parameter mkVar : Names.Id.t -&gt; constr.

Parameter mkInt : Uint63.t -&gt; constr.

Parameter mkMeta : metavariable -&gt; constr.

Definition existential := Evar.t * array constr.

Parameter mkEvar : existential -&gt; constr.

Parameter mkSort : Sorts.t -&gt; types.

Parameter mkSProp : types.

Parameter mkProp : types.

Parameter mkSet : types.

Parameter mkType : Univ.Universe.t -&gt; types.

Inductive cast_kind : Set :=
| VMcast : cast_kind
| NATIVEcast : cast_kind
| DEFAULTcast : cast_kind
| REVERTcast : cast_kind.

Parameter mkCast : constr * cast_kind * constr -&gt; constr.

Parameter mkProd : Context.binder_annot Names.Name.t * types * types -&gt; types.

Parameter mkLambda :
  Context.binder_annot Names.Name.t * types * constr -&gt; constr.

Parameter mkLetIn :
  Context.binder_annot Names.Name.t * constr * types * constr -&gt; constr.

Parameter mkApp : constr * array constr -&gt; constr.

Parameter map_puniverses : forall {a b : Set},
  (a -&gt; b) -&gt; Univ.puniverses a -&gt; Univ.puniverses b.

Parameter mkConst : Names.Constant.t -&gt; constr.

Parameter mkConstU : pconstant -&gt; constr.

Parameter mkProj : Names.Projection.t * constr -&gt; constr.

Parameter mkInd : Names.inductive -&gt; constr.

Parameter mkIndU : pinductive -&gt; constr.

Parameter mkConstruct : Names.constructor -&gt; constr.

Parameter mkConstructU : pconstructor -&gt; constr.

Parameter mkConstructUi : pinductive * Z -&gt; constr.

Parameter mkRef : Univ.puniverses Names.GlobRef.t -&gt; constr.

Parameter mkCase : case_info * constr * constr * array constr -&gt; constr.

Definition prec_declaration (constr types : Set) :=
  array (Context.binder_annot Names.Name.t) * array types * array constr.

Definition pfixpoint (constr types : Set) :=
  (array Z * Z) * prec_declaration constr types.

Definition pcofixpoint (constr types : Set) :=
  Z * prec_declaration constr types.

Definition rec_declaration := prec_declaration constr types.

Definition fixpoint := pfixpoint constr types.

Parameter mkFix : fixpoint -&gt; constr.

Definition cofixpoint := pcofixpoint constr types.

Parameter mkCoFix : cofixpoint -&gt; constr.

Definition pexistential (constr : Set) := Evar.t * array constr.

Inductive kind_of_term (constr types sort univs : Set) : Set :=
| Rel : Z -&gt; kind_of_term constr types sort univs
| Var : Names.Id.t -&gt; kind_of_term constr types sort univs
| Meta : metavariable -&gt; kind_of_term constr types sort univs
| Evar : pexistential constr -&gt; kind_of_term constr types sort univs
| Sort : sort -&gt; kind_of_term constr types sort univs
| Cast : constr -&gt; cast_kind -&gt; types -&gt; kind_of_term constr types sort univs
| Prod :
  Context.binder_annot Names.Name.t -&gt; types -&gt; types -&gt;
  kind_of_term constr types sort univs
| Lambda :
  Context.binder_annot Names.Name.t -&gt; types -&gt; constr -&gt;
  kind_of_term constr types sort univs
| LetIn :
  Context.binder_annot Names.Name.t -&gt; constr -&gt; types -&gt; constr -&gt;
  kind_of_term constr types sort univs
| App : constr -&gt; array constr -&gt; kind_of_term constr types sort univs
| Const : Names.Constant.t * univs -&gt; kind_of_term constr types sort univs
| Ind : Names.inductive * univs -&gt; kind_of_term constr types sort univs
| Construct : Names.constructor * univs -&gt; kind_of_term constr types sort univs
| Case :
  case_info -&gt; constr -&gt; constr -&gt; array constr -&gt;
  kind_of_term constr types sort univs
| Fix : pfixpoint constr types -&gt; kind_of_term constr types sort univs
| CoFix : pcofixpoint constr types -&gt; kind_of_term constr types sort univs
| Proj : Names.Projection.t -&gt; constr -&gt; kind_of_term constr types sort univs
| Int : Uint63.t -&gt; kind_of_term constr types sort univs.

Arguments Rel {_ _ _ _}.
Arguments Var {_ _ _ _}.
Arguments Meta {_ _ _ _}.
Arguments Evar {_ _ _ _}.
Arguments Sort {_ _ _ _}.
Arguments Cast {_ _ _ _}.
Arguments Prod {_ _ _ _}.
Arguments Lambda {_ _ _ _}.
Arguments LetIn {_ _ _ _}.
Arguments App {_ _ _ _}.
Arguments Const {_ _ _ _}.
Arguments Ind {_ _ _ _}.
Arguments Construct {_ _ _ _}.
Arguments Case {_ _ _ _}.
Arguments Fix {_ _ _ _}.
Arguments CoFix {_ _ _ _}.
Arguments Proj {_ _ _ _}.
Arguments Int {_ _ _ _}.

Parameter kind : constr -&gt; kind_of_term constr types Sorts.t Univ.Instance.t.

Parameter of_kind : kind_of_term constr types Sorts.t Univ.Instance.t -&gt; constr.

Parameter kind_nocast_gen : forall {sort univs v : Set},
  (v -&gt; kind_of_term v v sort univs) -&gt; v -&gt; kind_of_term v v sort univs.

Parameter kind_nocast :
  constr -&gt; kind_of_term constr types Sorts.t Univ.Instance.t.

Parameter isRel : constr -&gt; bool.

Parameter isRelN : Z -&gt; constr -&gt; bool.

Parameter isVar : constr -&gt; bool.

Parameter isVarId : Names.Id.t -&gt; constr -&gt; bool.

Parameter isInd : constr -&gt; bool.

Parameter isEvar : constr -&gt; bool.

Parameter isMeta : constr -&gt; bool.

Parameter isEvar_or_Meta : constr -&gt; bool.

Parameter isSort : constr -&gt; bool.

Parameter isCast : constr -&gt; bool.

Parameter isApp : constr -&gt; bool.

Parameter isLambda : constr -&gt; bool.

Parameter isLetIn : constr -&gt; bool.

Parameter isProd : constr -&gt; bool.

Parameter isConst : constr -&gt; bool.

Parameter isConstruct : constr -&gt; bool.

Parameter isFix : constr -&gt; bool.

Parameter isCoFix : constr -&gt; bool.

Parameter isCase : constr -&gt; bool.

Parameter isProj : constr -&gt; bool.

Parameter is_Prop : constr -&gt; bool.

Parameter is_Set : constr -&gt; bool.

Parameter isprop : constr -&gt; bool.

Parameter is_Type : constr -&gt; bool.

Parameter iskind : constr -&gt; bool.

Parameter is_small : Sorts.t -&gt; bool.

(* exception DestKO *)

Parameter destRel : constr -&gt; Z.

Parameter destMeta : constr -&gt; metavariable.

Parameter destVar : constr -&gt; Names.Id.t.

Parameter destSort : constr -&gt; Sorts.t.

Parameter destCast : constr -&gt; constr * cast_kind * constr.

Parameter destProd : types -&gt; Context.binder_annot Names.Name.t * types * types.

Parameter destLambda :
  constr -&gt; Context.binder_annot Names.Name.t * types * constr.

Parameter destLetIn :
  constr -&gt; Context.binder_annot Names.Name.t * constr * types * constr.

Parameter destApp : constr -&gt; constr * array constr.

Parameter decompose_app : constr -&gt; constr * list constr.

Parameter decompose_appvect : constr -&gt; constr * array constr.

Parameter destConst : constr -&gt; Univ.puniverses Names.Constant.t.

Parameter destEvar : constr -&gt; existential.

Parameter destInd : constr -&gt; Univ.puniverses Names.inductive.

Parameter destConstruct : constr -&gt; Univ.puniverses Names.constructor.

Parameter destCase : constr -&gt; case_info * constr * constr * array constr.

Parameter destProj : constr -&gt; Names.Projection.t * constr.

Parameter destFix : constr -&gt; fixpoint.

Parameter destCoFix : constr -&gt; cofixpoint.

Parameter destRef : constr -&gt; Univ.puniverses Names.GlobRef.t.

Parameter equal : constr -&gt; constr -&gt; bool.

Parameter eq_constr_univs : UGraph.check_function constr.

Parameter leq_constr_univs : UGraph.check_function constr.

Parameter eq_constr_univs_infer :
  UGraph.t -&gt; constr -&gt; constr -&gt; Univ.constrained bool.

Parameter leq_constr_univs_infer :
  UGraph.t -&gt; constr -&gt; constr -&gt; Univ.constrained bool.

Parameter eq_constr_nounivs : constr -&gt; constr -&gt; bool.

Parameter compare : constr -&gt; constr -&gt; Z.

Definition rel_declaration := Context.Rel.Declaration.pt constr types.

Definition named_declaration := Context.Named.Declaration.pt constr types.

Definition compacted_declaration :=
  Context.Compacted.Declaration.pt constr types.

Definition rel_context := list rel_declaration.

Definition named_context := list named_declaration.

Definition compacted_context := list compacted_declaration.

Parameter exliftn : Esubst.lift -&gt; constr -&gt; constr.

Parameter liftn : Z -&gt; Z -&gt; constr -&gt; constr.

Parameter lift : Z -&gt; constr -&gt; constr.

Parameter map_under_context : (constr -&gt; constr) -&gt; Z -&gt; constr -&gt; constr.

Parameter map_branches :
  (constr -&gt; constr) -&gt; case_info -&gt; array constr -&gt; array constr.

Parameter map_return_predicate :
  (constr -&gt; constr) -&gt; case_info -&gt; constr -&gt; constr.

Parameter map_under_context_with_binders : forall {a : Set},
  (a -&gt; a) -&gt; (a -&gt; constr -&gt; constr) -&gt; a -&gt; Z -&gt; constr -&gt; constr.

Parameter map_branches_with_binders : forall {a : Set},
  (a -&gt; a) -&gt; (a -&gt; constr -&gt; constr) -&gt; a -&gt; case_info -&gt; array constr -&gt;
  array constr.

Parameter map_return_predicate_with_binders : forall {a : Set},
  (a -&gt; a) -&gt; (a -&gt; constr -&gt; constr) -&gt; a -&gt; case_info -&gt; constr -&gt; constr.

Parameter map_under_context_with_full_binders : forall {a : Set},
  (Context.Rel.Declaration.pt constr constr -&gt; a -&gt; a) -&gt;
  (a -&gt; constr -&gt; constr) -&gt; a -&gt; Z -&gt; constr -&gt; constr.

Parameter map_branches_with_full_binders : forall {a : Set},
  (Context.Rel.Declaration.pt constr constr -&gt; a -&gt; a) -&gt;
  (a -&gt; constr -&gt; constr) -&gt; a -&gt; case_info -&gt; array constr -&gt; array constr.

Parameter map_return_predicate_with_full_binders : forall {a : Set},
  (Context.Rel.Declaration.pt constr constr -&gt; a -&gt; a) -&gt;
  (a -&gt; constr -&gt; constr) -&gt; a -&gt; case_info -&gt; constr -&gt; constr.

Parameter fold : forall {a : Set}, (a -&gt; constr -&gt; a) -&gt; a -&gt; constr -&gt; a.

Parameter fold_with_full_binders : forall {a b : Set},
  (rel_declaration -&gt; a -&gt; a) -&gt; (a -&gt; b -&gt; constr -&gt; b) -&gt; a -&gt; b -&gt; constr -&gt;
  b.

Parameter map : (constr -&gt; constr) -&gt; constr -&gt; constr.

Parameter map_user_view : (constr -&gt; constr) -&gt; constr -&gt; constr.

Parameter fold_map : forall {a : Set},
  (a -&gt; constr -&gt; a * constr) -&gt; a -&gt; constr -&gt; a * constr.

Parameter map_with_binders : forall {a : Set},
  (a -&gt; a) -&gt; (a -&gt; constr -&gt; constr) -&gt; a -&gt; constr -&gt; constr.

Parameter iter : (constr -&gt; unit) -&gt; constr -&gt; unit.

Parameter iter_with_binders : forall {a : Set},
  (a -&gt; a) -&gt; (a -&gt; constr -&gt; unit) -&gt; a -&gt; constr -&gt; unit.

Parameter fold_constr_with_binders : forall {a b : Set},
  (a -&gt; a) -&gt; (a -&gt; b -&gt; constr -&gt; b) -&gt; a -&gt; b -&gt; constr -&gt; b.

Definition constr_compare_fn (constr : Set) := Z -&gt; constr -&gt; constr -&gt; bool.

Parameter compare_head : constr_compare_fn constr -&gt; constr_compare_fn constr.

Definition instance_compare_fn (univs : Set) :=
  Names.GlobRef.t -&gt; Z -&gt; univs -&gt; univs -&gt; bool.

Parameter compare_head_gen :
  instance_compare_fn Univ.Instance.t -&gt; (Sorts.t -&gt; Sorts.t -&gt; bool) -&gt;
  constr_compare_fn constr -&gt; constr_compare_fn constr.

Parameter compare_head_gen_leq_with : forall {sort univs v : Set},
  (v -&gt; kind_of_term v v sort univs) -&gt; (v -&gt; kind_of_term v v sort univs) -&gt;
  instance_compare_fn univs -&gt; (sort -&gt; sort -&gt; bool) -&gt; constr_compare_fn v -&gt;
  constr_compare_fn v -&gt; constr_compare_fn v.

Parameter compare_head_gen_with : forall {sort univs v : Set},
  (v -&gt; kind_of_term v v sort univs) -&gt; (v -&gt; kind_of_term v v sort univs) -&gt;
  instance_compare_fn univs -&gt; (sort -&gt; sort -&gt; bool) -&gt; constr_compare_fn v -&gt;
  constr_compare_fn v.

Parameter compare_head_gen_leq :
  instance_compare_fn Univ.Instance.t -&gt; (Sorts.t -&gt; Sorts.t -&gt; bool) -&gt;
  constr_compare_fn constr -&gt; constr_compare_fn constr -&gt;
  constr_compare_fn constr.

Parameter hash : constr -&gt; Z.

Parameter case_info_hash : case_info -&gt; Z.

Parameter hcons : constr -&gt; constr.

Parameter debug_print : constr -&gt; Pp.t.

Parameter debug_print_fix : forall {a : Set},
  (a -&gt; Pp.t) -&gt; pfixpoint a a -&gt; Pp.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="context.ml">
  <div style="margin: 20px;">
    <h3>Context</h3>
    <ul>
      <li>OCaml size: 497 lines</li>
      <li>Coq size: 642 lines (+29% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#context.ml"><code>context.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jean-Christophe FilliÃ¢tre out of names.ml as part of the
   rebuilding of Coq around a purely functional abstract type-checker,
   Aug 1999 *)
(* Miscellaneous extensions, restructurations and bug-fixes by Hugo
   Herbelin and Bruno Barras *)

(* This file defines types and combinators regarding indexes-based and
   names-based contexts *)

(** The modules defined below represent a {e local context}
    as defined by Chapter 4 in the Reference Manual:

    A {e local context} is an ordered list of of {e local declarations}
    of names that we call {e variables}.

    A {e local declaration} of some variable can be either:
    - a {e local assumption}, or
    - a {e local definition}.
*)

open Util
open Names

type 'a binder_annot = { binder_name : 'a; binder_relevance : Sorts.relevance }

let eq_annot eq {binder_name=na1;binder_relevance=r1} {binder_name=na2;binder_relevance=r2} =
  eq na1 na2 &amp;&amp; Sorts.relevance_equal r1 r2

let hash_annot h {binder_name=n;binder_relevance=r} =
  Hashset.Combine.combinesmall (Sorts.relevance_hash r) (h n)

let map_annot f {binder_name=na;binder_relevance} =
  {binder_name=f na;binder_relevance}

let make_annot x r = {binder_name=x;binder_relevance=r}

let binder_name x = x.binder_name
let binder_relevance x = x.binder_relevance

let annotR x = make_annot x Sorts.Relevant

let nameR x = annotR (Name x)
let anonR = annotR Anonymous

(** Representation of contexts that can capture anonymous as well as non-anonymous variables.
    Individual declarations are then designated by de Bruijn indexes. *)
module Rel =
struct
  (** Representation of {e local declarations}. *)
  module Declaration =
  struct
    (* local declaration *)
    type ('constr, 'types) pt =
      | LocalAssum of Name.t binder_annot * 'types            (** name, type *)
      | LocalDef of Name.t binder_annot * 'constr * 'types   (** name, value, type *)

    let get_annot = function
      | LocalAssum (na,_) | LocalDef (na,_,_) -&gt; na

    (** Return the name bound by a given declaration. *)
    let get_name x = (get_annot x).binder_name

    (** Return [Some value] for local-declarations and [None] for local-assumptions. *)
    let get_value = function
      | LocalAssum _ -&gt; None
      | LocalDef (_,v,_) -&gt; Some v

    (** Return the type of the name bound by a given declaration. *)
    let get_type = function
      | LocalAssum (_,ty)
      | LocalDef (_,_,ty) -&gt; ty

    let get_relevance x = (get_annot x).binder_relevance

    (** Set the name that is bound by a given declaration. *)
    let set_name na = function
      | LocalAssum (x,ty) -&gt; LocalAssum ({x with binder_name=na}, ty)
      | LocalDef (x,v,ty) -&gt; LocalDef ({x with binder_name=na}, v, ty)

    (** Set the type of the bound variable in a given declaration. *)
    let set_type ty = function
      | LocalAssum (na,_) -&gt; LocalAssum (na, ty)
      | LocalDef (na,v,_) -&gt; LocalDef (na, v, ty)

    (** Return [true] iff a given declaration is a local assumption. *)
    let is_local_assum = function
      | LocalAssum _ -&gt; true
      | LocalDef _ -&gt; false

    (** Return [true] iff a given declaration is a local definition. *)
    let is_local_def = function
      | LocalAssum _ -&gt; false
      | LocalDef _ -&gt; true

    (** Check whether any term in a given declaration satisfies a given predicate. *)
    let exists f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v || f ty

      (** Check whether all terms in a given declaration satisfy a given predicate. *)
    let for_all f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v &amp;&amp; f ty

    (** Check whether the two given declarations are equal. *)
    let equal eq decl1 decl2 =
      match decl1, decl2 with
      | LocalAssum (n1,ty1), LocalAssum (n2, ty2) -&gt;
          eq_annot Name.equal n1 n2 &amp;&amp; eq ty1 ty2
      | LocalDef (n1,v1,ty1), LocalDef (n2,v2,ty2) -&gt;
          eq_annot Name.equal n1 n2 &amp;&amp; eq v1 v2 &amp;&amp; eq ty1 ty2
      | _ -&gt;
          false

    (** Map the name bound by a given declaration. *)
    let map_name f x =
      let na = get_name x in
      let na' = f na in
      if na == na' then x else set_name na' x

    (** For local assumptions, this function returns the original local assumptions.
        For local definitions, this function maps the value in the local definition. *)
    let map_value f = function
      | LocalAssum _ as decl -&gt; decl
      | LocalDef (na, v, t) as decl -&gt;
          let v' = f v in
          if v == v' then decl else LocalDef (na, v', t)

    (** Map the type of the name bound by a given declaration. *)
    let map_type f = function
      | LocalAssum (na, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (na, ty')
      | LocalDef (na, v, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalDef (na, v, ty')

    (** Map all terms in a given declaration. *)
    let map_constr f = function
      | LocalAssum (na, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (na, ty')
      | LocalDef (na, v, ty) as decl -&gt;
          let v' = f v in
          let ty' = f ty in
          if v == v' &amp;&amp; ty == ty' then decl else LocalDef (na, v', ty')

    let map_constr_het f = function
      | LocalAssum (na, ty) -&gt;
          let ty' = f ty in
          LocalAssum (na, ty')
      | LocalDef (na, v, ty) -&gt;
          let v' = f v in
          let ty' = f ty in
          LocalDef (na, v', ty')

    (** Perform a given action on all terms in a given declaration. *)
    let iter_constr f = function
      | LocalAssum (_,ty) -&gt; f ty
      | LocalDef (_,v,ty) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">f v; f ty</abbr>

    (** Reduce all terms in a given declaration to a single value. *)
    let fold_constr f decl acc =
      match decl with
      | LocalAssum (_n,ty) -&gt; f ty acc
      | LocalDef (_n,v,ty) -&gt; f ty (f v acc)

    let to_tuple = function
      | LocalAssum (na, ty) -&gt; na, None, ty
      | LocalDef (na, v, ty) -&gt; na, Some v, ty

    let drop_body = function
      | LocalAssum _ as d -&gt; d
      | LocalDef (na, _v, ty) -&gt; LocalAssum (na, ty)

  end

  (** Rel-context is represented as a list of declarations.
      Inner-most declarations are at the beginning of the list.
      Outer-most declarations are at the end of the list. *)
  type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

  (** empty rel-context *)
  let empty = []

  (** Return a new rel-context enriched by with a given inner-most declaration. *)
  let add d ctx = d :: ctx

  (** Return the number of {e local declarations} in a given context. *)
  let length = List.length

  (** [extended_rel_list n Î] builds an instance [args] such that [Î,Î â¢ args:Î]
      with n = |Î| and with the local definitions of [Î] skipped in
      [args]. Example: for [x:T,y:=c,z:U] and [n]=2, it gives [Rel 5, Rel 3]. *)
  let nhyps ctx =
    let open Declaration in
    let rec nhyps acc = function
      | [] -&gt; acc
      | LocalAssum _ :: hyps -&gt; nhyps (succ acc) hyps
      | LocalDef _ :: hyps -&gt; nhyps acc hyps
    in
    nhyps 0 ctx

  (** Return a declaration designated by a given de Bruijn index.
      @raise Not_found if the designated de Bruijn index is not present in the designated rel-context. *)
  let rec lookup n ctx =
    match n, ctx with
    | 1, decl :: _ -&gt; decl
    | n, _ :: sign -&gt; lookup (n-1) sign
    | _, []        -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

  (** Check whether given two rel-contexts are equal. *)
  let equal eq l = List.equal (fun c -&gt; Declaration.equal eq c) l

  (** Map all terms in a given rel-context. *)
  let map f = List.Smart.map (Declaration.map_constr f)

  (** Perform a given action on every declaration in a given rel-context. *)
  let iter f = List.iter (Declaration.iter_constr f)

  (** Reduce all terms in a given rel-context to a single value.
      Innermost declarations are processed first. *)
  let fold_inside f ~init = List.fold_left f init

  (** Reduce all terms in a given rel-context to a single value.
      Outermost declarations are processed first. *)
  let fold_outside f l ~init = List.fold_right f l init

  (** Map a given rel-context to a list where each {e local assumption} is mapped to [true]
      and each {e local definition} is mapped to [false]. *)
  let to_tags l =
    let rec aux l = function
      | [] -&gt; l
      | Declaration.LocalDef _ :: ctx -&gt; aux (true::l) ctx
      | Declaration.LocalAssum _ :: ctx -&gt; aux (false::l) ctx
    in aux [] l

  let drop_bodies l = List.Smart.map Declaration.drop_body l

  (** [extended_list n Î] builds an instance [args] such that [Î,Î â¢ args:Î]
      with n = |Î| and with the {e local definitions} of [Î] skipped in
      [args]. Example: for [x:T, y:=c, z:U] and [n]=2, it gives [Rel 5, Rel 3]. *)
  let to_extended_list mk n l =
    let rec reln l p = function
      | Declaration.LocalAssum _ :: hyps -&gt; reln (mk (n+p) :: l) (p+1) hyps
      | Declaration.LocalDef _ :: hyps -&gt; reln l (p+1) hyps
      | [] -&gt; l
    in
    reln [] 1 l

  (** [extended_vect n Î] does the same, returning instead an array. *)
  let to_extended_vect mk n hyps = Array.of_list (to_extended_list mk n hyps)
end

(** This module represents contexts that can capture non-anonymous variables.
    Individual declarations are then designated by the identifiers they bind. *)
module Named =
struct
  (** Representation of {e local declarations}. *)
  module Declaration =
  struct
    (** local declaration *)
    type ('constr, 'types) pt =
      | LocalAssum of Id.t binder_annot * 'types             (** identifier, type *)
      | LocalDef of Id.t binder_annot * 'constr * 'types    (** identifier, value, type *)

    let get_annot = function
      | LocalAssum (na,_) | LocalDef (na,_,_) -&gt; na

    (** Return the identifier bound by a given declaration. *)
    let get_id x = (get_annot x).binder_name

    (** Return [Some value] for local-declarations and [None] for local-assumptions. *)
    let get_value = function
      | LocalAssum _ -&gt; None
      | LocalDef (_,v,_) -&gt; Some v

    (** Return the type of the name bound by a given declaration. *)
    let get_type = function
      | LocalAssum (_,ty)
      | LocalDef (_,_,ty) -&gt; ty

    let get_relevance x = (get_annot x).binder_relevance

    (** Set the identifier that is bound by a given declaration. *)
    let set_id id =
      let set x = {x with binder_name = id} in
      function
      | LocalAssum (x,ty) -&gt; LocalAssum (set x, ty)
      | LocalDef (x, v, ty) -&gt; LocalDef (set x, v, ty)

    (** Set the type of the bound variable in a given declaration. *)
    let set_type ty = function
      | LocalAssum (id,_) -&gt; LocalAssum (id, ty)
      | LocalDef (id,v,_) -&gt; LocalDef (id, v, ty)

    (** Return [true] iff a given declaration is a local assumption. *)
    let is_local_assum = function
      | LocalAssum _ -&gt; true
      | LocalDef _ -&gt; false

    (** Return [true] iff a given declaration is a local definition. *)
    let is_local_def = function
      | LocalDef _ -&gt; true
      | LocalAssum _ -&gt; false

    (** Check whether any term in a given declaration satisfies a given predicate. *)
    let exists f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v || f ty

    (** Check whether all terms in a given declaration satisfy a given predicate. *)
    let for_all f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; f v &amp;&amp; f ty

    (** Check whether the two given declarations are equal. *)
    let equal eq decl1 decl2 =
      match decl1, decl2 with
      | LocalAssum (id1, ty1), LocalAssum (id2, ty2) -&gt;
          eq_annot Id.equal id1 id2 &amp;&amp; eq ty1 ty2
      | LocalDef (id1, v1, ty1), LocalDef (id2, v2, ty2) -&gt;
          eq_annot Id.equal id1 id2 &amp;&amp; eq v1 v2 &amp;&amp; eq ty1 ty2
      | _ -&gt;
          false

    (** Map the identifier bound by a given declaration. *)
    let map_id f x =
      let id = get_id x in
      let id' = f id in
      if id == id' then x else set_id id' x

    (** For local assumptions, this function returns the original local assumptions.
        For local definitions, this function maps the value in the local definition. *)
    let map_value f = function
      | LocalAssum _ as decl -&gt; decl
      | LocalDef (na, v, t) as decl -&gt;
          let v' = f v in
          if v == v' then decl else LocalDef (na, v', t)

    (** Map the type of the name bound by a given declaration. *)
    let map_type f = function
      | LocalAssum (id, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (id, ty')
      | LocalDef (id, v, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalDef (id, v, ty')

    (** Map all terms in a given declaration. *)
    let map_constr f = function
      | LocalAssum (id, ty) as decl -&gt;
          let ty' = f ty in
          if ty == ty' then decl else LocalAssum (id, ty')
      | LocalDef (id, v, ty) as decl -&gt;
          let v' = f v in
          let ty' = f ty in
          if v == v' &amp;&amp; ty == ty' then decl else LocalDef (id, v', ty')

    (** Perform a given action on all terms in a given declaration. *)
    let iter_constr f = function
      | LocalAssum (_, ty) -&gt; f ty
      | LocalDef (_, v, ty) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">f v; f ty</abbr>

    (** Reduce all terms in a given declaration to a single value. *)
    let fold_constr f decl a =
      match decl with
      | LocalAssum (_, ty) -&gt; f ty a
      | LocalDef (_, v, ty) -&gt; a |&gt; f v |&gt; f ty

    let to_tuple = function
      | LocalAssum (id, ty) -&gt; id, None, ty
      | LocalDef (id, v, ty) -&gt; id, Some v, ty

    let of_tuple = function
      | id, None, ty -&gt; LocalAssum (id, ty)
      | id, Some v, ty -&gt; LocalDef (id, v, ty)

    let drop_body = function
      | LocalAssum _ as d -&gt; d
      | LocalDef (id, _v, ty) -&gt; LocalAssum (id, ty)

    let of_rel_decl f = function
      | Rel.Declaration.LocalAssum (na,t) -&gt;
          LocalAssum (map_annot f na, t)
      | Rel.Declaration.LocalDef (na,v,t) -&gt;
          LocalDef (map_annot f na, v, t)

    let to_rel_decl =
      let name x = {binder_name=Name x.binder_name;binder_relevance=x.binder_relevance} in
      function
      | LocalAssum (id,t) -&gt;
          Rel.Declaration.LocalAssum (name id, t)
      | LocalDef (id,v,t) -&gt;
          Rel.Declaration.LocalDef (name id,v,t)
  end

  (** Named-context is represented as a list of declarations.
      Inner-most declarations are at the beginning of the list.
      Outer-most declarations are at the end of the list. *)
  type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

  (** empty named-context *)
  let empty = []

  (** empty named-context *)
  let add d ctx = d :: ctx

  (** Return the number of {e local declarations} in a given named-context. *)
  let length = List.length

(** Return a declaration designated by a given identifier
    @raise Not_found if the designated identifier is not present in the designated named-context. *)
  let rec lookup id = function
    | decl :: _ when Id.equal id (Declaration.get_id decl) -&gt; decl
    | _ :: sign -&gt; lookup id sign
    | [] -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

  (** Check whether given two named-contexts are equal. *)
  let equal eq l = List.equal (fun c -&gt; Declaration.equal eq c) l

  (** Map all terms in a given named-context. *)
  let map f = List.Smart.map (Declaration.map_constr f)

  (** Perform a given action on every declaration in a given named-context. *)
  let iter f = List.iter (Declaration.iter_constr f)

  (** Reduce all terms in a given named-context to a single value.
      Innermost declarations are processed first. *)
  let fold_inside f ~init = List.fold_left f init

  (** Reduce all terms in a given named-context to a single value.
      Outermost declarations are processed first. *)
  let fold_outside f l ~init = List.fold_right f l init

  (** Return the set of all identifiers bound in a given named-context. *)
  let to_vars l =
    List.fold_left (fun accu decl -&gt; Id.Set.add (Declaration.get_id decl) accu) Id.Set.empty l

  let drop_bodies l = List.Smart.map Declaration.drop_body l

  (** [instance_from_named_context Î©] builds an instance [args] such
      that [Î© â¢ args:Î©] where [Î©] is a named context and with the local
      definitions of [Î©] skipped. Example: for [id1:T,id2:=c,id3:U], it
      gives [Var id1, Var id3]. All [idj] are supposed distinct. *)
  let to_instance mk l =
    let filter = function
      | Declaration.LocalAssum (id, _) -&gt; Some (mk id.binder_name)
      | _ -&gt; None
    in
    List.map_filter filter l
end

module Compacted =
  struct
    module Declaration =
      struct
        type ('constr, 'types) pt =
          | LocalAssum of Id.t binder_annot list * 'types
          | LocalDef of Id.t binder_annot list * 'constr * 'types

        let map_constr f = function
          | LocalAssum (ids, ty) as decl -&gt;
             let ty' = f ty in
             if ty == ty' then decl else LocalAssum (ids, ty')
          | LocalDef (ids, c, ty) as decl -&gt;
             let ty' = f ty in
             let c' = f c in
             if c == c' &amp;&amp; ty == ty' then decl else LocalDef (ids,c',ty')

        let of_named_decl = function
          | Named.Declaration.LocalAssum (id,t) -&gt;
              LocalAssum ([id],t)
          | Named.Declaration.LocalDef (id,v,t) -&gt;
              LocalDef ([id],v,t)

        let to_named_context = function
          | LocalAssum (ids, t) -&gt;
             List.map (fun id -&gt; Named.Declaration.LocalAssum (id,t)) ids
          | LocalDef (ids, v, t) -&gt;
             List.map (fun id -&gt; Named.Declaration.LocalDef (id,v,t)) ids
      end

    type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

    let fold f l ~init = List.fold_right f l init
  end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#context.ml"><code>Context.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Module binder_annot.
  Record record {a : Set} := {
    binder_name : a;
    binder_relevance : Sorts.relevance }.
  Arguments record : clear implicits.
  Definition with_binder_name {a_type : Set} (r : record a_type) binder_name
    : record a_type :=
    {| binder_name := binder_name; binder_relevance := binder_relevance r |}.
  Definition with_binder_relevance {a_type : Set} (r : record a_type)
    binder_relevance : record a_type :=
    {| binder_name := binder_name r; binder_relevance := binder_relevance |}.
End binder_annot.
Definition binder_annot := binder_annot.record.

Definition eq_annot {A B : Set}
  (eq : A -&gt; B -&gt; bool) (function_parameter : binder_annot A)
  : binder_annot B -&gt; bool :=
  let '{|
    binder_annot.binder_name := na1; binder_annot.binder_relevance := r1 |} :=
    function_parameter in
  fun function_parameter =&gt;
    let '{|
      binder_annot.binder_name := na2;
        binder_annot.binder_relevance := r2
        |} := function_parameter in
    andb (eq na1 na2) (Sorts.relevance_equal r1 r2).

Definition hash_annot {A : Set}
  (h : A -&gt; Z) (function_parameter : binder_annot A) : Z :=
  let '{|
    binder_annot.binder_name := n; binder_annot.binder_relevance := r |} :=
    function_parameter in
  Hashset.Combine.combinesmall (Sorts.relevance_hash r) (h n).

Definition map_annot {A B : Set}
  (f : A -&gt; B) (function_parameter : binder_annot A) : binder_annot B :=
  let '{|
    binder_annot.binder_name := na;
      binder_annot.binder_relevance := binder_relevance
      |} := function_parameter in
  {| binder_annot.binder_name := f na;
    binder_annot.binder_relevance := binder_relevance |}.

Definition make_annot {A : Set} (x : A) (r : Sorts.relevance)
  : binder_annot A :=
  {| binder_annot.binder_name := x; binder_annot.binder_relevance := r |}.

Definition binder_name {A : Set} (x : binder_annot A) : A :=
  binder_annot.binder_name x.

Definition binder_relevance {A : Set} (x : binder_annot A) : Sorts.relevance :=
  binder_annot.binder_relevance x.

Definition annotR {A : Set} (x : A) : binder_annot A :=
  make_annot x Sorts.Relevant.

Definition nameR (x : Names.Id.t) : binder_annot Names.name :=
  annotR (Names.Name x).

Definition anonR : binder_annot Names.name := annotR Names.Anonymous.

Module Rel.
  Module Declaration.
    Inductive pt (constr types : Set) : Set :=
    | LocalAssum : binder_annot Names.Name.t -&gt; types -&gt; pt constr types
    | LocalDef : binder_annot Names.Name.t -&gt; constr -&gt; types -&gt; pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Definition get_annot {A B : Set} (function_parameter : pt A B)
      : binder_annot Names.Name.t :=
      let 'LocalAssum na _ | LocalDef na _ _ := function_parameter in
      na.
    
    Definition get_name {A B : Set} (x : pt A B) : Names.Name.t :=
      binder_annot.binder_name (get_annot x).
    
    Definition get_value {A B : Set} (function_parameter : pt A B) : option A :=
      match function_parameter with
      | LocalAssum _ _ =&gt; None
      | LocalDef _ v _ =&gt; Some v
      end.
    
    Definition get_type {A B : Set} (function_parameter : pt A B) : B :=
      let 'LocalAssum _ ty | LocalDef _ _ ty := function_parameter in
      ty.
    
    Definition get_relevance {A B : Set} (x : pt A B) : Sorts.relevance :=
      binder_annot.binder_relevance (get_annot x).
    
    Definition set_name {A B : Set}
      (na : Names.Name.t) (function_parameter : pt A B) : pt A B :=
      match function_parameter with
      | LocalAssum x ty =&gt; LocalAssum (binder_annot.with_binder_name x na) ty
      | LocalDef x v ty =&gt; LocalDef (binder_annot.with_binder_name x na) v ty
      end.
    
    Definition set_type {A B C : Set} (ty : A) (function_parameter : pt B C)
      : pt B A :=
      match function_parameter with
      | LocalAssum na _ =&gt; LocalAssum na ty
      | LocalDef na v _ =&gt; LocalDef na v ty
      end.
    
    Definition is_local_assum {A B : Set} (function_parameter : pt A B)
      : bool :=
      match function_parameter with
      | LocalAssum _ _ =&gt; true
      | LocalDef _ _ _ =&gt; false
      end.
    
    Definition is_local_def {A B : Set} (function_parameter : pt A B) : bool :=
      match function_parameter with
      | LocalAssum _ _ =&gt; false
      | LocalDef _ _ _ =&gt; true
      end.
    
    Definition __exists {A : Set} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; orb (f v) (f ty)
      end.
    
    Definition for_all {A : Set} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; andb (f v) (f ty)
      end.
    
    Definition equal {A B : Set}
      (eq : A -&gt; B -&gt; bool) (decl1 : pt A A) (decl2 : pt B B) : bool :=
      match (decl1, decl2) with
      | (LocalAssum n1 ty1, LocalAssum n2 ty2) =&gt;
        andb (eq_annot Name.equal n1 n2) (eq ty1 ty2)
      | (LocalDef n1 v1 ty1, LocalDef n2 v2 ty2) =&gt;
        andb (eq_annot Name.equal n1 n2) (andb (eq v1 v2) (eq ty1 ty2))
      | _ =&gt; false
      end.
    
    Definition map_name {A B : Set}
      (f : Names.Name.t -&gt; Names.Name.t) (x : pt A B) : pt A B :=
      let na := get_name x in
      let na' := f na in
      if Stdlib.op_eqeq na na' then
        x
      else
        set_name na' x.
    
    Definition map_value {A B : Set} (f : A -&gt; A) (function_parameter : pt A B)
      : pt A B :=
      match function_parameter with
      | (LocalAssum _ _) as decl =&gt; decl
      | (LocalDef na v t) as decl =&gt;
        let v' := f v in
        if Stdlib.op_eqeq v v' then
          decl
        else
          LocalDef na v' t
      end.
    
    Definition map_type {A B : Set} (f : A -&gt; A) (function_parameter : pt B A)
      : pt B A :=
      match function_parameter with
      | (LocalAssum na ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eqeq ty ty' then
          decl
        else
          LocalAssum na ty'
      | (LocalDef na v ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eqeq ty ty' then
          decl
        else
          LocalDef na v ty'
      end.
    
    Definition map_constr {A : Set} (f : A -&gt; A) (function_parameter : pt A A)
      : pt A A :=
      match function_parameter with
      | (LocalAssum na ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eqeq ty ty' then
          decl
        else
          LocalAssum na ty'
      | (LocalDef na v ty) as decl =&gt;
        let v' := f v in
        let ty' := f ty in
        if andb (Stdlib.op_eqeq v v') (Stdlib.op_eqeq ty ty') then
          decl
        else
          LocalDef na v' ty'
      end.
    
    Definition map_constr_het {A B : Set}
      (f : A -&gt; B) (function_parameter : pt A A) : pt B B :=
      match function_parameter with
      | LocalAssum na ty =&gt;
        let ty' := f ty in
        LocalAssum na ty'
      | LocalDef na v ty =&gt;
        let v' := f v in
        let ty' := f ty in
        LocalDef na v' ty'
      end.
    
    Definition iter_constr {A B : Set}
      (f : A -&gt; B) (function_parameter : pt A A) : B :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        f ty
      end.
    
    Definition fold_constr {A B : Set}
      (f : A -&gt; B -&gt; B) (decl : pt A A) (acc : B) : B :=
      match decl with
      | LocalAssum _n ty =&gt; f ty acc
      | LocalDef _n v ty =&gt; f ty (f v acc)
      end.
    
    Definition to_tuple {A B : Set} (function_parameter : pt A B)
      : binder_annot Names.Name.t * option A * B :=
      match function_parameter with
      | LocalAssum na ty =&gt; (na, None, ty)
      | LocalDef na v ty =&gt; (na, (Some v), ty)
      end.
    
    Definition drop_body {A B C : Set} (function_parameter : pt A B) : pt C B :=
      match function_parameter with
      | (LocalAssum _ _) as d =&gt; d
      | LocalDef na _v ty =&gt; LocalAssum na ty
      end.
  End Declaration.
  
  Definition pt (constr types : Set) := list (Declaration.pt constr types).
  
  Definition empty {A : Set} : list A := [].
  
  Definition add {A : Set} (d : A) (ctx : list A) : list A := cons d ctx.
  
  Definition length {A : Set} : list A -&gt; Z := (|Util.List|).(CList.ExtS.length).
  
  Definition nhyps {A B : Set} (ctx : list (Declaration.pt A B)) : Z :=
    let fix nhyps {C D : Set}
      (acc : Z) (function_parameter : list (Declaration.pt C D)) {struct acc}
      : Z :=
      match function_parameter with
      | [] =&gt; acc
      | cons (Declaration.LocalAssum _ _) hyps =&gt; nhyps (Z.succ acc) hyps
      | cons (Declaration.LocalDef _ _ _) hyps =&gt; nhyps acc hyps
      end in
    nhyps 0 ctx.
  
  Fixpoint lookup {A : Set} (n : Z) (ctx : list A) {struct n} : A :=
    match (n, ctx) with
    | (1, cons decl _) =&gt; decl
    | (n, cons _ sign) =&gt; lookup (Z.sub n 1) sign
    | (_, []) =&gt; Stdlib.raise extensible_type_value
    end.
  
  Definition equal {A : Set}
    (eq : A -&gt; A -&gt; bool) (l : list (Declaration.pt A A))
    : list (Declaration.pt A A) -&gt; bool :=
    (|Util.List|).(CList.ExtS.equal) (fun c =&gt; Declaration.equal eq c) l.
  
  Definition map {A : Set} (f : A -&gt; A)
    : list (Declaration.pt A A) -&gt; list (Declaration.pt A A) :=
    List.Smart.map (Declaration.map_constr f).
  
  Definition iter {A : Set} (f : A -&gt; unit)
    : list (Declaration.pt A A) -&gt; unit :=
    (|Util.List|).(CList.ExtS.iter) (Declaration.iter_constr f).
  
  Definition fold_inside {A B : Set} (f : A -&gt; B -&gt; A) (init : A)
    : list B -&gt; A := (|Util.List|).(CList.ExtS.fold_left) f init.
  
  Definition fold_outside {A B : Set} (f : A -&gt; B -&gt; B) (l : list A) (init : B)
    : B := (|Util.List|).(CList.ExtS.fold_right) f l init.
  
  Definition to_tags {A B : Set} (l : list (Declaration.pt A B)) : list bool :=
    let fix aux {C D : Set}
      (l : list bool) (function_parameter : list (Declaration.pt C D))
      {struct l} : list bool :=
      match function_parameter with
      | [] =&gt; l
      | cons (Declaration.LocalDef _ _ _) ctx =&gt; aux (cons true l) ctx
      | cons (Declaration.LocalAssum _ _) ctx =&gt; aux (cons false l) ctx
      end in
    aux [] l.
  
  Definition drop_bodies {A B : Set} (l : list (Declaration.pt A B))
    : list (Declaration.pt A B) := List.Smart.map Declaration.drop_body l.
  
  Definition to_extended_list {A B C : Set}
    (mk : Z -&gt; A) (n : Z) (l : list (Declaration.pt B C)) : list A :=
    let fix reln {D E : Set}
      (l : list A) (p : Z) (function_parameter : list (Declaration.pt D E))
      {struct l} : list A :=
      match function_parameter with
      | cons (Declaration.LocalAssum _ _) hyps =&gt;
        reln (cons (mk (Z.add n p)) l) (Z.add p 1) hyps
      | cons (Declaration.LocalDef _ _ _) hyps =&gt; reln l (Z.add p 1) hyps
      | [] =&gt; l
      end in
    reln [] 1 l.
  
  Definition to_extended_vect {A B C : Set}
    (mk : Z -&gt; A) (n : Z) (hyps : list (Declaration.pt B C)) : array A :=
    (|Util.Array|).(CArray.ExtS.of_list) (to_extended_list mk n hyps).
End Rel.

Module Named.
  Module Declaration.
    Inductive pt (constr types : Set) : Set :=
    | LocalAssum : binder_annot Names.Id.t -&gt; types -&gt; pt constr types
    | LocalDef : binder_annot Names.Id.t -&gt; constr -&gt; types -&gt; pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Definition get_annot {A B : Set} (function_parameter : pt A B)
      : binder_annot Names.Id.t :=
      let 'LocalAssum na _ | LocalDef na _ _ := function_parameter in
      na.
    
    Definition get_id {A B : Set} (x : pt A B) : Names.Id.t :=
      binder_annot.binder_name (get_annot x).
    
    Definition get_value {A B : Set} (function_parameter : pt A B) : option A :=
      match function_parameter with
      | LocalAssum _ _ =&gt; None
      | LocalDef _ v _ =&gt; Some v
      end.
    
    Definition get_type {A B : Set} (function_parameter : pt A B) : B :=
      let 'LocalAssum _ ty | LocalDef _ _ ty := function_parameter in
      ty.
    
    Definition get_relevance {A B : Set} (x : pt A B) : Sorts.relevance :=
      binder_annot.binder_relevance (get_annot x).
    
    Definition set_id {A B : Set} (id : Names.Id.t) : pt A B -&gt; pt A B :=
      let set {C : Set} (x : binder_annot C) : binder_annot Names.Id.t :=
        binder_annot.with_binder_name x id in
      fun function_parameter =&gt;
        match function_parameter with
        | LocalAssum x ty =&gt; LocalAssum (set x) ty
        | LocalDef x v ty =&gt; LocalDef (set x) v ty
        end.
    
    Definition set_type {A B C : Set} (ty : A) (function_parameter : pt B C)
      : pt B A :=
      match function_parameter with
      | LocalAssum id _ =&gt; LocalAssum id ty
      | LocalDef id v _ =&gt; LocalDef id v ty
      end.
    
    Definition is_local_assum {A B : Set} (function_parameter : pt A B)
      : bool :=
      match function_parameter with
      | LocalAssum _ _ =&gt; true
      | LocalDef _ _ _ =&gt; false
      end.
    
    Definition is_local_def {A B : Set} (function_parameter : pt A B) : bool :=
      match function_parameter with
      | LocalDef _ _ _ =&gt; true
      | LocalAssum _ _ =&gt; false
      end.
    
    Definition __exists {A : Set} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; orb (f v) (f ty)
      end.
    
    Definition for_all {A : Set} (f : A -&gt; bool) (function_parameter : pt A A)
      : bool :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt; andb (f v) (f ty)
      end.
    
    Definition equal {A B : Set}
      (eq : A -&gt; B -&gt; bool) (decl1 : pt A A) (decl2 : pt B B) : bool :=
      match (decl1, decl2) with
      | (LocalAssum id1 ty1, LocalAssum id2 ty2) =&gt;
        andb (eq_annot Id.equal id1 id2) (eq ty1 ty2)
      | (LocalDef id1 v1 ty1, LocalDef id2 v2 ty2) =&gt;
        andb (eq_annot Id.equal id1 id2) (andb (eq v1 v2) (eq ty1 ty2))
      | _ =&gt; false
      end.
    
    Definition map_id {A B : Set} (f : Names.Id.t -&gt; Names.Id.t) (x : pt A B)
      : pt A B :=
      let id := get_id x in
      let id' := f id in
      if Stdlib.op_eqeq id id' then
        x
      else
        set_id id' x.
    
    Definition map_value {A B : Set} (f : A -&gt; A) (function_parameter : pt A B)
      : pt A B :=
      match function_parameter with
      | (LocalAssum _ _) as decl =&gt; decl
      | (LocalDef na v t) as decl =&gt;
        let v' := f v in
        if Stdlib.op_eqeq v v' then
          decl
        else
          LocalDef na v' t
      end.
    
    Definition map_type {A B : Set} (f : A -&gt; A) (function_parameter : pt B A)
      : pt B A :=
      match function_parameter with
      | (LocalAssum id ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eqeq ty ty' then
          decl
        else
          LocalAssum id ty'
      | (LocalDef id v ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eqeq ty ty' then
          decl
        else
          LocalDef id v ty'
      end.
    
    Definition map_constr {A : Set} (f : A -&gt; A) (function_parameter : pt A A)
      : pt A A :=
      match function_parameter with
      | (LocalAssum id ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eqeq ty ty' then
          decl
        else
          LocalAssum id ty'
      | (LocalDef id v ty) as decl =&gt;
        let v' := f v in
        let ty' := f ty in
        if andb (Stdlib.op_eqeq v v') (Stdlib.op_eqeq ty ty') then
          decl
        else
          LocalDef id v' ty'
      end.
    
    Definition iter_constr {A B : Set}
      (f : A -&gt; B) (function_parameter : pt A A) : B :=
      match function_parameter with
      | LocalAssum _ ty =&gt; f ty
      | LocalDef _ v ty =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        f ty
      end.
    
    Definition fold_constr {A B : Set} (f : A -&gt; B -&gt; B) (decl : pt A A) (a : B)
      : B :=
      match decl with
      | LocalAssum _ ty =&gt; f ty a
      | LocalDef _ v ty =&gt;
        OCaml.Stdlib.reverse_apply (OCaml.Stdlib.reverse_apply a (f v)) (f ty)
      end.
    
    Definition to_tuple {A B : Set} (function_parameter : pt A B)
      : binder_annot Names.Id.t * option A * B :=
      match function_parameter with
      | LocalAssum id ty =&gt; (id, None, ty)
      | LocalDef id v ty =&gt; (id, (Some v), ty)
      end.
    
    Definition of_tuple {A B : Set}
      (function_parameter : binder_annot Names.Id.t * option A * B) : pt A B :=
      match function_parameter with
      | (id, None, ty) =&gt; LocalAssum id ty
      | (id, Some v, ty) =&gt; LocalDef id v ty
      end.
    
    Definition drop_body {A B C : Set} (function_parameter : pt A B) : pt C B :=
      match function_parameter with
      | (LocalAssum _ _) as d =&gt; d
      | LocalDef id _v ty =&gt; LocalAssum id ty
      end.
    
    Definition of_rel_decl {A B : Set}
      (f : Names.Name.t -&gt; Names.Id.t)
      (function_parameter : Rel.Declaration.pt A B) : pt A B :=
      match function_parameter with
      | Rel.Declaration.LocalAssum na t =&gt; LocalAssum (map_annot f na) t
      | Rel.Declaration.LocalDef na v t =&gt; LocalDef (map_annot f na) v t
      end.
    
    Definition to_rel_decl {A B : Set} : pt A B -&gt; Rel.Declaration.pt A B :=
      let name (x : binder_annot Names.Id.t) : binder_annot Names.name :=
        {| binder_annot.binder_name := Names.Name (binder_annot.binder_name x);
          binder_annot.binder_relevance := binder_annot.binder_relevance x |} in
      fun function_parameter =&gt;
        match function_parameter with
        | LocalAssum id t =&gt; Rel.Declaration.LocalAssum (name id) t
        | LocalDef id v t =&gt; Rel.Declaration.LocalDef (name id) v t
        end.
  End Declaration.
  
  Definition pt (constr types : Set) := list (Declaration.pt constr types).
  
  Definition empty {A : Set} : list A := [].
  
  Definition add {A : Set} (d : A) (ctx : list A) : list A := cons d ctx.
  
  Definition length {A : Set} : list A -&gt; Z := (|Util.List|).(CList.ExtS.length).
  
  Fixpoint lookup {A B : Set}
    (id : Names.Id.t) (function_parameter : list (Declaration.pt A B))
    {struct id} : Declaration.pt A B :=
    match
      (function_parameter,
        match function_parameter with
        | cons decl _ =&gt; Id.equal id (Declaration.get_id decl)
        | _ =&gt; false
        end) with
    | (cons decl _, true) =&gt; decl
    | (cons _ sign, _) =&gt; lookup id sign
    | ([], _) =&gt; Stdlib.raise extensible_type_value
    end.
  
  Definition equal {A : Set}
    (eq : A -&gt; A -&gt; bool) (l : list (Declaration.pt A A))
    : list (Declaration.pt A A) -&gt; bool :=
    (|Util.List|).(CList.ExtS.equal) (fun c =&gt; Declaration.equal eq c) l.
  
  Definition map {A : Set} (f : A -&gt; A)
    : list (Declaration.pt A A) -&gt; list (Declaration.pt A A) :=
    List.Smart.map (Declaration.map_constr f).
  
  Definition iter {A : Set} (f : A -&gt; unit)
    : list (Declaration.pt A A) -&gt; unit :=
    (|Util.List|).(CList.ExtS.iter) (Declaration.iter_constr f).
  
  Definition fold_inside {A B : Set} (f : A -&gt; B -&gt; A) (init : A)
    : list B -&gt; A := (|Util.List|).(CList.ExtS.fold_left) f init.
  
  Definition fold_outside {A B : Set} (f : A -&gt; B -&gt; B) (l : list A) (init : B)
    : B := (|Util.List|).(CList.ExtS.fold_right) f l init.
  
  Definition to_vars {A B : Set} (l : list (Declaration.pt A B))
    : Names.Id.__Set.t :=
    (|Util.List|).(CList.ExtS.fold_left)
      (fun accu =&gt; fun decl =&gt; Id.__Set.add (Declaration.get_id decl) accu)
      Id.__Set.empty l.
  
  Definition drop_bodies {A B : Set} (l : list (Declaration.pt A B))
    : list (Declaration.pt A B) := List.Smart.map Declaration.drop_body l.
  
  Definition to_instance {A B C : Set}
    (mk : Names.Id.t -&gt; A) (l : list (Declaration.pt B C)) : list A :=
    let filter {D E : Set} (function_parameter : Declaration.pt D E)
      : option A :=
      match function_parameter with
      | Declaration.LocalAssum id _ =&gt; Some (mk (binder_annot.binder_name id))
      | _ =&gt; None
      end in
    (|Util.List|).(CList.ExtS.map_filter) filter l.
End Named.

Module Compacted.
  Module Declaration.
    Inductive pt (constr types : Set) : Set :=
    | LocalAssum : list (binder_annot Names.Id.t) -&gt; types -&gt; pt constr types
    | LocalDef :
      list (binder_annot Names.Id.t) -&gt; constr -&gt; types -&gt; pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Definition map_constr {A : Set} (f : A -&gt; A) (function_parameter : pt A A)
      : pt A A :=
      match function_parameter with
      | (LocalAssum ids ty) as decl =&gt;
        let ty' := f ty in
        if Stdlib.op_eqeq ty ty' then
          decl
        else
          LocalAssum ids ty'
      | (LocalDef ids c ty) as decl =&gt;
        let ty' := f ty in
        let c' := f c in
        if andb (Stdlib.op_eqeq c c') (Stdlib.op_eqeq ty ty') then
          decl
        else
          LocalDef ids c' ty'
      end.
    
    Definition of_named_decl {A B : Set}
      (function_parameter : Named.Declaration.pt A B) : pt A B :=
      match function_parameter with
      | Named.Declaration.LocalAssum id t =&gt; LocalAssum [ id ] t
      | Named.Declaration.LocalDef id v t =&gt; LocalDef [ id ] v t
      end.
    
    Definition to_named_context {A B : Set} (function_parameter : pt A B)
      : list (Named.Declaration.pt A B) :=
      match function_parameter with
      | LocalAssum ids t =&gt;
        (|Util.List|).(CList.ExtS.map)
          (fun id =&gt; Named.Declaration.LocalAssum id t) ids
      | LocalDef ids v t =&gt;
        (|Util.List|).(CList.ExtS.map)
          (fun id =&gt; Named.Declaration.LocalDef id v t) ids
      end.
  End Declaration.
  
  Definition pt (constr types : Set) := list (Declaration.pt constr types).
  
  Definition fold {A B : Set} (f : A -&gt; B -&gt; B) (l : list A) (init : B) : B :=
    (|Util.List|).(CList.ExtS.fold_right) f l init.
End Compacted.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="context.mli">
  <div style="margin: 20px;">
    <h3>Context_mli</h3>
    <ul>
      <li>OCaml size: 319 lines</li>
      <li>Coq size: 257 lines (-20% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#context.mli"><code>context.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** The modules defined below represent a {e local context}
    as defined by Chapter 4 in the Reference Manual:

    A {e local context} is an ordered list of of {e local declarations}
    of names that we call {e variables}.

    A {e local declaration} of some variable can be either:
    - a {e local assumption}, or
    - a {e local definition}.

    {e Local assumptions} are denoted in the Reference Manual as [(name : typ)] and
    {e local definitions} are there denoted as [(name := value : typ)].
*)

open Names

type 'a binder_annot = { binder_name : 'a; binder_relevance : Sorts.relevance }
val eq_annot : ('a -&gt; 'a -&gt; bool) -&gt; 'a binder_annot -&gt; 'a binder_annot -&gt; bool

val hash_annot : ('a -&gt; int) -&gt; 'a binder_annot -&gt; int

val map_annot : ('a -&gt; 'b) -&gt; 'a binder_annot -&gt; 'b binder_annot

val make_annot : 'a -&gt; Sorts.relevance -&gt; 'a binder_annot

val binder_name : 'a binder_annot -&gt; 'a
val binder_relevance : 'a binder_annot -&gt; Sorts.relevance

val annotR : 'a -&gt; 'a binder_annot
(** Always Relevant *)

val nameR : Id.t -&gt; Name.t binder_annot
(** Relevant + Name *)

val anonR : Name.t binder_annot
(** Relevant + Anonymous *)

(** Representation of contexts that can capture anonymous as well as non-anonymous variables.
    Individual declarations are then designated by de Bruijn indexes. *)
module Rel :
sig
  module Declaration :
  sig
    (* local declaration *)
    type ('constr, 'types) pt =
    | LocalAssum of Name.t binder_annot * 'types            (** name, type *)
    | LocalDef of Name.t binder_annot * 'constr * 'types   (** name, value, type *)

    val get_annot : _ pt -&gt; Name.t binder_annot

    (** Return the name bound by a given declaration. *)
    val get_name : ('c, 't) pt -&gt; Name.t

    (** Return [Some value] for local-declarations and [None] for local-assumptions. *)
    val get_value : ('c, 't) pt -&gt; 'c option

    (** Return the type of the name bound by a given declaration. *)
    val get_type : ('c, 't) pt -&gt; 't

    val get_relevance : ('c, 't) pt -&gt; Sorts.relevance

    (** Set the name that is bound by a given declaration. *)
    val set_name : Name.t -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Set the type of the bound variable in a given declaration. *)
    val set_type : 't -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Return [true] iff a given declaration is a local assumption. *)
    val is_local_assum : ('c, 't) pt -&gt; bool

    (** Return [true] iff a given declaration is a local definition. *)
    val is_local_def : ('c, 't) pt -&gt; bool

    (** Check whether any term in a given declaration satisfies a given predicate. *)
    val exists : ('c -&gt; bool) -&gt; ('c, 'c) pt -&gt; bool

    (** Check whether all terms in a given declaration satisfy a given predicate. *)
    val for_all : ('c -&gt; bool) -&gt; ('c, 'c) pt -&gt; bool

    (** Check whether the two given declarations are equal. *)
    val equal : ('c -&gt; 'c -&gt; bool) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt -&gt; bool

    (** Map the name bound by a given declaration. *)
    val map_name : (Name.t -&gt; Name.t) -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** For local assumptions, this function returns the original local assumptions.
        For local definitions, this function maps the value in the local definition. *)
    val map_value : ('c -&gt; 'c) -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Map the type of the name bound by a given declaration. *)
    val map_type : ('t -&gt; 't) -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Map all terms in a given declaration. *)
    val map_constr : ('c -&gt; 'c) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt

    (** Map all terms, with an heterogeneous function. *)
    val map_constr_het : ('a -&gt; 'b) -&gt; ('a, 'a) pt -&gt; ('b, 'b) pt

    (** Perform a given action on all terms in a given declaration. *)
    val iter_constr : ('c -&gt; unit) -&gt; ('c, 'c) pt -&gt; unit

    (** Reduce all terms in a given declaration to a single value. *)
    val fold_constr : ('c -&gt; 'a -&gt; 'a) -&gt; ('c, 'c) pt -&gt; 'a -&gt; 'a

    val to_tuple : ('c, 't) pt -&gt; Name.t binder_annot * 'c option * 't

    (** Turn [LocalDef] into [LocalAssum], identity otherwise. *)
    val drop_body : ('c, 't) pt -&gt; ('c, 't) pt
  end

  (** Rel-context is represented as a list of declarations.
      Inner-most declarations are at the beginning of the list.
      Outer-most declarations are at the end of the list. *)
  type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

  (** empty rel-context *)
  val empty : ('c, 't) pt

  (** Return a new rel-context enriched by with a given inner-most declaration. *)
  val add : ('c, 't) Declaration.pt -&gt; ('c, 't) pt -&gt; ('c, 't) pt

  (** Return the number of {e local declarations} in a given context. *)
  val length : ('c, 't) pt -&gt; int

  (** Check whether given two rel-contexts are equal. *)
  val equal : ('c -&gt; 'c -&gt; bool) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt -&gt; bool

  (** Return the number of {e local assumptions} in a given rel-context. *)
  val nhyps : ('c, 't) pt -&gt; int

  (** Return a declaration designated by a given de Bruijn index.
      @raise Not_found if the designated de Bruijn index outside the range. *)
  val lookup : int -&gt; ('c, 't) pt -&gt; ('c, 't) Declaration.pt

  (** Map all terms in a given rel-context. *)
  val map : ('c -&gt; 'c) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt

  (** Perform a given action on every declaration in a given rel-context. *)
  val iter : ('c -&gt; unit) -&gt; ('c, 'c) pt -&gt; unit

  (** Reduce all terms in a given rel-context to a single value.
      Innermost declarations are processed first. *)
  val fold_inside : ('a -&gt; ('c, 't) Declaration.pt -&gt; 'a) -&gt; init:'a -&gt; ('c, 't) pt -&gt; 'a

  (** Reduce all terms in a given rel-context to a single value.
      Outermost declarations are processed first. *)
  val fold_outside : (('c, 't) Declaration.pt -&gt; 'a -&gt; 'a) -&gt; ('c, 't) pt -&gt; init:'a -&gt; 'a

  (** Map a given rel-context to a list where each {e local assumption} is mapped to [true]
      and each {e local definition} is mapped to [false]. *)
  val to_tags : ('c, 't) pt -&gt; bool list

  (** Turn all [LocalDef] into [LocalAssum], leave [LocalAssum] unchanged. *)
  val drop_bodies : ('c, 't) pt -&gt; ('c, 't) pt

  (** [extended_list mk n Î] builds an instance [args] such that [Î,Î â¢ args:Î]
      with n = |Î| and with the {e local definitions} of [Î] skipped in
      [args] where [mk] is used to build the corresponding variables.
      Example: for [x:T, y:=c, z:U] and [n]=2, it gives [mk 5, mk 3]. *)
  val to_extended_list : (int -&gt; 'r) -&gt; int -&gt; ('c, 't) pt -&gt; 'r list

  (** [extended_vect n Î] does the same, returning instead an array. *)
  val to_extended_vect : (int -&gt; 'r) -&gt; int -&gt; ('c, 't) pt -&gt; 'r array
end

(** This module represents contexts that can capture non-anonymous variables.
    Individual declarations are then designated by the identifiers they bind. *)
module Named :
sig
  (** Representation of {e local declarations}. *)
  module Declaration :
  sig
    type ('constr, 'types) pt =
      | LocalAssum of Id.t binder_annot * 'types             (** identifier, type *)
      | LocalDef of Id.t binder_annot * 'constr * 'types    (** identifier, value, type *)

    val get_annot : _ pt -&gt; Id.t binder_annot

    (** Return the identifier bound by a given declaration. *)
    val get_id : ('c, 't) pt -&gt; Id.t

    (** Return [Some value] for local-declarations and [None] for local-assumptions. *)
    val get_value : ('c, 't) pt -&gt; 'c option

    (** Return the type of the name bound by a given declaration. *)
    val get_type : ('c, 't) pt -&gt; 't

    val get_relevance : ('c, 't) pt -&gt; Sorts.relevance

    (** Set the identifier that is bound by a given declaration. *)
    val set_id : Id.t -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Set the type of the bound variable in a given declaration. *)
    val set_type : 't -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Return [true] iff a given declaration is a local assumption. *)
    val is_local_assum : ('c, 't) pt -&gt; bool

    (** Return [true] iff a given declaration is a local definition. *)
    val is_local_def : ('c, 't) pt -&gt; bool

    (** Check whether any term in a given declaration satisfies a given predicate. *)
    val exists : ('c -&gt; bool) -&gt; ('c, 'c) pt -&gt; bool

    (** Check whether all terms in a given declaration satisfy a given predicate. *)
    val for_all : ('c -&gt; bool) -&gt; ('c, 'c) pt -&gt; bool

    (** Check whether the two given declarations are equal. *)
    val equal : ('c -&gt; 'c -&gt; bool) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt -&gt; bool

    (** Map the identifier bound by a given declaration. *)
    val map_id : (Id.t -&gt; Id.t) -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** For local assumptions, this function returns the original local assumptions.
        For local definitions, this function maps the value in the local definition. *)
    val map_value : ('c -&gt; 'c) -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Map the type of the name bound by a given declaration. *)
    val map_type : ('t -&gt; 't) -&gt; ('c, 't) pt -&gt; ('c, 't) pt

    (** Map all terms in a given declaration. *)
    val map_constr : ('c -&gt; 'c) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt

    (** Perform a given action on all terms in a given declaration. *)
    val iter_constr : ('c -&gt; unit) -&gt; ('c, 'c) pt -&gt; unit

    (** Reduce all terms in a given declaration to a single value. *)
    val fold_constr : ('c -&gt; 'a -&gt; 'a) -&gt; ('c, 'c) pt -&gt; 'a -&gt; 'a

    val to_tuple : ('c, 't) pt -&gt; Id.t binder_annot * 'c option * 't
    val of_tuple : Id.t binder_annot * 'c option * 't -&gt; ('c, 't) pt

    (** Turn [LocalDef] into [LocalAssum], identity otherwise. *)
    val drop_body : ('c, 't) pt -&gt; ('c, 't) pt

    (** Convert [Rel.Declaration.t] value to the corresponding [Named.Declaration.t] value.
        The function provided as the first parameter determines how to translate &quot;names&quot; to &quot;ids&quot;. *)
    val of_rel_decl : (Name.t -&gt; Id.t) -&gt; ('c, 't) Rel.Declaration.pt -&gt; ('c, 't) pt

    (** Convert [Named.Declaration.t] value to the corresponding [Rel.Declaration.t] value. *)
    (* TODO: Move this function to [Rel.Declaration] module and rename it to [of_named]. *)
    val to_rel_decl : ('c, 't) pt -&gt; ('c, 't) Rel.Declaration.pt
  end

  (** Named-context is represented as a list of declarations.
      Inner-most declarations are at the beginning of the list.
      Outer-most declarations are at the end of the list. *)
  type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

  (** empty named-context *)
  val empty : ('c, 't) pt

  (** Return a new named-context enriched by with a given inner-most declaration. *)
  val add : ('c, 't) Declaration.pt -&gt; ('c, 't) pt -&gt; ('c, 't) pt

  (** Return the number of {e local declarations} in a given named-context. *)
  val length : ('c, 't) pt -&gt; int

  (** Return a declaration designated by an identifier of the variable bound in that declaration.
      @raise Not_found if the designated identifier is not bound in a given named-context. *)
  val lookup : Id.t -&gt; ('c, 't) pt -&gt; ('c, 't) Declaration.pt

  (** Check whether given two named-contexts are equal. *)
  val equal : ('c -&gt; 'c -&gt; bool) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt -&gt; bool

  (** Map all terms in a given named-context. *)
  val map : ('c -&gt; 'c) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt

  (** Perform a given action on every declaration in a given named-context. *)
  val iter : ('c -&gt; unit) -&gt; ('c, 'c) pt -&gt; unit

  (** Reduce all terms in a given named-context to a single value.
      Innermost declarations are processed first. *)
  val fold_inside : ('a -&gt; ('c, 't) Declaration.pt -&gt; 'a) -&gt; init:'a -&gt; ('c, 't) pt -&gt; 'a

  (** Reduce all terms in a given named-context to a single value.
      Outermost declarations are processed first. *)
  val fold_outside : (('c, 't) Declaration.pt -&gt; 'a -&gt; 'a) -&gt; ('c, 't) pt -&gt; init:'a -&gt; 'a

  (** Return the set of all identifiers bound in a given named-context. *)
  val to_vars : ('c, 't) pt -&gt; Id.Set.t

  (** Turn all [LocalDef] into [LocalAssum], leave [LocalAssum] unchanged. *)
  val drop_bodies : ('c, 't) pt -&gt; ('c, 't) pt

  (** [to_instance Î©] builds an instance [args] such
      that [Î© â¢ args:Î©] where [Î©] is a named-context and with the local
      definitions of [Î©] skipped. Example: for [id1:T,id2:=c,id3:U], it
      gives [Var id1, Var id3]. All [idj] are supposed distinct. *)
  val to_instance : (Id.t -&gt; 'r) -&gt; ('c, 't) pt -&gt; 'r list
end

module Compacted :
sig
  module Declaration :
  sig
    type ('constr, 'types) pt =
      | LocalAssum of Id.t binder_annot list * 'types
      | LocalDef of Id.t binder_annot list * 'constr * 'types

    val map_constr : ('c -&gt; 'c) -&gt; ('c, 'c) pt -&gt; ('c, 'c) pt
    val of_named_decl : ('c, 't) Named.Declaration.pt -&gt; ('c, 't) pt
    val to_named_context : ('c, 't) pt -&gt; ('c, 't) Named.pt
  end

  type ('constr, 'types) pt = ('constr, 'types) Declaration.pt list

  val fold : (('c, 't) Declaration.pt -&gt; 'a -&gt; 'a) -&gt; ('c, 't) pt -&gt; init:'a -&gt; 'a
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#context.mli"><code>Context_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Module binder_annot.
  Record record {a : Set} := {
    binder_name : a;
    binder_relevance : Sorts.relevance }.
  Arguments record : clear implicits.
  Definition with_binder_name {a_type : Set} (r : record a_type) binder_name
    : record a_type :=
    {| binder_name := binder_name; binder_relevance := binder_relevance r |}.
  Definition with_binder_relevance {a_type : Set} (r : record a_type)
    binder_relevance : record a_type :=
    {| binder_name := binder_name r; binder_relevance := binder_relevance |}.
End binder_annot.
Definition binder_annot := binder_annot.record.

Parameter eq_annot : forall {a : Set},
  (a -&gt; a -&gt; bool) -&gt; binder_annot a -&gt; binder_annot a -&gt; bool.

Parameter hash_annot : forall {a : Set}, (a -&gt; Z) -&gt; binder_annot a -&gt; Z.

Parameter map_annot : forall {a b : Set},
  (a -&gt; b) -&gt; binder_annot a -&gt; binder_annot b.

Parameter make_annot : forall {a : Set}, a -&gt; Sorts.relevance -&gt; binder_annot a.

Parameter binder_name : forall {a : Set}, binder_annot a -&gt; a.

Parameter binder_relevance : forall {a : Set},
  binder_annot a -&gt; Sorts.relevance.

Parameter annotR : forall {a : Set}, a -&gt; binder_annot a.

Parameter nameR : Names.Id.t -&gt; binder_annot Names.Name.t.

Parameter anonR : binder_annot Names.Name.t.

Module Rel.
  Module Declaration.
    Inductive pt (constr types : Set) : Set :=
    | LocalAssum : binder_annot Names.Name.t -&gt; types -&gt; pt constr types
    | LocalDef : binder_annot Names.Name.t -&gt; constr -&gt; types -&gt; pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Parameter get_annot : forall {A B : Set},
      pt A B -&gt; binder_annot Names.Name.t.
    
    Parameter get_name : forall {c t : Set}, pt c t -&gt; Names.Name.t.
    
    Parameter get_value : forall {c t : Set}, pt c t -&gt; option c.
    
    Parameter get_type : forall {c t : Set}, pt c t -&gt; t.
    
    Parameter get_relevance : forall {c t : Set}, pt c t -&gt; Sorts.relevance.
    
    Parameter set_name : forall {c t : Set}, Names.Name.t -&gt; pt c t -&gt; pt c t.
    
    Parameter set_type : forall {c t : Set}, t -&gt; pt c t -&gt; pt c t.
    
    Parameter is_local_assum : forall {c t : Set}, pt c t -&gt; bool.
    
    Parameter is_local_def : forall {c t : Set}, pt c t -&gt; bool.
    
    Parameter __exists : forall {c : Set}, (c -&gt; bool) -&gt; pt c c -&gt; bool.
    
    Parameter for_all : forall {c : Set}, (c -&gt; bool) -&gt; pt c c -&gt; bool.
    
    Parameter equal : forall {c : Set},
      (c -&gt; c -&gt; bool) -&gt; pt c c -&gt; pt c c -&gt; bool.
    
    Parameter map_name : forall {c t : Set},
      (Names.Name.t -&gt; Names.Name.t) -&gt; pt c t -&gt; pt c t.
    
    Parameter map_value : forall {c t : Set}, (c -&gt; c) -&gt; pt c t -&gt; pt c t.
    
    Parameter map_type : forall {c t : Set}, (t -&gt; t) -&gt; pt c t -&gt; pt c t.
    
    Parameter map_constr : forall {c : Set}, (c -&gt; c) -&gt; pt c c -&gt; pt c c.
    
    Parameter map_constr_het : forall {a b : Set}, (a -&gt; b) -&gt; pt a a -&gt; pt b b.
    
    Parameter iter_constr : forall {c : Set}, (c -&gt; unit) -&gt; pt c c -&gt; unit.
    
    Parameter fold_constr : forall {a c : Set},
      (c -&gt; a -&gt; a) -&gt; pt c c -&gt; a -&gt; a.
    
    Parameter to_tuple : forall {c t : Set},
      pt c t -&gt; binder_annot Names.Name.t * option c * t.
    
    Parameter drop_body : forall {c t : Set}, pt c t -&gt; pt c t.
  End Declaration.
  
  Definition pt (constr types : Set) := list (Declaration.pt constr types).
  
  Parameter empty : forall {c t : Set}, pt c t.
  
  Parameter add : forall {c t : Set}, Declaration.pt c t -&gt; pt c t -&gt; pt c t.
  
  Parameter length : forall {c t : Set}, pt c t -&gt; Z.
  
  Parameter equal : forall {c : Set},
    (c -&gt; c -&gt; bool) -&gt; pt c c -&gt; pt c c -&gt; bool.
  
  Parameter nhyps : forall {c t : Set}, pt c t -&gt; Z.
  
  Parameter lookup : forall {c t : Set}, Z -&gt; pt c t -&gt; Declaration.pt c t.
  
  Parameter map : forall {c : Set}, (c -&gt; c) -&gt; pt c c -&gt; pt c c.
  
  Parameter iter : forall {c : Set}, (c -&gt; unit) -&gt; pt c c -&gt; unit.
  
  Parameter fold_inside : forall {a c t : Set},
    (a -&gt; Declaration.pt c t -&gt; a) -&gt; a -&gt; pt c t -&gt; a.
  
  Parameter fold_outside : forall {a c t : Set},
    (Declaration.pt c t -&gt; a -&gt; a) -&gt; pt c t -&gt; a -&gt; a.
  
  Parameter to_tags : forall {c t : Set}, pt c t -&gt; list bool.
  
  Parameter drop_bodies : forall {c t : Set}, pt c t -&gt; pt c t.
  
  Parameter to_extended_list : forall {c r t : Set},
    (Z -&gt; r) -&gt; Z -&gt; pt c t -&gt; list r.
  
  Parameter to_extended_vect : forall {c r t : Set},
    (Z -&gt; r) -&gt; Z -&gt; pt c t -&gt; array r.
End Rel.

Module Named.
  Module Declaration.
    Inductive pt (constr types : Set) : Set :=
    | LocalAssum : binder_annot Names.Id.t -&gt; types -&gt; pt constr types
    | LocalDef : binder_annot Names.Id.t -&gt; constr -&gt; types -&gt; pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Parameter get_annot : forall {A B : Set}, pt A B -&gt; binder_annot Names.Id.t.
    
    Parameter get_id : forall {c t : Set}, pt c t -&gt; Names.Id.t.
    
    Parameter get_value : forall {c t : Set}, pt c t -&gt; option c.
    
    Parameter get_type : forall {c t : Set}, pt c t -&gt; t.
    
    Parameter get_relevance : forall {c t : Set}, pt c t -&gt; Sorts.relevance.
    
    Parameter set_id : forall {c t : Set}, Names.Id.t -&gt; pt c t -&gt; pt c t.
    
    Parameter set_type : forall {c t : Set}, t -&gt; pt c t -&gt; pt c t.
    
    Parameter is_local_assum : forall {c t : Set}, pt c t -&gt; bool.
    
    Parameter is_local_def : forall {c t : Set}, pt c t -&gt; bool.
    
    Parameter __exists : forall {c : Set}, (c -&gt; bool) -&gt; pt c c -&gt; bool.
    
    Parameter for_all : forall {c : Set}, (c -&gt; bool) -&gt; pt c c -&gt; bool.
    
    Parameter equal : forall {c : Set},
      (c -&gt; c -&gt; bool) -&gt; pt c c -&gt; pt c c -&gt; bool.
    
    Parameter map_id : forall {c t : Set},
      (Names.Id.t -&gt; Names.Id.t) -&gt; pt c t -&gt; pt c t.
    
    Parameter map_value : forall {c t : Set}, (c -&gt; c) -&gt; pt c t -&gt; pt c t.
    
    Parameter map_type : forall {c t : Set}, (t -&gt; t) -&gt; pt c t -&gt; pt c t.
    
    Parameter map_constr : forall {c : Set}, (c -&gt; c) -&gt; pt c c -&gt; pt c c.
    
    Parameter iter_constr : forall {c : Set}, (c -&gt; unit) -&gt; pt c c -&gt; unit.
    
    Parameter fold_constr : forall {a c : Set},
      (c -&gt; a -&gt; a) -&gt; pt c c -&gt; a -&gt; a.
    
    Parameter to_tuple : forall {c t : Set},
      pt c t -&gt; binder_annot Names.Id.t * option c * t.
    
    Parameter of_tuple : forall {c t : Set},
      binder_annot Names.Id.t * option c * t -&gt; pt c t.
    
    Parameter drop_body : forall {c t : Set}, pt c t -&gt; pt c t.
    
    Parameter of_rel_decl : forall {c t : Set},
      (Names.Name.t -&gt; Names.Id.t) -&gt; Rel.Declaration.pt c t -&gt; pt c t.
    
    Parameter to_rel_decl : forall {c t : Set},
      pt c t -&gt; Rel.Declaration.pt c t.
  End Declaration.
  
  Definition pt (constr types : Set) := list (Declaration.pt constr types).
  
  Parameter empty : forall {c t : Set}, pt c t.
  
  Parameter add : forall {c t : Set}, Declaration.pt c t -&gt; pt c t -&gt; pt c t.
  
  Parameter length : forall {c t : Set}, pt c t -&gt; Z.
  
  Parameter lookup : forall {c t : Set},
    Names.Id.t -&gt; pt c t -&gt; Declaration.pt c t.
  
  Parameter equal : forall {c : Set},
    (c -&gt; c -&gt; bool) -&gt; pt c c -&gt; pt c c -&gt; bool.
  
  Parameter map : forall {c : Set}, (c -&gt; c) -&gt; pt c c -&gt; pt c c.
  
  Parameter iter : forall {c : Set}, (c -&gt; unit) -&gt; pt c c -&gt; unit.
  
  Parameter fold_inside : forall {a c t : Set},
    (a -&gt; Declaration.pt c t -&gt; a) -&gt; a -&gt; pt c t -&gt; a.
  
  Parameter fold_outside : forall {a c t : Set},
    (Declaration.pt c t -&gt; a -&gt; a) -&gt; pt c t -&gt; a -&gt; a.
  
  Parameter to_vars : forall {c t : Set}, pt c t -&gt; Names.Id.__Set.t.
  
  Parameter drop_bodies : forall {c t : Set}, pt c t -&gt; pt c t.
  
  Parameter to_instance : forall {c r t : Set},
    (Names.Id.t -&gt; r) -&gt; pt c t -&gt; list r.
End Named.

Module Compacted.
  Module Declaration.
    Inductive pt (constr types : Set) : Set :=
    | LocalAssum : list (binder_annot Names.Id.t) -&gt; types -&gt; pt constr types
    | LocalDef :
      list (binder_annot Names.Id.t) -&gt; constr -&gt; types -&gt; pt constr types.
    
    Arguments LocalAssum {_ _}.
    Arguments LocalDef {_ _}.
    
    Parameter map_constr : forall {c : Set}, (c -&gt; c) -&gt; pt c c -&gt; pt c c.
    
    Parameter of_named_decl : forall {c t : Set},
      Named.Declaration.pt c t -&gt; pt c t.
    
    Parameter to_named_context : forall {c t : Set}, pt c t -&gt; Named.pt c t.
  End Declaration.
  
  Definition pt (constr types : Set) := list (Declaration.pt constr types).
  
  Parameter fold : forall {a c t : Set},
    (Declaration.pt c t -&gt; a -&gt; a) -&gt; pt c t -&gt; a -&gt; a.
End Compacted.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="conv_oracle.ml">
  <div style="margin: 20px;">
    <h3>Conv_oracle</h3>
    <ul>
      <li>OCaml size: 110 lines</li>
      <li>Coq size: 167 lines (+51% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#conv_oracle.ml"><code>conv_oracle.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras as part of the rewriting of the conversion
   algorithm, Nov 2001 *)

open Names

(* Priority for the expansion of constant in the conversion test.
 * Higher levels means that the expansion is less prioritary.
 * (And Expand stands for -oo, and Opaque +oo.)
 * The default value is [Level 100].
 *)
type level = Expand | Level of int | Opaque
let default = Level 0
let is_default = function
| Level 0 -&gt; true
| _ -&gt; false
let transparent = default
let is_transparent = function
| Level 0 -&gt; true
| _ -&gt; false

type oracle = {
  var_opacity : level Id.Map.t;
  cst_opacity : level Cmap.t;
  var_trstate : Id.Pred.t;
  cst_trstate : Cpred.t;
}

let empty = {
  var_opacity = Id.Map.empty;
  cst_opacity = Cmap.empty;
  var_trstate = Id.Pred.full;
  cst_trstate = Cpred.full;
}

let get_strategy { var_opacity; cst_opacity; _ } f = function
  | VarKey id -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try Id.Map.find id var_opacity
      with Not_found -&gt; default)</abbr>
  | ConstKey c -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try Cmap.find (f c) cst_opacity
      with Not_found -&gt; default)</abbr>
  | RelKey _ -&gt; Expand

let set_strategy ({ var_opacity; cst_opacity; _ } as oracle) k l =
  match k with
  | VarKey id -&gt;
    let var_opacity =
      if is_default l then Id.Map.remove id var_opacity
      else Id.Map.add id l var_opacity
    in
    let var_trstate = match l with
    | Opaque -&gt; Id.Pred.remove id oracle.var_trstate
    | _ -&gt; Id.Pred.add id oracle.var_trstate
    in
    { oracle with var_opacity; var_trstate; }
  | ConstKey c -&gt;
    let cst_opacity =
      if is_default l then Cmap.remove c cst_opacity
      else Cmap.add c l cst_opacity
    in
    let cst_trstate = match l with
    | Opaque -&gt; Cpred.remove c oracle.cst_trstate
    | _ -&gt; Cpred.add c oracle.cst_trstate
    in
    { oracle with cst_opacity; cst_trstate; }
  | RelKey _ -&gt; CErrors.user_err Pp.(str &quot;set_strategy: RelKey&quot;)

let fold_strategy f { var_opacity; cst_opacity; _ } accu =
  let fvar id lvl accu = f (VarKey id) lvl accu in
  let fcst cst lvl accu = f (ConstKey cst) lvl accu in
  let accu = Id.Map.fold fvar var_opacity accu in
  Cmap.fold fcst cst_opacity accu

let get_transp_state { var_trstate; cst_trstate; _ } =
  { TransparentState.tr_var = var_trstate; tr_cst = cst_trstate }

let dep_order l2r k1 k2 = match k1, k2 with
| RelKey _, RelKey _ -&gt; l2r
| RelKey _, (VarKey _ | ConstKey _) -&gt; true
| VarKey _, RelKey _ -&gt; false
| VarKey _, VarKey _ -&gt; l2r
| VarKey _, ConstKey _ -&gt; true
| ConstKey _, (RelKey _ | VarKey _) -&gt; false
| ConstKey _, ConstKey _ -&gt; l2r

(* Unfold the first constant only if it is &quot;more transparent&quot; than the
   second one. In case of tie, use the recommended default. *)
let oracle_order f o l2r k1 k2 =
  match get_strategy o f k1, get_strategy o f k2 with
  | Expand, Expand -&gt; dep_order l2r k1 k2
  | Expand, (Opaque | Level _) -&gt; true
  | (Opaque | Level _), Expand -&gt; false
  | Opaque, Opaque -&gt; dep_order l2r k1 k2
  | Level _, Opaque -&gt; true
  | Opaque, Level _ -&gt; false
  | Level n1, Level n2 -&gt;
     if Int.equal n1 n2 then dep_order l2r k1 k2
     else n1 &lt; n2

let get_strategy o = get_strategy o (fun x -&gt; x)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#conv_oracle.ml"><code>Conv_oracle.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Inductive level : Set :=
| Expand : level
| Level : Z -&gt; level
| Opaque : level.

Definition default : level := Level 0.

Definition is_default (function_parameter : level) : bool :=
  match function_parameter with
  | Level 0 =&gt; true
  | _ =&gt; false
  end.

Definition transparent : level := default.

Definition is_transparent (function_parameter : level) : bool :=
  match function_parameter with
  | Level 0 =&gt; true
  | _ =&gt; false
  end.

Module oracle.
  Record record := {
    var_opacity : Names.Id.Map.t level;
    cst_opacity : Names.Cmap.t level;
    var_trstate : Names.Id.Pred.t;
    cst_trstate : Names.Cpred.t }.
  Definition with_var_opacity (r : record) var_opacity : record :=
    {| var_opacity := var_opacity; cst_opacity := cst_opacity r;
      var_trstate := var_trstate r; cst_trstate := cst_trstate r |}.
  Definition with_cst_opacity (r : record) cst_opacity : record :=
    {| var_opacity := var_opacity r; cst_opacity := cst_opacity;
      var_trstate := var_trstate r; cst_trstate := cst_trstate r |}.
  Definition with_var_trstate (r : record) var_trstate : record :=
    {| var_opacity := var_opacity r; cst_opacity := cst_opacity r;
      var_trstate := var_trstate; cst_trstate := cst_trstate r |}.
  Definition with_cst_trstate (r : record) cst_trstate : record :=
    {| var_opacity := var_opacity r; cst_opacity := cst_opacity r;
      var_trstate := var_trstate r; cst_trstate := cst_trstate |}.
End oracle.
Definition oracle := oracle.record.

Definition empty : oracle :=
  {| oracle.var_opacity := Id.Map.empty; oracle.cst_opacity := Cmap.empty;
    oracle.var_trstate := Id.Pred.full; oracle.cst_trstate := Cpred.full |}.

Definition get_strategy {A : Set} (function_parameter : oracle)
  : (A -&gt; Names.Cmap.key) -&gt; Names.tableKey A -&gt; level :=
  let '{|
    oracle.var_opacity := var_opacity; oracle.cst_opacity := cst_opacity |} :=
    function_parameter in
  fun f =&gt;
    fun function_parameter =&gt;
      match function_parameter with
      | Names.VarKey id =&gt;
        (* ❌ Try-with are not handled *)
        try (Id.Map.find id var_opacity)
      | Names.ConstKey c =&gt;
        (* ❌ Try-with are not handled *)
        try (Cmap.find (f c) cst_opacity)
      | Names.RelKey _ =&gt; Expand
      end.

Definition set_strategy (function_parameter : oracle)
  : Names.tableKey Names.Cmap.key -&gt; level -&gt; oracle :=
  let
    '{| oracle.var_opacity := var_opacity; oracle.cst_opacity := cst_opacity |}
      as oracle := function_parameter in
  fun k =&gt;
    fun l =&gt;
      match k with
      | Names.VarKey id =&gt;
        let var_opacity :=
          if is_default l then
            Id.Map.remove id var_opacity
          else
            Id.Map.add id l var_opacity in
        let var_trstate :=
          match l with
          | Opaque =&gt; Id.Pred.remove id (oracle.var_trstate oracle)
          | _ =&gt; Id.Pred.add id (oracle.var_trstate oracle)
          end in
        oracle.with_var_trstate (oracle.with_var_opacity oracle var_opacity)
          var_trstate
      | Names.ConstKey c =&gt;
        let cst_opacity :=
          if is_default l then
            Cmap.remove c cst_opacity
          else
            Cmap.add c l cst_opacity in
        let cst_trstate :=
          match l with
          | Opaque =&gt; Cpred.remove c (oracle.cst_trstate oracle)
          | _ =&gt; Cpred.add c (oracle.cst_trstate oracle)
          end in
        oracle.with_cst_trstate (oracle.with_cst_opacity oracle cst_opacity)
          cst_trstate
      | Names.RelKey _ =&gt;
        CErrors.user_err None None (str &quot;set_strategy: RelKey&quot;)
      end.

Definition fold_strategy {A : Set}
  (f : Names.tableKey Names.Cmap.key -&gt; level -&gt; A -&gt; A)
  (function_parameter : oracle) : A -&gt; A :=
  let '{|
    oracle.var_opacity := var_opacity; oracle.cst_opacity := cst_opacity |} :=
    function_parameter in
  fun accu =&gt;
    let fvar (id : Names.Id.t) (lvl : level) (accu : A) : A :=
      f (Names.VarKey id) lvl accu in
    let fcst (cst : Names.Cmap.key) (lvl : level) (accu : A) : A :=
      f (Names.ConstKey cst) lvl accu in
    let accu := Id.Map.fold fvar var_opacity accu in
    Cmap.fold fcst cst_opacity accu.

Definition get_transp_state (function_parameter : oracle)
  : TransparentState.t :=
  let '{|
    oracle.var_trstate := var_trstate; oracle.cst_trstate := cst_trstate |} :=
    function_parameter in
  {| TransparentState.t.tr_var := var_trstate;
    TransparentState.t.tr_cst := cst_trstate |}.

Definition dep_order {A B : Set}
  (l2r : bool) (k1 : Names.tableKey A) (k2 : Names.tableKey B) : bool :=
  match (k1, k2) with
  | (Names.RelKey _, Names.RelKey _) =&gt; l2r
  | (Names.RelKey _, Names.VarKey _ | Names.ConstKey _) =&gt; true
  | (Names.VarKey _, Names.RelKey _) =&gt; false
  | (Names.VarKey _, Names.VarKey _) =&gt; l2r
  | (Names.VarKey _, Names.ConstKey _) =&gt; true
  | (Names.ConstKey _, Names.RelKey _ | Names.VarKey _) =&gt; false
  | (Names.ConstKey _, Names.ConstKey _) =&gt; l2r
  end.

Definition oracle_order {A : Set}
  (f : A -&gt; Names.Cmap.key) (o : oracle) (l2r : bool) (k1 : Names.tableKey A)
  (k2 : Names.tableKey A) : bool :=
  match ((get_strategy o f k1), (get_strategy o f k2)) with
  | (Expand, Expand) =&gt; dep_order l2r k1 k2
  | (Expand, Opaque | Level _) =&gt; true
  | (Opaque | Level _, Expand) =&gt; false
  | (Opaque, Opaque) =&gt; dep_order l2r k1 k2
  | (Level _, Opaque) =&gt; true
  | (Opaque, Level _) =&gt; false
  | (Level n1, Level n2) =&gt;
    if Int.equal n1 n2 then
      dep_order l2r k1 k2
    else
      OCaml.Stdlib.lt n1 n2
  end.

Definition get_strategy (o : oracle) : Names.tableKey Names.Cmap.key -&gt; level :=
  get_strategy o (fun x =&gt; x).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="conv_oracle.mli">
  <div style="margin: 20px;">
    <h3>Conv_oracle_mli</h3>
    <ul>
      <li>OCaml size: 44 lines</li>
      <li>Coq size: 37 lines (-16% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#conv_oracle.mli"><code>conv_oracle.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

type oracle

val empty : oracle

(** Order on section paths for unfolding.
   If [oracle_order kn1 kn2] is true, then unfold kn1 first.
   Note: the oracle does not introduce incompleteness, it only
   tries to postpone unfolding of &quot;opaque&quot; constants. *)
val oracle_order : ('a -&gt; Constant.t) -&gt; oracle -&gt; bool -&gt;
  'a tableKey -&gt; 'a tableKey -&gt; bool

(** Priority for the expansion of constant in the conversion test.
 * Higher levels means that the expansion is less prioritary.
 * (And Expand stands for -oo, and Opaque +oo.)
 * The default value (transparent constants) is [Level 0].
 *)
type level = Expand | Level of int | Opaque
val transparent : level

(** Check whether a level is transparent *)
val is_transparent : level -&gt; bool

val get_strategy : oracle -&gt; Constant.t tableKey -&gt; level

(** Sets the level of a constant.
 * Level of RelKey constant cannot be set. *)
val set_strategy : oracle -&gt; Constant.t tableKey -&gt; level -&gt; oracle

(** Fold over the non-transparent levels of the oracle. Order unspecified. *)
val fold_strategy : (Constant.t tableKey -&gt; level -&gt; 'a -&gt; 'a) -&gt; oracle -&gt; 'a -&gt; 'a

val get_transp_state : oracle -&gt; TransparentState.t

</pre>
  </div>
  <div class="col-md-6">
    <a href="#conv_oracle.mli"><code>Conv_oracle_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter oracle : Set.

Parameter empty : oracle.

Parameter oracle_order : forall {a : Set},
  (a -&gt; Names.Constant.t) -&gt; oracle -&gt; bool -&gt; Names.tableKey a -&gt;
  Names.tableKey a -&gt; bool.

Inductive level : Set :=
| Expand : level
| Level : Z -&gt; level
| Opaque : level.

Parameter transparent : level.

Parameter is_transparent : level -&gt; bool.

Parameter get_strategy : oracle -&gt; Names.tableKey Names.Constant.t -&gt; level.

Parameter set_strategy :
  oracle -&gt; Names.tableKey Names.Constant.t -&gt; level -&gt; oracle.

Parameter fold_strategy : forall {a : Set},
  (Names.tableKey Names.Constant.t -&gt; level -&gt; a -&gt; a) -&gt; oracle -&gt; a -&gt; a.

Parameter get_transp_state : oracle -&gt; TransparentState.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cooking.ml">
  <div style="margin: 20px;">
    <h3>Cooking</h3>
    <ul>
      <li>OCaml size: 251 lines</li>
      <li>Coq size: 359 lines (+43% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cooking.ml"><code>cooking.ml</code></a>&nbsp;<span class="label label-warning">21 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jean-Christophe FilliÃ¢tre out of V6.3 file constants.ml
   as part of the rebuilding of Coq around a purely functional
   abstract type-checker, Nov 1999 *)

(* This module implements kernel-level discharching of local
   declarations over global constants and inductive types *)

open Util
open Names
open Term
open Constr
open Declarations
open Univ
open Context

module NamedDecl = Context.Named.Declaration
module RelDecl = Context.Rel.Declaration

(*s Cooking the constants. *)

type my_global_reference =
  | ConstRef of Constant.t
  | IndRef of inductive
  | ConstructRef of constructor

module RefHash =
struct
  type t = my_global_reference
  let equal gr1 gr2 = match gr1, gr2 with
  | ConstRef c1, ConstRef c2 -&gt; Constant.SyntacticOrd.equal c1 c2
  | IndRef i1, IndRef i2 -&gt; eq_syntactic_ind i1 i2
  | ConstructRef c1, ConstructRef c2 -&gt; eq_syntactic_constructor c1 c2
  | _ -&gt; false
  open Hashset.Combine
  let hash = function
  | ConstRef c -&gt; combinesmall 1 (Constant.SyntacticOrd.hash c)
  | IndRef i -&gt; combinesmall 2 (ind_syntactic_hash i)
  | ConstructRef c -&gt; combinesmall 3 (constructor_syntactic_hash c)
end

module RefTable = Hashtbl.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RefHash</abbr>)

let instantiate_my_gr gr u =
  match gr with
  | ConstRef c -&gt; mkConstU (c, u)
  | IndRef i -&gt; mkIndU (i, u)
  | ConstructRef c -&gt; mkConstructU (c, u)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">share</abbr> cache r (cstl,knl) =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RefTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> cache r
  with Not_found -&gt;
  let (u,l) =
    match r with
    | IndRef (kn,_i) -&gt;
        Mindmap.find kn knl
    | ConstructRef ((kn,_i),_j) -&gt;
        Mindmap.find kn knl
    | ConstRef cst -&gt;
        Cmap.find cst cstl in
  let c = (u, Array.map mkVar l) in
  RefTable.add cache r c;
  c</abbr>

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">share_univs</abbr> cache r u l =
  let (u', args) = share cache r l in
    mkApp (instantiate_my_gr r (Instance.append u' u), args)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">update_case_info</abbr> cache ci modlist =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let (_u,l) = share cache (IndRef ci.ci_ind) modlist in
    { ci with ci_npar = ci.ci_npar + Array.length l }
  with Not_found -&gt;
    ci</abbr>

let is_empty_modlist (cm, mm) =
  Cmap.is_empty cm &amp;&amp; Mindmap.is_empty mm

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">expmod_constr</abbr> cache modlist c =
  let share_univs = share_univs cache in
  let update_case_info = update_case_info cache in
  let rec substrec c =
    match kind c with
      | Case (ci,p,t,br) -&gt;
          Constr.map substrec (mkCase (update_case_info ci modlist,p,t,br))

      | Ind (ind,u) -&gt;
          <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
            share_univs (IndRef ind) u modlist
           with
            | Not_found -&gt; Constr.map substrec c)</abbr>

      | Construct (cstr,u) -&gt;
          <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
             share_univs (ConstructRef cstr) u modlist
           with
            | Not_found -&gt; Constr.map substrec c)</abbr>

      | Const (cst,u) -&gt;
          <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
            share_univs (ConstRef cst) u modlist
           with
            | Not_found -&gt; Constr.map substrec c)</abbr>

      | Proj (p, c') -&gt;
        let map cst npars =
          let _, newpars = Mindmap.find cst (snd modlist) in
          (cst, npars + Array.length newpars)
        in
        let p' = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Projection.map_npars map p with Not_found -&gt; p</abbr> in
        let c'' = substrec c' in
        if p == p' &amp;&amp; c' == c'' then c else mkProj (p', c'')

  | _ -&gt; Constr.map substrec c

  in
  if is_empty_modlist modlist then c
  else substrec c

(** Transforms a named context into a rel context. Also returns the list of
    variables [id1 ... idn] that need to be replaced by [Rel 1 ... Rel n] to
    abstract a term that lived in that context. *)
let abstract_context hyps =
  let fold decl (ctx, subst) =
    let id, decl = match decl with
    | NamedDecl.LocalDef (id, b, t) -&gt;
      let b = Vars.subst_vars subst b in
      let t = Vars.subst_vars subst t in
      id, RelDecl.LocalDef (map_annot Name.mk_name id, b, t)
    | NamedDecl.LocalAssum (id, t) -&gt;
      let t = Vars.subst_vars subst t in
      id, RelDecl.LocalAssum (map_annot Name.mk_name id, t)
    in
    (decl :: ctx, id.binder_name :: subst)
  in
  Context.Named.fold_outside fold hyps ~init:([], [])

let abstract_constant_type t (hyps, subst) =
  let t = Vars.subst_vars subst t in
  List.fold_left (fun c d -&gt; mkProd_wo_LetIn d c) t hyps

let abstract_constant_body c (hyps, subst) =
  let c = Vars.subst_vars subst c in
  it_mkLambda_or_LetIn c hyps

type recipe = { from : constant_body; info : Opaqueproof.cooking_info }
type inline = bool

type result = {
  cook_body : constr Mod_subst.substituted constant_def;
  cook_type : types;
  cook_universes : universes;
  cook_private_univs : Univ.ContextSet.t option;
  cook_relevance : Sorts.relevance;
  cook_inline : inline;
  cook_context : Constr.named_context option;
}

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">expmod_constr_subst</abbr> cache modlist subst c =
  let subst = Univ.make_instance_subst subst in
  let c = expmod_constr cache modlist c in
    Vars.subst_univs_level_constr subst c

let lift_univs cb subst auctx0 =
  match cb.const_universes with
  | Monomorphic ctx -&gt;
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (AUContext.is_empty auctx0);
    subst, (Monomorphic ctx)</abbr>
  | Polymorphic auctx -&gt;
    (** Given a named instance [subst := uâ ... uâââ] together with an abstract
        context [auctx0 := 0 ... n - 1 |= C{0, ..., n - 1}] of the same length,
        and another abstract context relative to the former context
        [auctx := 0 ... m - 1 |= C'{uâ, ..., uâââ, 0, ..., m - 1}],
        construct the lifted abstract universe context
        [0 ... n - 1 n ... n + m - 1 |=
          C{0, ... n - 1} âª
          C'{0, ..., n - 1, n, ..., n + m - 1} ]
        together with the instance
        [uâ ... uâââ Var(0) ... Var (m - 1)].
    *)
    if (Univ.Instance.is_empty subst) then
      (** Still need to take the union for the constraints between globals *)
      subst, (Polymorphic (AUContext.union auctx0 auctx))
    else
      let ainst = Univ.make_abstract_instance auctx in
      let subst = Instance.append subst ainst in
      let substf = Univ.make_instance_subst subst in
      let auctx' = Univ.subst_univs_level_abstract_universe_context substf auctx in
      subst, (Polymorphic (AUContext.union auctx0 auctx'))

let cook_constr { Opaqueproof.modlist ; abstract } c =
  let cache = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RefTable.create</abbr> 13 in
  let abstract, usubst, abs_ctx = abstract in
  (* For now the STM only handles deferred computation of monomorphic
    constants. The API will need to be adapted when it's not the case
    anymore. *)
  let () = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (AUContext.is_empty abs_ctx)</abbr> in
  let expmod = expmod_constr_subst cache modlist usubst in
  let hyps = Context.Named.map expmod abstract in
  let hyps = abstract_context hyps in
  abstract_constant_body (expmod c) hyps

let cook_constant { from = cb; info } =
  let { Opaqueproof.modlist; abstract } = info in
  let cache = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RefTable.create</abbr> 13 in
  let abstract, usubst, abs_ctx = abstract in
  let usubst, univs = lift_univs cb usubst abs_ctx in
  let expmod = expmod_constr_subst cache modlist usubst in
  let hyps0 = Context.Named.map expmod abstract in
  let hyps = abstract_context hyps0 in
  let map c = abstract_constant_body (expmod c) hyps in
  let body = match cb.const_body with
  | Undef _ as x -&gt; x
  | Def cs -&gt; Def (Mod_subst.from_val (map (Mod_subst.force_constr cs)))
  | OpaqueDef o -&gt;
    OpaqueDef (Opaqueproof.discharge_direct_opaque ~cook_constr:map info o)
  | Primitive _ -&gt; CErrors.anomaly (Pp.str &quot;Primitives cannot be cooked&quot;)
  in
  let const_hyps =
    Context.Named.fold_outside (fun decl hyps -&gt;
      List.filter (fun decl' -&gt; not (Id.equal (NamedDecl.get_id decl) (NamedDecl.get_id decl')))
                  hyps)
      hyps0 ~init:cb.const_hyps in
  let typ = abstract_constant_type (expmod cb.const_type) hyps in
  let private_univs = Option.map (on_snd (Univ.subst_univs_level_constraints
                                            (Univ.make_instance_subst usubst)))
      cb.const_private_poly_univs
  in
  {
    cook_body = body;
    cook_type = typ;
    cook_universes = univs;
    cook_private_univs = private_univs;
    cook_relevance = cb.const_relevance;
    cook_inline = cb.const_inline_code;
    cook_context = Some const_hyps;
  }

(* let cook_constant_key = CProfile.declare_profile &quot;cook_constant&quot; *)
(* let cook_constant = CProfile.profile2 cook_constant_key cook_constant *)

let expmod_constr modlist c = expmod_constr (<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RefTable.create</abbr> 13) modlist c
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cooking.ml"><code>Cooking.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Term.

Import Constr.

Import Declarations.

Import Univ.

Import Context.

Module NamedDecl := Context.Named.Declaration.

Module RelDecl := Context.Rel.Declaration.

Inductive my_global_reference : Set :=
| ConstRef : Names.Constant.t -&gt; my_global_reference
| IndRef : Names.inductive -&gt; my_global_reference
| ConstructRef : Names.constructor -&gt; my_global_reference.

Module RefHash.
  Definition t := my_global_reference.
  
  Definition equal (gr1 : my_global_reference) (gr2 : my_global_reference)
    : bool :=
    match (gr1, gr2) with
    | (ConstRef c1, ConstRef c2) =&gt; Constant.SyntacticOrd.equal c1 c2
    | (IndRef i1, IndRef i2) =&gt; eq_syntactic_ind i1 i2
    | (ConstructRef c1, ConstructRef c2) =&gt; eq_syntactic_constructor c1 c2
    | _ =&gt; false
    end.
  
  Import Hashset.Combine.
  
  Definition hash (function_parameter : my_global_reference) : Z :=
    match function_parameter with
    | ConstRef c =&gt; combinesmall 1 (Constant.SyntacticOrd.hash c)
    | IndRef i =&gt; combinesmall 2 (ind_syntactic_hash i)
    | ConstructRef c =&gt; combinesmall 3 (constructor_syntactic_hash c)
    end.
End RefHash.

Definition RefTable :=
  Hashtbl.Make
    (existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal :=
          (|RefHash|).(Stdlib__hashtbl.HashedType.equal);
        Stdlib__hashtbl.HashedType.hash :=
          (|RefHash|).(Stdlib__hashtbl.HashedType.hash)
      |}).

Definition instantiate_my_gr (gr : my_global_reference) (u : Univ.Instance.t)
  : Constr.constr :=
  match gr with
  | ConstRef c =&gt; mkConstU (c, u)
  | IndRef i =&gt; mkIndU (i, u)
  | ConstructRef c =&gt; mkConstructU (c, u)
  end.

Definition share {A : Set}
  (cache : (|RefTable|).(Stdlib__hashtbl.S.t) (A * array Constr.constr))
  (r : (|RefTable|).(Stdlib__hashtbl.S.key))
  (function_parameter :
    Names.Cmap.t (A * array Names.Id.t) * Names.Mindmap.t (A * array Names.Id.t))
  : A * array Constr.constr :=
  let '(cstl, knl) := function_parameter in
  (* ❌ Try-with are not handled *)
  try ((|RefTable|).(Stdlib__hashtbl.S.find) cache r).

Definition share_univs
  (cache :
    (|RefTable|).(Stdlib__hashtbl.S.t) (Univ.Instance.t * array Constr.constr))
  (r : (|RefTable|).(Stdlib__hashtbl.S.key)) (u : Univ.Instance.t)
  (l :
    Names.Cmap.t (Univ.Instance.t * array Names.Id.t) *
      Names.Mindmap.t (Univ.Instance.t * array Names.Id.t)) : Constr.constr :=
  let '(u', args) := share cache r l in
  mkApp ((instantiate_my_gr r (Instance.append u' u)), args).

Definition update_case_info {A : Set}
  (cache : (|RefTable|).(Stdlib__hashtbl.S.t) (A * array Constr.constr))
  (ci : Constr.case_info)
  (modlist :
    Names.Cmap.t (A * array Names.Id.t) * Names.Mindmap.t (A * array Names.Id.t))
  : Constr.case_info :=
  (* ❌ Try-with are not handled *)
  try
    (let '(_u, l) := share cache (IndRef (Constr.case_info.ci_ind ci)) modlist
      in
    Constr.case_info.with_ci_npar ci
      (Z.add (Constr.case_info.ci_npar ci)
        ((|Util.Array|).(CArray.ExtS.length) l))).

Definition is_empty_modlist {A B : Set}
  (function_parameter : Names.Cmap.t A * Names.Mindmap.t B) : bool :=
  let '(cm, mm) := function_parameter in
  andb (Cmap.is_empty cm) (Mindmap.is_empty mm).

Definition expmod_constr
  (cache :
    (|RefTable|).(Stdlib__hashtbl.S.t) (Univ.Instance.t * array Constr.constr))
  (modlist :
    Names.Cmap.t (Univ.Instance.t * array Names.Id.t) *
      Names.Mindmap.t (Univ.Instance.t * array Names.Id.t)) (c : Constr.constr)
  : Constr.constr :=
  let share_univs := share_univs cache in
  let update_case_info := update_case_info cache in
  let fix substrec (c : Constr.constr) {struct c} : Constr.constr :=
    match kind c with
    | Constr.Case ci p t br =&gt;
      Constr.map substrec (mkCase ((update_case_info ci modlist), p, t, br))
    | Constr.Ind (ind, u) =&gt;
      (* ❌ Try-with are not handled *)
      try (share_univs (IndRef ind) u modlist)
    | Constr.Construct (cstr, u) =&gt;
      (* ❌ Try-with are not handled *)
      try (share_univs (ConstructRef cstr) u modlist)
    | Constr.Const (cst, u) =&gt;
      (* ❌ Try-with are not handled *)
      try (share_univs (ConstRef cst) u modlist)
    | Constr.Proj p c' =&gt;
      let map (cst : Names.Mindmap.key) (npars : Z) : Names.Mindmap.key * Z :=
        let '(_, newpars) := Mindmap.find cst (snd modlist) in
        (cst, (Z.add npars ((|Util.Array|).(CArray.ExtS.length) newpars))) in
      let p' :=
        (* ❌ Try-with are not handled *)
        try (Projection.map_npars map p) in
      let c'' := substrec c' in
      if andb (Stdlib.op_eqeq p p') (Stdlib.op_eqeq c' c'') then
        c
      else
        mkProj (p', c'')
    | _ =&gt; Constr.map substrec c
    end in
  if is_empty_modlist modlist then
    c
  else
    substrec c.

Definition abstract_context
  (hyps : Context.Named.pt Constr.constr Constr.constr)
  : list (RelDecl.pt Constr.constr Constr.constr) * list Names.Id.t :=
  let fold
    (decl : NamedDecl.pt Constr.constr Constr.constr)
    (function_parameter :
      list (RelDecl.pt Constr.constr Constr.constr) * list Names.Id.t)
    : list (RelDecl.pt Constr.constr Constr.constr) * list Names.Id.t :=
    let '(ctx, subst) := function_parameter in
    let '(id, decl) :=
      match decl with
      | NamedDecl.LocalDef id b t =&gt;
        let b := Vars.subst_vars subst b in
        let t := Vars.subst_vars subst t in
        (id, (RelDecl.LocalDef (map_annot Name.mk_name id) b t))
      | NamedDecl.LocalAssum id t =&gt;
        let t := Vars.subst_vars subst t in
        (id, (RelDecl.LocalAssum (map_annot Name.mk_name id) t))
      end in
    ((cons decl ctx), (cons (Context.binder_annot.binder_name id) subst)) in
  Context.Named.fold_outside fold hyps ([], []).

Definition abstract_constant_type
  (t : Constr.constr)
  (function_parameter : list Constr.rel_declaration * list Names.Id.t)
  : Constr.types :=
  let '(hyps, subst) := function_parameter in
  let t := Vars.subst_vars subst t in
  (|Util.List|).(CList.ExtS.fold_left) (fun c =&gt; fun d =&gt; mkProd_wo_LetIn d c) t
    hyps.

Definition abstract_constant_body
  (c : Constr.constr)
  (function_parameter : Constr.rel_context * list Names.Id.t) : Constr.constr :=
  let '(hyps, subst) := function_parameter in
  let c := Vars.subst_vars subst c in
  it_mkLambda_or_LetIn c hyps.

Module recipe.
  Record record := {
    from : Declarations.constant_body;
    info : Opaqueproof.cooking_info }.
  Definition with_from (r : record) from : record :=
    {| from := from; info := info r |}.
  Definition with_info (r : record) info : record :=
    {| from := from r; info := info |}.
End recipe.
Definition recipe := recipe.record.

Definition inline := bool.

Module result.
  Record record := {
    cook_body : Declarations.constant_def (Mod_subst.substituted Constr.constr);
    cook_type : Constr.types;
    cook_universes : Declarations.universes;
    cook_private_univs : option Univ.ContextSet.t;
    cook_relevance : Sorts.relevance;
    cook_inline : inline;
    cook_context : option Constr.named_context }.
  Definition with_cook_body (r : record) cook_body : record :=
    {| cook_body := cook_body; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_type (r : record) cook_type : record :=
    {| cook_body := cook_body r; cook_type := cook_type;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_universes (r : record) cook_universes : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_private_univs (r : record) cook_private_univs : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_relevance (r : record) cook_relevance : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_inline (r : record) cook_inline : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline;
      cook_context := cook_context r |}.
  Definition with_cook_context (r : record) cook_context : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context |}.
End result.
Definition result := result.record.

Definition expmod_constr_subst
  (cache :
    (|RefTable|).(Stdlib__hashtbl.S.t) (Univ.Instance.t * array Constr.constr))
  (modlist :
    Names.Cmap.t (Univ.Instance.t * array Names.Id.t) *
      Names.Mindmap.t (Univ.Instance.t * array Names.Id.t))
  (subst : Univ.Instance.t) (c : Constr.constr) : Constr.constr :=
  let subst := Univ.make_instance_subst subst in
  let c := expmod_constr cache modlist c in
  Vars.subst_univs_level_constr subst c.

Definition lift_univs
  (cb : Declarations.constant_body) (subst : Univ.Instance.t)
  (auctx0 : Univ.AUContext.t) : Univ.Instance.t * Declarations.universes :=
  match Declarations.constant_body.const_universes cb with
  | Declarations.Monomorphic ctx =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (subst, (Declarations.Monomorphic ctx))
  | Declarations.Polymorphic auctx =&gt;
    if Univ.Instance.is_empty subst then
      (subst, (Declarations.Polymorphic (AUContext.union auctx0 auctx)))
    else
      let ainst := Univ.make_abstract_instance auctx in
      let subst := Instance.append subst ainst in
      let substf := Univ.make_instance_subst subst in
      let auctx' :=
        Univ.subst_univs_level_abstract_universe_context substf auctx in
      (subst, (Declarations.Polymorphic (AUContext.union auctx0 auctx')))
  end.

Definition cook_constr (function_parameter : Opaqueproof.cooking_info)
  : Constr.constr -&gt; Constr.constr :=
  let '{|
    Opaqueproof.cooking_info.modlist := modlist;
      Opaqueproof.cooking_info.abstract := abstract
      |} := function_parameter in
  fun c =&gt;
    let cache := (|RefTable|).(Stdlib__hashtbl.S.create) 13 in
    let '(abstract, usubst, abs_ctx) := abstract in
    let '_ :=
      (* ❌ Assert instruction is not handled. *)
      assert (AUContext.is_empty abs_ctx) in
    let expmod := expmod_constr_subst cache modlist usubst in
    let hyps := Context.Named.map expmod abstract in
    let hyps := abstract_context hyps in
    abstract_constant_body (expmod c) hyps.

Definition cook_constant (function_parameter : recipe) : result :=
  let '{| recipe.from := cb; recipe.info := info |} := function_parameter in
  let '{|
    Opaqueproof.cooking_info.modlist := modlist;
      Opaqueproof.cooking_info.abstract := abstract
      |} := info in
  let cache := (|RefTable|).(Stdlib__hashtbl.S.create) 13 in
  let '(abstract, usubst, abs_ctx) := abstract in
  let '(usubst, univs) := lift_univs cb usubst abs_ctx in
  let expmod := expmod_constr_subst cache modlist usubst in
  let hyps0 := Context.Named.map expmod abstract in
  let hyps := abstract_context hyps0 in
  let map (c : Constr.constr) : Constr.constr :=
    abstract_constant_body (expmod c) hyps in
  let body :=
    match Declarations.constant_body.const_body cb with
    | (Declarations.Undef _) as x =&gt; x
    | Declarations.Def cs =&gt;
      Declarations.Def (Mod_subst.from_val (map (Mod_subst.force_constr cs)))
    | Declarations.OpaqueDef o =&gt;
      Declarations.OpaqueDef (Opaqueproof.discharge_direct_opaque map info o)
    | Declarations.Primitive _ =&gt;
      CErrors.anomaly None None (Pp.str &quot;Primitives cannot be cooked&quot;)
    end in
  let const_hyps :=
    Context.Named.fold_outside
      (fun decl =&gt;
        fun hyps =&gt;
          (|Util.List|).(CList.ExtS.filter)
            (fun decl' =&gt;
              negb (Id.equal (NamedDecl.get_id decl) (NamedDecl.get_id decl')))
            hyps) hyps0 (Declarations.constant_body.const_hyps cb) in
  let typ :=
    abstract_constant_type (expmod (Declarations.constant_body.const_type cb))
      hyps in
  let private_univs :=
    Option.map
      (on_snd
        (Univ.subst_univs_level_constraints (Univ.make_instance_subst usubst)))
      (Declarations.constant_body.const_private_poly_univs cb) in
  {| result.cook_body := body; result.cook_type := typ;
    result.cook_universes := univs; result.cook_private_univs := private_univs;
    result.cook_relevance := Declarations.constant_body.const_relevance cb;
    result.cook_inline := Declarations.constant_body.const_inline_code cb;
    result.cook_context := Some const_hyps |}.

Definition expmod_constr
  (modlist :
    Names.Cmap.t (Univ.Instance.t * array Names.Id.t) *
      Names.Mindmap.t (Univ.Instance.t * array Names.Id.t)) (c : Constr.constr)
  : Constr.constr :=
  expmod_constr ((|RefTable|).(Stdlib__hashtbl.S.create) 13) modlist c.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cooking.mli">
  <div style="margin: 20px;">
    <h3>Cooking_mli</h3>
    <ul>
      <li>OCaml size: 35 lines</li>
      <li>Coq size: 85 lines (+142% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cooking.mli"><code>cooking.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Constr
open Declarations

(** {6 Cooking the constants. } *)

type recipe = { from : constant_body; info : Opaqueproof.cooking_info }

type inline = bool

type result = {
  cook_body : constr Mod_subst.substituted constant_def;
  cook_type : types;
  cook_universes : universes;
  cook_private_univs : Univ.ContextSet.t option;
  cook_relevance : Sorts.relevance;
  cook_inline : inline;
  cook_context : Constr.named_context option;
}

val cook_constant : recipe -&gt; result
val cook_constr : Opaqueproof.cooking_info -&gt; constr -&gt; constr

(** {6 Utility functions used in module [Discharge]. } *)

val expmod_constr : Opaqueproof.work_list -&gt; constr -&gt; constr

</pre>
  </div>
  <div class="col-md-6">
    <a href="#cooking.mli"><code>Cooking_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Module recipe.
  Record record := {
    from : Declarations.constant_body;
    info : Opaqueproof.cooking_info }.
  Definition with_from (r : record) from : record :=
    {| from := from; info := info r |}.
  Definition with_info (r : record) info : record :=
    {| from := from r; info := info |}.
End recipe.
Definition recipe := recipe.record.

Definition inline := bool.

Module result.
  Record record := {
    cook_body : Declarations.constant_def (Mod_subst.substituted Constr.constr);
    cook_type : Constr.types;
    cook_universes : Declarations.universes;
    cook_private_univs : option Univ.ContextSet.t;
    cook_relevance : Sorts.relevance;
    cook_inline : inline;
    cook_context : option Constr.named_context }.
  Definition with_cook_body (r : record) cook_body : record :=
    {| cook_body := cook_body; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_type (r : record) cook_type : record :=
    {| cook_body := cook_body r; cook_type := cook_type;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_universes (r : record) cook_universes : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_private_univs (r : record) cook_private_univs : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_relevance (r : record) cook_relevance : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance; cook_inline := cook_inline r;
      cook_context := cook_context r |}.
  Definition with_cook_inline (r : record) cook_inline : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline;
      cook_context := cook_context r |}.
  Definition with_cook_context (r : record) cook_context : record :=
    {| cook_body := cook_body r; cook_type := cook_type r;
      cook_universes := cook_universes r;
      cook_private_univs := cook_private_univs r;
      cook_relevance := cook_relevance r; cook_inline := cook_inline r;
      cook_context := cook_context |}.
End result.
Definition result := result.record.

Parameter cook_constant : recipe -&gt; result.

Parameter cook_constr :
  Opaqueproof.cooking_info -&gt; Constr.constr -&gt; Constr.constr.

Parameter expmod_constr :
  Opaqueproof.work_list -&gt; Constr.constr -&gt; Constr.constr.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="copcodes.ml">
  <div style="margin: 20px;">
    <h3>Copcodes</h3>
    <ul>
      <li>OCaml size: 239 lines</li>
      <li>Coq size: 250 lines (+4% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#copcodes.ml"><code>copcodes.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(* DO NOT EDIT: automatically generated by kernel/genOpcodeFiles.ml *)let opACC0 = 0

let opACC1 = 1

let opACC2 = 2

let opACC3 = 3

let opACC4 = 4

let opACC5 = 5

let opACC6 = 6

let opACC7 = 7

let opACC = 8

let opPUSH = 9

let opPUSHACC0 = 10

let opPUSHACC1 = 11

let opPUSHACC2 = 12

let opPUSHACC3 = 13

let opPUSHACC4 = 14

let opPUSHACC5 = 15

let opPUSHACC6 = 16

let opPUSHACC7 = 17

let opPUSHACC = 18

let opPOP = 19

let opENVACC1 = 20

let opENVACC2 = 21

let opENVACC3 = 22

let opENVACC4 = 23

let opENVACC = 24

let opPUSHENVACC1 = 25

let opPUSHENVACC2 = 26

let opPUSHENVACC3 = 27

let opPUSHENVACC4 = 28

let opPUSHENVACC = 29

let opPUSH_RETADDR = 30

let opAPPLY = 31

let opAPPLY1 = 32

let opAPPLY2 = 33

let opAPPLY3 = 34

let opAPPLY4 = 35

let opAPPTERM = 36

let opAPPTERM1 = 37

let opAPPTERM2 = 38

let opAPPTERM3 = 39

let opRETURN = 40

let opRESTART = 41

let opGRAB = 42

let opGRABREC = 43

let opCLOSURE = 44

let opCLOSUREREC = 45

let opCLOSURECOFIX = 46

let opOFFSETCLOSUREM2 = 47

let opOFFSETCLOSURE0 = 48

let opOFFSETCLOSURE2 = 49

let opOFFSETCLOSURE = 50

let opPUSHOFFSETCLOSUREM2 = 51

let opPUSHOFFSETCLOSURE0 = 52

let opPUSHOFFSETCLOSURE2 = 53

let opPUSHOFFSETCLOSURE = 54

let opGETGLOBAL = 55

let opPUSHGETGLOBAL = 56

let opMAKEBLOCK = 57

let opMAKEBLOCK1 = 58

let opMAKEBLOCK2 = 59

let opMAKEBLOCK3 = 60

let opMAKEBLOCK4 = 61

let opSWITCH = 62

let opPUSHFIELDS = 63

let opGETFIELD0 = 64

let opGETFIELD1 = 65

let opGETFIELD = 66

let opSETFIELD0 = 67

let opSETFIELD1 = 68

let opSETFIELD = 69

let opPROJ = 70

let opENSURESTACKCAPACITY = 71

let opCONST0 = 72

let opCONST1 = 73

let opCONST2 = 74

let opCONST3 = 75

let opCONSTINT = 76

let opPUSHCONST0 = 77

let opPUSHCONST1 = 78

let opPUSHCONST2 = 79

let opPUSHCONST3 = 80

let opPUSHCONSTINT = 81

let opACCUMULATE = 82

let opMAKESWITCHBLOCK = 83

let opMAKEACCU = 84

let opMAKEPROD = 85

let opBRANCH = 86

let opCHECKADDINT63 = 87

let opADDINT63 = 88

let opCHECKADDCINT63 = 89

let opCHECKADDCARRYCINT63 = 90

let opCHECKSUBINT63 = 91

let opSUBINT63 = 92

let opCHECKSUBCINT63 = 93

let opCHECKSUBCARRYCINT63 = 94

let opCHECKMULINT63 = 95

let opCHECKMULCINT63 = 96

let opCHECKDIVINT63 = 97

let opCHECKMODINT63 = 98

let opCHECKDIVEUCLINT63 = 99

let opCHECKDIV21INT63 = 100

let opCHECKLXORINT63 = 101

let opCHECKLORINT63 = 102

let opCHECKLANDINT63 = 103

let opCHECKLSLINT63 = 104

let opCHECKLSRINT63 = 105

let opCHECKADDMULDIVINT63 = 106

let opCHECKLSLINT63CONST1 = 107

let opCHECKLSRINT63CONST1 = 108

let opCHECKEQINT63 = 109

let opCHECKLTINT63 = 110

let opLTINT63 = 111

let opCHECKLEINT63 = 112

let opLEINT63 = 113

let opCHECKCOMPAREINT63 = 114

let opCHECKHEAD0INT63 = 115

let opCHECKTAIL0INT63 = 116

let opISINT = 117

let opAREINT2 = 118

let opSTOP = 119

</pre>
  </div>
  <div class="col-md-6">
    <a href="#copcodes.ml"><code>Copcodes.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition opACC0 : Z := 0.

Definition opACC1 : Z := 1.

Definition opACC2 : Z := 2.

Definition opACC3 : Z := 3.

Definition opACC4 : Z := 4.

Definition opACC5 : Z := 5.

Definition opACC6 : Z := 6.

Definition opACC7 : Z := 7.

Definition opACC : Z := 8.

Definition opPUSH : Z := 9.

Definition opPUSHACC0 : Z := 10.

Definition opPUSHACC1 : Z := 11.

Definition opPUSHACC2 : Z := 12.

Definition opPUSHACC3 : Z := 13.

Definition opPUSHACC4 : Z := 14.

Definition opPUSHACC5 : Z := 15.

Definition opPUSHACC6 : Z := 16.

Definition opPUSHACC7 : Z := 17.

Definition opPUSHACC : Z := 18.

Definition opPOP : Z := 19.

Definition opENVACC1 : Z := 20.

Definition opENVACC2 : Z := 21.

Definition opENVACC3 : Z := 22.

Definition opENVACC4 : Z := 23.

Definition opENVACC : Z := 24.

Definition opPUSHENVACC1 : Z := 25.

Definition opPUSHENVACC2 : Z := 26.

Definition opPUSHENVACC3 : Z := 27.

Definition opPUSHENVACC4 : Z := 28.

Definition opPUSHENVACC : Z := 29.

Definition opPUSH_RETADDR : Z := 30.

Definition opAPPLY : Z := 31.

Definition opAPPLY1 : Z := 32.

Definition opAPPLY2 : Z := 33.

Definition opAPPLY3 : Z := 34.

Definition opAPPLY4 : Z := 35.

Definition opAPPTERM : Z := 36.

Definition opAPPTERM1 : Z := 37.

Definition opAPPTERM2 : Z := 38.

Definition opAPPTERM3 : Z := 39.

Definition opRETURN : Z := 40.

Definition opRESTART : Z := 41.

Definition opGRAB : Z := 42.

Definition opGRABREC : Z := 43.

Definition opCLOSURE : Z := 44.

Definition opCLOSUREREC : Z := 45.

Definition opCLOSURECOFIX : Z := 46.

Definition opOFFSETCLOSUREM2 : Z := 47.

Definition opOFFSETCLOSURE0 : Z := 48.

Definition opOFFSETCLOSURE2 : Z := 49.

Definition opOFFSETCLOSURE : Z := 50.

Definition opPUSHOFFSETCLOSUREM2 : Z := 51.

Definition opPUSHOFFSETCLOSURE0 : Z := 52.

Definition opPUSHOFFSETCLOSURE2 : Z := 53.

Definition opPUSHOFFSETCLOSURE : Z := 54.

Definition opGETGLOBAL : Z := 55.

Definition opPUSHGETGLOBAL : Z := 56.

Definition opMAKEBLOCK : Z := 57.

Definition opMAKEBLOCK1 : Z := 58.

Definition opMAKEBLOCK2 : Z := 59.

Definition opMAKEBLOCK3 : Z := 60.

Definition opMAKEBLOCK4 : Z := 61.

Definition opSWITCH : Z := 62.

Definition opPUSHFIELDS : Z := 63.

Definition opGETFIELD0 : Z := 64.

Definition opGETFIELD1 : Z := 65.

Definition opGETFIELD : Z := 66.

Definition opSETFIELD0 : Z := 67.

Definition opSETFIELD1 : Z := 68.

Definition opSETFIELD : Z := 69.

Definition opPROJ : Z := 70.

Definition opENSURESTACKCAPACITY : Z := 71.

Definition opCONST0 : Z := 72.

Definition opCONST1 : Z := 73.

Definition opCONST2 : Z := 74.

Definition opCONST3 : Z := 75.

Definition opCONSTINT : Z := 76.

Definition opPUSHCONST0 : Z := 77.

Definition opPUSHCONST1 : Z := 78.

Definition opPUSHCONST2 : Z := 79.

Definition opPUSHCONST3 : Z := 80.

Definition opPUSHCONSTINT : Z := 81.

Definition opACCUMULATE : Z := 82.

Definition opMAKESWITCHBLOCK : Z := 83.

Definition opMAKEACCU : Z := 84.

Definition opMAKEPROD : Z := 85.

Definition opBRANCH : Z := 86.

Definition opCHECKADDINT63 : Z := 87.

Definition opADDINT63 : Z := 88.

Definition opCHECKADDCINT63 : Z := 89.

Definition opCHECKADDCARRYCINT63 : Z := 90.

Definition opCHECKSUBINT63 : Z := 91.

Definition opSUBINT63 : Z := 92.

Definition opCHECKSUBCINT63 : Z := 93.

Definition opCHECKSUBCARRYCINT63 : Z := 94.

Definition opCHECKMULINT63 : Z := 95.

Definition opCHECKMULCINT63 : Z := 96.

Definition opCHECKDIVINT63 : Z := 97.

Definition opCHECKMODINT63 : Z := 98.

Definition opCHECKDIVEUCLINT63 : Z := 99.

Definition opCHECKDIV21INT63 : Z := 100.

Definition opCHECKLXORINT63 : Z := 101.

Definition opCHECKLORINT63 : Z := 102.

Definition opCHECKLANDINT63 : Z := 103.

Definition opCHECKLSLINT63 : Z := 104.

Definition opCHECKLSRINT63 : Z := 105.

Definition opCHECKADDMULDIVINT63 : Z := 106.

Definition opCHECKLSLINT63CONST1 : Z := 107.

Definition opCHECKLSRINT63CONST1 : Z := 108.

Definition opCHECKEQINT63 : Z := 109.

Definition opCHECKLTINT63 : Z := 110.

Definition opLTINT63 : Z := 111.

Definition opCHECKLEINT63 : Z := 112.

Definition opLEINT63 : Z := 113.

Definition opCHECKCOMPAREINT63 : Z := 114.

Definition opCHECKHEAD0INT63 : Z := 115.

Definition opCHECKTAIL0INT63 : Z := 116.

Definition opISINT : Z := 117.

Definition opAREINT2 : Z := 118.

Definition opSTOP : Z := 119.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="csymtable.ml">
  <div style="margin: 20px;">
    <h3>Csymtable</h3>
    <ul>
      <li>OCaml size: 196 lines</li>
      <li>Coq size: 230 lines (+17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#csymtable.ml"><code>csymtable.ml</code></a>&nbsp;<span class="label label-warning">29 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras for Benjamin GrÃ©goire as part of the
   bytecode-based reduction machine, Oct 2004 *)
(* Bug fix #1419 by Jean-Marc Notin, Mar 2007 *)

(* This file manages the table of global symbols for the bytecode machine *)

open Util
open Names
open Vmvalues
open Cemitcodes
open Cbytecodes
open Declarations
open Environ
open Cbytegen

module NamedDecl = Context.Named.Declaration
module RelDecl = Context.Rel.Declaration

external eval_tcode : tcode -&gt; atom array -&gt; vm_global -&gt; values array -&gt; values = &quot;coq_eval_tcode&quot;

type global_data = { mutable glob_len : int; mutable glob_val : values array }

(*******************)
(* Linkage du code *)
(*******************)

(* Table des globaux *)

(* [global_data] contient les valeurs des constantes globales
   (axiomes,definitions), les annotations des switch et les structured
   constant *)
let global_data = {
  glob_len = 0;
  glob_val = Array.make 4096 crazy_val;
}

let get_global_data () = Vmvalues.vm_global global_data.glob_val

let realloc_global_data n =
  let n = min (2 * n + 0x100) Sys.max_array_length in
  let ans = Array.make n crazy_val in
  let src = global_data.glob_val in
  let () = Array.blit src 0 ans 0 (Array.length src) in
  <abbr class="mark-warning" title="Set record field not handled.">global_data.glob_val &lt;- ans</abbr>

let check_global_data n =
  if n &gt;= Array.length global_data.glob_val then realloc_global_data n

let set_global v =
  let n = global_data.glob_len in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_global_data n;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">global_data.glob_val.(n) &lt;- v;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">global_data.glob_len &lt;- global_data.glob_len + 1;
  n</abbr>

(* table pour les structured_constant et les annotations des switchs *)

module SConstTable = Hashtbl.Make (<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">struct
  type t = structured_constant
  let equal = eq_structured_constant
  let hash = hash_structured_constant
end</abbr>)

module AnnotTable = Hashtbl.Make (<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">struct
  type t = annot_switch
  let equal = eq_annot_switch
  let hash = hash_annot_switch
end</abbr>)

module ProjNameTable = Hashtbl.Make (<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Projection.Repr</abbr>)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">str_cst_tbl</abbr> : int SConstTable.t = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">SConstTable.create</abbr> 31

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">annot_tbl</abbr> : int AnnotTable.t = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">AnnotTable.create</abbr> 31
    (* (annot_switch * int) Hashtbl.t  *)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">proj_name_tbl</abbr> : int ProjNameTable.t = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ProjNameTable.create</abbr> 31

(*************************************************************)
(*** Mise a jour des valeurs des variables et des constantes *)
(*************************************************************)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception NotEvaluated</abbr>

let key rk =
  match !rk with
  | None -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotEvaluated</abbr>
  | Some k -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try CEphemeron.get k
      with CEphemeron.InvalidKey -&gt; raise NotEvaluated</abbr>

(************************)
(* traduction des patch *)

(* slot_for_*, calcul la valeur de l'objet, la place
   dans la table global, rend sa position dans la table *)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">slot_for_str_cst</abbr> key =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">SConstTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> str_cst_tbl key
  with Not_found -&gt;
    let n = set_global (val_of_str_const key) in
    SConstTable.add str_cst_tbl key n;
    n</abbr>

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">slot_for_annot</abbr> key =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">AnnotTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> annot_tbl key
  with Not_found -&gt;
    let n =  set_global (val_of_annot_switch key) in
    AnnotTable.add annot_tbl key n;
    n</abbr>

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">slot_for_proj_name</abbr> key =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ProjNameTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> proj_name_tbl key
  with Not_found -&gt;
    let n =  set_global (val_of_proj_name key) in
    ProjNameTable.add proj_name_tbl key n;
    n</abbr>

let rec slot_for_getglobal env kn =
  let (cb,(_,rk)) = lookup_constant_key kn env in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try key rk
  with NotEvaluated -&gt;
(*    Pp.msgnl(str&quot;not yet evaluated&quot;);*)
    let pos =
      match cb.const_body_code with
      | None -&gt; set_global (val_of_constant kn)
      | Some code -&gt;
         match Cemitcodes.force code with
         | BCdefined(code,pl,fv) -&gt;
           let v = eval_to_patch env (code,pl,fv) in
           set_global v
         | BCalias kn' -&gt; slot_for_getglobal env kn'
         | BCconstant -&gt; set_global (val_of_constant kn)
    in
(*Pp.msgnl(str&quot;value stored at: &quot;++int pos);*)
    rk := Some (CEphemeron.create pos);
    pos</abbr>

and slot_for_fv env fv =
  let fill_fv_cache cache id v_of_id env_of_id b =
    let v,d =
      match b with
      | None -&gt; v_of_id id, Id.Set.empty
      | Some c -&gt;
          val_of_constr (env_of_id id env) c,
          Environ.global_vars_set env c in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">build_lazy_val cache (v, d); v</abbr> in
  let val_of_rel i = val_of_rel (nb_rel env - i) in
  let idfun _ x = x in
  match fv with
  | FVnamed id -&gt;
      let nv = lookup_named_val id env in
      begin match force_lazy_val nv with
      | None -&gt;
         env |&gt; lookup_named id |&gt; NamedDecl.get_value |&gt; fill_fv_cache nv id val_of_named idfun
      | Some (v, _) -&gt; v
      end
  | FVrel i -&gt;
      let rv = lookup_rel_val i env in
      begin match force_lazy_val rv with
      | None -&gt;
        env |&gt; lookup_rel i |&gt; RelDecl.get_value |&gt; fill_fv_cache rv i val_of_rel env_of_rel
      | Some (v, _) -&gt; v
      end
  | FVevar evk -&gt; val_of_evar evk
  | FVuniv_var _idu -&gt;
    <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

and eval_to_patch env (buff,pl,fv) =
  let slots = function
    | Reloc_annot a -&gt; slot_for_annot a
    | Reloc_const sc -&gt; slot_for_str_cst sc
    | Reloc_getglobal kn -&gt; slot_for_getglobal env kn
    | Reloc_proj_name p -&gt; slot_for_proj_name p
  in
  let tc = patch buff pl slots in
  let vm_env = Array.map (slot_for_fv env) fv in
  eval_tcode tc (get_atom_rel ()) (vm_global global_data.glob_val) vm_env

and val_of_constr env c =
  match compile ~fail_on_error:true env c with
  | Some v -&gt; eval_to_patch env (to_memory v)
  | None -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let set_transparent_const _kn = () (* !?! *)
let set_opaque_const _kn = () (* !?! *)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#csymtable.ml"><code>Csymtable.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Vmvalues.

Import Cemitcodes.

Import Cbytecodes.

Import Declarations.

Import Environ.

Import Cbytegen.

Module NamedDecl := Context.Named.Declaration.

Module RelDecl := Context.Rel.Declaration.

Parameter eval_tcode :
Vmvalues.tcode -&gt; array Vmvalues.atom -&gt; Vmvalues.vm_global -&gt;
array Vmvalues.values -&gt; Vmvalues.values.

Module global_data.
  Record record := {
    glob_len : Z;
    glob_val : array Vmvalues.values }.
  Definition with_glob_len (r : record) glob_len : record :=
    {| glob_len := glob_len; glob_val := glob_val r |}.
  Definition with_glob_val (r : record) glob_val : record :=
    {| glob_len := glob_len r; glob_val := glob_val |}.
End global_data.
Definition global_data := global_data.record.

Definition global_data : global_data :=
  {| global_data.glob_len := 0;
    global_data.glob_val := (|Util.Array|).(CArray.ExtS.make) 4096 crazy_val |}.

Definition get_global_data (function_parameter : unit) : Vmvalues.vm_global :=
  let '_ := function_parameter in
  Vmvalues.vm_global (global_data.glob_val global_data).

Definition realloc_global_data (n : Z) : unit :=
  let n := OCaml.Stdlib.min (Z.add (Z.mul 2 n) 256) Sys.max_array_length in
  let ans := (|Util.Array|).(CArray.ExtS.make) n crazy_val in
  let src := global_data.glob_val global_data in
  let '_ :=
    (|Util.Array|).(CArray.ExtS.blit) src 0 ans 0
      ((|Util.Array|).(CArray.ExtS.length) src) in
  (* ❌ Set record field not handled. *)
  set_record_field global_data &quot;glob_val&quot; ans.

Definition check_global_data (n : Z) : unit :=
  if
    OCaml.Stdlib.ge n
      ((|Util.Array|).(CArray.ExtS.length) (global_data.glob_val global_data))
    then
    realloc_global_data n
  else
    tt.

Definition set_global (v : Vmvalues.values) : Z :=
  let n := global_data.glob_len global_data in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  n.

Definition SConstTable :=
  Hashtbl.Make
    (let t := Vmvalues.structured_constant in
    let equal := eq_structured_constant in
    let hash := hash_structured_constant in
    existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal := equal;
        Stdlib__hashtbl.HashedType.hash := hash
      |}).

Definition AnnotTable :=
  Hashtbl.Make
    (let t := Vmvalues.annot_switch in
    let equal := eq_annot_switch in
    let hash := hash_annot_switch in
    existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal := equal;
        Stdlib__hashtbl.HashedType.hash := hash
      |}).

Definition ProjNameTable :=
  Hashtbl.Make
    (existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal := Names.Projection.Repr.equal;
        Stdlib__hashtbl.HashedType.hash := Names.Projection.Repr.hash
      |}).

Definition str_cst_tbl : (|SConstTable|).(Stdlib__hashtbl.S.t) Z :=
  (|SConstTable|).(Stdlib__hashtbl.S.create) 31.

Definition annot_tbl : (|AnnotTable|).(Stdlib__hashtbl.S.t) Z :=
  (|AnnotTable|).(Stdlib__hashtbl.S.create) 31.

Definition proj_name_tbl : (|ProjNameTable|).(Stdlib__hashtbl.S.t) Z :=
  (|ProjNameTable|).(Stdlib__hashtbl.S.create) 31.

(* ❌ The definition of exceptions is not handled. *)
(* exception NotEvaluated *)

Definition key {A : Set} (rk : Stdlib.ref (option (CEphemeron.key A))) : A :=
  match Stdlib.op_exclamation rk with
  | None =&gt; Stdlib.raise extensible_type_value
  | Some k =&gt;
    (* ❌ Try-with are not handled *)
    try (CEphemeron.get k)
  end.

Definition slot_for_str_cst (key : (|SConstTable|).(Stdlib__hashtbl.S.key))
  : Z :=
  (* ❌ Try-with are not handled *)
  try ((|SConstTable|).(Stdlib__hashtbl.S.find) str_cst_tbl key).

Definition slot_for_annot (key : (|AnnotTable|).(Stdlib__hashtbl.S.key)) : Z :=
  (* ❌ Try-with are not handled *)
  try ((|AnnotTable|).(Stdlib__hashtbl.S.find) annot_tbl key).

Definition slot_for_proj_name (key : (|ProjNameTable|).(Stdlib__hashtbl.S.key))
  : Z :=
  (* ❌ Try-with are not handled *)
  try ((|ProjNameTable|).(Stdlib__hashtbl.S.find) proj_name_tbl key).

Fixpoint slot_for_getglobal (env : Environ.env) (kn : Names.Constant.t)
  {struct env} : Z :=
  let '(cb, (_, rk)) := lookup_constant_key kn env in
  (* ❌ Try-with are not handled *)
  try (key rk)

with slot_for_fv (env : Environ.env) (fv : Cbytecodes.fv_elem) {struct env}
  : Vmvalues.values :=
  let fill_fv_cache {A : Set}
    (cache : Environ.lazy_val) (id : A) (v_of_id : A -&gt; Vmvalues.values)
    (env_of_id : A -&gt; Environ.env -&gt; Environ.env) (b : option Constr.constr)
    : Vmvalues.values :=
    let '(v, d) :=
      match b with
      | None =&gt; ((v_of_id id), Id.__Set.empty)
      | Some c =&gt;
        ((val_of_constr (env_of_id id env) c), (Environ.global_vars_set env c))
      end in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    v in
  let val_of_rel (i : Z) : Vmvalues.values :=
    val_of_rel (Z.sub (nb_rel env) i) in
  let idfun {A B : Set} (function_parameter : A) : B -&gt; B :=
    let '_ := function_parameter in
    fun x =&gt; x in
  match fv with
  | Cbytecodes.FVnamed id =&gt;
    let nv := lookup_named_val id env in
    match force_lazy_val nv with
    | None =&gt;
      OCaml.Stdlib.reverse_apply
        (OCaml.Stdlib.reverse_apply
          (OCaml.Stdlib.reverse_apply env (lookup_named id)) NamedDecl.get_value)
        (fill_fv_cache nv id val_of_named idfun)
    | Some (v, _) =&gt; v
    end
  | Cbytecodes.FVrel i =&gt;
    let rv := lookup_rel_val i env in
    match force_lazy_val rv with
    | None =&gt;
      OCaml.Stdlib.reverse_apply
        (OCaml.Stdlib.reverse_apply
          (OCaml.Stdlib.reverse_apply env (lookup_rel i)) RelDecl.get_value)
        (fill_fv_cache rv i val_of_rel env_of_rel)
    | Some (v, _) =&gt; v
    end
  | Cbytecodes.FVevar evk =&gt; val_of_evar evk
  | Cbytecodes.FVuniv_var _idu =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end

with eval_to_patch
  (env : Environ.env)
  (function_parameter :
    Cemitcodes.emitcodes * Cemitcodes.patches * Cbytecodes.fv) {struct env}
  : Vmvalues.values :=
  let '(buff, pl, fv) := function_parameter in
  let slots (function_parameter : Cemitcodes.reloc_info) : Z :=
    match function_parameter with
    | Cemitcodes.Reloc_annot a =&gt; slot_for_annot a
    | Cemitcodes.Reloc_const sc =&gt; slot_for_str_cst sc
    | Cemitcodes.Reloc_getglobal kn =&gt; slot_for_getglobal env kn
    | Cemitcodes.Reloc_proj_name p =&gt; slot_for_proj_name p
    end in
  let tc := patch buff pl slots in
  let vm_env := (|Util.Array|).(CArray.ExtS.map) (slot_for_fv env) fv in
  eval_tcode tc (get_atom_rel tt) (vm_global (global_data.glob_val global_data))
    vm_env

with val_of_constr (env : Environ.env) (c : Constr.constr) {struct env}
  : Vmvalues.values :=
  match compile true None env c with
  | Some v =&gt; eval_to_patch env (to_memory v)
  | None =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition set_transparent_const {A : Set} (_kn : A) : unit := tt.

Definition set_opaque_const {A : Set} (_kn : A) : unit := tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="csymtable.mli">
  <div style="margin: 20px;">
    <h3>Csymtable_mli</h3>
    <ul>
      <li>OCaml size: 22 lines</li>
      <li>Coq size: 18 lines (-19% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#csymtable.mli"><code>csymtable.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* $Id$ *)

open Names
open Constr
open Environ

val val_of_constr : env -&gt; constr -&gt; Vmvalues.values

val set_opaque_const      : Constant.t -&gt; unit
val set_transparent_const : Constant.t -&gt; unit

val get_global_data : unit -&gt; Vmvalues.vm_global
</pre>
  </div>
  <div class="col-md-6">
    <a href="#csymtable.mli"><code>Csymtable_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter val_of_constr : Environ.env -&gt; Constr.constr -&gt; Vmvalues.values.

Parameter set_opaque_const : Names.Constant.t -&gt; unit.

Parameter set_transparent_const : Names.Constant.t -&gt; unit.

Parameter get_global_data : unit -&gt; Vmvalues.vm_global.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="declarations.ml">
  <div style="margin: 20px;">
    <h3>Declarations</h3>
    <ul>
      <li>OCaml size: 322 lines</li>
      <li>Coq size: 703 lines (+118% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#declarations.ml"><code>declarations.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr

(** This module defines the internal representation of global
   declarations. This includes global constants/axioms, mutual
   inductive definitions, modules and module types *)

type set_predicativity = ImpredicativeSet | PredicativeSet

type engagement = set_predicativity

(** {6 Representation of constants (Definition/Axiom) } *)

(** Non-universe polymorphic mode polymorphism (Coq 8.2+): inductives
    and constants hiding inductives are implicitly polymorphic when
    applied to parameters, on the universes appearing in the whnf of
    their parameters and their conclusion, in a template style.

    In truly universe polymorphic mode, we always use RegularArity.
*)

type template_arity = {
  template_param_levels : Univ.Level.t option list;
  template_level : Univ.Universe.t;
}

type ('a, 'b) declaration_arity =
  | RegularArity of 'a
  | TemplateArity of 'b

(** Inlining level of parameters at functor applications.
    None means no inlining *)

type inline = int option

(** A constant can have no body (axiom/parameter), or a
    transparent body, or an opaque one *)

(* Global declarations (i.e. constants) can be either: *)
type 'a constant_def =
  | Undef of inline                       (** a global assumption *)
  | Def of 'a                             (** or a transparent global definition *)
  | OpaqueDef of Opaqueproof.opaque       (** or an opaque global definition *)
  | Primitive of CPrimitives.t            (** or a primitive operation *)

type universes =
  | Monomorphic of Univ.ContextSet.t
  | Polymorphic of Univ.AUContext.t

(** The [typing_flags] are instructions to the type-checker which
    modify its behaviour. The typing flags used in the type-checking
    of a constant are tracked in their {!constant_body} so that they
    can be displayed to the user. *)
type typing_flags = {
  check_guarded : bool;
  (** If [false] then fixed points and co-fixed points are assumed to
      be total. *)

  check_universes : bool;
  (** If [false] universe constraints are not checked *)

  conv_oracle : Conv_oracle.oracle;
  (** Unfolding strategies for conversion *)

  share_reduction : bool;
  (** Use by-need reduction algorithm *)

  enable_VM : bool;
  (** If [false], all VM conversions fall back to interpreted ones *)

  enable_native_compiler : bool;
  (** If [false], all native conversions fall back to VM ones *)

  indices_matter: bool;
  (** The universe of an inductive type must be above that of its indices. *)

  check_template : bool;
  (* If [false] then we don't check that the universes template-polymorphic
     inductive parameterize on are necessarily local and unbounded from below.
     This potentially introduces inconsistencies. *)
}

(* some contraints are in constant_constraints, some other may be in
 * the OpaqueDef *)
type constant_body = {
    const_hyps : Constr.named_context; (** New: younger hyp at top *)
    const_body : Constr.t Mod_subst.substituted constant_def;
    const_type : types;
    const_relevance : Sorts.relevance;
    const_body_code : Cemitcodes.to_patch_substituted option;
    const_universes : universes;
    const_private_poly_univs : Univ.ContextSet.t option;
    const_inline_code : bool;
    const_typing_flags : typing_flags; (** The typing options which
                                           were used for
                                           type-checking. *)
}

(** {6 Representation of mutual inductive types in the kernel } *)

type recarg =
  | Norec
  | Mrec of inductive
  | Imbr of inductive

type wf_paths = recarg Rtree.t

(**
{v
   Inductive I1 (params) : U1 := c11 : T11 | ... | c1p1 : T1p1
   ...
   with      In (params) : Un := cn1 : Tn1 | ... | cnpn : Tnpn
v}
*)

(** Record information:
    If the type is not a record, then NotRecord
    If the type is a non-primitive record, then FakeRecord
    If it is a primitive record, for every type in the block, we get:
    - The identifier for the binder name of the record in primitive projections.
    - The constants associated to each projection.
    - The projection types (under parameters).

    The kernel does not exploit the difference between [NotRecord] and
    [FakeRecord]. It is mostly used by extraction, and should be extruded from
    the kernel at some point.
*)

type record_info =
| NotRecord
| FakeRecord
| PrimRecord of (Id.t * Label.t array * Sorts.relevance array * types array) array

type regular_inductive_arity = {
  mind_user_arity : types;
  mind_sort : Sorts.t;
}

type inductive_arity = (regular_inductive_arity, template_arity) declaration_arity

type one_inductive_body = {
(** {8 Primitive datas } *)

    mind_typename : Id.t; (** Name of the type: [Ii] *)

    mind_arity_ctxt : Constr.rel_context; (** Arity context of [Ii] with parameters: [forall params, Ui] *)

    mind_arity : inductive_arity; (** Arity sort and original user arity *)

    mind_consnames : Id.t array; (** Names of the constructors: [cij] *)

    mind_user_lc : types array;
 (** Types of the constructors with parameters:  [forall params, Tij],
     where the Ik are replaced by de Bruijn index in the
     context I1:forall params, U1 ..  In:forall params, Un *)

(** {8 Derived datas } *)

    mind_nrealargs : int; (** Number of expected real arguments of the type (no let, no params) *)

    mind_nrealdecls : int; (** Length of realargs context (with let, no params) *)

    mind_kelim : Sorts.family list; (** List of allowed elimination sorts *)

    mind_nf_lc : (rel_context * types) array; (** Head normalized constructor types so that their conclusion exposes the inductive type *)

    mind_consnrealargs : int array;
 (** Number of expected proper arguments of the constructors (w/o params) *)

    mind_consnrealdecls : int array;
 (** Length of the signature of the constructors (with let, w/o params) *)

    mind_recargs : wf_paths; (** Signature of recursive arguments in the constructors *)

    mind_relevance : Sorts.relevance;

(** {8 Datas for bytecode compilation } *)

    mind_nb_constant : int; (** number of constant constructor *)

    mind_nb_args : int; (** number of no constant constructor *)

    mind_reloc_tbl :  Vmvalues.reloc_table;
  }

type recursivity_kind =
  | Finite (** = inductive *)
  | CoFinite (** = coinductive *)
  | BiFinite (** = non-recursive, like in &quot;Record&quot; definitions *)

type mutual_inductive_body = {

    mind_packets : one_inductive_body array;  (** The component of the mutual inductive block *)

    mind_record : record_info; (** The record information *)

    mind_finite : recursivity_kind;  (** Whether the type is inductive or coinductive *)

    mind_ntypes : int;  (** Number of types in the block *)

    mind_hyps : Constr.named_context;  (** Section hypotheses on which the block depends *)

    mind_nparams : int;  (** Number of expected parameters including non-uniform ones (i.e. length of mind_params_ctxt w/o let-in) *)

    mind_nparams_rec : int;  (** Number of recursively uniform (i.e. ordinary) parameters *)

    mind_params_ctxt : Constr.rel_context;  (** The context of parameters (includes let-in declaration) *)

    mind_universes : universes; (** Information about monomorphic/polymorphic/cumulative inductives and their universes *)

    mind_variance : Univ.Variance.t array option; (** Variance info, [None] when non-cumulative. *)

    mind_private : bool option; (** allow pattern-matching: Some true ok, Some false blocked *)

    mind_typing_flags : typing_flags; (** typing flags at the time of the inductive creation *)
}

(** {6 Module declarations } *)

(** Functor expressions are forced to be on top of other expressions *)

type ('ty,'a) functorize =
  | NoFunctor of 'a
  | MoreFunctor of MBId.t * 'ty * ('ty,'a) functorize

(** The fully-algebraic module expressions : names, applications, 'with ...'.
    They correspond to the user entries of non-interactive modules.
    They will be later expanded into module structures in [Mod_typing],
    and won't play any role into the kernel after that : they are kept
    only for short module printing and for extraction. *)

type with_declaration =
  | WithMod of Id.t list * ModPath.t
  | WithDef of Id.t list * (constr * Univ.AUContext.t option)

type module_alg_expr =
  | MEident of ModPath.t
  | MEapply of module_alg_expr * ModPath.t
  | MEwith of module_alg_expr * with_declaration

(** A component of a module structure *)

type structure_field_body =
  | SFBconst of constant_body
  | SFBmind of mutual_inductive_body
  | SFBmodule of module_body
  | SFBmodtype of module_type_body

(** A module structure is a list of labeled components.

    Note : we may encounter now (at most) twice the same label in
    a [structure_body], once for a module ([SFBmodule] or [SFBmodtype])
    and once for an object ([SFBconst] or [SFBmind]) *)

and structure_body = (Label.t * structure_field_body) list

(** A module signature is a structure, with possibly functors on top of it *)

and module_signature = (module_type_body,structure_body) functorize

(** A module expression is an algebraic expression, possibly functorized. *)

and module_expression = (module_type_body,module_alg_expr) functorize

and module_implementation =
  | Abstract (** no accessible implementation *)
  | Algebraic of module_expression (** non-interactive algebraic expression *)
  | Struct of module_signature (** interactive body *)
  | FullStruct (** special case of [Struct] : the body is exactly [mod_type] *)

and 'a generic_module_body =
  { mod_mp : ModPath.t; (** absolute path of the module *)
    mod_expr : 'a; (** implementation *)
    mod_type : module_signature; (** expanded type *)
    mod_type_alg : module_expression option; (** algebraic type *)
    mod_constraints : Univ.ContextSet.t; (**
      set of all universes constraints in the module  *)
    mod_delta : Mod_subst.delta_resolver; (**
      quotiented set of equivalent constants and inductive names *)
    mod_retroknowledge : 'a module_retroknowledge }

(** For a module, there are five possible situations:
    - [Declare Module M : T] then [mod_expr = Abstract; mod_type_alg = Some T]
    - [Module M := E] then [mod_expr = Algebraic E; mod_type_alg = None]
    - [Module M : T := E] then [mod_expr = Algebraic E; mod_type_alg = Some T]
    - [Module M. ... End M] then [mod_expr = FullStruct; mod_type_alg = None]
    - [Module M : T. ... End M] then [mod_expr = Struct; mod_type_alg = Some T]
    And of course, all these situations may be functors or not. *)

and module_body = module_implementation generic_module_body

(** A [module_type_body] is just a [module_body] with no implementation and
    also an empty [mod_retroknowledge]. Its [mod_type_alg] contains
    the algebraic definition of this module type, or [None]
    if it has been built interactively. *)

and module_type_body = unit generic_module_body

and _ module_retroknowledge =
| ModBodyRK :
  Retroknowledge.action list -&gt; module_implementation module_retroknowledge
| ModTypeRK : unit module_retroknowledge

(** Extra invariants :

    - No [MEwith] inside a [mod_expr] implementation : the 'with' syntax
      is only supported for module types

    - A module application is atomic, for instance ((M N) P) :
      * the head of [MEapply] can only be another [MEapply] or a [MEident]
      * the argument of [MEapply] is now directly forced to be a [ModPath.t].
*)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#declarations.ml"><code>Declarations.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Constr.

Inductive set_predicativity : Set :=
| ImpredicativeSet : set_predicativity
| PredicativeSet : set_predicativity.

Definition engagement := set_predicativity.

Module template_arity.
  Record record := {
    template_param_levels : list (option Univ.Level.t);
    template_level : Univ.Universe.t }.
  Definition with_template_param_levels (r : record) template_param_levels
    : record :=
    {| template_param_levels := template_param_levels;
      template_level := template_level r |}.
  Definition with_template_level (r : record) template_level : record :=
    {| template_param_levels := template_param_levels r;
      template_level := template_level |}.
End template_arity.
Definition template_arity := template_arity.record.

Inductive declaration_arity (a b : Set) : Set :=
| RegularArity : a -&gt; declaration_arity a b
| TemplateArity : b -&gt; declaration_arity a b.

Arguments RegularArity {_ _}.
Arguments TemplateArity {_ _}.

Definition inline := option Z.

Inductive constant_def (a : Set) : Set :=
| Undef : inline -&gt; constant_def a
| Def : a -&gt; constant_def a
| OpaqueDef : Opaqueproof.opaque -&gt; constant_def a
| Primitive : CPrimitives.t -&gt; constant_def a.

Arguments Undef {_}.
Arguments Def {_}.
Arguments OpaqueDef {_}.
Arguments Primitive {_}.

Inductive universes : Set :=
| Monomorphic : Univ.ContextSet.t -&gt; universes
| Polymorphic : Univ.AUContext.t -&gt; universes.

Module typing_flags.
  Record record := {
    check_guarded : bool;
    check_universes : bool;
    conv_oracle : Conv_oracle.oracle;
    share_reduction : bool;
    enable_VM : bool;
    enable_native_compiler : bool;
    indices_matter : bool;
    check_template : bool }.
  Definition with_check_guarded (r : record) check_guarded : record :=
    {| check_guarded := check_guarded; check_universes := check_universes r;
      conv_oracle := conv_oracle r; share_reduction := share_reduction r;
      enable_VM := enable_VM r;
      enable_native_compiler := enable_native_compiler r;
      indices_matter := indices_matter r; check_template := check_template r |}.
  Definition with_check_universes (r : record) check_universes : record :=
    {| check_guarded := check_guarded r; check_universes := check_universes;
      conv_oracle := conv_oracle r; share_reduction := share_reduction r;
      enable_VM := enable_VM r;
      enable_native_compiler := enable_native_compiler r;
      indices_matter := indices_matter r; check_template := check_template r |}.
  Definition with_conv_oracle (r : record) conv_oracle : record :=
    {| check_guarded := check_guarded r; check_universes := check_universes r;
      conv_oracle := conv_oracle; share_reduction := share_reduction r;
      enable_VM := enable_VM r;
      enable_native_compiler := enable_native_compiler r;
      indices_matter := indices_matter r; check_template := check_template r |}.
  Definition with_share_reduction (r : record) share_reduction : record :=
    {| check_guarded := check_guarded r; check_universes := check_universes r;
      conv_oracle := conv_oracle r; share_reduction := share_reduction;
      enable_VM := enable_VM r;
      enable_native_compiler := enable_native_compiler r;
      indices_matter := indices_matter r; check_template := check_template r |}.
  Definition with_enable_VM (r : record) enable_VM : record :=
    {| check_guarded := check_guarded r; check_universes := check_universes r;
      conv_oracle := conv_oracle r; share_reduction := share_reduction r;
      enable_VM := enable_VM;
      enable_native_compiler := enable_native_compiler r;
      indices_matter := indices_matter r; check_template := check_template r |}.
  Definition with_enable_native_compiler (r : record) enable_native_compiler
    : record :=
    {| check_guarded := check_guarded r; check_universes := check_universes r;
      conv_oracle := conv_oracle r; share_reduction := share_reduction r;
      enable_VM := enable_VM r;
      enable_native_compiler := enable_native_compiler;
      indices_matter := indices_matter r; check_template := check_template r |}.
  Definition with_indices_matter (r : record) indices_matter : record :=
    {| check_guarded := check_guarded r; check_universes := check_universes r;
      conv_oracle := conv_oracle r; share_reduction := share_reduction r;
      enable_VM := enable_VM r;
      enable_native_compiler := enable_native_compiler r;
      indices_matter := indices_matter; check_template := check_template r |}.
  Definition with_check_template (r : record) check_template : record :=
    {| check_guarded := check_guarded r; check_universes := check_universes r;
      conv_oracle := conv_oracle r; share_reduction := share_reduction r;
      enable_VM := enable_VM r;
      enable_native_compiler := enable_native_compiler r;
      indices_matter := indices_matter r; check_template := check_template |}.
End typing_flags.
Definition typing_flags := typing_flags.record.

Module constant_body.
  Record record := {
    const_hyps : Constr.named_context;
    const_body : constant_def (Mod_subst.substituted Constr.t);
    const_type : Constr.types;
    const_relevance : Sorts.relevance;
    const_body_code : option Cemitcodes.to_patch_substituted;
    const_universes : universes;
    const_private_poly_univs : option Univ.ContextSet.t;
    const_inline_code : bool;
    const_typing_flags : typing_flags }.
  Definition with_const_hyps (r : record) const_hyps : record :=
    {| const_hyps := const_hyps; const_body := const_body r;
      const_type := const_type r; const_relevance := const_relevance r;
      const_body_code := const_body_code r;
      const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_body (r : record) const_body : record :=
    {| const_hyps := const_hyps r; const_body := const_body;
      const_type := const_type r; const_relevance := const_relevance r;
      const_body_code := const_body_code r;
      const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_type (r : record) const_type : record :=
    {| const_hyps := const_hyps r; const_body := const_body r;
      const_type := const_type; const_relevance := const_relevance r;
      const_body_code := const_body_code r;
      const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_relevance (r : record) const_relevance : record :=
    {| const_hyps := const_hyps r; const_body := const_body r;
      const_type := const_type r; const_relevance := const_relevance;
      const_body_code := const_body_code r;
      const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_body_code (r : record) const_body_code : record :=
    {| const_hyps := const_hyps r; const_body := const_body r;
      const_type := const_type r; const_relevance := const_relevance r;
      const_body_code := const_body_code; const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_universes (r : record) const_universes : record :=
    {| const_hyps := const_hyps r; const_body := const_body r;
      const_type := const_type r; const_relevance := const_relevance r;
      const_body_code := const_body_code r; const_universes := const_universes;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_private_poly_univs (r : record) const_private_poly_univs
    : record :=
    {| const_hyps := const_hyps r; const_body := const_body r;
      const_type := const_type r; const_relevance := const_relevance r;
      const_body_code := const_body_code r;
      const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_inline_code (r : record) const_inline_code : record :=
    {| const_hyps := const_hyps r; const_body := const_body r;
      const_type := const_type r; const_relevance := const_relevance r;
      const_body_code := const_body_code r;
      const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code;
      const_typing_flags := const_typing_flags r |}.
  Definition with_const_typing_flags (r : record) const_typing_flags : record :=
    {| const_hyps := const_hyps r; const_body := const_body r;
      const_type := const_type r; const_relevance := const_relevance r;
      const_body_code := const_body_code r;
      const_universes := const_universes r;
      const_private_poly_univs := const_private_poly_univs r;
      const_inline_code := const_inline_code r;
      const_typing_flags := const_typing_flags |}.
End constant_body.
Definition constant_body := constant_body.record.

Inductive recarg : Set :=
| Norec : recarg
| Mrec : Names.inductive -&gt; recarg
| Imbr : Names.inductive -&gt; recarg.

Definition wf_paths := Rtree.t recarg.

Inductive record_info : Set :=
| NotRecord : record_info
| FakeRecord : record_info
| PrimRecord :
  array
    (Names.Id.t * array Names.Label.t * array Sorts.relevance *
      array Constr.types) -&gt; record_info.

Module regular_inductive_arity.
  Record record := {
    mind_user_arity : Constr.types;
    mind_sort : Sorts.t }.
  Definition with_mind_user_arity (r : record) mind_user_arity : record :=
    {| mind_user_arity := mind_user_arity; mind_sort := mind_sort r |}.
  Definition with_mind_sort (r : record) mind_sort : record :=
    {| mind_user_arity := mind_user_arity r; mind_sort := mind_sort |}.
End regular_inductive_arity.
Definition regular_inductive_arity := regular_inductive_arity.record.

Definition inductive_arity :=
  declaration_arity regular_inductive_arity template_arity.

Module one_inductive_body.
  Record record := {
    mind_typename : Names.Id.t;
    mind_arity_ctxt : Constr.rel_context;
    mind_arity : inductive_arity;
    mind_consnames : array Names.Id.t;
    mind_user_lc : array Constr.types;
    mind_nrealargs : Z;
    mind_nrealdecls : Z;
    mind_kelim : list Sorts.family;
    mind_nf_lc : array (Constr.rel_context * Constr.types);
    mind_consnrealargs : array Z;
    mind_consnrealdecls : array Z;
    mind_recargs : wf_paths;
    mind_relevance : Sorts.relevance;
    mind_nb_constant : Z;
    mind_nb_args : Z;
    mind_reloc_tbl : Vmvalues.reloc_table }.
  Definition with_mind_typename (r : record) mind_typename : record :=
    {| mind_typename := mind_typename; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_arity_ctxt (r : record) mind_arity_ctxt : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_arity (r : record) mind_arity : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_consnames (r : record) mind_consnames : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_user_lc (r : record) mind_user_lc : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_nrealargs (r : record) mind_nrealargs : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_nrealdecls (r : record) mind_nrealdecls : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_kelim (r : record) mind_kelim : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_nf_lc (r : record) mind_nf_lc : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_consnrealargs (r : record) mind_consnrealargs : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_consnrealdecls (r : record) mind_consnrealdecls
    : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_recargs (r : record) mind_recargs : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_relevance (r : record) mind_relevance : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_nb_constant (r : record) mind_nb_constant : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_nb_args (r : record) mind_nb_args : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args;
      mind_reloc_tbl := mind_reloc_tbl r |}.
  Definition with_mind_reloc_tbl (r : record) mind_reloc_tbl : record :=
    {| mind_typename := mind_typename r; mind_arity_ctxt := mind_arity_ctxt r;
      mind_arity := mind_arity r; mind_consnames := mind_consnames r;
      mind_user_lc := mind_user_lc r; mind_nrealargs := mind_nrealargs r;
      mind_nrealdecls := mind_nrealdecls r; mind_kelim := mind_kelim r;
      mind_nf_lc := mind_nf_lc r; mind_consnrealargs := mind_consnrealargs r;
      mind_consnrealdecls := mind_consnrealdecls r;
      mind_recargs := mind_recargs r; mind_relevance := mind_relevance r;
      mind_nb_constant := mind_nb_constant r; mind_nb_args := mind_nb_args r;
      mind_reloc_tbl := mind_reloc_tbl |}.
End one_inductive_body.
Definition one_inductive_body := one_inductive_body.record.

Inductive recursivity_kind : Set :=
| Finite : recursivity_kind
| CoFinite : recursivity_kind
| BiFinite : recursivity_kind.

Module mutual_inductive_body.
  Record record := {
    mind_packets : array one_inductive_body;
    mind_record : record_info;
    mind_finite : recursivity_kind;
    mind_ntypes : Z;
    mind_hyps : Constr.named_context;
    mind_nparams : Z;
    mind_nparams_rec : Z;
    mind_params_ctxt : Constr.rel_context;
    mind_universes : universes;
    mind_variance : option (array Univ.Variance.t);
    mind_private : option bool;
    mind_typing_flags : typing_flags }.
  Definition with_mind_packets (r : record) mind_packets : record :=
    {| mind_packets := mind_packets; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_record (r : record) mind_record : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_finite (r : record) mind_finite : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_ntypes (r : record) mind_ntypes : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_hyps (r : record) mind_hyps : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_nparams (r : record) mind_nparams : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_nparams_rec (r : record) mind_nparams_rec : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_params_ctxt (r : record) mind_params_ctxt : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt; mind_universes := mind_universes r;
      mind_variance := mind_variance r; mind_private := mind_private r;
      mind_typing_flags := mind_typing_flags r |}.
  Definition with_mind_universes (r : record) mind_universes : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r; mind_universes := mind_universes;
      mind_variance := mind_variance r; mind_private := mind_private r;
      mind_typing_flags := mind_typing_flags r |}.
  Definition with_mind_variance (r : record) mind_variance : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags r
      |}.
  Definition with_mind_private (r : record) mind_private : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private; mind_typing_flags := mind_typing_flags r |}.
  Definition with_mind_typing_flags (r : record) mind_typing_flags : record :=
    {| mind_packets := mind_packets r; mind_record := mind_record r;
      mind_finite := mind_finite r; mind_ntypes := mind_ntypes r;
      mind_hyps := mind_hyps r; mind_nparams := mind_nparams r;
      mind_nparams_rec := mind_nparams_rec r;
      mind_params_ctxt := mind_params_ctxt r;
      mind_universes := mind_universes r; mind_variance := mind_variance r;
      mind_private := mind_private r; mind_typing_flags := mind_typing_flags |}.
End mutual_inductive_body.
Definition mutual_inductive_body := mutual_inductive_body.record.

Inductive functorize (ty a : Set) : Set :=
| NoFunctor : a -&gt; functorize ty a
| MoreFunctor : Names.MBId.t -&gt; ty -&gt; functorize ty a -&gt; functorize ty a.

Arguments NoFunctor {_ _}.
Arguments MoreFunctor {_ _}.

Inductive with_declaration : Set :=
| WithMod : list Names.Id.t -&gt; Names.ModPath.t -&gt; with_declaration
| WithDef :
  list Names.Id.t -&gt; Constr.constr * option Univ.AUContext.t -&gt; with_declaration.

Inductive module_alg_expr : Set :=
| MEident : Names.ModPath.t -&gt; module_alg_expr
| MEapply : module_alg_expr -&gt; Names.ModPath.t -&gt; module_alg_expr
| MEwith : module_alg_expr -&gt; with_declaration -&gt; module_alg_expr.

Reserved Notation &quot;'structure_body&quot;.
Reserved Notation &quot;'module_signature&quot;.
Reserved Notation &quot;'module_expression&quot;.
Reserved Notation &quot;'generic_module_body&quot;.
Reserved Notation &quot;'module_body&quot;.
Reserved Notation &quot;'module_type_body&quot;.
Reserved Notation &quot;'module_retroknowledge&quot;.

Module generic_module_body.
  Record record {mod_mp mod_expr mod_type mod_type_alg mod_constraints mod_delta
    mod_retroknowledge : Set} := {
    mod_mp : mod_mp;
    mod_expr : mod_expr;
    mod_type : mod_type;
    mod_type_alg : mod_type_alg;
    mod_constraints : mod_constraints;
    mod_delta : mod_delta;
    mod_retroknowledge : mod_retroknowledge }.
  Arguments record : clear implicits.
  Definition with_mod_mp
    {mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
      mod_constraints_type mod_delta_type mod_retroknowledge_type : Set}
    (r :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type) mod_mp
    :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type :=
    {| mod_mp := mod_mp; mod_expr := mod_expr r; mod_type := mod_type r;
      mod_type_alg := mod_type_alg r; mod_constraints := mod_constraints r;
      mod_delta := mod_delta r; mod_retroknowledge := mod_retroknowledge r |}.
  Definition with_mod_expr
    {mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
      mod_constraints_type mod_delta_type mod_retroknowledge_type : Set}
    (r :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type) mod_expr
    :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type :=
    {| mod_mp := mod_mp r; mod_expr := mod_expr; mod_type := mod_type r;
      mod_type_alg := mod_type_alg r; mod_constraints := mod_constraints r;
      mod_delta := mod_delta r; mod_retroknowledge := mod_retroknowledge r |}.
  Definition with_mod_type
    {mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
      mod_constraints_type mod_delta_type mod_retroknowledge_type : Set}
    (r :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type) mod_type
    :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type :=
    {| mod_mp := mod_mp r; mod_expr := mod_expr r; mod_type := mod_type;
      mod_type_alg := mod_type_alg r; mod_constraints := mod_constraints r;
      mod_delta := mod_delta r; mod_retroknowledge := mod_retroknowledge r |}.
  Definition with_mod_type_alg
    {mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
      mod_constraints_type mod_delta_type mod_retroknowledge_type : Set}
    (r :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type)
    mod_type_alg
    :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type :=
    {| mod_mp := mod_mp r; mod_expr := mod_expr r; mod_type := mod_type r;
      mod_type_alg := mod_type_alg; mod_constraints := mod_constraints r;
      mod_delta := mod_delta r; mod_retroknowledge := mod_retroknowledge r |}.
  Definition with_mod_constraints
    {mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
      mod_constraints_type mod_delta_type mod_retroknowledge_type : Set}
    (r :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type)
    mod_constraints
    :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type :=
    {| mod_mp := mod_mp r; mod_expr := mod_expr r; mod_type := mod_type r;
      mod_type_alg := mod_type_alg r; mod_constraints := mod_constraints;
      mod_delta := mod_delta r; mod_retroknowledge := mod_retroknowledge r |}.
  Definition with_mod_delta
    {mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
      mod_constraints_type mod_delta_type mod_retroknowledge_type : Set}
    (r :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type) mod_delta
    :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type :=
    {| mod_mp := mod_mp r; mod_expr := mod_expr r; mod_type := mod_type r;
      mod_type_alg := mod_type_alg r; mod_constraints := mod_constraints r;
      mod_delta := mod_delta; mod_retroknowledge := mod_retroknowledge r |}.
  Definition with_mod_retroknowledge
    {mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
      mod_constraints_type mod_delta_type mod_retroknowledge_type : Set}
    (r :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type)
    mod_retroknowledge
    :
      record mod_mp_type mod_expr_type mod_type_type mod_type_alg_type
        mod_constraints_type mod_delta_type mod_retroknowledge_type :=
    {| mod_mp := mod_mp r; mod_expr := mod_expr r; mod_type := mod_type r;
      mod_type_alg := mod_type_alg r; mod_constraints := mod_constraints r;
      mod_delta := mod_delta r; mod_retroknowledge := mod_retroknowledge |}.
End generic_module_body.
Definition generic_module_body_skeleton := generic_module_body.record.

Inductive structure_field_body : Set :=
| SFBconst : constant_body -&gt; structure_field_body
| SFBmind : mutual_inductive_body -&gt; structure_field_body
| SFBmodule : 'module_body -&gt; structure_field_body
| SFBmodtype : 'module_type_body -&gt; structure_field_body

with module_implementation : Set :=
| Abstract : module_implementation
| Algebraic : 'module_expression -&gt; module_implementation
| Struct : 'module_signature -&gt; module_implementation
| FullStruct : module_implementation

with module_retroknowledge_gadt : Set :=
| ModBodyRK : list Retroknowledge.action -&gt; module_retroknowledge_gadt
| ModTypeRK : module_retroknowledge_gadt

where &quot;'structure_body&quot; := (list (Names.Label.t * structure_field_body))
and &quot;'module_signature&quot; := (functorize 'module_type_body 'structure_body)
and &quot;'module_expression&quot; := (functorize 'module_type_body module_alg_expr)
and &quot;'generic_module_body&quot; := (fun (a : Set) =&gt;
  generic_module_body_skeleton Names.ModPath.t a 'module_signature
    (option 'module_expression) Univ.ContextSet.t Mod_subst.delta_resolver
    ('module_retroknowledge a))
and &quot;'module_body&quot; := ('generic_module_body module_implementation)
and &quot;'module_type_body&quot; := ('generic_module_body unit)
and &quot;'module_retroknowledge&quot; := (fun (_ : Set) =&gt; module_retroknowledge_gadt).

Definition structure_body := 'structure_body.
Definition module_signature := 'module_signature.
Definition module_expression := 'module_expression.
Definition generic_module_body := 'generic_module_body.
Definition module_body := 'module_body.
Definition module_type_body := 'module_type_body.
Definition module_retroknowledge := 'module_retroknowledge.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="declareops.ml">
  <div style="margin: 20px;">
    <h3>Declareops</h3>
    <ul>
      <li>OCaml size: 421 lines</li>
      <li>Coq size: 672 lines (+59% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#declareops.ml"><code>declareops.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Declarations
open Mod_subst
open Util

module RelDecl = Context.Rel.Declaration

(** Operations concernings types in [Declarations] :
    [constant_body], [mutual_inductive_body], [module_body] ... *)

let safe_flags oracle = {
  check_guarded = true;
  check_universes = true;
  conv_oracle = oracle;
  share_reduction = true;
  enable_VM = true;
  enable_native_compiler = true;
  indices_matter = true;
  check_template = true;
}

(** {6 Arities } *)

let subst_decl_arity f g sub ar =
  match ar with
  | RegularArity x -&gt;
    let x' = f sub x in
      if x' == x then ar
      else RegularArity x'
  | TemplateArity x -&gt;
    let x' = g sub x in
      if x' == x then ar
      else TemplateArity x'

let map_decl_arity f g = function
  | RegularArity a -&gt; RegularArity (f a)
  | TemplateArity a -&gt; TemplateArity (g a)

let hcons_template_arity ar =
  { template_param_levels = ar.template_param_levels;
      (* List.Smart.map (Option.Smart.map Univ.hcons_univ_level) ar.template_param_levels; *)
    template_level = Univ.hcons_univ ar.template_level }

let universes_context = function
  | Monomorphic _ -&gt; Univ.AUContext.empty
  | Polymorphic ctx -&gt; ctx

let abstract_universes = function
  | Entries.Monomorphic_entry ctx -&gt;
    Univ.empty_level_subst, Monomorphic ctx
  | Entries.Polymorphic_entry (nas, ctx) -&gt;
    let (inst, auctx) = Univ.abstract_universes nas ctx in
    let inst = Univ.make_instance_subst inst in
    (inst, Polymorphic auctx)

(** {6 Constants } *)

let constant_is_polymorphic cb =
  match cb.const_universes with
  | Monomorphic _ -&gt; false
  | Polymorphic _ -&gt; true


let constant_has_body cb = match cb.const_body with
  | Undef _ | Primitive _ -&gt; false
  | Def _ | OpaqueDef _ -&gt; true

let constant_polymorphic_context cb =
  universes_context cb.const_universes

let is_opaque cb = match cb.const_body with
  | OpaqueDef _ -&gt; true
  | Undef _ | Def _ | Primitive _ -&gt; false

(** {7 Constant substitutions } *)

let subst_rel_declaration sub =
  RelDecl.map_constr (subst_mps sub)

let subst_rel_context sub = List.Smart.map (subst_rel_declaration sub)

let subst_const_type sub arity =
  if is_empty_subst sub then arity
  else subst_mps sub arity

(** No need here to check for physical equality after substitution,
    at least for Def due to the delayed substitution [subst_constr_subst]. *)
let subst_const_def sub def = match def with
  | Undef _ | Primitive _ -&gt; def
  | Def c -&gt; Def (subst_constr sub c)
  | OpaqueDef o -&gt; OpaqueDef (Opaqueproof.subst_opaque sub o)

let subst_const_body sub cb =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (List.is_empty cb.const_hyps); (* we're outside sections *)
  if is_empty_subst sub then cb
  else
    let body' = subst_const_def sub cb.const_body in
    let type' = subst_const_type sub cb.const_type in
    if body' == cb.const_body &amp;&amp; type' == cb.const_type
    then cb
    else
      { const_hyps = [];
        const_body = body';
        const_type = type';
        const_body_code =
          Option.map (Cemitcodes.subst_to_patch_subst sub) cb.const_body_code;
        const_universes = cb.const_universes;
        const_private_poly_univs = cb.const_private_poly_univs;
        const_relevance = cb.const_relevance;
        const_inline_code = cb.const_inline_code;
        const_typing_flags = cb.const_typing_flags }</abbr>

(** {7 Hash-consing of constants } *)

(** This hash-consing is currently quite partial : we only
    share internal fields (e.g. constr), and not the records
    themselves. But would it really bring substantial gains ? *)

let hcons_rel_decl =
  RelDecl.map_name Names.Name.hcons %&gt; RelDecl.map_value Constr.hcons %&gt; RelDecl.map_type Constr.hcons

let hcons_rel_context l = List.Smart.map hcons_rel_decl l

let hcons_const_def = function
  | Undef inl -&gt; Undef inl
  | Primitive p -&gt; Primitive p
  | Def l_constr -&gt;
    let constr = force_constr l_constr in
    Def (from_val (Constr.hcons constr))
  | OpaqueDef _ as x -&gt; x (* hashconsed when turned indirect *)

let hcons_universes cbu =
  match cbu with
  | Monomorphic ctx -&gt;
    Monomorphic (Univ.hcons_universe_context_set ctx)
  | Polymorphic ctx -&gt;
    Polymorphic (Univ.hcons_abstract_universe_context ctx)

let hcons_const_private_univs = function
  | None -&gt; None
  | Some univs -&gt; Some (Univ.hcons_universe_context_set univs)

let hcons_const_body cb =
  { cb with
    const_body = hcons_const_def cb.const_body;
    const_type = Constr.hcons cb.const_type;
    const_universes = hcons_universes cb.const_universes;
    const_private_poly_univs = hcons_const_private_univs cb.const_private_poly_univs;
  }

(** {6 Inductive types } *)

let eq_recarg r1 r2 = match r1, r2 with
| Norec, Norec -&gt; true
| Mrec i1, Mrec i2 -&gt; Names.eq_ind i1 i2
| Imbr i1, Imbr i2 -&gt; Names.eq_ind i1 i2
| _ -&gt; false

let subst_recarg sub r = match r with
  | Norec -&gt; r
  | Mrec (kn,i) -&gt;
    let kn' = subst_mind sub kn in
    if kn==kn' then r else Mrec (kn',i)
  | Imbr (kn,i) -&gt;
    let kn' = subst_mind sub kn in
    if kn==kn' then r else Imbr (kn',i)

let mk_norec = Rtree.mk_node Norec <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

let mk_paths r recargs =
  Rtree.mk_node r
    (Array.map (fun l -&gt; Rtree.mk_node Norec (Array.of_list l)) recargs)

let dest_recarg p = fst (Rtree.dest_node p)

(* dest_subterms returns the sizes of each argument of each constructor of
   an inductive object of size [p]. This should never be done for Norec,
   because the number of sons does not correspond to the number of
   constructors.
 *)
let dest_subterms p =
  let (ra,cstrs) = Rtree.dest_node p in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (match ra with Norec -&gt; false | _ -&gt; true);
  Array.map (fun t -&gt; Array.to_list (snd (Rtree.dest_node t))) cstrs</abbr>

let recarg_length p j =
  let (_,cstrs) = Rtree.dest_node p in
  Array.length (snd (Rtree.dest_node cstrs.(j-1)))

let subst_wf_paths sub p = Rtree.Smart.map (subst_recarg sub) p

(** {7 Substitution of inductive declarations } *)

let subst_regular_ind_arity sub s =
  let uar' = subst_mps sub s.mind_user_arity in
    if uar' == s.mind_user_arity then s
    else { mind_user_arity = uar'; mind_sort = s.mind_sort }

let subst_template_ind_arity _sub s = s

(* FIXME records *)
let subst_ind_arity =
  subst_decl_arity subst_regular_ind_arity subst_template_ind_arity

let subst_mind_packet sub mbp =
  { mind_consnames = mbp.mind_consnames;
    mind_consnrealdecls = mbp.mind_consnrealdecls;
    mind_consnrealargs = mbp.mind_consnrealargs;
    mind_typename = mbp.mind_typename;
    mind_nf_lc = Array.Smart.map (fun (ctx, c) -&gt; Context.Rel.map (subst_mps sub) ctx, subst_mps sub c) mbp.mind_nf_lc;
    mind_arity_ctxt = subst_rel_context sub mbp.mind_arity_ctxt;
    mind_arity = subst_ind_arity sub mbp.mind_arity;
    mind_user_lc = Array.Smart.map (subst_mps sub) mbp.mind_user_lc;
    mind_nrealargs = mbp.mind_nrealargs;
    mind_nrealdecls = mbp.mind_nrealdecls;
    mind_kelim = mbp.mind_kelim;
    mind_recargs = subst_wf_paths sub mbp.mind_recargs (*wf_paths*);
    mind_relevance = mbp.mind_relevance;
    mind_nb_constant = mbp.mind_nb_constant;
    mind_nb_args = mbp.mind_nb_args;
    mind_reloc_tbl = mbp.mind_reloc_tbl }

let subst_mind_record sub r = match r with
| NotRecord -&gt; NotRecord
| FakeRecord -&gt; FakeRecord
| PrimRecord infos -&gt;
  let map (id, ps, rs, pb as info) =
    let pb' = Array.Smart.map (subst_mps sub) pb in
    if pb' == pb then info
    else (id, ps, rs, pb')
  in
  let infos' = Array.Smart.map map infos in
  if infos' == infos then r else PrimRecord infos'

let subst_mind_body sub mib =
  { mind_record = subst_mind_record sub mib.mind_record ;
    mind_finite = mib.mind_finite ;
    mind_ntypes = mib.mind_ntypes ;
    mind_hyps = (match mib.mind_hyps with [] -&gt; [] | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>);
    mind_nparams = mib.mind_nparams;
    mind_nparams_rec = mib.mind_nparams_rec;
    mind_params_ctxt =
      Context.Rel.map (subst_mps sub) mib.mind_params_ctxt;
    mind_packets = Array.Smart.map (subst_mind_packet sub) mib.mind_packets ;
    mind_universes = mib.mind_universes;
    mind_variance = mib.mind_variance;
    mind_private = mib.mind_private;
    mind_typing_flags = mib.mind_typing_flags;
  }

let inductive_polymorphic_context mib =
  universes_context mib.mind_universes

let inductive_is_polymorphic mib =
  match mib.mind_universes with
  | Monomorphic _ -&gt; false
  | Polymorphic _ctx -&gt; true

let inductive_is_cumulative mib =
  Option.has_some mib.mind_variance

let inductive_make_projection ind mib ~proj_arg =
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt; None
  | PrimRecord infos -&gt;
    let _, labs, _, _ = infos.(snd ind) in
    Some (Names.Projection.Repr.make ind
            ~proj_npars:mib.mind_nparams
            ~proj_arg
            labs.(proj_arg))

let inductive_make_projections ind mib =
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt; None
  | PrimRecord infos -&gt;
    let _, labs, _, _ = infos.(snd ind) in
    let projs = Array.mapi (fun proj_arg lab -&gt;
        Names.Projection.Repr.make ind ~proj_npars:mib.mind_nparams ~proj_arg lab)
        labs
    in
    Some projs

let relevance_of_projection_repr mib p =
  let _mind,i = Names.Projection.Repr.inductive p in
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt;
    CErrors.anomaly ~label:&quot;relevance_of_projection&quot; Pp.(str &quot;not a projection&quot;)
  | PrimRecord infos -&gt;
    let _,_,rs,_ = infos.(i) in
    rs.(Names.Projection.Repr.arg p)

(** {6 Hash-consing of inductive declarations } *)

let hcons_regular_ind_arity a =
  { mind_user_arity = Constr.hcons a.mind_user_arity;
    mind_sort = Sorts.hcons a.mind_sort }

(** Just as for constants, this hash-consing is quite partial *)

let hcons_ind_arity =
  map_decl_arity hcons_regular_ind_arity hcons_template_arity

(** Substitution of inductive declarations *)

let hcons_mind_packet oib =
  let user = Array.Smart.map Constr.hcons oib.mind_user_lc in
  let map (ctx, c) = Context.Rel.map Constr.hcons ctx, Constr.hcons c in
  let nf = Array.Smart.map map oib.mind_nf_lc in
  { oib with
    mind_typename = Names.Id.hcons oib.mind_typename;
    mind_arity_ctxt = hcons_rel_context oib.mind_arity_ctxt;
    mind_arity = hcons_ind_arity oib.mind_arity;
    mind_consnames = Array.Smart.map Names.Id.hcons oib.mind_consnames;
    mind_user_lc = user;
    mind_nf_lc = nf }

let hcons_mind mib =
  { mib with
    mind_packets = Array.Smart.map hcons_mind_packet mib.mind_packets;
    mind_params_ctxt = hcons_rel_context mib.mind_params_ctxt;
    mind_universes = hcons_universes mib.mind_universes }

(** Hashconsing of modules *)

let hcons_functorize hty he hself f = match f with
| NoFunctor e -&gt;
  let e' = he e in
  if e == e' then f else NoFunctor e'
| MoreFunctor (mid, ty, nf) -&gt;
  (** FIXME *)
  let mid' = mid in
  let ty' = hty ty in
  let nf' = hself nf in
  if mid == mid' &amp;&amp; ty == ty' &amp;&amp; nf == nf' then f
  else MoreFunctor (mid, ty', nf')

let hcons_module_alg_expr me = me

let rec hcons_structure_field_body sb = match sb with
| SFBconst cb -&gt;
  let cb' = hcons_const_body cb in
  if cb == cb' then sb else SFBconst cb'
| SFBmind mib -&gt;
  let mib' = hcons_mind mib in
  if mib == mib' then sb else SFBmind mib'
| SFBmodule mb -&gt;
  let mb' = hcons_module_body mb in
  if mb == mb' then sb else SFBmodule mb'
| SFBmodtype mb -&gt;
  let mb' = hcons_module_type mb in
  if mb == mb' then sb else SFBmodtype mb'

and hcons_structure_body sb =
  (** FIXME *)
  let map (l, sfb as fb) =
    let l' = Names.Label.hcons l in
    let sfb' = hcons_structure_field_body sfb in
    if l == l' &amp;&amp; sfb == sfb' then fb else (l', sfb')
  in
  List.Smart.map map sb

and hcons_module_signature ms =
  hcons_functorize hcons_module_type hcons_structure_body hcons_module_signature ms

and hcons_module_expression me =
  hcons_functorize hcons_module_type hcons_module_alg_expr hcons_module_expression me

and hcons_module_implementation mip = match mip with
| Abstract -&gt; Abstract
| Algebraic me -&gt;
  let me' = hcons_module_expression me in
  if me == me' then mip else Algebraic me'
| Struct ms -&gt;
  let ms' = hcons_module_signature ms in
  if ms == ms' then mip else Struct ms
| FullStruct -&gt; FullStruct

and hcons_generic_module_body :
  'a. ('a -&gt; 'a) -&gt; 'a generic_module_body -&gt; 'a generic_module_body =
  fun hcons_impl mb -&gt;
  let mp' = mb.mod_mp in
  let expr' = hcons_impl mb.mod_expr in
  let type' = hcons_module_signature mb.mod_type in
  let type_alg' = mb.mod_type_alg in
  let constraints' = Univ.hcons_universe_context_set mb.mod_constraints in
  let delta' = mb.mod_delta in
  let retroknowledge' = mb.mod_retroknowledge in

  if
    mb.mod_mp == mp' &amp;&amp;
    mb.mod_expr == expr' &amp;&amp;
    mb.mod_type == type' &amp;&amp;
    mb.mod_type_alg == type_alg' &amp;&amp;
    mb.mod_constraints == constraints' &amp;&amp;
    mb.mod_delta == delta' &amp;&amp;
    mb.mod_retroknowledge == retroknowledge'
  then mb
  else {
    mod_mp = mp';
    mod_expr = expr';
    mod_type = type';
    mod_type_alg = type_alg';
    mod_constraints = constraints';
    mod_delta = delta';
    mod_retroknowledge = retroknowledge';
  }

and hcons_module_body mb =
  hcons_generic_module_body hcons_module_implementation mb

and hcons_module_type mb =
  hcons_generic_module_body (fun () -&gt; ()) mb
</pre>
  </div>
  <div class="col-md-6">
    <a href="#declareops.ml"><code>Declareops.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Declarations.

Import Mod_subst.

Import Util.

Module RelDecl := Context.Rel.Declaration.

Definition safe_flags (oracle : Conv_oracle.oracle)
  : Declarations.typing_flags :=
  {| Declarations.typing_flags.check_guarded := true;
    Declarations.typing_flags.check_universes := true;
    Declarations.typing_flags.conv_oracle := oracle;
    Declarations.typing_flags.share_reduction := true;
    Declarations.typing_flags.enable_VM := true;
    Declarations.typing_flags.enable_native_compiler := true;
    Declarations.typing_flags.indices_matter := true;
    Declarations.typing_flags.check_template := true |}.

Definition subst_decl_arity {A B C : Set}
  (f : A -&gt; B -&gt; B) (g : A -&gt; C -&gt; C) (sub : A)
  (ar : Declarations.declaration_arity B C)
  : Declarations.declaration_arity B C :=
  match ar with
  | Declarations.RegularArity x =&gt;
    let x' := f sub x in
    if Stdlib.op_eqeq x' x then
      ar
    else
      Declarations.RegularArity x'
  | Declarations.TemplateArity x =&gt;
    let x' := g sub x in
    if Stdlib.op_eqeq x' x then
      ar
    else
      Declarations.TemplateArity x'
  end.

Definition map_decl_arity {A B C D : Set}
  (f : A -&gt; B) (g : C -&gt; D)
  (function_parameter : Declarations.declaration_arity A C)
  : Declarations.declaration_arity B D :=
  match function_parameter with
  | Declarations.RegularArity a =&gt; Declarations.RegularArity (f a)
  | Declarations.TemplateArity a =&gt; Declarations.TemplateArity (g a)
  end.

Definition hcons_template_arity (ar : Declarations.template_arity)
  : Declarations.template_arity :=
  {|
    Declarations.template_arity.template_param_levels :=
      Declarations.template_arity.template_param_levels ar;
    Declarations.template_arity.template_level :=
      Univ.hcons_univ (Declarations.template_arity.template_level ar) |}.

Definition universes_context (function_parameter : Declarations.universes)
  : Univ.AUContext.t :=
  match function_parameter with
  | Declarations.Monomorphic _ =&gt; Univ.AUContext.empty
  | Declarations.Polymorphic ctx =&gt; ctx
  end.

Definition abstract_universes (function_parameter : Entries.universes_entry)
  : Univ.universe_level_subst * Declarations.universes :=
  match function_parameter with
  | Entries.Monomorphic_entry ctx =&gt;
    (Univ.empty_level_subst, (Declarations.Monomorphic ctx))
  | Entries.Polymorphic_entry nas ctx =&gt;
    let '(inst, auctx) := Univ.abstract_universes nas ctx in
    let inst := Univ.make_instance_subst inst in
    (inst, (Declarations.Polymorphic auctx))
  end.

Definition constant_is_polymorphic (cb : Declarations.constant_body) : bool :=
  match Declarations.constant_body.const_universes cb with
  | Declarations.Monomorphic _ =&gt; false
  | Declarations.Polymorphic _ =&gt; true
  end.

Definition constant_has_body (cb : Declarations.constant_body) : bool :=
  match Declarations.constant_body.const_body cb with
  | Declarations.Undef _ | Declarations.Primitive _ =&gt; false
  | Declarations.Def _ | Declarations.OpaqueDef _ =&gt; true
  end.

Definition constant_polymorphic_context (cb : Declarations.constant_body)
  : Univ.AUContext.t :=
  universes_context (Declarations.constant_body.const_universes cb).

Definition is_opaque (cb : Declarations.constant_body) : bool :=
  match Declarations.constant_body.const_body cb with
  | Declarations.OpaqueDef _ =&gt; true
  | Declarations.Undef _ | Declarations.Def _ | Declarations.Primitive _ =&gt;
    false
  end.

Definition subst_rel_declaration (sub : Mod_subst.substitution)
  : RelDecl.pt Constr.constr Constr.constr -&gt;
  RelDecl.pt Constr.constr Constr.constr := RelDecl.map_constr (subst_mps sub).

Definition subst_rel_context (sub : Mod_subst.substitution)
  : list (RelDecl.pt Constr.constr Constr.constr) -&gt;
  list (RelDecl.pt Constr.constr Constr.constr) :=
  List.Smart.map (subst_rel_declaration sub).

Definition subst_const_type
  (sub : Mod_subst.substitution) (arity : Constr.constr) : Constr.constr :=
  if is_empty_subst sub then
    arity
  else
    subst_mps sub arity.

Definition subst_const_def
  (sub : Mod_subst.substitution)
  (def : Declarations.constant_def (Mod_subst.substituted Constr.constr))
  : Declarations.constant_def (Mod_subst.substituted Constr.constr) :=
  match def with
  | Declarations.Undef _ | Declarations.Primitive _ =&gt; def
  | Declarations.Def c =&gt; Declarations.Def (subst_constr sub c)
  | Declarations.OpaqueDef o =&gt;
    Declarations.OpaqueDef (Opaqueproof.subst_opaque sub o)
  end.

Definition subst_const_body
  (sub : Mod_subst.substitution) (cb : Declarations.constant_body)
  : Declarations.constant_body :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  if is_empty_subst sub then
    cb
  else
    let body' := subst_const_def sub (Declarations.constant_body.const_body cb)
      in
    let type' := subst_const_type sub (Declarations.constant_body.const_type cb)
      in
    if
      andb (Stdlib.op_eqeq body' (Declarations.constant_body.const_body cb))
        (Stdlib.op_eqeq type' (Declarations.constant_body.const_type cb)) then
      cb
    else
      {| Declarations.constant_body.const_hyps := [];
        Declarations.constant_body.const_body := body';
        Declarations.constant_body.const_type := type';
        Declarations.constant_body.const_relevance :=
          Declarations.constant_body.const_relevance cb;
        Declarations.constant_body.const_body_code :=
          Option.map (Cemitcodes.subst_to_patch_subst sub)
            (Declarations.constant_body.const_body_code cb);
        Declarations.constant_body.const_universes :=
          Declarations.constant_body.const_universes cb;
        Declarations.constant_body.const_private_poly_univs :=
          Declarations.constant_body.const_private_poly_univs cb;
        Declarations.constant_body.const_inline_code :=
          Declarations.constant_body.const_inline_code cb;
        Declarations.constant_body.const_typing_flags :=
          Declarations.constant_body.const_typing_flags cb |}.

Definition hcons_rel_decl
  : RelDecl.pt Constr.constr Constr.constr -&gt;
  RelDecl.pt Constr.constr Constr.constr :=
  op_percentgt
    (op_percentgt (RelDecl.map_name Names.Name.hcons)
      (RelDecl.map_value Constr.hcons)) (RelDecl.map_type Constr.hcons).

Definition hcons_rel_context (l : list (RelDecl.pt Constr.constr Constr.constr))
  : list (RelDecl.pt Constr.constr Constr.constr) :=
  List.Smart.map hcons_rel_decl l.

Definition hcons_const_def
  (function_parameter :
    Declarations.constant_def (Mod_subst.substituted Constr.constr))
  : Declarations.constant_def (Mod_subst.substituted Constr.constr) :=
  match function_parameter with
  | Declarations.Undef inl =&gt; Declarations.Undef inl
  | Declarations.Primitive p =&gt; Declarations.Primitive p
  | Declarations.Def l_constr =&gt;
    let constr := force_constr l_constr in
    Declarations.Def (from_val (Constr.hcons constr))
  | (Declarations.OpaqueDef _) as x =&gt; x
  end.

Definition hcons_universes (cbu : Declarations.universes)
  : Declarations.universes :=
  match cbu with
  | Declarations.Monomorphic ctx =&gt;
    Declarations.Monomorphic (Univ.hcons_universe_context_set ctx)
  | Declarations.Polymorphic ctx =&gt;
    Declarations.Polymorphic (Univ.hcons_abstract_universe_context ctx)
  end.

Definition hcons_const_private_univs
  (function_parameter : option Univ.ContextSet.t) : option Univ.ContextSet.t :=
  match function_parameter with
  | None =&gt; None
  | Some univs =&gt; Some (Univ.hcons_universe_context_set univs)
  end.

Definition hcons_const_body (cb : Declarations.constant_body)
  : Declarations.constant_body :=
  Declarations.constant_body.with_const_private_poly_univs
    (Declarations.constant_body.with_const_universes
      (Declarations.constant_body.with_const_type
        (Declarations.constant_body.with_const_body cb
          (hcons_const_def (Declarations.constant_body.const_body cb)))
        (Constr.hcons (Declarations.constant_body.const_type cb)))
      (hcons_universes (Declarations.constant_body.const_universes cb)))
    (hcons_const_private_univs
      (Declarations.constant_body.const_private_poly_univs cb)).

Definition eq_recarg (r1 : Declarations.recarg) (r2 : Declarations.recarg)
  : bool :=
  match (r1, r2) with
  | (Declarations.Norec, Declarations.Norec) =&gt; true
  | (Declarations.Mrec i1, Declarations.Mrec i2) =&gt; Names.eq_ind i1 i2
  | (Declarations.Imbr i1, Declarations.Imbr i2) =&gt; Names.eq_ind i1 i2
  | _ =&gt; false
  end.

Definition subst_recarg (sub : Mod_subst.substitution) (r : Declarations.recarg)
  : Declarations.recarg :=
  match r with
  | Declarations.Norec =&gt; r
  | Declarations.Mrec (kn, i) =&gt;
    let kn' := subst_mind sub kn in
    if Stdlib.op_eqeq kn kn' then
      r
    else
      Declarations.Mrec (kn', i)
  | Declarations.Imbr (kn, i) =&gt;
    let kn' := subst_mind sub kn in
    if Stdlib.op_eqeq kn kn' then
      r
    else
      Declarations.Imbr (kn', i)
  end.

Definition mk_norec : Rtree.t Declarations.recarg :=
  Rtree.mk_node Declarations.Norec
    (* ❌ Arrays not handled. *)
    [ ].

Definition mk_paths
  (r : Declarations.recarg)
  (recargs : array (list (Rtree.t Declarations.recarg)))
  : Rtree.t Declarations.recarg :=
  Rtree.mk_node r
    ((|Util.Array|).(CArray.ExtS.map)
      (fun l =&gt;
        Rtree.mk_node Declarations.Norec
          ((|Util.Array|).(CArray.ExtS.of_list) l)) recargs).

Definition dest_recarg {A : Set} (p : Rtree.t A) : A := fst (Rtree.dest_node p).

Definition dest_subterms (p : Rtree.t Declarations.recarg)
  : array (list (Rtree.t Declarations.recarg)) :=
  let '(ra, cstrs) := Rtree.dest_node p in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (|Util.Array|).(CArray.ExtS.map)
    (fun t =&gt; (|Util.Array|).(CArray.ExtS.to_list) (snd (Rtree.dest_node t)))
    cstrs.

Definition recarg_length {A : Set} (p : Rtree.t A) (j : Z) : Z :=
  let '(_, cstrs) := Rtree.dest_node p in
  (|Util.Array|).(CArray.ExtS.length)
    (snd (Rtree.dest_node ((|Util.Array|).(CArray.ExtS.get) cstrs (Z.sub j 1)))).

Definition subst_wf_paths
  (sub : Mod_subst.substitution) (p : Rtree.t Declarations.recarg)
  : Rtree.t Declarations.recarg := Rtree.Smart.map (subst_recarg sub) p.

Definition subst_regular_ind_arity
  (sub : Mod_subst.substitution) (s : Declarations.regular_inductive_arity)
  : Declarations.regular_inductive_arity :=
  let uar' :=
    subst_mps sub (Declarations.regular_inductive_arity.mind_user_arity s) in
  if
    Stdlib.op_eqeq uar' (Declarations.regular_inductive_arity.mind_user_arity s)
    then
    s
  else
    {| Declarations.regular_inductive_arity.mind_user_arity := uar';
      Declarations.regular_inductive_arity.mind_sort :=
        Declarations.regular_inductive_arity.mind_sort s |}.

Definition subst_template_ind_arity {A B : Set} (_sub : A) (s : B) : B := s.

Definition subst_ind_arity
  : Mod_subst.substitution -&gt;
  Declarations.declaration_arity Declarations.regular_inductive_arity
    Declarations.template_arity -&gt;
  Declarations.declaration_arity Declarations.regular_inductive_arity
    Declarations.template_arity :=
  subst_decl_arity subst_regular_ind_arity subst_template_ind_arity.

Definition subst_mind_packet
  (sub : Mod_subst.substitution) (mbp : Declarations.one_inductive_body)
  : Declarations.one_inductive_body :=
  {|
    Declarations.one_inductive_body.mind_typename :=
      Declarations.one_inductive_body.mind_typename mbp;
    Declarations.one_inductive_body.mind_arity_ctxt :=
      subst_rel_context sub
        (Declarations.one_inductive_body.mind_arity_ctxt mbp);
    Declarations.one_inductive_body.mind_arity :=
      subst_ind_arity sub (Declarations.one_inductive_body.mind_arity mbp);
    Declarations.one_inductive_body.mind_consnames :=
      Declarations.one_inductive_body.mind_consnames mbp;
    Declarations.one_inductive_body.mind_user_lc :=
      Array.Smart.map (subst_mps sub)
        (Declarations.one_inductive_body.mind_user_lc mbp);
    Declarations.one_inductive_body.mind_nrealargs :=
      Declarations.one_inductive_body.mind_nrealargs mbp;
    Declarations.one_inductive_body.mind_nrealdecls :=
      Declarations.one_inductive_body.mind_nrealdecls mbp;
    Declarations.one_inductive_body.mind_kelim :=
      Declarations.one_inductive_body.mind_kelim mbp;
    Declarations.one_inductive_body.mind_nf_lc :=
      Array.Smart.map
        (fun function_parameter =&gt;
          let '(ctx, c) := function_parameter in
          ((Context.Rel.map (subst_mps sub) ctx), (subst_mps sub c)))
        (Declarations.one_inductive_body.mind_nf_lc mbp);
    Declarations.one_inductive_body.mind_consnrealargs :=
      Declarations.one_inductive_body.mind_consnrealargs mbp;
    Declarations.one_inductive_body.mind_consnrealdecls :=
      Declarations.one_inductive_body.mind_consnrealdecls mbp;
    Declarations.one_inductive_body.mind_recargs :=
      subst_wf_paths sub (Declarations.one_inductive_body.mind_recargs mbp);
    Declarations.one_inductive_body.mind_relevance :=
      Declarations.one_inductive_body.mind_relevance mbp;
    Declarations.one_inductive_body.mind_nb_constant :=
      Declarations.one_inductive_body.mind_nb_constant mbp;
    Declarations.one_inductive_body.mind_nb_args :=
      Declarations.one_inductive_body.mind_nb_args mbp;
    Declarations.one_inductive_body.mind_reloc_tbl :=
      Declarations.one_inductive_body.mind_reloc_tbl mbp |}.

Definition subst_mind_record
  (sub : Mod_subst.substitution) (r : Declarations.record_info)
  : Declarations.record_info :=
  match r with
  | Declarations.NotRecord =&gt; Declarations.NotRecord
  | Declarations.FakeRecord =&gt; Declarations.FakeRecord
  | Declarations.PrimRecord infos =&gt;
    let map {A B C : Set} (function_parameter : A * B * C * array Constr.constr)
      : A * B * C * array Constr.constr :=
      let '(id, ps, rs, pb) as info := function_parameter in
      let pb' := Array.Smart.map (subst_mps sub) pb in
      if Stdlib.op_eqeq pb' pb then
        info
      else
        (id, ps, rs, pb') in
    let infos' := Array.Smart.map map infos in
    if Stdlib.op_eqeq infos' infos then
      r
    else
      Declarations.PrimRecord infos'
  end.

Definition subst_mind_body
  (sub : Mod_subst.substitution) (mib : Declarations.mutual_inductive_body)
  : Declarations.mutual_inductive_body :=
  {|
    Declarations.mutual_inductive_body.mind_packets :=
      Array.Smart.map (subst_mind_packet sub)
        (Declarations.mutual_inductive_body.mind_packets mib);
    Declarations.mutual_inductive_body.mind_record :=
      subst_mind_record sub (Declarations.mutual_inductive_body.mind_record mib);
    Declarations.mutual_inductive_body.mind_finite :=
      Declarations.mutual_inductive_body.mind_finite mib;
    Declarations.mutual_inductive_body.mind_ntypes :=
      Declarations.mutual_inductive_body.mind_ntypes mib;
    Declarations.mutual_inductive_body.mind_hyps :=
      match Declarations.mutual_inductive_body.mind_hyps mib with
      | [] =&gt; []
      | _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end;
    Declarations.mutual_inductive_body.mind_nparams :=
      Declarations.mutual_inductive_body.mind_nparams mib;
    Declarations.mutual_inductive_body.mind_nparams_rec :=
      Declarations.mutual_inductive_body.mind_nparams_rec mib;
    Declarations.mutual_inductive_body.mind_params_ctxt :=
      Context.Rel.map (subst_mps sub)
        (Declarations.mutual_inductive_body.mind_params_ctxt mib);
    Declarations.mutual_inductive_body.mind_universes :=
      Declarations.mutual_inductive_body.mind_universes mib;
    Declarations.mutual_inductive_body.mind_variance :=
      Declarations.mutual_inductive_body.mind_variance mib;
    Declarations.mutual_inductive_body.mind_private :=
      Declarations.mutual_inductive_body.mind_private mib;
    Declarations.mutual_inductive_body.mind_typing_flags :=
      Declarations.mutual_inductive_body.mind_typing_flags mib |}.

Definition inductive_polymorphic_context
  (mib : Declarations.mutual_inductive_body) : Univ.AUContext.t :=
  universes_context (Declarations.mutual_inductive_body.mind_universes mib).

Definition inductive_is_polymorphic (mib : Declarations.mutual_inductive_body)
  : bool :=
  match Declarations.mutual_inductive_body.mind_universes mib with
  | Declarations.Monomorphic _ =&gt; false
  | Declarations.Polymorphic _ctx =&gt; true
  end.

Definition inductive_is_cumulative (mib : Declarations.mutual_inductive_body)
  : bool :=
  Option.has_some (Declarations.mutual_inductive_body.mind_variance mib).

Definition inductive_make_projection
  (ind : Names.inductive) (mib : Declarations.mutual_inductive_body)
  (proj_arg : Z) : option Names.Projection.Repr.t :=
  match Declarations.mutual_inductive_body.mind_record mib with
  | Declarations.NotRecord | Declarations.FakeRecord =&gt; None
  | Declarations.PrimRecord infos =&gt;
    let '(_, labs, _, _) := (|Util.Array|).(CArray.ExtS.get) infos (snd ind) in
    Some
      (Names.Projection.Repr.make ind
        (Declarations.mutual_inductive_body.mind_nparams mib) proj_arg
        ((|Util.Array|).(CArray.ExtS.get) labs proj_arg))
  end.

Definition inductive_make_projections
  (ind : Names.inductive) (mib : Declarations.mutual_inductive_body)
  : option (array Names.Projection.Repr.t) :=
  match Declarations.mutual_inductive_body.mind_record mib with
  | Declarations.NotRecord | Declarations.FakeRecord =&gt; None
  | Declarations.PrimRecord infos =&gt;
    let '(_, labs, _, _) := (|Util.Array|).(CArray.ExtS.get) infos (snd ind) in
    let projs :=
      (|Util.Array|).(CArray.ExtS.mapi)
        (fun proj_arg =&gt;
          fun lab =&gt;
            Names.Projection.Repr.make ind
              (Declarations.mutual_inductive_body.mind_nparams mib) proj_arg lab)
        labs in
    Some projs
  end.

Definition relevance_of_projection_repr
  (mib : Declarations.mutual_inductive_body) (p : Names.Projection.Repr.t)
  : Sorts.relevance :=
  let '(_mind, i) := Names.Projection.Repr.inductive p in
  match Declarations.mutual_inductive_body.mind_record mib with
  | Declarations.NotRecord | Declarations.FakeRecord =&gt;
    CErrors.anomaly None (Some &quot;relevance_of_projection&quot;)
      (str &quot;not a projection&quot;)
  | Declarations.PrimRecord infos =&gt;
    let '(_, _, rs, _) := (|Util.Array|).(CArray.ExtS.get) infos i in
    (|Util.Array|).(CArray.ExtS.get) rs (Names.Projection.Repr.arg p)
  end.

Definition hcons_regular_ind_arity (a : Declarations.regular_inductive_arity)
  : Declarations.regular_inductive_arity :=
  {|
    Declarations.regular_inductive_arity.mind_user_arity :=
      Constr.hcons (Declarations.regular_inductive_arity.mind_user_arity a);
    Declarations.regular_inductive_arity.mind_sort :=
      Sorts.hcons (Declarations.regular_inductive_arity.mind_sort a) |}.

Definition hcons_ind_arity
  : Declarations.declaration_arity Declarations.regular_inductive_arity
    Declarations.template_arity -&gt;
  Declarations.declaration_arity Declarations.regular_inductive_arity
    Declarations.template_arity :=
  map_decl_arity hcons_regular_ind_arity hcons_template_arity.

Definition hcons_mind_packet (oib : Declarations.one_inductive_body)
  : Declarations.one_inductive_body :=
  let user :=
    Array.Smart.map Constr.hcons
      (Declarations.one_inductive_body.mind_user_lc oib) in
  let map
    (function_parameter :
      Context.Rel.pt Constr.constr Constr.constr * Constr.constr)
    : Context.Rel.pt Constr.constr Constr.constr * Constr.constr :=
    let '(ctx, c) := function_parameter in
    ((Context.Rel.map Constr.hcons ctx), (Constr.hcons c)) in
  let nf := Array.Smart.map map (Declarations.one_inductive_body.mind_nf_lc oib)
    in
  Declarations.one_inductive_body.with_mind_nf_lc
    (Declarations.one_inductive_body.with_mind_user_lc
      (Declarations.one_inductive_body.with_mind_consnames
        (Declarations.one_inductive_body.with_mind_arity
          (Declarations.one_inductive_body.with_mind_arity_ctxt
            (Declarations.one_inductive_body.with_mind_typename oib
              (Names.Id.hcons
                (Declarations.one_inductive_body.mind_typename oib)))
            (hcons_rel_context
              (Declarations.one_inductive_body.mind_arity_ctxt oib)))
          (hcons_ind_arity (Declarations.one_inductive_body.mind_arity oib)))
        (Array.Smart.map Names.Id.hcons
          (Declarations.one_inductive_body.mind_consnames oib))) user) nf.

Definition hcons_mind (mib : Declarations.mutual_inductive_body)
  : Declarations.mutual_inductive_body :=
  Declarations.mutual_inductive_body.with_mind_universes
    (Declarations.mutual_inductive_body.with_mind_params_ctxt
      (Declarations.mutual_inductive_body.with_mind_packets mib
        (Array.Smart.map hcons_mind_packet
          (Declarations.mutual_inductive_body.mind_packets mib)))
      (hcons_rel_context
        (Declarations.mutual_inductive_body.mind_params_ctxt mib)))
    (hcons_universes (Declarations.mutual_inductive_body.mind_universes mib)).

Definition hcons_functorize {A B : Set}
  (hty : A -&gt; A) (he : B -&gt; B)
  (hself : Declarations.functorize A B -&gt; Declarations.functorize A B)
  (f : Declarations.functorize A B) : Declarations.functorize A B :=
  match f with
  | Declarations.NoFunctor e =&gt;
    let e' := he e in
    if Stdlib.op_eqeq e e' then
      f
    else
      Declarations.NoFunctor e'
  | Declarations.MoreFunctor mid ty nf =&gt;
    let mid' := mid in
    let ty' := hty ty in
    let nf' := hself nf in
    if
      andb (Stdlib.op_eqeq mid mid')
        (andb (Stdlib.op_eqeq ty ty') (Stdlib.op_eqeq nf nf')) then
      f
    else
      Declarations.MoreFunctor mid ty' nf'
  end.

Definition hcons_module_alg_expr {A : Set} (me : A) : A := me.

Fixpoint hcons_structure_field_body (sb : Declarations.structure_field_body)
  {struct sb} : Declarations.structure_field_body :=
  match sb with
  | Declarations.SFBconst cb =&gt;
    let cb' := hcons_const_body cb in
    if Stdlib.op_eqeq cb cb' then
      sb
    else
      Declarations.SFBconst cb'
  | Declarations.SFBmind mib =&gt;
    let mib' := hcons_mind mib in
    if Stdlib.op_eqeq mib mib' then
      sb
    else
      Declarations.SFBmind mib'
  | Declarations.SFBmodule mb =&gt;
    let mb' := hcons_module_body mb in
    if Stdlib.op_eqeq mb mb' then
      sb
    else
      Declarations.SFBmodule mb'
  | Declarations.SFBmodtype mb =&gt;
    let mb' := hcons_module_type mb in
    if Stdlib.op_eqeq mb mb' then
      sb
    else
      Declarations.SFBmodtype mb'
  end

with hcons_structure_body (sb : Declarations.structure_body) {struct sb}
  : Declarations.structure_body :=
  let map
    (function_parameter : Names.Label.t * Declarations.structure_field_body)
    : Names.Label.t * Declarations.structure_field_body :=
    let '(l, sfb) as fb := function_parameter in
    let l' := Names.Label.hcons l in
    let sfb' := hcons_structure_field_body sfb in
    if andb (Stdlib.op_eqeq l l') (Stdlib.op_eqeq sfb sfb') then
      fb
    else
      (l', sfb') in
  List.Smart.map map sb

with hcons_module_signature (ms : Declarations.module_signature) {struct ms}
  : Declarations.module_signature :=
  hcons_functorize hcons_module_type hcons_structure_body hcons_module_signature
    ms

with hcons_module_expression
  (me :
    Declarations.functorize Declarations.module_type_body
      Declarations.module_alg_expr) {struct me}
  : Declarations.functorize Declarations.module_type_body
    Declarations.module_alg_expr :=
  hcons_functorize hcons_module_type hcons_module_alg_expr
    hcons_module_expression me

with hcons_module_implementation (mip : Declarations.module_implementation)
  {struct mip} : Declarations.module_implementation :=
  match mip with
  | Declarations.Abstract =&gt; Declarations.Abstract
  | Declarations.Algebraic me =&gt;
    let me' := hcons_module_expression me in
    if Stdlib.op_eqeq me me' then
      mip
    else
      Declarations.Algebraic me'
  | Declarations.Struct ms =&gt;
    let ms' := hcons_module_signature ms in
    if Stdlib.op_eqeq ms ms' then
      mip
    else
      Declarations.Struct ms
  | Declarations.FullStruct =&gt; Declarations.FullStruct
  end

with hcons_generic_module_body {a : Set}
  (hcons_impl : a -&gt; a) (mb : Declarations.generic_module_body a)
  {struct hcons_impl} : Declarations.generic_module_body a :=
  let mp' := Declarations.generic_module_body.mod_mp mb in
  let expr' := hcons_impl (Declarations.generic_module_body.mod_expr mb) in
  let type' :=
    hcons_module_signature (Declarations.generic_module_body.mod_type mb) in
  let type_alg' := Declarations.generic_module_body.mod_type_alg mb in
  let constraints' :=
    Univ.hcons_universe_context_set
      (Declarations.generic_module_body.mod_constraints mb) in
  let delta' := Declarations.generic_module_body.mod_delta mb in
  let retroknowledge' := Declarations.generic_module_body.mod_retroknowledge mb
    in
  if
    andb (Stdlib.op_eqeq (Declarations.generic_module_body.mod_mp mb) mp')
      (andb
        (Stdlib.op_eqeq (Declarations.generic_module_body.mod_expr mb) expr')
        (andb
          (Stdlib.op_eqeq (Declarations.generic_module_body.mod_type mb) type')
          (andb
            (Stdlib.op_eqeq (Declarations.generic_module_body.mod_type_alg mb)
              type_alg')
            (andb
              (Stdlib.op_eqeq
                (Declarations.generic_module_body.mod_constraints mb)
                constraints')
              (andb
                (Stdlib.op_eqeq (Declarations.generic_module_body.mod_delta mb)
                  delta')
                (Stdlib.op_eqeq
                  (Declarations.generic_module_body.mod_retroknowledge mb)
                  retroknowledge')))))) then
    mb
  else
    {| Declarations.generic_module_body.mod_mp := mp';
      Declarations.generic_module_body.mod_expr := expr';
      Declarations.generic_module_body.mod_type := type';
      Declarations.generic_module_body.mod_type_alg := type_alg';
      Declarations.generic_module_body.mod_constraints := constraints';
      Declarations.generic_module_body.mod_delta := delta';
      Declarations.generic_module_body.mod_retroknowledge := retroknowledge' |}

with hcons_module_body (mb : Declarations.module_body) {struct mb}
  : Declarations.module_body :=
  hcons_generic_module_body hcons_module_implementation mb

with hcons_module_type (mb : Declarations.module_type_body) {struct mb}
  : Declarations.module_type_body :=
  hcons_generic_module_body
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      tt) mb.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="declareops.mli">
  <div style="margin: 20px;">
    <h3>Declareops_mli</h3>
    <ul>
      <li>OCaml size: 89 lines</li>
      <li>Coq size: 90 lines (+1% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#declareops.mli"><code>declareops.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Declarations
open Mod_subst
open Univ

(** Operations concerning types in [Declarations] :
    [constant_body], [mutual_inductive_body], [module_body] ... *)

val universes_context : universes -&gt; AUContext.t

val abstract_universes : Entries.universes_entry -&gt; Univ.universe_level_subst * universes

(** {6 Arities} *)

val map_decl_arity : ('a -&gt; 'c) -&gt; ('b -&gt; 'd) -&gt;
  ('a, 'b) declaration_arity -&gt; ('c, 'd) declaration_arity

(** {6 Constants} *)

val subst_const_body : substitution -&gt; constant_body -&gt; constant_body

(** Is there a actual body in const_body ? *)

val constant_has_body : constant_body -&gt; bool

val constant_polymorphic_context : constant_body -&gt; AUContext.t

(** Is the constant polymorphic? *)
val constant_is_polymorphic : constant_body -&gt; bool

(** Return the universe context, in case the definition is polymorphic, otherwise
    the context is empty. *)

val is_opaque : constant_body -&gt; bool

(** {6 Inductive types} *)

val eq_recarg : recarg -&gt; recarg -&gt; bool

val subst_recarg : substitution -&gt; recarg -&gt; recarg

val mk_norec : wf_paths
val mk_paths : recarg -&gt; wf_paths list array -&gt; wf_paths
val dest_recarg : wf_paths -&gt; recarg
val dest_subterms : wf_paths -&gt; wf_paths list array
val recarg_length : wf_paths -&gt; int -&gt; int

val subst_wf_paths : substitution -&gt; wf_paths -&gt; wf_paths

val subst_mind_body : substitution -&gt; mutual_inductive_body -&gt; mutual_inductive_body

val inductive_polymorphic_context : mutual_inductive_body -&gt; AUContext.t

(** Is the inductive polymorphic? *)
val inductive_is_polymorphic : mutual_inductive_body -&gt; bool
(** Is the inductive cumulative? *)
val inductive_is_cumulative : mutual_inductive_body -&gt; bool

val inductive_make_projection : Names.inductive -&gt; mutual_inductive_body -&gt; proj_arg:int -&gt;
  Names.Projection.Repr.t option
val inductive_make_projections : Names.inductive -&gt; mutual_inductive_body -&gt;
  Names.Projection.Repr.t array option

val relevance_of_projection_repr : mutual_inductive_body -&gt; Names.Projection.Repr.t -&gt; Sorts.relevance

(** {6 Kernel flags} *)

(** A default, safe set of flags for kernel type-checking *)
val safe_flags : Conv_oracle.oracle -&gt; typing_flags

(** {6 Hash-consing} *)

(** Here, strictly speaking, we don't perform true hash-consing
    of the structure, but simply hash-cons all inner constr
    and other known elements *)

val hcons_const_body : constant_body -&gt; constant_body
val hcons_mind : mutual_inductive_body -&gt; mutual_inductive_body
val hcons_module_body : module_body -&gt; module_body
val hcons_module_type : module_type_body -&gt; module_type_body
</pre>
  </div>
  <div class="col-md-6">
    <a href="#declareops.mli"><code>Declareops_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter universes_context : Declarations.universes -&gt; Univ.AUContext.t.

Parameter abstract_universes :
  Entries.universes_entry -&gt; Univ.universe_level_subst * Declarations.universes.

Parameter map_decl_arity : forall {a b c d : Set},
  (a -&gt; c) -&gt; (b -&gt; d) -&gt; Declarations.declaration_arity a b -&gt;
  Declarations.declaration_arity c d.

Parameter subst_const_body :
  Mod_subst.substitution -&gt; Declarations.constant_body -&gt;
  Declarations.constant_body.

Parameter constant_has_body : Declarations.constant_body -&gt; bool.

Parameter constant_polymorphic_context :
  Declarations.constant_body -&gt; Univ.AUContext.t.

Parameter constant_is_polymorphic : Declarations.constant_body -&gt; bool.

Parameter is_opaque : Declarations.constant_body -&gt; bool.

Parameter eq_recarg : Declarations.recarg -&gt; Declarations.recarg -&gt; bool.

Parameter subst_recarg :
  Mod_subst.substitution -&gt; Declarations.recarg -&gt; Declarations.recarg.

Parameter mk_norec : Declarations.wf_paths.

Parameter mk_paths :
  Declarations.recarg -&gt; array (list Declarations.wf_paths) -&gt;
  Declarations.wf_paths.

Parameter dest_recarg : Declarations.wf_paths -&gt; Declarations.recarg.

Parameter dest_subterms :
  Declarations.wf_paths -&gt; array (list Declarations.wf_paths).

Parameter recarg_length : Declarations.wf_paths -&gt; Z -&gt; Z.

Parameter subst_wf_paths :
  Mod_subst.substitution -&gt; Declarations.wf_paths -&gt; Declarations.wf_paths.

Parameter subst_mind_body :
  Mod_subst.substitution -&gt; Declarations.mutual_inductive_body -&gt;
  Declarations.mutual_inductive_body.

Parameter inductive_polymorphic_context :
  Declarations.mutual_inductive_body -&gt; Univ.AUContext.t.

Parameter inductive_is_polymorphic : Declarations.mutual_inductive_body -&gt; bool.

Parameter inductive_is_cumulative : Declarations.mutual_inductive_body -&gt; bool.

Parameter inductive_make_projection :
  Names.inductive -&gt; Declarations.mutual_inductive_body -&gt; Z -&gt;
  option Names.Projection.Repr.t.

Parameter inductive_make_projections :
  Names.inductive -&gt; Declarations.mutual_inductive_body -&gt;
  option (array Names.Projection.Repr.t).

Parameter relevance_of_projection_repr :
  Declarations.mutual_inductive_body -&gt; Names.Projection.Repr.t -&gt;
  Sorts.relevance.

Parameter safe_flags : Conv_oracle.oracle -&gt; Declarations.typing_flags.

Parameter hcons_const_body :
  Declarations.constant_body -&gt; Declarations.constant_body.

Parameter hcons_mind :
  Declarations.mutual_inductive_body -&gt; Declarations.mutual_inductive_body.

Parameter hcons_module_body :
  Declarations.module_body -&gt; Declarations.module_body.

Parameter hcons_module_type :
  Declarations.module_type_body -&gt; Declarations.module_type_body.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="entries.ml">
  <div style="margin: 20px;">
    <h3>Entries</h3>
    <ul>
      <li>OCaml size: 128 lines</li>
      <li>Coq size: 310 lines (+142% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#entries.ml"><code>entries.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr

(** This module defines the entry types for global declarations. This
   information is entered in the environments. This includes global
   constants/axioms, mutual inductive definitions, modules and module
   types *)

type universes_entry =
  | Monomorphic_entry of Univ.ContextSet.t
  | Polymorphic_entry of Name.t array * Univ.UContext.t

type 'a in_universes_entry = 'a * universes_entry

(** {6 Declaration of inductive types. } *)

(** Assume the following definition in concrete syntax:
{v Inductive I1 (x1:X1) ... (xn:Xn) : A1 := c11 : T11 | ... | c1n1 : T1n1
...
with      Ip (x1:X1) ... (xn:Xn) : Ap := cp1 : Tp1 | ... | cpnp : Tpnp. v}

then, in i{^ th} block, [mind_entry_params] is [xn:Xn;...;x1:X1];
[mind_entry_arity] is [Ai], defined in context [x1:X1;...;xn:Xn];
[mind_entry_lc] is [Ti1;...;Tini], defined in context [[A'1;...;A'p;x1:X1;...;xn:Xn]] where [A'i] is [Ai] generalized over [[x1:X1;...;xn:Xn]].
*)

type one_inductive_entry = {
  mind_entry_typename : Id.t;
  mind_entry_arity : constr;
  mind_entry_template : bool; (* Use template polymorphism *)
  mind_entry_consnames : Id.t list;
  mind_entry_lc : constr list }

type mutual_inductive_entry = {
  mind_entry_record : (Id.t array option) option;
  (** Some (Some ids): primitive records with ids the binder name of each
      record in their respective projections. Not used by the kernel.
      Some None: non-primitive record *)
  mind_entry_finite : Declarations.recursivity_kind;
  mind_entry_params : Constr.rel_context;
  mind_entry_inds : one_inductive_entry list;
  mind_entry_universes : universes_entry;
  mind_entry_variance : Univ.Variance.t array option;
  (* universe constraints and the constraints for subtyping of
     inductive types in the block. *)
  mind_entry_private : bool option;
}

(** {6 Constants (Definition/Axiom) } *)
type 'a proof_output = constr Univ.in_universe_context_set * 'a
type 'a const_entry_body = 'a proof_output Future.computation

type 'a definition_entry = {
  const_entry_body   : 'a const_entry_body;
  (* List of section variables *)
  const_entry_secctx : Constr.named_context option;
  (* State id on which the completion of type checking is reported *)
  const_entry_feedback : Stateid.t option;
  const_entry_type        : types option;
  const_entry_universes   : universes_entry;
  const_entry_opaque      : bool;
  const_entry_inline_code : bool }

type section_def_entry = {
  secdef_body : constr;
  secdef_secctx : Constr.named_context option;
  secdef_feedback : Stateid.t option;
  secdef_type : types option;
}

type inline = int option (* inlining level, None for no inlining *)

type parameter_entry =
    Constr.named_context option * types in_universes_entry * inline

type primitive_entry = {
  prim_entry_type : types option;
  prim_entry_univs : Univ.ContextSet.t; (* always monomorphic *)
  prim_entry_content : CPrimitives.op_or_type;
}

type 'a constant_entry =
  | DefinitionEntry of 'a definition_entry
  | ParameterEntry of parameter_entry
  | PrimitiveEntry of primitive_entry

(** {6 Modules } *)

type module_struct_entry = Declarations.module_alg_expr

type module_params_entry =
  (MBId.t * module_struct_entry) list (** older first *)

type module_type_entry = module_params_entry * module_struct_entry

type module_entry =
  | MType of module_params_entry * module_struct_entry
  | MExpr of
      module_params_entry * module_struct_entry * module_struct_entry option


<abbr class="mark-warning" title="Polymorphic variant types are not handled">type seff_env =
  [ `Nothing
  (* The proof term and its universes.
     Same as the constant_body's but not in an ephemeron *)
  | `Opaque of Constr.t * Univ.ContextSet.t ]</abbr>

(** Not used by the kernel. *)
type side_effect_role =
  | Subproof
  | Schema of inductive * string

type side_eff = {
  seff_constant : Constant.t;
  seff_body : Declarations.constant_body;
  seff_env : seff_env;
  seff_role : side_effect_role;
}
</pre>
  </div>
  <div class="col-md-6">
    <a href="#entries.ml"><code>Entries.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Constr.

Inductive universes_entry : Set :=
| Monomorphic_entry : Univ.ContextSet.t -&gt; universes_entry
| Polymorphic_entry : array Names.Name.t -&gt; Univ.UContext.t -&gt; universes_entry.

Definition in_universes_entry (a : Set) := a * universes_entry.

Module one_inductive_entry.
  Record record := {
    mind_entry_typename : Names.Id.t;
    mind_entry_arity : Constr.constr;
    mind_entry_template : bool;
    mind_entry_consnames : list Names.Id.t;
    mind_entry_lc : list Constr.constr }.
  Definition with_mind_entry_typename (r : record) mind_entry_typename
    : record :=
    {| mind_entry_typename := mind_entry_typename;
      mind_entry_arity := mind_entry_arity r;
      mind_entry_template := mind_entry_template r;
      mind_entry_consnames := mind_entry_consnames r;
      mind_entry_lc := mind_entry_lc r |}.
  Definition with_mind_entry_arity (r : record) mind_entry_arity : record :=
    {| mind_entry_typename := mind_entry_typename r;
      mind_entry_arity := mind_entry_arity;
      mind_entry_template := mind_entry_template r;
      mind_entry_consnames := mind_entry_consnames r;
      mind_entry_lc := mind_entry_lc r |}.
  Definition with_mind_entry_template (r : record) mind_entry_template
    : record :=
    {| mind_entry_typename := mind_entry_typename r;
      mind_entry_arity := mind_entry_arity r;
      mind_entry_template := mind_entry_template;
      mind_entry_consnames := mind_entry_consnames r;
      mind_entry_lc := mind_entry_lc r |}.
  Definition with_mind_entry_consnames (r : record) mind_entry_consnames
    : record :=
    {| mind_entry_typename := mind_entry_typename r;
      mind_entry_arity := mind_entry_arity r;
      mind_entry_template := mind_entry_template r;
      mind_entry_consnames := mind_entry_consnames;
      mind_entry_lc := mind_entry_lc r |}.
  Definition with_mind_entry_lc (r : record) mind_entry_lc : record :=
    {| mind_entry_typename := mind_entry_typename r;
      mind_entry_arity := mind_entry_arity r;
      mind_entry_template := mind_entry_template r;
      mind_entry_consnames := mind_entry_consnames r;
      mind_entry_lc := mind_entry_lc |}.
End one_inductive_entry.
Definition one_inductive_entry := one_inductive_entry.record.

Module mutual_inductive_entry.
  Record record := {
    mind_entry_record : option (option (array Names.Id.t));
    mind_entry_finite : Declarations.recursivity_kind;
    mind_entry_params : Constr.rel_context;
    mind_entry_inds : list one_inductive_entry;
    mind_entry_universes : universes_entry;
    mind_entry_variance : option (array Univ.Variance.t);
    mind_entry_private : option bool }.
  Definition with_mind_entry_record (r : record) mind_entry_record : record :=
    {| mind_entry_record := mind_entry_record;
      mind_entry_finite := mind_entry_finite r;
      mind_entry_params := mind_entry_params r;
      mind_entry_inds := mind_entry_inds r;
      mind_entry_universes := mind_entry_universes r;
      mind_entry_variance := mind_entry_variance r;
      mind_entry_private := mind_entry_private r |}.
  Definition with_mind_entry_finite (r : record) mind_entry_finite : record :=
    {| mind_entry_record := mind_entry_record r;
      mind_entry_finite := mind_entry_finite;
      mind_entry_params := mind_entry_params r;
      mind_entry_inds := mind_entry_inds r;
      mind_entry_universes := mind_entry_universes r;
      mind_entry_variance := mind_entry_variance r;
      mind_entry_private := mind_entry_private r |}.
  Definition with_mind_entry_params (r : record) mind_entry_params : record :=
    {| mind_entry_record := mind_entry_record r;
      mind_entry_finite := mind_entry_finite r;
      mind_entry_params := mind_entry_params;
      mind_entry_inds := mind_entry_inds r;
      mind_entry_universes := mind_entry_universes r;
      mind_entry_variance := mind_entry_variance r;
      mind_entry_private := mind_entry_private r |}.
  Definition with_mind_entry_inds (r : record) mind_entry_inds : record :=
    {| mind_entry_record := mind_entry_record r;
      mind_entry_finite := mind_entry_finite r;
      mind_entry_params := mind_entry_params r;
      mind_entry_inds := mind_entry_inds;
      mind_entry_universes := mind_entry_universes r;
      mind_entry_variance := mind_entry_variance r;
      mind_entry_private := mind_entry_private r |}.
  Definition with_mind_entry_universes (r : record) mind_entry_universes
    : record :=
    {| mind_entry_record := mind_entry_record r;
      mind_entry_finite := mind_entry_finite r;
      mind_entry_params := mind_entry_params r;
      mind_entry_inds := mind_entry_inds r;
      mind_entry_universes := mind_entry_universes;
      mind_entry_variance := mind_entry_variance r;
      mind_entry_private := mind_entry_private r |}.
  Definition with_mind_entry_variance (r : record) mind_entry_variance
    : record :=
    {| mind_entry_record := mind_entry_record r;
      mind_entry_finite := mind_entry_finite r;
      mind_entry_params := mind_entry_params r;
      mind_entry_inds := mind_entry_inds r;
      mind_entry_universes := mind_entry_universes r;
      mind_entry_variance := mind_entry_variance;
      mind_entry_private := mind_entry_private r |}.
  Definition with_mind_entry_private (r : record) mind_entry_private : record :=
    {| mind_entry_record := mind_entry_record r;
      mind_entry_finite := mind_entry_finite r;
      mind_entry_params := mind_entry_params r;
      mind_entry_inds := mind_entry_inds r;
      mind_entry_universes := mind_entry_universes r;
      mind_entry_variance := mind_entry_variance r;
      mind_entry_private := mind_entry_private |}.
End mutual_inductive_entry.
Definition mutual_inductive_entry := mutual_inductive_entry.record.

Definition proof_output (a : Set) :=
  Univ.in_universe_context_set Constr.constr * a.

Definition const_entry_body (a : Set) := Future.computation (proof_output a).

Module definition_entry.
  Record record {a : Set} := {
    const_entry_body : const_entry_body a;
    const_entry_secctx : option Constr.named_context;
    const_entry_feedback : option Stateid.t;
    const_entry_type : option Constr.types;
    const_entry_universes : universes_entry;
    const_entry_opaque : bool;
    const_entry_inline_code : bool }.
  Arguments record : clear implicits.
  Definition with_const_entry_body {a_type : Set} (r : record a_type)
    const_entry_body : record a_type :=
    {| const_entry_body := const_entry_body;
      const_entry_secctx := const_entry_secctx r;
      const_entry_feedback := const_entry_feedback r;
      const_entry_type := const_entry_type r;
      const_entry_universes := const_entry_universes r;
      const_entry_opaque := const_entry_opaque r;
      const_entry_inline_code := const_entry_inline_code r |}.
  Definition with_const_entry_secctx {a_type : Set} (r : record a_type)
    const_entry_secctx : record a_type :=
    {| const_entry_body := const_entry_body r;
      const_entry_secctx := const_entry_secctx;
      const_entry_feedback := const_entry_feedback r;
      const_entry_type := const_entry_type r;
      const_entry_universes := const_entry_universes r;
      const_entry_opaque := const_entry_opaque r;
      const_entry_inline_code := const_entry_inline_code r |}.
  Definition with_const_entry_feedback {a_type : Set} (r : record a_type)
    const_entry_feedback : record a_type :=
    {| const_entry_body := const_entry_body r;
      const_entry_secctx := const_entry_secctx r;
      const_entry_feedback := const_entry_feedback;
      const_entry_type := const_entry_type r;
      const_entry_universes := const_entry_universes r;
      const_entry_opaque := const_entry_opaque r;
      const_entry_inline_code := const_entry_inline_code r |}.
  Definition with_const_entry_type {a_type : Set} (r : record a_type)
    const_entry_type : record a_type :=
    {| const_entry_body := const_entry_body r;
      const_entry_secctx := const_entry_secctx r;
      const_entry_feedback := const_entry_feedback r;
      const_entry_type := const_entry_type;
      const_entry_universes := const_entry_universes r;
      const_entry_opaque := const_entry_opaque r;
      const_entry_inline_code := const_entry_inline_code r |}.
  Definition with_const_entry_universes {a_type : Set} (r : record a_type)
    const_entry_universes : record a_type :=
    {| const_entry_body := const_entry_body r;
      const_entry_secctx := const_entry_secctx r;
      const_entry_feedback := const_entry_feedback r;
      const_entry_type := const_entry_type r;
      const_entry_universes := const_entry_universes;
      const_entry_opaque := const_entry_opaque r;
      const_entry_inline_code := const_entry_inline_code r |}.
  Definition with_const_entry_opaque {a_type : Set} (r : record a_type)
    const_entry_opaque : record a_type :=
    {| const_entry_body := const_entry_body r;
      const_entry_secctx := const_entry_secctx r;
      const_entry_feedback := const_entry_feedback r;
      const_entry_type := const_entry_type r;
      const_entry_universes := const_entry_universes r;
      const_entry_opaque := const_entry_opaque;
      const_entry_inline_code := const_entry_inline_code r |}.
  Definition with_const_entry_inline_code {a_type : Set} (r : record a_type)
    const_entry_inline_code : record a_type :=
    {| const_entry_body := const_entry_body r;
      const_entry_secctx := const_entry_secctx r;
      const_entry_feedback := const_entry_feedback r;
      const_entry_type := const_entry_type r;
      const_entry_universes := const_entry_universes r;
      const_entry_opaque := const_entry_opaque r;
      const_entry_inline_code := const_entry_inline_code |}.
End definition_entry.
Definition definition_entry := definition_entry.record.

Module section_def_entry.
  Record record := {
    secdef_body : Constr.constr;
    secdef_secctx : option Constr.named_context;
    secdef_feedback : option Stateid.t;
    secdef_type : option Constr.types }.
  Definition with_secdef_body (r : record) secdef_body : record :=
    {| secdef_body := secdef_body; secdef_secctx := secdef_secctx r;
      secdef_feedback := secdef_feedback r; secdef_type := secdef_type r |}.
  Definition with_secdef_secctx (r : record) secdef_secctx : record :=
    {| secdef_body := secdef_body r; secdef_secctx := secdef_secctx;
      secdef_feedback := secdef_feedback r; secdef_type := secdef_type r |}.
  Definition with_secdef_feedback (r : record) secdef_feedback : record :=
    {| secdef_body := secdef_body r; secdef_secctx := secdef_secctx r;
      secdef_feedback := secdef_feedback; secdef_type := secdef_type r |}.
  Definition with_secdef_type (r : record) secdef_type : record :=
    {| secdef_body := secdef_body r; secdef_secctx := secdef_secctx r;
      secdef_feedback := secdef_feedback r; secdef_type := secdef_type |}.
End section_def_entry.
Definition section_def_entry := section_def_entry.record.

Definition inline := option Z.

Definition parameter_entry :=
  option Constr.named_context * in_universes_entry Constr.types * inline.

Module primitive_entry.
  Record record := {
    prim_entry_type : option Constr.types;
    prim_entry_univs : Univ.ContextSet.t;
    prim_entry_content : CPrimitives.op_or_type }.
  Definition with_prim_entry_type (r : record) prim_entry_type : record :=
    {| prim_entry_type := prim_entry_type;
      prim_entry_univs := prim_entry_univs r;
      prim_entry_content := prim_entry_content r |}.
  Definition with_prim_entry_univs (r : record) prim_entry_univs : record :=
    {| prim_entry_type := prim_entry_type r;
      prim_entry_univs := prim_entry_univs;
      prim_entry_content := prim_entry_content r |}.
  Definition with_prim_entry_content (r : record) prim_entry_content : record :=
    {| prim_entry_type := prim_entry_type r;
      prim_entry_univs := prim_entry_univs r;
      prim_entry_content := prim_entry_content |}.
End primitive_entry.
Definition primitive_entry := primitive_entry.record.

Inductive constant_entry (a : Set) : Set :=
| DefinitionEntry : definition_entry a -&gt; constant_entry a
| ParameterEntry : parameter_entry -&gt; constant_entry a
| PrimitiveEntry : primitive_entry -&gt; constant_entry a.

Arguments DefinitionEntry {_}.
Arguments ParameterEntry {_}.
Arguments PrimitiveEntry {_}.

Definition module_struct_entry := Declarations.module_alg_expr.

Definition module_params_entry := list (Names.MBId.t * module_struct_entry).

Definition module_type_entry := module_params_entry * module_struct_entry.

Inductive module_entry : Set :=
| MType : module_params_entry -&gt; module_struct_entry -&gt; module_entry
| MExpr :
  module_params_entry -&gt; module_struct_entry -&gt; option module_struct_entry -&gt;
  module_entry.

Inductive seff_env : Set :=
| Nothing : seff_env
| Opaque : Constr.t * Univ.ContextSet.t -&gt; seff_env.

Inductive side_effect_role : Set :=
| Subproof : side_effect_role
| Schema : Names.inductive -&gt; string -&gt; side_effect_role.

Module side_eff.
  Record record := {
    seff_constant : Names.Constant.t;
    seff_body : Declarations.constant_body;
    seff_env : seff_env;
    seff_role : side_effect_role }.
  Definition with_seff_constant (r : record) seff_constant : record :=
    {| seff_constant := seff_constant; seff_body := seff_body r;
      seff_env := seff_env r; seff_role := seff_role r |}.
  Definition with_seff_body (r : record) seff_body : record :=
    {| seff_constant := seff_constant r; seff_body := seff_body;
      seff_env := seff_env r; seff_role := seff_role r |}.
  Definition with_seff_env (r : record) seff_env : record :=
    {| seff_constant := seff_constant r; seff_body := seff_body r;
      seff_env := seff_env; seff_role := seff_role r |}.
  Definition with_seff_role (r : record) seff_role : record :=
    {| seff_constant := seff_constant r; seff_body := seff_body r;
      seff_env := seff_env r; seff_role := seff_role |}.
End side_eff.
Definition side_eff := side_eff.record.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="environ.ml">
  <div style="margin: 20px;">
    <h3>Environ</h3>
    <ul>
      <li>OCaml size: 811 lines</li>
      <li>Coq size: 1215 lines (+49% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#environ.ml"><code>environ.ml</code></a>&nbsp;<span class="label label-warning">14 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Author: Jean-Christophe FilliÃ¢tre as part of the rebuilding of Coq
   around a purely functional abstract type-checker, Aug 1999 *)
(* Cleaning and lightening of the kernel by Bruno Barras, Nov 2001 *)
(* Flag for predicativity of Set by Hugo Herbelin in Oct 2003 *)
(* Support for virtual machine by Benjamin GrÃ©goire in Oct 2004 *)
(* Support for retroknowledge by Arnaud Spiwack in May 2007 *)
(* Support for assumption dependencies by Arnaud Spiwack in May 2007 *)

(* Miscellaneous maintenance by Bruno Barras, Hugo Herbelin, Jean-Marc
   Notin, Matthieu Sozeau *)

(* This file defines the type of environments on which the
   type-checker works, together with simple related functions *)

open CErrors
open Util
open Names
open Constr
open Vars
open Declarations
open Context.Rel.Declaration

module NamedDecl = Context.Named.Declaration

(* The type of environments. *)

(* The key attached to each constant is used by the VM to retrieve previous *)
(* evaluations of the constant. It is essentially an index in the symbols table *)
(* used by the VM. *)
type key = int CEphemeron.key option ref

(** Linking information for the native compiler. *)

type link_info =
  | Linked of string
  | LinkedInteractive of string
  | NotLinked

type constant_key = constant_body * (link_info ref * key)

type mind_key = mutual_inductive_body * link_info ref

type globals = {
  env_constants : constant_key Cmap_env.t;
  env_inductives : mind_key Mindmap_env.t;
  env_modules : module_body MPmap.t;
  env_modtypes : module_type_body MPmap.t;
}

type stratification = {
  env_universes : UGraph.t;
  env_sprop_allowed : bool;
  env_universes_lbound : Univ.Level.t;
  env_engagement : engagement
}

type val_kind =
    | VKvalue of (Vmvalues.values * Id.Set.t) CEphemeron.key
    | VKnone

type lazy_val = val_kind ref

let force_lazy_val vk = match !vk with
| VKnone -&gt; None
| VKvalue v -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (CEphemeron.get v) with CEphemeron.InvalidKey -&gt; None</abbr>

let dummy_lazy_val () = ref VKnone
let build_lazy_val vk key = vk := VKvalue (CEphemeron.create key)

type named_context_val = {
  env_named_ctx : Constr.named_context;
  env_named_map : (Constr.named_declaration * lazy_val) Id.Map.t;
}

type rel_context_val = {
  env_rel_ctx : Constr.rel_context;
  env_rel_map : (Constr.rel_declaration * lazy_val) Range.t;
}

type env = {
  env_globals       : globals;
  env_named_context : named_context_val; (* section variables *)
  env_rel_context   : rel_context_val;
  env_nb_rel        : int;
  env_stratification : stratification;
  env_typing_flags  : typing_flags;
  retroknowledge : Retroknowledge.retroknowledge;
  indirect_pterms : Opaqueproof.opaquetab;
}

let empty_named_context_val = {
  env_named_ctx = [];
  env_named_map = Id.Map.empty;
}

let empty_rel_context_val = {
  env_rel_ctx = [];
  env_rel_map = Range.empty;
}

let empty_env = {
  env_globals = {
    env_constants = Cmap_env.empty;
    env_inductives = Mindmap_env.empty;
    env_modules = MPmap.empty;
    env_modtypes = MPmap.empty};
  env_named_context = empty_named_context_val;
  env_rel_context = empty_rel_context_val;
  env_nb_rel = 0;
  env_stratification = {
    env_universes = UGraph.initial_universes;
    env_sprop_allowed = false;
    env_universes_lbound = Univ.Level.set;
    env_engagement = PredicativeSet };
  env_typing_flags = Declareops.safe_flags Conv_oracle.empty;
  retroknowledge = Retroknowledge.empty;
  indirect_pterms = Opaqueproof.empty_opaquetab }


(* Rel context *)

let push_rel_context_val d ctx = {
  env_rel_ctx = Context.Rel.add d ctx.env_rel_ctx;
  env_rel_map = Range.cons (d, ref VKnone) ctx.env_rel_map;
}

let match_rel_context_val ctx = match ctx.env_rel_ctx with
| [] -&gt; None
| decl :: rem -&gt;
  let (_, lval) = Range.hd ctx.env_rel_map in
  let ctx = { env_rel_ctx = rem; env_rel_map = Range.tl ctx.env_rel_map } in
  Some (decl, lval, ctx)

let push_rel d env =
    { env with
      env_rel_context = push_rel_context_val d env.env_rel_context;
      env_nb_rel = env.env_nb_rel + 1 }

let lookup_rel n env =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try fst (Range.get env.env_rel_context.env_rel_map (n - 1))
  with Invalid_argument _ -&gt; raise Not_found</abbr>

let lookup_rel_val n env =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try snd (Range.get env.env_rel_context.env_rel_map (n - 1))
  with Invalid_argument _ -&gt; raise Not_found</abbr>

let rel_skipn n ctx = {
  env_rel_ctx = Util.List.skipn n ctx.env_rel_ctx;
  env_rel_map = Range.skipn n ctx.env_rel_map;
}

let env_of_rel n env =
  { env with
    env_rel_context = rel_skipn n env.env_rel_context;
    env_nb_rel = env.env_nb_rel - n
  }

(* Named context *)

let push_named_context_val_val d rval ctxt =
(*   assert (not (Id.Map.mem (NamedDecl.get_id d) ctxt.env_named_map)); *)
  {
    env_named_ctx = Context.Named.add d ctxt.env_named_ctx;
    env_named_map = Id.Map.add (NamedDecl.get_id d) (d, rval) ctxt.env_named_map;
  }

let push_named_context_val d ctxt =
  push_named_context_val_val d (ref VKnone) ctxt

let match_named_context_val c = match c.env_named_ctx with
| [] -&gt; None
| decl :: ctx -&gt;
  let (_, v) = Id.Map.find (NamedDecl.get_id decl) c.env_named_map in
  let map = Id.Map.remove (NamedDecl.get_id decl) c.env_named_map in
  let cval = { env_named_ctx = ctx; env_named_map = map } in
  Some (decl, v, cval)

let map_named_val f ctxt =
  let open Context.Named.Declaration in
  let fold accu d =
    let d' = map_constr f d in
    let accu =
      if d == d' then accu
      else Id.Map.modify (get_id d) (fun _ (_, v) -&gt; (d', v)) accu
    in
    (accu, d')
  in
  let map, ctx = List.fold_left_map fold ctxt.env_named_map ctxt.env_named_ctx in
  if map == ctxt.env_named_map then ctxt
  else { env_named_ctx = ctx; env_named_map = map }

let push_named d env =
  {env with env_named_context = push_named_context_val d env.env_named_context}

let lookup_named id env =
  fst (Id.Map.find id env.env_named_context.env_named_map)

let lookup_named_val id env =
  snd(Id.Map.find id env.env_named_context.env_named_map)

let lookup_named_ctxt id ctxt =
  fst (Id.Map.find id ctxt.env_named_map)

let fold_constants f env acc =
  Cmap_env.fold (fun c (body,_) acc -&gt; f c body acc) env.env_globals.env_constants acc

(* Global constants *)

let lookup_constant_key kn env =
  Cmap_env.find kn env.env_globals.env_constants

let lookup_constant kn env =
  fst (Cmap_env.find kn env.env_globals.env_constants)

(* Mutual Inductives *)
let lookup_mind kn env =
  fst (Mindmap_env.find kn env.env_globals.env_inductives)

let mind_context env mind =
  let mib = lookup_mind mind env in
  Declareops.inductive_polymorphic_context mib

let lookup_mind_key kn env =
  Mindmap_env.find kn env.env_globals.env_inductives

let oracle env = env.env_typing_flags.conv_oracle
let set_oracle env o =
  let env_typing_flags = { env.env_typing_flags with conv_oracle = o } in
  { env with env_typing_flags }

let engagement env = env.env_stratification.env_engagement
let typing_flags env = env.env_typing_flags

let is_impredicative_set env =
  match engagement env with
  | ImpredicativeSet -&gt; true
  | _ -&gt; false

let is_impredicative_sort env = function
  | Sorts.SProp | Sorts.Prop -&gt; true
  | Sorts.Set -&gt; is_impredicative_set env
  | Sorts.Type _ -&gt; false

let is_impredicative_univ env u = is_impredicative_sort env (Sorts.sort_of_univ u)

let type_in_type env = not (typing_flags env).check_universes
let deactivated_guard env = not (typing_flags env).check_guarded

let indices_matter env = env.env_typing_flags.indices_matter
let check_template env = env.env_typing_flags.check_template

let universes env = env.env_stratification.env_universes
let universes_lbound env = env.env_stratification.env_universes_lbound

let set_universes_lbound env lbound =
  let env_stratification = { env.env_stratification with env_universes_lbound = lbound } in
  { env with env_stratification }

let named_context env = env.env_named_context.env_named_ctx
let named_context_val env = env.env_named_context
let rel_context env = env.env_rel_context.env_rel_ctx
let opaque_tables env = env.indirect_pterms
let set_opaque_tables env indirect_pterms = { env with indirect_pterms }

let empty_context env =
  match env.env_rel_context.env_rel_ctx, env.env_named_context.env_named_ctx with
  | [], [] -&gt; true
  | _ -&gt; false

(* Rel context *)
let evaluable_rel n env =
  is_local_def (lookup_rel n env)

let nb_rel env = env.env_nb_rel

let push_rel_context ctxt x = Context.Rel.fold_outside push_rel ctxt ~init:x

let push_rec_types (lna,typarray,_) env =
  let ctxt = Array.map2_i (fun i na t -&gt; LocalAssum (na, lift i t)) lna typarray in
  Array.fold_left (fun e assum -&gt; push_rel assum e) env ctxt

let fold_rel_context f env ~init =
  let rec fold_right env =
    match match_rel_context_val env.env_rel_context with
    | None -&gt; init
    | Some (rd, _, rc) -&gt;
        let env =
          { env with
            env_rel_context = rc;
            env_nb_rel = env.env_nb_rel - 1 } in
        f env rd (fold_right env)
  in fold_right env

(* Named context *)

let named_context_of_val c = c.env_named_ctx

let ids_of_named_context_val c = Id.Map.domain c.env_named_map

let empty_named_context = Context.Named.empty

let push_named_context = List.fold_right push_named

let val_of_named_context ctxt =
  List.fold_right push_named_context_val ctxt empty_named_context_val


let eq_named_context_val c1 c2 =
   c1 == c2 || Context.Named.equal Constr.equal (named_context_of_val c1) (named_context_of_val c2)

(* A local const is evaluable if it is defined  *)

let named_type id env =
  let open Context.Named.Declaration in
  get_type (lookup_named id env)

let named_body id env =
  let open Context.Named.Declaration in
  get_value (lookup_named id env)

let evaluable_named id env =
  match named_body id env with
  | Some _      -&gt; true
  | _          -&gt; false

let reset_with_named_context ctxt env =
  { env with
    env_named_context = ctxt;
    env_rel_context = empty_rel_context_val;
    env_nb_rel = 0 }

let reset_context = reset_with_named_context empty_named_context_val

let pop_rel_context n env =
  let rec skip n ctx =
    if Int.equal n 0 then ctx
    else match match_rel_context_val ctx with
    | None -&gt; invalid_arg &quot;List.skipn&quot;
    | Some (_, _, ctx) -&gt; skip (pred n) ctx
  in
  let ctxt = env.env_rel_context in
  { env with
    env_rel_context = skip n ctxt;
    env_nb_rel = env.env_nb_rel - n }

let fold_named_context f env ~init =
  let rec fold_right env =
    match match_named_context_val env.env_named_context with
    | None -&gt; init
    | Some (d, _v, rem) -&gt;
        let env =
          reset_with_named_context rem env in
        f env d (fold_right env)
  in fold_right env

let fold_named_context_reverse f ~init env =
  Context.Named.fold_inside f ~init:init (named_context env)


(* Universe constraints *)

let map_universes f env =
  let s = env.env_stratification in
    { env with env_stratification =
         { s with env_universes = f s.env_universes } }

let add_constraints c env =
  if Univ.Constraint.is_empty c then env
  else map_universes (UGraph.merge_constraints c) env

let check_constraints c env =
  UGraph.check_constraints c env.env_stratification.env_universes

let push_constraints_to_env (_,univs) env =
  add_constraints univs env

let add_universes ~lbound ~strict ctx g =
  let g = Array.fold_left
            (fun g v -&gt; UGraph.add_universe ~lbound ~strict v g)
            g (Univ.Instance.to_array (Univ.UContext.instance ctx))
  in
    UGraph.merge_constraints (Univ.UContext.constraints ctx) g

let push_context ?(strict=false) ctx env =
  map_universes (add_universes ~lbound:(universes_lbound env) ~strict ctx) env

let add_universes_set ~lbound ~strict ctx g =
  let g = Univ.LSet.fold
            (* Be lenient, module typing reintroduces universes and constraints due to includes *)
            (fun v g -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try UGraph.add_universe ~lbound ~strict v g with UGraph.AlreadyDeclared -&gt; g</abbr>)
            (Univ.ContextSet.levels ctx) g
  in UGraph.merge_constraints (Univ.ContextSet.constraints ctx) g

let push_context_set ?(strict=false) ctx env =
  map_universes (add_universes_set ~lbound:(universes_lbound env) ~strict ctx) env

let push_subgraph (levels,csts) env =
  let lbound = universes_lbound env in
  let add_subgraph g =
    let newg = Univ.LSet.fold (fun v g -&gt; UGraph.add_universe ~lbound ~strict:false v g) levels g in
    let newg = UGraph.merge_constraints csts newg in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(if not (Univ.Constraint.is_empty csts) then
       let restricted = UGraph.constraints_for ~kept:(UGraph.domain g) newg in
       (if not (UGraph.check_constraints restricted g) then
          CErrors.anomaly Pp.(str &quot;Local constraints imply new transitive constraints.&quot;)));
    newg</abbr>
  in
  map_universes add_subgraph env

let set_engagement c env = (* Unsafe *)
  { env with env_stratification =
    { env.env_stratification with env_engagement = c } }

(* It's convenient to use [{flags with foo = bar}] so we're smart wrt to it. *)
let same_flags {
     check_guarded;
     check_universes;
     conv_oracle;
     indices_matter;
     share_reduction;
     enable_VM;
     enable_native_compiler;
     check_template;
  } alt =
  check_guarded == alt.check_guarded &amp;&amp;
  check_universes == alt.check_universes &amp;&amp;
  conv_oracle == alt.conv_oracle &amp;&amp;
  indices_matter == alt.indices_matter &amp;&amp;
  share_reduction == alt.share_reduction &amp;&amp;
  enable_VM == alt.enable_VM &amp;&amp;
  enable_native_compiler == alt.enable_native_compiler &amp;&amp;
  check_template == alt.check_template
[@warning &quot;+9&quot;]

let set_typing_flags c env = (* Unsafe *)
  if same_flags env.env_typing_flags c then env
  else { env with env_typing_flags = c }

let make_sprop_cumulative = map_universes UGraph.make_sprop_cumulative

let set_allow_sprop b env =
  { env with env_stratification =
    { env.env_stratification with env_sprop_allowed = b } }

let sprop_allowed env = env.env_stratification.env_sprop_allowed

(* Global constants *)

let no_link_info = NotLinked

let add_constant_key kn cb linkinfo env =
  let new_constants =
    Cmap_env.add kn (cb,(ref linkinfo, ref None)) env.env_globals.env_constants in
  let new_globals =
    { env.env_globals with
        env_constants = new_constants } in
  { env with env_globals = new_globals }

let add_constant kn cb env =
  add_constant_key kn cb no_link_info env

(* constant_type gives the type of a constant *)
let constant_type env (kn,u) =
  let cb = lookup_constant kn env in
  let uctx = Declareops.constant_polymorphic_context cb in
  let csts = Univ.AUContext.instantiate u uctx in
  (subst_instance_constr u cb.const_type, csts)

type const_evaluation_result =
  | NoBody
  | Opaque
  | IsPrimitive of CPrimitives.t

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception NotEvaluableConst of const_evaluation_result</abbr>

let constant_value_and_type env (kn, u) =
  let cb = lookup_constant kn env in
  let uctx = Declareops.constant_polymorphic_context cb in
  let cst = Univ.AUContext.instantiate u uctx in
  let b' = match cb.const_body with
    | Def l_body -&gt; Some (subst_instance_constr u (Mod_subst.force_constr l_body))
    | OpaqueDef _ -&gt; None
    | Undef _ | Primitive _ -&gt; None
  in
  b', subst_instance_constr u cb.const_type, cst

let body_of_constant_body env cb =
  let otab = opaque_tables env in
  match cb.const_body with
  | Undef _ | Primitive _ -&gt;
     None
  | Def c -&gt;
     Some (Mod_subst.force_constr c, Declareops.constant_polymorphic_context cb)
  | OpaqueDef o -&gt;
     Some (Opaqueproof.force_proof otab o, Declareops.constant_polymorphic_context cb)

(* These functions should be called under the invariant that [env]
   already contains the constraints corresponding to the constant
   application. *)

(* constant_type gives the type of a constant *)
let constant_type_in env (kn,u) =
  let cb = lookup_constant kn env in
  subst_instance_constr u cb.const_type

let constant_value_in env (kn,u) =
  let cb = lookup_constant kn env in
  match cb.const_body with
    | Def l_body -&gt;
      let b = Mod_subst.force_constr l_body in
        subst_instance_constr u b
    | OpaqueDef _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">(NotEvaluableConst Opaque)</abbr>
    | Undef _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">(NotEvaluableConst NoBody)</abbr>
    | Primitive p -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">(NotEvaluableConst (IsPrimitive p))</abbr>

let constant_opt_value_in env cst =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (constant_value_in env cst)
  with NotEvaluableConst _ -&gt; None</abbr>

(* A global const is evaluable if it is defined and not opaque *)
let evaluable_constant kn env =
  let cb = lookup_constant kn env in
    match cb.const_body with
    | Def _ -&gt; true
    | OpaqueDef _ -&gt; false
    | Undef _ | Primitive _ -&gt; false

let is_primitive env c =
  let cb = lookup_constant c env in
  match cb.Declarations.const_body with
  | Declarations.Primitive _ -&gt; true
  | _ -&gt; false

let polymorphic_constant cst env =
  Declareops.constant_is_polymorphic (lookup_constant cst env)

let polymorphic_pconstant (cst,u) env =
  if Univ.Instance.is_empty u then false
  else polymorphic_constant cst env

let type_in_type_constant cst env =
  not (lookup_constant cst env).const_typing_flags.check_universes

let lookup_projection p env =
  let mind,i = Projection.inductive p in
  let mib = lookup_mind mind env in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(if not (Int.equal mib.mind_nparams (Projection.npars p))
   then anomaly ~label:&quot;lookup_projection&quot; Pp.(str &quot;Bad number of parameters on projection.&quot;));
  match mib.mind_record with
  | NotRecord | FakeRecord -&gt; anomaly ~label:&quot;lookup_projection&quot; Pp.(str &quot;not a projection&quot;)
  | PrimRecord infos -&gt;
    let _,_,_,typs = infos.(i) in
    typs.(Projection.arg p)</abbr>

let get_projection env ind ~proj_arg =
  let mib = lookup_mind (fst ind) env in
  Declareops.inductive_make_projection ind mib ~proj_arg

let get_projections env ind =
  let mib = lookup_mind (fst ind) env in
  Declareops.inductive_make_projections ind mib

(* Mutual Inductives *)
let polymorphic_ind (mind,_i) env =
  Declareops.inductive_is_polymorphic (lookup_mind mind env)

let polymorphic_pind (ind,u) env =
  if Univ.Instance.is_empty u then false
  else polymorphic_ind ind env

let type_in_type_ind (mind,_i) env =
  not (lookup_mind mind env).mind_typing_flags.check_universes

let template_checked_ind (mind,_i) env =
  (lookup_mind mind env).mind_typing_flags.check_template

let template_polymorphic_ind (mind,i) env =
  match (lookup_mind mind env).mind_packets.(i).mind_arity with
  | TemplateArity _ -&gt; true
  | RegularArity _ -&gt; false

let template_polymorphic_variables (mind,i) env =
  match (lookup_mind mind env).mind_packets.(i).mind_arity with
  | TemplateArity { Declarations.template_param_levels = l; _ } -&gt;
    List.map_filter (fun level -&gt; level) l
  | RegularArity _ -&gt; []

let template_polymorphic_pind (ind,u) env =
  if not (Univ.Instance.is_empty u) then false
  else template_polymorphic_ind ind env

let add_mind_key kn (_mind, _ as mind_key) env =
  let new_inds = Mindmap_env.add kn mind_key env.env_globals.env_inductives in
  let new_globals =
    { env.env_globals with
        env_inductives = new_inds; } in
  { env with env_globals = new_globals }

let add_mind kn mib env =
  let li = ref no_link_info in add_mind_key kn (mib, li) env

(* Lookup of section variables *)

let lookup_constant_variables c env =
  let cmap = lookup_constant c env in
  Context.Named.to_vars cmap.const_hyps

let lookup_inductive_variables (kn,_i) env =
  let mis = lookup_mind kn env in
  Context.Named.to_vars mis.mind_hyps

let lookup_constructor_variables (ind,_) env =
  lookup_inductive_variables ind env

(* Universes *)
let constant_context env c =
  let cb = lookup_constant c env in
  Declareops.constant_polymorphic_context cb

let universes_of_global env r =
  let open GlobRef in
    match r with
    | VarRef _ -&gt; Univ.AUContext.empty
    | ConstRef c -&gt; constant_context env c
    | IndRef (mind,_) | ConstructRef ((mind,_),_) -&gt;
      let mib = lookup_mind mind env in
      Declareops.inductive_polymorphic_context mib

(* Returns the list of global variables in a term *)

let vars_of_global env gr =
  let open GlobRef in
  match gr with
  | VarRef id -&gt; Id.Set.singleton id
  | ConstRef kn -&gt; lookup_constant_variables kn env
  | IndRef ind -&gt; lookup_inductive_variables ind env
  | ConstructRef cstr -&gt; lookup_constructor_variables cstr env

let global_vars_set env constr =
  let rec filtrec acc c =
    match destRef c with
    | gr, _ -&gt;
      Id.Set.union (vars_of_global env gr) acc
    | exception <abbr class="mark-warning" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">DestKO</abbr> -&gt; Constr.fold filtrec acc c
  in
  filtrec Id.Set.empty constr


(* [keep_hyps env ids] keeps the part of the section context of [env] which
   contains the variables of the set [ids], and recursively the variables
   contained in the types of the needed variables. *)

let really_needed env needed =
  let open! Context.Named.Declaration in
  Context.Named.fold_inside
    (fun need decl -&gt;
      if Id.Set.mem (get_id decl) need then
        let globc =
          match decl with
            | LocalAssum _ -&gt; Id.Set.empty
            | LocalDef (_,c,_) -&gt; global_vars_set env c in
        Id.Set.union
          (global_vars_set env (get_type decl))
          (Id.Set.union globc need)
      else need)
    ~init:needed
    (named_context env)

let keep_hyps env needed =
  let open Context.Named.Declaration in
  let really_needed = really_needed env needed in
  Context.Named.fold_outside
    (fun d nsign -&gt;
      if Id.Set.mem (get_id d) really_needed then Context.Named.add d nsign
      else nsign)
    (named_context env)
    ~init:empty_named_context

(* Modules *)

let add_modtype mtb env =
  let mp = mtb.mod_mp in
  let new_modtypes = MPmap.add mp mtb env.env_globals.env_modtypes in
  let new_globals = { env.env_globals with env_modtypes = new_modtypes } in
  { env with env_globals = new_globals }

let shallow_add_module mb env =
  let mp = mb.mod_mp in
  let new_mods = MPmap.add mp mb env.env_globals.env_modules in
  let new_globals = { env.env_globals with env_modules = new_mods } in
  { env with env_globals = new_globals }

let lookup_module mp env =
    MPmap.find mp env.env_globals.env_modules


let lookup_modtype mp env =
  MPmap.find mp env.env_globals.env_modtypes

(*s Judgments. *)

type ('constr, 'types) punsafe_judgment = {
  uj_val : 'constr;
  uj_type : 'types }

let on_judgment f j = { uj_val = f j.uj_val; uj_type = f j.uj_type }
let on_judgment_value f j = { j with uj_val = f j.uj_val }
let on_judgment_type f j = { j with uj_type = f j.uj_type }

type unsafe_judgment = (constr, types) punsafe_judgment

let make_judge v tj =
  { uj_val = v;
    uj_type = tj }

let j_val j = j.uj_val
let j_type j = j.uj_type

type 'types punsafe_type_judgment = {
  utj_val : 'types;
  utj_type : Sorts.t }

type unsafe_type_judgment = types punsafe_type_judgment

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception Hyp_not_found</abbr>

let apply_to_hyp ctxt id f =
  let open Context.Named.Declaration in
  let rec aux rtail ctxt =
    match match_named_context_val ctxt with
    | Some (d, v, ctxt) -&gt;
        if Id.equal (get_id d) id then
          push_named_context_val_val (f ctxt.env_named_ctx d rtail) v ctxt
        else
          let ctxt' = aux (d::rtail) ctxt in
          push_named_context_val_val d v ctxt'
    | None -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Hyp_not_found</abbr>
  in aux [] ctxt

(* To be used in Logic.clear_hyps *)
let remove_hyps ids check_context check_value ctxt =
  let rec remove_hyps ctxt = match match_named_context_val ctxt with
  | None -&gt; empty_named_context_val, false
  | Some (d, v, rctxt) -&gt;
     let open Context.Named.Declaration in
    let (ans, seen) = remove_hyps rctxt in
    if Id.Set.mem (get_id d) ids then (ans, true)
    else if not seen then ctxt, false
    else
      let rctxt' = ans in
      let d' = check_context d in
      let v' = check_value v in
      if d == d' &amp;&amp; v == v' &amp;&amp; rctxt == rctxt' then
        ctxt, true
      else push_named_context_val_val d' v' rctxt', true
  in
  fst (remove_hyps ctxt)

(* A general request *)

let is_polymorphic env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef c -&gt; polymorphic_constant c env
  | IndRef ind -&gt; polymorphic_ind ind env
  | ConstructRef cstr -&gt; polymorphic_ind (inductive_of_constructor cstr) env

let is_template_polymorphic env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef _c -&gt; false
  | IndRef ind -&gt; template_polymorphic_ind ind env
  | ConstructRef cstr -&gt; template_polymorphic_ind (inductive_of_constructor cstr) env

let get_template_polymorphic_variables env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; []
  | ConstRef _c -&gt; []
  | IndRef ind -&gt; template_polymorphic_variables ind env
  | ConstructRef cstr -&gt; template_polymorphic_variables (inductive_of_constructor cstr) env

let is_template_checked env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef _c -&gt; false
  | IndRef ind -&gt; template_checked_ind ind env
  | ConstructRef cstr -&gt; template_checked_ind (inductive_of_constructor cstr) env

let is_type_in_type env r =
  let open Names.GlobRef in
  match r with
  | VarRef _id -&gt; false
  | ConstRef c -&gt; type_in_type_constant c env
  | IndRef ind -&gt; type_in_type_ind ind env
  | ConstructRef cstr -&gt; type_in_type_ind (inductive_of_constructor cstr) env

let set_retroknowledge env r = { env with retroknowledge = r }
</pre>
  </div>
  <div class="col-md-6">
    <a href="#environ.ml"><code>Environ.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Util.

Import Names.

Import Constr.

Import Vars.

Import Declarations.

Import Context.Rel.Declaration.

Module NamedDecl := Context.Named.Declaration.

Definition key := Stdlib.ref (option (CEphemeron.key Z)).

Inductive link_info : Set :=
| Linked : string -&gt; link_info
| LinkedInteractive : string -&gt; link_info
| NotLinked : link_info.

Definition constant_key :=
  Declarations.constant_body * (Stdlib.ref link_info * key).

Definition mind_key :=
  Declarations.mutual_inductive_body * Stdlib.ref link_info.

Module globals.
  Record record := {
    env_constants : Names.Cmap_env.t constant_key;
    env_inductives : Names.Mindmap_env.t mind_key;
    env_modules : Names.MPmap.t Declarations.module_body;
    env_modtypes : Names.MPmap.t Declarations.module_type_body }.
  Definition with_env_constants (r : record) env_constants : record :=
    {| env_constants := env_constants; env_inductives := env_inductives r;
      env_modules := env_modules r; env_modtypes := env_modtypes r |}.
  Definition with_env_inductives (r : record) env_inductives : record :=
    {| env_constants := env_constants r; env_inductives := env_inductives;
      env_modules := env_modules r; env_modtypes := env_modtypes r |}.
  Definition with_env_modules (r : record) env_modules : record :=
    {| env_constants := env_constants r; env_inductives := env_inductives r;
      env_modules := env_modules; env_modtypes := env_modtypes r |}.
  Definition with_env_modtypes (r : record) env_modtypes : record :=
    {| env_constants := env_constants r; env_inductives := env_inductives r;
      env_modules := env_modules r; env_modtypes := env_modtypes |}.
End globals.
Definition globals := globals.record.

Module stratification.
  Record record := {
    env_universes : UGraph.t;
    env_sprop_allowed : bool;
    env_universes_lbound : Univ.Level.t;
    env_engagement : Declarations.engagement }.
  Definition with_env_universes (r : record) env_universes : record :=
    {| env_universes := env_universes; env_sprop_allowed := env_sprop_allowed r;
      env_universes_lbound := env_universes_lbound r;
      env_engagement := env_engagement r |}.
  Definition with_env_sprop_allowed (r : record) env_sprop_allowed : record :=
    {| env_universes := env_universes r; env_sprop_allowed := env_sprop_allowed;
      env_universes_lbound := env_universes_lbound r;
      env_engagement := env_engagement r |}.
  Definition with_env_universes_lbound (r : record) env_universes_lbound
    : record :=
    {| env_universes := env_universes r;
      env_sprop_allowed := env_sprop_allowed r;
      env_universes_lbound := env_universes_lbound;
      env_engagement := env_engagement r |}.
  Definition with_env_engagement (r : record) env_engagement : record :=
    {| env_universes := env_universes r;
      env_sprop_allowed := env_sprop_allowed r;
      env_universes_lbound := env_universes_lbound r;
      env_engagement := env_engagement |}.
End stratification.
Definition stratification := stratification.record.

Inductive val_kind : Set :=
| VKvalue : CEphemeron.key (Vmvalues.values * Names.Id.__Set.t) -&gt; val_kind
| VKnone : val_kind.

Definition lazy_val := Stdlib.ref val_kind.

Definition force_lazy_val (vk : Stdlib.ref val_kind)
  : option (Vmvalues.values * Names.Id.__Set.t) :=
  match Stdlib.op_exclamation vk with
  | VKnone =&gt; None
  | VKvalue v =&gt;
    (* ❌ Try-with are not handled *)
    try (Some (CEphemeron.get v))
  end.

Definition dummy_lazy_val (function_parameter : unit) : Stdlib.ref val_kind :=
  let '_ := function_parameter in
  Stdlib.__ref_value VKnone.

Definition build_lazy_val
  (vk : Stdlib.ref val_kind) (key : Vmvalues.values * Names.Id.__Set.t)
  : unit := Stdlib.op_coloneq vk (VKvalue (CEphemeron.create key)).

Module named_context_val.
  Record record := {
    env_named_ctx : Constr.named_context;
    env_named_map : Names.Id.Map.t (Constr.named_declaration * lazy_val) }.
  Definition with_env_named_ctx (r : record) env_named_ctx : record :=
    {| env_named_ctx := env_named_ctx; env_named_map := env_named_map r |}.
  Definition with_env_named_map (r : record) env_named_map : record :=
    {| env_named_ctx := env_named_ctx r; env_named_map := env_named_map |}.
End named_context_val.
Definition named_context_val := named_context_val.record.

Module rel_context_val.
  Record record := {
    env_rel_ctx : Constr.rel_context;
    env_rel_map : Range.t (Constr.rel_declaration * lazy_val) }.
  Definition with_env_rel_ctx (r : record) env_rel_ctx : record :=
    {| env_rel_ctx := env_rel_ctx; env_rel_map := env_rel_map r |}.
  Definition with_env_rel_map (r : record) env_rel_map : record :=
    {| env_rel_ctx := env_rel_ctx r; env_rel_map := env_rel_map |}.
End rel_context_val.
Definition rel_context_val := rel_context_val.record.

Module env.
  Record record := {
    env_globals : globals;
    env_named_context : named_context_val;
    env_rel_context : rel_context_val;
    env_nb_rel : Z;
    env_stratification : stratification;
    env_typing_flags : Declarations.typing_flags;
    retroknowledge : Retroknowledge.retroknowledge;
    indirect_pterms : Opaqueproof.opaquetab }.
  Definition with_env_globals (r : record) env_globals : record :=
    {| env_globals := env_globals; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_named_context (r : record) env_named_context : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_rel_context (r : record) env_rel_context : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_nb_rel (r : record) env_nb_rel : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_stratification (r : record) env_stratification : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_typing_flags (r : record) env_typing_flags : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags; retroknowledge := retroknowledge r;
      indirect_pterms := indirect_pterms r |}.
  Definition with_retroknowledge (r : record) retroknowledge : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r; retroknowledge := retroknowledge;
      indirect_pterms := indirect_pterms r |}.
  Definition with_indirect_pterms (r : record) indirect_pterms : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms |}.
End env.
Definition env := env.record.

Definition empty_named_context_val : named_context_val :=
  {| named_context_val.env_named_ctx := [];
    named_context_val.env_named_map := Id.Map.empty |}.

Definition empty_rel_context_val : rel_context_val :=
  {| rel_context_val.env_rel_ctx := [];
    rel_context_val.env_rel_map := Range.empty |}.

Definition empty_env : env :=
  {|
    env.env_globals :=
      {| globals.env_constants := Cmap_env.empty;
        globals.env_inductives := Mindmap_env.empty;
        globals.env_modules := MPmap.empty; globals.env_modtypes := MPmap.empty
        |}; env.env_named_context := empty_named_context_val;
    env.env_rel_context := empty_rel_context_val; env.env_nb_rel := 0;
    env.env_stratification :=
      {| stratification.env_universes := UGraph.initial_universes;
        stratification.env_sprop_allowed := false;
        stratification.env_universes_lbound := Univ.Level.set;
        stratification.env_engagement := Declarations.PredicativeSet |};
    env.env_typing_flags := Declareops.safe_flags Conv_oracle.empty;
    env.retroknowledge := Retroknowledge.empty;
    env.indirect_pterms := Opaqueproof.empty_opaquetab |}.

Definition push_rel_context_val
  (d : Constr.rel_declaration) (ctx : rel_context_val) : rel_context_val :=
  {|
    rel_context_val.env_rel_ctx :=
      Context.Rel.add d (rel_context_val.env_rel_ctx ctx);
    rel_context_val.env_rel_map :=
      Range.cons (d, (Stdlib.__ref_value VKnone))
        (rel_context_val.env_rel_map ctx) |}.

Definition match_rel_context_val (ctx : rel_context_val)
  : option (Constr.rel_declaration * lazy_val * rel_context_val) :=
  match rel_context_val.env_rel_ctx ctx with
  | [] =&gt; None
  | cons decl rem =&gt;
    let '(_, lval) := Range.hd (rel_context_val.env_rel_map ctx) in
    let ctx :=
      {| rel_context_val.env_rel_ctx := rem;
        rel_context_val.env_rel_map :=
          Range.tl (rel_context_val.env_rel_map ctx) |} in
    Some (decl, lval, ctx)
  end.

Definition push_rel (d : Constr.rel_declaration) (env : env) : env :=
  env.with_env_nb_rel
    (env.with_env_rel_context env
      (push_rel_context_val d (env.env_rel_context env)))
    (Z.add (env.env_nb_rel env) 1).

Definition lookup_rel (n : Z) (env : env) : Constr.rel_declaration :=
  (* ❌ Try-with are not handled *)
  try
    (fst
      (Range.get (rel_context_val.env_rel_map (env.env_rel_context env))
        (Z.sub n 1))).

Definition lookup_rel_val (n : Z) (env : env) : lazy_val :=
  (* ❌ Try-with are not handled *)
  try
    (snd
      (Range.get (rel_context_val.env_rel_map (env.env_rel_context env))
        (Z.sub n 1))).

Definition rel_skipn (n : Z) (ctx : rel_context_val) : rel_context_val :=
  {|
    rel_context_val.env_rel_ctx :=
      (|Util.List|).(CList.ExtS.skipn) n (rel_context_val.env_rel_ctx ctx);
    rel_context_val.env_rel_map :=
      Range.skipn n (rel_context_val.env_rel_map ctx) |}.

Definition env_of_rel (n : Z) (env : env) : env :=
  env.with_env_nb_rel
    (env.with_env_rel_context env (rel_skipn n (env.env_rel_context env)))
    (Z.sub (env.env_nb_rel env) n).

Definition push_named_context_val_val
  (d : NamedDecl.pt Constr.constr Constr.types) (rval : lazy_val)
  (ctxt : named_context_val) : named_context_val :=
  {|
    named_context_val.env_named_ctx :=
      Context.Named.add d (named_context_val.env_named_ctx ctxt);
    named_context_val.env_named_map :=
      Id.Map.add (NamedDecl.get_id d) (d, rval)
        (named_context_val.env_named_map ctxt) |}.

Definition push_named_context_val
  (d : NamedDecl.pt Constr.constr Constr.types) (ctxt : named_context_val)
  : named_context_val :=
  push_named_context_val_val d (Stdlib.__ref_value VKnone) ctxt.

Definition match_named_context_val (c : named_context_val)
  : option (Constr.named_declaration * lazy_val * named_context_val) :=
  match named_context_val.env_named_ctx c with
  | [] =&gt; None
  | cons decl ctx =&gt;
    let '(_, v) :=
      Id.Map.find (NamedDecl.get_id decl) (named_context_val.env_named_map c) in
    let map :=
      Id.Map.remove (NamedDecl.get_id decl) (named_context_val.env_named_map c)
      in
    let cval :=
      {| named_context_val.env_named_ctx := ctx;
        named_context_val.env_named_map := map |} in
    Some (decl, v, cval)
  end.

Definition map_named_val
  (f : Constr.constr -&gt; Constr.constr) (ctxt : named_context_val)
  : named_context_val :=
  let fold {A : Set}
    (accu :
      Names.Id.Map.t
        (Context.Named.Declaration.pt Constr.constr Constr.constr * A))
    (d : Context.Named.Declaration.pt Constr.constr Constr.constr)
    : Names.Id.Map.t
      (Context.Named.Declaration.pt Constr.constr Constr.constr * A) *
      Context.Named.Declaration.pt Constr.constr Constr.constr :=
    let d' := map_constr f d in
    let accu :=
      if Stdlib.op_eqeq d d' then
        accu
      else
        Id.Map.modify (get_id d)
          (fun function_parameter =&gt;
            let '_ := function_parameter in
            fun function_parameter =&gt;
              let '(_, v) := function_parameter in
              (d', v)) accu in
    (accu, d') in
  let '(map, ctx) :=
    (|Util.List|).(CList.ExtS.fold_left_map) fold
      (named_context_val.env_named_map ctxt)
      (named_context_val.env_named_ctx ctxt) in
  if Stdlib.op_eqeq map (named_context_val.env_named_map ctxt) then
    ctxt
  else
    {| named_context_val.env_named_ctx := ctx;
      named_context_val.env_named_map := map |}.

Definition push_named (d : NamedDecl.pt Constr.constr Constr.types) (env : env)
  : env :=
  env.with_env_named_context env
    (push_named_context_val d (env.env_named_context env)).

Definition lookup_named (id : Names.Id.Map.key) (env : env)
  : Constr.named_declaration :=
  fst
    (Id.Map.find id
      (named_context_val.env_named_map (env.env_named_context env))).

Definition lookup_named_val (id : Names.Id.Map.key) (env : env) : lazy_val :=
  snd
    (Id.Map.find id
      (named_context_val.env_named_map (env.env_named_context env))).

Definition lookup_named_ctxt (id : Names.Id.Map.key) (ctxt : named_context_val)
  : Constr.named_declaration :=
  fst (Id.Map.find id (named_context_val.env_named_map ctxt)).

Definition fold_constants {A : Set}
  (f : Names.Cmap_env.key -&gt; Declarations.constant_body -&gt; A -&gt; A) (env : env)
  (acc : A) : A :=
  Cmap_env.fold
    (fun c =&gt;
      fun function_parameter =&gt;
        let '(body, _) := function_parameter in
        fun acc =&gt; f c body acc) (globals.env_constants (env.env_globals env))
    acc.

Definition lookup_constant_key (kn : Names.Cmap_env.key) (env : env)
  : constant_key :=
  Cmap_env.find kn (globals.env_constants (env.env_globals env)).

Definition lookup_constant (kn : Names.Cmap_env.key) (env : env)
  : Declarations.constant_body :=
  fst (Cmap_env.find kn (globals.env_constants (env.env_globals env))).

Definition lookup_mind (kn : Names.Mindmap_env.key) (env : env)
  : Declarations.mutual_inductive_body :=
  fst (Mindmap_env.find kn (globals.env_inductives (env.env_globals env))).

Definition mind_context (env : env) (mind : Names.Mindmap_env.key)
  : Univ.AUContext.t :=
  let mib := lookup_mind mind env in
  Declareops.inductive_polymorphic_context mib.

Definition lookup_mind_key (kn : Names.Mindmap_env.key) (env : env)
  : mind_key :=
  Mindmap_env.find kn (globals.env_inductives (env.env_globals env)).

Definition oracle (env : env) : Conv_oracle.oracle :=
  Declarations.typing_flags.conv_oracle (env.env_typing_flags env).

Definition set_oracle (env : env) (o : Conv_oracle.oracle) : env :=
  let env_typing_flags :=
    Declarations.typing_flags.with_conv_oracle (env.env_typing_flags env) o in
  env.with_env_typing_flags env env_typing_flags.

Definition engagement (env : env) : Declarations.engagement :=
  stratification.env_engagement (env.env_stratification env).

Definition typing_flags (env : env) : Declarations.typing_flags :=
  env.env_typing_flags env.

Definition is_impredicative_set (env : env) : bool :=
  match engagement env with
  | Declarations.ImpredicativeSet =&gt; true
  | _ =&gt; false
  end.

Definition is_impredicative_sort (env : env) (function_parameter : Sorts.t)
  : bool :=
  match function_parameter with
  | Sorts.SProp | Sorts.Prop =&gt; true
  | Sorts.__Set =&gt; is_impredicative_set env
  | Sorts.Type _ =&gt; false
  end.

Definition is_impredicative_univ (env : env) (u : Univ.Universe.t) : bool :=
  is_impredicative_sort env (Sorts.sort_of_univ u).

Definition type_in_type (env : env) : bool :=
  negb (Declarations.typing_flags.check_universes (typing_flags env)).

Definition deactivated_guard (env : env) : bool :=
  negb (Declarations.typing_flags.check_guarded (typing_flags env)).

Definition indices_matter (env : env) : bool :=
  Declarations.typing_flags.indices_matter (env.env_typing_flags env).

Definition check_template (env : env) : bool :=
  Declarations.typing_flags.check_template (env.env_typing_flags env).

Definition universes (env : env) : UGraph.t :=
  stratification.env_universes (env.env_stratification env).

Definition universes_lbound (env : env) : Univ.Level.t :=
  stratification.env_universes_lbound (env.env_stratification env).

Definition set_universes_lbound (env : env) (lbound : Univ.Level.t) : env :=
  let env_stratification :=
    stratification.with_env_universes_lbound (env.env_stratification env) lbound
    in
  env.with_env_stratification env env_stratification.

Definition named_context (env : env) : Constr.named_context :=
  named_context_val.env_named_ctx (env.env_named_context env).

Definition named_context_val (env : env) : named_context_val :=
  env.env_named_context env.

Definition rel_context (env : env) : Constr.rel_context :=
  rel_context_val.env_rel_ctx (env.env_rel_context env).

Definition opaque_tables (env : env) : Opaqueproof.opaquetab :=
  env.indirect_pterms env.

Definition set_opaque_tables
  (env : env) (indirect_pterms : Opaqueproof.opaquetab) : env :=
  env.with_indirect_pterms env indirect_pterms.

Definition empty_context (env : env) : bool :=
  match
    ((rel_context_val.env_rel_ctx (env.env_rel_context env)),
      (named_context_val.env_named_ctx (env.env_named_context env))) with
  | ([], []) =&gt; true
  | _ =&gt; false
  end.

Definition evaluable_rel (n : Z) (env : env) : bool :=
  is_local_def (lookup_rel n env).

Definition nb_rel (env : env) : Z := env.env_nb_rel env.

Definition push_rel_context
  (ctxt : Context.Rel.pt Constr.constr Constr.types) (x : env) : env :=
  Context.Rel.fold_outside push_rel ctxt x.

Definition push_rec_types {A : Set}
  (function_parameter :
    array (Context.binder_annot Names.Name.t) * array Constr.constr * A)
  : env -&gt; env :=
  let '(lna, typarray, _) := function_parameter in
  fun env =&gt;
    let ctxt :=
      (|Util.Array|).(CArray.ExtS.map2_i)
        (fun i =&gt;
          fun na =&gt; fun t =&gt; Context.Rel.Declaration.LocalAssum na (lift i t))
        lna typarray in
    (|Util.Array|).(CArray.ExtS.fold_left)
      (fun e =&gt; fun assum =&gt; push_rel assum e) env ctxt.

Definition fold_rel_context {A : Set}
  (f : env -&gt; Constr.rel_declaration -&gt; A -&gt; A) (env : env) (init : A) : A :=
  let fix fold_right (env : env) {struct env} : A :=
    match match_rel_context_val (env.env_rel_context env) with
    | None =&gt; init
    | Some (rd, _, rc) =&gt;
      let env :=
        env.with_env_nb_rel (env.with_env_rel_context env rc)
          (Z.sub (env.env_nb_rel env) 1) in
      f env rd (fold_right env)
    end in
  fold_right env.

Definition named_context_of_val (c : named_context_val)
  : Constr.named_context := named_context_val.env_named_ctx c.

Definition ids_of_named_context_val (c : named_context_val)
  : Names.Id.__Set.t := Id.Map.domain (named_context_val.env_named_map c).

Definition empty_named_context {A B : Set} : Context.Named.pt A B :=
  Context.Named.empty.

Definition push_named_context
  : list (NamedDecl.pt Constr.constr Constr.types) -&gt; env -&gt; env :=
  (|Util.List|).(CList.ExtS.fold_right) push_named.

Definition val_of_named_context
  (ctxt : list (NamedDecl.pt Constr.constr Constr.types)) : named_context_val :=
  (|Util.List|).(CList.ExtS.fold_right) push_named_context_val ctxt
    empty_named_context_val.

Definition eq_named_context_val
  (c1 : named_context_val) (c2 : named_context_val) : bool :=
  orb (Stdlib.op_eqeq c1 c2)
    (Context.Named.equal Constr.equal (named_context_of_val c1)
      (named_context_of_val c2)).

Definition named_type (id : Names.Id.Map.key) (env : env) : Constr.types :=
  get_type (lookup_named id env).

Definition named_body (id : Names.Id.Map.key) (env : env)
  : option Constr.constr := get_value (lookup_named id env).

Definition evaluable_named (id : Names.Id.Map.key) (env : env) : bool :=
  match named_body id env with
  | Some _ =&gt; true
  | _ =&gt; false
  end.

Definition reset_with_named_context (ctxt : named_context_val) (env : env)
  : env :=
  env.with_env_nb_rel
    (env.with_env_rel_context (env.with_env_named_context env ctxt)
      empty_rel_context_val) 0.

Definition reset_context : env -&gt; env :=
  reset_with_named_context empty_named_context_val.

Definition pop_rel_context (n : Int.t) (env : env) : env :=
  let fix skip (n : Int.t) (ctx : rel_context_val) {struct n}
    : rel_context_val :=
    if Int.equal n 0 then
      ctx
    else
      match match_rel_context_val ctx with
      | None =&gt; invalid_arg None &quot;List.skipn&quot;
      | Some (_, _, ctx) =&gt; skip (Z.pred n) ctx
      end in
  let ctxt := env.env_rel_context env in
  env.with_env_nb_rel (env.with_env_rel_context env (skip n ctxt))
    (Z.sub (env.env_nb_rel env) n).

Definition fold_named_context {A : Set}
  (f : env -&gt; Constr.named_declaration -&gt; A -&gt; A) (env : env) (init : A) : A :=
  let fix fold_right (env : env) {struct env} : A :=
    match match_named_context_val (env.env_named_context env) with
    | None =&gt; init
    | Some (d, _v, rem) =&gt;
      let env := reset_with_named_context rem env in
      f env d (fold_right env)
    end in
  fold_right env.

Definition fold_named_context_reverse {A : Set}
  (f : A -&gt; Context.Named.Declaration.pt Constr.constr Constr.types -&gt; A)
  (init : A) (env : env) : A :=
  Context.Named.fold_inside f init (named_context env).

Definition map_universes (f : UGraph.t -&gt; UGraph.t) (env : env) : env :=
  let s := env.env_stratification env in
  env.with_env_stratification env
    (stratification.with_env_universes s (f (stratification.env_universes s))).

Definition add_constraints (c : Univ.Constraint.t) (env : env) : env :=
  if Univ.Constraint.is_empty c then
    env
  else
    map_universes (UGraph.merge_constraints c) env.

Definition check_constraints (c : Univ.Constraint.t) (env : env) : bool :=
  UGraph.check_constraints c
    (stratification.env_universes (env.env_stratification env)).

Definition push_constraints_to_env {A : Set}
  (function_parameter : A * Univ.Constraint.t) : env -&gt; env :=
  let '(_, univs) := function_parameter in
  fun env =&gt; add_constraints univs env.

Definition add_universes
  (lbound : Univ.Level.t) (strict : bool) (ctx : Univ.UContext.t) (g : UGraph.t)
  : UGraph.t :=
  let g :=
    (|Util.Array|).(CArray.ExtS.fold_left)
      (fun g =&gt; fun v =&gt; UGraph.add_universe v lbound strict g) g
      (Univ.Instance.to_array (Univ.UContext.instance ctx)) in
  UGraph.merge_constraints (Univ.UContext.constraints ctx) g.

Definition push_context (op_staroptstar : option bool)
  : Univ.UContext.t -&gt; env -&gt; env :=
  let strict :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun ctx =&gt;
    fun env =&gt;
      map_universes (add_universes (universes_lbound env) strict ctx) env.

Definition add_universes_set
  (lbound : Univ.Level.t) (strict : bool) (ctx : Univ.ContextSet.t)
  (g : UGraph.t) : UGraph.t :=
  let g :=
    Univ.LSet.fold
      (fun v =&gt;
        fun g =&gt;
          (* ❌ Try-with are not handled *)
          try (UGraph.add_universe v lbound strict g))
      (Univ.ContextSet.levels ctx) g in
  UGraph.merge_constraints (Univ.ContextSet.constraints ctx) g.

Definition push_context_set (op_staroptstar : option bool)
  : Univ.ContextSet.t -&gt; env -&gt; env :=
  let strict :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun ctx =&gt;
    fun env =&gt;
      map_universes (add_universes_set (universes_lbound env) strict ctx) env.

Definition push_subgraph (function_parameter : Univ.LSet.t * Univ.Constraint.t)
  : env -&gt; env :=
  let '(levels, csts) := function_parameter in
  fun env =&gt;
    let lbound := universes_lbound env in
    let add_subgraph (g : UGraph.t) : UGraph.t :=
      let newg :=
        Univ.LSet.fold (fun v =&gt; fun g =&gt; UGraph.add_universe v lbound false g)
          levels g in
      let newg := UGraph.merge_constraints csts newg in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      newg in
    map_universes add_subgraph env.

Definition set_engagement (c : Declarations.engagement) (env : env) : env :=
  env.with_env_stratification env
    (stratification.with_env_engagement (env.env_stratification env) c).

Definition same_flags (function_parameter : Declarations.typing_flags)
  : Declarations.typing_flags -&gt; bool :=
  let '{|
    Declarations.typing_flags.check_guarded := check_guarded;
      Declarations.typing_flags.check_universes := check_universes;
      Declarations.typing_flags.conv_oracle := conv_oracle;
      Declarations.typing_flags.share_reduction := share_reduction;
      Declarations.typing_flags.enable_VM := enable_VM;
      Declarations.typing_flags.enable_native_compiler := enable_native_compiler;
      Declarations.typing_flags.indices_matter := indices_matter;
      Declarations.typing_flags.check_template := check_template
      |} := function_parameter in
  fun alt =&gt;
    andb
      (Stdlib.op_eqeq check_guarded
        (Declarations.typing_flags.check_guarded alt))
      (andb
        (Stdlib.op_eqeq check_universes
          (Declarations.typing_flags.check_universes alt))
        (andb
          (Stdlib.op_eqeq conv_oracle
            (Declarations.typing_flags.conv_oracle alt))
          (andb
            (Stdlib.op_eqeq indices_matter
              (Declarations.typing_flags.indices_matter alt))
            (andb
              (Stdlib.op_eqeq share_reduction
                (Declarations.typing_flags.share_reduction alt))
              (andb
                (Stdlib.op_eqeq enable_VM
                  (Declarations.typing_flags.enable_VM alt))
                (andb
                  (Stdlib.op_eqeq enable_native_compiler
                    (Declarations.typing_flags.enable_native_compiler alt))
                  (Stdlib.op_eqeq check_template
                    (Declarations.typing_flags.check_template alt)))))))).

Definition set_typing_flags (c : Declarations.typing_flags) (env : env) : env :=
  if same_flags (env.env_typing_flags env) c then
    env
  else
    env.with_env_typing_flags env c.

Definition make_sprop_cumulative : env -&gt; env :=
  map_universes UGraph.make_sprop_cumulative.

Definition set_allow_sprop (b : bool) (env : env) : env :=
  env.with_env_stratification env
    (stratification.with_env_sprop_allowed (env.env_stratification env) b).

Definition sprop_allowed (env : env) : bool :=
  stratification.env_sprop_allowed (env.env_stratification env).

Definition no_link_info : link_info := NotLinked.

Definition add_constant_key
  (kn : Names.Cmap_env.key) (cb : Declarations.constant_body)
  (linkinfo : link_info) (env : env) : env :=
  let new_constants :=
    Cmap_env.add kn
      (cb, ((Stdlib.__ref_value linkinfo), (Stdlib.__ref_value None)))
      (globals.env_constants (env.env_globals env)) in
  let new_globals :=
    globals.with_env_constants (env.env_globals env) new_constants in
  env.with_env_globals env new_globals.

Definition add_constant
  (kn : Names.Cmap_env.key) (cb : Declarations.constant_body) (env : env)
  : env := add_constant_key kn cb no_link_info env.

Definition constant_type
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : Constr.constr * Univ.Constraint.t :=
  let '(kn, u) := function_parameter in
  let cb := lookup_constant kn env in
  let uctx := Declareops.constant_polymorphic_context cb in
  let csts := Univ.AUContext.instantiate u uctx in
  ((subst_instance_constr u (Declarations.constant_body.const_type cb)), csts).

Inductive const_evaluation_result : Set :=
| NoBody : const_evaluation_result
| Opaque : const_evaluation_result
| IsPrimitive : CPrimitives.t -&gt; const_evaluation_result.

(* ❌ The definition of exceptions is not handled. *)
(* exception NotEvaluableConst *)

Definition constant_value_and_type
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : option Constr.constr * Constr.constr * Univ.Constraint.t :=
  let '(kn, u) := function_parameter in
  let cb := lookup_constant kn env in
  let uctx := Declareops.constant_polymorphic_context cb in
  let cst := Univ.AUContext.instantiate u uctx in
  let b' :=
    match Declarations.constant_body.const_body cb with
    | Declarations.Def l_body =&gt;
      Some (subst_instance_constr u (Mod_subst.force_constr l_body))
    | Declarations.OpaqueDef _ =&gt; None
    | Declarations.Undef _ | Declarations.Primitive _ =&gt; None
    end in
  (b', (subst_instance_constr u (Declarations.constant_body.const_type cb)), cst).

Definition body_of_constant_body (env : env) (cb : Declarations.constant_body)
  : option (Constr.constr * Univ.AUContext.t) :=
  let otab := opaque_tables env in
  match Declarations.constant_body.const_body cb with
  | Declarations.Undef _ | Declarations.Primitive _ =&gt; None
  | Declarations.Def c =&gt;
    Some
      ((Mod_subst.force_constr c), (Declareops.constant_polymorphic_context cb))
  | Declarations.OpaqueDef o =&gt;
    Some
      ((Opaqueproof.force_proof otab o),
        (Declareops.constant_polymorphic_context cb))
  end.

Definition constant_type_in
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : Constr.constr :=
  let '(kn, u) := function_parameter in
  let cb := lookup_constant kn env in
  subst_instance_constr u (Declarations.constant_body.const_type cb).

Definition constant_value_in
  (env : env) (function_parameter : Names.Cmap_env.key * Univ.Instance.t)
  : Constr.constr :=
  let '(kn, u) := function_parameter in
  let cb := lookup_constant kn env in
  match Declarations.constant_body.const_body cb with
  | Declarations.Def l_body =&gt;
    let b := Mod_subst.force_constr l_body in
    subst_instance_constr u b
  | Declarations.OpaqueDef _ =&gt; Stdlib.raise extensible_type_value
  | Declarations.Undef _ =&gt; Stdlib.raise extensible_type_value
  | Declarations.Primitive p =&gt; Stdlib.raise extensible_type_value
  end.

Definition constant_opt_value_in
  (env : env) (cst : Names.Cmap_env.key * Univ.Instance.t)
  : option Constr.constr :=
  (* ❌ Try-with are not handled *)
  try (Some (constant_value_in env cst)).

Definition evaluable_constant (kn : Names.Cmap_env.key) (env : env) : bool :=
  let cb := lookup_constant kn env in
  match Declarations.constant_body.const_body cb with
  | Declarations.Def _ =&gt; true
  | Declarations.OpaqueDef _ =&gt; false
  | Declarations.Undef _ | Declarations.Primitive _ =&gt; false
  end.

Definition is_primitive (env : env) (c : Names.Cmap_env.key) : bool :=
  let cb := lookup_constant c env in
  match Declarations.constant_body.const_body cb with
  | Declarations.Primitive _ =&gt; true
  | _ =&gt; false
  end.

Definition polymorphic_constant (cst : Names.Cmap_env.key) (env : env) : bool :=
  Declareops.constant_is_polymorphic (lookup_constant cst env).

Definition polymorphic_pconstant
  (function_parameter : Names.Cmap_env.key * Univ.Instance.t) : env -&gt; bool :=
  let '(cst, u) := function_parameter in
  fun env =&gt;
    if Univ.Instance.is_empty u then
      false
    else
      polymorphic_constant cst env.

Definition type_in_type_constant (cst : Names.Cmap_env.key) (env : env)
  : bool :=
  negb
    (Declarations.typing_flags.check_universes
      (Declarations.constant_body.const_typing_flags (lookup_constant cst env))).

Definition lookup_projection (p : Names.Projection.t) (env : env)
  : Constr.types :=
  let '(mind, i) := Projection.inductive p in
  let mib := lookup_mind mind env in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  match Declarations.mutual_inductive_body.mind_record mib with
  | Declarations.NotRecord | Declarations.FakeRecord =&gt;
    anomaly None (Some &quot;lookup_projection&quot;) (str &quot;not a projection&quot;)
  | Declarations.PrimRecord infos =&gt;
    let '(_, _, _, typs) := (|Util.Array|).(CArray.ExtS.get) infos i in
    (|Util.Array|).(CArray.ExtS.get) typs (Projection.arg p)
  end.

Definition get_projection (env : env) (ind : Names.inductive) (proj_arg : Z)
  : option Names.Projection.Repr.t :=
  let mib := lookup_mind (fst ind) env in
  Declareops.inductive_make_projection ind mib proj_arg.

Definition get_projections (env : env) (ind : Names.inductive)
  : option (array Names.Projection.Repr.t) :=
  let mib := lookup_mind (fst ind) env in
  Declareops.inductive_make_projections ind mib.

Definition polymorphic_ind {A : Set}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; bool :=
  let '(mind, _i) := function_parameter in
  fun env =&gt; Declareops.inductive_is_polymorphic (lookup_mind mind env).

Definition polymorphic_pind {A : Set}
  (function_parameter : (Names.Mindmap_env.key * A) * Univ.Instance.t)
  : env -&gt; bool :=
  let '(ind, u) := function_parameter in
  fun env =&gt;
    if Univ.Instance.is_empty u then
      false
    else
      polymorphic_ind ind env.

Definition type_in_type_ind {A : Set}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; bool :=
  let '(mind, _i) := function_parameter in
  fun env =&gt;
    negb
      (Declarations.typing_flags.check_universes
        (Declarations.mutual_inductive_body.mind_typing_flags
          (lookup_mind mind env))).

Definition template_checked_ind {A : Set}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; bool :=
  let '(mind, _i) := function_parameter in
  fun env =&gt;
    Declarations.typing_flags.check_template
      (Declarations.mutual_inductive_body.mind_typing_flags
        (lookup_mind mind env)).

Definition template_polymorphic_ind
  (function_parameter : Names.Mindmap_env.key * Z) : env -&gt; bool :=
  let '(mind, i) := function_parameter in
  fun env =&gt;
    match
      Declarations.one_inductive_body.mind_arity
        ((|Util.Array|).(CArray.ExtS.get)
          (Declarations.mutual_inductive_body.mind_packets
            (lookup_mind mind env)) i) with
    | Declarations.TemplateArity _ =&gt; true
    | Declarations.RegularArity _ =&gt; false
    end.

Definition template_polymorphic_variables
  (function_parameter : Names.Mindmap_env.key * Z) : env -&gt; list Univ.Level.t :=
  let '(mind, i) := function_parameter in
  fun env =&gt;
    match
      Declarations.one_inductive_body.mind_arity
        ((|Util.Array|).(CArray.ExtS.get)
          (Declarations.mutual_inductive_body.mind_packets
            (lookup_mind mind env)) i) with
    |
      Declarations.TemplateArity {|
        Declarations.template_arity.template_param_levels := l |} =&gt;
      (|Util.List|).(CList.ExtS.map_filter) (fun level =&gt; level) l
    | Declarations.RegularArity _ =&gt; []
    end.

Definition template_polymorphic_pind
  (function_parameter : (Names.Mindmap_env.key * Z) * Univ.Instance.t)
  : env -&gt; bool :=
  let '(ind, u) := function_parameter in
  fun env =&gt;
    if negb (Univ.Instance.is_empty u) then
      false
    else
      template_polymorphic_ind ind env.

Definition add_mind_key
  (kn : Names.Mindmap_env.key)
  (function_parameter :
    Declarations.mutual_inductive_body * Stdlib.ref link_info) : env -&gt; env :=
  let '(_mind, _) as mind_key := function_parameter in
  fun env =&gt;
    let new_inds :=
      Mindmap_env.add kn mind_key (globals.env_inductives (env.env_globals env))
      in
    let new_globals :=
      globals.with_env_inductives (env.env_globals env) new_inds in
    env.with_env_globals env new_globals.

Definition add_mind
  (kn : Names.Mindmap_env.key) (mib : Declarations.mutual_inductive_body)
  (env : env) : env :=
  let li := Stdlib.__ref_value no_link_info in
  add_mind_key kn (mib, li) env.

Definition lookup_constant_variables (c : Names.Cmap_env.key) (env : env)
  : Names.Id.__Set.t :=
  let cmap := lookup_constant c env in
  Context.Named.to_vars (Declarations.constant_body.const_hyps cmap).

Definition lookup_inductive_variables {A : Set}
  (function_parameter : Names.Mindmap_env.key * A) : env -&gt; Names.Id.__Set.t :=
  let '(kn, _i) := function_parameter in
  fun env =&gt;
    let mis := lookup_mind kn env in
    Context.Named.to_vars (Declarations.mutual_inductive_body.mind_hyps mis).

Definition lookup_constructor_variables {A B : Set}
  (function_parameter : (Names.Mindmap_env.key * A) * B)
  : env -&gt; Names.Id.__Set.t :=
  let '(ind, _) := function_parameter in
  fun env =&gt; lookup_inductive_variables ind env.

Definition constant_context (env : env) (c : Names.Cmap_env.key)
  : Univ.AUContext.t :=
  let cb := lookup_constant c env in
  Declareops.constant_polymorphic_context cb.

Definition universes_of_global (env : env) (r : Names.GlobRef.t)
  : Univ.AUContext.t :=
  match r with
  | Names.GlobRef.VarRef _ =&gt; Univ.AUContext.empty
  | Names.GlobRef.ConstRef c =&gt; constant_context env c
  | Names.GlobRef.IndRef (mind, _) | Names.GlobRef.ConstructRef ((mind, _), _)
    =&gt;
    let mib := lookup_mind mind env in
    Declareops.inductive_polymorphic_context mib
  end.

Definition vars_of_global (env : env) (gr : Names.GlobRef.t)
  : Names.Id.__Set.t :=
  match gr with
  | Names.GlobRef.VarRef id =&gt; Id.__Set.singleton id
  | Names.GlobRef.ConstRef kn =&gt; lookup_constant_variables kn env
  | Names.GlobRef.IndRef ind =&gt; lookup_inductive_variables ind env
  | Names.GlobRef.ConstructRef cstr =&gt; lookup_constructor_variables cstr env
  end.

Definition global_vars_set (env : env) (constr : Constr.constr)
  : Names.Id.__Set.t :=
  let fix filtrec (acc : Names.Id.__Set.t) (c : Constr.constr) {struct acc}
    : Names.Id.__Set.t :=
    let '(gr, _) := destRef c in
    Id.__Set.union (vars_of_global env gr) acc in
  filtrec Id.__Set.empty constr.

Definition really_needed (env : env) (needed : Names.Id.__Set.t)
  : Names.Id.__Set.t :=
  Context.Named.fold_inside
    (fun need =&gt;
      fun decl =&gt;
        if Id.__Set.mem (get_id decl) need then
          let globc :=
            match decl with
            | Context.Named.Declaration.LocalAssum _ _ =&gt; Id.__Set.empty
            | Context.Named.Declaration.LocalDef _ c _ =&gt; global_vars_set env c
            end in
          Id.__Set.union (global_vars_set env (get_type decl))
            (Id.__Set.union globc need)
        else
          need) needed (named_context env).

Definition keep_hyps (env : env) (needed : Names.Id.__Set.t)
  : Context.Named.pt Constr.constr Constr.types :=
  let really_needed := really_needed env needed in
  Context.Named.fold_outside
    (fun d =&gt;
      fun nsign =&gt;
        if Id.__Set.mem (get_id d) really_needed then
          Context.Named.add d nsign
        else
          nsign) (named_context env) empty_named_context.

Definition add_modtype (mtb : Declarations.module_type_body) (env : env)
  : env :=
  let mp := Declarations.generic_module_body.mod_mp mtb in
  let new_modtypes :=
    MPmap.add mp mtb (globals.env_modtypes (env.env_globals env)) in
  let new_globals :=
    globals.with_env_modtypes (env.env_globals env) new_modtypes in
  env.with_env_globals env new_globals.

Definition shallow_add_module (mb : Declarations.module_body) (env : env)
  : env :=
  let mp := Declarations.generic_module_body.mod_mp mb in
  let new_mods := MPmap.add mp mb (globals.env_modules (env.env_globals env)) in
  let new_globals := globals.with_env_modules (env.env_globals env) new_mods in
  env.with_env_globals env new_globals.

Definition lookup_module (mp : Names.MPmap.key) (env : env)
  : Declarations.module_body :=
  MPmap.find mp (globals.env_modules (env.env_globals env)).

Definition lookup_modtype (mp : Names.MPmap.key) (env : env)
  : Declarations.module_type_body :=
  MPmap.find mp (globals.env_modtypes (env.env_globals env)).

Module punsafe_judgment.
  Record record {constr types : Set} := {
    uj_val : constr;
    uj_type : types }.
  Arguments record : clear implicits.
  Definition with_uj_val {constr_type types_type : Set}
    (r : record constr_type types_type) uj_val
    : record constr_type types_type :=
    {| uj_val := uj_val; uj_type := uj_type r |}.
  Definition with_uj_type {constr_type types_type : Set}
    (r : record constr_type types_type) uj_type
    : record constr_type types_type :=
    {| uj_val := uj_val r; uj_type := uj_type |}.
End punsafe_judgment.
Definition punsafe_judgment := punsafe_judgment.record.

Definition on_judgment {A B : Set} (f : A -&gt; B) (j : punsafe_judgment A A)
  : punsafe_judgment B B :=
  {| punsafe_judgment.uj_val := f (punsafe_judgment.uj_val j);
    punsafe_judgment.uj_type := f (punsafe_judgment.uj_type j) |}.

Definition on_judgment_value {A B C : Set}
  (f : A -&gt; B) (j : punsafe_judgment A C) : punsafe_judgment B C :=
  punsafe_judgment.with_uj_val j (f (punsafe_judgment.uj_val j)).

Definition on_judgment_type {A B C : Set}
  (f : A -&gt; B) (j : punsafe_judgment C A) : punsafe_judgment C B :=
  punsafe_judgment.with_uj_type j (f (punsafe_judgment.uj_type j)).

Definition unsafe_judgment := punsafe_judgment Constr.constr Constr.types.

Definition make_judge {A B : Set} (v : A) (tj : B) : punsafe_judgment A B :=
  {| punsafe_judgment.uj_val := v; punsafe_judgment.uj_type := tj |}.

Definition j_val {A B : Set} (j : punsafe_judgment A B) : A :=
  punsafe_judgment.uj_val j.

Definition j_type {A B : Set} (j : punsafe_judgment A B) : B :=
  punsafe_judgment.uj_type j.

Module punsafe_type_judgment.
  Record record {types : Set} := {
    utj_val : types;
    utj_type : Sorts.t }.
  Arguments record : clear implicits.
  Definition with_utj_val {types_type : Set} (r : record types_type) utj_val
    : record types_type :=
    {| utj_val := utj_val; utj_type := utj_type r |}.
  Definition with_utj_type {types_type : Set} (r : record types_type) utj_type
    : record types_type :=
    {| utj_val := utj_val r; utj_type := utj_type |}.
End punsafe_type_judgment.
Definition punsafe_type_judgment := punsafe_type_judgment.record.

Definition unsafe_type_judgment := punsafe_type_judgment Constr.types.

(* ❌ The definition of exceptions is not handled. *)
(* exception Hyp_not_found *)

Definition apply_to_hyp
  (ctxt : named_context_val) (id : Names.Id.t)
  (f :
    Constr.named_context -&gt; Constr.named_declaration -&gt;
    list Constr.named_declaration -&gt; NamedDecl.pt Constr.constr Constr.types)
  : named_context_val :=
  let fix aux (rtail : list Constr.named_declaration) (ctxt : named_context_val)
    {struct rtail} : named_context_val :=
    match match_named_context_val ctxt with
    | Some (d, v, ctxt) =&gt;
      if Id.equal (get_id d) id then
        push_named_context_val_val
          (f (named_context_val.env_named_ctx ctxt) d rtail) v ctxt
      else
        let ctxt' := aux (cons d rtail) ctxt in
        push_named_context_val_val d v ctxt'
    | None =&gt; Stdlib.raise extensible_type_value
    end in
  aux [] ctxt.

Definition remove_hyps
  (ids : Names.Id.__Set.t)
  (check_context : Constr.named_declaration -&gt; Constr.named_declaration)
  (check_value : lazy_val -&gt; lazy_val) (ctxt : named_context_val)
  : named_context_val :=
  let fix remove_hyps (ctxt : named_context_val) {struct ctxt}
    : named_context_val * bool :=
    match match_named_context_val ctxt with
    | None =&gt; (empty_named_context_val, false)
    | Some (d, v, rctxt) =&gt;
      let '(ans, seen) := remove_hyps rctxt in
      if Id.__Set.mem (get_id d) ids then
        (ans, true)
      else
        if negb seen then
          (ctxt, false)
        else
          let rctxt' := ans in
          let d' := check_context d in
          let v' := check_value v in
          if
            andb (Stdlib.op_eqeq d d')
              (andb (Stdlib.op_eqeq v v') (Stdlib.op_eqeq rctxt rctxt')) then
            (ctxt, true)
          else
            ((push_named_context_val_val d' v' rctxt'), true)
    end in
  fst (remove_hyps ctxt).

Definition is_polymorphic (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | Names.GlobRef.VarRef _id =&gt; false
  | Names.GlobRef.ConstRef c =&gt; polymorphic_constant c env
  | Names.GlobRef.IndRef ind =&gt; polymorphic_ind ind env
  | Names.GlobRef.ConstructRef cstr =&gt;
    polymorphic_ind (inductive_of_constructor cstr) env
  end.

Definition is_template_polymorphic (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | Names.GlobRef.VarRef _id =&gt; false
  | Names.GlobRef.ConstRef _c =&gt; false
  | Names.GlobRef.IndRef ind =&gt; template_polymorphic_ind ind env
  | Names.GlobRef.ConstructRef cstr =&gt;
    template_polymorphic_ind (inductive_of_constructor cstr) env
  end.

Definition get_template_polymorphic_variables (env : env) (r : Names.GlobRef.t)
  : list Univ.Level.t :=
  match r with
  | Names.GlobRef.VarRef _id =&gt; []
  | Names.GlobRef.ConstRef _c =&gt; []
  | Names.GlobRef.IndRef ind =&gt; template_polymorphic_variables ind env
  | Names.GlobRef.ConstructRef cstr =&gt;
    template_polymorphic_variables (inductive_of_constructor cstr) env
  end.

Definition is_template_checked (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | Names.GlobRef.VarRef _id =&gt; false
  | Names.GlobRef.ConstRef _c =&gt; false
  | Names.GlobRef.IndRef ind =&gt; template_checked_ind ind env
  | Names.GlobRef.ConstructRef cstr =&gt;
    template_checked_ind (inductive_of_constructor cstr) env
  end.

Definition is_type_in_type (env : env) (r : Names.GlobRef.t) : bool :=
  match r with
  | Names.GlobRef.VarRef _id =&gt; false
  | Names.GlobRef.ConstRef c =&gt; type_in_type_constant c env
  | Names.GlobRef.IndRef ind =&gt; type_in_type_ind ind env
  | Names.GlobRef.ConstructRef cstr =&gt;
    type_in_type_ind (inductive_of_constructor cstr) env
  end.

Definition set_retroknowledge (env : env) (r : Retroknowledge.retroknowledge)
  : env := env.with_retroknowledge env r.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="environ.mli">
  <div style="margin: 20px;">
    <h3>Environ_mli</h3>
    <ul>
      <li>OCaml size: 367 lines</li>
      <li>Coq size: 464 lines (+26% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#environ.mli"><code>environ.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Univ
open Declarations

(** Unsafe environments. We define here a datatype for environments.
   Since typing is not yet defined, it is not possible to check the
   informations added in environments, and that is why we speak here
   of ``unsafe'' environments. *)

(** Environments have the following components:
   - a context for de Bruijn variables
   - a context for de Bruijn variables vm values
   - a context for section variables and goal assumptions
   - a context for section variables and goal assumptions vm values
   - a context for global constants and axioms
   - a context for inductive definitions
   - a set of universe constraints
   - a flag telling if Set is, can be, or cannot be set impredicative *)

type lazy_val

val build_lazy_val : lazy_val -&gt; (Vmvalues.values * Id.Set.t) -&gt; unit
val force_lazy_val : lazy_val -&gt; (Vmvalues.values * Id.Set.t) option
val dummy_lazy_val : unit -&gt; lazy_val

(** Linking information for the native compiler *)
type link_info =
  | Linked of string
  | LinkedInteractive of string
  | NotLinked

type key = int CEphemeron.key option ref

type constant_key = constant_body * (link_info ref * key)

type mind_key = mutual_inductive_body * link_info ref

type globals
(** globals = constants + projections + inductive types + modules + module-types *)

type stratification = {
  env_universes : UGraph.t;
  env_sprop_allowed : bool;
  env_universes_lbound : Univ.Level.t;
  env_engagement : engagement
}

type named_context_val = private {
  env_named_ctx : Constr.named_context;
  env_named_map : (Constr.named_declaration * lazy_val) Id.Map.t;
}

type rel_context_val = private {
  env_rel_ctx : Constr.rel_context;
  env_rel_map : (Constr.rel_declaration * lazy_val) Range.t;
}

type env = private {
  env_globals       : globals;
  env_named_context : named_context_val; (* section variables *)
  env_rel_context   : rel_context_val;
  env_nb_rel        : int;
  env_stratification : stratification;
  env_typing_flags  : typing_flags;
  retroknowledge : Retroknowledge.retroknowledge;
  indirect_pterms : Opaqueproof.opaquetab;
}

val oracle : env -&gt; Conv_oracle.oracle
val set_oracle : env -&gt; Conv_oracle.oracle -&gt; env

val eq_named_context_val : named_context_val -&gt; named_context_val -&gt; bool

val empty_env : env

val universes     : env -&gt; UGraph.t
val universes_lbound : env -&gt; Univ.Level.t
val set_universes_lbound : env -&gt; Univ.Level.t -&gt; env
val rel_context   : env -&gt; Constr.rel_context
val named_context : env -&gt; Constr.named_context
val named_context_val : env -&gt; named_context_val

val opaque_tables : env -&gt; Opaqueproof.opaquetab
val set_opaque_tables : env -&gt; Opaqueproof.opaquetab -&gt; env


val engagement    : env -&gt; engagement
val typing_flags    : env -&gt; typing_flags
val is_impredicative_set : env -&gt; bool
val type_in_type : env -&gt; bool
val deactivated_guard : env -&gt; bool
val indices_matter : env -&gt; bool
val check_template : env -&gt; bool

val is_impredicative_sort : env -&gt; Sorts.t -&gt; bool
val is_impredicative_univ : env -&gt; Univ.Universe.t -&gt; bool

(** is the local context empty *)
val empty_context : env -&gt; bool

(** {5 Context of de Bruijn variables ([rel_context]) } *)

val nb_rel           : env -&gt; int
val push_rel         : Constr.rel_declaration -&gt; env -&gt; env
val push_rel_context : Constr.rel_context -&gt; env -&gt; env
val push_rec_types   : rec_declaration -&gt; env -&gt; env

(** Looks up in the context of local vars referred by indice ([rel_context])
   raises [Not_found] if the index points out of the context *)
val lookup_rel    : int -&gt; env -&gt; Constr.rel_declaration
val lookup_rel_val : int -&gt; env -&gt; lazy_val
val evaluable_rel : int -&gt; env -&gt; bool
val env_of_rel     : int -&gt; env -&gt; env

(** {6 Recurrence on [rel_context] } *)

val fold_rel_context :
  (env -&gt; Constr.rel_declaration -&gt; 'a -&gt; 'a) -&gt; env -&gt; init:'a -&gt; 'a

(** {5 Context of variables (section variables and goal assumptions) } *)

val named_context_of_val : named_context_val -&gt; Constr.named_context
val val_of_named_context : Constr.named_context -&gt; named_context_val
val empty_named_context_val : named_context_val
val ids_of_named_context_val : named_context_val -&gt; Id.Set.t


(** [map_named_val f ctxt] apply [f] to the body and the type of
   each declarations.
   *** /!\ ***   [f t] should be convertible with t *)
val map_named_val :
   (constr -&gt; constr) -&gt; named_context_val -&gt; named_context_val

val push_named : Constr.named_declaration -&gt; env -&gt; env
val push_named_context : Constr.named_context -&gt; env -&gt; env
val push_named_context_val  :
    Constr.named_declaration -&gt; named_context_val -&gt; named_context_val



(** Looks up in the context of local vars referred by names ([named_context])
   raises [Not_found] if the Id.t is not found *)

val lookup_named     : variable -&gt; env -&gt; Constr.named_declaration
val lookup_named_val : variable -&gt; env -&gt; lazy_val
val lookup_named_ctxt : variable -&gt; named_context_val -&gt; Constr.named_declaration
val evaluable_named  : variable -&gt; env -&gt; bool
val named_type : variable -&gt; env -&gt; types
val named_body : variable -&gt; env -&gt; constr option

(** {6 Recurrence on [named_context]: older declarations processed first } *)

val fold_named_context :
  (env -&gt; Constr.named_declaration -&gt; 'a -&gt; 'a) -&gt; env -&gt; init:'a -&gt; 'a

(** Recurrence on [named_context] starting from younger decl *)
val fold_named_context_reverse :
  ('a -&gt; Constr.named_declaration -&gt; 'a) -&gt; init:'a -&gt; env -&gt; 'a

(** This forgets named and rel contexts *)
val reset_context : env -&gt; env

(** This forgets rel context and sets a new named context *)
val reset_with_named_context : named_context_val -&gt; env -&gt; env

(** This removes the [n] last declarations from the rel context *)
val pop_rel_context : int -&gt; env -&gt; env

(** Useful for printing *)
val fold_constants : (Constant.t -&gt; constant_body -&gt; 'a -&gt; 'a) -&gt; env -&gt; 'a -&gt; 'a

(** {5 Global constants }
  {6 Add entries to global environment } *)

val add_constant : Constant.t -&gt; constant_body -&gt; env -&gt; env
val add_constant_key : Constant.t -&gt; constant_body -&gt; link_info -&gt;
  env -&gt; env
val lookup_constant_key :  Constant.t -&gt; env -&gt; constant_key

(** Looks up in the context of global constant names
   raises [Not_found] if the required path is not found *)
val lookup_constant    : Constant.t -&gt; env -&gt; constant_body
val evaluable_constant : Constant.t -&gt; env -&gt; bool

(** New-style polymorphism *)
val polymorphic_constant  : Constant.t -&gt; env -&gt; bool
val polymorphic_pconstant : pconstant -&gt; env -&gt; bool
val type_in_type_constant : Constant.t -&gt; env -&gt; bool

(** {6 ... } *)
(** [constant_value env c] raises [NotEvaluableConst Opaque] if
   [c] is opaque, [NotEvaluableConst NoBody] if it has no
   body, [NotEvaluableConst IsProj] if [c] is a projection,
   [NotEvaluableConst (IsPrimitive p)] if [c] is primitive [p]
   and [Not_found] if it does not exist in [env] *)

type const_evaluation_result =
  | NoBody
  | Opaque
  | IsPrimitive of CPrimitives.t
<abbr class="mark-warning" title="Signature item `exception` not handled">exception NotEvaluableConst of const_evaluation_result</abbr>

val constant_type : env -&gt; Constant.t puniverses -&gt; types constrained

val constant_value_and_type : env -&gt; Constant.t puniverses -&gt;
  constr option * types * Univ.Constraint.t
(** The universe context associated to the constant, empty if not
    polymorphic *)
val constant_context : env -&gt; Constant.t -&gt; Univ.AUContext.t

(** Returns the body of the constant if it has any, and the polymorphic context
    it lives in. For monomorphic constant, the latter is empty, and for
    polymorphic constants, the term contains De Bruijn universe variables that
    need to be instantiated. *)
val body_of_constant_body : env -&gt; constant_body -&gt; (Constr.constr * Univ.AUContext.t) option

(* These functions should be called under the invariant that [env]
   already contains the constraints corresponding to the constant
   application. *)
val constant_value_in : env -&gt; Constant.t puniverses -&gt; constr
val constant_type_in : env -&gt; Constant.t puniverses -&gt; types
val constant_opt_value_in : env -&gt; Constant.t puniverses -&gt; constr option

val is_primitive : env -&gt; Constant.t -&gt; bool

(** {6 Primitive projections} *)

(** Checks that the number of parameters is correct. *)
val lookup_projection : Names.Projection.t -&gt; env -&gt; types

val get_projection : env -&gt; inductive -&gt; proj_arg:int -&gt; Names.Projection.Repr.t option
val get_projections : env -&gt; inductive -&gt; Names.Projection.Repr.t array option

(** {5 Inductive types } *)
val lookup_mind_key : MutInd.t -&gt; env -&gt; mind_key
val add_mind_key : MutInd.t -&gt; mind_key -&gt; env -&gt; env
val add_mind : MutInd.t -&gt; mutual_inductive_body -&gt; env -&gt; env

(** Looks up in the context of global inductive names
   raises [Not_found] if the required path is not found *)
val lookup_mind : MutInd.t -&gt; env -&gt; mutual_inductive_body

(** The universe context associated to the inductive, empty if not
    polymorphic *)
val mind_context : env -&gt; MutInd.t -&gt; Univ.AUContext.t

(** New-style polymorphism *)
val polymorphic_ind  : inductive -&gt; env -&gt; bool
val polymorphic_pind : pinductive -&gt; env -&gt; bool
val type_in_type_ind : inductive -&gt; env -&gt; bool

(** Old-style polymorphism *)
val template_polymorphic_ind : inductive -&gt; env -&gt; bool
val template_polymorphic_variables : inductive -&gt; env -&gt; Univ.Level.t list
val template_polymorphic_pind : pinductive -&gt; env -&gt; bool
val template_checked_ind : inductive -&gt; env -&gt; bool

(** {5 Modules } *)

val add_modtype : module_type_body -&gt; env -&gt; env

(** [shallow_add_module] does not add module components *)
val shallow_add_module : module_body -&gt; env -&gt; env

val lookup_module : ModPath.t -&gt; env -&gt; module_body
val lookup_modtype : ModPath.t -&gt; env -&gt; module_type_body

(** {5 Universe constraints } *)

(** Add universe constraints to the environment.
    @raise UniverseInconsistency .
*)
val add_constraints : Univ.Constraint.t -&gt; env -&gt; env

(** Check constraints are satifiable in the environment. *)
val check_constraints : Univ.Constraint.t -&gt; env -&gt; bool
val push_context : ?strict:bool -&gt; Univ.UContext.t -&gt; env -&gt; env
val push_context_set : ?strict:bool -&gt; Univ.ContextSet.t -&gt; env -&gt; env
val push_constraints_to_env : 'a Univ.constrained -&gt; env -&gt; env

val push_subgraph : Univ.ContextSet.t -&gt; env -&gt; env
(** [push_subgraph univs env] adds the universes and constraints in
   [univs] to [env] as [push_context_set ~strict:false univs env], and
   also checks that they do not imply new transitive constraints
   between pre-existing universes in [env]. *)

val set_engagement : engagement -&gt; env -&gt; env
val set_typing_flags : typing_flags -&gt; env -&gt; env
val make_sprop_cumulative : env -&gt; env
val set_allow_sprop : bool -&gt; env -&gt; env
val sprop_allowed : env -&gt; bool

val universes_of_global : env -&gt; GlobRef.t -&gt; AUContext.t

(** {6 Sets of referred section variables }
   [global_vars_set env c] returns the list of [id]'s occurring either
   directly as [Var id] in [c] or indirectly as a section variable
   dependent in a global reference occurring in [c] *)

val global_vars_set : env -&gt; constr -&gt; Id.Set.t

val vars_of_global : env -&gt; GlobRef.t -&gt; Id.Set.t

(** closure of the input id set w.r.t. dependency *)
val really_needed : env -&gt; Id.Set.t -&gt; Id.Set.t

(** like [really_needed] but computes a well ordered named context *)
val keep_hyps : env -&gt; Id.Set.t -&gt; Constr.named_context

(** {5 Unsafe judgments. }
    We introduce here the pre-type of judgments, which is
  actually only a datatype to store a term with its type and the type of its
  type. *)

type ('constr, 'types) punsafe_judgment = {
  uj_val : 'constr;
  uj_type : 'types }

val on_judgment       : ('a -&gt; 'b) -&gt; ('a, 'a) punsafe_judgment -&gt; ('b, 'b) punsafe_judgment
val on_judgment_value : ('c -&gt; 'c) -&gt; ('c, 't) punsafe_judgment -&gt; ('c, 't) punsafe_judgment
val on_judgment_type  : ('t -&gt; 't) -&gt; ('c, 't) punsafe_judgment -&gt; ('c, 't) punsafe_judgment

type unsafe_judgment = (constr, types) punsafe_judgment

val make_judge : 'constr -&gt; 'types -&gt; ('constr, 'types) punsafe_judgment
val j_val  : ('constr, 'types) punsafe_judgment -&gt; 'constr
val j_type : ('constr, 'types) punsafe_judgment -&gt; 'types

type 'types punsafe_type_judgment = {
  utj_val : 'types;
  utj_type : Sorts.t }

type unsafe_type_judgment = types punsafe_type_judgment

<abbr class="mark-warning" title="Signature item `exception` not handled">exception Hyp_not_found</abbr>

(** [apply_to_hyp sign id f] split [sign] into [tail::(id,_,_)::head] and
   return [tail::(f head (id,_,_) (rev tail))::head].
   the value associated to id should not change *)
val apply_to_hyp : named_context_val -&gt; variable -&gt;
  (Constr.named_context -&gt; Constr.named_declaration -&gt; Constr.named_context -&gt; Constr.named_declaration) -&gt;
    named_context_val

val remove_hyps : Id.Set.t -&gt; (Constr.named_declaration -&gt; Constr.named_declaration) -&gt; (lazy_val -&gt; lazy_val) -&gt; named_context_val -&gt; named_context_val

val is_polymorphic : env -&gt; Names.GlobRef.t -&gt; bool
val is_template_polymorphic : env -&gt; GlobRef.t -&gt; bool
val get_template_polymorphic_variables : env -&gt; GlobRef.t -&gt; Univ.Level.t list
val is_template_checked : env -&gt; GlobRef.t -&gt; bool
val is_type_in_type : env -&gt; GlobRef.t -&gt; bool

(** Native compiler *)
val no_link_info : link_info

(** Primitives *)
val set_retroknowledge : env -&gt; Retroknowledge.retroknowledge -&gt; env
</pre>
  </div>
  <div class="col-md-6">
    <a href="#environ.mli"><code>Environ_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter lazy_val : Set.

Parameter build_lazy_val :
  lazy_val -&gt; Vmvalues.values * Names.Id.__Set.t -&gt; unit.

Parameter force_lazy_val :
  lazy_val -&gt; option (Vmvalues.values * Names.Id.__Set.t).

Parameter dummy_lazy_val : unit -&gt; lazy_val.

Inductive link_info : Set :=
| Linked : string -&gt; link_info
| LinkedInteractive : string -&gt; link_info
| NotLinked : link_info.

Definition key := Stdlib.ref (option (CEphemeron.key Z)).

Definition constant_key :=
  Declarations.constant_body * (Stdlib.ref link_info * key).

Definition mind_key :=
  Declarations.mutual_inductive_body * Stdlib.ref link_info.

Parameter globals : Set.

Module stratification.
  Record record := {
    env_universes : UGraph.t;
    env_sprop_allowed : bool;
    env_universes_lbound : Univ.Level.t;
    env_engagement : Declarations.engagement }.
  Definition with_env_universes (r : record) env_universes : record :=
    {| env_universes := env_universes; env_sprop_allowed := env_sprop_allowed r;
      env_universes_lbound := env_universes_lbound r;
      env_engagement := env_engagement r |}.
  Definition with_env_sprop_allowed (r : record) env_sprop_allowed : record :=
    {| env_universes := env_universes r; env_sprop_allowed := env_sprop_allowed;
      env_universes_lbound := env_universes_lbound r;
      env_engagement := env_engagement r |}.
  Definition with_env_universes_lbound (r : record) env_universes_lbound
    : record :=
    {| env_universes := env_universes r;
      env_sprop_allowed := env_sprop_allowed r;
      env_universes_lbound := env_universes_lbound;
      env_engagement := env_engagement r |}.
  Definition with_env_engagement (r : record) env_engagement : record :=
    {| env_universes := env_universes r;
      env_sprop_allowed := env_sprop_allowed r;
      env_universes_lbound := env_universes_lbound r;
      env_engagement := env_engagement |}.
End stratification.
Definition stratification := stratification.record.

Module named_context_val.
  Record record := {
    env_named_ctx : Constr.named_context;
    env_named_map : Names.Id.Map.t (Constr.named_declaration * lazy_val) }.
  Definition with_env_named_ctx (r : record) env_named_ctx : record :=
    {| env_named_ctx := env_named_ctx; env_named_map := env_named_map r |}.
  Definition with_env_named_map (r : record) env_named_map : record :=
    {| env_named_ctx := env_named_ctx r; env_named_map := env_named_map |}.
End named_context_val.
Definition named_context_val := named_context_val.record.

Module rel_context_val.
  Record record := {
    env_rel_ctx : Constr.rel_context;
    env_rel_map : Range.t (Constr.rel_declaration * lazy_val) }.
  Definition with_env_rel_ctx (r : record) env_rel_ctx : record :=
    {| env_rel_ctx := env_rel_ctx; env_rel_map := env_rel_map r |}.
  Definition with_env_rel_map (r : record) env_rel_map : record :=
    {| env_rel_ctx := env_rel_ctx r; env_rel_map := env_rel_map |}.
End rel_context_val.
Definition rel_context_val := rel_context_val.record.

Module env.
  Record record := {
    env_globals : globals;
    env_named_context : named_context_val;
    env_rel_context : rel_context_val;
    env_nb_rel : Z;
    env_stratification : stratification;
    env_typing_flags : Declarations.typing_flags;
    retroknowledge : Retroknowledge.retroknowledge;
    indirect_pterms : Opaqueproof.opaquetab }.
  Definition with_env_globals (r : record) env_globals : record :=
    {| env_globals := env_globals; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_named_context (r : record) env_named_context : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_rel_context (r : record) env_rel_context : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_nb_rel (r : record) env_nb_rel : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_stratification (r : record) env_stratification : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms r
      |}.
  Definition with_env_typing_flags (r : record) env_typing_flags : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags; retroknowledge := retroknowledge r;
      indirect_pterms := indirect_pterms r |}.
  Definition with_retroknowledge (r : record) retroknowledge : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r; retroknowledge := retroknowledge;
      indirect_pterms := indirect_pterms r |}.
  Definition with_indirect_pterms (r : record) indirect_pterms : record :=
    {| env_globals := env_globals r; env_named_context := env_named_context r;
      env_rel_context := env_rel_context r; env_nb_rel := env_nb_rel r;
      env_stratification := env_stratification r;
      env_typing_flags := env_typing_flags r;
      retroknowledge := retroknowledge r; indirect_pterms := indirect_pterms |}.
End env.
Definition env := env.record.

Parameter oracle : env -&gt; Conv_oracle.oracle.

Parameter set_oracle : env -&gt; Conv_oracle.oracle -&gt; env.

Parameter eq_named_context_val : named_context_val -&gt; named_context_val -&gt; bool.

Parameter empty_env : env.

Parameter universes : env -&gt; UGraph.t.

Parameter universes_lbound : env -&gt; Univ.Level.t.

Parameter set_universes_lbound : env -&gt; Univ.Level.t -&gt; env.

Parameter rel_context : env -&gt; Constr.rel_context.

Parameter named_context : env -&gt; Constr.named_context.

Parameter named_context_val : env -&gt; named_context_val.

Parameter opaque_tables : env -&gt; Opaqueproof.opaquetab.

Parameter set_opaque_tables : env -&gt; Opaqueproof.opaquetab -&gt; env.

Parameter engagement : env -&gt; Declarations.engagement.

Parameter typing_flags : env -&gt; Declarations.typing_flags.

Parameter is_impredicative_set : env -&gt; bool.

Parameter type_in_type : env -&gt; bool.

Parameter deactivated_guard : env -&gt; bool.

Parameter indices_matter : env -&gt; bool.

Parameter check_template : env -&gt; bool.

Parameter is_impredicative_sort : env -&gt; Sorts.t -&gt; bool.

Parameter is_impredicative_univ : env -&gt; Univ.Universe.t -&gt; bool.

Parameter empty_context : env -&gt; bool.

Parameter nb_rel : env -&gt; Z.

Parameter push_rel : Constr.rel_declaration -&gt; env -&gt; env.

Parameter push_rel_context : Constr.rel_context -&gt; env -&gt; env.

Parameter push_rec_types : Constr.rec_declaration -&gt; env -&gt; env.

Parameter lookup_rel : Z -&gt; env -&gt; Constr.rel_declaration.

Parameter lookup_rel_val : Z -&gt; env -&gt; lazy_val.

Parameter evaluable_rel : Z -&gt; env -&gt; bool.

Parameter env_of_rel : Z -&gt; env -&gt; env.

Parameter fold_rel_context : forall {a : Set},
  (env -&gt; Constr.rel_declaration -&gt; a -&gt; a) -&gt; env -&gt; a -&gt; a.

Parameter named_context_of_val : named_context_val -&gt; Constr.named_context.

Parameter val_of_named_context : Constr.named_context -&gt; named_context_val.

Parameter empty_named_context_val : named_context_val.

Parameter ids_of_named_context_val : named_context_val -&gt; Names.Id.__Set.t.

Parameter map_named_val :
  (Constr.constr -&gt; Constr.constr) -&gt; named_context_val -&gt; named_context_val.

Parameter push_named : Constr.named_declaration -&gt; env -&gt; env.

Parameter push_named_context : Constr.named_context -&gt; env -&gt; env.

Parameter push_named_context_val :
  Constr.named_declaration -&gt; named_context_val -&gt; named_context_val.

Parameter lookup_named : Names.variable -&gt; env -&gt; Constr.named_declaration.

Parameter lookup_named_val : Names.variable -&gt; env -&gt; lazy_val.

Parameter lookup_named_ctxt :
  Names.variable -&gt; named_context_val -&gt; Constr.named_declaration.

Parameter evaluable_named : Names.variable -&gt; env -&gt; bool.

Parameter named_type : Names.variable -&gt; env -&gt; Constr.types.

Parameter named_body : Names.variable -&gt; env -&gt; option Constr.constr.

Parameter fold_named_context : forall {a : Set},
  (env -&gt; Constr.named_declaration -&gt; a -&gt; a) -&gt; env -&gt; a -&gt; a.

Parameter fold_named_context_reverse : forall {a : Set},
  (a -&gt; Constr.named_declaration -&gt; a) -&gt; a -&gt; env -&gt; a.

Parameter reset_context : env -&gt; env.

Parameter reset_with_named_context : named_context_val -&gt; env -&gt; env.

Parameter pop_rel_context : Z -&gt; env -&gt; env.

Parameter fold_constants : forall {a : Set},
  (Names.Constant.t -&gt; Declarations.constant_body -&gt; a -&gt; a) -&gt; env -&gt; a -&gt; a.

Parameter add_constant :
  Names.Constant.t -&gt; Declarations.constant_body -&gt; env -&gt; env.

Parameter add_constant_key :
  Names.Constant.t -&gt; Declarations.constant_body -&gt; link_info -&gt; env -&gt; env.

Parameter lookup_constant_key : Names.Constant.t -&gt; env -&gt; constant_key.

Parameter lookup_constant :
  Names.Constant.t -&gt; env -&gt; Declarations.constant_body.

Parameter evaluable_constant : Names.Constant.t -&gt; env -&gt; bool.

Parameter polymorphic_constant : Names.Constant.t -&gt; env -&gt; bool.

Parameter polymorphic_pconstant : Constr.pconstant -&gt; env -&gt; bool.

Parameter type_in_type_constant : Names.Constant.t -&gt; env -&gt; bool.

Inductive const_evaluation_result : Set :=
| NoBody : const_evaluation_result
| Opaque : const_evaluation_result
| IsPrimitive : CPrimitives.t -&gt; const_evaluation_result.

(* exception NotEvaluableConst *)

Parameter constant_type :
  env -&gt; Univ.puniverses Names.Constant.t -&gt; Univ.constrained Constr.types.

Parameter constant_value_and_type :
  env -&gt; Univ.puniverses Names.Constant.t -&gt;
  option Constr.constr * Constr.types * Univ.Constraint.t.

Parameter constant_context : env -&gt; Names.Constant.t -&gt; Univ.AUContext.t.

Parameter body_of_constant_body :
  env -&gt; Declarations.constant_body -&gt; option (Constr.constr * Univ.AUContext.t).

Parameter constant_value_in :
  env -&gt; Univ.puniverses Names.Constant.t -&gt; Constr.constr.

Parameter constant_type_in :
  env -&gt; Univ.puniverses Names.Constant.t -&gt; Constr.types.

Parameter constant_opt_value_in :
  env -&gt; Univ.puniverses Names.Constant.t -&gt; option Constr.constr.

Parameter is_primitive : env -&gt; Names.Constant.t -&gt; bool.

Parameter lookup_projection : Names.Projection.t -&gt; env -&gt; Constr.types.

Parameter get_projection :
  env -&gt; Names.inductive -&gt; Z -&gt; option Names.Projection.Repr.t.

Parameter get_projections :
  env -&gt; Names.inductive -&gt; option (array Names.Projection.Repr.t).

Parameter lookup_mind_key : Names.MutInd.t -&gt; env -&gt; mind_key.

Parameter add_mind_key : Names.MutInd.t -&gt; mind_key -&gt; env -&gt; env.

Parameter add_mind :
  Names.MutInd.t -&gt; Declarations.mutual_inductive_body -&gt; env -&gt; env.

Parameter lookup_mind :
  Names.MutInd.t -&gt; env -&gt; Declarations.mutual_inductive_body.

Parameter mind_context : env -&gt; Names.MutInd.t -&gt; Univ.AUContext.t.

Parameter polymorphic_ind : Names.inductive -&gt; env -&gt; bool.

Parameter polymorphic_pind : Constr.pinductive -&gt; env -&gt; bool.

Parameter type_in_type_ind : Names.inductive -&gt; env -&gt; bool.

Parameter template_polymorphic_ind : Names.inductive -&gt; env -&gt; bool.

Parameter template_polymorphic_variables :
  Names.inductive -&gt; env -&gt; list Univ.Level.t.

Parameter template_polymorphic_pind : Constr.pinductive -&gt; env -&gt; bool.

Parameter template_checked_ind : Names.inductive -&gt; env -&gt; bool.

Parameter add_modtype : Declarations.module_type_body -&gt; env -&gt; env.

Parameter shallow_add_module : Declarations.module_body -&gt; env -&gt; env.

Parameter lookup_module : Names.ModPath.t -&gt; env -&gt; Declarations.module_body.

Parameter lookup_modtype :
  Names.ModPath.t -&gt; env -&gt; Declarations.module_type_body.

Parameter add_constraints : Univ.Constraint.t -&gt; env -&gt; env.

Parameter check_constraints : Univ.Constraint.t -&gt; env -&gt; bool.

Parameter push_context : option bool -&gt; Univ.UContext.t -&gt; env -&gt; env.

Parameter push_context_set : option bool -&gt; Univ.ContextSet.t -&gt; env -&gt; env.

Parameter push_constraints_to_env : forall {a : Set},
  Univ.constrained a -&gt; env -&gt; env.

Parameter push_subgraph : Univ.ContextSet.t -&gt; env -&gt; env.

Parameter set_engagement : Declarations.engagement -&gt; env -&gt; env.

Parameter set_typing_flags : Declarations.typing_flags -&gt; env -&gt; env.

Parameter make_sprop_cumulative : env -&gt; env.

Parameter set_allow_sprop : bool -&gt; env -&gt; env.

Parameter sprop_allowed : env -&gt; bool.

Parameter universes_of_global : env -&gt; Names.GlobRef.t -&gt; Univ.AUContext.t.

Parameter global_vars_set : env -&gt; Constr.constr -&gt; Names.Id.__Set.t.

Parameter vars_of_global : env -&gt; Names.GlobRef.t -&gt; Names.Id.__Set.t.

Parameter really_needed : env -&gt; Names.Id.__Set.t -&gt; Names.Id.__Set.t.

Parameter keep_hyps : env -&gt; Names.Id.__Set.t -&gt; Constr.named_context.

Module punsafe_judgment.
  Record record {constr types : Set} := {
    uj_val : constr;
    uj_type : types }.
  Arguments record : clear implicits.
  Definition with_uj_val {constr_type types_type : Set}
    (r : record constr_type types_type) uj_val
    : record constr_type types_type :=
    {| uj_val := uj_val; uj_type := uj_type r |}.
  Definition with_uj_type {constr_type types_type : Set}
    (r : record constr_type types_type) uj_type
    : record constr_type types_type :=
    {| uj_val := uj_val r; uj_type := uj_type |}.
End punsafe_judgment.
Definition punsafe_judgment := punsafe_judgment.record.

Parameter on_judgment : forall {a b : Set},
  (a -&gt; b) -&gt; punsafe_judgment a a -&gt; punsafe_judgment b b.

Parameter on_judgment_value : forall {c t : Set},
  (c -&gt; c) -&gt; punsafe_judgment c t -&gt; punsafe_judgment c t.

Parameter on_judgment_type : forall {c t : Set},
  (t -&gt; t) -&gt; punsafe_judgment c t -&gt; punsafe_judgment c t.

Definition unsafe_judgment := punsafe_judgment Constr.constr Constr.types.

Parameter make_judge : forall {constr types : Set},
  constr -&gt; types -&gt; punsafe_judgment constr types.

Parameter j_val : forall {constr types : Set},
  punsafe_judgment constr types -&gt; constr.

Parameter j_type : forall {constr types : Set},
  punsafe_judgment constr types -&gt; types.

Module punsafe_type_judgment.
  Record record {types : Set} := {
    utj_val : types;
    utj_type : Sorts.t }.
  Arguments record : clear implicits.
  Definition with_utj_val {types_type : Set} (r : record types_type) utj_val
    : record types_type :=
    {| utj_val := utj_val; utj_type := utj_type r |}.
  Definition with_utj_type {types_type : Set} (r : record types_type) utj_type
    : record types_type :=
    {| utj_val := utj_val r; utj_type := utj_type |}.
End punsafe_type_judgment.
Definition punsafe_type_judgment := punsafe_type_judgment.record.

Definition unsafe_type_judgment := punsafe_type_judgment Constr.types.

(* exception Hyp_not_found *)

Parameter apply_to_hyp :
  named_context_val -&gt; Names.variable -&gt;
  (Constr.named_context -&gt; Constr.named_declaration -&gt; Constr.named_context -&gt;
  Constr.named_declaration) -&gt; named_context_val.

Parameter remove_hyps :
  Names.Id.__Set.t -&gt; (Constr.named_declaration -&gt; Constr.named_declaration) -&gt;
  (lazy_val -&gt; lazy_val) -&gt; named_context_val -&gt; named_context_val.

Parameter is_polymorphic : env -&gt; Names.GlobRef.t -&gt; bool.

Parameter is_template_polymorphic : env -&gt; Names.GlobRef.t -&gt; bool.

Parameter get_template_polymorphic_variables :
  env -&gt; Names.GlobRef.t -&gt; list Univ.Level.t.

Parameter is_template_checked : env -&gt; Names.GlobRef.t -&gt; bool.

Parameter is_type_in_type : env -&gt; Names.GlobRef.t -&gt; bool.

Parameter no_link_info : link_info.

Parameter set_retroknowledge : env -&gt; Retroknowledge.retroknowledge -&gt; env.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="esubst.ml">
  <div style="margin: 20px;">
    <h3>Esubst</h3>
    <ul>
      <li>OCaml size: 186 lines</li>
      <li>Coq size: 241 lines (+29% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#esubst.ml"><code>esubst.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Bruno Barras for Coq V7.0, Mar 2001 *)

(* Support for explicit substitutions *)

open Util

(*********************)
(*      Lifting      *)
(*********************)

(* Explicit lifts and basic operations *)
(* Invariant to preserve in this module: no lift contains two consecutive
    [ELSHFT] nor two consecutive [ELLFT]. *)
type lift =
  | ELID
  | ELSHFT of lift * int (* ELSHFT(l,n) == lift of n, then apply lift l *)
  | ELLFT of int * lift  (* ELLFT(n,l)  == apply l to de Bruijn &gt; n *)
                         (*                 i.e under n binders *)

let el_id = ELID

(* compose a relocation of magnitude n *)
let el_shft_rec n = function
  | ELSHFT(el,k) -&gt; ELSHFT(el,k+n)
  | el           -&gt; ELSHFT(el,n)
let el_shft n el = if Int.equal n 0 then el else el_shft_rec n el

(* cross n binders *)
let el_liftn_rec n = function
  | ELID        -&gt; ELID
  | ELLFT(k,el) -&gt; ELLFT(n+k, el)
  | el          -&gt; ELLFT(n, el)
let el_liftn n el = if Int.equal n 0 then el else el_liftn_rec n el

let el_lift el = el_liftn_rec 1 el

(* relocation of de Bruijn n in an explicit lift *)
let rec reloc_rel n = function
  | ELID -&gt; n
  | ELLFT(k,el) -&gt;
      if n &lt;= k then n else (reloc_rel (n-k) el) + k
  | ELSHFT(el,k) -&gt; (reloc_rel (n+k) el)

let rec is_lift_id = function
  | ELID -&gt; true
  | ELSHFT(e,n) -&gt; Int.equal n 0 &amp;&amp; is_lift_id e
  | ELLFT (_,e) -&gt; is_lift_id e

(*********************)
(*  Substitutions    *)
(*********************)

(* (bounded) explicit substitutions of type 'a *)
type 'a subs =
  | ESID of int            (* ESID(n)    = %n END   bounded identity *)
  | CONS of 'a array * 'a subs
                           (* CONS([|t1..tn|],S)  =
                              (S.t1...tn)    parallel substitution
                              beware of the order *)
  | SHIFT of int * 'a subs (* SHIFT(n,S) = (^n o S) terms in S are relocated *)
                           (*                        with n vars *)
  | LIFT of int * 'a subs  (* LIFT(n,S) = (%n S) stands for ((^n o S).n...1) *)

(* operations of subs: collapses constructors when possible.
 * Needn't be recursive if we always use these functions
 *)

let subs_id i = ESID i

let subs_cons(x,s) = if Int.equal (Array.length x) 0 then s else CONS(x,s)

let subs_liftn n = function
  | ESID p        -&gt; ESID (p+n) (* bounded identity lifted extends by p *)
  | LIFT (p,lenv) -&gt; LIFT (p+n, lenv)
  | lenv          -&gt; LIFT (n,lenv)

let subs_lift a = subs_liftn 1 a
let subs_liftn n a = if Int.equal n 0 then a else subs_liftn n a

let subs_shft = function
  | (0, s)            -&gt; s
  | (n, SHIFT (k,s1)) -&gt; SHIFT (k+n, s1)
  | (n, s)            -&gt; SHIFT (n,s)
let subs_shft s = if Int.equal (fst s) 0 then snd s else subs_shft s

let subs_shift_cons = function
  (0, s, t)           -&gt; CONS(t,s)
| (k, SHIFT(n,s1), t) -&gt; CONS(t,SHIFT(k+n, s1))
| (k, s, t)           -&gt; CONS(t,SHIFT(k, s));;

(* Tests whether a substitution is equal to the identity *)
let rec is_subs_id = function
    ESID _     -&gt; true
  | LIFT(_,s)  -&gt; is_subs_id s
  | SHIFT(0,s) -&gt; is_subs_id s
  | CONS(x,s)  -&gt; Int.equal (Array.length x) 0 &amp;&amp; is_subs_id s
  | _          -&gt; false

(* Expands de Bruijn k in the explicit substitution subs
 * lams accumulates de shifts to perform when retrieving the i-th value
 * the rules used are the following:
 *
 *    [id]k       --&gt; k
 *    [S.t]1      --&gt; t
 *    [S.t]k      --&gt; [S](k-1)  if k &gt; 1
 *    [^n o S] k  --&gt; [^n]([S]k)
 *    [(%n S)] k  --&gt; k         if k &lt;= n
 *    [(%n S)] k  --&gt; [^n]([S](k-n))
 *
 * the result is (Inr (k+lams,p)) when the variable is just relocated
 * where p is None if the variable points inside subs and Some(k) if the
 * variable points k bindings beyond subs.
 *)
let rec exp_rel lams k subs =
  match subs with
    | CONS (def,_) when k &lt;= Array.length def
                           -&gt; Inl(lams,def.(Array.length def - k))
    | CONS (v,l)           -&gt; exp_rel lams (k - Array.length v) l
    | LIFT (n,_) when k&lt;=n -&gt; Inr(lams+k,None)
    | LIFT (n,l)           -&gt; exp_rel (n+lams) (k-n) l
    | SHIFT (n,s)          -&gt; exp_rel (n+lams) k s
    | ESID n when k&lt;=n     -&gt; Inr(lams+k,None)
    | ESID n               -&gt; Inr(lams+k,Some (k-n))

let expand_rel k subs = exp_rel 0 k subs

let rec subs_map f = function
| ESID _ as s -&gt; s
| CONS (x, s) -&gt; CONS (Array.map f x, subs_map f s)
| SHIFT (n, s) -&gt; SHIFT (n, subs_map f s)
| LIFT (n, s) -&gt; LIFT (n, subs_map f s)

let rec lift_subst mk_cl s1 s2 = match s1 with
| ELID -&gt; subs_map (fun c -&gt; mk_cl ELID c) s2
| ELSHFT(s, k) -&gt; subs_shft(k, lift_subst mk_cl s s2)
| ELLFT (k, s) -&gt;
  match s2 with
  | CONS(x,s') -&gt;
      CONS(CArray.Fun1.map mk_cl s1 x, lift_subst mk_cl s1 s')
  | ESID n -&gt; lift_subst mk_cl s (ESID (n + k))
  | SHIFT(k',s') -&gt;
      if k&lt;k'
      then subs_shft(k, lift_subst mk_cl s (subs_shft(k'-k, s')))
      else subs_shft(k', lift_subst mk_cl (el_liftn (k-k') s) s')
  | LIFT(k',s') -&gt;
      if k&lt;k'
      then subs_liftn k (lift_subst mk_cl s (subs_liftn (k'-k) s'))
      else subs_liftn k' (lift_subst mk_cl (el_liftn (k-k') s) s')

let rec comp mk_cl s1 s2 =
  match (s1, s2) with
    | _, ESID _ -&gt; s1
    | ESID _, _ -&gt; s2
    | SHIFT(k,s), _ -&gt; subs_shft(k, comp mk_cl s s2)
    | _, CONS(x,s') -&gt;
        CONS(Array.Fun1.map (fun s t -&gt; mk_cl(s,t)) s1 x, comp mk_cl s1 s')
    | CONS(x,s), SHIFT(k,s') -&gt;
        let lg = Array.length x in
        if k == lg then comp mk_cl s s'
        else if k &gt; lg then comp mk_cl s (SHIFT(k-lg, s'))
        else comp mk_cl (CONS(Array.sub x 0 (lg-k), s)) s'
    | CONS(x,s), LIFT(k,s') -&gt;
        let lg = Array.length x in
        if k == lg then CONS(x, comp mk_cl s s')
        else if k &gt; lg then CONS(x, comp mk_cl s (LIFT(k-lg, s')))
        else
          CONS(Array.sub x (lg-k) k,
               comp mk_cl (CONS(Array.sub x 0 (lg-k),s)) s')
    | LIFT(k,s), SHIFT(k',s') -&gt;
        if k&lt;k'
        then subs_shft(k, comp mk_cl s (subs_shft(k'-k, s')))
        else subs_shft(k', comp mk_cl (subs_liftn (k-k') s) s')
    | LIFT(k,s), LIFT(k',s') -&gt;
        if k&lt;k'
        then subs_liftn k (comp mk_cl s (subs_liftn (k'-k) s'))
        else subs_liftn k' (comp mk_cl (subs_liftn (k-k') s) s')
</pre>
  </div>
  <div class="col-md-6">
    <a href="#esubst.ml"><code>Esubst.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Inductive lift : Set :=
| ELID : lift
| ELSHFT : lift -&gt; Z -&gt; lift
| ELLFT : Z -&gt; lift -&gt; lift.

Definition el_id : lift := ELID.

Definition el_shft_rec (n : Z) (function_parameter : lift) : lift :=
  match function_parameter with
  | ELSHFT el k =&gt; ELSHFT el (Z.add k n)
  | el =&gt; ELSHFT el n
  end.

Definition el_shft (n : Int.t) (el : lift) : lift :=
  if Int.equal n 0 then
    el
  else
    el_shft_rec n el.

Definition el_liftn_rec (n : Z) (function_parameter : lift) : lift :=
  match function_parameter with
  | ELID =&gt; ELID
  | ELLFT k el =&gt; ELLFT (Z.add n k) el
  | el =&gt; ELLFT n el
  end.

Definition el_liftn (n : Int.t) (el : lift) : lift :=
  if Int.equal n 0 then
    el
  else
    el_liftn_rec n el.

Definition el_lift (el : lift) : lift := el_liftn_rec 1 el.

Fixpoint reloc_rel (n : Z) (function_parameter : lift) {struct n} : Z :=
  match function_parameter with
  | ELID =&gt; n
  | ELLFT k el =&gt;
    if OCaml.Stdlib.le n k then
      n
    else
      Z.add (reloc_rel (Z.sub n k) el) k
  | ELSHFT el k =&gt; reloc_rel (Z.add n k) el
  end.

Fixpoint is_lift_id (function_parameter : lift) {struct function_parameter}
  : bool :=
  match function_parameter with
  | ELID =&gt; true
  | ELSHFT e n =&gt; andb (Int.equal n 0) (is_lift_id e)
  | ELLFT _ e =&gt; is_lift_id e
  end.

Inductive subs (a : Set) : Set :=
| ESID : Z -&gt; subs a
| CONS : array a -&gt; subs a -&gt; subs a
| SHIFT : Z -&gt; subs a -&gt; subs a
| LIFT : Z -&gt; subs a -&gt; subs a.

Arguments ESID {_}.
Arguments CONS {_}.
Arguments SHIFT {_}.
Arguments LIFT {_}.

Definition subs_id {A : Set} (i : Z) : subs A := ESID i.

Definition subs_cons {A : Set} (function_parameter : array A * subs A)
  : subs A :=
  let '(x, s) := function_parameter in
  if Int.equal ((|Util.Array|).(CArray.ExtS.length) x) 0 then
    s
  else
    CONS x s.

Definition subs_liftn {A : Set} (n : Z) (function_parameter : subs A)
  : subs A :=
  match function_parameter with
  | ESID p =&gt; ESID (Z.add p n)
  | LIFT p lenv =&gt; LIFT (Z.add p n) lenv
  | lenv =&gt; LIFT n lenv
  end.

Definition subs_lift {A : Set} (a : subs A) : subs A := subs_liftn 1 a.

Definition subs_liftn {A : Set} (n : Int.t) (a : subs A) : subs A :=
  if Int.equal n 0 then
    a
  else
    subs_liftn n a.

Definition subs_shft {A : Set} (function_parameter : Z * subs A) : subs A :=
  match function_parameter with
  | (0, s) =&gt; s
  | (n, SHIFT k s1) =&gt; SHIFT (Z.add k n) s1
  | (n, s) =&gt; SHIFT n s
  end.

Definition subs_shft {A : Set} (s : Int.t * subs A) : subs A :=
  if Int.equal (fst s) 0 then
    snd s
  else
    subs_shft s.

Definition subs_shift_cons {A : Set} (function_parameter : Z * subs A * array A)
  : subs A :=
  match function_parameter with
  | (0, s, t) =&gt; CONS t s
  | (k, SHIFT n s1, t) =&gt; CONS t (SHIFT (Z.add k n) s1)
  | (k, s, t) =&gt; CONS t (SHIFT k s)
  end.

Fixpoint is_subs_id {A : Set} (function_parameter : subs A)
  {struct function_parameter} : bool :=
  match function_parameter with
  | ESID _ =&gt; true
  | LIFT _ s =&gt; is_subs_id s
  | SHIFT 0 s =&gt; is_subs_id s
  | CONS x s =&gt;
    andb (Int.equal ((|Util.Array|).(CArray.ExtS.length) x) 0) (is_subs_id s)
  | _ =&gt; false
  end.

Fixpoint exp_rel {A : Set} (lams : Z) (k : Z) (subs : subs A) {struct lams}
  : Util.union (Z * A) (Z * option Z) :=
  match
    (subs,
      match subs with
      | CONS def _ =&gt;
        OCaml.Stdlib.le k ((|Util.Array|).(CArray.ExtS.length) def)
      | _ =&gt; false
      end,
      match subs with
      | LIFT n _ =&gt; OCaml.Stdlib.le k n
      | _ =&gt; false
      end,
      match subs with
      | ESID n =&gt; OCaml.Stdlib.le k n
      | _ =&gt; false
      end) with
  | (CONS def _, true, _, _) =&gt;
    Util.Inl
      (lams,
        ((|Util.Array|).(CArray.ExtS.get) def
          (Z.sub ((|Util.Array|).(CArray.ExtS.length) def) k)))
  | (CONS v l, _, _, _) =&gt;
    exp_rel lams (Z.sub k ((|Util.Array|).(CArray.ExtS.length) v)) l
  | (LIFT n _, _, true, _) =&gt; Util.Inr ((Z.add lams k), None)
  | (LIFT n l, _, _, _) =&gt; exp_rel (Z.add n lams) (Z.sub k n) l
  | (SHIFT n s, _, _, _) =&gt; exp_rel (Z.add n lams) k s
  | (ESID n, _, _, true) =&gt; Util.Inr ((Z.add lams k), None)
  | (ESID n, _, _, _) =&gt; Util.Inr ((Z.add lams k), (Some (Z.sub k n)))
  end.

Definition expand_rel {A : Set} (k : Z) (subs : subs A)
  : Util.union (Z * A) (Z * option Z) := exp_rel 0 k subs.

Fixpoint subs_map {A B : Set} (f : A -&gt; B) (function_parameter : subs A)
  {struct f} : subs B :=
  match function_parameter with
  | (ESID _) as s =&gt; s
  | CONS x s =&gt; CONS ((|Util.Array|).(CArray.ExtS.map) f x) (subs_map f s)
  | SHIFT n s =&gt; SHIFT n (subs_map f s)
  | LIFT n s =&gt; LIFT n (subs_map f s)
  end.

Fixpoint lift_subst {A B : Set}
  (mk_cl : lift -&gt; A -&gt; B) (s1 : lift) (s2 : subs A) {struct mk_cl} : subs B :=
  match s1 with
  | ELID =&gt; subs_map (fun c =&gt; mk_cl ELID c) s2
  | ELSHFT s k =&gt; subs_shft (k, (lift_subst mk_cl s s2))
  | ELLFT k s =&gt;
    match s2 with
    | CONS x s' =&gt; CONS (CArray.Fun1.map mk_cl s1 x) (lift_subst mk_cl s1 s')
    | ESID n =&gt; lift_subst mk_cl s (ESID (Z.add n k))
    | SHIFT k' s' =&gt;
      if OCaml.Stdlib.lt k k' then
        subs_shft (k, (lift_subst mk_cl s (subs_shft ((Z.sub k' k), s'))))
      else
        subs_shft (k', (lift_subst mk_cl (el_liftn (Z.sub k k') s) s'))
    | LIFT k' s' =&gt;
      if OCaml.Stdlib.lt k k' then
        subs_liftn k (lift_subst mk_cl s (subs_liftn (Z.sub k' k) s'))
      else
        subs_liftn k' (lift_subst mk_cl (el_liftn (Z.sub k k') s) s')
    end
  end.

Fixpoint comp {A : Set} (mk_cl : subs A * A -&gt; A) (s1 : subs A) (s2 : subs A)
  {struct mk_cl} : subs A :=
  match (s1, s2) with
  | (_, ESID _) =&gt; s1
  | (ESID _, _) =&gt; s2
  | (SHIFT k s, _) =&gt; subs_shft (k, (comp mk_cl s s2))
  | (_, CONS x s') =&gt;
    CONS (Array.Fun1.map (fun s =&gt; fun t =&gt; mk_cl (s, t)) s1 x)
      (comp mk_cl s1 s')
  | (CONS x s, SHIFT k s') =&gt;
    let lg := (|Util.Array|).(CArray.ExtS.length) x in
    if Stdlib.op_eqeq k lg then
      comp mk_cl s s'
    else
      if OCaml.Stdlib.gt k lg then
        comp mk_cl s (SHIFT (Z.sub k lg) s')
      else
        comp mk_cl (CONS ((|Util.Array|).(CArray.ExtS.sub) x 0 (Z.sub lg k)) s)
          s'
  | (CONS x s, LIFT k s') =&gt;
    let lg := (|Util.Array|).(CArray.ExtS.length) x in
    if Stdlib.op_eqeq k lg then
      CONS x (comp mk_cl s s')
    else
      if OCaml.Stdlib.gt k lg then
        CONS x (comp mk_cl s (LIFT (Z.sub k lg) s'))
      else
        CONS ((|Util.Array|).(CArray.ExtS.sub) x (Z.sub lg k) k)
          (comp mk_cl
            (CONS ((|Util.Array|).(CArray.ExtS.sub) x 0 (Z.sub lg k)) s) s')
  | (LIFT k s, SHIFT k' s') =&gt;
    if OCaml.Stdlib.lt k k' then
      subs_shft (k, (comp mk_cl s (subs_shft ((Z.sub k' k), s'))))
    else
      subs_shft (k', (comp mk_cl (subs_liftn (Z.sub k k') s) s'))
  | (LIFT k s, LIFT k' s') =&gt;
    if OCaml.Stdlib.lt k k' then
      subs_liftn k (comp mk_cl s (subs_liftn (Z.sub k' k) s'))
    else
      subs_liftn k' (comp mk_cl (subs_liftn (Z.sub k k') s) s')
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="esubst.mli">
  <div style="margin: 20px;">
    <h3>Esubst_mli</h3>
    <ul>
      <li>OCaml size: 81 lines</li>
      <li>Coq size: 61 lines (-25% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#esubst.mli"><code>esubst.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** Explicit substitutions *)

(** {6 Explicit substitutions } *)
(** Explicit substitutions of type ['a].
    - ESID(n)             = %n END   bounded identity
    - CONS([|t1..tn|],S)  = (S.t1...tn)    parallel substitution
        (beware of the order: indice 1 is substituted by tn)
    - SHIFT(n,S)          = (^n o S) terms in S are relocated with n vars
    - LIFT(n,S)           = (%n S) stands for ((^n o S).n...1)
         (corresponds to S crossing n binders) *)
type 'a subs = private
  | ESID of int
  | CONS of 'a array * 'a subs
  | SHIFT of int * 'a subs
  | LIFT of int * 'a subs

(** Derived constructors granting basic invariants *)
val subs_id : int -&gt; 'a subs
val subs_cons: 'a array * 'a subs -&gt; 'a subs
val subs_shft: int * 'a subs -&gt; 'a subs
val subs_lift: 'a subs -&gt; 'a subs
val subs_liftn: int -&gt; 'a subs -&gt; 'a subs

(** [subs_shift_cons(k,s,[|t1..tn|])] builds (^k s).t1..tn *)
val subs_shift_cons: int * 'a subs * 'a array -&gt; 'a subs

(** [expand_rel k subs] expands de Bruijn [k] in the explicit substitution
    [subs]. The result is either (Inl(lams,v)) when the variable is
    substituted by value [v] under lams binders (i.e. v *has* to be
    shifted by lams), or (Inr (k',p)) when the variable k is just relocated
    as k'; p is None if the variable points inside subs and Some(k) if the
    variable points k bindings beyond subs (cf argument of ESID).
*)
val expand_rel: int -&gt; 'a subs -&gt; (int * 'a, int * int option) Util.union

(** Tests whether a substitution behaves like the identity *)
val is_subs_id: 'a subs -&gt; bool

(** Composition of substitutions: [comp mk_clos s1 s2] computes a
    substitution equivalent to applying s2 then s1. Argument
    mk_clos is used when a closure has to be created, i.e. when
    s1 is applied on an element of s2.
*)
val comp : ('a subs * 'a -&gt; 'a) -&gt; 'a subs -&gt; 'a subs -&gt; 'a subs

(** {6 Compact representation } *)
(** Compact representation of explicit relocations
    - [ELSHFT(l,n)] == lift of [n], then apply [lift l].
    - [ELLFT(n,l)] == apply [l] to de Bruijn &gt; [n] i.e under n binders.

    Invariant ensured by the private flag: no lift contains two consecutive
    [ELSHFT] nor two consecutive [ELLFT].
*)
type lift = private
  | ELID
  | ELSHFT of lift * int
  | ELLFT of int * lift

val el_id : lift
val el_shft : int -&gt; lift -&gt; lift
val el_liftn : int -&gt; lift -&gt; lift
val el_lift : lift -&gt; lift
val reloc_rel : int -&gt; lift -&gt; int
val is_lift_id : lift -&gt; bool

(** Lift applied to substitution: [lift_subst mk_clos el s] computes a
    substitution equivalent to applying el then s. Argument
    mk_clos is used when a closure has to be created, i.e. when
    el is applied on an element of s.
*)
val lift_subst : (lift -&gt; 'a -&gt; 'b) -&gt; lift -&gt; 'a subs -&gt; 'b subs
</pre>
  </div>
  <div class="col-md-6">
    <a href="#esubst.mli"><code>Esubst_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Inductive subs (a : Set) : Set :=
| ESID : Z -&gt; subs a
| CONS : array a -&gt; subs a -&gt; subs a
| SHIFT : Z -&gt; subs a -&gt; subs a
| LIFT : Z -&gt; subs a -&gt; subs a.

Arguments ESID {_}.
Arguments CONS {_}.
Arguments SHIFT {_}.
Arguments LIFT {_}.

Parameter subs_id : forall {a : Set}, Z -&gt; subs a.

Parameter subs_cons : forall {a : Set}, array a * subs a -&gt; subs a.

Parameter subs_shft : forall {a : Set}, Z * subs a -&gt; subs a.

Parameter subs_lift : forall {a : Set}, subs a -&gt; subs a.

Parameter subs_liftn : forall {a : Set}, Z -&gt; subs a -&gt; subs a.

Parameter subs_shift_cons : forall {a : Set}, Z * subs a * array a -&gt; subs a.

Parameter expand_rel : forall {a : Set},
  Z -&gt; subs a -&gt; Util.union (Z * a) (Z * option Z).

Parameter is_subs_id : forall {a : Set}, subs a -&gt; bool.

Parameter comp : forall {a : Set},
  (subs a * a -&gt; a) -&gt; subs a -&gt; subs a -&gt; subs a.

Inductive lift : Set :=
| ELID : lift
| ELSHFT : lift -&gt; Z -&gt; lift
| ELLFT : Z -&gt; lift -&gt; lift.

Parameter el_id : lift.

Parameter el_shft : Z -&gt; lift -&gt; lift.

Parameter el_liftn : Z -&gt; lift -&gt; lift.

Parameter el_lift : lift -&gt; lift.

Parameter reloc_rel : Z -&gt; lift -&gt; Z.

Parameter is_lift_id : lift -&gt; bool.

Parameter lift_subst : forall {a b : Set},
  (lift -&gt; a -&gt; b) -&gt; lift -&gt; subs a -&gt; subs b.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="evar.ml">
  <div style="margin: 20px;">
    <h3>Evar</h3>
    <ul>
      <li>OCaml size: 21 lines</li>
      <li>Coq size: 28 lines (+33% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#evar.ml"><code>evar.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t = int

let repr x = x
let unsafe_of_int x = x
let compare = Int.compare
let equal = Int.equal
let hash = Int.hash
let print x = Pp.(str &quot;?X&quot; ++ int x)

module Set = Int.Set
module Map = Int.Map
</pre>
  </div>
  <div class="col-md-6">
    <a href="#evar.ml"><code>Evar.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition t := Z.

Definition repr {A : Set} (x : A) : A := x.

Definition unsafe_of_int {A : Set} (x : A) : A := x.

Definition compare : Int.t -&gt; Int.t -&gt; Z := Int.compare.

Definition equal : Int.t -&gt; Int.t -&gt; bool := Int.equal.

Definition hash : Int.t -&gt; Z := Int.hash.

Definition print (x : Z) : Pp.t := op_plusplus (str &quot;?X&quot;) (int x).

Module __Set := Int.__Set.

Module Map := Int.Map.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="evar.mli">
  <div style="margin: 20px;">
    <h3>Evar_mli</h3>
    <ul>
      <li>OCaml size: 39 lines</li>
      <li>Coq size: 28 lines (-29% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#evar.mli"><code>evar.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** This module defines existential variables, which are isomorphic to [int].
    Nonetheless, casting from an [int] to a variable is deemed unsafe, so that
    to keep track of such casts, one has to use the provided {!unsafe_of_int}
    function. *)

type t
(** Type of existential variables. *)

val repr : t -&gt; int
(** Recover the underlying integer. *)

val unsafe_of_int : int -&gt; t
(** This is not for dummies. Do not use this function if you don't know what you
    are doing. *)

val equal : t -&gt; t -&gt; bool
(** Equality over existential variables. *)

val compare : t -&gt; t -&gt; int
(** Comparison over existential variables. *)

val hash : t -&gt; int
(** Hash over existential variables. *)

val print : t -&gt; Pp.t
(** Printing representation *)

module Set : Set.S with type elt = t
<abbr class="mark-warning" title="Can only do `with` on types in module types">module Map : CMap.ExtS with type key = t and module Set := Set</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#evar.mli"><code>Evar_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter t : Set.

Parameter repr : t -&gt; Z.

Parameter unsafe_of_int : Z -&gt; t.

Parameter equal : t -&gt; t -&gt; bool.

Parameter compare : t -&gt; t -&gt; Z.

Parameter hash : t -&gt; Z.

Parameter print : t -&gt; Pp.t.

Parameter __Set : {t : _ &amp; __Set.S.signature t t}.

Parameter Map : {'[t, __Set_t] : _ &amp; CMap.ExtS.signature t t __Set_t}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="genOpcodeFiles.ml">
  <div style="margin: 20px;">
    <h3>GenOpcodeFiles</h3>
    <ul>
      <li>OCaml size: 193 lines</li>
      <li>Coq size: 252 lines (+30% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#genOpcodeFiles.ml"><code>genOpcodeFiles.ml</code></a>&nbsp;<span class="label label-warning">9 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** List of opcodes.

    It is used to generate the [coq_instruct.h], [coq_jumptbl.h] and
    [copcodes.ml] files.

    If adding an instruction, DON'T FORGET TO UPDATE coq_fix_code.c
    with the arity of the instruction and maybe coq_tcode_of_code.
*)
let opcodes =
  <abbr class="mark-warning" title="Arrays not handled.">[|
    &quot;ACC0&quot;;
    &quot;ACC1&quot;;
    &quot;ACC2&quot;;
    &quot;ACC3&quot;;
    &quot;ACC4&quot;;
    &quot;ACC5&quot;;
    &quot;ACC6&quot;;
    &quot;ACC7&quot;;
    &quot;ACC&quot;;
    &quot;PUSH&quot;;
    &quot;PUSHACC0&quot;;
    &quot;PUSHACC1&quot;;
    &quot;PUSHACC2&quot;;
    &quot;PUSHACC3&quot;;
    &quot;PUSHACC4&quot;;
    &quot;PUSHACC5&quot;;
    &quot;PUSHACC6&quot;;
    &quot;PUSHACC7&quot;;
    &quot;PUSHACC&quot;;
    &quot;POP&quot;;
    &quot;ENVACC1&quot;;
    &quot;ENVACC2&quot;;
    &quot;ENVACC3&quot;;
    &quot;ENVACC4&quot;;
    &quot;ENVACC&quot;;
    &quot;PUSHENVACC1&quot;;
    &quot;PUSHENVACC2&quot;;
    &quot;PUSHENVACC3&quot;;
    &quot;PUSHENVACC4&quot;;
    &quot;PUSHENVACC&quot;;
    &quot;PUSH_RETADDR&quot;;
    &quot;APPLY&quot;;
    &quot;APPLY1&quot;;
    &quot;APPLY2&quot;;
    &quot;APPLY3&quot;;
    &quot;APPLY4&quot;;
    &quot;APPTERM&quot;;
    &quot;APPTERM1&quot;;
    &quot;APPTERM2&quot;;
    &quot;APPTERM3&quot;;
    &quot;RETURN&quot;;
    &quot;RESTART&quot;;
    &quot;GRAB&quot;;
    &quot;GRABREC&quot;;
    &quot;CLOSURE&quot;;
    &quot;CLOSUREREC&quot;;
    &quot;CLOSURECOFIX&quot;;
    &quot;OFFSETCLOSUREM2&quot;;
    &quot;OFFSETCLOSURE0&quot;;
    &quot;OFFSETCLOSURE2&quot;;
    &quot;OFFSETCLOSURE&quot;;
    &quot;PUSHOFFSETCLOSUREM2&quot;;
    &quot;PUSHOFFSETCLOSURE0&quot;;
    &quot;PUSHOFFSETCLOSURE2&quot;;
    &quot;PUSHOFFSETCLOSURE&quot;;
    &quot;GETGLOBAL&quot;;
    &quot;PUSHGETGLOBAL&quot;;
    &quot;MAKEBLOCK&quot;;
    &quot;MAKEBLOCK1&quot;;
    &quot;MAKEBLOCK2&quot;;
    &quot;MAKEBLOCK3&quot;;
    &quot;MAKEBLOCK4&quot;;
    &quot;SWITCH&quot;;
    &quot;PUSHFIELDS&quot;;
    &quot;GETFIELD0&quot;;
    &quot;GETFIELD1&quot;;
    &quot;GETFIELD&quot;;
    &quot;SETFIELD0&quot;;
    &quot;SETFIELD1&quot;;
    &quot;SETFIELD&quot;;
    &quot;PROJ&quot;;
    &quot;ENSURESTACKCAPACITY&quot;;
    &quot;CONST0&quot;;
    &quot;CONST1&quot;;
    &quot;CONST2&quot;;
    &quot;CONST3&quot;;
    &quot;CONSTINT&quot;;
    &quot;PUSHCONST0&quot;;
    &quot;PUSHCONST1&quot;;
    &quot;PUSHCONST2&quot;;
    &quot;PUSHCONST3&quot;;
    &quot;PUSHCONSTINT&quot;;
    &quot;ACCUMULATE&quot;;
    &quot;MAKESWITCHBLOCK&quot;;
    &quot;MAKEACCU&quot;;
    &quot;MAKEPROD&quot;;
    &quot;BRANCH&quot;;
    &quot;CHECKADDINT63&quot;;
    &quot;ADDINT63&quot;;
    &quot;CHECKADDCINT63&quot;;
    &quot;CHECKADDCARRYCINT63&quot;;
    &quot;CHECKSUBINT63&quot;;
    &quot;SUBINT63&quot;;
    &quot;CHECKSUBCINT63&quot;;
    &quot;CHECKSUBCARRYCINT63&quot;;
    &quot;CHECKMULINT63&quot;;
    &quot;CHECKMULCINT63&quot;;
    &quot;CHECKDIVINT63&quot;;
    &quot;CHECKMODINT63&quot;;
    &quot;CHECKDIVEUCLINT63&quot;;
    &quot;CHECKDIV21INT63&quot;;
    &quot;CHECKLXORINT63&quot;;
    &quot;CHECKLORINT63&quot;;
    &quot;CHECKLANDINT63&quot;;
    &quot;CHECKLSLINT63&quot;;
    &quot;CHECKLSRINT63&quot;;
    &quot;CHECKADDMULDIVINT63&quot;;
    &quot;CHECKLSLINT63CONST1&quot;;
    &quot;CHECKLSRINT63CONST1&quot;;
    &quot;CHECKEQINT63&quot;;
    &quot;CHECKLTINT63&quot;;
    &quot;LTINT63&quot;;
    &quot;CHECKLEINT63&quot;;
    &quot;LEINT63&quot;;
    &quot;CHECKCOMPAREINT63&quot;;
    &quot;CHECKHEAD0INT63&quot;;
    &quot;CHECKTAIL0INT63&quot;;
    &quot;ISINT&quot;;
    &quot;AREINT2&quot;;
    &quot;STOP&quot;
  |]</abbr>

let pp_c_comment fmt =
  Format.fprintf fmt &quot;/* %a */&quot;

let pp_ocaml_comment fmt =
  Format.fprintf fmt &quot;(* %a *)&quot;

let pp_header isOcaml fmt =
  Format.fprintf fmt &quot;%a&quot;
    (fun fmt -&gt;
       (if isOcaml then pp_ocaml_comment else pp_c_comment) fmt
         Format.pp_print_string)
    &quot;DO NOT EDIT: automatically generated by kernel/genOpcodeFiles.ml&quot;

let pp_with_commas fmt k =
  Array.iteri (fun n s -&gt;
      Format.fprintf fmt &quot;  %a%s@.&quot;
        k s
        (if n + 1 &lt; Array.length opcodes
         then &quot;,&quot; else &quot;&quot;)
    ) opcodes

let pp_coq_instruct_h fmt =
  let line = Format.fprintf fmt &quot;%s@.&quot; in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">pp_header false fmt;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">line &quot;#pragma once&quot;;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">line &quot;enum instructions {&quot;;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">pp_with_commas fmt Format.pp_print_string;
  line &quot;};&quot;</abbr>

let pp_coq_jumptbl_h fmt =
  pp_with_commas fmt (fun fmt -&gt; Format.fprintf fmt &quot;&amp;&amp;coq_lbl_%s&quot;)

let pp_copcodes_ml fmt =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">pp_header true fmt;
  Array.iteri (fun n s -&gt;
      Format.fprintf fmt &quot;let op%s = %d@.@.&quot; s n
    ) opcodes</abbr>

let usage () =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.eprintf &quot;usage: %s [enum|jump|copml]@.&quot; Sys.argv.(0);
  exit 1</abbr>

let main () =
  match Sys.argv.(1) with
  | &quot;enum&quot; -&gt; pp_coq_instruct_h Format.std_formatter
  | &quot;jump&quot; -&gt; pp_coq_jumptbl_h Format.std_formatter
  | &quot;copml&quot; -&gt; pp_copcodes_ml Format.std_formatter
  | _ -&gt; usage ()
  | exception <abbr class="mark-warning" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">Invalid_argument _</abbr> -&gt; usage ()

<abbr class="mark-warning" title="Top-level evaluations are not handled">let () = main ()</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#genOpcodeFiles.ml"><code>GenOpcodeFiles.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition opcodes : array string :=
  (* ❌ Arrays not handled. *)
  [
    &quot;ACC0&quot;;
    &quot;ACC1&quot;;
    &quot;ACC2&quot;;
    &quot;ACC3&quot;;
    &quot;ACC4&quot;;
    &quot;ACC5&quot;;
    &quot;ACC6&quot;;
    &quot;ACC7&quot;;
    &quot;ACC&quot;;
    &quot;PUSH&quot;;
    &quot;PUSHACC0&quot;;
    &quot;PUSHACC1&quot;;
    &quot;PUSHACC2&quot;;
    &quot;PUSHACC3&quot;;
    &quot;PUSHACC4&quot;;
    &quot;PUSHACC5&quot;;
    &quot;PUSHACC6&quot;;
    &quot;PUSHACC7&quot;;
    &quot;PUSHACC&quot;;
    &quot;POP&quot;;
    &quot;ENVACC1&quot;;
    &quot;ENVACC2&quot;;
    &quot;ENVACC3&quot;;
    &quot;ENVACC4&quot;;
    &quot;ENVACC&quot;;
    &quot;PUSHENVACC1&quot;;
    &quot;PUSHENVACC2&quot;;
    &quot;PUSHENVACC3&quot;;
    &quot;PUSHENVACC4&quot;;
    &quot;PUSHENVACC&quot;;
    &quot;PUSH_RETADDR&quot;;
    &quot;APPLY&quot;;
    &quot;APPLY1&quot;;
    &quot;APPLY2&quot;;
    &quot;APPLY3&quot;;
    &quot;APPLY4&quot;;
    &quot;APPTERM&quot;;
    &quot;APPTERM1&quot;;
    &quot;APPTERM2&quot;;
    &quot;APPTERM3&quot;;
    &quot;RETURN&quot;;
    &quot;RESTART&quot;;
    &quot;GRAB&quot;;
    &quot;GRABREC&quot;;
    &quot;CLOSURE&quot;;
    &quot;CLOSUREREC&quot;;
    &quot;CLOSURECOFIX&quot;;
    &quot;OFFSETCLOSUREM2&quot;;
    &quot;OFFSETCLOSURE0&quot;;
    &quot;OFFSETCLOSURE2&quot;;
    &quot;OFFSETCLOSURE&quot;;
    &quot;PUSHOFFSETCLOSUREM2&quot;;
    &quot;PUSHOFFSETCLOSURE0&quot;;
    &quot;PUSHOFFSETCLOSURE2&quot;;
    &quot;PUSHOFFSETCLOSURE&quot;;
    &quot;GETGLOBAL&quot;;
    &quot;PUSHGETGLOBAL&quot;;
    &quot;MAKEBLOCK&quot;;
    &quot;MAKEBLOCK1&quot;;
    &quot;MAKEBLOCK2&quot;;
    &quot;MAKEBLOCK3&quot;;
    &quot;MAKEBLOCK4&quot;;
    &quot;SWITCH&quot;;
    &quot;PUSHFIELDS&quot;;
    &quot;GETFIELD0&quot;;
    &quot;GETFIELD1&quot;;
    &quot;GETFIELD&quot;;
    &quot;SETFIELD0&quot;;
    &quot;SETFIELD1&quot;;
    &quot;SETFIELD&quot;;
    &quot;PROJ&quot;;
    &quot;ENSURESTACKCAPACITY&quot;;
    &quot;CONST0&quot;;
    &quot;CONST1&quot;;
    &quot;CONST2&quot;;
    &quot;CONST3&quot;;
    &quot;CONSTINT&quot;;
    &quot;PUSHCONST0&quot;;
    &quot;PUSHCONST1&quot;;
    &quot;PUSHCONST2&quot;;
    &quot;PUSHCONST3&quot;;
    &quot;PUSHCONSTINT&quot;;
    &quot;ACCUMULATE&quot;;
    &quot;MAKESWITCHBLOCK&quot;;
    &quot;MAKEACCU&quot;;
    &quot;MAKEPROD&quot;;
    &quot;BRANCH&quot;;
    &quot;CHECKADDINT63&quot;;
    &quot;ADDINT63&quot;;
    &quot;CHECKADDCINT63&quot;;
    &quot;CHECKADDCARRYCINT63&quot;;
    &quot;CHECKSUBINT63&quot;;
    &quot;SUBINT63&quot;;
    &quot;CHECKSUBCINT63&quot;;
    &quot;CHECKSUBCARRYCINT63&quot;;
    &quot;CHECKMULINT63&quot;;
    &quot;CHECKMULCINT63&quot;;
    &quot;CHECKDIVINT63&quot;;
    &quot;CHECKMODINT63&quot;;
    &quot;CHECKDIVEUCLINT63&quot;;
    &quot;CHECKDIV21INT63&quot;;
    &quot;CHECKLXORINT63&quot;;
    &quot;CHECKLORINT63&quot;;
    &quot;CHECKLANDINT63&quot;;
    &quot;CHECKLSLINT63&quot;;
    &quot;CHECKLSRINT63&quot;;
    &quot;CHECKADDMULDIVINT63&quot;;
    &quot;CHECKLSLINT63CONST1&quot;;
    &quot;CHECKLSRINT63CONST1&quot;;
    &quot;CHECKEQINT63&quot;;
    &quot;CHECKLTINT63&quot;;
    &quot;LTINT63&quot;;
    &quot;CHECKLEINT63&quot;;
    &quot;LEINT63&quot;;
    &quot;CHECKCOMPAREINT63&quot;;
    &quot;CHECKHEAD0INT63&quot;;
    &quot;CHECKTAIL0INT63&quot;;
    &quot;ISINT&quot;;
    &quot;AREINT2&quot;;
    &quot;STOP&quot;
  ].

Definition pp_c_comment {A : Set} (fmt : Stdlib.Format.formatter)
  : (Stdlib.Format.formatter -&gt; A -&gt; unit) -&gt; A -&gt; unit :=
  Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;/* &quot;
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.String_literal &quot; */&quot;
            CamlinternalFormatBasics.End_of_format))) &quot;/* %a */&quot;).

Definition pp_ocaml_comment {A : Set} (fmt : Stdlib.Format.formatter)
  : (Stdlib.Format.formatter -&gt; A -&gt; unit) -&gt; A -&gt; unit :=
  Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;(* &quot;
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.String_literal &quot; *)&quot;
            CamlinternalFormatBasics.End_of_format))) &quot;(* %a *)&quot;).

Definition pp_header (isOcaml : bool) (fmt : Stdlib.Format.formatter) : unit :=
  Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Alpha CamlinternalFormatBasics.End_of_format)
      &quot;%a&quot;)
    (fun fmt =&gt;
      (if isOcaml then
        pp_ocaml_comment
      else
        pp_c_comment) fmt Format.pp_print_string)
    &quot;DO NOT EDIT: automatically generated by kernel/genOpcodeFiles.ml&quot;.

Definition pp_with_commas
  (fmt : Stdlib.Format.formatter)
  (k : Stdlib.Format.formatter -&gt; string -&gt; unit) : unit :=
  Array.iteri
    (fun n =&gt;
      fun s =&gt;
        Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;  &quot;
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Flush_newline
                    CamlinternalFormatBasics.End_of_format)))) &quot;  %a%s@.&quot;) k s
          (if OCaml.Stdlib.lt (Z.add n 1) (Array.length opcodes) then
            &quot;,&quot;
          else
            &quot;&quot;)) opcodes.

Definition pp_coq_instruct_h (fmt : Stdlib.Format.formatter) : unit :=
  let line :=
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.Formatting_lit
            CamlinternalFormatBasics.Flush_newline
            CamlinternalFormatBasics.End_of_format)) &quot;%s@.&quot;) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  line &quot;};&quot;.

Definition pp_coq_jumptbl_h (fmt : Stdlib.Format.formatter) : unit :=
  pp_with_commas fmt
    (fun fmt =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;&amp;&amp;coq_lbl_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.End_of_format)) &quot;&amp;&amp;coq_lbl_%s&quot;)).

Definition pp_copcodes_ml (fmt : Stdlib.Format.formatter) : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Array.iteri
    (fun n =&gt;
      fun s =&gt;
        Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;let op&quot;
              (CamlinternalFormatBasics.String
                CamlinternalFormatBasics.No_padding
                (CamlinternalFormatBasics.String_literal &quot; = &quot;
                  (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.No_precision
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Flush_newline
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Flush_newline
                        CamlinternalFormatBasics.End_of_format))))))
            &quot;let op%s = %d@.@.&quot;) s n) opcodes.

Definition usage {A : Set} (function_parameter : unit) : A :=
  let '_ := function_parameter in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.exit 1.

Definition main (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  match Array.get Sys.argv 1 with
  | &quot;enum&quot; =&gt; pp_coq_instruct_h Format.std_formatter
  | &quot;jump&quot; =&gt; pp_coq_jumptbl_h Format.std_formatter
  | &quot;copml&quot; =&gt; pp_copcodes_ml Format.std_formatter
  | _ =&gt; usage tt
  end.

(* ❌ Top-level evaluations are not handled *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="indTyping.ml">
  <div style="margin: 20px;">
    <h3>IndTyping</h3>
    <ul>
      <li>OCaml size: 420 lines</li>
      <li>Coq size: 576 lines (+37% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#indTyping.ml"><code>indTyping.ml</code></a>&nbsp;<span class="label label-warning">14 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open Names
open Univ
open Term
open Constr
open Declarations
open Environ
open Entries
open Type_errors
open Context.Rel.Declaration

(** Check name unicity.
    Redundant with safe_typing's add_field checks -&gt; to remove?. *)

(* [check_constructors_names id s cl] checks that all the constructors names
   appearing in [l] are not present in the set [s], and returns the new set
   of names. The name [id] is the name of the current inductive type, used
   when reporting the error. *)

let check_constructors_names =
  let rec check idset = function
    | [] -&gt; idset
    | c::cl -&gt;
        if Id.Set.mem c idset then
          raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError (SameNamesConstructors c))</abbr>
        else
          check (Id.Set.add c idset) cl
  in
  check

(* [mind_check_names mie] checks the names of an inductive types declaration,
   and raises the corresponding exceptions when two types or two constructors
   have the same name. *)

let mind_check_names mie =
  let rec check indset cstset = function
    | [] -&gt; ()
    | ind::inds -&gt;
        let id = ind.mind_entry_typename in
        let cl = ind.mind_entry_consnames in
        if Id.Set.mem id indset then
          raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError (SameNamesTypes id))</abbr>
        else
          let cstset' = check_constructors_names cstset cl in
          check (Id.Set.add id indset) cstset' inds
  in
  check Id.Set.empty Id.Set.empty mie.mind_entry_inds
(* The above verification is not necessary from the kernel point of
  vue since inductive and constructors are not referred to by their
  name, but only by the name of the inductive packet and an index. *)


(************************************************************************)
(************************** Cumulativity checking************************)
(************************************************************************)

(* Check arities and constructors *)
let check_subtyping_arity_constructor env subst arcn numparams is_arity =
  let numchecked = ref 0 in
  let basic_check ev tp =
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !numchecked &lt; numparams then () else Reduction.conv_leq ev tp (subst tp);
    numchecked := !numchecked + 1</abbr>
  in
  let check_typ typ typ_env =
    match typ with
    | LocalAssum (_, typ') -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">begin
       try
          </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">basic_check typ_env typ'; Environ.push_rel typ typ_env</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
        with Reduction.NotConvertible -&gt;
          CErrors.anomaly ~label:&quot;bad inductive subtyping relation&quot;
            Pp.(str &quot;Invalid subtyping relation&quot;)
      end</abbr>
    | _ -&gt; CErrors.anomaly Pp.(str &quot;&quot;)
  in
  let typs, codom = Reduction.dest_prod env arcn in
  let last_env = Context.Rel.fold_outside check_typ typs ~init:env in
  if not is_arity then basic_check last_env codom else ()

let check_cumulativity univs variances env_ar params data =
  let uctx = match univs with
    | Monomorphic_entry _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError BadUnivs)</abbr>
    | Polymorphic_entry (_,uctx) -&gt; uctx
  in
  let instance = UContext.instance uctx in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Instance.length instance != Array.length variances then raise (InductiveError BadUnivs);
  let numparams = Context.Rel.nhyps params in
  let new_levels = Array.init (Instance.length instance)
      (fun i -&gt; Level.(make (UGlobal.make DirPath.empty i)))
  in
  let lmap = Array.fold_left2 (fun lmap u u' -&gt; LMap.add u u' lmap)
      LMap.empty (Instance.to_array instance) new_levels
  in
  let dosubst = Vars.subst_univs_level_constr lmap in
  let instance_other = Instance.of_array new_levels in
  let constraints_other = Univ.subst_univs_level_constraints lmap (UContext.constraints uctx) in
  let uctx_other = Univ.UContext.make (instance_other, constraints_other) in
  let env = Environ.push_context uctx_other env_ar in
  let subtyp_constraints =
    Univ.enforce_leq_variance_instances variances
      instance instance_other
      Constraint.empty
  in
  let env = Environ.add_constraints subtyp_constraints env in
  (* process individual inductive types: *)
  List.iter (fun (arity,lc) -&gt;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_subtyping_arity_constructor env dosubst arity numparams true;
        Array.iter (fun cnt -&gt; check_subtyping_arity_constructor env dosubst cnt numparams false) lc</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)
    data</abbr>

(************************************************************************)
(************************** Type checking *******************************)
(************************************************************************)

type univ_info = { ind_squashed : bool; ind_has_relevant_arg : bool;
                   ind_min_univ : Universe.t option; (* Some for template *)
                   ind_univ : Universe.t }

let check_univ_leq ?(is_real_arg=false) env u info =
  let ind_univ = info.ind_univ in
  let info = if not info.ind_has_relevant_arg &amp;&amp; is_real_arg &amp;&amp; not (Univ.Universe.is_sprop u)
    then {info with ind_has_relevant_arg=true}
    else info
  in
  (* Inductive types provide explicit lifting from SProp to other universes, so allow SProp &lt;= any. *)
  if type_in_type env || Univ.Universe.is_sprop u || UGraph.check_leq (universes env) u ind_univ
  then { info with ind_min_univ = Option.map (Universe.sup u) info.ind_min_univ }
  else if is_impredicative_univ env ind_univ
  then if Option.is_empty info.ind_min_univ then { info with ind_squashed = true }
    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError BadUnivs)</abbr>
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError BadUnivs)</abbr>

let check_context_univs ~ctor env info ctx =
  let check_one d (info,env) =
    let info = match d with
      | LocalAssum (_,t) -&gt;
        (* could be retyping if it becomes available in the kernel *)
        let tj = Typeops.infer_type env t in
        check_univ_leq ~is_real_arg:ctor env (Sorts.univ_of_sort tj.utj_type) info
      | LocalDef _ -&gt; info
    in
    info, push_rel d env
  in
  fst (Context.Rel.fold_outside ~init:(info,env) check_one ctx)

let check_indices_matter env_params info indices =
  if not (indices_matter env_params) then info
  else check_context_univs ~ctor:false env_params info indices

(* env_ar contains the inductives before the current ones in the block, and no parameters *)
let check_arity env_params env_ar ind =
  let {utj_val=arity;utj_type=_} = Typeops.infer_type env_params ind.mind_entry_arity in
  let indices, ind_sort = Reduction.dest_arity env_params arity in
  let ind_min_univ = if ind.mind_entry_template then Some Universe.type0m else None in
  let univ_info = {
    ind_squashed=false;
    ind_has_relevant_arg=false;
    ind_min_univ;
    ind_univ=Sorts.univ_of_sort ind_sort;
  }
  in
  let univ_info = check_indices_matter env_params univ_info indices in
  (* We do not need to generate the universe of the arity with params;
     if later, after the validation of the inductive definition,
     full_arity is used as argument or subject to cast, an upper
     universe will be generated *)
  let arity = it_mkProd_or_LetIn arity (Environ.rel_context env_params) in
  let x = Context.make_annot (Name ind.mind_entry_typename) (Sorts.relevance_of_sort ind_sort) in
  push_rel (LocalAssum (x, arity)) env_ar,
  (arity, indices, univ_info)

let check_constructor_univs env_ar_par info (args,_) =
  (* We ignore the output, positivity will check that it's the expected inductive type *)
  check_context_univs ~ctor:true env_ar_par info args

let check_constructors env_ar_par isrecord params lc (arity,indices,univ_info) =
  let lc = Array.map_of_list (fun c -&gt; (Typeops.infer_type env_ar_par c).utj_val) lc in
  let splayed_lc = Array.map (Reduction.dest_prod_assum env_ar_par) lc in
  let univ_info = match Array.length lc with
    (* Empty type: all OK *)
    | 0 -&gt; univ_info

    (* SProp primitive records are OK, if we squash and become fakerecord also OK *)
    | 1 when isrecord -&gt; univ_info

    (* Unit and identity types must squash if SProp *)
    | 1 -&gt; check_univ_leq env_ar_par Univ.Universe.type0m univ_info

    (* More than 1 constructor: must squash if Prop/SProp *)
    | _ -&gt; check_univ_leq env_ar_par Univ.Universe.type0 univ_info
  in
  let univ_info = Array.fold_left (check_constructor_univs env_ar_par) univ_info splayed_lc in
  (* generalize the constructors over the parameters *)
  let lc = Array.map (fun c -&gt; Term.it_mkProd_or_LetIn c params) lc in
  (arity, lc), (indices, splayed_lc), univ_info

let check_record data =
  List.for_all (fun (_,(_,splayed_lc),info) -&gt;
      (* records must have all projections definable -&gt; equivalent to not being squashed *)
      not info.ind_squashed
      (* relevant records must have at least 1 relevant argument *)
      &amp;&amp; (Univ.Universe.is_sprop info.ind_univ
          || info.ind_has_relevant_arg)
      &amp;&amp; (match splayed_lc with
          (* records must have 1 constructor with at least 1 argument, and no anonymous fields *)
          | <abbr class="mark-warning" title="Patterns on array are not supported">[|ctx,_|]</abbr> -&gt;
            let module D = Context.Rel.Declaration in
            List.exists D.is_local_assum ctx &amp;&amp;
            List.for_all (fun d -&gt; not (D.is_local_assum d)
                                   || not (Name.is_anonymous (D.get_name d)))
              ctx
          | _ -&gt; false))
    data

(* Allowed eliminations *)

(* Previous comment: *)
(* Unitary/empty Prop: elimination to all sorts are realizable *)
(* unless the type is large. If it is large, forbids large elimination *)
(* which otherwise allows simulating the inconsistent system Type:Type. *)
(* -&gt; this is now handled by is_smashed: *)
(* - all_sorts in case of small, unitary Prop (not smashed) *)
(* - logical_sorts in case of large, unitary Prop (smashed) *)

let all_sorts = [InSProp;InProp;InSet;InType]
let small_sorts = [InSProp;InProp;InSet]
let logical_sorts = [InSProp;InProp]
let sprop_sorts = [InSProp]

let allowed_sorts {ind_squashed;ind_univ;ind_min_univ=_;ind_has_relevant_arg=_} =
  if not ind_squashed then all_sorts
  else match Sorts.family (Sorts.sort_of_univ ind_univ) with
    | InType -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    | InSet -&gt; small_sorts
    | InProp -&gt; logical_sorts
    | InSProp -&gt; sprop_sorts

(* For a level to be template polymorphic, it must be introduced
   by the definition (so have no constraint except lbound &lt;= l)
   and not to be constrained from below, so any universe l' &lt;= l
   can be used as an instance of l. All bounds from above, i.e.
   l &lt;=/&lt; r will be valid for any l' &lt;= l. *)
let unbounded_from_below u cstrs =
  Univ.Constraint.for_all (fun (l, d, r) -&gt;
      match d with
      | Eq -&gt; not (Univ.Level.equal l u) &amp;&amp; not (Univ.Level.equal r u)
      | Lt | Le -&gt; not (Univ.Level.equal r u))
    cstrs

(* Returns the list [x_1, ..., x_n] of levels contributing to template
   polymorphism. The elements x_k is None if the k-th parameter
   (starting from the most recent and ignoring let-definitions) is not
   contributing to the inductive type's sort or is Some u_k if its level
   is u_k and is contributing. *)
let template_polymorphic_univs ~template_check ~ctor_levels uctx paramsctxt concl =
  let check_level l =
    if Univ.LSet.mem l (Univ.ContextSet.levels uctx) &amp;&amp;
       unbounded_from_below l (Univ.ContextSet.constraints uctx) &amp;&amp;
       not (Univ.LSet.mem l ctor_levels) then
      Some l
    else None
  in
  let univs = Univ.Universe.levels concl in
  let univs =
    if template_check then
      Univ.LSet.filter (fun l -&gt; Option.has_some (check_level l) || Univ.Level.is_prop l) univs
    else univs (* Doesn't check the universes can be generalized *)
  in
  let fold acc = function
    | (LocalAssum (_, p)) -&gt;
      (let c = Term.strip_prod_assum p in
      match kind c with
        | Sort (Type u) -&gt;
          if template_check then
            (match Univ.Universe.level u with
             | Some l -&gt; if Univ.LSet.mem l univs &amp;&amp; not (Univ.Level.is_prop l) then Some l else None
             | None -&gt; None)
          else Univ.Universe.level u
        | _ -&gt; None) :: acc
    | LocalDef _ -&gt; acc
  in
  let params = List.fold_left fold [] paramsctxt in
  params, univs

let abstract_packets ~template_check univs usubst params ((arity,lc),(indices,splayed_lc),univ_info) =
  let arity = Vars.subst_univs_level_constr usubst arity in
  let lc = Array.map (Vars.subst_univs_level_constr usubst) lc in
  let indices = Vars.subst_univs_level_context usubst indices in
  let splayed_lc = Array.map (fun (args,out) -&gt;
      let args = Vars.subst_univs_level_context usubst args in
      let out = Vars.subst_univs_level_constr usubst out in
      args,out)
      splayed_lc
  in
  let ind_univ = Univ.subst_univs_level_universe usubst univ_info.ind_univ in

  let arity = match univ_info.ind_min_univ with
    | None -&gt; RegularArity {mind_user_arity = arity; mind_sort = Sorts.sort_of_univ ind_univ}
    | Some min_univ -&gt;
      let ctx = match univs with
          | Monomorphic ctx -&gt; ctx
          | Polymorphic _ -&gt;
            CErrors.anomaly ~label:&quot;polymorphic_template_ind&quot;
              Pp.(strbrk &quot;Template polymorphism and full polymorphism are incompatible.&quot;) in
      let ctor_levels =
        let add_levels c levels = Univ.LSet.union levels (Vars.universes_of_constr c) in
        let param_levels =
          List.fold_left (fun levels d -&gt; match d with
              | LocalAssum _ -&gt; levels
              | LocalDef (_,b,t) -&gt; add_levels b (add_levels t levels))
            Univ.LSet.empty params
        in
        Array.fold_left
          (fun levels (d,c) -&gt;
             let levels =
               List.fold_left (fun levels d -&gt;
                   Context.Rel.Declaration.fold_constr add_levels d levels)
                 levels d
             in
             add_levels c levels)
          param_levels
          splayed_lc
      in
      let param_levels, concl_levels =
        template_polymorphic_univs ~template_check ~ctor_levels ctx params min_univ
      in
      if template_check &amp;&amp; List.for_all (fun x -&gt; Option.is_empty x) param_levels
         &amp;&amp; Univ.LSet.is_empty concl_levels then
        CErrors.user_err
          Pp.(strbrk &quot;Ill-formed template inductive declaration: not polymorphic on any universe.&quot;)
      else
        TemplateArity {template_param_levels = param_levels; template_level = min_univ}
  in

  let kelim = allowed_sorts univ_info in
  (arity,lc), (indices,splayed_lc), kelim

let typecheck_inductive env (mie:mutual_inductive_entry) =
  let () = match mie.mind_entry_inds with
  | [] -&gt; CErrors.anomaly Pp.(str &quot;empty inductive types declaration.&quot;)
  | _ -&gt; ()
  in
  (* Check unicity of names (redundant with safe_typing's add_field checks) *)
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">mind_check_names mie;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (List.is_empty (Environ.rel_context env));

  let has_template_poly = List.exists (fun oie -&gt; oie.mind_entry_template) mie.mind_entry_inds in

  (* universes *)
  let env_univs =
    match mie.mind_entry_universes with
    | Monomorphic_entry ctx -&gt;
      let env = if has_template_poly then set_universes_lbound env Univ.Level.prop else env in
      push_context_set ctx env
    | Polymorphic_entry (_, ctx) -&gt; push_context ctx env
  in

  (* Params *)
  let env_params, params = Typeops.check_context env_univs mie.mind_entry_params in

  (* Arities *)
  let env_ar, data = List.fold_left_map (check_arity env_params) env_univs mie.mind_entry_inds in
  let env_ar_par = push_rel_context params env_ar in

  (* Constructors *)
  let isrecord = match mie.mind_entry_record with
    | Some (Some _) -&gt; true
    | Some None | None -&gt; false
  in
  let data = List.map2 (fun ind data -&gt;
      check_constructors env_ar_par isrecord params ind.mind_entry_lc data)
      mie.mind_entry_inds data
  in

  let record = mie.mind_entry_record in
  let data, record = match record with
    | None | Some None -&gt; data, record
    | Some (Some _) -&gt;
      if check_record data then
        data, record
      else
        (* if someone tried to declare a record as SProp but it can't
           be primitive we must squash. *)
        let data = List.map (fun (a,b,univs) -&gt;
            a,b,check_univ_leq env_ar_par Univ.Universe.type0m univs)
            data
        in
        data, Some None
  in

  let () = match mie.mind_entry_variance with
    | None -&gt; ()
    | Some variances -&gt;
      check_cumulativity mie.mind_entry_universes variances env_ar params (List.map pi1 data)
  in

  (* Abstract universes *)
  let usubst, univs = Declareops.abstract_universes mie.mind_entry_universes in
  let params = Vars.subst_univs_level_context usubst params in
  let template_check = Environ.check_template env in
  let data = List.map (abstract_packets ~template_check univs usubst params) data in

  let env_ar_par =
    let ctx = Environ.rel_context env_ar_par in
    let ctx = Vars.subst_univs_level_context usubst ctx in
    let env = Environ.pop_rel_context (Environ.nb_rel env_ar_par) env_ar_par in
    Environ.push_rel_context ctx env
  in

  env_ar_par, univs, mie.mind_entry_variance, record, params, Array.of_list data</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#indTyping.ml"><code>IndTyping.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Univ.

Import Term.

Import Constr.

Import Declarations.

Import Environ.

Import Entries.

Import Type_errors.

Import Context.Rel.Declaration.

Definition check_constructors_names
  : Names.Id.__Set.t -&gt; list Names.Id.__Set.elt -&gt; Names.Id.__Set.t :=
  let fix check
    (idset : Names.Id.__Set.t) (function_parameter : list Names.Id.__Set.elt)
    {struct idset} : Names.Id.__Set.t :=
    match function_parameter with
    | [] =&gt; idset
    | cons c cl =&gt;
      if Id.__Set.mem c idset then
        Stdlib.raise extensible_type_value
      else
        check (Id.__Set.add c idset) cl
    end in
  check.

Definition mind_check_names (mie : Entries.mutual_inductive_entry) : unit :=
  let fix check
    (indset : Names.Id.__Set.t) (cstset : Names.Id.__Set.t)
    (function_parameter : list Entries.one_inductive_entry) {struct indset}
    : unit :=
    match function_parameter with
    | [] =&gt; tt
    | cons ind inds =&gt;
      let id := Entries.one_inductive_entry.mind_entry_typename ind in
      let cl := Entries.one_inductive_entry.mind_entry_consnames ind in
      if Id.__Set.mem id indset then
        Stdlib.raise extensible_type_value
      else
        let cstset' := check_constructors_names cstset cl in
        check (Id.__Set.add id indset) cstset' inds
    end in
  check Id.__Set.empty Id.__Set.empty
    (Entries.mutual_inductive_entry.mind_entry_inds mie).

Definition check_subtyping_arity_constructor
  (env : Environ.env) (subst : Constr.types -&gt; Constr.types)
  (arcn : Constr.types) (numparams : Z) (is_arity : bool) : unit :=
  let numchecked := Stdlib.__ref_value 0 in
  let basic_check (ev : Environ.env) (tp : Constr.types) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.op_coloneq numchecked (Z.add (Stdlib.op_exclamation numchecked) 1) in
  let check_typ (typ : Constr.rel_declaration) (typ_env : Environ.env)
    : Environ.env :=
    match typ with
    | Context.Rel.Declaration.LocalAssum _ typ' =&gt;
      (* ❌ Try-with are not handled *)
      try
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (Environ.push_rel typ typ_env)
    | _ =&gt; CErrors.anomaly None None (str &quot;&quot;)
    end in
  let '(typs, codom) := Reduction.dest_prod env arcn in
  let last_env := Context.Rel.fold_outside check_typ typs env in
  if negb is_arity then
    basic_check last_env codom
  else
    tt.

Definition check_cumulativity {A B : Set}
  (univs : Entries.universes_entry) (variances : array Univ.Variance.t)
  (env_ar : Environ.env) (params : Context.Rel.pt A B)
  (data : list (Constr.types * array Constr.types)) : unit :=
  let uctx :=
    match univs with
    | Entries.Monomorphic_entry _ =&gt; Stdlib.raise extensible_type_value
    | Entries.Polymorphic_entry _ uctx =&gt; uctx
    end in
  let instance := UContext.instance uctx in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let numparams := Context.Rel.nhyps params in
  let new_levels :=
    (|Util.Array|).(CArray.ExtS.init) (Instance.length instance)
      (fun i =&gt; make (UGlobal.make DirPath.empty i)) in
  let lmap :=
    (|Util.Array|).(CArray.ExtS.fold_left2)
      (fun lmap =&gt; fun u =&gt; fun u' =&gt; LMap.add u u' lmap) LMap.empty
      (Instance.to_array instance) new_levels in
  let dosubst := Vars.subst_univs_level_constr lmap in
  let instance_other := Instance.of_array new_levels in
  let constraints_other :=
    Univ.subst_univs_level_constraints lmap (UContext.constraints uctx) in
  let uctx_other := Univ.UContext.make (instance_other, constraints_other) in
  let env := Environ.push_context None uctx_other env_ar in
  let subtyp_constraints :=
    Univ.enforce_leq_variance_instances variances instance instance_other
      Constraint.empty in
  let env := Environ.add_constraints subtyp_constraints env in
  (|Util.List|).(CList.ExtS.iter)
    (fun function_parameter =&gt;
      let '(arity, lc) := function_parameter in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (|Util.Array|).(CArray.ExtS.iter)
        (fun cnt =&gt;
          check_subtyping_arity_constructor env dosubst cnt numparams false) lc)
    data.

Module univ_info.
  Record record := {
    ind_squashed : bool;
    ind_has_relevant_arg : bool;
    ind_min_univ : option Univ.Universe.t;
    ind_univ : Univ.Universe.t }.
  Definition with_ind_squashed (r : record) ind_squashed : record :=
    {| ind_squashed := ind_squashed;
      ind_has_relevant_arg := ind_has_relevant_arg r;
      ind_min_univ := ind_min_univ r; ind_univ := ind_univ r |}.
  Definition with_ind_has_relevant_arg (r : record) ind_has_relevant_arg
    : record :=
    {| ind_squashed := ind_squashed r;
      ind_has_relevant_arg := ind_has_relevant_arg;
      ind_min_univ := ind_min_univ r; ind_univ := ind_univ r |}.
  Definition with_ind_min_univ (r : record) ind_min_univ : record :=
    {| ind_squashed := ind_squashed r;
      ind_has_relevant_arg := ind_has_relevant_arg r;
      ind_min_univ := ind_min_univ; ind_univ := ind_univ r |}.
  Definition with_ind_univ (r : record) ind_univ : record :=
    {| ind_squashed := ind_squashed r;
      ind_has_relevant_arg := ind_has_relevant_arg r;
      ind_min_univ := ind_min_univ r; ind_univ := ind_univ |}.
End univ_info.
Definition univ_info := univ_info.record.

Definition check_univ_leq (op_staroptstar : option bool)
  : Environ.env -&gt; Univ.Universe.t -&gt; univ_info -&gt; univ_info :=
  let is_real_arg :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun env =&gt;
    fun u =&gt;
      fun info =&gt;
        let ind_univ := univ_info.ind_univ info in
        let info :=
          if
            andb (negb (univ_info.ind_has_relevant_arg info))
              (andb is_real_arg (negb (Univ.Universe.is_sprop u))) then
            univ_info.with_ind_has_relevant_arg info true
          else
            info in
        if
          orb (type_in_type env)
            (orb (Univ.Universe.is_sprop u)
              (UGraph.check_leq (universes env) u ind_univ)) then
          univ_info.with_ind_min_univ info
            (Option.map (Universe.sup u) (univ_info.ind_min_univ info))
        else
          if is_impredicative_univ env ind_univ then
            if Option.is_empty (univ_info.ind_min_univ info) then
              univ_info.with_ind_squashed info true
            else
              Stdlib.raise extensible_type_value
          else
            Stdlib.raise extensible_type_value.

Definition check_context_univs
  (ctor : bool) (env : Environ.env) (info : univ_info)
  (ctx : Context.Rel.pt Constr.constr Constr.types) : univ_info :=
  let check_one
    (d : Constr.rel_declaration) (function_parameter : univ_info * Environ.env)
    : univ_info * Environ.env :=
    let '(info, env) := function_parameter in
    let info :=
      match d with
      | Context.Rel.Declaration.LocalAssum _ t =&gt;
        let tj := Typeops.infer_type env t in
        check_univ_leq (Some ctor) env
          (Sorts.univ_of_sort (Environ.punsafe_type_judgment.utj_type tj)) info
      | Context.Rel.Declaration.LocalDef _ _ _ =&gt; info
      end in
    (info, (push_rel d env)) in
  fst (Context.Rel.fold_outside check_one ctx (info, env)).

Definition check_indices_matter
  (env_params : Environ.env) (info : univ_info)
  (indices : Context.Rel.pt Constr.constr Constr.types) : univ_info :=
  if negb (indices_matter env_params) then
    info
  else
    check_context_univs false env_params info indices.

Definition check_arity
  (env_params : Environ.env) (env_ar : Environ.env)
  (ind : Entries.one_inductive_entry)
  : Environ.env * (Constr.types * Constr.rel_context * univ_info) :=
  let '{|
    Environ.punsafe_type_judgment.utj_val := arity;
      Environ.punsafe_type_judgment.utj_type := _
      |} :=
    Typeops.infer_type env_params
      (Entries.one_inductive_entry.mind_entry_arity ind) in
  let '(indices, ind_sort) := Reduction.dest_arity env_params arity in
  let ind_min_univ :=
    if Entries.one_inductive_entry.mind_entry_template ind then
      Some Universe.type0m
    else
      None in
  let univ_info :=
    {| univ_info.ind_squashed := false; univ_info.ind_has_relevant_arg := false;
      univ_info.ind_min_univ := ind_min_univ;
      univ_info.ind_univ := Sorts.univ_of_sort ind_sort |} in
  let univ_info := check_indices_matter env_params univ_info indices in
  let arity := it_mkProd_or_LetIn arity (Environ.rel_context env_params) in
  let x :=
    Context.make_annot
      (Names.Name (Entries.one_inductive_entry.mind_entry_typename ind))
      (Sorts.relevance_of_sort ind_sort) in
  ((push_rel (Context.Rel.Declaration.LocalAssum x arity) env_ar),
    (arity, indices, univ_info)).

Definition check_constructor_univs {A : Set}
  (env_ar_par : Environ.env) (info : univ_info)
  (function_parameter : Context.Rel.pt Constr.constr Constr.types * A)
  : univ_info :=
  let '(args, _) := function_parameter in
  check_context_univs true env_ar_par info args.

Definition check_constructors {A B : Set}
  (env_ar_par : Environ.env) (isrecord : bool) (params : Constr.rel_context)
  (lc : list Constr.types) (function_parameter : A * B * univ_info)
  : (A * array Constr.types) * (B * array (Constr.rel_context * Constr.types)) *
    univ_info :=
  let '(arity, indices, univ_info) := function_parameter in
  let lc :=
    (|Util.Array|).(CArray.ExtS.map_of_list)
      (fun c =&gt;
        Environ.punsafe_type_judgment.utj_val (Typeops.infer_type env_ar_par c))
      lc in
  let splayed_lc :=
    (|Util.Array|).(CArray.ExtS.map) (Reduction.dest_prod_assum env_ar_par) lc
    in
  let univ_info :=
    match
      (((|Util.Array|).(CArray.ExtS.length) lc),
        match (|Util.Array|).(CArray.ExtS.length) lc with
        | 1 =&gt; isrecord
        | _ =&gt; false
        end) with
    | (0, _) =&gt; univ_info
    | (1, true) =&gt; univ_info
    | (1, _) =&gt; check_univ_leq None env_ar_par Univ.Universe.type0m univ_info
    | (_, _) =&gt; check_univ_leq None env_ar_par Univ.Universe.type0 univ_info
    end in
  let univ_info :=
    (|Util.Array|).(CArray.ExtS.fold_left) (check_constructor_univs env_ar_par)
      univ_info splayed_lc in
  let lc :=
    (|Util.Array|).(CArray.ExtS.map) (fun c =&gt; Term.it_mkProd_or_LetIn c params)
      lc in
  ((arity, lc), (indices, splayed_lc), univ_info).

Definition check_record {A B C D E : Set}
  (data :
    list
      (A * (B * array (list (Context.Rel.Declaration.pt C D) * E)) * univ_info))
  : bool :=
  (|Util.List|).(CList.ExtS.for_all)
    (fun function_parameter =&gt;
      let '(_, (_, splayed_lc), info) := function_parameter in
      andb (negb (univ_info.ind_squashed info))
        (andb
          (orb (Univ.Universe.is_sprop (univ_info.ind_univ info))
            (univ_info.ind_has_relevant_arg info))
          match splayed_lc with
          | ((ctx, _)) =&gt;
            let D := Context.Rel.Declaration in
            andb ((|Util.List|).(CList.ExtS.__exists) D.is_local_assum ctx)
              ((|Util.List|).(CList.ExtS.for_all)
                (fun d =&gt;
                  orb (negb (D.is_local_assum d))
                    (negb (Name.is_anonymous (D.get_name d)))) ctx)
          | _ =&gt; false
          end)) data.

Definition all_sorts : list Term.sorts_family :=
  [ Term.InSProp; Term.InProp; Term.InSet; Term.InType ].

Definition small_sorts : list Term.sorts_family :=
  [ Term.InSProp; Term.InProp; Term.InSet ].

Definition logical_sorts : list Term.sorts_family :=
  [ Term.InSProp; Term.InProp ].

Definition sprop_sorts : list Term.sorts_family := [ Term.InSProp ].

Definition allowed_sorts (function_parameter : univ_info)
  : list Term.sorts_family :=
  let '{|
    univ_info.ind_squashed := ind_squashed;
      univ_info.ind_has_relevant_arg := _;
      univ_info.ind_min_univ := _;
      univ_info.ind_univ := ind_univ
      |} := function_parameter in
  if negb ind_squashed then
    all_sorts
  else
    match Sorts.family (Sorts.sort_of_univ ind_univ) with
    | Term.InType =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    | Term.InSet =&gt; small_sorts
    | Term.InProp =&gt; logical_sorts
    | Term.InSProp =&gt; sprop_sorts
    end.

Definition unbounded_from_below (u : Univ.Level.t) (cstrs : Univ.Constraint.t)
  : bool :=
  Univ.Constraint.for_all
    (fun function_parameter =&gt;
      let '(l, d, r) := function_parameter in
      match d with
      | Univ.Eq =&gt;
        andb (negb (Univ.Level.equal l u)) (negb (Univ.Level.equal r u))
      | Univ.Lt | Univ.Le =&gt; negb (Univ.Level.equal r u)
      end) cstrs.

Definition template_polymorphic_univs {A : Set}
  (template_check : bool) (ctor_levels : Univ.LSet.t) (uctx : Univ.ContextSet.t)
  (paramsctxt : list (Context.Rel.Declaration.pt A Constr.types))
  (concl : Univ.Universe.t) : list (option Univ.Level.t) * Univ.LSet.t :=
  let check_level (l : Univ.LSet.elt) : option Univ.LSet.elt :=
    if
      andb (Univ.LSet.mem l (Univ.ContextSet.levels uctx))
        (andb (unbounded_from_below l (Univ.ContextSet.constraints uctx))
          (negb (Univ.LSet.mem l ctor_levels))) then
      Some l
    else
      None in
  let univs := Univ.Universe.levels concl in
  let univs :=
    if template_check then
      Univ.LSet.filter
        (fun l =&gt; orb (Option.has_some (check_level l)) (Univ.Level.is_prop l))
        univs
    else
      univs in
  let fold {B : Set}
    (acc : list (option Univ.Level.t))
    (function_parameter : Context.Rel.Declaration.pt B Constr.types)
    : list (option Univ.Level.t) :=
    match function_parameter with
    | Context.Rel.Declaration.LocalAssum _ p =&gt;
      cons
        (let c := Term.strip_prod_assum p in
        match kind c with
        | Constr.Sort (Term.Type u) =&gt;
          if template_check then
            match Univ.Universe.level u with
            | Some l =&gt;
              if andb (Univ.LSet.mem l univs) (negb (Univ.Level.is_prop l)) then
                Some l
              else
                None
            | None =&gt; None
            end
          else
            Univ.Universe.level u
        | _ =&gt; None
        end) acc
    | Context.Rel.Declaration.LocalDef _ _ _ =&gt; acc
    end in
  let params := (|Util.List|).(CList.ExtS.fold_left) fold [] paramsctxt in
  (params, univs).

Definition abstract_packets
  (template_check : bool) (univs : Declarations.universes)
  (usubst : Univ.universe_level_subst)
  (params : list (Context.Rel.Declaration.pt Constr.constr Constr.types))
  (function_parameter :
    (Constr.constr * array Constr.constr) *
      (Constr.rel_context * array (Constr.rel_context * Constr.constr)) *
      univ_info)
  : (Declarations.declaration_arity Declarations.regular_inductive_arity
    Declarations.template_arity * array Constr.constr) *
    (Constr.rel_context * array (Constr.rel_context * Constr.constr)) *
    list Term.sorts_family :=
  let '((arity, lc), (indices, splayed_lc), univ_info) := function_parameter in
  let arity := Vars.subst_univs_level_constr usubst arity in
  let lc :=
    (|Util.Array|).(CArray.ExtS.map) (Vars.subst_univs_level_constr usubst) lc
    in
  let indices := Vars.subst_univs_level_context usubst indices in
  let splayed_lc :=
    (|Util.Array|).(CArray.ExtS.map)
      (fun function_parameter =&gt;
        let '(args, out) := function_parameter in
        let args := Vars.subst_univs_level_context usubst args in
        let out := Vars.subst_univs_level_constr usubst out in
        (args, out)) splayed_lc in
  let ind_univ :=
    Univ.subst_univs_level_universe usubst (univ_info.ind_univ univ_info) in
  let arity :=
    match univ_info.ind_min_univ univ_info with
    | None =&gt;
      Declarations.RegularArity
        {| Declarations.regular_inductive_arity.mind_user_arity := arity;
          Declarations.regular_inductive_arity.mind_sort :=
            Sorts.sort_of_univ ind_univ |}
    | Some min_univ =&gt;
      let ctx :=
        match univs with
        | Declarations.Monomorphic ctx =&gt; ctx
        | Declarations.Polymorphic _ =&gt;
          CErrors.anomaly None (Some &quot;polymorphic_template_ind&quot;)
            (strbrk
              &quot;Template polymorphism and full polymorphism are incompatible.&quot;)
        end in
      let ctor_levels :=
        let add_levels (c : Constr.constr) (levels : Univ.LSet.t)
          : Univ.LSet.t :=
          Univ.LSet.union levels (Vars.universes_of_constr c) in
        let param_levels :=
          (|Util.List|).(CList.ExtS.fold_left)
            (fun levels =&gt;
              fun d =&gt;
                match d with
                | Context.Rel.Declaration.LocalAssum _ _ =&gt; levels
                | Context.Rel.Declaration.LocalDef _ b t =&gt;
                  add_levels b (add_levels t levels)
                end) Univ.LSet.empty params in
        (|Util.Array|).(CArray.ExtS.fold_left)
          (fun levels =&gt;
            fun function_parameter =&gt;
              let '(d, c) := function_parameter in
              let levels :=
                (|Util.List|).(CList.ExtS.fold_left)
                  (fun levels =&gt;
                    fun d =&gt;
                      Context.Rel.Declaration.fold_constr add_levels d levels)
                  levels d in
              add_levels c levels) param_levels splayed_lc in
      let '(param_levels, concl_levels) :=
        template_polymorphic_univs template_check ctor_levels ctx params
          min_univ in
      if
        andb template_check
          (andb
            ((|Util.List|).(CList.ExtS.for_all) (fun x =&gt; Option.is_empty x)
              param_levels) (Univ.LSet.is_empty concl_levels)) then
        CErrors.user_err None None
          (strbrk
            &quot;Ill-formed template inductive declaration: not polymorphic on any universe.&quot;)
      else
        Declarations.TemplateArity
          {| Declarations.template_arity.template_param_levels := param_levels;
            Declarations.template_arity.template_level := min_univ |}
    end in
  let kelim := allowed_sorts univ_info in
  ((arity, lc), (indices, splayed_lc), kelim).

Definition typecheck_inductive
  (env : Environ.env) (mie : Entries.mutual_inductive_entry)
  : Environ.env * Declarations.universes * option (array Univ.Variance.t) *
    option (option (array Names.Id.t)) * Constr.rel_context *
    array
      ((Declarations.declaration_arity Declarations.regular_inductive_arity
        Declarations.template_arity * array Constr.constr) *
        (Constr.rel_context * array (Constr.rel_context * Constr.constr)) *
        list Term.sorts_family) :=
  let '_ :=
    match Entries.mutual_inductive_entry.mind_entry_inds mie with
    | [] =&gt; CErrors.anomaly None None (str &quot;empty inductive types declaration.&quot;)
    | _ =&gt; tt
    end in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let has_template_poly :=
    (|Util.List|).(CList.ExtS.__exists)
      (fun oie =&gt; Entries.one_inductive_entry.mind_entry_template oie)
      (Entries.mutual_inductive_entry.mind_entry_inds mie) in
  let env_univs :=
    match Entries.mutual_inductive_entry.mind_entry_universes mie with
    | Entries.Monomorphic_entry ctx =&gt;
      let env :=
        if has_template_poly then
          set_universes_lbound env Univ.Level.prop
        else
          env in
      push_context_set None ctx env
    | Entries.Polymorphic_entry _ ctx =&gt; push_context None ctx env
    end in
  let '(env_params, params) :=
    Typeops.check_context env_univs
      (Entries.mutual_inductive_entry.mind_entry_params mie) in
  let '(env_ar, data) :=
    (|Util.List|).(CList.ExtS.fold_left_map) (check_arity env_params) env_univs
      (Entries.mutual_inductive_entry.mind_entry_inds mie) in
  let env_ar_par := push_rel_context params env_ar in
  let isrecord :=
    match Entries.mutual_inductive_entry.mind_entry_record mie with
    | Some (Some _) =&gt; true
    | Some None | None =&gt; false
    end in
  let data :=
    (|Util.List|).(CList.ExtS.map2)
      (fun ind =&gt;
        fun data =&gt;
          check_constructors env_ar_par isrecord params
            (Entries.one_inductive_entry.mind_entry_lc ind) data)
      (Entries.mutual_inductive_entry.mind_entry_inds mie) data in
  let record := Entries.mutual_inductive_entry.mind_entry_record mie in
  let '(data, record) :=
    match record with
    | None | Some None =&gt; (data, record)
    | Some (Some _) =&gt;
      if check_record data then
        (data, record)
      else
        let data :=
          (|Util.List|).(CList.ExtS.map)
            (fun function_parameter =&gt;
              let '(a, b, univs) := function_parameter in
              (a, b, (check_univ_leq None env_ar_par Univ.Universe.type0m univs)))
            data in
        (data, (Some None))
    end in
  let '_ :=
    match Entries.mutual_inductive_entry.mind_entry_variance mie with
    | None =&gt; tt
    | Some variances =&gt;
      check_cumulativity
        (Entries.mutual_inductive_entry.mind_entry_universes mie) variances
        env_ar params ((|Util.List|).(CList.ExtS.map) pi1 data)
    end in
  let '(usubst, univs) :=
    Declareops.abstract_universes
      (Entries.mutual_inductive_entry.mind_entry_universes mie) in
  let params := Vars.subst_univs_level_context usubst params in
  let template_check := Environ.check_template env in
  let data :=
    (|Util.List|).(CList.ExtS.map)
      (abstract_packets template_check univs usubst params) data in
  let env_ar_par :=
    let ctx := Environ.rel_context env_ar_par in
    let ctx := Vars.subst_univs_level_context usubst ctx in
    let env := Environ.pop_rel_context (Environ.nb_rel env_ar_par) env_ar_par in
    Environ.push_rel_context ctx env in
  (env_ar_par, univs, (Entries.mutual_inductive_entry.mind_entry_variance mie),
    record, params, ((|Util.Array|).(CArray.ExtS.of_list) data)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="indTyping.mli">
  <div style="margin: 20px;">
    <h3>IndTyping_mli</h3>
    <ul>
      <li>OCaml size: 45 lines</li>
      <li>Coq size: 23 lines (-49% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#indTyping.mli"><code>indTyping.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Environ
open Entries
open Declarations

(** Type checking for some inductive entry.
    Returns:
    - environment with inductives + parameters in rel context
    - abstracted universes
    - checked variance info
    - record entry (checked to be OK)
    - parameters
    - for each inductive,
      (arity * constructors) (with params)
      * (indices * splayed constructor types) (both without params)
      * allowed eliminations
 *)
val typecheck_inductive : env -&gt; mutual_inductive_entry -&gt;
  env
  * universes * Univ.Variance.t array option
  * Names.Id.t array option option
  * Constr.rel_context
  * ((inductive_arity * Constr.types array) *
     (Constr.rel_context * (Constr.rel_context * Constr.types) array) *
     Sorts.family list)
    array

(* Utility function to compute the actual universe parameters
   of a template polymorphic inductive *)
val template_polymorphic_univs :
  template_check:bool -&gt;
  ctor_levels:Univ.LSet.t -&gt;
  Univ.ContextSet.t -&gt;
  Constr.rel_context -&gt;
  Univ.Universe.t -&gt;
  Univ.Level.t option list * Univ.LSet.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#indTyping.mli"><code>IndTyping_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter typecheck_inductive :
  Environ.env -&gt; Entries.mutual_inductive_entry -&gt;
  Environ.env * Declarations.universes * option (array Univ.Variance.t) *
    option (option (array Names.Id.t)) * Constr.rel_context *
    array
      ((Declarations.inductive_arity * array Constr.types) *
        (Constr.rel_context * array (Constr.rel_context * Constr.types)) *
        list Sorts.family).

Parameter template_polymorphic_univs :
  bool -&gt; Univ.LSet.t -&gt; Univ.ContextSet.t -&gt; Constr.rel_context -&gt;
  Univ.Universe.t -&gt; list (option Univ.Level.t) * Univ.LSet.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="indtypes.ml">
  <div style="margin: 20px;">
    <h3>Indtypes</h3>
    <ul>
      <li>OCaml size: 573 lines</li>
      <li>Coq size: 784 lines (+36% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#indtypes.ml"><code>indtypes.ml</code></a>&nbsp;<span class="label label-warning">28 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Util
open Names
open Term
open Constr
open Vars
open Declarations
open Declareops
open Inductive
open Environ
open Reduction
open Entries
open Context.Rel.Declaration

(* Terminology:
paramdecls (ou paramsctxt?)
args = params + realargs (called vargs when an array, largs when a list)
params = recparams + nonrecparams
nonrecargs = nonrecparams + realargs
env_ar = initial env + declaration of inductive types
env_ar_par = env_ar + declaration of parameters
nmr = ongoing computation of recursive parameters
*)

(* [weaker_noccur_between env n nvars t] (defined above), checks that
   no de Bruijn indices between [n] and [n+nvars] occur in [t]. If
   some such occurrences are found, then reduction is performed
   (lazily for efficiency purposes) in order to determine whether
   these occurrences are occurrences in the normal form. If the
   occurrences are eliminated a witness reduct [Some t'] of [t] is
   returned otherwise [None] is returned. *)
let weaker_noccur_between env x nvars t =
  if noccur_between x nvars t then Some t
  else
   let t' = whd_all env t in
   if noccur_between x nvars t' then Some t'
   else None

(************************************************************************)
(* Various well-formedness check for inductive declarations            *)

(* Errors related to inductive constructions *)
type inductive_error = Type_errors.inductive_error =
  | NonPos of env * constr * constr
  | NotEnoughArgs of env * constr * constr
  | NotConstructor of env * Id.t * constr * constr * int * int
  | NonPar of env * constr * int * constr * constr
  | SameNamesTypes of Id.t
  | SameNamesConstructors of Id.t
  | SameNamesOverlap of Id.t list
  | NotAnArity of env * constr
  | BadEntry
  | LargeNonPropInductiveNotInType
  | BadUnivs

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception InductiveError = Type_errors.InductiveError</abbr>

(************************************************************************)
(************************************************************************)
(* Positivity *)

type ill_formed_ind =
  | LocalNonPos of int
  | LocalNotEnoughArgs of int
  | LocalNotConstructor of Constr.rel_context * int
  | LocalNonPar of int * int * int

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception IllFormedInd of ill_formed_ind</abbr>

(* [mind_extract_params mie] extracts the params from an inductive types
   declaration, and checks that they are all present (and all the same)
   for all the given types. *)

let mind_extract_params = decompose_prod_n_assum

let explain_ind_err id ntyp env nparamsctxt c err =
  let (_lparams,c') = mind_extract_params nparamsctxt c in
  match err with
    | LocalNonPos kt -&gt;
        raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError (NonPos (env,c',mkRel (kt+nparamsctxt))))</abbr>
    | LocalNotEnoughArgs kt -&gt;
        raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError
                 (NotEnoughArgs (env,c',mkRel (kt+nparamsctxt))))</abbr>
    | LocalNotConstructor (paramsctxt,nargs)-&gt;
        let nparams = Context.Rel.nhyps paramsctxt in
        raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError
                 (NotConstructor (env,id,c',mkRel (ntyp+nparamsctxt),
                                  nparams,nargs)))</abbr>
    | LocalNonPar (n,i,l) -&gt;
        raise <abbr class="mark-warning" title="Values of extensible types are not handled">(InductiveError
                 (NonPar (env,c',n,mkRel i,mkRel (l+nparamsctxt))))</abbr>

let failwith_non_pos n ntypes c =
  <abbr class="mark-warning" title="For loops not handled.">for k = n to n + ntypes - 1 do
    if not (noccurn k c) then raise (IllFormedInd (LocalNonPos (k-n+1)))
  done</abbr>

let failwith_non_pos_vect n ntypes v =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (failwith_non_pos n ntypes) v;
  anomaly ~label:&quot;failwith_non_pos_vect&quot; (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot;)</abbr>

let failwith_non_pos_list n ntypes l =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">List.iter (failwith_non_pos n ntypes) l;
  anomaly ~label:&quot;failwith_non_pos_list&quot; (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot;)</abbr>

(* Check the inductive type is called with the expected parameters *)
(* [n] is the index of the last inductive type in [env] *)
let check_correct_par (env,n,ntypes,_) paramdecls ind_index args =
  let nparams = Context.Rel.nhyps paramdecls in
  let args = Array.of_list args in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Array.length args &lt; nparams then
    raise (IllFormedInd (LocalNotEnoughArgs ind_index));
  let (params,realargs) = Array.chop nparams args in
  let nparamdecls = List.length paramdecls in
  let rec check param_index paramdecl_index = function
    | [] -&gt; ()
    | LocalDef _ :: paramdecls -&gt;
      check param_index (paramdecl_index+1) paramdecls
    | _::paramdecls -&gt;
        match kind (whd_all env params.(param_index)) with
          | Rel w when Int.equal w paramdecl_index -&gt;
            check (param_index-1) (paramdecl_index+1) paramdecls
          | _ -&gt;
            let paramdecl_index_in_env = paramdecl_index-n+nparamdecls+1 in
            let err =
              LocalNonPar (param_index+1, paramdecl_index_in_env, ind_index) in
            raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">(IllFormedInd err)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  in </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (nparams-1) (n-nparamdecls) paramdecls;
  if not (Array.for_all (noccur_between n ntypes) realargs) then
    failwith_non_pos_vect n ntypes realargs</abbr>

(* Computes the maximum number of recursive parameters:
   the first parameters which are constant in recursive arguments
   [n] is the current depth, [nmr] is the maximum number of possible
   recursive parameters *)

let compute_rec_par (env,n,_,_) paramsctxt nmr largs =
if Int.equal nmr 0 then 0 else
(* start from 0, params will be in reverse order *)
  let (lpar,_) = List.chop nmr largs in
  let rec find k index =
      function
          ([],_) -&gt; nmr
        | (_,[]) -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* |paramsctxt|&gt;=nmr *)
        | (lp, LocalDef _ :: paramsctxt) -&gt; find k (index-1) (lp,paramsctxt)
        | (p::lp,_::paramsctxt) -&gt;
       ( match kind (whd_all env p) with
          | Rel w when Int.equal w index -&gt; find (k+1) (index-1) (lp,paramsctxt)
          | _ -&gt; k)
  in find 0 (n-1) (lpar,List.rev paramsctxt)

(* [env] is the typing environment
   [n] is the dB of the last inductive type
   [ntypes] is the number of inductive types in the definition
     (i.e. range of inductives is [n; n+ntypes-1])
   [lra] is the list of recursive tree of each variable
 *)
let ienv_push_var (env, n, ntypes, lra) (x,a,ra) =
  (push_rel (LocalAssum (x,a)) env, n+1, ntypes, (Norec,ra)::lra)

let ienv_push_inductive (env, n, ntypes, ra_env) ((mi,u),lrecparams) =
  let auxntyp = 1 in
  let specif = (lookup_mind_specif env mi, u) in
  let ty = type_of_inductive env specif in
  let env' =
    let r = (snd (fst specif)).mind_relevance in
    let anon = Context.make_annot Anonymous r in
    let decl = LocalAssum (anon, hnf_prod_applist env ty lrecparams) in
    push_rel decl env in
  let ra_env' =
    (Imbr mi,(Rtree.mk_rec_calls 1).(0)) ::
    List.map (fun (r,t) -&gt; (r,Rtree.lift 1 t)) ra_env in
  (* New index of the inductive types *)
  let newidx = n + auxntyp in
  (env', newidx, ntypes, ra_env')

let rec ienv_decompose_prod (env,_,_,_ as ienv) n c =
  if Int.equal n 0 then (ienv,c) else
    let c' = whd_all env c in
    match kind c' with
        Prod(na,a,b) -&gt;
          let ienv' = ienv_push_var ienv (na,a,mk_norec) in
          ienv_decompose_prod ienv' (n-1) b
      | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let array_min nmr a = if Int.equal nmr 0 then 0 else
  Array.fold_left (fun k (nmri,_) -&gt; min k nmri) nmr a

(** [check_positivity_one ienv paramsctxt (mind,i) nnonrecargs lcnames indlc]
    checks the positivity of the [i]-th member of the mutually
    inductive definition [mind]. It returns an [Rtree.t] which
    represents the position of the recursive calls of inductive in [i]
    for use by the guard condition (terms at these positions are
    considered sub-terms) as well as the number of of non-uniform
    arguments (used to generate induction schemes, so a priori less
    relevant to the kernel).

    If [chkpos] is [false] then positivity is assumed, and
    [check_positivity_one] computes the subterms occurrences in a
    best-effort fashion. *)
let check_positivity_one ~chkpos recursive (env,_,ntypes,_ as ienv) paramsctxt (_,i as ind) nnonrecargs lcnames indlc =
  let nparamsctxt = Context.Rel.length paramsctxt in
  let nmr = Context.Rel.nhyps paramsctxt in
  (** Positivity of one argument [c] of a constructor (i.e. the
      constructor [cn] has a type of the shape [â¦ -&gt; c â¦ -&gt; P], where,
      more generally, the arrows may be dependent). *)
  <abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">let rec check_pos (env, n, ntypes, ra_env as ienv) nmr c =
    let x,largs = decompose_app (whd_all env c) in
      match kind x with
        | Prod (na,b,d) -&gt;
            let () = </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Assert instruction is not handled.">assert (List.is_empty largs)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
            (** If one of the inductives of the mutually inductive
                block occurs in the left-hand side of a product, then
                such an occurrence is a non-strictly-positive
                recursive call. Occurrences in the right-hand side of
                the product must be strictly positive.*)
            (match weaker_noccur_between env n ntypes b with
              | None when chkpos -&gt;
                  failwith_non_pos_list n ntypes [b]
              | None -&gt;
                  check_pos (ienv_push_var ienv (na, b, mk_norec)) nmr d
              | Some b -&gt;
                  check_pos (ienv_push_var ienv (na, b, mk_norec)) nmr d)
        | Rel k -&gt;
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try let (ra,rarg) = List.nth ra_env (k-1) in
            let largs = List.map (whd_all env) largs in
            let nmr1 =
              (match ra with
                  Mrec _ -&gt; compute_rec_par ienv paramsctxt nmr largs
                |  _ -&gt; nmr)
            in
              (** The case where one of the inductives of the mutually
                  inductive block occurs as an argument of another is not
                  known to be safe. So Coq rejects it. *)
              if chkpos &amp;&amp;
                 not (List.for_all (noccur_between n ntypes) largs)
              then failwith_non_pos_list n ntypes largs
              else (nmr1,rarg)
              with Failure _ | Invalid_argument _ -&gt; (nmr,mk_norec))</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
        | Ind ind_kn -&gt;
            (** If one of the inductives of the mutually inductive
                block being defined appears in a parameter, then we
                have a nested inductive type. The positivity is then
                discharged to the [check_positive_nested] function. *)
            if List.for_all (noccur_between n ntypes) largs then (nmr,mk_norec)
            else check_positive_nested ienv nmr (ind_kn, largs)
        | _err -&gt;
            (** If an inductive of the mutually inductive block
                appears in any other way, then the positivy check gives
                up. *)
            if not chkpos ||
              (noccur_between n ntypes x &amp;&amp;
               List.for_all (noccur_between n ntypes) largs)
            then (nmr,mk_norec)
            else failwith_non_pos_list n ntypes (x::largs)

  (** [check_positive_nested] handles the case of nested inductive
      calls, that is, when an inductive types from the mutually
      inductive block is called as an argument of an inductive types
      (for the moment, this inductive type must be a previously
      defined types, not one of the types of the mutually inductive
      block being defined). *)
  (* accesses to the environment are not factorised, but is it worth? *)
  and check_positive_nested (env,n,ntypes,_ra_env as ienv) nmr ((mi,u), largs) =
    let (mib,mip) = lookup_mind_specif env mi in
    let auxnrecpar = mib.mind_nparams_rec in
    let auxnnonrecpar = mib.mind_nparams - auxnrecpar in
    let (auxrecparams,auxnonrecargs) =
      </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try List.chop auxnrecpar largs
      with Failure _ -&gt; raise (IllFormedInd (LocalNonPos n))</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in

      (** Inductives of the inductive block being defined are only
          allowed to appear nested in the parameters of another inductive
          type. Not in the proper indices. *)
      </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if chkpos &amp;&amp; not (List.for_all (noccur_between n ntypes) auxnonrecargs) then
        failwith_non_pos_list n ntypes auxnonrecargs;
      (* Nested mutual inductive types are not supported *)
      let auxntyp = mib.mind_ntypes in
        </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (Int.equal auxntyp 1) then raise (IllFormedInd (LocalNonPos n));
        (* The nested inductive type with parameters removed *)
        let auxlcvect = abstract_mind_lc auxntyp auxnrecpar mip.mind_nf_lc in
          (* Extends the environment with a variable corresponding to
             the inductive def *)
        let (env',_,_,_ as ienv') = ienv_push_inductive ienv ((mi,u),auxrecparams) in
          (* Parameters expressed in env' *)
        let auxrecparams' = List.map (lift auxntyp) auxrecparams in
        let irecargs_nmr =
          (** Checks that the &quot;nesting&quot; inductive type is covariant in
              the relevant parameters. In other words, that the
              (nested) parameters which are instantiated with
              inductives of the mutually inductive block occur
              positively in the types of the nested constructors. *)
          Array.map
            (function c -&gt;
              let c' = hnf_prod_applist env' c auxrecparams' in
              (* skip non-recursive parameters *)
              let (ienv',c') = ienv_decompose_prod ienv' auxnnonrecpar c' in
                check_constructors ienv' false nmr c')
            auxlcvect
        in
        let irecargs = Array.map snd irecargs_nmr
        and nmr' = array_min nmr irecargs_nmr
        in
          (nmr',(Rtree.mk_rec </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|mk_paths (Imbr mi) irecargs|]</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">).(0))</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

  (** [check_constructors ienv check_head nmr c] checks the positivity
      condition in the type [c] of a constructor (i.e. that recursive
      calls to the inductives of the mutually inductive definition
      appear strictly positively in each of the arguments of the
      constructor, see also [check_pos]). If [check_head] is [true],
      then the type of the fully applied constructor (the &quot;head&quot; of
      the type [c]) is checked to be the right (properly applied)
      inductive type. *)
  and check_constructors ienv check_head nmr c =
    let rec check_constr_rec (env,n,ntypes,_ra_env as ienv) nmr lrec c =
      let x,largs = decompose_app (whd_all env c) in
        match kind x with

          | Prod (na,b,d) -&gt;
              let () = </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Assert instruction is not handled.">assert (List.is_empty largs)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
              </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not recursive &amp;&amp; not (noccur_between n ntypes b) then
                raise (InductiveError BadEntry);
              let nmr',recarg = check_pos ienv nmr b in
              let ienv' = ienv_push_var ienv (na,b,mk_norec) in
                check_constr_rec ienv' nmr' (recarg::lrec) d</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
          | hd -&gt;
            let () =
              if check_head then
                begin match hd with
                | Rel j when Int.equal j (n + ntypes - i - 1) -&gt;
                  check_correct_par ienv paramsctxt (ntypes - i) largs
                | _ -&gt; raise </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Values of extensible types are not handled">(IllFormedInd (LocalNotConstructor(paramsctxt,nnonrecargs)))</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
                end
              else
                if chkpos &amp;&amp;
                   not (List.for_all (noccur_between n ntypes) largs)
                then failwith_non_pos_list n ntypes largs
            in
            (nmr, List.rev lrec)
    in check_constr_rec ienv nmr [] c
  in
  let irecargs_nmr =
    Array.map2
      (fun id c -&gt;
        let _,rawc = mind_extract_params nparamsctxt c in
          </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
            check_constructors ienv true nmr rawc
          with IllFormedInd err -&gt;
            explain_ind_err id (ntypes-i) env nparamsctxt c err</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">)
      (Array.of_list lcnames) indlc
  in
  let irecargs = Array.map snd irecargs_nmr
  and nmr' = array_min nmr irecargs_nmr
  in (nmr', mk_paths (Mrec ind) irecargs)</abbr>

(** [check_positivity ~chkpos kn env_ar paramsctxt inds] checks that the mutually
    inductive block [inds] is strictly positive.

    If [chkpos] is [false] then positivity is assumed, and
    [check_positivity_one] computes the subterms occurrences in a
    best-effort fashion. *)
let check_positivity ~chkpos kn names env_ar_par paramsctxt finite inds =
  let ntypes = Array.length inds in
  let recursive = finite != BiFinite in
  let rc = Array.mapi (fun j t -&gt; (Mrec (kn,j),t)) (Rtree.mk_rec_calls ntypes) in
  let ra_env_ar = Array.rev_to_list rc in
  let nparamsctxt = Context.Rel.length paramsctxt in
  let nmr = Context.Rel.nhyps paramsctxt in
  let check_one i (_,lcnames) (nindices,lc) =
    let ra_env_ar_par =
      List.init nparamsctxt (fun _ -&gt; (Norec,mk_norec)) @ ra_env_ar in
    let ienv = (env_ar_par, 1+nparamsctxt, ntypes, ra_env_ar_par) in
    check_positivity_one ~chkpos recursive ienv paramsctxt (kn,i) nindices lcnames lc
  in
  let irecargs_nmr = Array.map2_i check_one names inds in
  let irecargs = Array.map snd irecargs_nmr
  and nmr' = array_min nmr irecargs_nmr
  in (nmr',Rtree.mk_rec irecargs)


(************************************************************************)
(************************************************************************)
(* Build the inductive packet *)

let repair_arity indices = function
  | RegularArity ar -&gt; ar.mind_user_arity
  | TemplateArity ar -&gt; mkArity (indices,Sorts.sort_of_univ ar.template_level)

let fold_inductive_blocks f =
  Array.fold_left (fun acc ((arity,lc),(indices,_),_) -&gt;
    f (Array.fold_left f acc lc) (repair_arity indices arity))

let used_section_variables env inds =
  let fold l c = Id.Set.union (Environ.global_vars_set env c) l in
  let ids = fold_inductive_blocks fold Id.Set.empty inds in
  keep_hyps env ids

let rel_vect n m = Array.init m (fun i -&gt; mkRel(n+m-i))
let rel_list n m = Array.to_list (rel_vect n m)

(** From a rel context describing the constructor arguments,
    build an expansion function.
    The term built is expecting to be substituted first by
    a substitution of the form [params, x : ind params] *)
let compute_projections (kn, i as ind) mib =
  let pkt = mib.mind_packets.(i) in
  let u = Univ.make_abstract_instance (Declareops.inductive_polymorphic_context mib) in
  let subst = List.init mib.mind_ntypes (fun i -&gt; mkIndU ((kn, mib.mind_ntypes - i - 1), u)) in
  let (ctx, cty) = pkt.mind_nf_lc.(0) in
  let cty = it_mkProd_or_LetIn cty ctx in
  let rctx, _ = decompose_prod_assum (substl subst cty) in
  let ctx, paramslet = List.chop pkt.mind_consnrealdecls.(0) rctx in
  (** We build a substitution smashing the lets in the record parameters so
      that typechecking projections requires just a substitution and not
      matching with a parameter context. *)
  let paramsletsubst =
    (* [Ind inst] is typed in context [params-wo-let] *)
    let inst' = rel_list 0 mib.mind_nparams in
    (* {params-wo-let |- subst:params] *)
    let subst = subst_of_rel_context_instance paramslet inst' in
    (* {params-wo-let, x:Ind inst' |- subst':(params,x:Ind inst)] *)
    let subst = (* For the record parameter: *)
      mkRel 1 :: List.map (lift 1) subst in
    subst
  in
  let projections decl (i, j, labs, rs, pbs, letsubst) =
    match decl with
    | LocalDef (_na,c,_t) -&gt;
        (* From [params, field1,..,fieldj |- c(params,field1,..,fieldj)]
           to [params, x:I, field1,..,fieldj |- c(params,field1,..,fieldj)] *)
        let c = liftn 1 j c in
        (* From [params, x:I, field1,..,fieldj |- c(params,field1,..,fieldj)]
           to [params-wo-let, x:I |- c(params,proj1 x,..,projj x)] *)
        let c2 = substl letsubst c in
        (* From [params-wo-let, x:I |- subst:(params, x:I, field1,..,fieldj)]
           to [params-wo-let, x:I |- subst:(params, x:I, field1,..,fieldj+1)] *)
        let letsubst = c2 :: letsubst in
        (i, j+1, labs, rs, pbs, letsubst)
    | LocalAssum (na,t) -&gt;
      match na.Context.binder_name with
      | Name id -&gt;
        let r = na.Context.binder_relevance in
        let lab = Label.of_id id in
        let kn = Projection.Repr.make ind ~proj_npars:mib.mind_nparams ~proj_arg:i lab in
        (* from [params, field1,..,fieldj |- t(params,field1,..,fieldj)]
           to [params, x:I, field1,..,fieldj |- t(params,field1,..,fieldj] *)
        let t = liftn 1 j t in
        (* from [params, x:I, field1,..,fieldj |- t(params,field1,..,fieldj)]
           to [params-wo-let, x:I |- t(params,proj1 x,..,projj x)] *)
        let projty = substl letsubst t in
        (* from [params, x:I, field1,..,fieldj |- t(field1,..,fieldj)]
           to [params, x:I |- t(proj1 x,..,projj x)] *)
        let fterm = mkProj (Projection.make kn false, mkRel 1) in
        (i + 1, j + 1, lab :: labs, r :: rs, projty :: pbs, fterm :: letsubst)
      | Anonymous -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* checked by indTyping *)
  in
  let (_, _, labs, rs, pbs, _letsubst) =
    List.fold_right projections ctx (0, 1, [], [], [], paramsletsubst)
  in
  Array.of_list (List.rev labs),
  Array.of_list (List.rev rs),
  Array.of_list (List.rev pbs)

let build_inductive env names prv univs variance paramsctxt kn isrecord isfinite inds nmr recargs =
  let ntypes = Array.length inds in
  (* Compute the set of used section variables *)
  let hyps = used_section_variables env inds in
  let nparamargs = Context.Rel.nhyps paramsctxt in
  (* Check one inductive *)
  let build_one_packet (id,cnames) ((arity,lc),(indices,splayed_lc),kelim) recarg =
    (* Type of constructors in normal form *)
    let nf_lc = Array.map (fun (d, b) -&gt; (d@paramsctxt, b)) splayed_lc in
    let consnrealdecls =
      Array.map (fun (d,_) -&gt; Context.Rel.length d)
        splayed_lc in
    let consnrealargs =
      Array.map (fun (d,_) -&gt; Context.Rel.nhyps d)
        splayed_lc in
    let mind_relevance = match arity with
      | RegularArity { mind_sort;_ } -&gt; Sorts.relevance_of_sort mind_sort
      | TemplateArity _ -&gt; Sorts.Relevant
    in
    (* Assigning VM tags to constructors *)
    let nconst, nblock = ref 0, ref 0 in
    let transf num =
      let arity = List.length (dest_subterms recarg).(num) in
        if Int.equal arity 0 then
          let p  = (!nconst, 0) in
            <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr nconst; p</abbr>
        else
          let p = (!nblock + 1, arity) in
            <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr nblock; p</abbr>
              (* les tag des constructeur constant commence a 0,
                 les tag des constructeur non constant a 1 (0 =&gt; accumulator) *)
    in
    let rtbl = Array.init (List.length cnames) transf in
      (* Build the inductive packet *)
      { mind_typename = id;
        mind_arity = arity;
        mind_arity_ctxt = indices @ paramsctxt;
        mind_nrealargs = Context.Rel.nhyps indices;
        mind_nrealdecls = Context.Rel.length indices;
        mind_kelim = kelim;
        mind_consnames = Array.of_list cnames;
        mind_consnrealdecls = consnrealdecls;
        mind_consnrealargs = consnrealargs;
        mind_user_lc = lc;
        mind_nf_lc = nf_lc;
        mind_recargs = recarg;
        mind_relevance;
        mind_nb_constant = !nconst;
        mind_nb_args = !nblock;
        mind_reloc_tbl = rtbl;
      } in
  let packets = Array.map3 build_one_packet names inds recargs in
  let mib =
      (* Build the mutual inductive *)
    { mind_record = NotRecord;
      mind_ntypes = ntypes;
      mind_finite = isfinite;
      mind_hyps = hyps;
      mind_nparams = nparamargs;
      mind_nparams_rec = nmr;
      mind_params_ctxt = paramsctxt;
      mind_packets = packets;
      mind_universes = univs;
      mind_variance = variance;
      mind_private = prv;
      mind_typing_flags = Environ.typing_flags env;
    }
  in
  let record_info = match isrecord with
  | Some (Some rid) -&gt;
    (** The elimination criterion ensures that all projections can be defined. *)
    let map i id =
      let labs, rs, projs = compute_projections (kn, i) mib in
      (id, labs, rs, projs)
    in
    PrimRecord (Array.mapi map rid)
  | Some None -&gt; FakeRecord
  | None -&gt; NotRecord
  in
  { mib with mind_record = record_info }

(************************************************************************)
(************************************************************************)

let check_inductive env kn mie =
  (* First type-check the inductive definition *)
  let (env_ar_par, univs, variance, record, paramsctxt, inds) = IndTyping.typecheck_inductive env mie in
  (* Then check positivity conditions *)
  let chkpos = (Environ.typing_flags env).check_guarded in
  let names = Array.map_of_list (fun entry -&gt; entry.mind_entry_typename, entry.mind_entry_consnames)
      mie.mind_entry_inds
  in
  let (nmr,recargs) = check_positivity ~chkpos kn names
      env_ar_par paramsctxt mie.mind_entry_finite
      (Array.map (fun ((_,lc),(indices,_),_) -&gt; Context.Rel.nhyps indices,lc) inds)
  in
  (* Build the inductive packets *)
    build_inductive env names mie.mind_entry_private univs variance
      paramsctxt kn record mie.mind_entry_finite
      inds nmr recargs
</pre>
  </div>
  <div class="col-md-6">
    <a href="#indtypes.ml"><code>Indtypes.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Util.

Import Names.

Import Term.

Import Constr.

Import Vars.

Import Declarations.

Import Declareops.

Import Inductive.

Import Environ.

Import Reduction.

Import Entries.

Import Context.Rel.Declaration.

Definition weaker_noccur_between
  (env : Environ.env) (x : Z) (nvars : Z) (t : Constr.constr)
  : option Constr.constr :=
  if noccur_between x nvars t then
    Some t
  else
    let t' := whd_all env t in
    if noccur_between x nvars t' then
      Some t'
    else
      None.

Inductive inductive_error : Set :=
| NonPos : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotEnoughArgs :
  Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotConstructor :
  Environ.env -&gt; Names.Id.t -&gt; Constr.constr -&gt; Constr.constr -&gt; Z -&gt; Z -&gt;
  inductive_error
| NonPar :
  Environ.env -&gt; Constr.constr -&gt; Z -&gt; Constr.constr -&gt; Constr.constr -&gt;
  inductive_error
| SameNamesTypes : Names.Id.t -&gt; inductive_error
| SameNamesConstructors : Names.Id.t -&gt; inductive_error
| SameNamesOverlap : list Names.Id.t -&gt; inductive_error
| NotAnArity : Environ.env -&gt; Constr.constr -&gt; inductive_error
| BadEntry : inductive_error
| LargeNonPropInductiveNotInType : inductive_error
| BadUnivs : inductive_error.

(* ❌ The definition of exceptions is not handled. *)
(* exception InductiveError *)

Inductive ill_formed_ind : Set :=
| LocalNonPos : Z -&gt; ill_formed_ind
| LocalNotEnoughArgs : Z -&gt; ill_formed_ind
| LocalNotConstructor : Constr.rel_context -&gt; Z -&gt; ill_formed_ind
| LocalNonPar : Z -&gt; Z -&gt; Z -&gt; ill_formed_ind.

(* ❌ The definition of exceptions is not handled. *)
(* exception IllFormedInd *)

Definition mind_extract_params
  : Z -&gt; Constr.types -&gt; Constr.rel_context * Constr.types :=
  decompose_prod_n_assum.

Definition explain_ind_err {A : Set}
  (id : Names.Id.t) (ntyp : Z) (env : Environ.env) (nparamsctxt : Z)
  (c : Constr.types) (err : ill_formed_ind) : A :=
  let '(_lparams, c') := mind_extract_params nparamsctxt c in
  match err with
  | LocalNonPos kt =&gt; Stdlib.raise extensible_type_value
  | LocalNotEnoughArgs kt =&gt; Stdlib.raise extensible_type_value
  | LocalNotConstructor paramsctxt nargs =&gt;
    let nparams := Context.Rel.nhyps paramsctxt in
    Stdlib.raise extensible_type_value
  | LocalNonPar n i l =&gt; Stdlib.raise extensible_type_value
  end.

Definition failwith_non_pos (n : Z) (ntypes : Z) (c : Constr.constr) : unit :=
  (* ❌ For loops not handled. *)
  for.

Definition failwith_non_pos_vect {A : Set}
  (n : Z) (ntypes : Z) (v : array Constr.constr) : A :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  anomaly None (Some &quot;failwith_non_pos_vect&quot;)
    (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot;).

Definition failwith_non_pos_list {A : Set}
  (n : Z) (ntypes : Z) (l : list Constr.constr) : A :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  anomaly None (Some &quot;failwith_non_pos_list&quot;)
    (Pp.str &quot;some k in [n;n+ntypes-1] should occur.&quot;).

Definition check_correct_par {A B C : Set}
  (function_parameter : Environ.env * Z * Z * A)
  : Context.Rel.pt B C -&gt; Z -&gt; list Constr.constr -&gt; unit :=
  let '(env, n, ntypes, _) := function_parameter in
  fun paramdecls =&gt;
    fun ind_index =&gt;
      fun args =&gt;
        let nparams := Context.Rel.nhyps paramdecls in
        let args := (|Util.Array|).(CArray.ExtS.of_list) args in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let '(params, realargs) :=
          (|Util.Array|).(CArray.ExtS.chop) nparams args in
        let nparamdecls := (|Util.List|).(CList.ExtS.length) paramdecls in
        let fix check {D E : Set}
          (param_index : Z) (paramdecl_index : Z)
          (function_parameter : list (Context.Rel.Declaration.pt D E))
          {struct param_index} : unit :=
          match function_parameter with
          | [] =&gt; tt
          | cons (Context.Rel.Declaration.LocalDef _ _ _) paramdecls =&gt;
            check param_index (Z.add paramdecl_index 1) paramdecls
          | cons _ paramdecls =&gt;
            match
              ((kind
                (whd_all env
                  ((|Util.Array|).(CArray.ExtS.get) params param_index))),
                match
                  kind
                    (whd_all env
                      ((|Util.Array|).(CArray.ExtS.get) params param_index))
                  with
                | Constr.Rel w =&gt; Int.equal w paramdecl_index
                | _ =&gt; false
                end) with
            | (Constr.Rel w, true) =&gt;
              check (Z.sub param_index 1) (Z.add paramdecl_index 1) paramdecls
            | (_, _) =&gt;
              let paramdecl_index_in_env :=
                Z.add (Z.add (Z.sub paramdecl_index n) nparamdecls) 1 in
              let err :=
                LocalNonPar (Z.add param_index 1) paramdecl_index_in_env
                  ind_index in
              Stdlib.raise extensible_type_value
            end
          end in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        if
          negb
            ((|Util.Array|).(CArray.ExtS.for_all) (noccur_between n ntypes)
              realargs) then
          failwith_non_pos_vect n ntypes realargs
        else
          tt.

Definition compute_rec_par {A B C D : Set}
  (function_parameter : Environ.env * Z * A * B)
  : list (Context.Rel.Declaration.pt C D) -&gt; Int.t -&gt; list Constr.constr -&gt;
  Int.t :=
  let '(env, n, _, _) := function_parameter in
  fun paramsctxt =&gt;
    fun nmr =&gt;
      fun largs =&gt;
        if Int.equal nmr 0 then
          0
        else
          let '(lpar, _) := (|Util.List|).(CList.ExtS.chop) nmr largs in
          let fix find {E F : Set}
            (k : Int.t) (index : Z)
            (function_parameter :
              list Constr.constr * list (Context.Rel.Declaration.pt E F))
            {struct k} : Int.t :=
            match function_parameter with
            | ([], _) =&gt; nmr
            | (_, []) =&gt;
              (* ❌ Assert instruction is not handled. *)
              assert false
            | (lp, cons (Context.Rel.Declaration.LocalDef _ _ _) paramsctxt) =&gt;
              find k (Z.sub index 1) (lp, paramsctxt)
            | (cons p lp, cons _ paramsctxt) =&gt;
              match
                ((kind (whd_all env p)),
                  match kind (whd_all env p) with
                  | Constr.Rel w =&gt; Int.equal w index
                  | _ =&gt; false
                  end) with
              | (Constr.Rel w, true) =&gt;
                find (Z.add k 1) (Z.sub index 1) (lp, paramsctxt)
              | (_, _) =&gt; k
              end
            end in
          find 0 (Z.sub n 1) (lpar, ((|Util.List|).(CList.ExtS.rev) paramsctxt)).

Definition ienv_push_var {A B : Set}
  (function_parameter : Environ.env * Z * A * list (Declarations.recarg * B))
  : Context.binder_annot Names.Name.t * Constr.types * B -&gt;
  Environ.env * Z * A * list (Declarations.recarg * B) :=
  let '(env, n, ntypes, lra) := function_parameter in
  fun function_parameter =&gt;
    let '(x, a, ra) := function_parameter in
    ((push_rel (Context.Rel.Declaration.LocalAssum x a) env), (Z.add n 1),
      ntypes, (cons (Declarations.Norec, ra) lra)).

Definition ienv_push_inductive {A B : Set}
  (function_parameter :
    Environ.env * Z * A * list (Declarations.recarg * Rtree.t B))
  : (Names.inductive * Univ.Instance.t) * list Constr.constr -&gt;
  Environ.env * Z * A * list (Declarations.recarg * Rtree.t B) :=
  let '(env, n, ntypes, ra_env) := function_parameter in
  fun function_parameter =&gt;
    let '((mi, u), lrecparams) := function_parameter in
    let auxntyp := 1 in
    let specif := ((lookup_mind_specif env mi), u) in
    let ty := type_of_inductive env specif in
    let env' :=
      let r := Declarations.one_inductive_body.mind_relevance (snd (fst specif))
        in
      let anon := Context.make_annot Names.Anonymous r in
      let decl :=
        Context.Rel.Declaration.LocalAssum anon
          (hnf_prod_applist env ty lrecparams) in
      push_rel decl env in
    let ra_env' :=
      cons
        ((Declarations.Imbr mi),
          ((|Util.Array|).(CArray.ExtS.get) (Rtree.mk_rec_calls 1) 0))
        ((|Util.List|).(CList.ExtS.map)
          (fun function_parameter =&gt;
            let '(r, t) := function_parameter in
            (r, (Rtree.lift 1 t))) ra_env) in
    let newidx := Z.add n auxntyp in
    (env', newidx, ntypes, ra_env').

Fixpoint ienv_decompose_prod {A : Set}
  (function_parameter :
    Environ.env * Z * A * list (Declarations.recarg * Declarations.wf_paths))
  {struct function_parameter}
  : Int.t -&gt; Constr.constr -&gt;
  (Environ.env * Z * A * list (Declarations.recarg * Declarations.wf_paths)) *
    Constr.constr :=
  let '(env, _, _, _) as ienv := function_parameter in
  fun n =&gt;
    fun c =&gt;
      if Int.equal n 0 then
        (ienv, c)
      else
        let c' := whd_all env c in
        match kind c' with
        | Constr.Prod na a b =&gt;
          let ienv' := ienv_push_var ienv (na, a, mk_norec) in
          ienv_decompose_prod ienv' (Z.sub n 1) b
        | _ =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        end.

Definition array_min {A : Set} (nmr : Int.t) (a : array (Int.t * A)) : Int.t :=
  if Int.equal nmr 0 then
    0
  else
    (|Util.Array|).(CArray.ExtS.fold_left)
      (fun k =&gt;
        fun function_parameter =&gt;
          let '(nmri, _) := function_parameter in
          OCaml.Stdlib.min k nmri) nmr a.

Definition check_positivity_one
  (chkpos : bool) (recursive : bool)
  (function_parameter :
    Environ.env * Z * Z * list (Declarations.recarg * Declarations.wf_paths))
  : Context.Rel.pt Constr.constr Constr.types -&gt; Names.MutInd.t * Z -&gt; Z -&gt;
  list Names.Id.t -&gt; array Constr.types -&gt; Int.t * Declarations.wf_paths :=
  let '(env, _, ntypes, _) as ienv := function_parameter in
  fun paramsctxt =&gt;
    fun function_parameter =&gt;
      let '(_, i) as ind := function_parameter in
      fun nnonrecargs =&gt;
        fun lcnames =&gt;
          fun indlc =&gt;
            let nparamsctxt := Context.Rel.length paramsctxt in
            let nmr := Context.Rel.nhyps paramsctxt in
            let fix check_pos
              (function_parameter :
                Environ.env * Z * Z *
                  list (Declarations.recarg * Declarations.wf_paths))
              {struct function_parameter}
              : Int.t -&gt; Constr.constr -&gt; Int.t * Declarations.wf_paths :=
              let '(env, n, ntypes, ra_env) as ienv := function_parameter in
              fun nmr =&gt;
                fun c =&gt;
                  let '(x, largs) := decompose_app (whd_all env c) in
                  match kind x with
                  | Constr.Prod na b d =&gt;
                    let '_ :=
                      (* ❌ Assert instruction is not handled. *)
                      assert ((|Util.List|).(CList.ExtS.is_empty) largs) in
                    match
                      ((weaker_noccur_between env n ntypes b),
                        match weaker_noccur_between env n ntypes b with
                        | None =&gt; chkpos
                        | _ =&gt; false
                        end) with
                    | (None, true) =&gt; failwith_non_pos_list n ntypes [ b ]
                    | (None, _) =&gt;
                      check_pos (ienv_push_var ienv (na, b, mk_norec)) nmr d
                    | (Some b, _) =&gt;
                      check_pos (ienv_push_var ienv (na, b, mk_norec)) nmr d
                    end
                  | Constr.Rel k =&gt;
                    (* ❌ Try-with are not handled *)
                    try
                      (let '(ra, rarg) :=
                        (|Util.List|).(CList.ExtS.nth) ra_env (Z.sub k 1) in
                      let largs :=
                        (|Util.List|).(CList.ExtS.map) (whd_all env) largs in
                      let nmr1 :=
                        match ra with
                        | Declarations.Mrec _ =&gt;
                          compute_rec_par ienv paramsctxt nmr largs
                        | _ =&gt; nmr
                        end in
                      if
                        andb chkpos
                          (negb
                            ((|Util.List|).(CList.ExtS.for_all)
                              (noccur_between n ntypes) largs)) then
                        failwith_non_pos_list n ntypes largs
                      else
                        (nmr1, rarg))
                  | Constr.Ind ind_kn =&gt;
                    if
                      (|Util.List|).(CList.ExtS.for_all)
                        (noccur_between n ntypes) largs then
                      (nmr, mk_norec)
                    else
                      check_positive_nested ienv nmr (ind_kn, largs)
                  | _err =&gt;
                    if
                      orb (negb chkpos)
                        (andb (noccur_between n ntypes x)
                          ((|Util.List|).(CList.ExtS.for_all)
                            (noccur_between n ntypes) largs)) then
                      (nmr, mk_norec)
                    else
                      failwith_non_pos_list n ntypes (cons x largs)
                  end
            with check_positive_nested
              (function_parameter :
                Environ.env * Z * Z *
                  list (Declarations.recarg * Declarations.wf_paths))
              {struct function_parameter}
              : Int.t -&gt;
              (Names.inductive * Univ.Instance.t) * list Constr.constr -&gt;
              Int.t * Declarations.wf_paths :=
              let '(env, n, ntypes, _ra_env) as ienv := function_parameter in
              fun nmr =&gt;
                fun function_parameter =&gt;
                  let '((mi, u), largs) := function_parameter in
                  let '(mib, mip) := lookup_mind_specif env mi in
                  let auxnrecpar :=
                    Declarations.mutual_inductive_body.mind_nparams_rec mib in
                  let auxnnonrecpar :=
                    Z.sub (Declarations.mutual_inductive_body.mind_nparams mib)
                      auxnrecpar in
                  let '(auxrecparams, auxnonrecargs) :=
                    (* ❌ Try-with are not handled *)
                    try ((|Util.List|).(CList.ExtS.chop) auxnrecpar largs) in
                  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
                  (* ❌ instruction_sequence &quot;;&quot; *)
                  let auxntyp :=
                    Declarations.mutual_inductive_body.mind_ntypes mib in
                  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
                  (* ❌ instruction_sequence &quot;;&quot; *)
                  let auxlcvect :=
                    abstract_mind_lc auxntyp auxnrecpar
                      (Declarations.one_inductive_body.mind_nf_lc mip) in
                  let '(env', _, _, _) as ienv' :=
                    ienv_push_inductive ienv ((mi, u), auxrecparams) in
                  let auxrecparams' :=
                    (|Util.List|).(CList.ExtS.map) (lift auxntyp) auxrecparams
                    in
                  let irecargs_nmr :=
                    (|Util.Array|).(CArray.ExtS.map)
                      (fun c =&gt;
                        let c' := hnf_prod_applist env' c auxrecparams' in
                        let '(ienv', c') :=
                          ienv_decompose_prod ienv' auxnnonrecpar c' in
                        check_constructors ienv' false nmr c') auxlcvect in
                  let irecargs : array (list Declarations.wf_paths) :=
                    (|Util.Array|).(CArray.ExtS.map) snd irecargs_nmr
                  with nmr' : Int.t :=
                    array_min nmr irecargs_nmr in
                  (nmr',
                    ((|Util.Array|).(CArray.ExtS.get)
                      (Rtree.mk_rec
                        (* ❌ Arrays not handled. *)
                        [ mk_paths (Declarations.Imbr mi) irecargs ]) 0))
            with check_constructors
              (ienv :
                Environ.env * Z * Z *
                  list (Declarations.recarg * Declarations.wf_paths))
              (check_head : bool) (nmr : Int.t) (c : Constr.constr)
              {struct ienv} : Int.t * list Declarations.wf_paths :=
              let fix check_constr_rec
                (function_parameter :
                  Environ.env * Z * Z *
                    list (Declarations.recarg * Declarations.wf_paths))
                {struct function_parameter}
                : Int.t -&gt; list Declarations.wf_paths -&gt; Constr.constr -&gt;
                Int.t * list Declarations.wf_paths :=
                let '(env, n, ntypes, _ra_env) as ienv := function_parameter in
                fun nmr =&gt;
                  fun lrec =&gt;
                    fun c =&gt;
                      let '(x, largs) := decompose_app (whd_all env c) in
                      match kind x with
                      | Constr.Prod na b d =&gt;
                        let '_ :=
                          (* ❌ Assert instruction is not handled. *)
                          assert ((|Util.List|).(CList.ExtS.is_empty) largs) in
                        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
                        (* ❌ instruction_sequence &quot;;&quot; *)
                        let '(nmr', recarg) := check_pos ienv nmr b in
                        let ienv' := ienv_push_var ienv (na, b, mk_norec) in
                        check_constr_rec ienv' nmr' (cons recarg lrec) d
                      | hd =&gt;
                        let '_ :=
                          if check_head then
                            match
                              (hd,
                                match hd with
                                | Constr.Rel j =&gt;
                                  Int.equal j
                                    (Z.sub (Z.sub (Z.add n ntypes) i) 1)
                                | _ =&gt; false
                                end) with
                            | (Constr.Rel j, true) =&gt;
                              check_correct_par ienv paramsctxt (Z.sub ntypes i)
                                largs
                            | (_, _) =&gt; Stdlib.raise extensible_type_value
                            end
                          else
                            if
                              andb chkpos
                                (negb
                                  ((|Util.List|).(CList.ExtS.for_all)
                                    (noccur_between n ntypes) largs)) then
                              failwith_non_pos_list n ntypes largs
                            else
                              tt in
                        (nmr, ((|Util.List|).(CList.ExtS.rev) lrec))
                      end in
              check_constr_rec ienv nmr [] c in
            let irecargs_nmr :=
              (|Util.Array|).(CArray.ExtS.map2)
                (fun id =&gt;
                  fun c =&gt;
                    let '(_, rawc) := mind_extract_params nparamsctxt c in
                    (* ❌ Try-with are not handled *)
                    try (check_constructors ienv true nmr rawc))
                ((|Util.Array|).(CArray.ExtS.of_list) lcnames) indlc in
            let irecargs : array (list Declarations.wf_paths) :=
              (|Util.Array|).(CArray.ExtS.map) snd irecargs_nmr
            with nmr' : Int.t :=
              array_min nmr irecargs_nmr in
            (nmr', (mk_paths (Declarations.Mrec ind) irecargs)).

Definition check_positivity {A : Set}
  (chkpos : bool) (kn : Names.MutInd.t) (names : array (A * list Names.Id.t))
  (env_ar_par : Environ.env)
  (paramsctxt : Context.Rel.pt Constr.constr Constr.types)
  (finite : Declarations.recursivity_kind)
  (inds : array (Z * array Constr.types))
  : Int.t * array (Rtree.t Declarations.recarg) :=
  let ntypes := (|Util.Array|).(CArray.ExtS.length) inds in
  let recursive := Stdlib.op_exclamationeq finite Declarations.BiFinite in
  let rc :=
    (|Util.Array|).(CArray.ExtS.mapi)
      (fun j =&gt; fun t =&gt; ((Declarations.Mrec (kn, j)), t))
      (Rtree.mk_rec_calls ntypes) in
  let ra_env_ar := (|Util.Array|).(CArray.ExtS.rev_to_list) rc in
  let nparamsctxt := Context.Rel.length paramsctxt in
  let nmr := Context.Rel.nhyps paramsctxt in
  let check_one {B : Set} (i : Z) (function_parameter : B * list Names.Id.t)
    : Z * array Constr.types -&gt; Int.t * Declarations.wf_paths :=
    let '(_, lcnames) := function_parameter in
    fun function_parameter =&gt;
      let '(nindices, lc) := function_parameter in
      let ra_env_ar_par :=
        op_at
          ((|Util.List|).(CList.ExtS.init) nparamsctxt
            (fun function_parameter =&gt;
              let '_ := function_parameter in
              (Declarations.Norec, mk_norec))) ra_env_ar in
      let ienv := (env_ar_par, (Z.add 1 nparamsctxt), ntypes, ra_env_ar_par) in
      check_positivity_one chkpos recursive ienv paramsctxt (kn, i) nindices
        lcnames lc in
  let irecargs_nmr := (|Util.Array|).(CArray.ExtS.map2_i) check_one names inds
    in
  let irecargs : array Declarations.wf_paths :=
    (|Util.Array|).(CArray.ExtS.map) snd irecargs_nmr
  with nmr' : Int.t :=
    array_min nmr irecargs_nmr in
  (nmr', (Rtree.mk_rec irecargs)).

Definition repair_arity
  (indices : Constr.rel_context)
  (function_parameter :
    Declarations.declaration_arity Declarations.regular_inductive_arity
      Declarations.template_arity) : Constr.types :=
  match function_parameter with
  | Declarations.RegularArity ar =&gt;
    Declarations.regular_inductive_arity.mind_user_arity ar
  | Declarations.TemplateArity ar =&gt;
    mkArity
      (indices,
        (Sorts.sort_of_univ (Declarations.template_arity.template_level ar)))
  end.

Definition fold_inductive_blocks {A B C : Set} (f : A -&gt; Constr.types -&gt; A)
  : A -&gt;
  array
    ((Declarations.declaration_arity Declarations.regular_inductive_arity
      Declarations.template_arity * array Constr.types) *
      (Constr.rel_context * B) * C) -&gt; A :=
  (|Util.Array|).(CArray.ExtS.fold_left)
    (fun acc =&gt;
      fun function_parameter =&gt;
        let '((arity, lc), (indices, _), _) := function_parameter in
        f ((|Util.Array|).(CArray.ExtS.fold_left) f acc lc)
          (repair_arity indices arity)).

Definition used_section_variables {A B : Set}
  (env : Environ.env)
  (inds :
    array
      ((Declarations.declaration_arity Declarations.regular_inductive_arity
        Declarations.template_arity * array Constr.types) *
        (Constr.rel_context * A) * B)) : Constr.named_context :=
  let fold (l : Names.Id.__Set.t) (c : Constr.constr) : Names.Id.__Set.t :=
    Id.__Set.union (Environ.global_vars_set env c) l in
  let ids := fold_inductive_blocks fold Id.__Set.empty inds in
  keep_hyps env ids.

Definition rel_vect (n : Z) (m : Z) : array Constr.constr :=
  (|Util.Array|).(CArray.ExtS.init) m (fun i =&gt; mkRel (Z.sub (Z.add n m) i)).

Definition rel_list (n : Z) (m : Z) : list Constr.constr :=
  (|Util.Array|).(CArray.ExtS.to_list) (rel_vect n m).

Definition compute_projections (function_parameter : Names.MutInd.t * Z)
  : Declarations.mutual_inductive_body -&gt;
  array Names.Label.t * array Sorts.relevance * array Constr.constr :=
  let '(kn, i) as ind := function_parameter in
  fun mib =&gt;
    let pkt :=
      (|Util.Array|).(CArray.ExtS.get)
        (Declarations.mutual_inductive_body.mind_packets mib) i in
    let u :=
      Univ.make_abstract_instance (Declareops.inductive_polymorphic_context mib)
      in
    let subst :=
      (|Util.List|).(CList.ExtS.init)
        (Declarations.mutual_inductive_body.mind_ntypes mib)
        (fun i =&gt;
          mkIndU
            ((kn,
              (Z.sub
                (Z.sub (Declarations.mutual_inductive_body.mind_ntypes mib) i) 1)),
              u)) in
    let '(ctx, cty) :=
      (|Util.Array|).(CArray.ExtS.get)
        (Declarations.one_inductive_body.mind_nf_lc pkt) 0 in
    let cty := it_mkProd_or_LetIn cty ctx in
    let '(rctx, _) := decompose_prod_assum (substl subst cty) in
    let '(ctx, paramslet) :=
      (|Util.List|).(CList.ExtS.chop)
        ((|Util.Array|).(CArray.ExtS.get)
          (Declarations.one_inductive_body.mind_consnrealdecls pkt) 0) rctx in
    let paramsletsubst :=
      let inst' :=
        rel_list 0 (Declarations.mutual_inductive_body.mind_nparams mib) in
      let subst := subst_of_rel_context_instance paramslet inst' in
      let subst :=
        cons (mkRel 1) ((|Util.List|).(CList.ExtS.map) (lift 1) subst) in
      subst in
    let projections
      (decl : Context.Rel.Declaration.pt Constr.constr Constr.constr)
      (function_parameter :
        Z * Z * list Names.Label.t * list Sorts.relevance * list Constr.constr *
          Vars.substl)
      : Z * Z * list Names.Label.t * list Sorts.relevance * list Constr.constr *
        list Constr.constr :=
      let '(i, j, labs, rs, pbs, letsubst) := function_parameter in
      match decl with
      | Context.Rel.Declaration.LocalDef _na c _t =&gt;
        let c := liftn 1 j c in
        let c2 := substl letsubst c in
        let letsubst := cons c2 letsubst in
        (i, (Z.add j 1), labs, rs, pbs, letsubst)
      | Context.Rel.Declaration.LocalAssum na t =&gt;
        match Context.binder_annot.binder_name na with
        | Names.Name id =&gt;
          let r := Context.binder_annot.binder_relevance na in
          let lab := Label.of_id id in
          let kn :=
            Projection.Repr.make ind
              (Declarations.mutual_inductive_body.mind_nparams mib) i lab in
          let t := liftn 1 j t in
          let projty := substl letsubst t in
          let fterm := mkProj ((Projection.make kn false), (mkRel 1)) in
          ((Z.add i 1), (Z.add j 1), (cons lab labs), (cons r rs),
            (cons projty pbs), (cons fterm letsubst))
        | Names.Anonymous =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        end
      end in
    let '(_, _, labs, rs, pbs, _letsubst) :=
      (|Util.List|).(CList.ExtS.fold_right) projections ctx
        (0, 1, [], [], [], paramsletsubst) in
    (((|Util.Array|).(CArray.ExtS.of_list) ((|Util.List|).(CList.ExtS.rev) labs)),
      ((|Util.Array|).(CArray.ExtS.of_list) ((|Util.List|).(CList.ExtS.rev) rs)),
      ((|Util.Array|).(CArray.ExtS.of_list) ((|Util.List|).(CList.ExtS.rev) pbs))).

Definition build_inductive
  (env : Environ.env) (names : array (Names.Id.t * list Names.Id.t))
  (prv : option bool) (univs : Declarations.universes)
  (variance : option (array Univ.Variance.t))
  (paramsctxt : Context.Rel.pt Constr.constr Constr.types) (kn : Names.MutInd.t)
  (isrecord : option (option (array Names.Id.t)))
  (isfinite : Declarations.recursivity_kind)
  (inds :
    array
      ((Declarations.inductive_arity * array Constr.types) *
        (Context.Rel.pt Constr.constr Constr.types *
          array (Context.Rel.pt Constr.constr Constr.types * Constr.types)) *
        list Sorts.family)) (nmr : Z) (recargs : array Declarations.wf_paths)
  : Declarations.mutual_inductive_body :=
  let ntypes := (|Util.Array|).(CArray.ExtS.length) inds in
  let hyps := used_section_variables env inds in
  let nparamargs := Context.Rel.nhyps paramsctxt in
  let build_one_packet (function_parameter : Names.Id.t * list Names.Id.t)
    : (Declarations.inductive_arity * array Constr.types) *
      (Context.Rel.pt Constr.constr Constr.types *
        array (Context.Rel.pt Constr.constr Constr.types * Constr.types)) *
      list Sorts.family -&gt; Declarations.wf_paths -&gt;
    Declarations.one_inductive_body :=
    let '(id, cnames) := function_parameter in
    fun function_parameter =&gt;
      let '((arity, lc), (indices, splayed_lc), kelim) := function_parameter in
      fun recarg =&gt;
        let nf_lc :=
          (|Util.Array|).(CArray.ExtS.map)
            (fun function_parameter =&gt;
              let '(d, b) := function_parameter in
              ((op_at d paramsctxt), b)) splayed_lc in
        let consnrealdecls :=
          (|Util.Array|).(CArray.ExtS.map)
            (fun function_parameter =&gt;
              let '(d, _) := function_parameter in
              Context.Rel.length d) splayed_lc in
        let consnrealargs :=
          (|Util.Array|).(CArray.ExtS.map)
            (fun function_parameter =&gt;
              let '(d, _) := function_parameter in
              Context.Rel.nhyps d) splayed_lc in
        let mind_relevance :=
          match arity with
          |
            Declarations.RegularArity {|
              Declarations.regular_inductive_arity.mind_sort := mind_sort |}
            =&gt; Sorts.relevance_of_sort mind_sort
          | Declarations.TemplateArity _ =&gt; Sorts.Relevant
          end in
        let '(nconst, nblock) :=
          ((Stdlib.__ref_value 0), (Stdlib.__ref_value 0)) in
        let transf (num : Z) : Z * Z :=
          let arity :=
            (|Util.List|).(CList.ExtS.length)
              ((|Util.Array|).(CArray.ExtS.get) (dest_subterms recarg) num) in
          if Int.equal arity 0 then
            let p := ((Stdlib.op_exclamation nconst), 0) in
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            p
          else
            let p := ((Z.add (Stdlib.op_exclamation nblock) 1), arity) in
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            p in
        let rtbl :=
          (|Util.Array|).(CArray.ExtS.init)
            ((|Util.List|).(CList.ExtS.length) cnames) transf in
        {| Declarations.one_inductive_body.mind_typename := id;
          Declarations.one_inductive_body.mind_arity_ctxt :=
            op_at indices paramsctxt;
          Declarations.one_inductive_body.mind_arity := arity;
          Declarations.one_inductive_body.mind_consnames :=
            (|Util.Array|).(CArray.ExtS.of_list) cnames;
          Declarations.one_inductive_body.mind_user_lc := lc;
          Declarations.one_inductive_body.mind_nrealargs :=
            Context.Rel.nhyps indices;
          Declarations.one_inductive_body.mind_nrealdecls :=
            Context.Rel.length indices;
          Declarations.one_inductive_body.mind_kelim := kelim;
          Declarations.one_inductive_body.mind_nf_lc := nf_lc;
          Declarations.one_inductive_body.mind_consnrealargs := consnrealargs;
          Declarations.one_inductive_body.mind_consnrealdecls := consnrealdecls;
          Declarations.one_inductive_body.mind_recargs := recarg;
          Declarations.one_inductive_body.mind_relevance := mind_relevance;
          Declarations.one_inductive_body.mind_nb_constant :=
            Stdlib.op_exclamation nconst;
          Declarations.one_inductive_body.mind_nb_args :=
            Stdlib.op_exclamation nblock;
          Declarations.one_inductive_body.mind_reloc_tbl := rtbl |} in
  let packets :=
    (|Util.Array|).(CArray.ExtS.map3) build_one_packet names inds recargs in
  let mib :=
    {| Declarations.mutual_inductive_body.mind_packets := packets;
      Declarations.mutual_inductive_body.mind_record := Declarations.NotRecord;
      Declarations.mutual_inductive_body.mind_finite := isfinite;
      Declarations.mutual_inductive_body.mind_ntypes := ntypes;
      Declarations.mutual_inductive_body.mind_hyps := hyps;
      Declarations.mutual_inductive_body.mind_nparams := nparamargs;
      Declarations.mutual_inductive_body.mind_nparams_rec := nmr;
      Declarations.mutual_inductive_body.mind_params_ctxt := paramsctxt;
      Declarations.mutual_inductive_body.mind_universes := univs;
      Declarations.mutual_inductive_body.mind_variance := variance;
      Declarations.mutual_inductive_body.mind_private := prv;
      Declarations.mutual_inductive_body.mind_typing_flags :=
        Environ.typing_flags env |} in
  let record_info :=
    match isrecord with
    | Some (Some rid) =&gt;
      let map {A : Set} (i : Z) (id : A)
        : A * array Names.Label.t * array Sorts.relevance * array Constr.constr :=
        let '(labs, rs, projs) := compute_projections (kn, i) mib in
        (id, labs, rs, projs) in
      Declarations.PrimRecord ((|Util.Array|).(CArray.ExtS.mapi) map rid)
    | Some None =&gt; Declarations.FakeRecord
    | None =&gt; Declarations.NotRecord
    end in
  Declarations.mutual_inductive_body.with_mind_record mib record_info.

Definition check_inductive
  (env : Environ.env) (kn : Names.MutInd.t)
  (mie : Entries.mutual_inductive_entry) : Declarations.mutual_inductive_body :=
  let '(env_ar_par, univs, variance, record, paramsctxt, inds) :=
    IndTyping.typecheck_inductive env mie in
  let chkpos :=
    Declarations.typing_flags.check_guarded (Environ.typing_flags env) in
  let names :=
    (|Util.Array|).(CArray.ExtS.map_of_list)
      (fun entry =&gt;
        ((Entries.one_inductive_entry.mind_entry_typename entry),
          (Entries.one_inductive_entry.mind_entry_consnames entry)))
      (Entries.mutual_inductive_entry.mind_entry_inds mie) in
  let '(nmr, recargs) :=
    check_positivity chkpos kn names env_ar_par paramsctxt
      (Entries.mutual_inductive_entry.mind_entry_finite mie)
      ((|Util.Array|).(CArray.ExtS.map)
        (fun function_parameter =&gt;
          let '((_, lc), (indices, _), _) := function_parameter in
          ((Context.Rel.nhyps indices), lc)) inds) in
  build_inductive env names
    (Entries.mutual_inductive_entry.mind_entry_private mie) univs variance
    paramsctxt kn record (Entries.mutual_inductive_entry.mind_entry_finite mie)
    inds nmr recargs.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="indtypes.mli">
  <div style="margin: 20px;">
    <h3>Indtypes_mli</h3>
    <ul>
      <li>OCaml size: 36 lines</li>
      <li>Coq size: 34 lines (-6% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#indtypes.mli"><code>indtypes.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Declarations
open Environ
open Entries

(** Check an inductive. *)
val check_inductive : env -&gt; MutInd.t -&gt; mutual_inductive_entry -&gt; mutual_inductive_body

(** Deprecated *)
type inductive_error =
  | NonPos of env * constr * constr
  | NotEnoughArgs of env * constr * constr
  | NotConstructor of env * Id.t * constr * constr * int * int
  | NonPar of env * constr * int * constr * constr
  | SameNamesTypes of Id.t
  | SameNamesConstructors of Id.t
  | SameNamesOverlap of Id.t list
  | NotAnArity of env * constr
  | BadEntry
  | LargeNonPropInductiveNotInType
  | BadUnivs
[@@ocaml.deprecated &quot;Use [Type_errors.inductive_error]&quot;]

<abbr class="mark-warning" title="Signature item `exception` not handled">exception InductiveError of Type_errors.inductive_error
[@@ocaml.deprecated &quot;Use [Type_errors.InductiveError]&quot;]</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#indtypes.mli"><code>Indtypes_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter check_inductive :
  Environ.env -&gt; Names.MutInd.t -&gt; Entries.mutual_inductive_entry -&gt;
  Declarations.mutual_inductive_body.

Inductive inductive_error : Set :=
| NonPos : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotEnoughArgs :
  Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotConstructor :
  Environ.env -&gt; Names.Id.t -&gt; Constr.constr -&gt; Constr.constr -&gt; Z -&gt; Z -&gt;
  inductive_error
| NonPar :
  Environ.env -&gt; Constr.constr -&gt; Z -&gt; Constr.constr -&gt; Constr.constr -&gt;
  inductive_error
| SameNamesTypes : Names.Id.t -&gt; inductive_error
| SameNamesConstructors : Names.Id.t -&gt; inductive_error
| SameNamesOverlap : list Names.Id.t -&gt; inductive_error
| NotAnArity : Environ.env -&gt; Constr.constr -&gt; inductive_error
| BadEntry : inductive_error
| LargeNonPropInductiveNotInType : inductive_error
| BadUnivs : inductive_error.

(* exception InductiveError *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="inductive.ml">
  <div style="margin: 20px;">
    <h3>Inductive</h3>
    <ul>
      <li>OCaml size: 1284 lines</li>
      <li>Coq size: 1656 lines (+28% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#inductive.ml"><code>inductive.ml</code></a>&nbsp;<span class="label label-warning">87 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Util
open Names
open Univ
open Constr
open Vars
open Declarations
open Declareops
open Environ
open Reduction
open Type_errors
open Context.Rel.Declaration

type mind_specif = mutual_inductive_body * one_inductive_body

(* raise Not_found if not an inductive type *)
let lookup_mind_specif env (kn,tyi) =
  let mib = Environ.lookup_mind kn env in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if tyi &gt;= Array.length mib.mind_packets then
    user_err Pp.(str &quot;Inductive.lookup_mind_specif: invalid inductive index&quot;);
  (mib, mib.mind_packets.(tyi))</abbr>

let find_rectype env c =
  let (t, l) = decompose_app (whd_all env c) in
  match kind t with
  | Ind ind -&gt; (ind, l)
  | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

let find_inductive env c =
  let (t, l) = decompose_app (whd_all env c) in
  match kind t with
    | Ind ind
        when (fst (lookup_mind_specif env (out_punivs ind))).mind_finite &lt;&gt; CoFinite -&gt; (ind, l)
    | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

let find_coinductive env c =
  let (t, l) = decompose_app (whd_all env c) in
  match kind t with
    | Ind ind
        when (fst (lookup_mind_specif env (out_punivs ind))).mind_finite == CoFinite -&gt; (ind, l)
    | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

let inductive_params (mib,_) = mib.mind_nparams

let inductive_paramdecls (mib,u) =
  Vars.subst_instance_context u mib.mind_params_ctxt

let instantiate_inductive_constraints mib u =
  Univ.AUContext.instantiate u (Declareops.inductive_polymorphic_context mib)

(************************************************************************)

(* Build the substitution that replaces Rels by the appropriate *)
(* inductives *)
let ind_subst mind mib u =
  let ntypes = mib.mind_ntypes in
  let make_Ik k = mkIndU ((mind,ntypes-k-1),u) in
  List.init ntypes make_Ik

(* Instantiate inductives in constructor type *)
let constructor_instantiate mind u mib c =
  let s = ind_subst mind mib u in
    substl s (subst_instance_constr u c)

let instantiate_params full t u args sign =
  let fail () =
    anomaly ~label:&quot;instantiate_params&quot; (Pp.str &quot;type, ctxt and args mismatch.&quot;) in
  let (rem_args, subs, ty) =
    Context.Rel.fold_outside
      (fun decl (largs,subs,ty) -&gt;
        match (decl, largs, kind ty) with
          | (LocalAssum _, a::args, Prod(_,_,t)) -&gt; (args, a::subs, t)
          | (LocalDef (_,b,_), _, LetIn(_,_,_,t))    -&gt;
             (largs, (substl subs (subst_instance_constr u b))::subs, t)
          | (_,[],_)                -&gt; if full then fail() else ([], subs, ty)
          | _                       -&gt; fail ())
      sign
      ~init:(args,[],t)
  in
  let () = if not (List.is_empty rem_args) then fail () in
  substl subs ty

let full_inductive_instantiate mib u params sign =
  let dummy = Sorts.prop in
  let t = Term.mkArity (Vars.subst_instance_context u sign,dummy) in
    fst (Term.destArity (instantiate_params true t u params mib.mind_params_ctxt))

let full_constructor_instantiate ((mind,_),u,(mib,_),params) t =
  let inst_ind = constructor_instantiate mind u mib t in
   instantiate_params true inst_ind u params mib.mind_params_ctxt

(************************************************************************)
(************************************************************************)

(* Functions to build standard types related to inductive *)

(*
Computing the actual sort of an applied or partially applied inductive type:

I_i: forall uniformparams:utyps, forall otherparams:otyps, Type(a)
uniformargs : utyps
otherargs : otyps
I_1:forall ...,s_1;...I_n:forall ...,s_n |- sort(C_kj(uniformargs)) = s_kj
s'_k = max(..s_kj..)
merge(..s'_k..) = ..s''_k..
--------------------------------------------------------------------
Gamma |- I_i uniformargs otherargs : phi(s''_i)

where

- if p=0, phi() = Prop
- if p=1, phi(s) = s
- if p&lt;&gt;1, phi(s) = sup(Set,s)

Remark: Set (predicative) is encoded as Type(0)
*)

(* Template polymorphism *)

(* cons_subst add the mapping [u |-&gt; su] in subst if [u] is not *)
(* in the domain or add [u |-&gt; sup x su] if [u] is already mapped *)
(* to [x]. *)
let cons_subst u su subst =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    Univ.LMap.add u (Univ.sup (Univ.LMap.find u subst) su) subst
  with Not_found -&gt; Univ.LMap.add u su subst</abbr>

(* remember_subst updates the mapping [u |-&gt; x] by [u |-&gt; sup x u] *)
(* if it is presents and returns the substitution unchanged if not.*)
let remember_subst u subst =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let su = Universe.make u in
    Univ.LMap.add u (Univ.sup (Univ.LMap.find u subst) su) subst
  with Not_found -&gt; subst</abbr>

(* Bind expected levels of parameters to actual levels *)
(* Propagate the new levels in the signature *)
let make_subst env =
  let rec make subst = function
    | LocalDef _ :: sign, exp, args -&gt;
        make subst (sign, exp, args)
    | _d::sign, None::exp, args -&gt;
        let args = match args with _::args -&gt; args | [] -&gt; [] in
        make subst (sign, exp, args)
    | _d::sign, Some u::exp, a::args -&gt;
        (* We recover the level of the argument, but we don't change the *)
        (* level in the corresponding type in the arity; this level in the *)
        (* arity is a global level which, at typing time, will be enforce *)
        (* to be greater than the level of the argument; this is probably *)
        (* a useless extra constraint *)
        let s = Sorts.univ_of_sort (snd (dest_arity env (Lazy.force a))) in
          make (cons_subst u s subst) (sign, exp, args)
    | LocalAssum (_na,_t) :: sign, Some u::exp, [] -&gt;
        (* No more argument here: we add the remaining universes to the *)
        (* substitution (when [u] is distinct from all other universes in the *)
        (* template, it is identity substitution  otherwise (ie. when u is *)
        (* already in the domain of the substitution) [remember_subst] will *)
        (* update its image [x] by [sup x u] in order not to forget the *)
        (* dependency in [u] that remains to be fulfilled. *)
        make (remember_subst u subst) (sign, exp, [])
    | _sign, [], _ -&gt;
        (* Uniform parameters are exhausted *)
        subst
    | [], _, _ -&gt;
        <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in
  make Univ.LMap.empty

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception SingletonInductiveBecomesProp of Id.t</abbr>

let instantiate_universes env ctx ar argsorts =
  let args = Array.to_list argsorts in
  let subst = make_subst env (ctx,ar.template_param_levels,args) in
  let level = Univ.subst_univs_universe (Univ.make_subst subst) ar.template_level in
  let ty =
    (* Singleton type not containing types are interpretable in Prop *)
    if is_type0m_univ level then Sorts.prop
    (* Non singleton type not containing types are interpretable in Set *)
    else if is_type0_univ level then Sorts.set
    (* This is a Type with constraints *)
    else Sorts.sort_of_univ level
  in
    (ctx, ty)

(* Type of an inductive type *)

let relevance_of_inductive env ind =
  let _, mip = lookup_mind_specif env ind in
  mip.mind_relevance

let type_of_inductive_gen ?(polyprop=true) env ((_,mip),u) paramtyps =
  match mip.mind_arity with
  | RegularArity a -&gt; subst_instance_constr u a.mind_user_arity
  | TemplateArity ar -&gt;
    let ctx = List.rev mip.mind_arity_ctxt in
    let ctx,s = instantiate_universes env ctx ar paramtyps in
      (* The Ocaml extraction cannot handle (yet?) &quot;Prop-polymorphism&quot;, i.e.
         the situation where a non-Prop singleton inductive becomes Prop
         when applied to Prop params *)
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not polyprop &amp;&amp; not (is_type0m_univ ar.template_level) &amp;&amp; Sorts.is_prop s
      then raise (SingletonInductiveBecomesProp mip.mind_typename);
      Term.mkArity (List.rev ctx,s)</abbr>

let type_of_inductive env pind =
  type_of_inductive_gen env pind <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

let constrained_type_of_inductive env ((mib,_mip),u as pind) =
  let ty = type_of_inductive env pind in
  let cst = instantiate_inductive_constraints mib u in
    (ty, cst)

let constrained_type_of_inductive_knowing_parameters env ((mib,_mip),u as pind) args =
  let ty = type_of_inductive_gen env pind args in
  let cst = instantiate_inductive_constraints mib u in
    (ty, cst)

let type_of_inductive_knowing_parameters env ?(polyprop=true) mip args =
  type_of_inductive_gen ~polyprop env mip args

(* The max of an array of universes *)

let cumulate_constructor_univ u = let open Sorts in function
  | SProp | Prop -&gt;
    (* SProp is non cumulative but allowed in constructors of any
       inductive (except non-sprop primitive records) *)
    u
  | Set -&gt; Universe.sup Universe.type0 u
  | Type u' -&gt; Universe.sup u u'

let max_inductive_sort =
  Array.fold_left cumulate_constructor_univ Universe.type0m

(************************************************************************)
(* Type of a constructor *)

let type_of_constructor (cstr, u) (mib,mip) =
  let ind = inductive_of_constructor cstr in
  let specif = mip.mind_user_lc in
  let i = index_of_constructor cstr in
  let nconstr = Array.length mip.mind_consnames in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if i &gt; nconstr then user_err Pp.(str &quot;Not enough constructors in the type.&quot;);
  constructor_instantiate (fst ind) u mib specif.(i-1)</abbr>

let constrained_type_of_constructor (_cstr,u as cstru) (mib,_mip as ind) =
  let ty = type_of_constructor cstru ind in
  let cst = instantiate_inductive_constraints mib u in
    (ty, cst)

let arities_of_specif (kn,u) (mib,mip) =
  let specif = mip.mind_nf_lc in
  let map (ctx, c) =
    let cty = Term.it_mkProd_or_LetIn c ctx in
    constructor_instantiate kn u mib cty
  in
  Array.map map specif

let arities_of_constructors ind specif =
  arities_of_specif (fst (fst ind), snd ind) specif

let type_of_constructors (ind,u) (mib,mip) =
  let specif = mip.mind_user_lc in
    Array.map (constructor_instantiate (fst ind) u mib) specif

(************************************************************************)

(* Type of case predicates *)

(* Get type of inductive, with parameters instantiated *)

let inductive_sort_family mip =
  match mip.mind_arity with
  | RegularArity s -&gt; Sorts.family s.mind_sort
  | TemplateArity _ -&gt; Sorts.InType

let mind_arity mip =
  mip.mind_arity_ctxt, inductive_sort_family mip

let get_instantiated_arity (_ind,u) (mib,mip) params =
  let sign, s = mind_arity mip in
  full_inductive_instantiate mib u params sign, s

let elim_sorts (_,mip) = mip.mind_kelim

let is_private (mib,_) = mib.mind_private = Some true
let is_primitive_record (mib,_) =
  match mib.mind_record with
  | PrimRecord _ -&gt; true
  | NotRecord | FakeRecord -&gt; false

let build_dependent_inductive ind (_,mip) params =
  let realargs,_ = List.chop mip.mind_nrealdecls mip.mind_arity_ctxt in
  Term.applist
    (mkIndU ind,
       List.map (lift mip.mind_nrealdecls) params
       @ Context.Rel.to_extended_list mkRel 0 realargs)

(* This exception is local *)
<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception LocalArity of (Sorts.family list * Sorts.family * Sorts.family * arity_error) option</abbr>

let check_allowed_sort ksort specif =
  if not (CList.exists (Sorts.family_equal ksort) (elim_sorts specif)) then
    let s = inductive_sort_family (snd specif) in
    raise <abbr class="mark-warning" title="Values of extensible types are not handled">(LocalArity (Some(elim_sorts specif, ksort,s,error_elim_explain ksort s)))</abbr>

let is_correct_arity env c pj ind specif params =
  let arsign,_ = get_instantiated_arity ind specif params in
  let rec srec env pt ar =
    let pt' = whd_all env pt in
    match kind pt', ar with
      | Prod (na1,a1,t), (LocalAssum (_,a1'))::ar' -&gt;
          let () =
            <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try conv env a1 a1'
            with NotConvertible -&gt; raise (LocalArity None)</abbr> in
          srec (push_rel (LocalAssum (na1,a1)) env) t ar'
      (* The last Prod domain is the type of the scrutinee *)
      | Prod (na1,a1,a2), [] -&gt; (* whnf of t was not needed here! *)
         let env' = push_rel (LocalAssum (na1,a1)) env in
         let ksort = match kind (whd_all env' a2) with
         | Sort s -&gt; Sorts.family s
         | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">(LocalArity None)</abbr> in
         let dep_ind = build_dependent_inductive ind specif params in
         let _ =
           <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try conv env a1 dep_ind
           with NotConvertible -&gt; raise (LocalArity None)</abbr> in
           check_allowed_sort ksort specif
      | _, (LocalDef _ as d)::ar' -&gt;
          srec (push_rel d env) (lift 1 pt') ar'
      | _ -&gt;
          raise <abbr class="mark-warning" title="Values of extensible types are not handled">(LocalArity None)</abbr>
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try srec env pj.uj_type (List.rev arsign)
  with LocalArity kinds -&gt;
    error_elim_arity env ind c pj kinds</abbr>


(************************************************************************)
(* Type of case branches *)

(* [p] is the predicate, [i] is the constructor number (starting from 0),
   and [cty] is the type of the constructor (params not instantiated) *)
let build_branches_type (ind,u) (_,mip as specif) params p =
  let build_one_branch i (ctx, c) =
    let cty = Term.it_mkProd_or_LetIn c ctx in
    let typi = full_constructor_instantiate (ind,u,specif,params) cty in
    let (cstrsign,ccl) = Term.decompose_prod_assum typi in
    let nargs = Context.Rel.length cstrsign in
    let (_,allargs) = decompose_app ccl in
    let (lparams,vargs) = List.chop (inductive_params specif) allargs in
    let cargs =
      let cstr = ith_constructor_of_inductive ind (i+1) in
      let dep_cstr = Term.applist (mkConstructU (cstr,u),lparams@(Context.Rel.to_extended_list mkRel 0 cstrsign)) in
      vargs @ [dep_cstr] in
    let base = Term.lambda_appvect_assum (mip.mind_nrealdecls+1) (lift nargs p) (Array.of_list cargs) in
    Term.it_mkProd_or_LetIn base cstrsign in
  Array.mapi build_one_branch mip.mind_nf_lc

(* [p] is the predicate, [c] is the match object, [realargs] is the
   list of real args of the inductive type *)
let build_case_type env n p c realargs =
  whd_betaiota env (Term.lambda_appvect_assum (n+1) p (Array.of_list (realargs@[c])))

let type_case_branches env (pind,largs) pj c =
  let specif = lookup_mind_specif env (fst pind) in
  let nparams = inductive_params specif in
  let (params,realargs) = List.chop nparams largs in
  let p = pj.uj_val in
  let () = is_correct_arity env c pj pind specif params in
  let lc = build_branches_type pind specif params p in
  let ty = build_case_type env (snd specif).mind_nrealdecls p c realargs in
  (lc, ty)


(************************************************************************)
(* Checking the case annotation is relevant *)

let check_case_info env (indsp,u) r ci =
  let (mib,mip as spec) = lookup_mind_specif env indsp in
  if
    not (eq_ind indsp ci.ci_ind) ||
    not (Int.equal mib.mind_nparams ci.ci_npar) ||
    not (Array.equal Int.equal mip.mind_consnrealdecls ci.ci_cstr_ndecls) ||
    not (Array.equal Int.equal mip.mind_consnrealargs ci.ci_cstr_nargs) ||
    not (ci.ci_relevance == r) ||
    is_primitive_record spec
  then raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError(env,WrongCaseInfo((indsp,u),ci)))</abbr>

(************************************************************************)
(************************************************************************)

(* Guard conditions for fix and cofix-points *)

(* Check if t is a subterm of Rel n, and gives its specification,
   assuming lst already gives index of
   subterms with corresponding specifications of recursive arguments *)

(* A powerful notion of subterm *)

(* To each inductive definition corresponds an array describing the
   structure of recursive arguments for each constructor, we call it
   the recursive spec of the type (it has type recargs vect).  For
   checking the guard, we start from the decreasing argument (Rel n)
   with its recursive spec.  During checking the guardness condition,
   we collect patterns variables corresponding to subterms of n, each
   of them with its recursive spec.  They are organised in a list lst
   of type (int * recargs) list which is sorted with respect to the
   first argument.
*)

(*************************************************************)
(* Environment annotated with marks on recursive arguments *)

(* tells whether it is a strict or loose subterm *)
type size = Large | Strict

(* merging information *)
let size_glb s1 s2 =
  match s1,s2 with
      Strict, Strict -&gt; Strict
    | _ -&gt; Large

(* possible specifications for a term:
   - Not_subterm: when the size of a term is not related to the
     recursive argument of the fixpoint
   - Subterm: when the term is a subterm of the recursive argument
       the wf_paths argument specifies which subterms are recursive
   - Dead_code: when the term has been built by elimination over an
       empty type
 *)

type subterm_spec =
    Subterm of (size * wf_paths)
  | Dead_code
  | Not_subterm

let eq_wf_paths = Rtree.equal Declareops.eq_recarg

let inter_recarg r1 r2 = match r1, r2 with
| Norec, Norec -&gt; Some r1
| Mrec i1, Mrec i2
| Imbr i1, Imbr i2
| Mrec i1, Imbr i2 -&gt; if Names.eq_ind i1 i2 then Some r1 else None
| Imbr i1, Mrec i2 -&gt; if Names.eq_ind i1 i2 then Some r2 else None
| _ -&gt; None

let inter_wf_paths = Rtree.inter Declareops.eq_recarg inter_recarg Norec

let incl_wf_paths = Rtree.incl Declareops.eq_recarg inter_recarg Norec

let spec_of_tree t =
  if eq_wf_paths t mk_norec
  then Not_subterm
  else Subterm (Strict, t)

let inter_spec s1 s2 =
  match s1, s2 with
  | _, Dead_code -&gt; s1
  | Dead_code, _ -&gt; s2
  | Not_subterm, _ -&gt; s1
  | _, Not_subterm -&gt; s2
  | Subterm (a1,t1), Subterm (a2,t2) -&gt;
     Subterm (size_glb a1 a2, inter_wf_paths t1 t2)

let subterm_spec_glb =
  Array.fold_left inter_spec Dead_code

type guard_env =
  { env     : env;
    (* dB of last fixpoint *)
    rel_min : int;
    (* dB of variables denoting subterms *)
    genv    : subterm_spec Lazy.t list;
  }

let make_renv env recarg tree =
  { env = env;
    rel_min = recarg+2; (* recarg = 0 ==&gt; Rel 1 -&gt; recarg; Rel 2 -&gt; fix *)
    genv = [Lazy.from_val(Subterm(Large,tree))] }

let push_var renv (x,ty,spec) =
  { env = push_rel (LocalAssum (x,ty)) renv.env;
    rel_min = renv.rel_min+1;
    genv = spec:: renv.genv }

let assign_var_spec renv (i,spec) =
  { renv with genv = List.assign renv.genv (i-1) spec }

let push_var_renv renv (x,ty) =
  push_var renv (x,ty,<abbr class="mark-warning" title="Lazy expressions are not handled">lazy Not_subterm</abbr>)

(* Fetch recursive information about a variable p *)
let subterm_var p renv =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Lazy.force (List.nth renv.genv (p-1))
  with Failure _ | Invalid_argument _ -&gt; Not_subterm</abbr>

let push_ctxt_renv renv ctxt =
  let n = Context.Rel.length ctxt in
  { env = push_rel_context ctxt renv.env;
    rel_min = renv.rel_min+n;
    genv = iterate (fun ge -&gt; <abbr class="mark-warning" title="Lazy expressions are not handled">lazy Not_subterm</abbr>::ge) n renv.genv }

let push_fix_renv renv (_,v,_ as recdef) =
  let n = Array.length v in
  { env = push_rec_types recdef renv.env;
    rel_min = renv.rel_min+n;
    genv = iterate (fun ge -&gt; <abbr class="mark-warning" title="Lazy expressions are not handled">lazy Not_subterm</abbr>::ge) n renv.genv }

(* Definition and manipulation of the stack *)
type stack_element = |SClosure of guard_env*constr |SArg of subterm_spec Lazy.t

let push_stack_closures renv l stack =
  List.fold_right (fun h b -&gt; (SClosure (renv,h))::b) l stack

let push_stack_args l stack =
  List.fold_right (fun h b -&gt; (SArg h)::b) l stack

(******************************)
(* {6 Computing the recursive subterms of a term (propagation of size
   information through Cases).} *)

let lookup_subterms env ind =
  let (_,mip) = lookup_mind_specif env ind in
  mip.mind_recargs

let match_inductive ind ra =
  match ra with
    | (Mrec i | Imbr i) -&gt; eq_ind ind i
    | Norec -&gt; false

(* In {match c as z in ci y_s return P with |C_i x_s =&gt; t end}
   [branches_specif renv c_spec ci] returns an array of x_s specs knowing
   c_spec. *)
let branches_specif renv c_spec ci =
  let car =
    (* We fetch the regular tree associated to the inductive of the match.
       This is just to get the number of constructors (and constructor
       arities) that fit the match branches without forcing c_spec.
       Note that c_spec might be more precise than [v] below, because of
       nested inductive types. *)
    let (_,mip) = lookup_mind_specif renv.env ci.ci_ind in
    let v = dest_subterms mip.mind_recargs in
      Array.map List.length v in
    Array.mapi
      (fun i nca -&gt; (* i+1-th cstructor has arity nca *)
         let lvra = <abbr class="mark-warning" title="Lazy expressions are not handled">lazy
           (match Lazy.force c_spec with
                Subterm (_,t) when match_inductive ci.ci_ind (dest_recarg t) -&gt;
                  let vra = Array.of_list (dest_subterms t).(i) in
                  </abbr><abbr class="mark-warning" title="Lazy expressions are not handled

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Int.equal nca (Array.length vra));
                  Array.map spec_of_tree vra</abbr><abbr class="mark-warning" title="Lazy expressions are not handled">
              | Dead_code -&gt; Array.make nca Dead_code
              | _ -&gt; Array.make nca Not_subterm)</abbr> in
         List.init nca (fun j -&gt; <abbr class="mark-warning" title="Lazy expressions are not handled">lazy (Lazy.force lvra).(j)</abbr>))
      car

let check_inductive_codomain env p =
  let absctx, ar = dest_lam_assum env p in
  let env = push_rel_context absctx env in
  let arctx, s = dest_prod_assum env ar in
  let env = push_rel_context arctx env in
  let i,_l' = decompose_app (whd_all env s) in
  isInd i

(* The following functions are almost duplicated from indtypes.ml, except
that they carry here a poorer environment (containing less information). *)
let ienv_push_var (env, lra) (x,a,ra) =
  (push_rel (LocalAssum (x,a)) env, (Norec,ra)::lra)

let ienv_push_inductive (env, ra_env) ((mind,u),lpar) =
  let mib = Environ.lookup_mind mind env in
  let ntypes = mib.mind_ntypes in
  let push_ind specif env =
    let r = specif.mind_relevance in
    let anon = Context.make_annot Anonymous r in
    let decl = LocalAssum (anon, hnf_prod_applist env (type_of_inductive env ((mib,specif),u)) lpar) in
    push_rel decl env
  in
  let env = Array.fold_right push_ind mib.mind_packets env in
  let rc = Array.mapi (fun j t -&gt; (Imbr (mind,j),t)) (Rtree.mk_rec_calls ntypes) in
  let lra_ind = Array.rev_to_list rc in
  let ra_env = List.map (fun (r,t) -&gt; (r,Rtree.lift ntypes t)) ra_env in
  (env, lra_ind @ ra_env)

let rec ienv_decompose_prod (env,_ as ienv) n c =
 if Int.equal n 0 then (ienv,c) else
   let c' = whd_all env c in
   match kind c' with
   Prod(na,a,b) -&gt;
     let ienv' = ienv_push_var ienv (na,a,mk_norec) in
     ienv_decompose_prod ienv' (n-1) b
     | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let dummy_univ = Level.(make (UGlobal.make (DirPath.make [Id.of_string &quot;implicit&quot;]) 0))
let dummy_implicit_sort = mkType (Universe.make dummy_univ)
let lambda_implicit_lift n a =
  let anon = Context.make_annot Anonymous Sorts.Relevant in
  let lambda_implicit a = mkLambda (anon, dummy_implicit_sort, a) in
  iterate lambda_implicit n (lift n a)

(* This removes global parameters of the inductive types in lc (for
   nested inductive types only ) *)
let abstract_mind_lc ntyps npars lc =
  let lc = Array.map (fun (ctx, c) -&gt; Term.it_mkProd_or_LetIn c ctx) lc in
  if Int.equal npars 0 then
    lc
  else
    let make_abs =
      List.init ntyps
        (function i -&gt; lambda_implicit_lift npars (mkRel (i+1)))
    in
    Array.map (substl make_abs) lc

(* [get_recargs_approx env tree ind args] builds an approximation of the recargs
tree for ind, knowing args. The argument tree is used to know when candidate
nested types should be traversed, pruning the tree otherwise. This code is very
close to check_positive in indtypes.ml, but does no positivity check and does not
compute the number of recursive arguments. *)
let get_recargs_approx env tree ind args =
  <abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">let rec build_recargs (env, ra_env as ienv) tree c =
    let x,largs = decompose_app (whd_all env c) in
    match kind x with
    | Prod (na,b,d) -&gt;
       </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (List.is_empty largs);
       build_recargs (ienv_push_var ienv (na, b, mk_norec)) tree d</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
    | Rel k -&gt;
       (* Free variables are allowed and assigned Norec *)
       </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try snd (List.nth ra_env (k-1))
        with Failure _ | Invalid_argument _ -&gt; mk_norec)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
    | Ind ind_kn -&gt;
       (* When the inferred tree allows it, we consider that we have a potential
       nested inductive type *)
       begin match dest_recarg tree with
             | Imbr kn' | Mrec kn' when eq_ind (fst ind_kn) kn' -&gt;
                           build_recargs_nested ienv tree (ind_kn, largs)
             | _ -&gt; mk_norec
       end
    | _err -&gt;
       mk_norec

  and build_recargs_nested (env,_ra_env as ienv) tree (((mind,i),u), largs) =
    (* If the inferred tree already disallows recursion, no need to go further *)
    if eq_wf_paths tree mk_norec then tree
    else
    let mib = Environ.lookup_mind mind env in
    let auxnpar = mib.mind_nparams_rec in
    let nonrecpar = mib.mind_nparams - auxnpar in
    let (lpar,_) = List.chop auxnpar largs in
    let auxntyp = mib.mind_ntypes in
    (* Extends the environment with a variable corresponding to
             the inductive def *)
    let (env',_ as ienv') = ienv_push_inductive ienv ((mind,u),lpar) in
    (* Parameters expressed in env' *)
    let lpar' = List.map (lift auxntyp) lpar in
    (* In case of mutual inductive types, we use the recargs tree which was
    computed statically. This is fine because nested inductive types with
    mutually recursive containers are not supported. *)
    let trees =
      if Int.equal auxntyp 1 then </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Arrays not handled.">[|dest_subterms tree|]</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
      else Array.map (fun mip -&gt; dest_subterms mip.mind_recargs) mib.mind_packets
    in
    let mk_irecargs j specif =
      (* The nested inductive type with parameters removed *)
      let auxlcvect = abstract_mind_lc auxntyp auxnpar specif.mind_nf_lc in
      let paths = Array.mapi
        (fun k c -&gt;
         let c' = hnf_prod_applist env' c lpar' in
         (* skip non-recursive parameters *)
         let (ienv',c') = ienv_decompose_prod ienv' nonrecpar c' in
         build_recargs_constructors ienv' trees.(j).(k) c')
        auxlcvect
      in
      mk_paths (Imbr (mind,j)) paths
    in
    let irecargs = Array.mapi mk_irecargs mib.mind_packets in
    (Rtree.mk_rec irecargs).(i)

  and build_recargs_constructors ienv trees c =
    let rec recargs_constr_rec (env,_ra_env as ienv) trees lrec c =
      let x,largs = decompose_app (whd_all env c) in
        match kind x with

          | Prod (na,b,d) -&gt;
             let () = </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Assert instruction is not handled.">assert (List.is_empty largs)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
             let recarg = build_recargs ienv (List.hd trees) b in
             let ienv' = ienv_push_var ienv (na,b,mk_norec) in
             recargs_constr_rec ienv' (List.tl trees) (recarg::lrec) d
          | _hd -&gt;
             List.rev lrec
    in
    recargs_constr_rec ienv trees [] c
  in
  (* starting with ra_env = [] seems safe because any unbounded Rel will be
  assigned Norec *)
  build_recargs_nested (env,[]) tree (ind, args)</abbr>

(* [restrict_spec env spec p] restricts the size information in spec to what is
   allowed to flow through a match with predicate p in environment env. *)
let restrict_spec env spec p =
  if spec = Not_subterm then spec
  else let absctx, ar = dest_lam_assum env p in
  (* Optimization: if the predicate is not dependent, no restriction is needed
     and we avoid building the recargs tree. *)
  if noccur_with_meta 1 (Context.Rel.length absctx) ar then spec
  else
  let env = push_rel_context absctx env in
  let arctx, s = dest_prod_assum env ar in
  let env = push_rel_context arctx env in
  let i,args = decompose_app (whd_all env s) in
  match kind i with
  | Ind i -&gt;
     begin match spec with
           | Dead_code -&gt; spec
           | Subterm(st,tree) -&gt;
              let recargs = get_recargs_approx env tree i args in
              let recargs = inter_wf_paths tree recargs in
              Subterm(st,recargs)
           | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
     end
  | _ -&gt; Not_subterm

(* [subterm_specif renv t] computes the recursive structure of [t] and
   compare its size with the size of the initial recursive argument of
   the fixpoint we are checking. [renv] collects such information
   about variables.
*)

let rec subterm_specif renv stack t =
  (* maybe reduction is not always necessary! *)
  let f,l = decompose_app (whd_all renv.env t) in
    match kind f with
    | Rel k -&gt; subterm_var k renv
    | Case (ci,p,c,lbr) -&gt;
       let stack' = push_stack_closures renv l stack in
       let cases_spec =
         branches_specif renv (lazy_subterm_specif renv [] c) ci
       in
       let stl =
         Array.mapi (fun i br' -&gt;
                     let stack_br = push_stack_args (cases_spec.(i)) stack' in
                     subterm_specif renv stack_br br')
                    lbr in
       let spec = subterm_spec_glb stl in
       restrict_spec renv.env spec p

    | Fix ((recindxs,i),(_,typarray,bodies as recdef)) -&gt;
      (* when proving that the fixpoint f(x)=e is less than n, it is enough
         to prove that e is less than n assuming f is less than n
         furthermore when f is applied to a term which is strictly less than
         n, one may assume that x itself is strictly less than n
      *)
    if not (check_inductive_codomain renv.env typarray.(i)) then Not_subterm
    else
      let (ctxt,clfix) = dest_prod renv.env typarray.(i) in
      let oind =
        let env' = push_rel_context ctxt renv.env in
          <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some(fst(find_inductive env' clfix))
          with Not_found -&gt; None</abbr> in
        (match oind with
      None -&gt; Not_subterm (* happens if fix is polymorphic *)
        | Some (ind, _) -&gt;
        let nbfix = Array.length typarray in
        let recargs = lookup_subterms renv.env ind in
                   (* pushing the fixpoints *)
        let renv' = push_fix_renv renv recdef in
        let renv' =
                     (* Why Strict here ? To be general, it could also be
                        Large... *)
          assign_var_spec renv'
          (nbfix-i, <abbr class="mark-warning" title="Lazy expressions are not handled">lazy (Subterm(Strict,recargs))</abbr>) in
        let decrArg = recindxs.(i) in
        let theBody = bodies.(i)   in
        let nbOfAbst = decrArg+1 in
        let sign,strippedBody = Term.decompose_lam_n_assum nbOfAbst theBody in
                   (* pushing the fix parameters *)
        let stack' = push_stack_closures renv l stack in
        let renv'' = push_ctxt_renv renv' sign in
        let renv'' =
          if List.length stack' &lt; nbOfAbst then renv''
          else
            let decrArg = List.nth stack' decrArg in
            let arg_spec = stack_element_specif decrArg in
              assign_var_spec renv'' (1, arg_spec) in
          subterm_specif renv'' [] strippedBody)

    | Lambda (x,a,b) -&gt;
      let () = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (List.is_empty l)</abbr> in
      let spec,stack' = extract_stack stack in
        subterm_specif (push_var renv (x,a,spec)) stack' b

      (* Metas and evars are considered OK *)
    | (Meta _|Evar _) -&gt; Dead_code

    | Proj (p, c) -&gt;
      let subt = subterm_specif renv stack c in
      (match subt with
       | Subterm (_s, wf) -&gt;
         (* We take the subterm specs of the constructor of the record *)
         let wf_args = (dest_subterms wf).(0) in
         (* We extract the tree of the projected argument *)
         let n = Projection.arg p in
         spec_of_tree (List.nth wf_args n)
       | Dead_code -&gt; Dead_code
       | Not_subterm -&gt; Not_subterm)

    | Var _ | Sort _ | Cast _ | Prod _ | LetIn _ | App _ | Const _ | Ind _
      | Construct _ | CoFix _ | Int _ -&gt; Not_subterm


      (* Other terms are not subterms *)

and lazy_subterm_specif renv stack t =
  <abbr class="mark-warning" title="Lazy expressions are not handled">lazy (subterm_specif renv stack t)</abbr>

and stack_element_specif = function
  |SClosure (h_renv,h) -&gt; lazy_subterm_specif h_renv [] h
  |SArg x -&gt; x

and extract_stack = function
   | [] -&gt; Lazy.from_val Not_subterm , []
   | h::t -&gt; stack_element_specif h, t

(* Check term c can be applied to one of the mutual fixpoints. *)
let check_is_subterm x tree =
  match Lazy.force x with
  | Subterm (Strict,tree') -&gt; incl_wf_paths tree tree'
  | Dead_code -&gt; true
  |  _ -&gt; false

(************************************************************************)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception FixGuardError of env * guard_error</abbr>

let error_illegal_rec_call renv fx (arg_renv,arg) =
  let (_,le_vars,lt_vars) =
    List.fold_left
      (fun (i,le,lt) sbt -&gt;
        match Lazy.force sbt with
            (Subterm(Strict,_) | Dead_code) -&gt; (i+1, le, i::lt)
          | (Subterm(Large,_)) -&gt; (i+1, i::le, lt)
          | _ -&gt; (i+1, le ,lt))
      (1,[],[]) renv.genv in
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(FixGuardError (renv.env,
                        RecursionOnIllegalTerm(fx,(arg_renv.env, arg),
                                               le_vars,lt_vars)))</abbr>

let error_partial_apply renv fx =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(FixGuardError (renv.env,NotEnoughArgumentsForFixCall fx))</abbr>

let filter_stack_domain env p stack =
  let absctx, ar = dest_lam_assum env p in
  (* Optimization: if the predicate is not dependent, no restriction is needed
     and we avoid building the recargs tree. *)
  if noccur_with_meta 1 (Context.Rel.length absctx) ar then stack
  else let env = push_rel_context absctx env in
  let rec filter_stack env ar stack =
    let t = whd_all env ar in
    match stack, kind t with
    | elt :: stack', Prod (n,a,c0) -&gt;
      let d = LocalAssum (n,a) in
      let ctx, a = dest_prod_assum env a in
      let env = push_rel_context ctx env in
      let ty, args = decompose_app (whd_all env a) in
      let elt = match kind ty with
      | Ind ind -&gt;
        let spec' = stack_element_specif elt in
        (match (Lazy.force spec') with
        | Not_subterm | Dead_code -&gt; elt
        | Subterm(s,path) -&gt;
            let recargs = get_recargs_approx env path ind args in
            let path = inter_wf_paths path recargs in
            SArg <abbr class="mark-warning" title="Lazy expressions are not handled">(lazy (Subterm(s,path)))</abbr>)
      | _ -&gt; (SArg <abbr class="mark-warning" title="Lazy expressions are not handled">(lazy Not_subterm)</abbr>)
      in
      elt :: filter_stack (push_rel d env) c0 stack'
    | _,_ -&gt; List.fold_right (fun _ l -&gt; SArg <abbr class="mark-warning" title="Lazy expressions are not handled">(lazy Not_subterm)</abbr> :: l) stack []
  in
  filter_stack env ar stack

let judgment_of_fixpoint (_, types, bodies) =
  Array.map2 (fun typ body -&gt; { uj_val = body ; uj_type = typ }) types bodies

(* Check if [def] is a guarded fixpoint body with decreasing arg.
   given [recpos], the decreasing arguments of each mutually defined
   fixpoint. *)
let check_one_fix renv recpos trees def =
  let nfi = Array.length recpos in

  (* Checks if [t] only make valid recursive calls
     [stack] is the list of constructor's argument specification and
     arguments that will be applied after reduction.
     example u in t where we have (match .. with |.. =&gt; t end) u *)
  <abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">let rec check_rec_call renv stack t =
    (* if [t] does not make recursive calls, it is guarded: *)
    if noccur_with_meta renv.rel_min nfi t then ()
    else
      let (f,l) = decompose_app (whd_betaiotazeta renv.env t) in
      match kind f with
        | Rel p -&gt;
            (* Test if [p] is a fixpoint (recursive call) *)
            if renv.rel_min &lt;= p &amp;&amp; p &lt; renv.rel_min+nfi then
              </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
                List.iter (check_rec_call renv []) l;
                (* the position of the invoked fixpoint: *)
                let glob = renv.rel_min+nfi-1-p in
                (* the decreasing arg of the rec call: *)
                let np = recpos.(glob) in
                let stack' = push_stack_closures renv l stack in
                if List.length stack' &lt;= np then error_partial_apply renv glob
                else
                  (* Retrieve the expected tree for the argument *)
                  (* Check the decreasing arg is smaller *)
                  let z = List.nth stack' np in
                  if not (check_is_subterm (stack_element_specif z) trees.(glob)) then
                    begin match z with
                      |SClosure (z,z') -&gt; error_illegal_rec_call renv glob (z,z')
                      |SArg _ -&gt; error_partial_apply renv glob
                    end
              end</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
            else
              begin
                match lookup_rel p renv.env with
                | LocalAssum _ -&gt;
                    List.iter (check_rec_call renv []) l
                | LocalDef (_,c,_) -&gt;
                    </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try List.iter (check_rec_call renv []) l
                    with FixGuardError _ -&gt;
                      check_rec_call renv stack (Term.applist(lift p c,l))</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
              end

        | Case (ci,p,c_0,lrest) -&gt;
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">begin try
              </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">List.iter (check_rec_call renv []) (c_0::p::l);
              (* compute the recarg info for the arguments of each branch *)
              let case_spec =
                branches_specif renv (lazy_subterm_specif renv [] c_0) ci in
              let stack' = push_stack_closures renv l stack in
              let stack' = filter_stack_domain renv.env p stack' in
              lrest |&gt; Array.iteri (fun k br' -&gt;
                let stack_br = push_stack_args case_spec.(k) stack' in
                check_rec_call renv stack_br br')</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
            with (FixGuardError _ as exn) -&gt;
              let exn = CErrors.push exn in
              (* we try hard to reduce the match away by looking for a
                 constructor in c_0 (we unfold definitions too) *)
              let c_0 = whd_all renv.env c_0 in
              let hd, _ = decompose_app c_0 in
              match kind hd with
              | Construct _ -&gt;
                  (* the call to whd_betaiotazeta will reduce the
                     apparent iota redex away *)
                  check_rec_call renv []
                    (Term.applist (mkCase (ci,p,c_0,lrest), l))
              | _ -&gt; Exninfo.iraise exn
            end</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

        (* Enables to traverse Fixpoint definitions in a more intelligent
           way, ie, the rule :
           if - g = fix g (y1:T1)...(yp:Tp) {struct yp} := e &amp;
              - f is guarded with respect to the set of pattern variables S
                in a1 ... am        &amp;
              - f is guarded with respect to the set of pattern variables S
                in T1 ... Tp        &amp;
              - ap is a sub-term of the formal argument of f &amp;
              - f is guarded with respect to the set of pattern variables
                S+{yp} in e
           then f is guarded with respect to S in (g a1 ... am).
           Eduardo 7/9/98 *)
        | Fix ((recindxs,i),(_,typarray,bodies as recdef)) -&gt;
            let decrArg = recindxs.(i) in
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">begin try
              </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">List.iter (check_rec_call renv []) l;
              </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (check_rec_call renv []) typarray;
              let renv' = push_fix_renv renv recdef in
              let stack' = push_stack_closures renv l stack in
              bodies |&gt; Array.iteri (fun j body -&gt;
                if Int.equal i j &amp;&amp; (List.length stack' &gt; decrArg) then
                  let recArg = List.nth stack' decrArg in
                  let arg_sp = stack_element_specif recArg in
                  let illformed () =
                    error_ill_formed_rec_body renv.env NotEnoughAbstractionInFixBody
                      (pi1 recdef) i (push_rec_types recdef renv.env)
                      (judgment_of_fixpoint recdef)
                  in
                  check_nested_fix_body illformed renv' (decrArg+1) arg_sp body
                else check_rec_call renv' [] body)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
            with (FixGuardError _ as exn) -&gt;
              let exn = CErrors.push exn in
              (* we try hard to reduce the fix away by looking for a
                 constructor in l[decrArg] (we unfold definitions too) *)
              if List.length l &lt;= decrArg then Exninfo.iraise exn;
              let recArg = List.nth l decrArg in
              let recArg = whd_all renv.env recArg in
              let hd, _ = decompose_app recArg in
              match kind hd with
              | Construct _ -&gt;
                  let before, after = CList.(firstn decrArg l, skipn (decrArg+1) l) in
                  check_rec_call renv []
                    (Term.applist (mkFix ((recindxs,i),recdef), (before @ recArg :: after)))
              | _ -&gt; Exninfo.iraise exn
            end</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

        | Const (kn,_u as cu) -&gt;
            if evaluable_constant kn renv.env then
              </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try List.iter (check_rec_call renv []) l
              with (FixGuardError _ ) -&gt;
                let value = (Term.applist(constant_value_in renv.env cu, l)) in
                check_rec_call renv stack value</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
            else List.iter (check_rec_call renv []) l

        | Lambda (x,a,b) -&gt;
            let () = </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Assert instruction is not handled.">assert (List.is_empty l)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_rec_call renv [] a ;
            let spec, stack' = extract_stack stack in
            check_rec_call (push_var renv (x,a,spec)) stack' b</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

        | Prod (x,a,b) -&gt;
            let () = </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Assert instruction is not handled.">assert (List.is_empty l &amp;&amp; List.is_empty stack)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_rec_call renv [] a;
            check_rec_call (push_var_renv renv (x,a)) [] b</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

        | CoFix (_i,(_,typarray,bodies as recdef)) -&gt;
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">List.iter (check_rec_call renv []) l;
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (check_rec_call renv []) typarray;
            let renv' = push_fix_renv renv recdef in
            Array.iter (check_rec_call renv' []) bodies</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

        | (Ind _ | Construct _) -&gt;
            List.iter (check_rec_call renv []) l

        | Proj (p, c) -&gt;
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">begin try
              </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">List.iter (check_rec_call renv []) l;
              check_rec_call renv [] c</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
            with (FixGuardError _ as exn) -&gt;
              let exn = CErrors.push exn in
              (* we try hard to reduce the proj away by looking for a
                 constructor in c (we unfold definitions too) *)
              let c = whd_all renv.env c in
              let hd, _ = decompose_app c in
              match kind hd with
              | Construct _ -&gt;
                  check_rec_call renv []
                    (Term.applist (mkProj(Projection.unfold p,c), l))
              | _ -&gt; Exninfo.iraise exn
            end</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

        | Var id -&gt;
            begin
              let open! Context.Named.Declaration in
              match lookup_named id renv.env with
              | LocalAssum _ -&gt;
                  List.iter (check_rec_call renv []) l
              | LocalDef (_,c,_) -&gt;
                  </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try List.iter (check_rec_call renv []) l
                  with (FixGuardError _) -&gt;
                    check_rec_call renv stack (Term.applist(c,l))</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
            end

        | Sort _ | Int _ -&gt;
          </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Assert instruction is not handled.">assert (List.is_empty l)</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

        (* l is not checked because it is considered as the meta's context *)
        | (Evar _ | Meta _) -&gt; ()

        | (App _ | LetIn _ | Cast _) -&gt; </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Assert instruction is not handled.">assert false</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> (* beta zeta reduction *)

  and check_nested_fix_body illformed renv decr recArgsDecrArg body =
    if Int.equal decr 0 then
      check_rec_call (assign_var_spec renv (1,recArgsDecrArg)) [] body
    else
      match kind (whd_all renv.env body) with
        | Lambda (x,a,b) -&gt;
            </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_rec_call renv [] a;
            let renv' = push_var_renv renv (x,a) in
              check_nested_fix_body illformed renv' (decr-1) recArgsDecrArg b</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
        | _ -&gt; illformed ()

  in
  check_rec_call renv [] def</abbr>

let inductive_of_mutfix env ((nvect,bodynum),(names,types,bodies as recdef)) =
  let nbfix = Array.length bodies in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int.equal nbfix 0
    || not (Int.equal (Array.length nvect) nbfix)
    || not (Int.equal (Array.length types) nbfix)
    || not (Int.equal (Array.length names) nbfix)
    || bodynum &lt; 0
    || bodynum &gt;= nbfix
  then anomaly (Pp.str &quot;Ill-formed fix term.&quot;);
  let fixenv = push_rec_types recdef env in
  let vdefj = judgment_of_fixpoint recdef in
  let raise_err env i err =
    error_ill_formed_rec_body env err names i fixenv vdefj in
  (* Check the i-th definition with recarg k *)
  let find_ind i k def =
    (* check fi does not appear in the k+1 first abstractions,
       gives the type of the k+1-eme abstraction (must be an inductive)  *)
    let rec check_occur env n def =
      match kind (whd_all env def) with
        | Lambda (x,a,b) -&gt;
            if noccur_with_meta n nbfix a then
              let env' = push_rel (LocalAssum (x,a)) env in
              if Int.equal n (k + 1) then
                (* get the inductive type of the fixpoint *)
                let (mind, _) =
                  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try find_inductive env a
                  with Not_found -&gt;
                    raise_err env i (RecursionNotOnInductiveType a)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> in
                let mib,_ = lookup_mind_specif env (out_punivs mind) in
                </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if mib.mind_finite != Finite then
                  raise_err env i (RecursionNotOnInductiveType a);
                (mind, (env', b))</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
              else check_occur env' (n+1) b
            else anomaly ~label:&quot;check_one_fix&quot; (Pp.str &quot;Bad occurrence of recursive call.&quot;)
        | _ -&gt; raise_err env i NotEnoughAbstractionInFixBody
    in
    let ((ind, _), _) as res = check_occur fixenv 1 def in
    let _, ind = lookup_mind_specif env ind in
    (* recursive sprop means non record with projections -&gt; squashed *)
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Sorts.Irrelevant == ind.mind_relevance
    then
      begin
        if names.(i).Context.binder_relevance == Sorts.Relevant
        then raise_err env i FixpointOnIrrelevantInductive
      end;
    res</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  in
  (* Do it on every fixpoint *)
  let rv = Array.map2_i find_ind nvect bodies in
  (Array.map fst rv, Array.map snd rv)</abbr>


let check_fix env ((nvect,_),(names,_,bodies as recdef) as fix) =
  let flags = Environ.typing_flags env in
  if flags.check_guarded then
    let (minds, rdef) = inductive_of_mutfix env fix in
    let get_tree (kn,i) =
      let mib = Environ.lookup_mind kn env in
      mib.mind_packets.(i).mind_recargs
    in
    let trees = Array.map (fun (mind,_) -&gt; get_tree mind) minds in
    <abbr class="mark-warning" title="For loops not handled.">for i = 0 to Array.length bodies - 1 do
      let (fenv,body) = rdef.(i) in
      let renv = make_renv fenv nvect.(i) trees.(i) in
      try check_one_fix renv nvect trees body
      with FixGuardError (fixenv,err) -&gt;
        error_ill_formed_rec_body fixenv err names i
          (push_rec_types recdef env) (judgment_of_fixpoint recdef)
    done</abbr>
  else
    ()

(*
let cfkey = CProfile.declare_profile &quot;check_fix&quot;;;
let check_fix env fix = CProfile.profile3 cfkey check_fix env fix;;
*)

(************************************************************************)
(* Co-fixpoints. *)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception CoFixGuardError of env * guard_error</abbr>

let anomaly_ill_typed () =
  anomaly ~label:&quot;check_one_cofix&quot; (Pp.str &quot;too many arguments applied to constructor.&quot;)

let rec codomain_is_coind env c =
  let b = whd_all env c in
  match kind b with
    | Prod (x,a,b) -&gt;
        codomain_is_coind (push_rel (LocalAssum (x,a)) env) b
    | _ -&gt;
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try find_coinductive env b
        with Not_found -&gt;
          raise (CoFixGuardError (env, CodomainNotInductiveType b)))</abbr>

let check_one_cofix env nbfix def deftype =
  let rec check_rec_call env alreadygrd n tree vlra  t =
    if not (noccur_with_meta n nbfix t) then
      let c,args = decompose_app (whd_all env t) in
      match kind c with
        | Rel p when  n &lt;= p &amp;&amp; p &lt; n+nbfix -&gt;
            (* recursive call: must be guarded and no nested recursive
               call allowed *)
            if not alreadygrd then
              raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,UnguardedRecursiveCall t))</abbr>
            else if not(List.for_all (noccur_with_meta n nbfix) args) then
              raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,NestedRecursiveOccurrences))</abbr>
        | Construct ((_,i as cstr_kn),_u)  -&gt;
            let lra = vlra.(i-1) in
            let mI = inductive_of_constructor cstr_kn in
            let (mib,_mip) = lookup_mind_specif env mI in
            let realargs = List.skipn mib.mind_nparams args in
            let rec process_args_of_constr = function
              | (t::lr), (rar::lrar) -&gt;
                  if eq_wf_paths rar mk_norec then
                    if noccur_with_meta n nbfix t
                    then process_args_of_constr (lr, lrar)
                    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError
                                 (env,RecCallInNonRecArgOfConstructor t))</abbr>
                  else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
                      check_rec_call env true n rar (dest_subterms rar) t;
                      process_args_of_constr (lr, lrar)
                    end</abbr>
              | [],_ -&gt; ()
              | _ -&gt; anomaly_ill_typed ()
            in process_args_of_constr (realargs, lra)

        | Lambda (x,a,b) -&gt;
            let () = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (List.is_empty args)</abbr> in
            if noccur_with_meta n nbfix a then
              let env' = push_rel (LocalAssum (x,a)) env in
              check_rec_call env' alreadygrd (n+1) tree vlra b
            else
              raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,RecCallInTypeOfAbstraction a))</abbr>

        | CoFix (_j,(_,varit,vdefs as recdef)) -&gt;
            if List.for_all (noccur_with_meta n nbfix) args
            then
              if Array.for_all (noccur_with_meta n nbfix) varit then
                let nbfix = Array.length vdefs in
                let env' = push_rec_types recdef env in
                <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(Array.iter (check_rec_call env' alreadygrd (n+nbfix) tree vlra) vdefs;
                 List.iter (check_rec_call env alreadygrd n tree vlra) args)</abbr>
              else
                raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,RecCallInTypeOfDef c))</abbr>
            else
              raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,UnguardedRecursiveCall c))</abbr>

        | Case (_,p,tm,vrest) -&gt;
           begin
             let tree = match restrict_spec env (Subterm (Strict, tree)) p with
             | Dead_code -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
             | Subterm (_, tree') -&gt; tree'
             | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env, ReturnPredicateNotCoInductive c))</abbr>
             in
               if (noccur_with_meta n nbfix p) then
                 if (noccur_with_meta n nbfix tm) then
                   if (List.for_all (noccur_with_meta n nbfix) args) then
                     let vlra = dest_subterms tree in
                     Array.iter (check_rec_call env alreadygrd n tree vlra) vrest
                   else
                     raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,RecCallInCaseFun c))</abbr>
                 else
                   raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,RecCallInCaseArg c))</abbr>
               else
                 raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,RecCallInCasePred c))</abbr>
           end

        | Meta _ -&gt; ()
        | Evar _ -&gt;
            List.iter (check_rec_call env alreadygrd n tree vlra) args
        | Rel _ | Var _ | Sort _ | Cast _ | Prod _ | LetIn _ | App _ | Const _
          | Ind _ | Fix _ | Proj _ | Int _ -&gt;
           raise <abbr class="mark-warning" title="Values of extensible types are not handled">(CoFixGuardError (env,NotGuardedForm t))</abbr> in

  let ((mind, _),_) = codomain_is_coind env deftype in
  let vlra = lookup_subterms env mind in
  check_rec_call env false 1 vlra (dest_subterms vlra) def

(* The  function which checks that the whole block of definitions
   satisfies the guarded condition *)

let check_cofix env (_bodynum,(names,types,bodies as recdef)) =
  let flags = Environ.typing_flags env in
  if flags.check_guarded then
    let nbfix = Array.length bodies in
    <abbr class="mark-warning" title="For loops not handled.">for i = 0 to nbfix-1 do
      let fixenv = push_rec_types recdef env in
      try check_one_cofix fixenv nbfix bodies.(i) types.(i)
      with CoFixGuardError (errenv,err) -&gt;
        error_ill_formed_rec_body errenv err names i
          fixenv (judgment_of_fixpoint recdef)
    done</abbr>
  else
    ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#inductive.ml"><code>Inductive.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Util.

Import Names.

Import Univ.

Import Constr.

Import Vars.

Import Declarations.

Import Declareops.

Import Environ.

Import Reduction.

Import Type_errors.

Import Context.Rel.Declaration.

Definition mind_specif :=
  Declarations.mutual_inductive_body * Declarations.one_inductive_body.

Definition lookup_mind_specif
  (env : Environ.env) (function_parameter : Names.MutInd.t * Z)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body :=
  let '(kn, tyi) := function_parameter in
  let mib := Environ.lookup_mind kn env in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (mib,
    ((|Util.Array|).(CArray.ExtS.get)
      (Declarations.mutual_inductive_body.mind_packets mib) tyi)).

Definition find_rectype (env : Environ.env) (c : Constr.constr)
  : (Names.inductive * Univ.Instance.t) * list Constr.constr :=
  let '(t, l) := decompose_app (whd_all env c) in
  match kind t with
  | Constr.Ind ind =&gt; (ind, l)
  | _ =&gt; Stdlib.raise extensible_type_value
  end.

Definition find_inductive (env : Environ.env) (c : Constr.constr)
  : (Names.inductive * Univ.Instance.t) * list Constr.constr :=
  let '(t, l) := decompose_app (whd_all env c) in
  match
    ((kind t),
      match kind t with
      | Constr.Ind ind =&gt;
        nequiv_decb
          (Declarations.mutual_inductive_body.mind_finite
            (fst (lookup_mind_specif env (out_punivs ind))))
          Declarations.CoFinite
      | _ =&gt; false
      end) with
  | (Constr.Ind ind, true) =&gt; (ind, l)
  | (_, _) =&gt; Stdlib.raise extensible_type_value
  end.

Definition find_coinductive (env : Environ.env) (c : Constr.constr)
  : (Names.inductive * Univ.Instance.t) * list Constr.constr :=
  let '(t, l) := decompose_app (whd_all env c) in
  match
    ((kind t),
      match kind t with
      | Constr.Ind ind =&gt;
        Stdlib.op_eqeq
          (Declarations.mutual_inductive_body.mind_finite
            (fst (lookup_mind_specif env (out_punivs ind))))
          Declarations.CoFinite
      | _ =&gt; false
      end) with
  | (Constr.Ind ind, true) =&gt; (ind, l)
  | (_, _) =&gt; Stdlib.raise extensible_type_value
  end.

Definition inductive_params {A : Set}
  (function_parameter : Declarations.mutual_inductive_body * A) : Z :=
  let '(mib, _) := function_parameter in
  Declarations.mutual_inductive_body.mind_nparams mib.

Definition inductive_paramdecls
  (function_parameter : Declarations.mutual_inductive_body * Univ.Instance.t)
  : Constr.rel_context :=
  let '(mib, u) := function_parameter in
  Vars.subst_instance_context u
    (Declarations.mutual_inductive_body.mind_params_ctxt mib).

Definition instantiate_inductive_constraints
  (mib : Declarations.mutual_inductive_body) (u : Univ.Instance.t)
  : Univ.Constraint.t :=
  Univ.AUContext.instantiate u (Declareops.inductive_polymorphic_context mib).

Definition ind_subst
  (mind : Names.MutInd.t) (mib : Declarations.mutual_inductive_body)
  (u : Univ.Instance.t) : list Constr.constr :=
  let ntypes := Declarations.mutual_inductive_body.mind_ntypes mib in
  let make_Ik (k : Z) : Constr.constr :=
    mkIndU ((mind, (Z.sub (Z.sub ntypes k) 1)), u) in
  (|Util.List|).(CList.ExtS.init) ntypes make_Ik.

Definition constructor_instantiate
  (mind : Names.MutInd.t) (u : Univ.Instance.t)
  (mib : Declarations.mutual_inductive_body) (c : Constr.constr)
  : Constr.constr :=
  let s := ind_subst mind mib u in
  substl s (subst_instance_constr u c).

Definition instantiate_params {A : Set}
  (full : bool) (t : Constr.constr) (u : Univ.Instance.t)
  (args : list Constr.constr) (sign : Context.Rel.pt Constr.constr A)
  : Constr.constr :=
  let fail {B : Set} (function_parameter : unit) : B :=
    let '_ := function_parameter in
    anomaly None (Some &quot;instantiate_params&quot;)
      (Pp.str &quot;type, ctxt and args mismatch.&quot;) in
  let '(rem_args, subs, ty) :=
    Context.Rel.fold_outside
      (fun decl =&gt;
        fun function_parameter =&gt;
          let '(largs, subs, ty) := function_parameter in
          match (decl, largs, (kind ty)) with
          |
            (Context.Rel.Declaration.LocalAssum _ _, cons a args,
              Constr.Prod _ _ t) =&gt; (args, (cons a subs), t)
          | (Context.Rel.Declaration.LocalDef _ b _, _, Constr.LetIn _ _ _ t) =&gt;
            (largs, (cons (substl subs (subst_instance_constr u b)) subs), t)
          | (_, [], _) =&gt;
            if full then
              fail tt
            else
              ([], subs, ty)
          | _ =&gt; fail tt
          end) sign (args, [], t) in
  let '_ :=
    if negb ((|Util.List|).(CList.ExtS.is_empty) rem_args) then
      fail tt
    else
      tt in
  substl subs ty.

Definition full_inductive_instantiate
  (mib : Declarations.mutual_inductive_body) (u : Univ.Instance.t)
  (params : list Constr.constr) (sign : Constr.rel_context)
  : Constr.rel_context :=
  let dummy := Sorts.prop in
  let t := Term.mkArity ((Vars.subst_instance_context u sign), dummy) in
  fst
    (Term.destArity
      (instantiate_params true t u params
        (Declarations.mutual_inductive_body.mind_params_ctxt mib))).

Definition full_constructor_instantiate {A B : Set}
  (function_parameter :
    (Names.MutInd.t * A) * Univ.Instance.t *
      (Declarations.mutual_inductive_body * B) * list Constr.constr)
  : Constr.constr -&gt; Constr.constr :=
  let '((mind, _), u, (mib, _), params) := function_parameter in
  fun t =&gt;
    let inst_ind := constructor_instantiate mind u mib t in
    instantiate_params true inst_ind u params
      (Declarations.mutual_inductive_body.mind_params_ctxt mib).

Definition cons_subst
  (u : Univ.LMap.key) (su : Univ.Universe.t)
  (subst : Univ.LMap.t Univ.Universe.t) : Univ.LMap.t Univ.Universe.t :=
  (* ❌ Try-with are not handled *)
  try (Univ.LMap.add u (Univ.sup (Univ.LMap.find u subst) su) subst).

Definition remember_subst
  (u : Univ.LMap.key) (subst : Univ.LMap.t Univ.Universe.t)
  : Univ.LMap.t Univ.Universe.t :=
  (* ❌ Try-with are not handled *)
  try
    (let su := Universe.make u in
    Univ.LMap.add u (Univ.sup (Univ.LMap.find u subst) su) subst).

Definition make_subst {A B : Set} (env : Environ.env)
  : list (Context.Rel.Declaration.pt A B) * list (option Univ.LMap.key) *
    list (Stdlib.Lazy.t Constr.types) -&gt; Univ.LMap.t Univ.Universe.t :=
  let fix make {C D : Set}
    (subst : Univ.LMap.t Univ.Universe.t)
    (function_parameter :
      list (Context.Rel.Declaration.pt C D) * list (option Univ.LMap.key) *
        list (Stdlib.Lazy.t Constr.types)) {struct subst}
    : Univ.LMap.t Univ.Universe.t :=
    match function_parameter with
    | (cons (Context.Rel.Declaration.LocalDef _ _ _) sign, exp, args) =&gt;
      make subst (sign, exp, args)
    | (cons _d sign, cons None exp, args) =&gt;
      let args :=
        match args with
        | cons _ args =&gt; args
        | [] =&gt; []
        end in
      make subst (sign, exp, args)
    | (cons _d sign, cons (Some u) exp, cons a args) =&gt;
      let s := Sorts.univ_of_sort (snd (dest_arity env (Lazy.force a))) in
      make (cons_subst u s subst) (sign, exp, args)
    |
      (cons (Context.Rel.Declaration.LocalAssum _na _t) sign, cons (Some u) exp,
        []) =&gt; make (remember_subst u subst) (sign, exp, [])
    | (_sign, [], _) =&gt; subst
    | ([], _, _) =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  make Univ.LMap.empty.

(* ❌ The definition of exceptions is not handled. *)
(* exception SingletonInductiveBecomesProp *)

Definition instantiate_universes {A B : Set}
  (env : Environ.env) (ctx : list (Context.Rel.Declaration.pt A B))
  (ar : Declarations.template_arity)
  (argsorts : array (Stdlib.Lazy.t Constr.types))
  : list (Context.Rel.Declaration.pt A B) * Sorts.t :=
  let args := (|Util.Array|).(CArray.ExtS.to_list) argsorts in
  let subst :=
    make_subst env
      (ctx, (Declarations.template_arity.template_param_levels ar), args) in
  let level :=
    Univ.subst_univs_universe (Univ.make_subst subst)
      (Declarations.template_arity.template_level ar) in
  let ty :=
    if is_type0m_univ level then
      Sorts.prop
    else
      if is_type0_univ level then
        Sorts.set
      else
        Sorts.sort_of_univ level in
  (ctx, ty).

Definition relevance_of_inductive (env : Environ.env) (ind : Names.MutInd.t * Z)
  : Sorts.relevance :=
  let '(_, mip) := lookup_mind_specif env ind in
  Declarations.one_inductive_body.mind_relevance mip.

Definition type_of_inductive_gen {A : Set} (op_staroptstar : option bool)
  : Environ.env -&gt; (A * Declarations.one_inductive_body) * Univ.Instance.t -&gt;
  array (Stdlib.Lazy.t Constr.types) -&gt; Constr.constr :=
  let polyprop :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; true
    end in
  fun env =&gt;
    fun function_parameter =&gt;
      let '((_, mip), u) := function_parameter in
      fun paramtyps =&gt;
        match Declarations.one_inductive_body.mind_arity mip with
        | Declarations.RegularArity a =&gt;
          subst_instance_constr u
            (Declarations.regular_inductive_arity.mind_user_arity a)
        | Declarations.TemplateArity ar =&gt;
          let ctx :=
            (|Util.List|).(CList.ExtS.rev)
              (Declarations.one_inductive_body.mind_arity_ctxt mip) in
          let '(ctx, s) := instantiate_universes env ctx ar paramtyps in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          Term.mkArity (((|Util.List|).(CList.ExtS.rev) ctx), s)
        end.

Definition type_of_inductive {A : Set}
  (env : Environ.env)
  (pind : (A * Declarations.one_inductive_body) * Univ.Instance.t)
  : Constr.constr :=
  type_of_inductive_gen None env pind
    (* ❌ Arrays not handled. *)
    [ ].

Definition constrained_type_of_inductive
  (env : Environ.env)
  (function_parameter :
    (Declarations.mutual_inductive_body * Declarations.one_inductive_body) *
      Univ.Instance.t) : Constr.constr * Univ.Constraint.t :=
  let '((mib, _mip), u) as pind := function_parameter in
  let ty := type_of_inductive env pind in
  let cst := instantiate_inductive_constraints mib u in
  (ty, cst).

Definition constrained_type_of_inductive_knowing_parameters
  (env : Environ.env)
  (function_parameter :
    (Declarations.mutual_inductive_body * Declarations.one_inductive_body) *
      Univ.Instance.t)
  : array (Stdlib.Lazy.t Constr.types) -&gt; Constr.constr * Univ.Constraint.t :=
  let '((mib, _mip), u) as pind := function_parameter in
  fun args =&gt;
    let ty := type_of_inductive_gen None env pind args in
    let cst := instantiate_inductive_constraints mib u in
    (ty, cst).

Definition type_of_inductive_knowing_parameters {A : Set}
  (env : Environ.env) (op_staroptstar : option bool)
  : (A * Declarations.one_inductive_body) * Univ.Instance.t -&gt;
  array (Stdlib.Lazy.t Constr.types) -&gt; Constr.constr :=
  let polyprop :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; true
    end in
  fun mip =&gt; fun args =&gt; type_of_inductive_gen (Some polyprop) env mip args.

Definition cumulate_constructor_univ
  (u : Univ.Universe.t) (function_parameter : Sorts.t) : Univ.Universe.t :=
  match function_parameter with
  | Sorts.SProp | Sorts.Prop =&gt; u
  | Sorts.__Set =&gt; Universe.sup Universe.type0 u
  | Sorts.Type u' =&gt; Universe.sup u u'
  end.

Definition max_inductive_sort : array Sorts.t -&gt; Univ.Universe.t :=
  (|Util.Array|).(CArray.ExtS.fold_left) cumulate_constructor_univ
    Universe.type0m.

Definition type_of_constructor
  (function_parameter : Names.constructor * Univ.Instance.t)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body -&gt;
  Constr.constr :=
  let '(cstr, u) := function_parameter in
  fun function_parameter =&gt;
    let '(mib, mip) := function_parameter in
    let ind := inductive_of_constructor cstr in
    let specif := Declarations.one_inductive_body.mind_user_lc mip in
    let i := index_of_constructor cstr in
    let nconstr :=
      (|Util.Array|).(CArray.ExtS.length)
        (Declarations.one_inductive_body.mind_consnames mip) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    constructor_instantiate (fst ind) u mib
      ((|Util.Array|).(CArray.ExtS.get) specif (Z.sub i 1)).

Definition constrained_type_of_constructor
  (function_parameter : Names.constructor * Univ.Instance.t)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body -&gt;
  Constr.constr * Univ.Constraint.t :=
  let '(_cstr, u) as cstru := function_parameter in
  fun function_parameter =&gt;
    let '(mib, _mip) as ind := function_parameter in
    let ty := type_of_constructor cstru ind in
    let cst := instantiate_inductive_constraints mib u in
    (ty, cst).

Definition arities_of_specif
  (function_parameter : Names.MutInd.t * Univ.Instance.t)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body -&gt;
  array Constr.constr :=
  let '(kn, u) := function_parameter in
  fun function_parameter =&gt;
    let '(mib, mip) := function_parameter in
    let specif := Declarations.one_inductive_body.mind_nf_lc mip in
    let map (function_parameter : Constr.rel_context * Constr.types)
      : Constr.constr :=
      let '(ctx, c) := function_parameter in
      let cty := Term.it_mkProd_or_LetIn c ctx in
      constructor_instantiate kn u mib cty in
    (|Util.Array|).(CArray.ExtS.map) map specif.

Definition arities_of_constructors {A : Set}
  (ind : (Names.MutInd.t * A) * Univ.Instance.t)
  (specif : Declarations.mutual_inductive_body * Declarations.one_inductive_body)
  : array Constr.constr := arities_of_specif ((fst (fst ind)), (snd ind)) specif.

Definition type_of_constructors {A : Set}
  (function_parameter : (Names.MutInd.t * A) * Univ.Instance.t)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body -&gt;
  array Constr.constr :=
  let '(ind, u) := function_parameter in
  fun function_parameter =&gt;
    let '(mib, mip) := function_parameter in
    let specif := Declarations.one_inductive_body.mind_user_lc mip in
    (|Util.Array|).(CArray.ExtS.map) (constructor_instantiate (fst ind) u mib)
      specif.

Definition inductive_sort_family (mip : Declarations.one_inductive_body)
  : Sorts.family :=
  match Declarations.one_inductive_body.mind_arity mip with
  | Declarations.RegularArity s =&gt;
    Sorts.family (Declarations.regular_inductive_arity.mind_sort s)
  | Declarations.TemplateArity _ =&gt; Sorts.InType
  end.

Definition mind_arity (mip : Declarations.one_inductive_body)
  : Constr.rel_context * Sorts.family :=
  ((Declarations.one_inductive_body.mind_arity_ctxt mip),
    (inductive_sort_family mip)).

Definition get_instantiated_arity {A : Set}
  (function_parameter : A * Univ.Instance.t)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body -&gt;
  list Constr.constr -&gt; Constr.rel_context * Sorts.family :=
  let '(_ind, u) := function_parameter in
  fun function_parameter =&gt;
    let '(mib, mip) := function_parameter in
    fun params =&gt;
      let '(sign, s) := mind_arity mip in
      ((full_inductive_instantiate mib u params sign), s).

Definition elim_sorts {A : Set}
  (function_parameter : A * Declarations.one_inductive_body)
  : list Sorts.family :=
  let '(_, mip) := function_parameter in
  Declarations.one_inductive_body.mind_kelim mip.

Definition is_private {A : Set}
  (function_parameter : Declarations.mutual_inductive_body * A) : bool :=
  let '(mib, _) := function_parameter in
  equiv_decb (Declarations.mutual_inductive_body.mind_private mib) (Some true).

Definition is_primitive_record {A : Set}
  (function_parameter : Declarations.mutual_inductive_body * A) : bool :=
  let '(mib, _) := function_parameter in
  match Declarations.mutual_inductive_body.mind_record mib with
  | Declarations.PrimRecord _ =&gt; true
  | Declarations.NotRecord | Declarations.FakeRecord =&gt; false
  end.

Definition build_dependent_inductive {A : Set}
  (ind : Constr.pinductive)
  (function_parameter : A * Declarations.one_inductive_body)
  : list Constr.constr -&gt; Constr.constr :=
  let '(_, mip) := function_parameter in
  fun params =&gt;
    let '(realargs, _) :=
      (|Util.List|).(CList.ExtS.chop)
        (Declarations.one_inductive_body.mind_nrealdecls mip)
        (Declarations.one_inductive_body.mind_arity_ctxt mip) in
    Term.applist
      ((mkIndU ind),
        (op_at
          ((|Util.List|).(CList.ExtS.map)
            (lift (Declarations.one_inductive_body.mind_nrealdecls mip)) params)
          (Context.Rel.to_extended_list mkRel 0 realargs))).

(* ❌ The definition of exceptions is not handled. *)
(* exception LocalArity *)

Definition check_allowed_sort {A : Set}
  (ksort : Sorts.family) (specif : A * Declarations.one_inductive_body)
  : unit :=
  if
    negb
      ((|CList|).(CList.ExtS.__exists) (Sorts.family_equal ksort)
        (elim_sorts specif)) then
    let s := inductive_sort_family (snd specif) in
    Stdlib.raise extensible_type_value
  else
    tt.

Definition is_correct_arity
  (env : Environ.env) (c : Constr.constr)
  (pj : Environ.punsafe_judgment Constr.constr Constr.constr)
  (ind : Names.inductive * Univ.Instance.t)
  (specif : Declarations.mutual_inductive_body * Declarations.one_inductive_body)
  (params : list Constr.constr) : unit :=
  let '(arsign, _) := get_instantiated_arity ind specif params in
  let fix srec
    (env : Environ.env) (pt : Constr.constr)
    (ar : list (Context.Rel.Declaration.pt Constr.constr Constr.constr))
    {struct env} : unit :=
    let pt' := whd_all env pt in
    match ((kind pt'), ar) with
    |
      (Constr.Prod na1 a1 t, cons (Context.Rel.Declaration.LocalAssum _ a1') ar')
      =&gt;
      let '_ :=
        (* ❌ Try-with are not handled *)
        try (conv None None env None a1 a1') in
      srec (push_rel (Context.Rel.Declaration.LocalAssum na1 a1) env) t ar'
    | (Constr.Prod na1 a1 a2, []) =&gt;
      let env' := push_rel (Context.Rel.Declaration.LocalAssum na1 a1) env in
      let ksort :=
        match kind (whd_all env' a2) with
        | Constr.Sort s =&gt; Sorts.family s
        | _ =&gt; Stdlib.raise extensible_type_value
        end in
      let dep_ind := build_dependent_inductive ind specif params in
      let '_ :=
        (* ❌ Try-with are not handled *)
        try (conv None None env None a1 dep_ind) in
      check_allowed_sort ksort specif
    | (_, cons ((Context.Rel.Declaration.LocalDef _ _ _) as d) ar') =&gt;
      srec (push_rel d env) (lift 1 pt') ar'
    | _ =&gt; Stdlib.raise extensible_type_value
    end in
  (* ❌ Try-with are not handled *)
  try
    (srec env (Environ.punsafe_judgment.uj_type pj)
      ((|Util.List|).(CList.ExtS.rev) arsign)).

Definition build_branches_type
  (function_parameter : Names.inductive * Univ.Instance.t)
  : Declarations.mutual_inductive_body * Declarations.one_inductive_body -&gt;
  list Constr.constr -&gt; Constr.constr -&gt; array Constr.types :=
  let '(ind, u) := function_parameter in
  fun function_parameter =&gt;
    let '(_, mip) as specif := function_parameter in
    fun params =&gt;
      fun p =&gt;
        let build_one_branch
          (i : Z) (function_parameter : Constr.rel_context * Constr.types)
          : Constr.types :=
          let '(ctx, c) := function_parameter in
          let cty := Term.it_mkProd_or_LetIn c ctx in
          let typi := full_constructor_instantiate (ind, u, specif, params) cty
            in
          let '(cstrsign, ccl) := Term.decompose_prod_assum typi in
          let nargs := Context.Rel.length cstrsign in
          let '(_, allargs) := decompose_app ccl in
          let '(lparams, vargs) :=
            (|Util.List|).(CList.ExtS.chop) (inductive_params specif) allargs in
          let cargs :=
            let cstr := ith_constructor_of_inductive ind (Z.add i 1) in
            let dep_cstr :=
              Term.applist
                ((mkConstructU (cstr, u)),
                  (op_at lparams (Context.Rel.to_extended_list mkRel 0 cstrsign)))
              in
            op_at vargs [ dep_cstr ] in
          let base :=
            Term.lambda_appvect_assum
              (Z.add (Declarations.one_inductive_body.mind_nrealdecls mip) 1)
              (lift nargs p) ((|Util.Array|).(CArray.ExtS.of_list) cargs) in
          Term.it_mkProd_or_LetIn base cstrsign in
        (|Util.Array|).(CArray.ExtS.mapi) build_one_branch
          (Declarations.one_inductive_body.mind_nf_lc mip).

Definition build_case_type
  (env : Environ.env) (n : Z) (p : Constr.constr) (c : Constr.constr)
  (realargs : list Constr.constr) : Constr.constr :=
  whd_betaiota env
    (Term.lambda_appvect_assum (Z.add n 1) p
      ((|Util.Array|).(CArray.ExtS.of_list) (op_at realargs [ c ]))).

Definition type_case_branches
  (env : Environ.env)
  (function_parameter : (Names.inductive * Univ.Instance.t) * list Constr.constr)
  : Environ.punsafe_judgment Constr.constr Constr.constr -&gt; Constr.constr -&gt;
  array Constr.types * Constr.constr :=
  let '(pind, largs) := function_parameter in
  fun pj =&gt;
    fun c =&gt;
      let specif := lookup_mind_specif env (fst pind) in
      let nparams := inductive_params specif in
      let '(params, realargs) := (|Util.List|).(CList.ExtS.chop) nparams largs
        in
      let p := Environ.punsafe_judgment.uj_val pj in
      let '_ := is_correct_arity env c pj pind specif params in
      let lc := build_branches_type pind specif params p in
      let ty :=
        build_case_type env
          (Declarations.one_inductive_body.mind_nrealdecls (snd specif)) p c
          realargs in
      (lc, ty).

Definition check_case_info
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : Sorts.relevance -&gt; Constr.case_info -&gt; unit :=
  let '(indsp, u) := function_parameter in
  fun r =&gt;
    fun ci =&gt;
      let '(mib, mip) as spec := lookup_mind_specif env indsp in
      if
        orb (negb (eq_ind indsp (Constr.case_info.ci_ind ci)))
          (orb
            (negb
              (Int.equal (Declarations.mutual_inductive_body.mind_nparams mib)
                (Constr.case_info.ci_npar ci)))
            (orb
              (negb
                ((|Util.Array|).(CArray.ExtS.equal) Int.equal
                  (Declarations.one_inductive_body.mind_consnrealdecls mip)
                  (Constr.case_info.ci_cstr_ndecls ci)))
              (orb
                (negb
                  ((|Util.Array|).(CArray.ExtS.equal) Int.equal
                    (Declarations.one_inductive_body.mind_consnrealargs mip)
                    (Constr.case_info.ci_cstr_nargs ci)))
                (orb
                  (negb (Stdlib.op_eqeq (Constr.case_info.ci_relevance ci) r))
                  (is_primitive_record spec))))) then
        Stdlib.raise extensible_type_value
      else
        tt.

Inductive size : Set :=
| Large : size
| Strict : size.

Definition size_glb (s1 : size) (s2 : size) : size :=
  match (s1, s2) with
  | (Strict, Strict) =&gt; Strict
  | _ =&gt; Large
  end.

Inductive subterm_spec : Set :=
| Subterm : size * Declarations.wf_paths -&gt; subterm_spec
| Dead_code : subterm_spec
| Not_subterm : subterm_spec.

Definition eq_wf_paths
  : Rtree.t Declarations.recarg -&gt; Rtree.t Declarations.recarg -&gt; bool :=
  Rtree.equal Declareops.eq_recarg.

Definition inter_recarg (r1 : Declarations.recarg) (r2 : Declarations.recarg)
  : option Declarations.recarg :=
  match (r1, r2) with
  | (Declarations.Norec, Declarations.Norec) =&gt; Some r1
  |
    (Declarations.Mrec i1, Declarations.Mrec i2) |
    (Declarations.Imbr i1, Declarations.Imbr i2) |
    (Declarations.Mrec i1, Declarations.Imbr i2) =&gt;
    if Names.eq_ind i1 i2 then
      Some r1
    else
      None
  | (Declarations.Imbr i1, Declarations.Mrec i2) =&gt;
    if Names.eq_ind i1 i2 then
      Some r2
    else
      None
  | _ =&gt; None
  end.

Definition inter_wf_paths
  : Rtree.t Declarations.recarg -&gt; Rtree.t Declarations.recarg -&gt;
  Rtree.t Declarations.recarg :=
  Rtree.inter Declareops.eq_recarg inter_recarg Declarations.Norec.

Definition incl_wf_paths
  : Rtree.t Declarations.recarg -&gt; Rtree.t Declarations.recarg -&gt; bool :=
  Rtree.incl Declareops.eq_recarg inter_recarg Declarations.Norec.

Definition spec_of_tree (t : Declarations.wf_paths) : subterm_spec :=
  if eq_wf_paths t mk_norec then
    Not_subterm
  else
    Subterm (Strict, t).

Definition inter_spec (s1 : subterm_spec) (s2 : subterm_spec) : subterm_spec :=
  match (s1, s2) with
  | (_, Dead_code) =&gt; s1
  | (Dead_code, _) =&gt; s2
  | (Not_subterm, _) =&gt; s1
  | (_, Not_subterm) =&gt; s2
  | (Subterm (a1, t1), Subterm (a2, t2)) =&gt;
    Subterm ((size_glb a1 a2), (inter_wf_paths t1 t2))
  end.

Definition subterm_spec_glb : array subterm_spec -&gt; subterm_spec :=
  (|Util.Array|).(CArray.ExtS.fold_left) inter_spec Dead_code.

Module guard_env.
  Record record := {
    env : Environ.env;
    rel_min : Z;
    genv : list (Stdlib.Lazy.t subterm_spec) }.
  Definition with_env (r : record) env : record :=
    {| env := env; rel_min := rel_min r; genv := genv r |}.
  Definition with_rel_min (r : record) rel_min : record :=
    {| env := env r; rel_min := rel_min; genv := genv r |}.
  Definition with_genv (r : record) genv : record :=
    {| env := env r; rel_min := rel_min r; genv := genv |}.
End guard_env.
Definition guard_env := guard_env.record.

Definition make_renv
  (env : Environ.env) (recarg : Z) (tree : Declarations.wf_paths) : guard_env :=
  {| guard_env.env := env; guard_env.rel_min := Z.add recarg 2;
    guard_env.genv := [ Lazy.from_val (Subterm (Large, tree)) ] |}.

Definition push_var
  (renv : guard_env)
  (function_parameter :
    Context.binder_annot Names.Name.t * Constr.types *
      Stdlib.Lazy.t subterm_spec) : guard_env :=
  let '(x, ty, spec) := function_parameter in
  {|
    guard_env.env :=
      push_rel (Context.Rel.Declaration.LocalAssum x ty) (guard_env.env renv);
    guard_env.rel_min := Z.add (guard_env.rel_min renv) 1;
    guard_env.genv := cons spec (guard_env.genv renv) |}.

Definition assign_var_spec
  (renv : guard_env) (function_parameter : Z * Stdlib.Lazy.t subterm_spec)
  : guard_env :=
  let '(i, spec) := function_parameter in
  guard_env.with_genv renv
    ((|Util.List|).(CList.ExtS.assign) (guard_env.genv renv) (Z.sub i 1) spec).

Definition push_var_renv
  (renv : guard_env)
  (function_parameter : Context.binder_annot Names.Name.t * Constr.types)
  : guard_env :=
  let '(x, ty) := function_parameter in
  push_var renv
    (x, ty,
      (* ❌ Lazy expressions are not handled *)
      (lazy Not_subterm)).

Definition subterm_var (p : Z) (renv : guard_env) : subterm_spec :=
  (* ❌ Try-with are not handled *)
  try
    (Lazy.force
      ((|Util.List|).(CList.ExtS.nth) (guard_env.genv renv) (Z.sub p 1))).

Definition push_ctxt_renv
  (renv : guard_env) (ctxt : Context.Rel.pt Constr.constr Constr.types)
  : guard_env :=
  let n := Context.Rel.length ctxt in
  {| guard_env.env := push_rel_context ctxt (guard_env.env renv);
    guard_env.rel_min := Z.add (guard_env.rel_min renv) n;
    guard_env.genv :=
      iterate
        (fun ge =&gt;
          cons
            (* ❌ Lazy expressions are not handled *)
            (lazy Not_subterm) ge) n (guard_env.genv renv) |}.

Definition push_fix_renv
  (renv : guard_env)
  (function_parameter :
    array (Context.binder_annot Names.Name.t) * array Constr.types *
      array Constr.constr) : guard_env :=
  let '(_, v, _) as recdef := function_parameter in
  let n := (|Util.Array|).(CArray.ExtS.length) v in
  {| guard_env.env := push_rec_types recdef (guard_env.env renv);
    guard_env.rel_min := Z.add (guard_env.rel_min renv) n;
    guard_env.genv :=
      iterate
        (fun ge =&gt;
          cons
            (* ❌ Lazy expressions are not handled *)
            (lazy Not_subterm) ge) n (guard_env.genv renv) |}.

Inductive stack_element : Set :=
| SClosure : guard_env -&gt; Constr.constr -&gt; stack_element
| SArg : Stdlib.Lazy.t subterm_spec -&gt; stack_element.

Definition push_stack_closures
  (renv : guard_env) (l : list Constr.constr) (stack : list stack_element)
  : list stack_element :=
  (|Util.List|).(CList.ExtS.fold_right)
    (fun h =&gt; fun b =&gt; cons (SClosure renv h) b) l stack.

Definition push_stack_args
  (l : list (Stdlib.Lazy.t subterm_spec)) (stack : list stack_element)
  : list stack_element :=
  (|Util.List|).(CList.ExtS.fold_right) (fun h =&gt; fun b =&gt; cons (SArg h) b) l
    stack.

Definition lookup_subterms (env : Environ.env) (ind : Names.MutInd.t * Z)
  : Declarations.wf_paths :=
  let '(_, mip) := lookup_mind_specif env ind in
  Declarations.one_inductive_body.mind_recargs mip.

Definition match_inductive (ind : Names.inductive) (ra : Declarations.recarg)
  : bool :=
  match ra with
  | Declarations.Mrec i | Declarations.Imbr i =&gt; eq_ind ind i
  | Declarations.Norec =&gt; false
  end.

Definition branches_specif
  (renv : guard_env) (c_spec : Stdlib.Lazy.t subterm_spec)
  (ci : Constr.case_info) : array (list (lazy_t subterm_spec)) :=
  let car :=
    let '(_, mip) :=
      lookup_mind_specif (guard_env.env renv) (Constr.case_info.ci_ind ci) in
    let v := dest_subterms (Declarations.one_inductive_body.mind_recargs mip) in
    (|Util.Array|).(CArray.ExtS.map) (|Util.List|).(CList.ExtS.length) v in
  (|Util.Array|).(CArray.ExtS.mapi)
    (fun i =&gt;
      fun nca =&gt;
        let lvra :=
          (* ❌ Lazy expressions are not handled *)
          lazy
            match
              ((Lazy.force c_spec),
                match Lazy.force c_spec with
                | Subterm (_, t) =&gt;
                  match_inductive (Constr.case_info.ci_ind ci) (dest_recarg t)
                | _ =&gt; false
                end) with
            | (Subterm (_, t), true) =&gt;
              let vra :=
                (|Util.Array|).(CArray.ExtS.of_list)
                  ((|Util.Array|).(CArray.ExtS.get) (dest_subterms t) i) in
              (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
              (* ❌ instruction_sequence &quot;;&quot; *)
              (|Util.Array|).(CArray.ExtS.map) spec_of_tree vra
            | (Dead_code, _) =&gt; (|Util.Array|).(CArray.ExtS.make) nca Dead_code
            | (_, _) =&gt; (|Util.Array|).(CArray.ExtS.make) nca Not_subterm
            end in
        (|Util.List|).(CList.ExtS.init) nca
          (fun j =&gt;
            (* ❌ Lazy expressions are not handled *)
            lazy ((|Util.Array|).(CArray.ExtS.get) (Lazy.force lvra) j))) car.

Definition check_inductive_codomain (env : Environ.env) (p : Constr.constr)
  : bool :=
  let '(absctx, ar) := dest_lam_assum env p in
  let env := push_rel_context absctx env in
  let '(arctx, s) := dest_prod_assum env ar in
  let env := push_rel_context arctx env in
  let '(i, _l') := decompose_app (whd_all env s) in
  isInd i.

Definition ienv_push_var {A : Set}
  (function_parameter : Environ.env * list (Declarations.recarg * A))
  : Context.binder_annot Names.Name.t * Constr.types * A -&gt;
  Environ.env * list (Declarations.recarg * A) :=
  let '(env, lra) := function_parameter in
  fun function_parameter =&gt;
    let '(x, a, ra) := function_parameter in
    ((push_rel (Context.Rel.Declaration.LocalAssum x a) env),
      (cons (Declarations.Norec, ra) lra)).

Definition ienv_push_inductive {A : Set}
  (function_parameter : Environ.env * list (Declarations.recarg * Rtree.t A))
  : (Names.MutInd.t * Univ.Instance.t) * list Constr.constr -&gt;
  Environ.env * list (Declarations.recarg * Rtree.t A) :=
  let '(env, ra_env) := function_parameter in
  fun function_parameter =&gt;
    let '((mind, u), lpar) := function_parameter in
    let mib := Environ.lookup_mind mind env in
    let ntypes := Declarations.mutual_inductive_body.mind_ntypes mib in
    let push_ind (specif : Declarations.one_inductive_body) (env : Environ.env)
      : Environ.env :=
      let r := Declarations.one_inductive_body.mind_relevance specif in
      let anon := Context.make_annot Names.Anonymous r in
      let decl :=
        Context.Rel.Declaration.LocalAssum anon
          (hnf_prod_applist env (type_of_inductive env ((mib, specif), u)) lpar)
        in
      push_rel decl env in
    let env :=
      (|Util.Array|).(CArray.ExtS.fold_right) push_ind
        (Declarations.mutual_inductive_body.mind_packets mib) env in
    let rc :=
      (|Util.Array|).(CArray.ExtS.mapi)
        (fun j =&gt; fun t =&gt; ((Declarations.Imbr (mind, j)), t))
        (Rtree.mk_rec_calls ntypes) in
    let lra_ind := (|Util.Array|).(CArray.ExtS.rev_to_list) rc in
    let ra_env :=
      (|Util.List|).(CList.ExtS.map)
        (fun function_parameter =&gt;
          let '(r, t) := function_parameter in
          (r, (Rtree.lift ntypes t))) ra_env in
    (env, (op_at lra_ind ra_env)).

Fixpoint ienv_decompose_prod
  (function_parameter :
    Environ.env * list (Declarations.recarg * Declarations.wf_paths))
  {struct function_parameter}
  : Int.t -&gt; Constr.constr -&gt;
  (Environ.env * list (Declarations.recarg * Declarations.wf_paths)) *
    Constr.constr :=
  let '(env, _) as ienv := function_parameter in
  fun n =&gt;
    fun c =&gt;
      if Int.equal n 0 then
        (ienv, c)
      else
        let c' := whd_all env c in
        match kind c' with
        | Constr.Prod na a b =&gt;
          let ienv' := ienv_push_var ienv (na, a, mk_norec) in
          ienv_decompose_prod ienv' (Z.sub n 1) b
        | _ =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        end.

Definition dummy_univ : Univ.Level.t :=
  make (UGlobal.make (DirPath.make [ Id.of_string &quot;implicit&quot; ]) 0).

Definition dummy_implicit_sort : Constr.types :=
  mkType (Universe.make dummy_univ).

Definition lambda_implicit_lift (n : Z) (a : Constr.constr) : Constr.constr :=
  let anon := Context.make_annot Names.Anonymous Sorts.Relevant in
  let lambda_implicit (a : Constr.constr) : Constr.constr :=
    mkLambda (anon, dummy_implicit_sort, a) in
  iterate lambda_implicit n (lift n a).

Definition abstract_mind_lc
  (ntyps : Z) (npars : Int.t) (lc : array (Constr.rel_context * Constr.types))
  : array Constr.types :=
  let lc :=
    (|Util.Array|).(CArray.ExtS.map)
      (fun function_parameter =&gt;
        let '(ctx, c) := function_parameter in
        Term.it_mkProd_or_LetIn c ctx) lc in
  if Int.equal npars 0 then
    lc
  else
    let make_abs :=
      (|Util.List|).(CList.ExtS.init) ntyps
        (fun i =&gt; lambda_implicit_lift npars (mkRel (Z.add i 1))) in
    (|Util.Array|).(CArray.ExtS.map) (substl make_abs) lc.

Definition get_recargs_approx
  (env : Environ.env) (tree : Declarations.wf_paths)
  (ind : Names.inductive * Univ.Instance.t) (args : list Constr.constr)
  : Declarations.wf_paths :=
  let fix build_recargs
    (function_parameter :
      Environ.env * list (Declarations.recarg * Declarations.wf_paths))
    {struct function_parameter}
    : Declarations.wf_paths -&gt; Constr.constr -&gt; Declarations.wf_paths :=
    let '(env, ra_env) as ienv := function_parameter in
    fun tree =&gt;
      fun c =&gt;
        let '(x, largs) := decompose_app (whd_all env c) in
        match kind x with
        | Constr.Prod na b d =&gt;
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          build_recargs (ienv_push_var ienv (na, b, mk_norec)) tree d
        | Constr.Rel k =&gt;
          (* ❌ Try-with are not handled *)
          try (snd ((|Util.List|).(CList.ExtS.nth) ra_env (Z.sub k 1)))
        | Constr.Ind ind_kn =&gt;
          match
            ((dest_recarg tree),
              match dest_recarg tree with
              | Declarations.Imbr kn' | Declarations.Mrec kn' =&gt;
                eq_ind (fst ind_kn) kn'
              | _ =&gt; false
              end) with
          | (Declarations.Imbr kn' | Declarations.Mrec kn', true) =&gt;
            build_recargs_nested ienv tree (ind_kn, largs)
          | (_, _) =&gt; mk_norec
          end
        | _err =&gt; mk_norec
        end
  with build_recargs_nested
    (function_parameter :
      Environ.env * list (Declarations.recarg * Declarations.wf_paths))
    {struct function_parameter}
    : Declarations.wf_paths -&gt;
    (Names.inductive * Univ.Instance.t) * list Constr.constr -&gt;
    Declarations.wf_paths :=
    let '(env, _ra_env) as ienv := function_parameter in
    fun tree =&gt;
      fun function_parameter =&gt;
        let '(((mind, i), u), largs) := function_parameter in
        if eq_wf_paths tree mk_norec then
          tree
        else
          let mib := Environ.lookup_mind mind env in
          let auxnpar := Declarations.mutual_inductive_body.mind_nparams_rec mib
            in
          let nonrecpar :=
            Z.sub (Declarations.mutual_inductive_body.mind_nparams mib) auxnpar
            in
          let '(lpar, _) := (|Util.List|).(CList.ExtS.chop) auxnpar largs in
          let auxntyp := Declarations.mutual_inductive_body.mind_ntypes mib in
          let '(env', _) as ienv' := ienv_push_inductive ienv ((mind, u), lpar)
            in
          let lpar' := (|Util.List|).(CList.ExtS.map) (lift auxntyp) lpar in
          let trees :=
            if Int.equal auxntyp 1 then
              (* ❌ Arrays not handled. *)
              [ dest_subterms tree ]
            else
              (|Util.Array|).(CArray.ExtS.map)
                (fun mip =&gt;
                  dest_subterms
                    (Declarations.one_inductive_body.mind_recargs mip))
                (Declarations.mutual_inductive_body.mind_packets mib) in
          let mk_irecargs (j : Z) (specif : Declarations.one_inductive_body)
            : Declarations.wf_paths :=
            let auxlcvect :=
              abstract_mind_lc auxntyp auxnpar
                (Declarations.one_inductive_body.mind_nf_lc specif) in
            let paths :=
              (|Util.Array|).(CArray.ExtS.mapi)
                (fun k =&gt;
                  fun c =&gt;
                    let c' := hnf_prod_applist env' c lpar' in
                    let '(ienv', c') := ienv_decompose_prod ienv' nonrecpar c'
                      in
                    build_recargs_constructors ienv'
                      ((|Util.Array|).(CArray.ExtS.get)
                        ((|Util.Array|).(CArray.ExtS.get) trees j) k) c')
                auxlcvect in
            mk_paths (Declarations.Imbr (mind, j)) paths in
          let irecargs :=
            (|Util.Array|).(CArray.ExtS.mapi) mk_irecargs
              (Declarations.mutual_inductive_body.mind_packets mib) in
          (|Util.Array|).(CArray.ExtS.get) (Rtree.mk_rec irecargs) i
  with build_recargs_constructors
    (ienv : Environ.env * list (Declarations.recarg * Declarations.wf_paths))
    (trees : list Declarations.wf_paths) (c : Constr.constr) {struct ienv}
    : list Declarations.wf_paths :=
    let fix recargs_constr_rec
      (function_parameter :
        Environ.env * list (Declarations.recarg * Declarations.wf_paths))
      {struct function_parameter}
      : list Declarations.wf_paths -&gt; list Declarations.wf_paths -&gt;
      Constr.constr -&gt; list Declarations.wf_paths :=
      let '(env, _ra_env) as ienv := function_parameter in
      fun trees =&gt;
        fun lrec =&gt;
          fun c =&gt;
            let '(x, largs) := decompose_app (whd_all env c) in
            match kind x with
            | Constr.Prod na b d =&gt;
              let '_ :=
                (* ❌ Assert instruction is not handled. *)
                assert ((|Util.List|).(CList.ExtS.is_empty) largs) in
              let recarg :=
                build_recargs ienv ((|Util.List|).(CList.ExtS.hd) trees) b in
              let ienv' := ienv_push_var ienv (na, b, mk_norec) in
              recargs_constr_rec ienv' ((|Util.List|).(CList.ExtS.tl) trees)
                (cons recarg lrec) d
            | _hd =&gt; (|Util.List|).(CList.ExtS.rev) lrec
            end in
    recargs_constr_rec ienv trees [] c in
  build_recargs_nested (env, []) tree (ind, args).

Definition restrict_spec
  (env : Environ.env) (spec : subterm_spec) (p : Constr.constr)
  : subterm_spec :=
  if equiv_decb spec Not_subterm then
    spec
  else
    let '(absctx, ar) := dest_lam_assum env p in
    if noccur_with_meta 1 (Context.Rel.length absctx) ar then
      spec
    else
      let env := push_rel_context absctx env in
      let '(arctx, s) := dest_prod_assum env ar in
      let env := push_rel_context arctx env in
      let '(i, args) := decompose_app (whd_all env s) in
      match kind i with
      | Constr.Ind i =&gt;
        match spec with
        | Dead_code =&gt; spec
        | Subterm (st, tree) =&gt;
          let recargs := get_recargs_approx env tree i args in
          let recargs := inter_wf_paths tree recargs in
          Subterm (st, recargs)
        | _ =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        end
      | _ =&gt; Not_subterm
      end.

Fixpoint subterm_specif
  (renv : guard_env) (stack : list stack_element) (t : Constr.constr)
  {struct renv} : subterm_spec :=
  let '(f, l) := decompose_app (whd_all (guard_env.env renv) t) in
  match kind f with
  | Constr.Rel k =&gt; subterm_var k renv
  | Constr.Case ci p c lbr =&gt;
    let stack' := push_stack_closures renv l stack in
    let cases_spec := branches_specif renv (lazy_subterm_specif renv [] c) ci in
    let stl :=
      (|Util.Array|).(CArray.ExtS.mapi)
        (fun i =&gt;
          fun br' =&gt;
            let stack_br :=
              push_stack_args ((|Util.Array|).(CArray.ExtS.get) cases_spec i)
                stack' in
            subterm_specif renv stack_br br') lbr in
    let spec := subterm_spec_glb stl in
    restrict_spec (guard_env.env renv) spec p
  | Constr.Fix ((recindxs, i), (_, typarray, bodies) as recdef) =&gt;
    if
      negb
        (check_inductive_codomain (guard_env.env renv)
          ((|Util.Array|).(CArray.ExtS.get) typarray i)) then
      Not_subterm
    else
      let '(ctxt, clfix) :=
        dest_prod (guard_env.env renv)
          ((|Util.Array|).(CArray.ExtS.get) typarray i) in
      let oind :=
        let env' := push_rel_context ctxt (guard_env.env renv) in
        (* ❌ Try-with are not handled *)
        try (Some (fst (find_inductive env' clfix))) in
      match oind with
      | None =&gt; Not_subterm
      | Some (ind, _) =&gt;
        let nbfix := (|Util.Array|).(CArray.ExtS.length) typarray in
        let recargs := lookup_subterms (guard_env.env renv) ind in
        let renv' := push_fix_renv renv recdef in
        let renv' :=
          assign_var_spec renv'
            ((Z.sub nbfix i),
              (* ❌ Lazy expressions are not handled *)
              (lazy (Subterm (Strict, recargs)))) in
        let decrArg := (|Util.Array|).(CArray.ExtS.get) recindxs i in
        let theBody := (|Util.Array|).(CArray.ExtS.get) bodies i in
        let nbOfAbst := Z.add decrArg 1 in
        let '(sign, strippedBody) := Term.decompose_lam_n_assum nbOfAbst theBody
          in
        let stack' := push_stack_closures renv l stack in
        let renv'' := push_ctxt_renv renv' sign in
        let renv'' :=
          if OCaml.Stdlib.lt ((|Util.List|).(CList.ExtS.length) stack') nbOfAbst
            then
            renv''
          else
            let decrArg := (|Util.List|).(CList.ExtS.nth) stack' decrArg in
            let arg_spec := stack_element_specif decrArg in
            assign_var_spec renv'' (1, arg_spec) in
        subterm_specif renv'' [] strippedBody
      end
  | Constr.Lambda x a b =&gt;
    let '_ :=
      (* ❌ Assert instruction is not handled. *)
      assert ((|Util.List|).(CList.ExtS.is_empty) l) in
    let '(spec, stack') := extract_stack stack in
    subterm_specif (push_var renv (x, a, spec)) stack' b
  | Constr.Meta _ | Constr.Evar _ =&gt; Dead_code
  | Constr.Proj p c =&gt;
    let subt := subterm_specif renv stack c in
    match subt with
    | Subterm (_s, wf) =&gt;
      let wf_args := (|Util.Array|).(CArray.ExtS.get) (dest_subterms wf) 0 in
      let n := Projection.arg p in
      spec_of_tree ((|Util.List|).(CList.ExtS.nth) wf_args n)
    | Dead_code =&gt; Dead_code
    | Not_subterm =&gt; Not_subterm
    end
  |
    Constr.Var _ | Constr.Sort _ | Constr.Cast _ _ _ | Constr.Prod _ _ _ |
    Constr.LetIn _ _ _ _ | Constr.App _ _ | Constr.Const _ | Constr.Ind _ |
    Constr.Construct _ | Constr.CoFix _ | Constr.Int _ =&gt; Not_subterm
  end

with lazy_subterm_specif
  (renv : guard_env) (stack : list stack_element) (t : Constr.constr)
  {struct renv} : Stdlib.Lazy.t subterm_spec :=
  (* ❌ Lazy expressions are not handled *)
  lazy (subterm_specif renv stack t)

with stack_element_specif (function_parameter : stack_element)
  {struct function_parameter} : Stdlib.Lazy.t subterm_spec :=
  match function_parameter with
  | SClosure h_renv h =&gt; lazy_subterm_specif h_renv [] h
  | SArg x =&gt; x
  end

with extract_stack (function_parameter : list stack_element)
  {struct function_parameter}
  : Stdlib.Lazy.t subterm_spec * list stack_element :=
  match function_parameter with
  | [] =&gt; ((Lazy.from_val Not_subterm), [])
  | cons h t =&gt; ((stack_element_specif h), t)
  end.

Definition check_is_subterm
  (x : Stdlib.Lazy.t subterm_spec) (tree : Rtree.t Declarations.recarg)
  : bool :=
  match Lazy.force x with
  | Subterm (Strict, tree') =&gt; incl_wf_paths tree tree'
  | Dead_code =&gt; true
  | _ =&gt; false
  end.

(* ❌ The definition of exceptions is not handled. *)
(* exception FixGuardError *)

Definition error_illegal_rec_call {A : Set}
  (renv : guard_env) (fx : Z) (function_parameter : guard_env * Constr.constr)
  : A :=
  let '(arg_renv, arg) := function_parameter in
  let '(_, le_vars, lt_vars) :=
    (|Util.List|).(CList.ExtS.fold_left)
      (fun function_parameter =&gt;
        let '(i, le, lt) := function_parameter in
        fun sbt =&gt;
          match Lazy.force sbt with
          | Subterm (Strict, _) | Dead_code =&gt; ((Z.add i 1), le, (cons i lt))
          | Subterm (Large, _) =&gt; ((Z.add i 1), (cons i le), lt)
          | _ =&gt; ((Z.add i 1), le, lt)
          end) (1, [], []) (guard_env.genv renv) in
  Stdlib.raise extensible_type_value.

Definition error_partial_apply {A : Set} (renv : guard_env) (fx : Z) : A :=
  Stdlib.raise extensible_type_value.

Definition filter_stack_domain
  (env : Environ.env) (p : Constr.constr) (stack : list stack_element)
  : list stack_element :=
  let '(absctx, ar) := dest_lam_assum env p in
  if noccur_with_meta 1 (Context.Rel.length absctx) ar then
    stack
  else
    let env := push_rel_context absctx env in
    let fix filter_stack
      (env : Environ.env) (ar : Constr.constr) (stack : list stack_element)
      {struct env} : list stack_element :=
      let t := whd_all env ar in
      match (stack, (kind t)) with
      | (cons elt stack', Constr.Prod n a c0) =&gt;
        let d := Context.Rel.Declaration.LocalAssum n a in
        let '(ctx, a) := dest_prod_assum env a in
        let env := push_rel_context ctx env in
        let '(ty, args) := decompose_app (whd_all env a) in
        let elt :=
          match kind ty with
          | Constr.Ind ind =&gt;
            let spec' := stack_element_specif elt in
            match Lazy.force spec' with
            | Not_subterm | Dead_code =&gt; elt
            | Subterm (s, path) =&gt;
              let recargs := get_recargs_approx env path ind args in
              let path := inter_wf_paths path recargs in
              SArg
                (* ❌ Lazy expressions are not handled *)
                (lazy (Subterm (s, path)))
            end
          | _ =&gt;
            SArg
              (* ❌ Lazy expressions are not handled *)
              (lazy Not_subterm)
          end in
        cons elt (filter_stack (push_rel d env) c0 stack')
      | (_, _) =&gt;
        (|Util.List|).(CList.ExtS.fold_right)
          (fun function_parameter =&gt;
            let '_ := function_parameter in
            fun l =&gt;
              cons
                (SArg
                  (* ❌ Lazy expressions are not handled *)
                  (lazy Not_subterm)) l) stack []
      end in
    filter_stack env ar stack.

Definition judgment_of_fixpoint {A B C : Set}
  (function_parameter : A * array B * array C)
  : array (Environ.punsafe_judgment C B) :=
  let '(_, types, bodies) := function_parameter in
  (|Util.Array|).(CArray.ExtS.map2)
    (fun typ =&gt;
      fun body =&gt;
        {| Environ.punsafe_judgment.uj_val := body;
          Environ.punsafe_judgment.uj_type := typ |}) types bodies.

Definition check_one_fix
  (renv : guard_env) (recpos : array Z)
  (trees : array (Rtree.t Declarations.recarg)) (def : Constr.constr) : unit :=
  let nfi := (|Util.Array|).(CArray.ExtS.length) recpos in
  let fix check_rec_call
    (renv : guard_env) (stack : list stack_element) (t : Constr.constr)
    {struct renv} : unit :=
    if noccur_with_meta (guard_env.rel_min renv) nfi t then
      tt
    else
      let '(f, l) := decompose_app (whd_betaiotazeta (guard_env.env renv) t) in
      match kind f with
      | Constr.Rel p =&gt;
        if
          andb (OCaml.Stdlib.le (guard_env.rel_min renv) p)
            (OCaml.Stdlib.lt p (Z.add (guard_env.rel_min renv) nfi)) then
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          let glob := Z.sub (Z.sub (Z.add (guard_env.rel_min renv) nfi) 1) p in
          let np := (|Util.Array|).(CArray.ExtS.get) recpos glob in
          let stack' := push_stack_closures renv l stack in
          if OCaml.Stdlib.le ((|Util.List|).(CList.ExtS.length) stack') np then
            error_partial_apply renv glob
          else
            let z := (|Util.List|).(CList.ExtS.nth) stack' np in
            if
              negb
                (check_is_subterm (stack_element_specif z)
                  ((|Util.Array|).(CArray.ExtS.get) trees glob)) then
              match z with
              | SClosure z z' =&gt; error_illegal_rec_call renv glob (z, z')
              | SArg _ =&gt; error_partial_apply renv glob
              end
            else
              tt
        else
          match lookup_rel p (guard_env.env renv) with
          | Context.Rel.Declaration.LocalAssum _ _ =&gt;
            (|Util.List|).(CList.ExtS.iter) (check_rec_call renv []) l
          | Context.Rel.Declaration.LocalDef _ c _ =&gt;
            (* ❌ Try-with are not handled *)
            try ((|Util.List|).(CList.ExtS.iter) (check_rec_call renv []) l)
          end
      | Constr.Case ci p c_0 lrest =&gt;
        (* ❌ Try-with are not handled *)
        try
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (let case_spec :=
            branches_specif renv (lazy_subterm_specif renv [] c_0) ci in
          let stack' := push_stack_closures renv l stack in
          let stack' := filter_stack_domain (guard_env.env renv) p stack' in
          OCaml.Stdlib.reverse_apply lrest
            ((|Util.Array|).(CArray.ExtS.iteri)
              (fun k =&gt;
                fun br' =&gt;
                  let stack_br :=
                    push_stack_args
                      ((|Util.Array|).(CArray.ExtS.get) case_spec k) stack' in
                  check_rec_call renv stack_br br')))
      | Constr.Fix ((recindxs, i), (_, typarray, bodies) as recdef) =&gt;
        let decrArg := (|Util.Array|).(CArray.ExtS.get) recindxs i in
        (* ❌ Try-with are not handled *)
        try
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (let renv' := push_fix_renv renv recdef in
          let stack' := push_stack_closures renv l stack in
          OCaml.Stdlib.reverse_apply bodies
            ((|Util.Array|).(CArray.ExtS.iteri)
              (fun j =&gt;
                fun body =&gt;
                  if
                    andb (Int.equal i j)
                      (OCaml.Stdlib.gt
                        ((|Util.List|).(CList.ExtS.length) stack') decrArg) then
                    let recArg := (|Util.List|).(CList.ExtS.nth) stack' decrArg
                      in
                    let arg_sp := stack_element_specif recArg in
                    let illformed {A : Set} (function_parameter : unit) : A :=
                      let '_ := function_parameter in
                      error_ill_formed_rec_body (guard_env.env renv)
                        Type_errors.NotEnoughAbstractionInFixBody (pi1 recdef) i
                        (push_rec_types recdef (guard_env.env renv))
                        (judgment_of_fixpoint recdef) in
                    check_nested_fix_body illformed renv' (Z.add decrArg 1)
                      arg_sp body
                  else
                    check_rec_call renv' [] body)))
      | Constr.Const ((kn, _u) as cu) =&gt;
        if evaluable_constant kn (guard_env.env renv) then
          (* ❌ Try-with are not handled *)
          try ((|Util.List|).(CList.ExtS.iter) (check_rec_call renv []) l)
        else
          (|Util.List|).(CList.ExtS.iter) (check_rec_call renv []) l
      | Constr.Lambda x a b =&gt;
        let '_ :=
          (* ❌ Assert instruction is not handled. *)
          assert ((|Util.List|).(CList.ExtS.is_empty) l) in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let '(spec, stack') := extract_stack stack in
        check_rec_call (push_var renv (x, a, spec)) stack' b
      | Constr.Prod x a b =&gt;
        let '_ :=
          (* ❌ Assert instruction is not handled. *)
          assert
            (andb ((|Util.List|).(CList.ExtS.is_empty) l)
              ((|Util.List|).(CList.ExtS.is_empty) stack)) in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        check_rec_call (push_var_renv renv (x, a)) [] b
      | Constr.CoFix (_i, (_, typarray, bodies) as recdef) =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let renv' := push_fix_renv renv recdef in
        (|Util.Array|).(CArray.ExtS.iter) (check_rec_call renv' []) bodies
      | Constr.Ind _ | Constr.Construct _ =&gt;
        (|Util.List|).(CList.ExtS.iter) (check_rec_call renv []) l
      | Constr.Proj p c =&gt;
        (* ❌ Try-with are not handled *)
        try
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (check_rec_call renv [] c)
      | Constr.Var id =&gt;
        match lookup_named id (guard_env.env renv) with
        | Context.Named.Declaration.LocalAssum _ _ =&gt;
          (|Util.List|).(CList.ExtS.iter) (check_rec_call renv []) l
        | Context.Named.Declaration.LocalDef _ c _ =&gt;
          (* ❌ Try-with are not handled *)
          try ((|Util.List|).(CList.ExtS.iter) (check_rec_call renv []) l)
        end
      | Constr.Sort _ | Constr.Int _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert ((|Util.List|).(CList.ExtS.is_empty) l)
      | Constr.Evar _ | Constr.Meta _ =&gt; tt
      | Constr.App _ _ | Constr.LetIn _ _ _ _ | Constr.Cast _ _ _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end
  with check_nested_fix_body
    (illformed : unit -&gt; unit) (renv : guard_env) (decr : Int.t)
    (recArgsDecrArg : Stdlib.Lazy.t subterm_spec) (body : Constr.constr)
    {struct illformed} : unit :=
    if Int.equal decr 0 then
      check_rec_call (assign_var_spec renv (1, recArgsDecrArg)) [] body
    else
      match kind (whd_all (guard_env.env renv) body) with
      | Constr.Lambda x a b =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let renv' := push_var_renv renv (x, a) in
        check_nested_fix_body illformed renv' (Z.sub decr 1) recArgsDecrArg b
      | _ =&gt; illformed tt
      end in
  check_rec_call renv [] def.

Definition inductive_of_mutfix
  (env : Environ.env)
  (function_parameter :
    (array Z * Z) *
      (array (Context.binder_annot Names.Name.t) * array Constr.types *
        array Constr.constr))
  : array (Names.inductive * Univ.Instance.t) *
    array (Environ.env * Constr.constr) :=
  let '((nvect, bodynum), (names, types, bodies) as recdef) :=
    function_parameter in
  let nbfix := (|Util.Array|).(CArray.ExtS.length) bodies in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fixenv := push_rec_types recdef env in
  let vdefj := judgment_of_fixpoint recdef in
  let raise_err {A : Set}
    (env : Environ.env) (i : Z) (err : Type_errors.guard_error) : A :=
    error_ill_formed_rec_body env err names i fixenv vdefj in
  let find_ind (i : Z) (k : Z) (def : Constr.constr)
    : (Names.inductive * Univ.Instance.t) * (Environ.env * Constr.constr) :=
    let fix check_occur (env : Environ.env) (n : Int.t) (def : Constr.constr)
      {struct env}
      : (Names.inductive * Univ.Instance.t) * (Environ.env * Constr.constr) :=
      match kind (whd_all env def) with
      | Constr.Lambda x a b =&gt;
        if noccur_with_meta n nbfix a then
          let env' := push_rel (Context.Rel.Declaration.LocalAssum x a) env in
          if Int.equal n (Z.add k 1) then
            let '(mind, _) :=
              (* ❌ Try-with are not handled *)
              try (find_inductive env a) in
            let '(mib, _) := lookup_mind_specif env (out_punivs mind) in
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            (mind, (env', b))
          else
            check_occur env' (Z.add n 1) b
        else
          anomaly None (Some &quot;check_one_fix&quot;)
            (Pp.str &quot;Bad occurrence of recursive call.&quot;)
      | _ =&gt; raise_err env i Type_errors.NotEnoughAbstractionInFixBody
      end in
    let '((ind, _), _) as res := check_occur fixenv 1 def in
    let '(_, ind) := lookup_mind_specif env ind in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    res in
  let rv := (|Util.Array|).(CArray.ExtS.map2_i) find_ind nvect bodies in
  (((|Util.Array|).(CArray.ExtS.map) fst rv),
    ((|Util.Array|).(CArray.ExtS.map) snd rv)).

Definition check_fix
  (env : Environ.env)
  (function_parameter :
    (array Z * Z) *
      (array (Context.binder_annot Names.Name.t) * array Constr.types *
        array Constr.constr)) : unit :=
  let '((nvect, _), (names, _, bodies) as recdef) as fix := function_parameter
    in
  let flags := Environ.typing_flags env in
  if Declarations.typing_flags.check_guarded flags then
    let '(minds, rdef) := inductive_of_mutfix env fix in
    let get_tree (function_parameter : Names.MutInd.t * Z)
      : Declarations.wf_paths :=
      let '(kn, i) := function_parameter in
      let mib := Environ.lookup_mind kn env in
      Declarations.one_inductive_body.mind_recargs
        ((|Util.Array|).(CArray.ExtS.get)
          (Declarations.mutual_inductive_body.mind_packets mib) i) in
    let trees :=
      (|Util.Array|).(CArray.ExtS.map)
        (fun function_parameter =&gt;
          let '(mind, _) := function_parameter in
          get_tree mind) minds in
    (* ❌ For loops not handled. *)
    for
  else
    tt.

(* ❌ The definition of exceptions is not handled. *)
(* exception CoFixGuardError *)

Definition anomaly_ill_typed {A : Set} (function_parameter : unit) : A :=
  let '_ := function_parameter in
  anomaly None (Some &quot;check_one_cofix&quot;)
    (Pp.str &quot;too many arguments applied to constructor.&quot;).

Fixpoint codomain_is_coind (env : Environ.env) (c : Constr.constr) {struct env}
  : (Names.inductive * Univ.Instance.t) * list Constr.constr :=
  let b := whd_all env c in
  match kind b with
  | Constr.Prod x a b =&gt;
    codomain_is_coind (push_rel (Context.Rel.Declaration.LocalAssum x a) env) b
  | _ =&gt;
    (* ❌ Try-with are not handled *)
    try (find_coinductive env b)
  end.

Definition check_one_cofix
  (env : Environ.env) (nbfix : Z) (def : Constr.constr)
  (deftype : Constr.constr) : unit :=
  let fix check_rec_call
    (env : Environ.env) (alreadygrd : bool) (n : Z)
    (tree : Declarations.wf_paths) (vlra : array (list Declarations.wf_paths))
    (t : Constr.constr) {struct env} : unit :=
    if negb (noccur_with_meta n nbfix t) then
      let '(c, args) := decompose_app (whd_all env t) in
      match
        ((kind c),
          match kind c with
          | Constr.Rel p =&gt;
            andb (OCaml.Stdlib.le n p) (OCaml.Stdlib.lt p (Z.add n nbfix))
          | _ =&gt; false
          end) with
      | (Constr.Rel p, true) =&gt;
        if negb alreadygrd then
          Stdlib.raise extensible_type_value
        else
          if
            negb
              ((|Util.List|).(CList.ExtS.for_all) (noccur_with_meta n nbfix)
                args) then
            Stdlib.raise extensible_type_value
          else
            tt
      | (Constr.Construct ((_, i) as cstr_kn, _u), _) =&gt;
        let lra := (|Util.Array|).(CArray.ExtS.get) vlra (Z.sub i 1) in
        let mI := inductive_of_constructor cstr_kn in
        let '(mib, _mip) := lookup_mind_specif env mI in
        let realargs :=
          (|Util.List|).(CList.ExtS.skipn)
            (Declarations.mutual_inductive_body.mind_nparams mib) args in
        let fix process_args_of_constr
          (function_parameter : list Constr.constr * list Declarations.wf_paths)
          {struct function_parameter} : unit :=
          match function_parameter with
          | (cons t lr, cons rar lrar) =&gt;
            if eq_wf_paths rar mk_norec then
              if noccur_with_meta n nbfix t then
                process_args_of_constr (lr, lrar)
              else
                Stdlib.raise extensible_type_value
            else
              (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
              (* ❌ instruction_sequence &quot;;&quot; *)
              process_args_of_constr (lr, lrar)
          | ([], _) =&gt; tt
          | _ =&gt; anomaly_ill_typed tt
          end in
        process_args_of_constr (realargs, lra)
      | (Constr.Lambda x a b, _) =&gt;
        let '_ :=
          (* ❌ Assert instruction is not handled. *)
          assert ((|Util.List|).(CList.ExtS.is_empty) args) in
        if noccur_with_meta n nbfix a then
          let env' := push_rel (Context.Rel.Declaration.LocalAssum x a) env in
          check_rec_call env' alreadygrd (Z.add n 1) tree vlra b
        else
          Stdlib.raise extensible_type_value
      | (Constr.CoFix (_j, (_, varit, vdefs) as recdef), _) =&gt;
        if (|Util.List|).(CList.ExtS.for_all) (noccur_with_meta n nbfix) args
          then
          if
            (|Util.Array|).(CArray.ExtS.for_all) (noccur_with_meta n nbfix)
              varit then
            let nbfix := (|Util.Array|).(CArray.ExtS.length) vdefs in
            let env' := push_rec_types recdef env in
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            (|Util.List|).(CList.ExtS.iter)
              (check_rec_call env alreadygrd n tree vlra) args
          else
            Stdlib.raise extensible_type_value
        else
          Stdlib.raise extensible_type_value
      | (Constr.Case _ p tm vrest, _) =&gt;
        let tree :=
          match restrict_spec env (Subterm (Strict, tree)) p with
          | Dead_code =&gt;
            (* ❌ Assert instruction is not handled. *)
            assert false
          | Subterm (_, tree') =&gt; tree'
          | _ =&gt; Stdlib.raise extensible_type_value
          end in
        if noccur_with_meta n nbfix p then
          if noccur_with_meta n nbfix tm then
            if
              (|Util.List|).(CList.ExtS.for_all) (noccur_with_meta n nbfix) args
              then
              let vlra := dest_subterms tree in
              (|Util.Array|).(CArray.ExtS.iter)
                (check_rec_call env alreadygrd n tree vlra) vrest
            else
              Stdlib.raise extensible_type_value
          else
            Stdlib.raise extensible_type_value
        else
          Stdlib.raise extensible_type_value
      | (Constr.Meta _, _) =&gt; tt
      | (Constr.Evar _, _) =&gt;
        (|Util.List|).(CList.ExtS.iter)
          (check_rec_call env alreadygrd n tree vlra) args
      |
        (Constr.Rel _ | Constr.Var _ | Constr.Sort _ | Constr.Cast _ _ _ |
        Constr.Prod _ _ _ | Constr.LetIn _ _ _ _ | Constr.App _ _ |
        Constr.Const _ | Constr.Ind _ | Constr.Fix _ | Constr.Proj _ _ |
        Constr.Int _, _) =&gt; Stdlib.raise extensible_type_value
      end
    else
      tt in
  let '((mind, _), _) := codomain_is_coind env deftype in
  let vlra := lookup_subterms env mind in
  check_rec_call env false 1 vlra (dest_subterms vlra) def.

Definition check_cofix {A : Set}
  (env : Environ.env)
  (function_parameter :
    A *
      (array (Context.binder_annot Names.Name.t) * array Constr.types *
        array Constr.constr)) : unit :=
  let '(_bodynum, (names, types, bodies) as recdef) := function_parameter in
  let flags := Environ.typing_flags env in
  if Declarations.typing_flags.check_guarded flags then
    let nbfix := (|Util.Array|).(CArray.ExtS.length) bodies in
    (* ❌ For loops not handled. *)
    for
  else
    tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="inductive.mli">
  <div style="margin: 20px;">
    <h3>Inductive_mli</h3>
    <ul>
      <li>OCaml size: 144 lines</li>
      <li>Coq size: 141 lines (-3% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#inductive.mli"><code>inductive.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Univ
open Declarations
open Environ

(** {6 Extracting an inductive type from a construction } *)

(** [find_m*type env sigma c] coerce [c] to an recursive type (I args).
   [find_rectype], [find_inductive] and [find_coinductive]
   respectively accepts any recursive type, only an inductive type and
   only a coinductive type.
   They raise [Not_found] if not convertible to a recursive type. *)

val find_rectype     : env -&gt; types -&gt; pinductive * constr list
val find_inductive   : env -&gt; types -&gt; pinductive * constr list
val find_coinductive : env -&gt; types -&gt; pinductive * constr list

type mind_specif = mutual_inductive_body * one_inductive_body

(** {6 ... } *)
(** Fetching information in the environment about an inductive type.
    Raises [Not_found] if the inductive type is not found. *)
val lookup_mind_specif : env -&gt; inductive -&gt; mind_specif

(** {6 Functions to build standard types related to inductive } *)
val ind_subst : MutInd.t -&gt; mutual_inductive_body -&gt; Instance.t -&gt; constr list

val inductive_paramdecls : mutual_inductive_body puniverses -&gt; Constr.rel_context

val instantiate_inductive_constraints :
  mutual_inductive_body -&gt; Instance.t -&gt; Constraint.t

val constrained_type_of_inductive : env -&gt; mind_specif puniverses -&gt; types constrained
val constrained_type_of_inductive_knowing_parameters :
  env -&gt; mind_specif puniverses -&gt; types Lazy.t array -&gt; types constrained

val relevance_of_inductive : env -&gt; inductive -&gt; Sorts.relevance

val type_of_inductive : env -&gt; mind_specif puniverses -&gt; types

val type_of_inductive_knowing_parameters :
  env -&gt; ?polyprop:bool -&gt; mind_specif puniverses -&gt; types Lazy.t array -&gt; types

val elim_sorts : mind_specif -&gt; Sorts.family list

val is_private : mind_specif -&gt; bool
val is_primitive_record : mind_specif -&gt; bool

(** Return type as quoted by the user *)

val constrained_type_of_constructor : pconstructor -&gt; mind_specif -&gt; types constrained
val type_of_constructor : pconstructor -&gt; mind_specif -&gt; types

(** Return constructor types in normal form *)
val arities_of_constructors : pinductive -&gt; mind_specif -&gt; types array

(** Return constructor types in user form *)
val type_of_constructors : pinductive -&gt; mind_specif -&gt; types array

(** Transforms inductive specification into types (in nf) *)
val arities_of_specif : MutInd.t puniverses -&gt; mind_specif -&gt; types array

val inductive_params : mind_specif -&gt; int

(** [type_case_branches env (I,args) (p:A) c] computes useful types
   about the following Cases expression:
      &lt;p&gt;Cases (c :: (I args)) of b1..bn end
   It computes the type of every branch (pattern variables are
   introduced by products), the type for the whole expression, and
   the universe constraints generated.
 *)
val type_case_branches :
  env -&gt; pinductive * constr list -&gt; unsafe_judgment -&gt; constr
    -&gt; types array * types

val build_branches_type :
  pinductive -&gt; mutual_inductive_body * one_inductive_body -&gt;
    constr list -&gt; constr -&gt; types array

(** Return the arity of an inductive type *)
val mind_arity : one_inductive_body -&gt; Constr.rel_context * Sorts.family

val inductive_sort_family : one_inductive_body -&gt; Sorts.family

(** Check a [case_info] actually correspond to a Case expression on the
   given inductive type. *)
val check_case_info : env -&gt; pinductive -&gt; Sorts.relevance -&gt; case_info -&gt; unit

(** {6 Guard conditions for fix and cofix-points. } *)

(** When [chk] is false, the guard condition is not actually
    checked. *)
val check_fix : env -&gt; fixpoint -&gt; unit
val check_cofix : env -&gt; cofixpoint -&gt; unit

(** {6 Support for sort-polymorphic inductive types } *)

(** The &quot;polyprop&quot; optional argument below controls
    the &quot;Prop-polymorphism&quot;. By default, it is allowed.
    But when &quot;polyprop=false&quot;, the following exception is raised
    when a polymorphic singleton inductive type becomes Prop due to
    parameter instantiation. This is used by the Ocaml extraction,
    which cannot handle (yet?) Prop-polymorphism. *)

<abbr class="mark-warning" title="Signature item `exception` not handled">exception SingletonInductiveBecomesProp of Id.t</abbr>

val max_inductive_sort : Sorts.t array -&gt; Universe.t

val instantiate_universes : env -&gt; Constr.rel_context -&gt;
  template_arity -&gt; constr Lazy.t array -&gt; Constr.rel_context * Sorts.t

(** {6 Debug} *)

type size = Large | Strict
type subterm_spec =
    Subterm of (size * wf_paths)
  | Dead_code
  | Not_subterm
type guard_env =
  { env     : env;
    (** dB of last fixpoint *)
    rel_min : int;
    (** dB of variables denoting subterms *)
    genv    : subterm_spec Lazy.t list;
  }

type stack_element = |SClosure of guard_env*constr |SArg of subterm_spec Lazy.t

val subterm_specif : guard_env -&gt; stack_element list -&gt; constr -&gt; subterm_spec

val lambda_implicit_lift : int -&gt; constr -&gt; constr

val abstract_mind_lc : int -&gt; Int.t -&gt; (rel_context * constr) array -&gt; constr array
</pre>
  </div>
  <div class="col-md-6">
    <a href="#inductive.mli"><code>Inductive_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter find_rectype :
  Environ.env -&gt; Constr.types -&gt; Constr.pinductive * list Constr.constr.

Parameter find_inductive :
  Environ.env -&gt; Constr.types -&gt; Constr.pinductive * list Constr.constr.

Parameter find_coinductive :
  Environ.env -&gt; Constr.types -&gt; Constr.pinductive * list Constr.constr.

Definition mind_specif :=
  Declarations.mutual_inductive_body * Declarations.one_inductive_body.

Parameter lookup_mind_specif : Environ.env -&gt; Names.inductive -&gt; mind_specif.

Parameter ind_subst :
  Names.MutInd.t -&gt; Declarations.mutual_inductive_body -&gt; Univ.Instance.t -&gt;
  list Constr.constr.

Parameter inductive_paramdecls :
  Univ.puniverses Declarations.mutual_inductive_body -&gt; Constr.rel_context.

Parameter instantiate_inductive_constraints :
  Declarations.mutual_inductive_body -&gt; Univ.Instance.t -&gt; Univ.Constraint.t.

Parameter constrained_type_of_inductive :
  Environ.env -&gt; Univ.puniverses mind_specif -&gt; Univ.constrained Constr.types.

Parameter constrained_type_of_inductive_knowing_parameters :
  Environ.env -&gt; Univ.puniverses mind_specif -&gt;
  array (Stdlib.Lazy.t Constr.types) -&gt; Univ.constrained Constr.types.

Parameter relevance_of_inductive :
  Environ.env -&gt; Names.inductive -&gt; Sorts.relevance.

Parameter type_of_inductive :
  Environ.env -&gt; Univ.puniverses mind_specif -&gt; Constr.types.

Parameter type_of_inductive_knowing_parameters :
  Environ.env -&gt; option bool -&gt; Univ.puniverses mind_specif -&gt;
  array (Stdlib.Lazy.t Constr.types) -&gt; Constr.types.

Parameter elim_sorts : mind_specif -&gt; list Sorts.family.

Parameter is_private : mind_specif -&gt; bool.

Parameter is_primitive_record : mind_specif -&gt; bool.

Parameter constrained_type_of_constructor :
  Constr.pconstructor -&gt; mind_specif -&gt; Univ.constrained Constr.types.

Parameter type_of_constructor :
  Constr.pconstructor -&gt; mind_specif -&gt; Constr.types.

Parameter arities_of_constructors :
  Constr.pinductive -&gt; mind_specif -&gt; array Constr.types.

Parameter type_of_constructors :
  Constr.pinductive -&gt; mind_specif -&gt; array Constr.types.

Parameter arities_of_specif :
  Univ.puniverses Names.MutInd.t -&gt; mind_specif -&gt; array Constr.types.

Parameter inductive_params : mind_specif -&gt; Z.

Parameter type_case_branches :
  Environ.env -&gt; Constr.pinductive * list Constr.constr -&gt;
  Environ.unsafe_judgment -&gt; Constr.constr -&gt; array Constr.types * Constr.types.

Parameter build_branches_type :
  Constr.pinductive -&gt;
  Declarations.mutual_inductive_body * Declarations.one_inductive_body -&gt;
  list Constr.constr -&gt; Constr.constr -&gt; array Constr.types.

Parameter mind_arity :
  Declarations.one_inductive_body -&gt; Constr.rel_context * Sorts.family.

Parameter inductive_sort_family :
  Declarations.one_inductive_body -&gt; Sorts.family.

Parameter check_case_info :
  Environ.env -&gt; Constr.pinductive -&gt; Sorts.relevance -&gt; Constr.case_info -&gt;
  unit.

Parameter check_fix : Environ.env -&gt; Constr.fixpoint -&gt; unit.

Parameter check_cofix : Environ.env -&gt; Constr.cofixpoint -&gt; unit.

(* exception SingletonInductiveBecomesProp *)

Parameter max_inductive_sort : array Sorts.t -&gt; Univ.Universe.t.

Parameter instantiate_universes :
  Environ.env -&gt; Constr.rel_context -&gt; Declarations.template_arity -&gt;
  array (Stdlib.Lazy.t Constr.constr) -&gt; Constr.rel_context * Sorts.t.

Inductive size : Set :=
| Large : size
| Strict : size.

Inductive subterm_spec : Set :=
| Subterm : size * Declarations.wf_paths -&gt; subterm_spec
| Dead_code : subterm_spec
| Not_subterm : subterm_spec.

Module guard_env.
  Record record := {
    env : Environ.env;
    rel_min : Z;
    genv : list (Stdlib.Lazy.t subterm_spec) }.
  Definition with_env (r : record) env : record :=
    {| env := env; rel_min := rel_min r; genv := genv r |}.
  Definition with_rel_min (r : record) rel_min : record :=
    {| env := env r; rel_min := rel_min; genv := genv r |}.
  Definition with_genv (r : record) genv : record :=
    {| env := env r; rel_min := rel_min r; genv := genv |}.
End guard_env.
Definition guard_env := guard_env.record.

Inductive stack_element : Set :=
| SClosure : guard_env -&gt; Constr.constr -&gt; stack_element
| SArg : Stdlib.Lazy.t subterm_spec -&gt; stack_element.

Parameter subterm_specif :
  guard_env -&gt; list stack_element -&gt; Constr.constr -&gt; subterm_spec.

Parameter lambda_implicit_lift : Z -&gt; Constr.constr -&gt; Constr.constr.

Parameter abstract_mind_lc :
  Z -&gt; Int.t -&gt; array (Constr.rel_context * Constr.constr) -&gt;
  array Constr.constr.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="mod_subst.ml">
  <div style="margin: 20px;">
    <h3>Mod_subst</h3>
    <ul>
      <li>OCaml size: 583 lines</li>
      <li>Coq size: 1014 lines (+73% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#mod_subst.ml"><code>mod_subst.ml</code></a>&nbsp;<span class="label label-warning">26 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Claudio Sacerdoti from contents of term.ml, names.ml and
   new support for constant inlining in functor application, Nov 2004 *)
(* Optimizations and bug fixes by Ãlie Soubiran, from Feb 2008 *)

(* This file provides types and functions for managing name
   substitution in module constructions *)

open Pp
open Util
open Names
open Constr

(* For Inline, the int is an inlining level, and the constr (if present)
   is the term into which we should inline. *)

type delta_hint =
  | Inline of int * constr Univ.univ_abstracted option
  | Equiv of KerName.t

(* NB: earlier constructor Prefix_equiv of ModPath.t
   is now stored in a separate table, see Deltamap.t below *)

module Deltamap = struct
  type t = ModPath.t MPmap.t * delta_hint KNmap.t
  let empty = MPmap.empty, KNmap.empty
  let is_empty (mm, km) =
    MPmap.is_empty mm &amp;&amp; KNmap.is_empty km
  let add_kn kn hint (mm,km) = (mm,KNmap.add kn hint km)
  let add_mp mp mp' (mm,km) = (MPmap.add mp mp' mm, km)
  let find_mp mp map = MPmap.find mp (fst map)
  let find_kn kn map = KNmap.find kn (snd map)
  let mem_mp mp map = MPmap.mem mp (fst map)
  let fold_kn f map i = KNmap.fold f (snd map) i
  let fold fmp fkn (mm,km) i =
    MPmap.fold fmp mm (KNmap.fold fkn km i)
  let join map1 map2 = fold add_mp add_kn map1 map2
end

(* Invariant: in the [delta_hint] map, an [Equiv] should only
   relate [KerName.t] with the same label (and section dirpath). *)

type delta_resolver = Deltamap.t

let empty_delta_resolver = Deltamap.empty

module Umap :
  sig
    type 'a t
    val empty : 'a t
    val is_empty : 'a t -&gt; bool
    val add_mbi : MBId.t -&gt; 'a -&gt; 'a t -&gt; 'a t
    val add_mp : ModPath.t -&gt; 'a -&gt; 'a t -&gt; 'a t
    val find : ModPath.t -&gt; 'a t -&gt; 'a
    val join : 'a t -&gt; 'a t -&gt; 'a t
    val fold : (ModPath.t -&gt; 'a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b
  end = struct
  type 'a t = 'a MPmap.t
  let empty = MPmap.empty
  let is_empty m = MPmap.is_empty m
  let add_mbi mbi x m = MPmap.add (MPbound mbi) x m
  let add_mp mp x m = MPmap.add mp x m
  let find = MPmap.find
  let fold = MPmap.fold
  let join map1 map2 = fold add_mp map1 map2
end

type substitution = (ModPath.t * delta_resolver) Umap.t

let empty_subst = Umap.empty

let is_empty_subst = Umap.is_empty

(* &lt;debug&gt; *)

let string_of_hint = function
  | Inline (_,Some _) -&gt; &quot;inline(Some _)&quot;
  | Inline _ -&gt; &quot;inline()&quot;
  | Equiv kn -&gt; KerName.to_string kn

let debug_string_of_delta resolve =
  let kn_to_string kn hint l =
    (KerName.to_string kn ^ &quot;=&gt;&quot; ^ string_of_hint hint) :: l
  in
  let mp_to_string mp mp' l =
    (ModPath.to_string mp ^ &quot;=&gt;&quot; ^ ModPath.to_string mp') :: l
  in
  let l = Deltamap.fold mp_to_string kn_to_string resolve [] in
  String.concat &quot;, &quot; (List.rev l)

let list_contents sub =
  let one_pair (mp,reso) = (ModPath.to_string mp,debug_string_of_delta reso) in
  let mp_one_pair mp0 p l = (ModPath.to_string mp0, one_pair p)::l in
  Umap.fold mp_one_pair sub []

let debug_string_of_subst sub =
  let l = List.map (fun (s1,(s2,s3)) -&gt; s1^&quot;|-&gt;&quot;^s2^&quot;[&quot;^s3^&quot;]&quot;)
    (list_contents sub)
  in
  &quot;{&quot; ^ String.concat &quot;; &quot; l ^ &quot;}&quot;

let debug_pr_delta resolve =
  str (debug_string_of_delta resolve)

let debug_pr_subst sub =
  let l = list_contents sub in
  let f (s1,(s2,s3)) = hov 2 (str s1 ++ spc () ++ str &quot;|-&gt; &quot; ++ str s2 ++
                              spc () ++ str &quot;[&quot; ++ str s3 ++ str &quot;]&quot;)
  in
  str &quot;{&quot; ++ hov 2 (prlist_with_sep pr_comma f l) ++ str &quot;}&quot;

(* &lt;/debug&gt; *)

(** Extending a [delta_resolver] *)

let add_inline_delta_resolver kn (lev,oc) = Deltamap.add_kn kn (Inline (lev,oc))

let add_kn_delta_resolver kn kn' =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Label.equal (KerName.label kn) (KerName.label kn'));
  Deltamap.add_kn kn (Equiv kn')</abbr>

let add_mp_delta_resolver mp1 mp2 = Deltamap.add_mp mp1 mp2

(** Extending a [substitution] without sequential composition *)

let add_mbid mbid mp resolve s = Umap.add_mbi mbid (mp,resolve) s
let add_mp mp1 mp2 resolve s = Umap.add_mp mp1 (mp2,resolve) s

let map_mbid mbid mp resolve = add_mbid mbid mp resolve empty_subst
let map_mp mp1 mp2 resolve = add_mp mp1 mp2 resolve empty_subst

let mp_in_delta mp = Deltamap.mem_mp mp

let kn_in_delta kn resolver =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    match Deltamap.find_kn kn resolver with
      | Equiv _ -&gt; true
      | Inline _ -&gt; false
  with Not_found -&gt; false</abbr>

let con_in_delta con resolver = kn_in_delta (Constant.user con) resolver
let mind_in_delta mind resolver = kn_in_delta (MutInd.user mind) resolver

let mp_of_delta resolve mp =
 <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Deltamap.find_mp mp resolve with Not_found -&gt; mp</abbr>

let find_prefix resolve mp =
  let rec sub_mp = function
    | MPdot(mp,l) as mp_sup -&gt;
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try Deltamap.find_mp mp_sup resolve
         with Not_found -&gt; MPdot(sub_mp mp,l))</abbr>
    | p -&gt; Deltamap.find_mp p resolve
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try sub_mp mp with Not_found -&gt; mp</abbr>

(** Applying a resolver to a kernel name *)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception Change_equiv_to_inline of (int * constr Univ.univ_abstracted)</abbr>

let solve_delta_kn resolve kn =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    match Deltamap.find_kn kn resolve with
      | Equiv kn1 -&gt; kn1
      | Inline (lev, Some c) -&gt;	raise </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Values of extensible types are not handled">(Change_equiv_to_inline (lev,c))</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
      | Inline (_, None) -&gt; raise </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Values of extensible types are not handled">Not_found</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
  with Not_found -&gt;
    let mp,l = KerName.repr kn in
    let new_mp = find_prefix resolve mp in
    if mp == new_mp then
      kn
    else
      KerName.make new_mp l</abbr>

let kn_of_delta resolve kn =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try solve_delta_kn resolve kn
  with Change_equiv_to_inline _ -&gt; kn</abbr>

(** Try a 1st resolver, and then a 2nd in case it had no effect *)

let kn_of_deltas resolve1 resolve2 kn =
  let kn' = kn_of_delta resolve1 kn in
  if kn' == kn then kn_of_delta resolve2 kn else kn'

let constant_of_delta_kn resolve kn =
  Constant.make kn (kn_of_delta resolve kn)

let constant_of_deltas_kn resolve1 resolve2 kn =
  Constant.make kn (kn_of_deltas resolve1 resolve2 kn)

let mind_of_delta_kn resolve kn =
  MutInd.make kn (kn_of_delta resolve kn)

let mind_of_deltas_kn resolve1 resolve2 kn =
  MutInd.make kn (kn_of_deltas resolve1 resolve2 kn)

let inline_of_delta inline resolver =
  match inline with
    | None -&gt; []
    | Some inl_lev -&gt;
      let extract kn hint l =
        match hint with
          | Inline (lev,_) -&gt; if lev &lt;= inl_lev then (lev,kn)::l else l
          | _ -&gt; l
      in
      Deltamap.fold_kn extract resolver []

let search_delta_inline resolve kn1 kn2 =
  let find kn = match Deltamap.find_kn kn resolve with
    | Inline (_,o) -&gt; o
    | Equiv _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try find kn1
  with Not_found -&gt;
    if kn1 == kn2 then None
    else
      try find kn2
      with Not_found -&gt; None</abbr>

let subst_mp0 sub mp = (* 's like subst *)
 let rec aux mp =
  match mp with
    | MPfile _ | MPbound _ -&gt; Umap.find mp sub
    | MPdot (mp1,l) as mp2 -&gt;
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">begin
          try Umap.find mp2 sub
          with Not_found -&gt;
            let mp1',resolve = aux mp1 in
            MPdot (mp1',l),resolve
        end</abbr>
 in
 <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (aux mp) with Not_found -&gt; None</abbr>

let subst_mp sub mp =
 match subst_mp0 sub mp with
    None -&gt; mp
  | Some (mp',_) -&gt; mp'

let subst_kn_delta sub kn =
 let mp,l = KerName.repr kn in
  match subst_mp0 sub mp with
     Some (mp',resolve) -&gt;
      solve_delta_kn resolve (KerName.make mp' l)
   | None -&gt; kn


let subst_kn sub kn =
 let mp,l = KerName.repr kn in
  match subst_mp0 sub mp with
     Some (mp',_) -&gt;
      (KerName.make mp' l)
   | None -&gt; kn

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception No_subst</abbr>

let subst_dual_mp sub mp1 mp2 =
  let o1 = subst_mp0 sub mp1 in
  let o2 = if mp1 == mp2 then o1 else subst_mp0 sub mp2 in
  match o1, o2 with
    | None, None -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">No_subst</abbr>
    | Some (mp1',resolve), None -&gt; mp1', mp2, resolve, true
    | None, Some (mp2',resolve) -&gt; mp1, mp2', resolve, false
    | Some (mp1',_), Some (mp2',resolve) -&gt; mp1', mp2', resolve, false

let progress f x ~orelse =
  let y = f x in
  if y != x then y else orelse

let subst_mind sub mind =
  let mpu,l = MutInd.repr2 mind in
  let mpc = KerName.modpath (MutInd.canonical mind) in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let mpu,mpc,resolve,user = subst_dual_mp sub mpu mpc in
    let knu = KerName.make mpu l in
    let knc = if mpu == mpc then knu else KerName.make mpc l in
    let knc' =
      progress (kn_of_delta resolve) (if user then knu else knc) ~orelse:knc
    in
    MutInd.make knu knc'
  with No_subst -&gt; mind</abbr>

let subst_ind sub (ind,i as indi) =
  let ind' = subst_mind sub ind in
    if ind' == ind then indi else ind',i

let subst_pind sub (ind,u) =
  (subst_ind sub ind, u)

let subst_con0 sub cst =
  let mpu,l = Constant.repr2 cst in
  let mpc = KerName.modpath (Constant.canonical cst) in
  let mpu,mpc,resolve,user = subst_dual_mp sub mpu mpc in
  let knu = KerName.make mpu l in
  let knc = if mpu == mpc then knu else KerName.make mpc l in
  match search_delta_inline resolve knu knc with
    | Some t -&gt;
      (* In case of inlining, discard the canonical part (cf #2608) *)
      Constant.make1 knu, Some t
    | None -&gt;
      let knc' =
        progress (kn_of_delta resolve) (if user then knu else knc) ~orelse:knc
      in
      let cst' = Constant.make knu knc' in
      cst', None

let subst_con sub cst =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try subst_con0 sub cst
  with No_subst -&gt; cst, None</abbr>

let subst_pcon sub (con,u as pcon) =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try let con', _can = subst_con0 sub con in
        con',u
  with No_subst -&gt; pcon</abbr>

let subst_constant sub con =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try fst (subst_con0 sub con)
  with No_subst -&gt; con</abbr>

let subst_proj_repr sub p =
  Projection.Repr.map (subst_mind sub) p

let subst_proj sub p =
  Projection.map (subst_mind sub) p

let subst_retro_action subst action =
  let open Retroknowledge in
  match action with
  | Register_ind(prim,ind) -&gt;
    let ind' = subst_ind subst ind in
    if ind == ind' then action else Register_ind(prim, ind')
  | Register_type(prim,c) -&gt;
    let c' = subst_constant subst c in
    if c == c' then action else Register_type(prim, c')

(* Here the semantics is completely unclear.
   What does &quot;Hint Unfold t&quot; means when &quot;t&quot; is a parameter?
   Does the user mean &quot;Unfold X.t&quot; or does she mean &quot;Unfold y&quot;
   where X.t is later on instantiated with y? I choose the first
   interpretation (i.e. an evaluable reference is never expanded). *)
let subst_evaluable_reference subst = function
  | EvalVarRef id -&gt; EvalVarRef id
  | EvalConstRef kn -&gt; EvalConstRef (subst_constant subst kn)

let rec map_kn f f' c =
  let func = map_kn f f' in
    match kind c with
      | Const kn -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try f' kn with No_subst -&gt; c)</abbr>
      | Proj (p,t) -&gt;
          let p' = Projection.map f p in
          let t' = func t in
            if p' == p &amp;&amp; t' == t then c
            else mkProj (p', t')
      | Ind ((kn,i),u) -&gt;
          let kn' = f kn in
          if kn'==kn then c else mkIndU ((kn',i),u)
      | Construct (((kn,i),j),u) -&gt;
          let kn' = f kn in
          if kn'==kn then c else mkConstructU (((kn',i),j),u)
      | Case (ci,p,ct,l) -&gt;
          let ci_ind =
            let (kn,i) = ci.ci_ind in
            let kn' = f kn in
            if kn'==kn then ci.ci_ind else kn',i
          in
          let p' = func p in
          let ct' = func ct in
          let l' = Array.Smart.map func l in
            if (ci.ci_ind==ci_ind &amp;&amp; p'==p
                &amp;&amp; l'==l &amp;&amp; ct'==ct)then c
            else
              mkCase ({ci with ci_ind = ci_ind},
                      p',ct', l')
      | Cast (ct,k,t) -&gt;
          let ct' = func ct in
          let t'= func t in
            if (t'==t &amp;&amp; ct'==ct) then c
            else mkCast (ct', k, t')
      | Prod (na,t,ct) -&gt;
          let ct' = func ct in
          let t'= func t in
            if (t'==t &amp;&amp; ct'==ct) then c
            else mkProd (na, t', ct')
      | Lambda (na,t,ct) -&gt;
          let ct' = func ct in
          let t'= func t in
            if (t'==t &amp;&amp; ct'==ct) then c
            else mkLambda (na, t', ct')
      | LetIn (na,b,t,ct) -&gt;
          let ct' = func ct in
          let t'= func t in
          let b'= func b in
            if (t'==t &amp;&amp; ct'==ct &amp;&amp; b==b') then c
            else mkLetIn (na, b', t', ct')
      | App (ct,l) -&gt;
          let ct' = func ct in
          let l' = Array.Smart.map func l in
            if (ct'== ct &amp;&amp; l'==l) then c
            else mkApp (ct',l')
      | Evar (e,l) -&gt;
          let l' = Array.Smart.map func l in
            if (l'==l) then c
            else mkEvar (e,l')
      | Fix (ln,(lna,tl,bl)) -&gt;
          let tl' = Array.Smart.map func tl in
          let bl' = Array.Smart.map func bl in
            if (bl == bl'&amp;&amp; tl == tl') then c
            else mkFix (ln,(lna,tl',bl'))
      | CoFix(ln,(lna,tl,bl)) -&gt;
          let tl' = Array.Smart.map func tl in
          let bl' = Array.Smart.map func bl in
            if (bl == bl'&amp;&amp; tl == tl') then c
            else mkCoFix (ln,(lna,tl',bl'))
      | _ -&gt; c

let subst_mps sub c =
  let subst_pcon_term sub (con,u) =
    let con', can = subst_con0 sub con in
    match can with
    | None -&gt; mkConstU (con',u)
    | Some t -&gt; Vars.univ_instantiate_constr u t
  in
  if is_empty_subst sub then c
  else map_kn (subst_mind sub) (subst_pcon_term sub) c

let rec replace_mp_in_mp mpfrom mpto mp =
  match mp with
    | _ when ModPath.equal mp mpfrom -&gt; mpto
    | MPdot (mp1,l) -&gt;
        let mp1' = replace_mp_in_mp mpfrom mpto mp1 in
          if mp1 == mp1' then mp
          else MPdot (mp1',l)
    | _ -&gt; mp

let replace_mp_in_kn mpfrom mpto kn =
 let mp,l = KerName.repr kn in
  let mp'' = replace_mp_in_mp mpfrom mpto mp in
    if mp==mp'' then kn
    else KerName.make mp'' l

let rec mp_in_mp mp mp1 =
  match mp1 with
    | _ when ModPath.equal mp1 mp -&gt; true
    | MPdot (mp2,_l) -&gt; mp_in_mp mp mp2
    | _ -&gt; false

let subset_prefixed_by mp resolver =
  let mp_prefix mkey mequ rslv =
    if mp_in_mp mp mkey then Deltamap.add_mp mkey mequ rslv else rslv
  in
  let kn_prefix kn hint rslv =
    match hint with
      | Inline _ -&gt; rslv
      | Equiv _ -&gt;
        if mp_in_mp mp (KerName.modpath kn) then Deltamap.add_kn kn hint rslv else rslv
  in
  Deltamap.fold mp_prefix kn_prefix resolver empty_delta_resolver

let subst_dom_delta_resolver subst resolver =
  let mp_apply_subst mkey mequ rslv =
    Deltamap.add_mp (subst_mp subst mkey) mequ rslv
  in
  let kn_apply_subst kkey hint rslv =
    Deltamap.add_kn (subst_kn subst kkey) hint rslv
  in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver

let subst_mp_delta sub mp mkey =
 match subst_mp0 sub mp with
    None -&gt; empty_delta_resolver,mp
  | Some (mp',resolve) -&gt;
      let mp1 = find_prefix resolve mp' in
      let resolve1 = subset_prefixed_by mp1 resolve in
      (subst_dom_delta_resolver
         (map_mp mp1 mkey empty_delta_resolver) resolve1),mp1

let gen_subst_delta_resolver dom subst resolver =
  let mp_apply_subst mkey mequ rslv =
    let mkey' = if dom then subst_mp subst mkey else mkey in
    let rslv',mequ' = subst_mp_delta subst mequ mkey in
    Deltamap.join rslv' (Deltamap.add_mp mkey' mequ' rslv)
  in
  let kn_apply_subst kkey hint rslv =
    let kkey' = if dom then subst_kn subst kkey else kkey in
    let hint' = match hint with
      | Equiv kequ -&gt;
          <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try Equiv (subst_kn_delta subst kequ)
           with Change_equiv_to_inline (lev,c) -&gt; Inline (lev,Some c))</abbr>
      | Inline (lev,Some t) -&gt; Inline (lev,Some (Univ.map_univ_abstracted (subst_mps subst) t))
      | Inline (_,None) -&gt; hint
    in
    Deltamap.add_kn kkey' hint' rslv
  in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver

let subst_codom_delta_resolver = gen_subst_delta_resolver false
let subst_dom_codom_delta_resolver = gen_subst_delta_resolver true

let update_delta_resolver resolver1 resolver2 =
  let mp_apply_rslv mkey mequ rslv =
    Deltamap.add_mp mkey (find_prefix resolver2 mequ) rslv
  in
  let kn_apply_rslv kkey hint1 rslv =
    let hint = match hint1 with
      | Equiv kequ -&gt;
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try Equiv (solve_delta_kn resolver2 kequ)
         with Change_equiv_to_inline (lev,c) -&gt; Inline (lev, Some c))</abbr>
      | Inline (_,Some _) -&gt; hint1
      | Inline (_,None) -&gt;
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try Deltamap.find_kn kkey resolver2 with Not_found -&gt; hint1)</abbr>
    in
    Deltamap.add_kn kkey hint rslv
  in
  Deltamap.fold mp_apply_rslv kn_apply_rslv resolver1 resolver2

let add_delta_resolver resolver1 resolver2 =
  if Deltamap.is_empty resolver2 then
    resolver1
  else
    update_delta_resolver resolver1 resolver2

let substition_prefixed_by k mp subst =
  let mp_prefixmp kmp (mp_to,reso) sub =
    if mp_in_mp mp kmp &amp;&amp; not (ModPath.equal mp kmp) then
      let new_key = replace_mp_in_mp mp k kmp in
      Umap.add_mp new_key (mp_to,reso) sub
    else sub
  in
  Umap.fold mp_prefixmp subst empty_subst

let join subst1 subst2 =
  let apply_subst mpk add (mp,resolve) res =
    let mp',resolve' =
      match subst_mp0 subst2 mp with
        | None -&gt; mp, None
        | Some (mp',resolve') -&gt;  mp', Some resolve' in
    let resolve'' =
      match resolve' with
        | Some res -&gt;
            add_delta_resolver
              (subst_dom_codom_delta_resolver subst2 resolve) res
        | None -&gt;
            subst_codom_delta_resolver subst2 resolve
    in
    let prefixed_subst = substition_prefixed_by mpk mp' subst2 in
    Umap.join prefixed_subst (add (mp',resolve'') res)
  in
  let mp_apply_subst mp = apply_subst mp (Umap.add_mp mp) in
  let subst = Umap.fold mp_apply_subst subst1 empty_subst in
  Umap.join subst2 subst

type 'a substituted = {
  mutable subst_value : 'a;
  mutable subst_subst : substitution list;
}

let from_val x = { subst_value = x; subst_subst = []; }

let force fsubst r = match r.subst_subst with
| [] -&gt; r.subst_value
| s -&gt;
  let subst = List.fold_left join empty_subst (List.rev s) in
  let x = fsubst subst r.subst_value in
  let () = <abbr class="mark-warning" title="Set record field not handled.">r.subst_subst &lt;- []</abbr> in
  let () = <abbr class="mark-warning" title="Set record field not handled.">r.subst_value &lt;- x</abbr> in
  x

let subst_substituted s r = { r with subst_subst = s :: r.subst_subst; }

let force_constr = force subst_mps
let subst_constr = subst_substituted

(* debug *)
let repr_substituted r = match r.subst_subst with
| [] -&gt; None, r.subst_value
| s -&gt; Some s, r.subst_value
</pre>
  </div>
  <div class="col-md-6">
    <a href="#mod_subst.ml"><code>Mod_subst.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Pp.

Import Util.

Import Names.

Import Constr.

Inductive delta_hint : Set :=
| Inline : Z -&gt; option (Univ.univ_abstracted Constr.constr) -&gt; delta_hint
| Equiv : Names.KerName.t -&gt; delta_hint.

Module Deltamap.
  Definition t := Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint.
  
  Definition empty {A B : Set} : Names.MPmap.t A * Names.KNmap.t B :=
    (MPmap.empty, KNmap.empty).
  
  Definition is_empty {A B : Set}
    (function_parameter : Names.MPmap.t A * Names.KNmap.t B) : bool :=
    let '(mm, km) := function_parameter in
    andb (MPmap.is_empty mm) (KNmap.is_empty km).
  
  Definition add_kn {A B : Set}
    (kn : Names.KNmap.key) (hint : A) (function_parameter : B * Names.KNmap.t A)
    : B * Names.KNmap.t A :=
    let '(mm, km) := function_parameter in
    (mm, (KNmap.add kn hint km)).
  
  Definition add_mp {A B : Set}
    (mp : Names.MPmap.key) (mp' : A) (function_parameter : Names.MPmap.t A * B)
    : Names.MPmap.t A * B :=
    let '(mm, km) := function_parameter in
    ((MPmap.add mp mp' mm), km).
  
  Definition find_mp {A B : Set}
    (mp : Names.MPmap.key) (map : Names.MPmap.t A * B) : A :=
    MPmap.find mp (fst map).
  
  Definition find_kn {A B : Set}
    (kn : Names.KNmap.key) (map : A * Names.KNmap.t B) : B :=
    KNmap.find kn (snd map).
  
  Definition mem_mp {A B : Set}
    (mp : Names.MPmap.key) (map : Names.MPmap.t A * B) : bool :=
    MPmap.mem mp (fst map).
  
  Definition fold_kn {A B C : Set}
    (f : Names.KNmap.key -&gt; A -&gt; B -&gt; B) (map : C * Names.KNmap.t A) (i : B)
    : B := KNmap.fold f (snd map) i.
  
  Definition fold {A B C : Set}
    (fmp : Names.MPmap.key -&gt; A -&gt; B -&gt; B)
    (fkn : Names.KNmap.key -&gt; C -&gt; B -&gt; B)
    (function_parameter : Names.MPmap.t A * Names.KNmap.t C) : B -&gt; B :=
    let '(mm, km) := function_parameter in
    fun i =&gt; MPmap.fold fmp mm (KNmap.fold fkn km i).
  
  Definition join {A B : Set}
    (map1 : Names.MPmap.t A * Names.KNmap.t B)
    (map2 : Names.MPmap.t A * Names.KNmap.t B)
    : Names.MPmap.t A * Names.KNmap.t B := fold add_mp add_kn map1 map2.
End Deltamap.

Definition delta_resolver := Deltamap.t.

Definition empty_delta_resolver {A B : Set}
  : Names.MPmap.t A * Names.KNmap.t B := Deltamap.empty.

Module Umap.
  Definition t (a : Set) := Names.MPmap.t a.
  
  Definition empty {A : Set} : Names.MPmap.t A := MPmap.empty.
  
  Definition is_empty {A : Set} (m : Names.MPmap.t A) : bool := MPmap.is_empty m.
  
  Definition add_mbi {A : Set}
    (mbi : Names.MBId.t) (x : A) (m : Names.MPmap.t A) : Names.MPmap.t A :=
    MPmap.add (Names.MPbound mbi) x m.
  
  Definition add_mp {A : Set}
    (mp : Names.MPmap.key) (x : A) (m : Names.MPmap.t A) : Names.MPmap.t A :=
    MPmap.add mp x m.
  
  Definition find {A : Set} : Names.MPmap.key -&gt; Names.MPmap.t A -&gt; A :=
    MPmap.find.
  
  Definition fold {A B : Set}
    : (Names.MPmap.key -&gt; A -&gt; B -&gt; B) -&gt; Names.MPmap.t A -&gt; B -&gt; B :=
    MPmap.fold.
  
  Definition join {A : Set} (map1 : Names.MPmap.t A) (map2 : Names.MPmap.t A)
    : Names.MPmap.t A := fold add_mp map1 map2.
End Umap.

Definition substitution := Umap.t (Names.ModPath.t * delta_resolver).

Definition empty_subst {A : Set} : Umap.t A := Umap.empty.

Definition is_empty_subst {A : Set} : Umap.t A -&gt; bool := Umap.is_empty.

Definition string_of_hint (function_parameter : delta_hint) : string :=
  match function_parameter with
  | Inline _ (Some _) =&gt; &quot;inline(Some _)&quot;
  | Inline _ _ =&gt; &quot;inline()&quot;
  | Equiv kn =&gt; KerName.to_string kn
  end.

Definition debug_string_of_delta
  (resolve : Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint)
  : string :=
  let kn_to_string (kn : Names.KerName.t) (hint : delta_hint) (l : list string)
    : list string :=
    cons
      (String.append (KerName.to_string kn)
        (String.append &quot;=&gt;&quot; (string_of_hint hint))) l in
  let mp_to_string
    (mp : Names.ModPath.t) (mp' : Names.ModPath.t) (l : list string)
    : list string :=
    cons
      (String.append (ModPath.to_string mp)
        (String.append &quot;=&gt;&quot; (ModPath.to_string mp'))) l in
  let l := Deltamap.fold mp_to_string kn_to_string resolve [] in
  (|Util.String|).(CString.ExtS.concat) &quot;, &quot; ((|Util.List|).(CList.ExtS.rev) l).

Definition list_contents
  (sub :
    Umap.t
      (Names.ModPath.t *
        (Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint)))
  : list (string * (string * string)) :=
  let one_pair
    (function_parameter :
      Names.ModPath.t *
        (Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint))
    : string * string :=
    let '(mp, reso) := function_parameter in
    ((ModPath.to_string mp), (debug_string_of_delta reso)) in
  let mp_one_pair
    (mp0 : Names.ModPath.t)
    (p :
      Names.ModPath.t *
        (Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint))
    (l : list (string * (string * string)))
    : list (string * (string * string)) :=
    cons ((ModPath.to_string mp0), (one_pair p)) l in
  Umap.fold mp_one_pair sub [].

Definition debug_string_of_subst
  (sub :
    Umap.t
      (Names.ModPath.t *
        (Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint))) : string :=
  let l :=
    (|Util.List|).(CList.ExtS.map)
      (fun function_parameter =&gt;
        let '(s1, (s2, s3)) := function_parameter in
        String.append s1
          (String.append &quot;|-&gt;&quot;
            (String.append s2 (String.append &quot;[&quot; (String.append s3 &quot;]&quot;)))))
      (list_contents sub) in
  String.append &quot;{&quot;
    (String.append ((|Util.String|).(CString.ExtS.concat) &quot;; &quot; l) &quot;}&quot;).

Definition debug_pr_delta
  (resolve : Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint) : Pp.t :=
  str (debug_string_of_delta resolve).

Definition debug_pr_subst
  (sub :
    Umap.t
      (Names.ModPath.t *
        (Names.MPmap.t Names.ModPath.t * Names.KNmap.t delta_hint))) : Pp.t :=
  let l := list_contents sub in
  let f (function_parameter : string * (string * string)) : Pp.t :=
    let '(s1, (s2, s3)) := function_parameter in
    hov 2
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus
                (op_plusplus (op_plusplus (str s1) (spc tt)) (str &quot;|-&gt; &quot;))
                (str s2)) (spc tt)) (str &quot;[&quot;)) (str s3)) (str &quot;]&quot;)) in
  op_plusplus (op_plusplus (str &quot;{&quot;) (hov 2 (prlist_with_sep pr_comma f l)))
    (str &quot;}&quot;).

Definition add_inline_delta_resolver {A : Set}
  (kn : Names.KNmap.key)
  (function_parameter : Z * option (Univ.univ_abstracted Constr.constr))
  : A * Names.KNmap.t delta_hint -&gt; A * Names.KNmap.t delta_hint :=
  let '(lev, oc) := function_parameter in
  Deltamap.add_kn kn (Inline lev oc).

Definition add_kn_delta_resolver {A : Set}
  (kn : Names.KNmap.key) (kn' : Names.KerName.t)
  : A * Names.KNmap.t delta_hint -&gt; A * Names.KNmap.t delta_hint :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Deltamap.add_kn kn (Equiv kn').

Definition add_mp_delta_resolver {A B : Set} (mp1 : Names.MPmap.key) (mp2 : A)
  : Names.MPmap.t A * B -&gt; Names.MPmap.t A * B := Deltamap.add_mp mp1 mp2.

Definition add_mbid {A B : Set}
  (mbid : Names.MBId.t) (mp : A) (resolve : B) (s : Umap.t (A * B))
  : Umap.t (A * B) := Umap.add_mbi mbid (mp, resolve) s.

Definition add_mp {A B : Set}
  (mp1 : Names.ModPath.t) (mp2 : A) (resolve : B) (s : Umap.t (A * B))
  : Umap.t (A * B) := Umap.add_mp mp1 (mp2, resolve) s.

Definition map_mbid {A B : Set} (mbid : Names.MBId.t) (mp : A) (resolve : B)
  : Umap.t (A * B) := add_mbid mbid mp resolve empty_subst.

Definition map_mp {A B : Set} (mp1 : Names.ModPath.t) (mp2 : A) (resolve : B)
  : Umap.t (A * B) := add_mp mp1 mp2 resolve empty_subst.

Definition mp_in_delta {A B : Set} (mp : Names.MPmap.key)
  : Names.MPmap.t A * B -&gt; bool := Deltamap.mem_mp mp.

Definition kn_in_delta {A : Set}
  (kn : Names.KNmap.key) (resolver : A * Names.KNmap.t delta_hint) : bool :=
  (* ❌ Try-with are not handled *)
  try
    match Deltamap.find_kn kn resolver with
    | Equiv _ =&gt; true
    | Inline _ _ =&gt; false
    end.

Definition con_in_delta {A : Set}
  (con : Names.Constant.t) (resolver : A * Names.KNmap.t delta_hint) : bool :=
  kn_in_delta (Constant.user con) resolver.

Definition mind_in_delta {A : Set}
  (mind : Names.MutInd.t) (resolver : A * Names.KNmap.t delta_hint) : bool :=
  kn_in_delta (MutInd.user mind) resolver.

Definition mp_of_delta {A : Set}
  (resolve : Names.MPmap.t Names.MPmap.key * A) (mp : Names.MPmap.key)
  : Names.MPmap.key :=
  (* ❌ Try-with are not handled *)
  try (Deltamap.find_mp mp resolve).

Definition find_prefix {A : Set}
  (resolve : Names.MPmap.t Names.module_path * A) (mp : Names.module_path)
  : Names.module_path :=
  let fix sub_mp (function_parameter : Names.module_path)
    {struct function_parameter} : Names.module_path :=
    match function_parameter with
    | (Names.MPdot mp l) as mp_sup =&gt;
      (* ❌ Try-with are not handled *)
      try (Deltamap.find_mp mp_sup resolve)
    | p =&gt; Deltamap.find_mp p resolve
    end in
  (* ❌ Try-with are not handled *)
  try (sub_mp mp).

(* ❌ The definition of exceptions is not handled. *)
(* exception Change_equiv_to_inline *)

Definition solve_delta_kn
  (resolve : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (kn : Names.KNmap.key) : Names.KerName.t :=
  (* ❌ Try-with are not handled *)
  try
    match Deltamap.find_kn kn resolve with
    | Equiv kn1 =&gt; kn1
    | Inline lev (Some c) =&gt; Stdlib.raise extensible_type_value
    | Inline _ None =&gt; Stdlib.raise extensible_type_value
    end.

Definition kn_of_delta
  (resolve : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (kn : Names.KNmap.key) : Names.KerName.t :=
  (* ❌ Try-with are not handled *)
  try (solve_delta_kn resolve kn).

Definition kn_of_deltas
  (resolve1 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (resolve2 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (kn : Names.KNmap.key) : Names.KerName.t :=
  let kn' := kn_of_delta resolve1 kn in
  if Stdlib.op_eqeq kn' kn then
    kn_of_delta resolve2 kn
  else
    kn'.

Definition constant_of_delta_kn
  (resolve : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (kn : Names.KNmap.key) : Names.Constant.t :=
  Constant.make kn (kn_of_delta resolve kn).

Definition constant_of_deltas_kn
  (resolve1 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (resolve2 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (kn : Names.KNmap.key) : Names.Constant.t :=
  Constant.make kn (kn_of_deltas resolve1 resolve2 kn).

Definition mind_of_delta_kn
  (resolve : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (kn : Names.KNmap.key) : Names.MutInd.t :=
  MutInd.make kn (kn_of_delta resolve kn).

Definition mind_of_deltas_kn
  (resolve1 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (resolve2 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (kn : Names.KNmap.key) : Names.MutInd.t :=
  MutInd.make kn (kn_of_deltas resolve1 resolve2 kn).

Definition inline_of_delta {A : Set}
  (inline : option Z) (resolver : A * Names.KNmap.t delta_hint)
  : list (Z * Names.KNmap.key) :=
  match inline with
  | None =&gt; []
  | Some inl_lev =&gt;
    let extract {B : Set} (kn : B) (hint : delta_hint) (l : list (Z * B))
      : list (Z * B) :=
      match hint with
      | Inline lev _ =&gt;
        if OCaml.Stdlib.le lev inl_lev then
          cons (lev, kn) l
        else
          l
      | _ =&gt; l
      end in
    Deltamap.fold_kn extract resolver []
  end.

Definition search_delta_inline {A : Set}
  (resolve : A * Names.KNmap.t delta_hint) (kn1 : Names.KNmap.key)
  (kn2 : Names.KNmap.key) : option (Univ.univ_abstracted Constr.constr) :=
  let find (kn : Names.KNmap.key)
    : option (Univ.univ_abstracted Constr.constr) :=
    match Deltamap.find_kn kn resolve with
    | Inline _ o =&gt; o
    | Equiv _ =&gt; Stdlib.raise extensible_type_value
    end in
  (* ❌ Try-with are not handled *)
  try (find kn1).

Definition subst_mp0 {A : Set}
  (sub : Umap.t (Names.module_path * A)) (mp : Names.module_path)
  : option (Names.module_path * A) :=
  let fix aux (mp : Names.module_path) {struct mp} : Names.module_path * A :=
    match mp with
    | Names.MPfile _ | Names.MPbound _ =&gt; Umap.find mp sub
    | (Names.MPdot mp1 l) as mp2 =&gt;
      (* ❌ Try-with are not handled *)
      try (Umap.find mp2 sub)
    end in
  (* ❌ Try-with are not handled *)
  try (Some (aux mp)).

Definition subst_mp {A : Set}
  (sub : Umap.t (Names.module_path * A)) (mp : Names.module_path)
  : Names.module_path :=
  match subst_mp0 sub mp with
  | None =&gt; mp
  | Some (mp', _) =&gt; mp'
  end.

Definition subst_kn_delta
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (kn : Names.KerName.t) : Names.KerName.t :=
  let '(mp, l) := KerName.repr kn in
  match subst_mp0 sub mp with
  | Some (mp', resolve) =&gt; solve_delta_kn resolve (KerName.make mp' l)
  | None =&gt; kn
  end.

Definition subst_kn {A : Set}
  (sub : Umap.t (Names.module_path * A)) (kn : Names.KerName.t)
  : Names.KerName.t :=
  let '(mp, l) := KerName.repr kn in
  match subst_mp0 sub mp with
  | Some (mp', _) =&gt; KerName.make mp' l
  | None =&gt; kn
  end.

(* ❌ The definition of exceptions is not handled. *)
(* exception No_subst *)

Definition subst_dual_mp {A : Set}
  (sub : Umap.t (Names.module_path * A)) (mp1 : Names.module_path)
  (mp2 : Names.module_path)
  : Names.module_path * Names.module_path * A * bool :=
  let o1 := subst_mp0 sub mp1 in
  let o2 :=
    if Stdlib.op_eqeq mp1 mp2 then
      o1
    else
      subst_mp0 sub mp2 in
  match (o1, o2) with
  | (None, None) =&gt; Stdlib.raise extensible_type_value
  | (Some (mp1', resolve), None) =&gt; (mp1', mp2, resolve, true)
  | (None, Some (mp2', resolve)) =&gt; (mp1, mp2', resolve, false)
  | (Some (mp1', _), Some (mp2', resolve)) =&gt; (mp1', mp2', resolve, false)
  end.

Definition progress {A : Set} (f : A -&gt; A) (x : A) (orelse : A) : A :=
  let y := f x in
  if Stdlib.op_exclamationeq y x then
    y
  else
    orelse.

Definition subst_mind
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (mind : Names.MutInd.t) : Names.MutInd.t :=
  let '(mpu, l) := MutInd.repr2 mind in
  let mpc := KerName.modpath (MutInd.canonical mind) in
  (* ❌ Try-with are not handled *)
  try
    (let '(mpu, mpc, resolve, user) := subst_dual_mp sub mpu mpc in
    let knu := KerName.make mpu l in
    let knc :=
      if Stdlib.op_eqeq mpu mpc then
        knu
      else
        KerName.make mpc l in
    let knc' :=
      progress (kn_of_delta resolve)
        (if user then
          knu
        else
          knc) knc in
    MutInd.make knu knc').

Definition subst_ind {A : Set}
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (function_parameter : Names.MutInd.t * A) : Names.MutInd.t * A :=
  let '(ind, i) as indi := function_parameter in
  let ind' := subst_mind sub ind in
  if Stdlib.op_eqeq ind' ind then
    indi
  else
    (ind', i).

Definition subst_pind {A B : Set}
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (function_parameter : (Names.MutInd.t * A) * B) : (Names.MutInd.t * A) * B :=
  let '(ind, u) := function_parameter in
  ((subst_ind sub ind), u).

Definition subst_con0
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (cst : Names.Constant.t)
  : Names.Constant.t * option (Univ.univ_abstracted Constr.constr) :=
  let '(mpu, l) := Constant.repr2 cst in
  let mpc := KerName.modpath (Constant.canonical cst) in
  let '(mpu, mpc, resolve, user) := subst_dual_mp sub mpu mpc in
  let knu := KerName.make mpu l in
  let knc :=
    if Stdlib.op_eqeq mpu mpc then
      knu
    else
      KerName.make mpc l in
  match search_delta_inline resolve knu knc with
  | Some t =&gt; ((Constant.make1 knu), (Some t))
  | None =&gt;
    let knc' :=
      progress (kn_of_delta resolve)
        (if user then
          knu
        else
          knc) knc in
    let cst' := Constant.make knu knc' in
    (cst', None)
  end.

Definition subst_con
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (cst : Names.Constant.t)
  : Names.Constant.t * option (Univ.univ_abstracted Constr.constr) :=
  (* ❌ Try-with are not handled *)
  try (subst_con0 sub cst).

Definition subst_pcon {A : Set}
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (function_parameter : Names.Constant.t * A) : Names.Constant.t * A :=
  let '(con, u) as pcon := function_parameter in
  (* ❌ Try-with are not handled *)
  try
    (let '(con', _can) := subst_con0 sub con in
    (con', u)).

Definition subst_constant
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (con : Names.Constant.t) : Names.Constant.t :=
  (* ❌ Try-with are not handled *)
  try (fst (subst_con0 sub con)).

Definition subst_proj_repr
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (p : Names.Projection.Repr.t) : Names.Projection.Repr.t :=
  Projection.Repr.map (subst_mind sub) p.

Definition subst_proj
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (p : Names.Projection.t) : Names.Projection.t :=
  Projection.map (subst_mind sub) p.

Definition subst_retro_action
  (subst :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (action : Retroknowledge.action) : Retroknowledge.action :=
  match action with
  | Retroknowledge.Register_ind prim ind =&gt;
    let ind' := subst_ind subst ind in
    if Stdlib.op_eqeq ind ind' then
      action
    else
      Retroknowledge.Register_ind prim ind'
  | Retroknowledge.Register_type prim c =&gt;
    let c' := subst_constant subst c in
    if Stdlib.op_eqeq c c' then
      action
    else
      Retroknowledge.Register_type prim c'
  end.

Definition subst_evaluable_reference
  (subst :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (function_parameter : Names.evaluable_global_reference)
  : Names.evaluable_global_reference :=
  match function_parameter with
  | Names.EvalVarRef id =&gt; Names.EvalVarRef id
  | Names.EvalConstRef kn =&gt; Names.EvalConstRef (subst_constant subst kn)
  end.

Fixpoint map_kn
  (f : Names.MutInd.t -&gt; Names.MutInd.t)
  (f' : Names.Constant.t * Univ.Instance.t -&gt; Constr.constr) (c : Constr.constr)
  {struct f} : Constr.constr :=
  let func := map_kn f f' in
  match kind c with
  | Constr.Const kn =&gt;
    (* ❌ Try-with are not handled *)
    try (f' kn)
  | Constr.Proj p t =&gt;
    let p' := Projection.map f p in
    let t' := func t in
    if andb (Stdlib.op_eqeq p' p) (Stdlib.op_eqeq t' t) then
      c
    else
      mkProj (p', t')
  | Constr.Ind ((kn, i), u) =&gt;
    let kn' := f kn in
    if Stdlib.op_eqeq kn' kn then
      c
    else
      mkIndU ((kn', i), u)
  | Constr.Construct (((kn, i), j), u) =&gt;
    let kn' := f kn in
    if Stdlib.op_eqeq kn' kn then
      c
    else
      mkConstructU (((kn', i), j), u)
  | Constr.Case ci p ct l =&gt;
    let ci_ind :=
      let '(kn, i) := Constr.case_info.ci_ind ci in
      let kn' := f kn in
      if Stdlib.op_eqeq kn' kn then
        Constr.case_info.ci_ind ci
      else
        (kn', i) in
    let p' := func p in
    let ct' := func ct in
    let l' := Array.Smart.map func l in
    if
      andb (Stdlib.op_eqeq (Constr.case_info.ci_ind ci) ci_ind)
        (andb (Stdlib.op_eqeq p' p)
          (andb (Stdlib.op_eqeq l' l) (Stdlib.op_eqeq ct' ct))) then
      c
    else
      mkCase ((Constr.case_info.with_ci_ind ci ci_ind), p', ct', l')
  | Constr.Cast ct k t =&gt;
    let ct' := func ct in
    let t' := func t in
    if andb (Stdlib.op_eqeq t' t) (Stdlib.op_eqeq ct' ct) then
      c
    else
      mkCast (ct', k, t')
  | Constr.Prod na t ct =&gt;
    let ct' := func ct in
    let t' := func t in
    if andb (Stdlib.op_eqeq t' t) (Stdlib.op_eqeq ct' ct) then
      c
    else
      mkProd (na, t', ct')
  | Constr.Lambda na t ct =&gt;
    let ct' := func ct in
    let t' := func t in
    if andb (Stdlib.op_eqeq t' t) (Stdlib.op_eqeq ct' ct) then
      c
    else
      mkLambda (na, t', ct')
  | Constr.LetIn na b t ct =&gt;
    let ct' := func ct in
    let t' := func t in
    let b' := func b in
    if
      andb (Stdlib.op_eqeq t' t)
        (andb (Stdlib.op_eqeq ct' ct) (Stdlib.op_eqeq b b')) then
      c
    else
      mkLetIn (na, b', t', ct')
  | Constr.App ct l =&gt;
    let ct' := func ct in
    let l' := Array.Smart.map func l in
    if andb (Stdlib.op_eqeq ct' ct) (Stdlib.op_eqeq l' l) then
      c
    else
      mkApp (ct', l')
  | Constr.Evar (e, l) =&gt;
    let l' := Array.Smart.map func l in
    if Stdlib.op_eqeq l' l then
      c
    else
      mkEvar (e, l')
  | Constr.Fix (ln, (lna, tl, bl)) =&gt;
    let tl' := Array.Smart.map func tl in
    let bl' := Array.Smart.map func bl in
    if andb (Stdlib.op_eqeq bl bl') (Stdlib.op_eqeq tl tl') then
      c
    else
      mkFix (ln, (lna, tl', bl'))
  | Constr.CoFix (ln, (lna, tl, bl)) =&gt;
    let tl' := Array.Smart.map func tl in
    let bl' := Array.Smart.map func bl in
    if andb (Stdlib.op_eqeq bl bl') (Stdlib.op_eqeq tl tl') then
      c
    else
      mkCoFix (ln, (lna, tl', bl'))
  | _ =&gt; c
  end.

Definition subst_mps
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (c : Constr.constr) : Constr.constr :=
  let subst_pcon_term
    (sub :
      Umap.t
        (Names.module_path *
          (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
    (function_parameter : Names.Constant.t * Univ.Instance.t) : Constr.constr :=
    let '(con, u) := function_parameter in
    let '(con', can) := subst_con0 sub con in
    match can with
    | None =&gt; mkConstU (con', u)
    | Some t =&gt; Vars.univ_instantiate_constr u t
    end in
  if is_empty_subst sub then
    c
  else
    map_kn (subst_mind sub) (subst_pcon_term sub) c.

Fixpoint replace_mp_in_mp
  (mpfrom : Names.ModPath.t) (mpto : Names.module_path) (mp : Names.module_path)
  {struct mpfrom} : Names.module_path :=
  match
    (mp,
      match mp with
      | _ =&gt; ModPath.equal mp mpfrom
      | _ =&gt; false
      end) with
  | (_, true) =&gt; mpto
  | (Names.MPdot mp1 l, _) =&gt;
    let mp1' := replace_mp_in_mp mpfrom mpto mp1 in
    if Stdlib.op_eqeq mp1 mp1' then
      mp
    else
      Names.MPdot mp1' l
  | (_, _) =&gt; mp
  end.

Definition replace_mp_in_kn
  (mpfrom : Names.ModPath.t) (mpto : Names.module_path) (kn : Names.KerName.t)
  : Names.KerName.t :=
  let '(mp, l) := KerName.repr kn in
  let mp'' := replace_mp_in_mp mpfrom mpto mp in
  if Stdlib.op_eqeq mp mp'' then
    kn
  else
    KerName.make mp'' l.

Fixpoint mp_in_mp (mp : Names.ModPath.t) (mp1 : Names.module_path) {struct mp}
  : bool :=
  match
    (mp1,
      match mp1 with
      | _ =&gt; ModPath.equal mp1 mp
      | _ =&gt; false
      end) with
  | (_, true) =&gt; true
  | (Names.MPdot mp2 _l, _) =&gt; mp_in_mp mp mp2
  | (_, _) =&gt; false
  end.

Definition subset_prefixed_by {A : Set}
  (mp : Names.ModPath.t) (resolver : Names.MPmap.t A * Names.KNmap.t delta_hint)
  : Names.MPmap.t A * Names.KNmap.t delta_hint :=
  let mp_prefix {B C : Set}
    (mkey : Names.module_path) (mequ : B) (rslv : Names.MPmap.t B * C)
    : Names.MPmap.t B * C :=
    if mp_in_mp mp mkey then
      Deltamap.add_mp mkey mequ rslv
    else
      rslv in
  let kn_prefix {B : Set}
    (kn : Names.KNmap.key) (hint : delta_hint)
    (rslv : B * Names.KNmap.t delta_hint) : B * Names.KNmap.t delta_hint :=
    match hint with
    | Inline _ _ =&gt; rslv
    | Equiv _ =&gt;
      if mp_in_mp mp (KerName.modpath kn) then
        Deltamap.add_kn kn hint rslv
      else
        rslv
    end in
  Deltamap.fold mp_prefix kn_prefix resolver empty_delta_resolver.

Definition subst_dom_delta_resolver {A B C : Set}
  (subst : Umap.t (Names.module_path * A))
  (resolver : Names.MPmap.t B * Names.KNmap.t C)
  : Names.MPmap.t B * Names.KNmap.t C :=
  let mp_apply_subst {D E : Set}
    (mkey : Names.module_path) (mequ : D) (rslv : Names.MPmap.t D * E)
    : Names.MPmap.t D * E :=
    Deltamap.add_mp (subst_mp subst mkey) mequ rslv in
  let kn_apply_subst {D E : Set}
    (kkey : Names.KerName.t) (hint : D) (rslv : E * Names.KNmap.t D)
    : E * Names.KNmap.t D :=
    Deltamap.add_kn (subst_kn subst kkey) hint rslv in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver.

Definition subst_mp_delta
  (sub :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (mp : Names.module_path) (mkey : Names.module_path)
  : (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint) *
    Names.module_path :=
  match subst_mp0 sub mp with
  | None =&gt; (empty_delta_resolver, mp)
  | Some (mp', resolve) =&gt;
    let mp1 := find_prefix resolve mp' in
    let resolve1 := subset_prefixed_by mp1 resolve in
    ((subst_dom_delta_resolver (map_mp mp1 mkey empty_delta_resolver) resolve1),
      mp1)
  end.

Definition gen_subst_delta_resolver
  (dom : bool)
  (subst :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (resolver : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint :=
  let mp_apply_subst
    (mkey : Names.module_path) (mequ : Names.module_path)
    (rslv : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
    : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint :=
    let mkey' :=
      if dom then
        subst_mp subst mkey
      else
        mkey in
    let '(rslv', mequ') := subst_mp_delta subst mequ mkey in
    Deltamap.join rslv' (Deltamap.add_mp mkey' mequ' rslv) in
  let kn_apply_subst {A : Set}
    (kkey : Names.KNmap.key) (hint : delta_hint)
    (rslv : A * Names.KNmap.t delta_hint) : A * Names.KNmap.t delta_hint :=
    let kkey' :=
      if dom then
        subst_kn subst kkey
      else
        kkey in
    let hint' :=
      match hint with
      | Equiv kequ =&gt;
        (* ❌ Try-with are not handled *)
        try (Equiv (subst_kn_delta subst kequ))
      | Inline lev (Some t) =&gt;
        Inline lev (Some (Univ.map_univ_abstracted (subst_mps subst) t))
      | Inline _ None =&gt; hint
      end in
    Deltamap.add_kn kkey' hint' rslv in
  Deltamap.fold mp_apply_subst kn_apply_subst resolver empty_delta_resolver.

Definition subst_codom_delta_resolver
  : Umap.t
    (Names.module_path *
      (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)) -&gt;
  Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint -&gt;
  Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint :=
  gen_subst_delta_resolver false.

Definition subst_dom_codom_delta_resolver
  : Umap.t
    (Names.module_path *
      (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)) -&gt;
  Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint -&gt;
  Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint :=
  gen_subst_delta_resolver true.

Definition update_delta_resolver
  (resolver1 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (resolver2 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint :=
  let mp_apply_rslv {A : Set}
    (mkey : Names.MPmap.key) (mequ : Names.module_path)
    (rslv : Names.MPmap.t Names.module_path * A)
    : Names.MPmap.t Names.module_path * A :=
    Deltamap.add_mp mkey (find_prefix resolver2 mequ) rslv in
  let kn_apply_rslv {A : Set}
    (kkey : Names.KNmap.key) (hint1 : delta_hint)
    (rslv : A * Names.KNmap.t delta_hint) : A * Names.KNmap.t delta_hint :=
    let hint :=
      match hint1 with
      | Equiv kequ =&gt;
        (* ❌ Try-with are not handled *)
        try (Equiv (solve_delta_kn resolver2 kequ))
      | Inline _ (Some _) =&gt; hint1
      | Inline _ None =&gt;
        (* ❌ Try-with are not handled *)
        try (Deltamap.find_kn kkey resolver2)
      end in
    Deltamap.add_kn kkey hint rslv in
  Deltamap.fold mp_apply_rslv kn_apply_rslv resolver1 resolver2.

Definition add_delta_resolver
  (resolver1 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  (resolver2 : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)
  : Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint :=
  if Deltamap.is_empty resolver2 then
    resolver1
  else
    update_delta_resolver resolver1 resolver2.

Definition substition_prefixed_by {A B : Set}
  (k : Names.module_path) (mp : Names.ModPath.t) (subst : Umap.t (A * B))
  : Umap.t (A * B) :=
  let mp_prefixmp {C D : Set}
    (kmp : Names.module_path) (function_parameter : C * D)
    : Umap.t (C * D) -&gt; Umap.t (C * D) :=
    let '(mp_to, reso) := function_parameter in
    fun sub =&gt;
      if andb (mp_in_mp mp kmp) (negb (ModPath.equal mp kmp)) then
        let new_key := replace_mp_in_mp mp k kmp in
        Umap.add_mp new_key (mp_to, reso) sub
      else
        sub in
  Umap.fold mp_prefixmp subst empty_subst.

Definition join
  (subst1 :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  (subst2 :
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
  : Umap.t
    (Names.module_path *
      (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)) :=
  let apply_subst {A : Set}
    (mpk : Names.module_path)
    (add :
      Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint) -&gt; A -&gt;
      Umap.t
        (Names.module_path *
          (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)))
    (function_parameter :
      Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint))
    : A -&gt;
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)) :=
    let '(mp, resolve) := function_parameter in
    fun res =&gt;
      let '(mp', resolve') :=
        match subst_mp0 subst2 mp with
        | None =&gt; (mp, None)
        | Some (mp', resolve') =&gt; (mp', (Some resolve'))
        end in
      let resolve'' :=
        match resolve' with
        | Some res =&gt;
          add_delta_resolver (subst_dom_codom_delta_resolver subst2 resolve) res
        | None =&gt; subst_codom_delta_resolver subst2 resolve
        end in
      let prefixed_subst := substition_prefixed_by mpk mp' subst2 in
      Umap.join prefixed_subst (add (mp', resolve'') res) in
  let mp_apply_subst (mp : Names.module_path)
    : Names.module_path *
      (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint) -&gt;
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)) -&gt;
    Umap.t
      (Names.module_path *
        (Names.MPmap.t Names.module_path * Names.KNmap.t delta_hint)) :=
    apply_subst mp (Umap.add_mp mp) in
  let subst := Umap.fold mp_apply_subst subst1 empty_subst in
  Umap.join subst2 subst.

Module substituted.
  Record record {a : Set} := {
    subst_value : a;
    subst_subst : list substitution }.
  Arguments record : clear implicits.
  Definition with_subst_value {a_type : Set} (r : record a_type) subst_value
    : record a_type :=
    {| subst_value := subst_value; subst_subst := subst_subst r |}.
  Definition with_subst_subst {a_type : Set} (r : record a_type) subst_subst
    : record a_type :=
    {| subst_value := subst_value r; subst_subst := subst_subst |}.
End substituted.
Definition substituted := substituted.record.

Definition from_val {A : Set} (x : A) : substituted A :=
  {| substituted.subst_value := x; substituted.subst_subst := [] |}.

Definition force {A : Set}
  (fsubst : Umap.t (Names.module_path * delta_resolver) -&gt; A -&gt; A)
  (r : substituted A) : A :=
  match substituted.subst_subst r with
  | [] =&gt; substituted.subst_value r
  | s =&gt;
    let subst :=
      (|Util.List|).(CList.ExtS.fold_left) join empty_subst
        ((|Util.List|).(CList.ExtS.rev) s) in
    let x := fsubst subst (substituted.subst_value r) in
    let '_ :=
      (* ❌ Set record field not handled. *)
      set_record_field r &quot;subst_subst&quot; [] in
    let '_ :=
      (* ❌ Set record field not handled. *)
      set_record_field r &quot;subst_value&quot; x in
    x
  end.

Definition subst_substituted {A : Set} (s : substitution) (r : substituted A)
  : substituted A :=
  substituted.with_subst_subst r (cons s (substituted.subst_subst r)).

Definition force_constr : substituted Constr.constr -&gt; Constr.constr :=
  force subst_mps.

Definition subst_constr {A : Set}
  : substitution -&gt; substituted A -&gt; substituted A := subst_substituted.

Definition repr_substituted {A : Set} (r : substituted A)
  : option (list substitution) * A :=
  match substituted.subst_subst r with
  | [] =&gt; (None, (substituted.subst_value r))
  | s =&gt; ((Some s), (substituted.subst_value r))
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="mod_subst.mli">
  <div style="margin: 20px;">
    <h3>Mod_subst_mli</h3>
    <ul>
      <li>OCaml size: 171 lines</li>
      <li>Coq size: 144 lines (-16% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#mod_subst.mli"><code>mod_subst.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** {6 [Mod_subst] } *)

open Names
open Constr

(** {6 Delta resolver} *)

(** A delta_resolver maps name (constant, inductive, module_path)
   to canonical name  *)
type delta_resolver

val empty_delta_resolver : delta_resolver

val add_mp_delta_resolver :
  ModPath.t -&gt; ModPath.t -&gt; delta_resolver -&gt; delta_resolver

val add_kn_delta_resolver :
  KerName.t -&gt; KerName.t -&gt; delta_resolver -&gt; delta_resolver

val add_inline_delta_resolver :
  KerName.t -&gt; (int * constr Univ.univ_abstracted option) -&gt; delta_resolver -&gt; delta_resolver

val add_delta_resolver : delta_resolver -&gt; delta_resolver -&gt; delta_resolver

(** Effect of a [delta_resolver] on a module path, on a kernel name *)

val mp_of_delta : delta_resolver -&gt; ModPath.t -&gt; ModPath.t
val kn_of_delta : delta_resolver -&gt; KerName.t -&gt; KerName.t

(** Build a constant whose canonical part is obtained via a resolver *)

val constant_of_delta_kn : delta_resolver -&gt; KerName.t -&gt; Constant.t

(** Same, but a 2nd resolver is tried if the 1st one had no effect *)

val constant_of_deltas_kn :
  delta_resolver -&gt; delta_resolver -&gt; KerName.t -&gt; Constant.t

(** Same for inductive names *)

val mind_of_delta_kn : delta_resolver -&gt; KerName.t -&gt; MutInd.t
val mind_of_deltas_kn :
  delta_resolver -&gt; delta_resolver -&gt; KerName.t -&gt; MutInd.t

(** Extract the set of inlined constant in the resolver *)
val inline_of_delta : int option -&gt; delta_resolver -&gt; (int * KerName.t) list

(** Does a [delta_resolver] contains a [mp], a constant, an inductive ? *)

val mp_in_delta : ModPath.t -&gt; delta_resolver -&gt; bool
val con_in_delta : Constant.t -&gt; delta_resolver -&gt; bool
val mind_in_delta : MutInd.t -&gt; delta_resolver -&gt; bool


(** {6 Substitution} *)

type substitution

val empty_subst : substitution

val is_empty_subst : substitution -&gt; bool

(** add_* add [arg2/arg1]\{arg3\} to the substitution with no sequential
   composition. Most often this is not what you want. For sequential
   composition, try [join (map_mbid mp delta) subs] **)
val add_mbid :
  MBId.t -&gt; ModPath.t -&gt; delta_resolver  -&gt; substitution -&gt; substitution
val add_mp :
  ModPath.t -&gt; ModPath.t -&gt; delta_resolver -&gt; substitution -&gt; substitution

(** map_* create a new substitution [arg2/arg1]\{arg3\} *)
val map_mbid :
  MBId.t -&gt; ModPath.t -&gt; delta_resolver -&gt; substitution
val map_mp :
  ModPath.t -&gt; ModPath.t -&gt; delta_resolver -&gt; substitution

(** sequential composition:
   [substitute (join sub1 sub2) t = substitute sub2 (substitute sub1 t)]
*)
val join : substitution -&gt; substitution -&gt; substitution


(** Apply the substitution on the domain of the resolver  *)
val subst_dom_delta_resolver : substitution -&gt; delta_resolver -&gt; delta_resolver

(** Apply the substitution on the codomain of the resolver  *)
val subst_codom_delta_resolver :
  substitution -&gt; delta_resolver -&gt; delta_resolver

val subst_dom_codom_delta_resolver :
  substitution -&gt; delta_resolver -&gt; delta_resolver


type 'a substituted
val from_val : 'a -&gt; 'a substituted
val force : (substitution -&gt; 'a -&gt; 'a) -&gt; 'a substituted -&gt; 'a
val subst_substituted : substitution -&gt; 'a substituted -&gt; 'a substituted

(**/**)
(* debugging *)
val debug_string_of_subst : substitution -&gt; string
val debug_pr_subst : substitution -&gt; Pp.t
val debug_string_of_delta : delta_resolver -&gt; string
val debug_pr_delta : delta_resolver -&gt; Pp.t
(**/**)

(** [subst_mp sub mp] guarantees that whenever the result of the
   substitution is structutally equal [mp], it is equal by pointers
   as well [==] *)

val subst_mp :
  substitution -&gt; ModPath.t -&gt; ModPath.t

val subst_mind :
  substitution -&gt; MutInd.t -&gt; MutInd.t

val subst_ind :
  substitution -&gt; inductive -&gt; inductive

val subst_pind : substitution -&gt; pinductive -&gt; pinductive

val subst_kn :
  substitution -&gt; KerName.t -&gt; KerName.t

val subst_con :
  substitution -&gt; Constant.t -&gt; Constant.t * constr Univ.univ_abstracted option

val subst_pcon :
  substitution -&gt; pconstant -&gt; pconstant

val subst_constant :
  substitution -&gt; Constant.t -&gt; Constant.t

val subst_proj_repr : substitution -&gt; Projection.Repr.t -&gt; Projection.Repr.t
val subst_proj : substitution -&gt; Projection.t -&gt; Projection.t

val subst_retro_action : substitution -&gt; Retroknowledge.action -&gt; Retroknowledge.action

(** Here the semantics is completely unclear.
   What does &quot;Hint Unfold t&quot; means when &quot;t&quot; is a parameter?
   Does the user mean &quot;Unfold X.t&quot; or does she mean &quot;Unfold y&quot;
   where X.t is later on instantiated with y? I choose the first
   interpretation (i.e. an evaluable reference is never expanded). *)
val subst_evaluable_reference :
  substitution -&gt; evaluable_global_reference -&gt; evaluable_global_reference

(** [replace_mp_in_con mp mp' con] replaces [mp] with [mp'] in [con] *)
val replace_mp_in_kn : ModPath.t -&gt; ModPath.t -&gt; KerName.t -&gt; KerName.t

(** [subst_mps sub c] performs the substitution [sub] on all kernel
   names appearing in [c] *)
val subst_mps : substitution -&gt; constr -&gt; constr

(** [repr_substituted r] dumps the representation of a substituted:
    - [None, a] when r is a value
    - [Some s, a] when r is a delayed substitution [s] applied to [a] *)

val repr_substituted : 'a substituted -&gt; substitution list option * 'a

val force_constr : constr substituted -&gt; constr
val subst_constr : substitution -&gt; constr substituted -&gt; constr substituted
</pre>
  </div>
  <div class="col-md-6">
    <a href="#mod_subst.mli"><code>Mod_subst_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter delta_resolver : Set.

Parameter empty_delta_resolver : delta_resolver.

Parameter add_mp_delta_resolver :
  Names.ModPath.t -&gt; Names.ModPath.t -&gt; delta_resolver -&gt; delta_resolver.

Parameter add_kn_delta_resolver :
  Names.KerName.t -&gt; Names.KerName.t -&gt; delta_resolver -&gt; delta_resolver.

Parameter add_inline_delta_resolver :
  Names.KerName.t -&gt; Z * option (Univ.univ_abstracted Constr.constr) -&gt;
  delta_resolver -&gt; delta_resolver.

Parameter add_delta_resolver :
  delta_resolver -&gt; delta_resolver -&gt; delta_resolver.

Parameter mp_of_delta : delta_resolver -&gt; Names.ModPath.t -&gt; Names.ModPath.t.

Parameter kn_of_delta : delta_resolver -&gt; Names.KerName.t -&gt; Names.KerName.t.

Parameter constant_of_delta_kn :
  delta_resolver -&gt; Names.KerName.t -&gt; Names.Constant.t.

Parameter constant_of_deltas_kn :
  delta_resolver -&gt; delta_resolver -&gt; Names.KerName.t -&gt; Names.Constant.t.

Parameter mind_of_delta_kn :
  delta_resolver -&gt; Names.KerName.t -&gt; Names.MutInd.t.

Parameter mind_of_deltas_kn :
  delta_resolver -&gt; delta_resolver -&gt; Names.KerName.t -&gt; Names.MutInd.t.

Parameter inline_of_delta :
  option Z -&gt; delta_resolver -&gt; list (Z * Names.KerName.t).

Parameter mp_in_delta : Names.ModPath.t -&gt; delta_resolver -&gt; bool.

Parameter con_in_delta : Names.Constant.t -&gt; delta_resolver -&gt; bool.

Parameter mind_in_delta : Names.MutInd.t -&gt; delta_resolver -&gt; bool.

Parameter substitution : Set.

Parameter empty_subst : substitution.

Parameter is_empty_subst : substitution -&gt; bool.

Parameter add_mbid :
  Names.MBId.t -&gt; Names.ModPath.t -&gt; delta_resolver -&gt; substitution -&gt;
  substitution.

Parameter add_mp :
  Names.ModPath.t -&gt; Names.ModPath.t -&gt; delta_resolver -&gt; substitution -&gt;
  substitution.

Parameter map_mbid :
  Names.MBId.t -&gt; Names.ModPath.t -&gt; delta_resolver -&gt; substitution.

Parameter map_mp :
  Names.ModPath.t -&gt; Names.ModPath.t -&gt; delta_resolver -&gt; substitution.

Parameter join : substitution -&gt; substitution -&gt; substitution.

Parameter subst_dom_delta_resolver :
  substitution -&gt; delta_resolver -&gt; delta_resolver.

Parameter subst_codom_delta_resolver :
  substitution -&gt; delta_resolver -&gt; delta_resolver.

Parameter subst_dom_codom_delta_resolver :
  substitution -&gt; delta_resolver -&gt; delta_resolver.

Parameter substituted : forall (a : Set), Set.

Parameter from_val : forall {a : Set}, a -&gt; substituted a.

Parameter force : forall {a : Set},
  (substitution -&gt; a -&gt; a) -&gt; substituted a -&gt; a.

Parameter subst_substituted : forall {a : Set},
  substitution -&gt; substituted a -&gt; substituted a.

Parameter debug_string_of_subst : substitution -&gt; string.

Parameter debug_pr_subst : substitution -&gt; Pp.t.

Parameter debug_string_of_delta : delta_resolver -&gt; string.

Parameter debug_pr_delta : delta_resolver -&gt; Pp.t.

Parameter subst_mp : substitution -&gt; Names.ModPath.t -&gt; Names.ModPath.t.

Parameter subst_mind : substitution -&gt; Names.MutInd.t -&gt; Names.MutInd.t.

Parameter subst_ind : substitution -&gt; Names.inductive -&gt; Names.inductive.

Parameter subst_pind : substitution -&gt; Constr.pinductive -&gt; Constr.pinductive.

Parameter subst_kn : substitution -&gt; Names.KerName.t -&gt; Names.KerName.t.

Parameter subst_con :
  substitution -&gt; Names.Constant.t -&gt;
  Names.Constant.t * option (Univ.univ_abstracted Constr.constr).

Parameter subst_pcon : substitution -&gt; Constr.pconstant -&gt; Constr.pconstant.

Parameter subst_constant : substitution -&gt; Names.Constant.t -&gt; Names.Constant.t.

Parameter subst_proj_repr :
  substitution -&gt; Names.Projection.Repr.t -&gt; Names.Projection.Repr.t.

Parameter subst_proj : substitution -&gt; Names.Projection.t -&gt; Names.Projection.t.

Parameter subst_retro_action :
  substitution -&gt; Retroknowledge.action -&gt; Retroknowledge.action.

Parameter subst_evaluable_reference :
  substitution -&gt; Names.evaluable_global_reference -&gt;
  Names.evaluable_global_reference.

Parameter replace_mp_in_kn :
  Names.ModPath.t -&gt; Names.ModPath.t -&gt; Names.KerName.t -&gt; Names.KerName.t.

Parameter subst_mps : substitution -&gt; Constr.constr -&gt; Constr.constr.

Parameter repr_substituted : forall {a : Set},
  substituted a -&gt; option (list substitution) * a.

Parameter force_constr : substituted Constr.constr -&gt; Constr.constr.

Parameter subst_constr :
  substitution -&gt; substituted Constr.constr -&gt; substituted Constr.constr.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="mod_typing.ml">
  <div style="margin: 20px;">
    <h3>Mod_typing</h3>
    <ul>
      <li>OCaml size: 380 lines</li>
      <li>Coq size: 573 lines (+50% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#mod_typing.ml"><code>mod_typing.ml</code></a>&nbsp;<span class="label label-warning">13 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)

(* This module provides the main functions for type-checking module
   declarations *)

open Util
open Names
open Declarations
open Entries
open Environ
open Modops
open Mod_subst

type 'alg translation =
  module_signature * 'alg * delta_resolver * Univ.ContextSet.t

let rec mp_from_mexpr = function
  | MEident mp -&gt; mp
  | MEapply (expr,_) -&gt; mp_from_mexpr expr
  | MEwith (expr,_) -&gt; mp_from_mexpr expr

let is_modular = function
  | SFBmodule _ | SFBmodtype _ -&gt; true
  | SFBconst _ | SFBmind _ -&gt; false

(** Split a [structure_body] at some label corresponding to
    a modular definition or not. *)

let split_struc k m struc =
  let rec split rev_before = function
    | [] -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>
    | (k',b)::after when Label.equal k k' &amp;&amp; (is_modular b) == (m : bool) -&gt;
      List.rev rev_before,b,after
    | h::tail -&gt; split (h::rev_before) tail
  in split [] struc

let discr_resolver mtb = match mtb.mod_type with
  | NoFunctor _ -&gt; mtb.mod_delta
  | MoreFunctor _ -&gt; empty_delta_resolver

let rec rebuild_mp mp l =
  match l with
  | []-&gt; mp
  | i::r -&gt; rebuild_mp (MPdot(mp,Label.of_id i)) r

let (+++) = Univ.ContextSet.union

let rec check_with_def env struc (idl,(c,ctx)) mp equiv =
  let lab,idl = match idl with
    | [] -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    | id::idl -&gt; Label.of_id id, idl
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let modular = not (List.is_empty idl) in
    let before,spec,after = split_struc lab modular struc in
    let env' = Modops.add_structure mp before equiv env in
    if List.is_empty idl then
      (* Toplevel definition *)
      let cb = match spec with
        | SFBconst cb -&gt; cb
        | _ -&gt; error_not_a_constant lab
      in
      (* In the spirit of subtyping.check_constant, we accept
         any implementations of parameters and opaques terms,
         as long as they have the right type *)
      let c', univs, ctx' =
        match cb.const_universes, ctx with
        | Monomorphic _, None -&gt;
          let c',cst = match cb.const_body with
            | Undef _ | OpaqueDef _ -&gt;
              let j = Typeops.infer env' c in
              </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (j.uj_val == c); (* relevances should already be correct here *)
              let typ = cb.const_type in
              let cst' = Reduction.infer_conv_leq env' (Environ.universes env')
                  j.uj_type typ in
              j.uj_val, cst'</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
            | Def cs -&gt;
              let c' = Mod_subst.force_constr cs in
              c, Reduction.infer_conv env' (Environ.universes env') c c'
            | Primitive _ -&gt;
              error_incorrect_with_constraint lab
          in
          c', Monomorphic Univ.ContextSet.empty, cst
        | Polymorphic uctx, Some ctx -&gt;
          let () =
            if not (UGraph.check_subtype ~lbound:(Environ.universes_lbound env)
                      (Environ.universes env) uctx ctx) then
              error_incorrect_with_constraint lab
          in
          (** Terms are compared in a context with De Bruijn universe indices *)
          let env' = Environ.push_context ~strict:false (Univ.AUContext.repr uctx) env in
          let cst = match cb.const_body with
            | Undef _ | OpaqueDef _ -&gt;
              let j = Typeops.infer env' c in
              </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (j.uj_val == c); (* relevances should already be correct here *)
              let typ = cb.const_type in
              let cst' = Reduction.infer_conv_leq env' (Environ.universes env')
                  j.uj_type typ in
              cst'</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
            | Def cs -&gt;
              let c' = Mod_subst.force_constr cs in
              let cst' = Reduction.infer_conv env' (Environ.universes env') c c' in
              cst'
            | Primitive _ -&gt;
              error_incorrect_with_constraint lab
          in
          </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (Univ.Constraint.is_empty cst) then
            error_incorrect_with_constraint lab;
          c, Polymorphic ctx, Univ.Constraint.empty</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
        | _ -&gt; error_incorrect_with_constraint lab
      in
      let def = Def (Mod_subst.from_val c') in
      (*      let ctx' = Univ.UContext.make (newus, cst) in *)
      let cb' =
        { cb with
          const_body = def;
          const_universes = univs ;
          const_body_code = Option.map Cemitcodes.from_val
              (Cbytegen.compile_constant_body ~fail_on_error:false env' cb.const_universes def) }
      in
      before@(lab,SFBconst(cb'))::after, c', ctx'
    else
      (* Definition inside a sub-module *)
      let mb = match spec with
        | SFBmodule mb -&gt; mb
        | _ -&gt; error_not_a_module (Label.to_string lab)
      in
      begin match mb.mod_expr with
        | Abstract -&gt;
          let struc = Modops.destr_nofunctor mb.mod_type in
          let struc',c',cst =
            check_with_def env' struc (idl,(c,ctx)) (MPdot(mp,lab)) mb.mod_delta
          in
          let mb' = { mb with
                      mod_type = NoFunctor struc';
                      mod_type_alg = None }
          in
          before@(lab,SFBmodule mb')::after, c', cst
        | _ -&gt; error_generative_module_expected lab
      end
  with
  | Not_found -&gt; error_no_such_label lab
  | Reduction.NotConvertible -&gt; error_incorrect_with_constraint lab</abbr>

let rec check_with_mod env struc (idl,mp1) mp equiv =
  let lab,idl = match idl with
    | [] -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    | id::idl -&gt; Label.of_id id, idl
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let before,spec,after = split_struc lab true struc in
    let env' = Modops.add_structure mp before equiv env in
    let old = match spec with
      | SFBmodule mb -&gt; mb
      | _ -&gt; error_not_a_module (Label.to_string lab)
    in
    if List.is_empty idl then
      (* Toplevel module definition *)
      let mb_mp1 = lookup_module mp1 env in
      let mtb_mp1 = module_type_of_module mb_mp1 in
      let cst = match old.mod_expr with
        | Abstract -&gt;
          let mtb_old = module_type_of_module old in
          let chk_cst = Subtyping.check_subtypes env' mtb_mp1 mtb_old in
          Univ.ContextSet.add_constraints chk_cst old.mod_constraints
        | Algebraic (NoFunctor (MEident(mp'))) -&gt;
          </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_modpath_equiv env' mp1 mp';
          old.mod_constraints</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
        | _ -&gt; error_generative_module_expected lab
      in
      let mp' = MPdot (mp,lab) in
      let new_mb = strengthen_and_subst_mb mb_mp1 mp' false in
      let new_mb' =
        { new_mb with
          mod_mp = mp';
          mod_expr = Algebraic (NoFunctor (MEident mp1));
          mod_constraints = cst }
      in
      let new_equiv = add_delta_resolver equiv new_mb.mod_delta in
      (* we propagate the new equality in the rest of the signature
         with the identity substitution accompanied by the new resolver*)
      let id_subst = map_mp mp' mp' new_mb.mod_delta in
      let new_after = subst_structure id_subst after in
      before@(lab,SFBmodule new_mb')::new_after, new_equiv, cst
    else
      (* Module definition of a sub-module *)
      let mp' = MPdot (mp,lab) in
      let old = match spec with
        | SFBmodule msb -&gt; msb
        | _ -&gt; error_not_a_module (Label.to_string lab)
      in
      begin match old.mod_expr with
      | Abstract -&gt;
        let struc = destr_nofunctor old.mod_type in
        let struc',equiv',cst =
          check_with_mod env' struc (idl,mp1) mp' old.mod_delta
        in
        let new_mb =
          { old with
            mod_type = NoFunctor struc';
            mod_type_alg = None;
            mod_delta = equiv' }
        in
        let new_equiv = add_delta_resolver equiv equiv' in
        let id_subst = map_mp mp' mp' equiv' in
        let new_after = subst_structure id_subst after in
        before@(lab,SFBmodule new_mb)::new_after, new_equiv, cst
      | Algebraic (NoFunctor (MEident mp0)) -&gt;
        let mpnew = rebuild_mp mp0 idl in
        </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_modpath_equiv env' mpnew mp;
        before@(lab,spec)::after, equiv, Univ.ContextSet.empty</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
      | _ -&gt; error_generative_module_expected lab
      end
  with
  | Not_found -&gt; error_no_such_label lab
  | Reduction.NotConvertible -&gt; error_incorrect_with_constraint lab</abbr>

let check_with env mp (sign,alg,reso,cst) = function
  |WithDef(idl, (c, ctx)) -&gt;
    let struc = destr_nofunctor sign in
    let struc', c', cst' = check_with_def env struc (idl, (c, ctx)) mp reso in
    let wd' = WithDef (idl, (c', ctx)) in
    NoFunctor struc', MEwith (alg,wd'), reso, Univ.ContextSet.add_constraints cst' cst
  |WithMod(idl,mp1) as wd -&gt;
    let struc = destr_nofunctor sign in
    let struc',reso',cst' = check_with_mod env struc (idl,mp1) mp reso in
    NoFunctor struc', MEwith (alg,wd), reso', cst+++cst'

let translate_apply env inl (sign,alg,reso,cst1) mp1 mkalg =
  let farg_id, farg_b, fbody_b = destr_functor sign in
  let mtb = module_type_of_module (lookup_module mp1 env) in
  let cst2 = Subtyping.check_subtypes env mtb farg_b in
  let mp_delta = discr_resolver mtb in
  let mp_delta = inline_delta_resolver env inl mp1 farg_id farg_b mp_delta in
  let subst = map_mbid farg_id mp1 mp_delta in
  let body = subst_signature subst fbody_b in
  let alg' = mkalg alg mp1 in
  let reso' = subst_codom_delta_resolver subst reso in
  body,alg',reso', Univ.ContextSet.add_constraints cst2 cst1

(** Translation of a module struct entry :
    - We translate to a module when a [module_path] is given,
      otherwise to a module type.
    - The first output is the expanded signature
    - The second output is the algebraic expression, kept for the extraction.
*)

let mk_alg_app alg arg = MEapply (alg,arg)

let rec translate_mse env mpo inl = function
  |MEident mp1 as me -&gt;
    let mb = match mpo with
      |Some mp -&gt; strengthen_and_subst_mb (lookup_module mp1 env) mp false
      |None -&gt;
        let mt = lookup_modtype mp1 env in
        module_body_of_type mt.mod_mp mt
    in
    mb.mod_type, me, mb.mod_delta, Univ.ContextSet.empty
  |MEapply (fe,mp1) -&gt;
    translate_apply env inl (translate_mse env mpo inl fe) mp1 mk_alg_app
  |MEwith(me, with_decl) -&gt;
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (mpo == None); (* No 'with' syntax for modules *)
    let mp = mp_from_mexpr me in
    check_with env mp (translate_mse env None inl me) with_decl</abbr>

let mk_mod mp e ty cst reso =
  { mod_mp = mp;
    mod_expr = e;
    mod_type = ty;
    mod_type_alg = None;
    mod_constraints = cst;
    mod_delta = reso;
    mod_retroknowledge = ModBodyRK []; }

let mk_modtype mp ty cst reso =
  let mb = mk_mod mp Abstract ty cst reso in
  { mb with mod_expr = (); mod_retroknowledge = ModTypeRK }

let rec translate_mse_funct env mpo inl mse = function
  |[] -&gt;
    let sign,alg,reso,cst = translate_mse env mpo inl mse in
    sign, NoFunctor alg, reso, cst
  |(mbid, ty) :: params -&gt;
    let mp_id = MPbound mbid in
    let mtb = translate_modtype env mp_id inl ([],ty) in
    let env' = add_module_type mp_id mtb env in
    let sign,alg,reso,cst = translate_mse_funct env' mpo inl mse params in
    let alg' = MoreFunctor (mbid,mtb,alg) in
    MoreFunctor (mbid, mtb, sign), alg',reso, cst +++ mtb.mod_constraints

and translate_modtype env mp inl (params,mte) =
  let sign,alg,reso,cst = translate_mse_funct env None inl mte params in
  let mtb = mk_modtype (mp_from_mexpr mte) sign cst reso in
  let mtb' = subst_modtype_and_resolver mtb mp in
  { mtb' with mod_type_alg = Some alg }

(** [finalize_module] :
    from an already-translated (or interactive) implementation and
    an (optional) signature entry, produces a final [module_body] *)

let finalize_module env mp (sign,alg,reso,cst) restype = match restype with
  |None -&gt;
    let impl = match alg with Some e -&gt; Algebraic e | None -&gt; FullStruct in
    mk_mod mp impl sign cst reso
  |Some (params_mte,inl) -&gt;
    let res_mtb = translate_modtype env mp inl params_mte in
    let auto_mtb = mk_modtype mp sign Univ.ContextSet.empty reso in
    let cst' = Subtyping.check_subtypes env auto_mtb res_mtb in
    let impl = match alg with Some e -&gt; Algebraic e | None -&gt; Struct sign in
    { res_mtb with
      mod_mp = mp;
      mod_expr = impl;
      mod_retroknowledge = ModBodyRK [];
      (** cst from module body typing,
          cst' from subtyping,
          constraints from module type. *)
      mod_constraints =
        Univ.ContextSet.add_constraints cst' (cst +++ res_mtb.mod_constraints) }

let translate_module env mp inl = function
  |MType (params,ty) -&gt;
    let mtb = translate_modtype env mp inl (params,ty) in
    module_body_of_type mp mtb
  |MExpr (params,mse,oty) -&gt;
    let (sg,alg,reso,cst) = translate_mse_funct env (Some mp) inl mse params in
    let restype = Option.map (fun ty -&gt; ((params,ty),inl)) oty in
    finalize_module env mp (sg,Some alg,reso,cst) restype

(** We now forbid any Include of functors with restricted signatures.
    Otherwise, we could end with the creation of undesired axioms
    (see #3746). Note that restricted non-functorized modules are ok,
    thanks to strengthening. *)

let rec unfunct = function
  |NoFunctor me -&gt; me
  |MoreFunctor(_,_,me) -&gt; unfunct me

let rec forbid_incl_signed_functor env = function
  |MEapply(fe,_) -&gt; forbid_incl_signed_functor env fe
  |MEwith _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* No 'with' syntax for modules *)
  |MEident mp1 -&gt;
    let mb = lookup_module mp1 env in
    match mb.mod_type, mb.mod_type_alg, mb.mod_expr with
    |MoreFunctor _, Some _, _ -&gt;
      (* functor + restricted signature = error *)
      error_include_restricted_functor mp1
    |MoreFunctor _, None, Algebraic me -&gt;
      (* functor, no signature yet, a definition which may be restricted *)
      forbid_incl_signed_functor env (unfunct me)
    |_ -&gt; ()

let rec translate_mse_inclmod env mp inl = function
  |MEident mp1 -&gt;
    let mb = strengthen_and_subst_mb (lookup_module mp1 env) mp true in
    let sign = clean_bounded_mod_expr mb.mod_type in
    sign,(),mb.mod_delta,Univ.ContextSet.empty
  |MEapply (fe,arg) -&gt;
    let ftrans = translate_mse_inclmod env mp inl fe in
    translate_apply env inl ftrans arg (fun _ _ -&gt; ())
  |MEwith _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* No 'with' syntax for modules *)

let translate_mse_incl is_mod env mp inl me =
  if is_mod then
    let () = forbid_incl_signed_functor env me in
    translate_mse_inclmod env mp inl me
  else
    let mtb = translate_modtype env mp inl ([],me) in
    let sign = clean_bounded_mod_expr mtb.mod_type in
    sign,(),mtb.mod_delta,mtb.mod_constraints
</pre>
  </div>
  <div class="col-md-6">
    <a href="#mod_typing.ml"><code>Mod_typing.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Declarations.

Import Entries.

Import Environ.

Import Modops.

Import Mod_subst.

Definition translation (alg : Set) :=
  Declarations.module_signature * alg * Mod_subst.delta_resolver *
    Univ.ContextSet.t.

Fixpoint mp_from_mexpr (function_parameter : Declarations.module_alg_expr)
  {struct function_parameter} : Names.ModPath.t :=
  match function_parameter with
  | Declarations.MEident mp =&gt; mp
  | Declarations.MEapply expr _ =&gt; mp_from_mexpr expr
  | Declarations.MEwith expr _ =&gt; mp_from_mexpr expr
  end.

Definition is_modular (function_parameter : Declarations.structure_field_body)
  : bool :=
  match function_parameter with
  | Declarations.SFBmodule _ | Declarations.SFBmodtype _ =&gt; true
  | Declarations.SFBconst _ | Declarations.SFBmind _ =&gt; false
  end.

Definition split_struc
  (k : Names.Label.t) (m : bool)
  (struc : list (Names.Label.t * Declarations.structure_field_body))
  : list (Names.Label.t * Declarations.structure_field_body) *
    Declarations.structure_field_body *
    list (Names.Label.t * Declarations.structure_field_body) :=
  let fix split
    (rev_before : list (Names.Label.t * Declarations.structure_field_body))
    (function_parameter :
      list (Names.Label.t * Declarations.structure_field_body))
    {struct rev_before}
    : list (Names.Label.t * Declarations.structure_field_body) *
      Declarations.structure_field_body *
      list (Names.Label.t * Declarations.structure_field_body) :=
    match
      (function_parameter,
        match function_parameter with
        | cons (k', b) after =&gt;
          andb (Label.equal k k') (Stdlib.op_eqeq (is_modular b) m)
        | _ =&gt; false
        end) with
    | ([], _) =&gt; Stdlib.raise extensible_type_value
    | (cons (k', b) after, true) =&gt;
      (((|Util.List|).(CList.ExtS.rev) rev_before), b, after)
    | (cons h tail, _) =&gt; split (cons h rev_before) tail
    end in
  split [] struc.

Definition discr_resolver {A : Set} (mtb : Declarations.generic_module_body A)
  : Mod_subst.delta_resolver :=
  match Declarations.generic_module_body.mod_type mtb with
  | Declarations.NoFunctor _ =&gt; Declarations.generic_module_body.mod_delta mtb
  | Declarations.MoreFunctor _ _ _ =&gt; empty_delta_resolver
  end.

Fixpoint rebuild_mp (mp : Names.module_path) (l : list Names.Id.t) {struct mp}
  : Names.module_path :=
  match l with
  | [] =&gt; mp
  | cons i r =&gt; rebuild_mp (Names.MPdot mp (Label.of_id i)) r
  end.

Definition op_plusplusplus
  : Univ.ContextSet.t -&gt; Univ.ContextSet.t -&gt; Univ.ContextSet.t :=
  Univ.ContextSet.union.

Fixpoint check_with_def
  (env : Environ.env)
  (struc : list (Names.Label.t * Declarations.structure_field_body))
  (function_parameter :
    list Names.Id.t * (Constr.constr * option Univ.AUContext.t)) {struct env}
  : Names.ModPath.t -&gt; Mod_subst.delta_resolver -&gt;
  list (Names.Label.t * Declarations.structure_field_body) * Constr.constr *
    Univ.Constraint.t :=
  let '(idl, (c, ctx)) := function_parameter in
  fun mp =&gt;
    fun equiv =&gt;
      let '(lab, idl) :=
        match idl with
        | [] =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        | cons id idl =&gt; ((Label.of_id id), idl)
        end in
      (* ❌ Try-with are not handled *)
      try
        (let modular := negb ((|Util.List|).(CList.ExtS.is_empty) idl) in
        let '(before, spec, after) := split_struc lab modular struc in
        let env' := Modops.add_structure mp before equiv env in
        if (|Util.List|).(CList.ExtS.is_empty) idl then
          let cb :=
            match spec with
            | Declarations.SFBconst cb =&gt; cb
            | _ =&gt; error_not_a_constant lab
            end in
          let '(c', univs, ctx') :=
            match ((Declarations.constant_body.const_universes cb), ctx) with
            | (Declarations.Monomorphic _, None) =&gt;
              let '(c', cst) :=
                match Declarations.constant_body.const_body cb with
                | Declarations.Undef _ | Declarations.OpaqueDef _ =&gt;
                  let j := Typeops.infer env' c in
                  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
                  (* ❌ instruction_sequence &quot;;&quot; *)
                  let typ := Declarations.constant_body.const_type cb in
                  let cst' :=
                    Reduction.infer_conv_leq None None None env'
                      (Environ.universes env')
                      (Environ.punsafe_judgment.uj_type j) typ in
                  ((Environ.punsafe_judgment.uj_val j), cst')
                | Declarations.Def cs =&gt;
                  let c' := Mod_subst.force_constr cs in
                  (c,
                    (Reduction.infer_conv None None None env'
                      (Environ.universes env') c c'))
                | Declarations.Primitive _ =&gt;
                  error_incorrect_with_constraint lab
                end in
              (c', (Declarations.Monomorphic Univ.ContextSet.empty), cst)
            | (Declarations.Polymorphic uctx, Some ctx) =&gt;
              let '_ :=
                if
                  negb
                    (UGraph.check_subtype (Environ.universes_lbound env)
                      (Environ.universes env) uctx ctx) then
                  error_incorrect_with_constraint lab
                else
                  tt in
              let env' :=
                Environ.push_context (Some false) (Univ.AUContext.repr uctx) env
                in
              let cst :=
                match Declarations.constant_body.const_body cb with
                | Declarations.Undef _ | Declarations.OpaqueDef _ =&gt;
                  let j := Typeops.infer env' c in
                  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
                  (* ❌ instruction_sequence &quot;;&quot; *)
                  let typ := Declarations.constant_body.const_type cb in
                  let cst' :=
                    Reduction.infer_conv_leq None None None env'
                      (Environ.universes env')
                      (Environ.punsafe_judgment.uj_type j) typ in
                  cst'
                | Declarations.Def cs =&gt;
                  let c' := Mod_subst.force_constr cs in
                  let cst' :=
                    Reduction.infer_conv None None None env'
                      (Environ.universes env') c c' in
                  cst'
                | Declarations.Primitive _ =&gt;
                  error_incorrect_with_constraint lab
                end in
              (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
              (* ❌ instruction_sequence &quot;;&quot; *)
              (c, (Declarations.Polymorphic ctx), Univ.Constraint.empty)
            | _ =&gt; error_incorrect_with_constraint lab
            end in
          let def := Declarations.Def (Mod_subst.from_val c') in
          let cb' :=
            Declarations.constant_body.with_const_universes
              (Declarations.constant_body.with_const_body_code
                (Declarations.constant_body.with_const_body cb def)
                (Option.map Cemitcodes.from_val
                  (Cbytegen.compile_constant_body false env'
                    (Declarations.constant_body.const_universes cb) def))) univs
            in
          ((op_at before (cons (lab, (Declarations.SFBconst cb')) after)), c',
            ctx')
        else
          let mb :=
            match spec with
            | Declarations.SFBmodule mb =&gt; mb
            | _ =&gt; error_not_a_module (Label.to_string lab)
            end in
          match Declarations.generic_module_body.mod_expr mb with
          | Declarations.Abstract =&gt;
            let struc :=
              Modops.destr_nofunctor
                (Declarations.generic_module_body.mod_type mb) in
            let '(struc', c', cst) :=
              check_with_def env' struc (idl, (c, ctx)) (Names.MPdot mp lab)
                (Declarations.generic_module_body.mod_delta mb) in
            let mb' :=
              Declarations.generic_module_body.with_mod_type_alg
                (Declarations.generic_module_body.with_mod_type mb
                  (Declarations.NoFunctor struc')) None in
            ((op_at before (cons (lab, (Declarations.SFBmodule mb')) after)),
              c', cst)
          | _ =&gt; error_generative_module_expected lab
          end).

Fixpoint check_with_mod
  (env : Environ.env)
  (struc : list (Names.Label.t * Declarations.structure_field_body))
  (function_parameter : list Names.Id.t * Names.ModPath.t) {struct env}
  : Names.ModPath.t -&gt; Mod_subst.delta_resolver -&gt;
  list (Names.Label.t * Declarations.structure_field_body) *
    Mod_subst.delta_resolver * Univ.ContextSet.t :=
  let '(idl, mp1) := function_parameter in
  fun mp =&gt;
    fun equiv =&gt;
      let '(lab, idl) :=
        match idl with
        | [] =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        | cons id idl =&gt; ((Label.of_id id), idl)
        end in
      (* ❌ Try-with are not handled *)
      try
        (let '(before, spec, after) := split_struc lab true struc in
        let env' := Modops.add_structure mp before equiv env in
        let old :=
          match spec with
          | Declarations.SFBmodule mb =&gt; mb
          | _ =&gt; error_not_a_module (Label.to_string lab)
          end in
        if (|Util.List|).(CList.ExtS.is_empty) idl then
          let mb_mp1 := lookup_module mp1 env in
          let mtb_mp1 := module_type_of_module mb_mp1 in
          let cst :=
            match Declarations.generic_module_body.mod_expr old with
            | Declarations.Abstract =&gt;
              let mtb_old := module_type_of_module old in
              let chk_cst := Subtyping.check_subtypes env' mtb_mp1 mtb_old in
              Univ.ContextSet.add_constraints chk_cst
                (Declarations.generic_module_body.mod_constraints old)
            |
              Declarations.Algebraic
                (Declarations.NoFunctor (Declarations.MEident mp')) =&gt;
              (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
              (* ❌ instruction_sequence &quot;;&quot; *)
              Declarations.generic_module_body.mod_constraints old
            | _ =&gt; error_generative_module_expected lab
            end in
          let mp' := Names.MPdot mp lab in
          let new_mb := strengthen_and_subst_mb mb_mp1 mp' false in
          let new_mb' :=
            Declarations.generic_module_body.with_mod_constraints
              (Declarations.generic_module_body.with_mod_expr
                (Declarations.generic_module_body.with_mod_mp new_mb mp')
                (Declarations.Algebraic
                  (Declarations.NoFunctor (Declarations.MEident mp1)))) cst in
          let new_equiv :=
            add_delta_resolver equiv
              (Declarations.generic_module_body.mod_delta new_mb) in
          let id_subst :=
            map_mp mp' mp' (Declarations.generic_module_body.mod_delta new_mb)
            in
          let new_after := subst_structure id_subst after in
          ((op_at before
            (cons (lab, (Declarations.SFBmodule new_mb')) new_after)),
            new_equiv, cst)
        else
          let mp' := Names.MPdot mp lab in
          let old :=
            match spec with
            | Declarations.SFBmodule msb =&gt; msb
            | _ =&gt; error_not_a_module (Label.to_string lab)
            end in
          match Declarations.generic_module_body.mod_expr old with
          | Declarations.Abstract =&gt;
            let struc :=
              destr_nofunctor (Declarations.generic_module_body.mod_type old) in
            let '(struc', equiv', cst) :=
              check_with_mod env' struc (idl, mp1) mp'
                (Declarations.generic_module_body.mod_delta old) in
            let new_mb :=
              Declarations.generic_module_body.with_mod_delta
                (Declarations.generic_module_body.with_mod_type_alg
                  (Declarations.generic_module_body.with_mod_type old
                    (Declarations.NoFunctor struc')) None) equiv' in
            let new_equiv := add_delta_resolver equiv equiv' in
            let id_subst := map_mp mp' mp' equiv' in
            let new_after := subst_structure id_subst after in
            ((op_at before
              (cons (lab, (Declarations.SFBmodule new_mb)) new_after)),
              new_equiv, cst)
          |
            Declarations.Algebraic
              (Declarations.NoFunctor (Declarations.MEident mp0)) =&gt;
            let mpnew := rebuild_mp mp0 idl in
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            ((op_at before (cons (lab, spec) after)), equiv,
              Univ.ContextSet.empty)
          | _ =&gt; error_generative_module_expected lab
          end).

Definition check_with {A B : Set}
  (env : Environ.env) (mp : Names.ModPath.t)
  (function_parameter :
    Declarations.functorize A
      (list (Names.Label.t * Declarations.structure_field_body)) *
      Declarations.module_alg_expr * Mod_subst.delta_resolver *
      Univ.ContextSet.t)
  : Declarations.with_declaration -&gt;
  Declarations.functorize B
    (list (Names.Label.t * Declarations.structure_field_body)) *
    Declarations.module_alg_expr * Mod_subst.delta_resolver * Univ.ContextSet.t :=
  let '(sign, alg, reso, cst) := function_parameter in
  fun function_parameter =&gt;
    match function_parameter with
    | Declarations.WithDef idl (c, ctx) =&gt;
      let struc := destr_nofunctor sign in
      let '(struc', c', cst') :=
        check_with_def env struc (idl, (c, ctx)) mp reso in
      let wd' := Declarations.WithDef idl (c', ctx) in
      ((Declarations.NoFunctor struc'), (Declarations.MEwith alg wd'), reso,
        (Univ.ContextSet.add_constraints cst' cst))
    | (Declarations.WithMod idl mp1) as wd =&gt;
      let struc := destr_nofunctor sign in
      let '(struc', reso', cst') := check_with_mod env struc (idl, mp1) mp reso
        in
      ((Declarations.NoFunctor struc'), (Declarations.MEwith alg wd), reso',
        (op_plusplusplus cst cst'))
    end.

Definition translate_apply {A B : Set}
  (env : Environ.env) (inl : Entries.inline)
  (function_parameter :
    Declarations.functorize Declarations.module_type_body
      Declarations.structure_body * A * Mod_subst.delta_resolver *
      Univ.ContextSet.t)
  : Names.ModPath.t -&gt; (A -&gt; Names.ModPath.t -&gt; B) -&gt;
  Declarations.module_signature * B * Mod_subst.delta_resolver *
    Univ.ContextSet.t :=
  let '(sign, alg, reso, cst1) := function_parameter in
  fun mp1 =&gt;
    fun mkalg =&gt;
      let '(farg_id, farg_b, fbody_b) := destr_functor sign in
      let mtb := module_type_of_module (lookup_module mp1 env) in
      let cst2 := Subtyping.check_subtypes env mtb farg_b in
      let mp_delta := discr_resolver mtb in
      let mp_delta := inline_delta_resolver env inl mp1 farg_id farg_b mp_delta
        in
      let subst := map_mbid farg_id mp1 mp_delta in
      let body := subst_signature subst fbody_b in
      let alg' := mkalg alg mp1 in
      let reso' := subst_codom_delta_resolver subst reso in
      (body, alg', reso', (Univ.ContextSet.add_constraints cst2 cst1)).

Definition mk_alg_app
  (alg : Declarations.module_alg_expr) (arg : Names.ModPath.t)
  : Declarations.module_alg_expr := Declarations.MEapply alg arg.

Fixpoint translate_mse
  (env : Environ.env) (mpo : option Names.ModPath.t) (inl : Entries.inline)
  (function_parameter : Declarations.module_alg_expr) {struct env}
  : Declarations.module_signature * Declarations.module_alg_expr *
    Mod_subst.delta_resolver * Univ.ContextSet.t :=
  match function_parameter with
  | (Declarations.MEident mp1) as me =&gt;
    let mb :=
      match mpo with
      | Some mp =&gt; strengthen_and_subst_mb (lookup_module mp1 env) mp false
      | None =&gt;
        let mt := lookup_modtype mp1 env in
        module_body_of_type (Declarations.generic_module_body.mod_mp mt) mt
      end in
    ((Declarations.generic_module_body.mod_type mb), me,
      (Declarations.generic_module_body.mod_delta mb), Univ.ContextSet.empty)
  | Declarations.MEapply fe mp1 =&gt;
    translate_apply env inl (translate_mse env mpo inl fe) mp1 mk_alg_app
  | Declarations.MEwith me with_decl =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let mp := mp_from_mexpr me in
    check_with env mp (translate_mse env None inl me) with_decl
  end.

Definition mk_mod
  (mp : Names.ModPath.t) (e : Declarations.module_implementation)
  (ty : Declarations.module_signature) (cst : Univ.ContextSet.t)
  (reso : Mod_subst.delta_resolver)
  : Declarations.generic_module_body Declarations.module_implementation :=
  {| Declarations.generic_module_body.mod_mp := mp;
    Declarations.generic_module_body.mod_expr := e;
    Declarations.generic_module_body.mod_type := ty;
    Declarations.generic_module_body.mod_type_alg := None;
    Declarations.generic_module_body.mod_constraints := cst;
    Declarations.generic_module_body.mod_delta := reso;
    Declarations.generic_module_body.mod_retroknowledge :=
      Declarations.ModBodyRK [] |}.

Definition mk_modtype
  (mp : Names.ModPath.t) (ty : Declarations.module_signature)
  (cst : Univ.ContextSet.t) (reso : Mod_subst.delta_resolver)
  : Declarations.generic_module_body unit :=
  let mb := mk_mod mp Declarations.Abstract ty cst reso in
  Declarations.generic_module_body.with_mod_retroknowledge
    (Declarations.generic_module_body.with_mod_expr mb tt)
    Declarations.ModTypeRK.

Fixpoint translate_mse_funct
  (env : Environ.env) (mpo : option Names.ModPath.t) (inl : Entries.inline)
  (mse : Declarations.module_alg_expr)
  (function_parameter : list (Names.MBId.t * Declarations.module_alg_expr))
  {struct env}
  : Declarations.module_signature * Declarations.module_expression *
    Mod_subst.delta_resolver * Univ.ContextSet.t :=
  match function_parameter with
  | [] =&gt;
    let '(sign, alg, reso, cst) := translate_mse env mpo inl mse in
    (sign, (Declarations.NoFunctor alg), reso, cst)
  | cons (mbid, ty) params =&gt;
    let mp_id := Names.MPbound mbid in
    let mtb := translate_modtype env mp_id inl ([], ty) in
    let env' := add_module_type mp_id mtb env in
    let '(sign, alg, reso, cst) := translate_mse_funct env' mpo inl mse params
      in
    let alg' := Declarations.MoreFunctor mbid mtb alg in
    ((Declarations.MoreFunctor mbid mtb sign), alg', reso,
      (op_plusplusplus cst
        (Declarations.generic_module_body.mod_constraints mtb)))
  end

with translate_modtype
  (env : Environ.env) (mp : Names.module_path) (inl : Entries.inline)
  (function_parameter :
    list (Names.MBId.t * Declarations.module_alg_expr) *
      Declarations.module_alg_expr) {struct env}
  : Declarations.module_type_body :=
  let '(params, mte) := function_parameter in
  let '(sign, alg, reso, cst) := translate_mse_funct env None inl mte params in
  let mtb := mk_modtype (mp_from_mexpr mte) sign cst reso in
  let mtb' := subst_modtype_and_resolver mtb mp in
  Declarations.generic_module_body.with_mod_type_alg mtb' (Some alg).

Definition finalize_module
  (env : Environ.env) (mp : Names.module_path)
  (function_parameter :
    Declarations.module_signature * option Declarations.module_expression *
      Mod_subst.delta_resolver * Univ.ContextSet.t)
  : option
    ((list (Names.MBId.t * Declarations.module_alg_expr) *
      Declarations.module_alg_expr) * Entries.inline) -&gt;
  Declarations.generic_module_body Declarations.module_implementation :=
  let '(sign, alg, reso, cst) := function_parameter in
  fun restype =&gt;
    match restype with
    | None =&gt;
      let impl :=
        match alg with
        | Some e =&gt; Declarations.Algebraic e
        | None =&gt; Declarations.FullStruct
        end in
      mk_mod mp impl sign cst reso
    | Some (params_mte, inl) =&gt;
      let res_mtb := translate_modtype env mp inl params_mte in
      let auto_mtb := mk_modtype mp sign Univ.ContextSet.empty reso in
      let cst' := Subtyping.check_subtypes env auto_mtb res_mtb in
      let impl :=
        match alg with
        | Some e =&gt; Declarations.Algebraic e
        | None =&gt; Declarations.Struct sign
        end in
      Declarations.generic_module_body.with_mod_retroknowledge
        (Declarations.generic_module_body.with_mod_constraints
          (Declarations.generic_module_body.with_mod_expr
            (Declarations.generic_module_body.with_mod_mp res_mtb mp) impl)
          (Univ.ContextSet.add_constraints cst'
            (op_plusplusplus cst
              (Declarations.generic_module_body.mod_constraints res_mtb))))
        (Declarations.ModBodyRK [])
    end.

Definition translate_module
  (env : Environ.env) (mp : Names.module_path) (inl : Entries.inline)
  (function_parameter : Entries.module_entry) : Declarations.module_body :=
  match function_parameter with
  | Entries.MType params ty =&gt;
    let mtb := translate_modtype env mp inl (params, ty) in
    module_body_of_type mp mtb
  | Entries.MExpr params mse oty =&gt;
    let '(sg, alg, reso, cst) :=
      translate_mse_funct env (Some mp) inl mse params in
    let restype := Option.map (fun ty =&gt; ((params, ty), inl)) oty in
    finalize_module env mp (sg, (Some alg), reso, cst) restype
  end.

Fixpoint unfunct {A B : Set} (function_parameter : Declarations.functorize A B)
  {struct function_parameter} : B :=
  match function_parameter with
  | Declarations.NoFunctor me =&gt; me
  | Declarations.MoreFunctor _ _ me =&gt; unfunct me
  end.

Fixpoint forbid_incl_signed_functor
  (env : Environ.env) (function_parameter : Declarations.module_alg_expr)
  {struct env} : unit :=
  match function_parameter with
  | Declarations.MEapply fe _ =&gt; forbid_incl_signed_functor env fe
  | Declarations.MEwith _ _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Declarations.MEident mp1 =&gt;
    let mb := lookup_module mp1 env in
    match
      ((Declarations.generic_module_body.mod_type mb),
        (Declarations.generic_module_body.mod_type_alg mb),
        (Declarations.generic_module_body.mod_expr mb)) with
    | (Declarations.MoreFunctor _ _ _, Some _, _) =&gt;
      error_include_restricted_functor mp1
    | (Declarations.MoreFunctor _ _ _, None, Declarations.Algebraic me) =&gt;
      forbid_incl_signed_functor env (unfunct me)
    | _ =&gt; tt
    end
  end.

Fixpoint translate_mse_inclmod
  (env : Environ.env) (mp : Names.ModPath.t) (inl : Entries.inline)
  (function_parameter : Declarations.module_alg_expr) {struct env}
  : Declarations.module_signature * unit * Mod_subst.delta_resolver *
    Univ.ContextSet.t :=
  match function_parameter with
  | Declarations.MEident mp1 =&gt;
    let mb := strengthen_and_subst_mb (lookup_module mp1 env) mp true in
    let sign :=
      clean_bounded_mod_expr (Declarations.generic_module_body.mod_type mb) in
    (sign, tt, (Declarations.generic_module_body.mod_delta mb),
      Univ.ContextSet.empty)
  | Declarations.MEapply fe arg =&gt;
    let ftrans := translate_mse_inclmod env mp inl fe in
    translate_apply env inl ftrans arg
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          tt)
  | Declarations.MEwith _ _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition translate_mse_incl
  (is_mod : bool) (env : Environ.env) (mp : Names.module_path)
  (inl : Entries.inline) (me : Declarations.module_alg_expr)
  : Declarations.module_signature * unit * Mod_subst.delta_resolver *
    Univ.ContextSet.t :=
  if is_mod then
    let '_ := forbid_incl_signed_functor env me in
    translate_mse_inclmod env mp inl me
  else
    let mtb := translate_modtype env mp inl ([], me) in
    let sign :=
      clean_bounded_mod_expr (Declarations.generic_module_body.mod_type mtb) in
    (sign, tt, (Declarations.generic_module_body.mod_delta mtb),
      (Declarations.generic_module_body.mod_constraints mtb)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="mod_typing.mli">
  <div style="margin: 20px;">
    <h3>Mod_typing_mli</h3>
    <ul>
      <li>OCaml size: 61 lines</li>
      <li>Coq size: 36 lines (-41% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#mod_typing.mli"><code>mod_typing.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Declarations
open Environ
open Entries
open Mod_subst
open Names

(** Main functions for translating module entries *)

(** [translate_module] produces a [module_body] out of a [module_entry].
    In the output fields:
    - [mod_expr] is [Abstract] for a [MType] entry, or [Algebraic] for [MExpr].
    - [mod_type_alg] is [None] only for a [MExpr] without explicit signature.
*)

val translate_module :
  env -&gt; ModPath.t -&gt; inline -&gt; module_entry -&gt; module_body

(** [translate_modtype] produces a [module_type_body] whose [mod_type_alg]
    cannot be [None] (and of course [mod_expr] is [Abstract]). *)

val translate_modtype :
  env -&gt; ModPath.t -&gt; inline -&gt; module_type_entry -&gt; module_type_body

(** Low-level function for translating a module struct entry :
    - We translate to a module when a [ModPath.t] is given,
      otherwise to a module type.
    - The first output is the expanded signature
    - The second output is the algebraic expression, kept mostly for
      the extraction. *)

type 'alg translation =
  module_signature * 'alg * delta_resolver * Univ.ContextSet.t

val translate_mse :
  env -&gt; ModPath.t option -&gt; inline -&gt; module_struct_entry -&gt;
    module_alg_expr translation

(** From an already-translated (or interactive) implementation and
    an (optional) signature entry, produces a final [module_body] *)

val finalize_module :
  env -&gt; ModPath.t -&gt; (module_expression option) translation -&gt;
  (module_type_entry * inline) option -&gt;
  module_body

(** [translate_mse_incl] translate the mse of a module or
    module type given to an Include *)

val translate_mse_incl :
  bool -&gt; env -&gt; ModPath.t -&gt; inline -&gt; module_struct_entry -&gt;
    unit translation
</pre>
  </div>
  <div class="col-md-6">
    <a href="#mod_typing.mli"><code>Mod_typing_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter translate_module :
  Environ.env -&gt; Names.ModPath.t -&gt; Entries.inline -&gt; Entries.module_entry -&gt;
  Declarations.module_body.

Parameter translate_modtype :
  Environ.env -&gt; Names.ModPath.t -&gt; Entries.inline -&gt;
  Entries.module_type_entry -&gt; Declarations.module_type_body.

Definition translation (alg : Set) :=
  Declarations.module_signature * alg * Mod_subst.delta_resolver *
    Univ.ContextSet.t.

Parameter translate_mse :
  Environ.env -&gt; option Names.ModPath.t -&gt; Entries.inline -&gt;
  Entries.module_struct_entry -&gt; translation Declarations.module_alg_expr.

Parameter finalize_module :
  Environ.env -&gt; Names.ModPath.t -&gt;
  translation (option Declarations.module_expression) -&gt;
  option (Entries.module_type_entry * Entries.inline) -&gt;
  Declarations.module_body.

Parameter translate_mse_incl :
  bool -&gt; Environ.env -&gt; Names.ModPath.t -&gt; Entries.inline -&gt;
  Entries.module_struct_entry -&gt; translation unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="modops.ml">
  <div style="margin: 20px;">
    <h3>Modops</h3>
    <ul>
      <li>OCaml size: 633 lines</li>
      <li>Coq size: 1005 lines (+58% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#modops.ml"><code>modops.ml</code></a>&nbsp;<span class="label label-warning">20 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)
(* Inlining and more liberal use of modules and module types by Claudio
   Sacerdoti, Nov 2004 *)
(* New structure-based model of modules and miscellaneous bug fixes by
   Ãlie Soubiran, from Feb 2008 *)

(* This file provides with various operations on modules and module types *)

open Util
open Names
open Constr
open Declarations
open Declareops
open Environ
open Entries
open Mod_subst

(** {6 Errors } *)

type signature_mismatch_error =
  | InductiveFieldExpected of mutual_inductive_body
  | DefinitionFieldExpected
  | ModuleFieldExpected
  | ModuleTypeFieldExpected
  | NotConvertibleInductiveField of Id.t
  | NotConvertibleConstructorField of Id.t
  | NotConvertibleBodyField
  | NotConvertibleTypeField of env * types * types
  | CumulativeStatusExpected of bool
  | PolymorphicStatusExpected of bool
  | NotSameConstructorNamesField
  | NotSameInductiveNameInBlockField
  | FiniteInductiveFieldExpected of bool
  | InductiveNumbersFieldExpected of int
  | InductiveParamsNumberField of int
  | RecordFieldExpected of bool
  | RecordProjectionsExpected of Name.t list
  | NotEqualInductiveAliases
  | IncompatibleUniverses of Univ.univ_inconsistency
  | IncompatiblePolymorphism of env * types * types
  | IncompatibleConstraints of { got : Univ.AUContext.t; expect : Univ.AUContext.t }
  | IncompatibleVariance

type module_typing_error =
  | SignatureMismatch of
      Label.t * structure_field_body * signature_mismatch_error
  | LabelAlreadyDeclared of Label.t
  | ApplicationToNotPath of module_struct_entry
  | NotAFunctor
  | IsAFunctor
  | IncompatibleModuleTypes of module_type_body * module_type_body
  | NotEqualModulePaths of ModPath.t * ModPath.t
  | NoSuchLabel of Label.t
  | IncompatibleLabels of Label.t * Label.t
  | NotAModule of string
  | NotAModuleType of string
  | NotAConstant of Label.t
  | IncorrectWithConstraint of Label.t
  | GenerativeModuleExpected of Label.t
  | LabelMissing of Label.t * string
  | IncludeRestrictedFunctor of ModPath.t

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception ModuleTypingError of module_typing_error</abbr>

let error_existing_label l =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (LabelAlreadyDeclared l))</abbr>

let error_not_a_functor () =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError NotAFunctor)</abbr>

let error_is_a_functor () =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError IsAFunctor)</abbr>

let error_incompatible_modtypes mexpr1 mexpr2 =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (IncompatibleModuleTypes (mexpr1,mexpr2)))</abbr>

let error_not_equal_modpaths mp1 mp2 =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (NotEqualModulePaths (mp1,mp2)))</abbr>

let error_signature_mismatch l spec why =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (SignatureMismatch (l,spec,why)))</abbr>

let error_no_such_label l =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (NoSuchLabel l))</abbr>

let error_incompatible_labels l l' =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (IncompatibleLabels (l,l')))</abbr>

let error_not_a_module s =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (NotAModule s))</abbr>

let error_not_a_constant l =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (NotAConstant l))</abbr>

let error_incorrect_with_constraint l =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (IncorrectWithConstraint l))</abbr>

let error_generative_module_expected l =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (GenerativeModuleExpected l))</abbr>

let error_no_such_label_sub l l1 =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (LabelMissing (l,l1)))</abbr>

let error_include_restricted_functor mp =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(ModuleTypingError (IncludeRestrictedFunctor mp))</abbr>

(** {6 Operations on functors } *)

let is_functor = function
  |NoFunctor _ -&gt; false
  |MoreFunctor _ -&gt; true

let destr_functor = function
  |NoFunctor _ -&gt; error_not_a_functor ()
  |MoreFunctor (mbid,ty,x) -&gt; (mbid,ty,x)

let destr_nofunctor = function
  |NoFunctor a -&gt; a
  |MoreFunctor _ -&gt; error_is_a_functor ()

let rec functor_smart_map fty f0 funct = match funct with
  |MoreFunctor (mbid,ty,e) -&gt;
    let ty' = fty ty in
    let e' = functor_smart_map fty f0 e in
    if ty==ty' &amp;&amp; e==e' then funct else MoreFunctor (mbid,ty',e')
  |NoFunctor a -&gt;
    let a' = f0 a in if a==a' then funct else NoFunctor a'

let rec functor_iter fty f0 = function
  |MoreFunctor (_mbid,ty,e) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">fty ty; functor_iter fty f0 e</abbr>
  |NoFunctor a -&gt; f0 a

(** {6 Misc operations } *)

let module_type_of_module mb =
  { mb with mod_expr = (); mod_type_alg = None;
    mod_retroknowledge = ModTypeRK; }

let module_body_of_type mp mtb =
  { mtb with mod_expr = Abstract; mod_mp = mp;
      mod_retroknowledge = ModBodyRK []; }

let check_modpath_equiv env mp1 mp2 =
  if ModPath.equal mp1 mp2 then ()
  else
    let mp1' = mp_of_delta (lookup_module mp1 env).mod_delta mp1 in
    let mp2' = mp_of_delta (lookup_module mp2 env).mod_delta mp2 in
    if ModPath.equal mp1' mp2' then ()
    else error_not_equal_modpaths mp1 mp2

let implem_smartmap fs fa impl = match impl with
  |Struct e -&gt; let e' = fs e in if e==e' then impl else Struct e'
  |Algebraic a -&gt; let a' = fa a in if a==a' then impl else Algebraic a'
  |Abstract|FullStruct -&gt; impl

let implem_iter fs fa impl = match impl with
  |Struct e -&gt; fs e
  |Algebraic a -&gt; fa a
  |Abstract|FullStruct -&gt; ()

(** {6 Substitutions of modular structures } *)

let id_delta x _y = x

let subst_with_body sub = function
  |WithMod(id,mp) as orig -&gt;
    let mp' = subst_mp sub mp in
    if mp==mp' then orig else WithMod(id,mp')
  |WithDef(id,(c,ctx)) as orig -&gt;
    let c' = subst_mps sub c in
    if c==c' then orig else WithDef(id,(c',ctx))

let rec subst_structure sub do_delta sign =
  let subst_body ((l,body) as orig) = match body with
    |SFBconst cb -&gt;
      let cb' = subst_const_body sub cb in
      if cb==cb' then orig else (l,SFBconst cb')
    |SFBmind mib -&gt;
      let mib' = subst_mind_body sub mib in
      if mib==mib' then orig else (l,SFBmind mib')
    |SFBmodule mb -&gt;
      let mb' = subst_module sub do_delta mb in
      if mb==mb' then orig else (l,SFBmodule mb')
    |SFBmodtype mtb -&gt;
      let mtb' = subst_modtype sub do_delta mtb in
      if mtb==mtb' then orig else (l,SFBmodtype mtb')
  in
  List.Smart.map subst_body sign

and subst_retro : type a. Mod_subst.substitution -&gt; a module_retroknowledge -&gt; a module_retroknowledge =
  fun subst retro -&gt;
    match retro with
    | ModTypeRK as r -&gt; r
    | ModBodyRK l as r -&gt;
      let l' = List.Smart.map (subst_retro_action subst) l in
      if l == l' then r else ModBodyRK l

and subst_body : 'a. _ -&gt; _ -&gt; (_ -&gt; 'a -&gt; 'a) -&gt; _ -&gt; 'a generic_module_body -&gt; 'a generic_module_body =
  fun is_mod sub subst_impl do_delta mb -&gt;
    let { mod_mp=mp; mod_expr=me; mod_type=ty; mod_type_alg=aty;
          mod_retroknowledge=retro; _ } = mb in
  let mp' = subst_mp sub mp in
  let sub =
    if ModPath.equal mp mp' then sub
    else if is_mod &amp;&amp; not (is_functor ty) then sub
    else add_mp mp mp' empty_delta_resolver sub
  in
  let ty' = subst_signature sub do_delta ty in
  let me' = subst_impl sub me in
  let aty' = Option.Smart.map (subst_expression sub id_delta) aty in
  let retro' = subst_retro sub retro in
  let delta' = do_delta mb.mod_delta sub in
  if mp==mp' &amp;&amp; me==me' &amp;&amp; ty==ty' &amp;&amp; aty==aty'
     &amp;&amp; retro==retro' &amp;&amp; delta'==mb.mod_delta
  then mb
  else
    { mb with
      mod_mp = mp';
      mod_expr = me';
      mod_type = ty';
      mod_type_alg = aty';
      mod_retroknowledge = retro';
      mod_delta = delta';
    }

and subst_module sub do_delta mb =
  subst_body true sub subst_impl do_delta mb

and subst_impl sub me =
  implem_smartmap
    (subst_signature sub id_delta) (subst_expression sub id_delta) me

and subst_modtype sub do_delta mtb = subst_body false sub (fun _ () -&gt; ()) do_delta mtb

and subst_expr sub do_delta seb = match seb with
  |MEident mp -&gt;
    let mp' = subst_mp sub mp in
    if mp==mp' then seb else MEident mp'
  |MEapply (meb1,mp2) -&gt;
    let meb1' = subst_expr sub do_delta meb1 in
    let mp2' = subst_mp sub mp2 in
    if meb1==meb1' &amp;&amp; mp2==mp2' then seb else MEapply(meb1',mp2')
  |MEwith (meb,wdb) -&gt;
    let meb' = subst_expr sub do_delta meb in
    let wdb' = subst_with_body sub wdb in
    if meb==meb' &amp;&amp; wdb==wdb' then seb else MEwith(meb',wdb')

and subst_expression sub do_delta =
  functor_smart_map
    (subst_modtype sub do_delta)
    (subst_expr sub do_delta)

and subst_signature sub do_delta =
  functor_smart_map
    (subst_modtype sub do_delta)
    (subst_structure sub do_delta)

let do_delta_dom reso sub = subst_dom_delta_resolver sub reso
let do_delta_codom reso sub = subst_codom_delta_resolver sub reso
let do_delta_dom_codom reso sub = subst_dom_codom_delta_resolver sub reso

let subst_signature subst = subst_signature subst do_delta_codom
let subst_structure subst = subst_structure subst do_delta_codom

(** {6 Adding a module in the environment } *)

let add_retroknowledge r env =
  match r with
  | ModBodyRK l -&gt; List.fold_left Primred.add_retroknowledge env l

let rec add_structure mp sign resolver linkinfo env =
  let add_one env (l,elem) = match elem with
    |SFBconst cb -&gt;
      let c = constant_of_delta_kn resolver (KerName.make mp l) in
      Environ.add_constant_key c cb linkinfo env
    |SFBmind mib -&gt;
      let mind = mind_of_delta_kn resolver (KerName.make mp l) in
      let mib =
        if mib.mind_private != None then
          { mib with mind_private = Some true }
        else mib
      in
      Environ.add_mind_key mind (mib,ref linkinfo) env
    |SFBmodule mb -&gt; add_module mb linkinfo env (* adds components as well *)
    |SFBmodtype mtb -&gt; Environ.add_modtype mtb env
  in
  List.fold_left add_one env sign

and add_module mb linkinfo env =
  let mp = mb.mod_mp in
  let env = Environ.shallow_add_module mb env in
  match mb.mod_type with
  |NoFunctor struc -&gt;
    add_retroknowledge mb.mod_retroknowledge
      (add_structure mp struc mb.mod_delta linkinfo env)
  |MoreFunctor _ -&gt; env

let add_linked_module mb linkinfo env =
  add_module mb linkinfo env

let add_structure mp sign resolver env =
  add_structure mp sign resolver no_link_info env

let add_module mb env =
  add_module mb no_link_info env

let add_module_type mp mtb env =
  add_module (module_body_of_type mp mtb) env

(** {6 Strengtening } *)

let strengthen_const mp_from l cb resolver =
  match cb.const_body with
  |Def _ -&gt; cb
  |_ -&gt;
    let kn = KerName.make mp_from l in
    let con = constant_of_delta_kn resolver kn in
    let u = Univ.make_abstract_instance (Declareops.constant_polymorphic_context cb) in
      { cb with
        const_body = Def (Mod_subst.from_val (mkConstU (con,u)));
        const_private_poly_univs = None;
        const_body_code = Some (Cemitcodes.from_val (Cbytegen.compile_alias con)) }

let rec strengthen_mod mp_from mp_to mb =
  if mp_in_delta mb.mod_mp mb.mod_delta then mb
  else match mb.mod_type with
  |NoFunctor struc -&gt;
    let reso,struc' = strengthen_sig mp_from struc mp_to mb.mod_delta in
    { mb with
      mod_expr = Algebraic (NoFunctor (MEident mp_to));
      mod_type = NoFunctor struc';
      mod_delta =
        add_mp_delta_resolver mp_from mp_to
          (add_delta_resolver mb.mod_delta reso) }
  |MoreFunctor _ -&gt; mb

and strengthen_sig mp_from struc mp_to reso = match struc with
  |[] -&gt; empty_delta_resolver,[]
  |(l,SFBconst cb) :: rest -&gt;
    let item' = l,SFBconst (strengthen_const mp_from l cb reso) in
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    reso',item'::rest'
  |(_,SFBmind _ as item):: rest -&gt;
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    reso',item::rest'
  |(l,SFBmodule mb) :: rest -&gt;
    let mp_from' = MPdot (mp_from,l) in
    let mp_to' = MPdot(mp_to,l) in
    let mb' = strengthen_mod mp_from' mp_to' mb in
    let item' = l,SFBmodule mb' in
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    add_delta_resolver reso' mb.mod_delta, item':: rest'
  |(_l,SFBmodtype _mty as item) :: rest -&gt;
    let reso',rest' = strengthen_sig mp_from rest mp_to reso in
    reso',item::rest'

let strengthen mtb mp =
  (* Has mtb already been strengthened ? *)
  if mp_in_delta mtb.mod_mp mtb.mod_delta then mtb
  else match mtb.mod_type with
  |NoFunctor struc -&gt;
    let reso',struc' = strengthen_sig mtb.mod_mp struc mp mtb.mod_delta in
    { mtb with
      mod_type = NoFunctor struc';
      mod_delta =
        add_delta_resolver mtb.mod_delta
          (add_mp_delta_resolver mtb.mod_mp mp reso') }
  |MoreFunctor _ -&gt; mtb

let inline_delta_resolver env inl mp mbid mtb delta =
  let constants = inline_of_delta inl mtb.mod_delta in
  let rec make_inline delta = function
    | [] -&gt; delta
    | (lev,kn)::r -&gt;
        let kn = replace_mp_in_kn (MPbound mbid) mp kn in
        let con = constant_of_delta_kn delta kn in
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
          let constant = lookup_constant con env in
          let l = make_inline delta r in
          match constant.const_body with
            | Undef _ | OpaqueDef _ | Primitive _ -&gt; l
            | Def body -&gt;
              let constr = Mod_subst.force_constr body in
              let ctx = Declareops.constant_polymorphic_context constant in
              let constr = Univ.{univ_abstracted_value=constr; univ_abstracted_binder=ctx} in
              add_inline_delta_resolver kn (lev, Some constr) l
        with Not_found -&gt;
          error_no_such_label_sub (Constant.label con)
            (ModPath.to_string (Constant.modpath con))</abbr>
  in
  make_inline delta constants

let rec strengthen_and_subst_mod mb subst mp_from mp_to =
  match mb.mod_type with
  |NoFunctor struc -&gt;
    let mb_is_an_alias = mp_in_delta mb.mod_mp mb.mod_delta in
    if mb_is_an_alias then subst_module subst do_delta_dom mb
    else
      let reso',struc' =
        strengthen_and_subst_struct struc subst
          mp_from mp_to false false mb.mod_delta
      in
      { mb with
        mod_mp = mp_to;
        mod_expr = Algebraic (NoFunctor (MEident mp_from));
        mod_type = NoFunctor struc';
        mod_delta = add_mp_delta_resolver mp_to mp_from reso' }
  |MoreFunctor _ -&gt;
    let subst = add_mp mb.mod_mp mp_to empty_delta_resolver subst in
    subst_module subst do_delta_dom mb

and strengthen_and_subst_struct str subst mp_from mp_to alias incl reso =
  match str with
    | [] -&gt; empty_delta_resolver,[]
    | (l,SFBconst cb) as item :: rest -&gt;
        let cb' = subst_const_body subst cb in
        let cb' =
          if alias then cb'
          else strengthen_const mp_from l cb' reso
        in
        let item' = if cb' == cb then item else (l, SFBconst cb') in
        let reso',rest' =
          strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
        if incl then
          (* If we are performing an inclusion we need to add
             the fact that the constant mp_to.l is \Delta-equivalent
             to reso(mp_from.l) *)
          let kn_from = KerName.make mp_from l in
          let kn_to = KerName.make mp_to l in
          let old_name = kn_of_delta reso kn_from in
          add_kn_delta_resolver kn_to old_name reso', str'
        else
          (* In this case the fact that the constant mp_to.l is
             \Delta-equivalent to resolver(mp_from.l) is already known
             because reso' contains mp_to maps to reso(mp_from) *)
          reso', str'
    | (l,SFBmind mib) as item :: rest -&gt;
        let mib' = subst_mind_body subst mib in
        let item' = if mib' == mib then item else (l, SFBmind mib') in
        let reso',rest' =
          strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
        (* Same as constant *)
        if incl then
          let kn_from = KerName.make mp_from l in
          let kn_to = KerName.make mp_to l in
          let old_name = kn_of_delta reso kn_from in
          add_kn_delta_resolver kn_to old_name reso', str'
        else
          reso', str'
    | (l,SFBmodule mb) as item :: rest -&gt;
        let mp_from' = MPdot (mp_from,l) in
        let mp_to' = MPdot (mp_to,l) in
        let mb' = if alias then
          subst_module subst do_delta_dom mb
        else
          strengthen_and_subst_mod mb subst mp_from' mp_to'
        in
        let item' = if mb' == mb then item else (l, SFBmodule mb') in
        let reso',rest' =
          strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
        (* if mb is a functor we should not derive new equivalences
           on names, hence we add the fact that the functor can only
           be equivalent to itself. If we adopt an applicative
           semantic for functor this should be changed.*)
        if is_functor mb'.mod_type then
          add_mp_delta_resolver mp_to' mp_to' reso', str'
        else
          add_delta_resolver reso' mb'.mod_delta, str'
    | (l,SFBmodtype mty) as item :: rest -&gt;
        let mp_from' = MPdot (mp_from,l) in
        let mp_to' = MPdot(mp_to,l) in
        let subst' = add_mp mp_from' mp_to' empty_delta_resolver subst in
        let mty' = subst_modtype subst'
          (fun resolver _ -&gt; subst_dom_codom_delta_resolver subst' resolver)
          mty
        in
        let item' = if mty' == mty then item else (l, SFBmodtype mty') in
        let reso',rest' =
          strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso
        in
        let str' =
          if rest' == rest &amp;&amp; item' == item then str
          else item' :: rest'
        in
        add_mp_delta_resolver mp_to' mp_to' reso', str'


(** Let P be a module path when we write:
     &quot;Module M:=P.&quot; or &quot;Module M. Include P. End M.&quot;
    We need to perform two operations to compute the body of M.
    - The first one is applying the substitution {P &lt;- M} on the type of P
    - The second one is strengthening. *)

let strengthen_and_subst_mb mb mp include_b = match mb.mod_type with
  |NoFunctor struc -&gt;
    let mb_is_an_alias = mp_in_delta mb.mod_mp mb.mod_delta in
    (* if mb.mod_mp is an alias then the strengthening is useless
       (i.e. it is already done)*)
    let mp_alias = mp_of_delta mb.mod_delta mb.mod_mp in
    let subst_resolver = map_mp mb.mod_mp mp empty_delta_resolver in
    let new_resolver =
      add_mp_delta_resolver mp mp_alias
        (subst_dom_delta_resolver subst_resolver mb.mod_delta)
    in
    let subst = map_mp mb.mod_mp mp new_resolver in
    let reso',struc' =
      strengthen_and_subst_struct struc subst
        mb.mod_mp mp mb_is_an_alias include_b mb.mod_delta
    in
    { mb with
      mod_mp = mp;
      mod_type = NoFunctor struc';
      mod_expr = Algebraic (NoFunctor (MEident mb.mod_mp));
      mod_delta =
        if include_b then reso'
        else add_delta_resolver new_resolver reso' }
  |MoreFunctor _ -&gt;
    let subst = map_mp mb.mod_mp mp empty_delta_resolver in
    subst_module subst do_delta_dom_codom mb

let subst_modtype_and_resolver mtb mp =
  let subst = map_mp mtb.mod_mp mp empty_delta_resolver in
  let new_delta = subst_dom_codom_delta_resolver subst mtb.mod_delta in
  let full_subst = map_mp mtb.mod_mp mp new_delta in
  subst_modtype full_subst do_delta_dom_codom mtb

(** {6 Cleaning a module expression from bounded parts }

     For instance:
       functor(X:T)-&gt;struct module M:=X end)
     becomes:
       functor(X:T)-&gt;struct module M:=&lt;content of T&gt; end)
*)

let rec is_bounded_expr l = function
  | MEident (MPbound mbid) -&gt; MBIset.mem mbid l
  | MEapply (fexpr,mp) -&gt;
      is_bounded_expr l (MEident mp) || is_bounded_expr l fexpr
  | _ -&gt; false

let rec clean_module_body l mb =
  let impl, typ = mb.mod_expr, mb.mod_type in
  let typ' = clean_signature l typ in
  let impl' = match impl with
    | Algebraic (NoFunctor m) when is_bounded_expr l m -&gt; FullStruct
    | _ -&gt; implem_smartmap (clean_signature l) (clean_expression l) impl
  in
  if typ==typ' &amp;&amp; impl==impl' then mb
  else { mb with mod_type=typ'; mod_expr=impl' }

and clean_module_type l mb =
  let (), typ = mb.mod_expr, mb.mod_type in
  let typ' = clean_signature l typ in
  if typ==typ' then mb
  else { mb with mod_type=typ' }

and clean_field l field = match field with
  |(lab,SFBmodule mb) -&gt;
    let mb' = clean_module_body l mb in
    if mb==mb' then field else (lab,SFBmodule mb')
  |_ -&gt; field

and clean_structure l = List.Smart.map (clean_field l)

and clean_signature l =
  functor_smart_map (clean_module_type l) (clean_structure l)

and clean_expression l =
  functor_smart_map (clean_module_type l) (fun me -&gt; me)

let rec collect_mbid l sign =  match sign with
  |MoreFunctor (mbid,ty,m) -&gt;
    let m' = collect_mbid (MBIset.add mbid l) m in
    if m==m' then sign else MoreFunctor (mbid,ty,m')
  |NoFunctor struc -&gt;
    let struc' = clean_structure l struc in
    if struc==struc' then sign else NoFunctor struc'

let clean_bounded_mod_expr sign =
  if is_functor sign then collect_mbid MBIset.empty sign else sign

(** {6 Stm machinery } *)
let join_constant_body except otab cb =
  match cb.const_body with
  | OpaqueDef o -&gt;
      (match Opaqueproof.uuid_opaque otab o with
      | Some uuid when not(Future.UUIDSet.mem uuid except) -&gt;
          Opaqueproof.join_opaque otab o
      | _ -&gt; ())
  | _ -&gt; ()

let join_structure except otab s =
  <abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">let rec join_module : 'a. 'a generic_module_body -&gt; unit = fun mb -&gt;
    </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Option.iter join_expression mb.mod_type_alg;
    join_signature mb.mod_type</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
  and join_field (_l,body) = match body with
    |SFBconst sb -&gt; join_constant_body except otab sb
    |SFBmind _ -&gt; ()
    |SFBmodule m -&gt;
      </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">implem_iter join_signature join_expression m.mod_expr;
      join_module m</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
    |SFBmodtype m -&gt; join_module m
  and join_structure struc = List.iter join_field struc
  and join_signature sign =
    functor_iter join_module join_structure sign
  and join_expression me = functor_iter join_module (fun _ -&gt; ()) me in
  join_structure s</abbr>

</pre>
  </div>
  <div class="col-md-6">
    <a href="#modops.ml"><code>Modops.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Declareops.

Import Environ.

Import Entries.

Import Mod_subst.

Module signature_mismatch_error.
  Module IncompatibleConstraints.
    Record record {got expect : Set} := {
      got : got;
      expect : expect }.
    Arguments record : clear implicits.
  End IncompatibleConstraints.
  Definition IncompatibleConstraints := IncompatibleConstraints.record.
End signature_mismatch_error.

Inductive signature_mismatch_error : Set :=
| InductiveFieldExpected :
  Declarations.mutual_inductive_body -&gt; signature_mismatch_error
| DefinitionFieldExpected : signature_mismatch_error
| ModuleFieldExpected : signature_mismatch_error
| ModuleTypeFieldExpected : signature_mismatch_error
| NotConvertibleInductiveField : Names.Id.t -&gt; signature_mismatch_error
| NotConvertibleConstructorField : Names.Id.t -&gt; signature_mismatch_error
| NotConvertibleBodyField : signature_mismatch_error
| NotConvertibleTypeField :
  Environ.env -&gt; Constr.types -&gt; Constr.types -&gt; signature_mismatch_error
| CumulativeStatusExpected : bool -&gt; signature_mismatch_error
| PolymorphicStatusExpected : bool -&gt; signature_mismatch_error
| NotSameConstructorNamesField : signature_mismatch_error
| NotSameInductiveNameInBlockField : signature_mismatch_error
| FiniteInductiveFieldExpected : bool -&gt; signature_mismatch_error
| InductiveNumbersFieldExpected : Z -&gt; signature_mismatch_error
| InductiveParamsNumberField : Z -&gt; signature_mismatch_error
| RecordFieldExpected : bool -&gt; signature_mismatch_error
| RecordProjectionsExpected : list Names.Name.t -&gt; signature_mismatch_error
| NotEqualInductiveAliases : signature_mismatch_error
| IncompatibleUniverses : Univ.univ_inconsistency -&gt; signature_mismatch_error
| IncompatiblePolymorphism :
  Environ.env -&gt; Constr.types -&gt; Constr.types -&gt; signature_mismatch_error
| IncompatibleConstraints :
  signature_mismatch_error.IncompatibleConstraints Univ.AUContext.t
    Univ.AUContext.t -&gt; signature_mismatch_error
| IncompatibleVariance : signature_mismatch_error.

Inductive module_typing_error : Set :=
| SignatureMismatch :
  Names.Label.t -&gt; Declarations.structure_field_body -&gt;
  signature_mismatch_error -&gt; module_typing_error
| LabelAlreadyDeclared : Names.Label.t -&gt; module_typing_error
| ApplicationToNotPath : Entries.module_struct_entry -&gt; module_typing_error
| NotAFunctor : module_typing_error
| IsAFunctor : module_typing_error
| IncompatibleModuleTypes :
  Declarations.module_type_body -&gt; Declarations.module_type_body -&gt;
  module_typing_error
| NotEqualModulePaths :
  Names.ModPath.t -&gt; Names.ModPath.t -&gt; module_typing_error
| NoSuchLabel : Names.Label.t -&gt; module_typing_error
| IncompatibleLabels : Names.Label.t -&gt; Names.Label.t -&gt; module_typing_error
| NotAModule : string -&gt; module_typing_error
| NotAModuleType : string -&gt; module_typing_error
| NotAConstant : Names.Label.t -&gt; module_typing_error
| IncorrectWithConstraint : Names.Label.t -&gt; module_typing_error
| GenerativeModuleExpected : Names.Label.t -&gt; module_typing_error
| LabelMissing : Names.Label.t -&gt; string -&gt; module_typing_error
| IncludeRestrictedFunctor : Names.ModPath.t -&gt; module_typing_error.

(* ❌ The definition of exceptions is not handled. *)
(* exception ModuleTypingError *)

Definition error_existing_label {A : Set} (l : Names.Label.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_not_a_functor {A : Set} (function_parameter : unit) : A :=
  let '_ := function_parameter in
  Stdlib.raise extensible_type_value.

Definition error_is_a_functor {A : Set} (function_parameter : unit) : A :=
  let '_ := function_parameter in
  Stdlib.raise extensible_type_value.

Definition error_incompatible_modtypes {A : Set}
  (mexpr1 : Declarations.module_type_body)
  (mexpr2 : Declarations.module_type_body) : A :=
  Stdlib.raise extensible_type_value.

Definition error_not_equal_modpaths {A : Set}
  (mp1 : Names.ModPath.t) (mp2 : Names.ModPath.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_signature_mismatch {A : Set}
  (l : Names.Label.t) (spec : Declarations.structure_field_body)
  (why : signature_mismatch_error) : A := Stdlib.raise extensible_type_value.

Definition error_no_such_label {A : Set} (l : Names.Label.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_incompatible_labels {A : Set}
  (l : Names.Label.t) (l' : Names.Label.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_not_a_module {A : Set} (s : string) : A :=
  Stdlib.raise extensible_type_value.

Definition error_not_a_constant {A : Set} (l : Names.Label.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_incorrect_with_constraint {A : Set} (l : Names.Label.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_generative_module_expected {A : Set} (l : Names.Label.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_no_such_label_sub {A : Set} (l : Names.Label.t) (l1 : string)
  : A := Stdlib.raise extensible_type_value.

Definition error_include_restricted_functor {A : Set} (mp : Names.ModPath.t)
  : A := Stdlib.raise extensible_type_value.

Definition is_functor {A B : Set}
  (function_parameter : Declarations.functorize A B) : bool :=
  match function_parameter with
  | Declarations.NoFunctor _ =&gt; false
  | Declarations.MoreFunctor _ _ _ =&gt; true
  end.

Definition destr_functor {A B : Set}
  (function_parameter : Declarations.functorize A B)
  : Names.MBId.t * A * Declarations.functorize A B :=
  match function_parameter with
  | Declarations.NoFunctor _ =&gt; error_not_a_functor tt
  | Declarations.MoreFunctor mbid ty x =&gt; (mbid, ty, x)
  end.

Definition destr_nofunctor {A B : Set}
  (function_parameter : Declarations.functorize A B) : B :=
  match function_parameter with
  | Declarations.NoFunctor a =&gt; a
  | Declarations.MoreFunctor _ _ _ =&gt; error_is_a_functor tt
  end.

Fixpoint functor_smart_map {A B : Set}
  (fty : A -&gt; A) (f0 : B -&gt; B) (funct : Declarations.functorize A B)
  {struct fty} : Declarations.functorize A B :=
  match funct with
  | Declarations.MoreFunctor mbid ty e =&gt;
    let ty' := fty ty in
    let e' := functor_smart_map fty f0 e in
    if andb (Stdlib.op_eqeq ty ty') (Stdlib.op_eqeq e e') then
      funct
    else
      Declarations.MoreFunctor mbid ty' e'
  | Declarations.NoFunctor a =&gt;
    let a' := f0 a in
    if Stdlib.op_eqeq a a' then
      funct
    else
      Declarations.NoFunctor a'
  end.

Fixpoint functor_iter {A B C D : Set}
  (fty : A -&gt; B) (f0 : C -&gt; D)
  (function_parameter : Declarations.functorize A C) {struct fty} : D :=
  match function_parameter with
  | Declarations.MoreFunctor _mbid ty e =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    functor_iter fty f0 e
  | Declarations.NoFunctor a =&gt; f0 a
  end.

Definition module_type_of_module {A : Set}
  (mb : Declarations.generic_module_body A)
  : Declarations.generic_module_body unit :=
  Declarations.generic_module_body.with_mod_retroknowledge
    (Declarations.generic_module_body.with_mod_type_alg
      (Declarations.generic_module_body.with_mod_expr mb tt) None)
    Declarations.ModTypeRK.

Definition module_body_of_type {A : Set}
  (mp : Names.ModPath.t) (mtb : Declarations.generic_module_body A)
  : Declarations.generic_module_body Declarations.module_implementation :=
  Declarations.generic_module_body.with_mod_retroknowledge
    (Declarations.generic_module_body.with_mod_expr
      (Declarations.generic_module_body.with_mod_mp mtb mp)
      Declarations.Abstract) (Declarations.ModBodyRK []).

Definition check_modpath_equiv
  (env : Environ.env) (mp1 : Names.ModPath.t) (mp2 : Names.ModPath.t) : unit :=
  if ModPath.equal mp1 mp2 then
    tt
  else
    let mp1' :=
      mp_of_delta
        (Declarations.generic_module_body.mod_delta (lookup_module mp1 env)) mp1
      in
    let mp2' :=
      mp_of_delta
        (Declarations.generic_module_body.mod_delta (lookup_module mp2 env)) mp2
      in
    if ModPath.equal mp1' mp2' then
      tt
    else
      error_not_equal_modpaths mp1 mp2.

Definition implem_smartmap
  (fs : Declarations.module_signature -&gt; Declarations.module_signature)
  (fa : Declarations.module_expression -&gt; Declarations.module_expression)
  (impl : Declarations.module_implementation)
  : Declarations.module_implementation :=
  match impl with
  | Declarations.Struct e =&gt;
    let e' := fs e in
    if Stdlib.op_eqeq e e' then
      impl
    else
      Declarations.Struct e'
  | Declarations.Algebraic a =&gt;
    let a' := fa a in
    if Stdlib.op_eqeq a a' then
      impl
    else
      Declarations.Algebraic a'
  | Declarations.Abstract | Declarations.FullStruct =&gt; impl
  end.

Definition implem_iter
  (fs : Declarations.module_signature -&gt; unit)
  (fa : Declarations.module_expression -&gt; unit)
  (impl : Declarations.module_implementation) : unit :=
  match impl with
  | Declarations.Struct e =&gt; fs e
  | Declarations.Algebraic a =&gt; fa a
  | Declarations.Abstract | Declarations.FullStruct =&gt; tt
  end.

Definition id_delta {A B : Set} (x : A) (_y : B) : A := x.

Definition subst_with_body
  (sub : Mod_subst.substitution)
  (function_parameter : Declarations.with_declaration)
  : Declarations.with_declaration :=
  match function_parameter with
  | (Declarations.WithMod id mp) as orig =&gt;
    let mp' := subst_mp sub mp in
    if Stdlib.op_eqeq mp mp' then
      orig
    else
      Declarations.WithMod id mp'
  | (Declarations.WithDef id (c, ctx)) as orig =&gt;
    let c' := subst_mps sub c in
    if Stdlib.op_eqeq c c' then
      orig
    else
      Declarations.WithDef id (c', ctx)
  end.

Fixpoint subst_structure
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt; Mod_subst.substitution -&gt;
    Mod_subst.delta_resolver) (sign : Declarations.structure_body) {struct sub}
  : Declarations.structure_body :=
  let subst_body {A : Set}
    (function_parameter : A * Declarations.structure_field_body)
    : A * Declarations.structure_field_body :=
    let '(l, body) as orig := function_parameter in
    match body with
    | Declarations.SFBconst cb =&gt;
      let cb' := subst_const_body sub cb in
      if Stdlib.op_eqeq cb cb' then
        orig
      else
        (l, (Declarations.SFBconst cb'))
    | Declarations.SFBmind mib =&gt;
      let mib' := subst_mind_body sub mib in
      if Stdlib.op_eqeq mib mib' then
        orig
      else
        (l, (Declarations.SFBmind mib'))
    | Declarations.SFBmodule mb =&gt;
      let mb' := subst_module sub do_delta mb in
      if Stdlib.op_eqeq mb mb' then
        orig
      else
        (l, (Declarations.SFBmodule mb'))
    | Declarations.SFBmodtype mtb =&gt;
      let mtb' := subst_modtype sub do_delta mtb in
      if Stdlib.op_eqeq mtb mtb' then
        orig
      else
        (l, (Declarations.SFBmodtype mtb'))
    end in
  List.Smart.map subst_body sign

with subst_retro {a : Set}
  (subst : Mod_subst.substitution)
  (retro : Declarations.module_retroknowledge a) {struct subst}
  : Declarations.module_retroknowledge a :=
  match retro with
  | Declarations.ModTypeRK as r =&gt; r
  | (Declarations.ModBodyRK l) as r =&gt;
    let l' := List.Smart.map (subst_retro_action subst) l in
    if Stdlib.op_eqeq l l' then
      r
    else
      Declarations.ModBodyRK l
  end

with subst_body {a : Set}
  (is_mod : bool) (sub : Mod_subst.substitution)
  (subst_impl : Mod_subst.substitution -&gt; a -&gt; a)
  (do_delta :
    Mod_subst.delta_resolver -&gt; Mod_subst.substitution -&gt;
    Mod_subst.delta_resolver) (mb : Declarations.generic_module_body a)
  {struct is_mod} : Declarations.generic_module_body a :=
  let '{|
    Declarations.generic_module_body.mod_mp := mp;
      Declarations.generic_module_body.mod_expr := me;
      Declarations.generic_module_body.mod_type := ty;
      Declarations.generic_module_body.mod_type_alg := aty;
      Declarations.generic_module_body.mod_retroknowledge := retro
      |} := mb in
  let mp' := subst_mp sub mp in
  let sub :=
    if ModPath.equal mp mp' then
      sub
    else
      if andb is_mod (negb (is_functor ty)) then
        sub
      else
        add_mp mp mp' empty_delta_resolver sub in
  let ty' := subst_signature sub do_delta ty in
  let me' := subst_impl sub me in
  let aty' := Option.Smart.map (subst_expression sub id_delta) aty in
  let retro' := subst_retro sub retro in
  let delta' := do_delta (Declarations.generic_module_body.mod_delta mb) sub in
  if
    andb (Stdlib.op_eqeq mp mp')
      (andb (Stdlib.op_eqeq me me')
        (andb (Stdlib.op_eqeq ty ty')
          (andb (Stdlib.op_eqeq aty aty')
            (andb (Stdlib.op_eqeq retro retro')
              (Stdlib.op_eqeq delta'
                (Declarations.generic_module_body.mod_delta mb)))))) then
    mb
  else
    Declarations.generic_module_body.with_mod_retroknowledge
      (Declarations.generic_module_body.with_mod_delta
        (Declarations.generic_module_body.with_mod_type_alg
          (Declarations.generic_module_body.with_mod_type
            (Declarations.generic_module_body.with_mod_expr
              (Declarations.generic_module_body.with_mod_mp mb mp') me') ty')
          aty') delta') retro'

with subst_module
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt; Mod_subst.substitution -&gt;
    Mod_subst.delta_resolver) (mb : Declarations.module_body) {struct sub}
  : Declarations.module_body := subst_body true sub subst_impl do_delta mb

with subst_impl
  (sub : Mod_subst.substitution) (me : Declarations.module_implementation)
  {struct sub} : Declarations.module_implementation :=
  implem_smartmap (subst_signature sub id_delta) (subst_expression sub id_delta)
    me

with subst_modtype
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt; Mod_subst.substitution -&gt;
    Mod_subst.delta_resolver) (mtb : Declarations.module_type_body) {struct sub}
  : Declarations.module_type_body :=
  subst_body false sub
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        tt) do_delta mtb

with subst_expr
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt; Mod_subst.substitution -&gt;
    Mod_subst.delta_resolver) (seb : Declarations.module_alg_expr) {struct sub}
  : Declarations.module_alg_expr :=
  match seb with
  | Declarations.MEident mp =&gt;
    let mp' := subst_mp sub mp in
    if Stdlib.op_eqeq mp mp' then
      seb
    else
      Declarations.MEident mp'
  | Declarations.MEapply meb1 mp2 =&gt;
    let meb1' := subst_expr sub do_delta meb1 in
    let mp2' := subst_mp sub mp2 in
    if andb (Stdlib.op_eqeq meb1 meb1') (Stdlib.op_eqeq mp2 mp2') then
      seb
    else
      Declarations.MEapply meb1' mp2'
  | Declarations.MEwith meb wdb =&gt;
    let meb' := subst_expr sub do_delta meb in
    let wdb' := subst_with_body sub wdb in
    if andb (Stdlib.op_eqeq meb meb') (Stdlib.op_eqeq wdb wdb') then
      seb
    else
      Declarations.MEwith meb' wdb'
  end

with subst_expression
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt; Mod_subst.substitution -&gt;
    Mod_subst.delta_resolver) {struct sub}
  : Declarations.module_expression -&gt; Declarations.module_expression :=
  functor_smart_map (subst_modtype sub do_delta) (subst_expr sub do_delta)

with subst_signature
  (sub : Mod_subst.substitution)
  (do_delta :
    Mod_subst.delta_resolver -&gt; Mod_subst.substitution -&gt;
    Mod_subst.delta_resolver) {struct sub}
  : Declarations.module_signature -&gt; Declarations.module_signature :=
  functor_smart_map (subst_modtype sub do_delta) (subst_structure sub do_delta).

Definition do_delta_dom
  (reso : Mod_subst.delta_resolver) (sub : Mod_subst.substitution)
  : Mod_subst.delta_resolver := subst_dom_delta_resolver sub reso.

Definition do_delta_codom
  (reso : Mod_subst.delta_resolver) (sub : Mod_subst.substitution)
  : Mod_subst.delta_resolver := subst_codom_delta_resolver sub reso.

Definition do_delta_dom_codom
  (reso : Mod_subst.delta_resolver) (sub : Mod_subst.substitution)
  : Mod_subst.delta_resolver := subst_dom_codom_delta_resolver sub reso.

Definition subst_signature (subst : Mod_subst.substitution)
  : Declarations.module_signature -&gt; Declarations.module_signature :=
  subst_signature subst do_delta_codom.

Definition subst_structure (subst : Mod_subst.substitution)
  : Declarations.structure_body -&gt; Declarations.structure_body :=
  subst_structure subst do_delta_codom.

Definition add_retroknowledge
  (r : Declarations.module_retroknowledge Declarations.module_implementation)
  (env : Environ.env) : Environ.env :=
  let 'Declarations.ModBodyRK l := r in
  (|Util.List|).(CList.ExtS.fold_left) Primred.add_retroknowledge env l.

Fixpoint add_structure
  (mp : Names.ModPath.t)
  (sign : list (Names.Label.t * Declarations.structure_field_body))
  (resolver : Mod_subst.delta_resolver) (linkinfo : Environ.link_info)
  (env : Environ.env) {struct mp} : Environ.env :=
  let add_one
    (env : Environ.env)
    (function_parameter : Names.Label.t * Declarations.structure_field_body)
    : Environ.env :=
    let '(l, elem) := function_parameter in
    match elem with
    | Declarations.SFBconst cb =&gt;
      let c := constant_of_delta_kn resolver (KerName.make mp l) in
      Environ.add_constant_key c cb linkinfo env
    | Declarations.SFBmind mib =&gt;
      let mind := mind_of_delta_kn resolver (KerName.make mp l) in
      let mib :=
        if
          Stdlib.op_exclamationeq
            (Declarations.mutual_inductive_body.mind_private mib) None then
          Declarations.mutual_inductive_body.with_mind_private mib (Some true)
        else
          mib in
      Environ.add_mind_key mind (mib, (Stdlib.__ref_value linkinfo)) env
    | Declarations.SFBmodule mb =&gt; add_module mb linkinfo env
    | Declarations.SFBmodtype mtb =&gt; Environ.add_modtype mtb env
    end in
  (|Util.List|).(CList.ExtS.fold_left) add_one env sign

with add_module
  (mb : Declarations.module_body) (linkinfo : Environ.link_info)
  (env : Environ.env) {struct mb} : Environ.env :=
  let mp := Declarations.generic_module_body.mod_mp mb in
  let env := Environ.shallow_add_module mb env in
  match Declarations.generic_module_body.mod_type mb with
  | Declarations.NoFunctor struc =&gt;
    add_retroknowledge (Declarations.generic_module_body.mod_retroknowledge mb)
      (add_structure mp struc (Declarations.generic_module_body.mod_delta mb)
        linkinfo env)
  | Declarations.MoreFunctor _ _ _ =&gt; env
  end.

Definition add_linked_module
  (mb : Declarations.module_body) (linkinfo : Environ.link_info)
  (env : Environ.env) : Environ.env := add_module mb linkinfo env.

Definition add_structure
  (mp : Names.ModPath.t)
  (sign : list (Names.Label.t * Declarations.structure_field_body))
  (resolver : Mod_subst.delta_resolver) (env : Environ.env) : Environ.env :=
  add_structure mp sign resolver no_link_info env.

Definition add_module (mb : Declarations.module_body) (env : Environ.env)
  : Environ.env := add_module mb no_link_info env.

Definition add_module_type {A : Set}
  (mp : Names.ModPath.t) (mtb : Declarations.generic_module_body A)
  (env : Environ.env) : Environ.env :=
  add_module (module_body_of_type mp mtb) env.

Definition strengthen_const
  (mp_from : Names.ModPath.t) (l : Names.Label.t)
  (cb : Declarations.constant_body) (resolver : Mod_subst.delta_resolver)
  : Declarations.constant_body :=
  match Declarations.constant_body.const_body cb with
  | Declarations.Def _ =&gt; cb
  | _ =&gt;
    let kn := KerName.make mp_from l in
    let con := constant_of_delta_kn resolver kn in
    let u :=
      Univ.make_abstract_instance (Declareops.constant_polymorphic_context cb)
      in
    Declarations.constant_body.with_const_private_poly_univs
      (Declarations.constant_body.with_const_body_code
        (Declarations.constant_body.with_const_body cb
          (Declarations.Def (Mod_subst.from_val (mkConstU (con, u)))))
        (Some (Cemitcodes.from_val (Cbytegen.compile_alias con)))) None
  end.

Fixpoint strengthen_mod
  (mp_from : Names.ModPath.t) (mp_to : Names.ModPath.t)
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  {struct mp_from}
  : Declarations.generic_module_body Declarations.module_implementation :=
  if
    mp_in_delta (Declarations.generic_module_body.mod_mp mb)
      (Declarations.generic_module_body.mod_delta mb) then
    mb
  else
    match Declarations.generic_module_body.mod_type mb with
    | Declarations.NoFunctor struc =&gt;
      let '(reso, struc') :=
        strengthen_sig mp_from struc mp_to
          (Declarations.generic_module_body.mod_delta mb) in
      Declarations.generic_module_body.with_mod_delta
        (Declarations.generic_module_body.with_mod_type
          (Declarations.generic_module_body.with_mod_expr mb
            (Declarations.Algebraic
              (Declarations.NoFunctor (Declarations.MEident mp_to))))
          (Declarations.NoFunctor struc'))
        (add_mp_delta_resolver mp_from mp_to
          (add_delta_resolver (Declarations.generic_module_body.mod_delta mb)
            reso))
    | Declarations.MoreFunctor _ _ _ =&gt; mb
    end

with strengthen_sig
  (mp_from : Names.ModPath.t) (struc : Declarations.structure_body)
  (mp_to : Names.ModPath.t) (reso : Mod_subst.delta_resolver) {struct mp_from}
  : Mod_subst.delta_resolver * Declarations.structure_body :=
  match struc with
  | [] =&gt; (empty_delta_resolver, [])
  | cons (l, Declarations.SFBconst cb) rest =&gt;
    let item' :=
      (l, (Declarations.SFBconst (strengthen_const mp_from l cb reso))) in
    let '(reso', rest') := strengthen_sig mp_from rest mp_to reso in
    (reso', (cons item' rest'))
  | cons ((_, Declarations.SFBmind _) as item) rest =&gt;
    let '(reso', rest') := strengthen_sig mp_from rest mp_to reso in
    (reso', (cons item rest'))
  | cons (l, Declarations.SFBmodule mb) rest =&gt;
    let mp_from' := Names.MPdot mp_from l in
    let mp_to' := Names.MPdot mp_to l in
    let mb' := strengthen_mod mp_from' mp_to' mb in
    let item' := (l, (Declarations.SFBmodule mb')) in
    let '(reso', rest') := strengthen_sig mp_from rest mp_to reso in
    ((add_delta_resolver reso' (Declarations.generic_module_body.mod_delta mb)),
      (cons item' rest'))
  | cons ((_l, Declarations.SFBmodtype _mty) as item) rest =&gt;
    let '(reso', rest') := strengthen_sig mp_from rest mp_to reso in
    (reso', (cons item rest'))
  end.

Definition strengthen {A : Set}
  (mtb : Declarations.generic_module_body A) (mp : Names.ModPath.t)
  : Declarations.generic_module_body A :=
  if
    mp_in_delta (Declarations.generic_module_body.mod_mp mtb)
      (Declarations.generic_module_body.mod_delta mtb) then
    mtb
  else
    match Declarations.generic_module_body.mod_type mtb with
    | Declarations.NoFunctor struc =&gt;
      let '(reso', struc') :=
        strengthen_sig (Declarations.generic_module_body.mod_mp mtb) struc mp
          (Declarations.generic_module_body.mod_delta mtb) in
      Declarations.generic_module_body.with_mod_delta
        (Declarations.generic_module_body.with_mod_type mtb
          (Declarations.NoFunctor struc'))
        (add_delta_resolver (Declarations.generic_module_body.mod_delta mtb)
          (add_mp_delta_resolver (Declarations.generic_module_body.mod_mp mtb)
            mp reso'))
    | Declarations.MoreFunctor _ _ _ =&gt; mtb
    end.

Definition inline_delta_resolver {A : Set}
  (env : Environ.env) (inl : option Z) (mp : Names.ModPath.t)
  (mbid : Names.MBId.t) (mtb : Declarations.generic_module_body A)
  (delta : Mod_subst.delta_resolver) : Mod_subst.delta_resolver :=
  let constants :=
    inline_of_delta inl (Declarations.generic_module_body.mod_delta mtb) in
  let fix make_inline
    (delta : Mod_subst.delta_resolver)
    (function_parameter : list (Z * Names.KerName.t)) {struct delta}
    : Mod_subst.delta_resolver :=
    match function_parameter with
    | [] =&gt; delta
    | cons (lev, kn) r =&gt;
      let kn := replace_mp_in_kn (Names.MPbound mbid) mp kn in
      let con := constant_of_delta_kn delta kn in
      (* ❌ Try-with are not handled *)
      try
        (let constant := lookup_constant con env in
        let l := make_inline delta r in
        match Declarations.constant_body.const_body constant with
        |
          Declarations.Undef _ | Declarations.OpaqueDef _ |
          Declarations.Primitive _ =&gt; l
        | Declarations.Def body =&gt;
          let constr := Mod_subst.force_constr body in
          let ctx := Declareops.constant_polymorphic_context constant in
          let constr :=
            {| Univ.univ_abstracted.univ_abstracted_value := constr;
              Univ.univ_abstracted.univ_abstracted_binder := ctx |} in
          add_inline_delta_resolver kn (lev, (Some constr)) l
        end)
    end in
  make_inline delta constants.

Fixpoint strengthen_and_subst_mod
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  (subst : Mod_subst.substitution) (mp_from : Names.ModPath.t)
  (mp_to : Names.ModPath.t) {struct mb} : Declarations.module_body :=
  match Declarations.generic_module_body.mod_type mb with
  | Declarations.NoFunctor struc =&gt;
    let mb_is_an_alias :=
      mp_in_delta (Declarations.generic_module_body.mod_mp mb)
        (Declarations.generic_module_body.mod_delta mb) in
    if mb_is_an_alias then
      subst_module subst do_delta_dom mb
    else
      let '(reso', struc') :=
        strengthen_and_subst_struct struc subst mp_from mp_to false false
          (Declarations.generic_module_body.mod_delta mb) in
      Declarations.generic_module_body.with_mod_delta
        (Declarations.generic_module_body.with_mod_type
          (Declarations.generic_module_body.with_mod_expr
            (Declarations.generic_module_body.with_mod_mp mb mp_to)
            (Declarations.Algebraic
              (Declarations.NoFunctor (Declarations.MEident mp_from))))
          (Declarations.NoFunctor struc'))
        (add_mp_delta_resolver mp_to mp_from reso')
  | Declarations.MoreFunctor _ _ _ =&gt;
    let subst :=
      add_mp (Declarations.generic_module_body.mod_mp mb) mp_to
        empty_delta_resolver subst in
    subst_module subst do_delta_dom mb
  end

with strengthen_and_subst_struct
  (str : Declarations.structure_body) (subst : Mod_subst.substitution)
  (mp_from : Names.ModPath.t) (mp_to : Names.ModPath.t) (alias : bool)
  (incl : bool) (reso : Mod_subst.delta_resolver) {struct str}
  : Mod_subst.delta_resolver * Declarations.structure_body :=
  match str with
  | [] =&gt; (empty_delta_resolver, [])
  | cons ((l, Declarations.SFBconst cb) as item) rest =&gt;
    let cb' := subst_const_body subst cb in
    let cb' :=
      if alias then
        cb'
      else
        strengthen_const mp_from l cb' reso in
    let item' :=
      if Stdlib.op_eqeq cb' cb then
        item
      else
        (l, (Declarations.SFBconst cb')) in
    let '(reso', rest') :=
      strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso in
    let str' :=
      if andb (Stdlib.op_eqeq rest' rest) (Stdlib.op_eqeq item' item) then
        str
      else
        cons item' rest' in
    if incl then
      let kn_from := KerName.make mp_from l in
      let kn_to := KerName.make mp_to l in
      let old_name := kn_of_delta reso kn_from in
      ((add_kn_delta_resolver kn_to old_name reso'), str')
    else
      (reso', str')
  | cons ((l, Declarations.SFBmind mib) as item) rest =&gt;
    let mib' := subst_mind_body subst mib in
    let item' :=
      if Stdlib.op_eqeq mib' mib then
        item
      else
        (l, (Declarations.SFBmind mib')) in
    let '(reso', rest') :=
      strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso in
    let str' :=
      if andb (Stdlib.op_eqeq rest' rest) (Stdlib.op_eqeq item' item) then
        str
      else
        cons item' rest' in
    if incl then
      let kn_from := KerName.make mp_from l in
      let kn_to := KerName.make mp_to l in
      let old_name := kn_of_delta reso kn_from in
      ((add_kn_delta_resolver kn_to old_name reso'), str')
    else
      (reso', str')
  | cons ((l, Declarations.SFBmodule mb) as item) rest =&gt;
    let mp_from' := Names.MPdot mp_from l in
    let mp_to' := Names.MPdot mp_to l in
    let mb' :=
      if alias then
        subst_module subst do_delta_dom mb
      else
        strengthen_and_subst_mod mb subst mp_from' mp_to' in
    let item' :=
      if Stdlib.op_eqeq mb' mb then
        item
      else
        (l, (Declarations.SFBmodule mb')) in
    let '(reso', rest') :=
      strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso in
    let str' :=
      if andb (Stdlib.op_eqeq rest' rest) (Stdlib.op_eqeq item' item) then
        str
      else
        cons item' rest' in
    if is_functor (Declarations.generic_module_body.mod_type mb') then
      ((add_mp_delta_resolver mp_to' mp_to' reso'), str')
    else
      ((add_delta_resolver reso'
        (Declarations.generic_module_body.mod_delta mb')), str')
  | cons ((l, Declarations.SFBmodtype mty) as item) rest =&gt;
    let mp_from' := Names.MPdot mp_from l in
    let mp_to' := Names.MPdot mp_to l in
    let subst' := add_mp mp_from' mp_to' empty_delta_resolver subst in
    let mty' :=
      subst_modtype subst'
        (fun resolver =&gt;
          fun function_parameter =&gt;
            let '_ := function_parameter in
            subst_dom_codom_delta_resolver subst' resolver) mty in
    let item' :=
      if Stdlib.op_eqeq mty' mty then
        item
      else
        (l, (Declarations.SFBmodtype mty')) in
    let '(reso', rest') :=
      strengthen_and_subst_struct rest subst mp_from mp_to alias incl reso in
    let str' :=
      if andb (Stdlib.op_eqeq rest' rest) (Stdlib.op_eqeq item' item) then
        str
      else
        cons item' rest' in
    ((add_mp_delta_resolver mp_to' mp_to' reso'), str')
  end.

Definition strengthen_and_subst_mb
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  (mp : Names.ModPath.t) (include_b : bool) : Declarations.module_body :=
  match Declarations.generic_module_body.mod_type mb with
  | Declarations.NoFunctor struc =&gt;
    let mb_is_an_alias :=
      mp_in_delta (Declarations.generic_module_body.mod_mp mb)
        (Declarations.generic_module_body.mod_delta mb) in
    let mp_alias :=
      mp_of_delta (Declarations.generic_module_body.mod_delta mb)
        (Declarations.generic_module_body.mod_mp mb) in
    let subst_resolver :=
      map_mp (Declarations.generic_module_body.mod_mp mb) mp
        empty_delta_resolver in
    let new_resolver :=
      add_mp_delta_resolver mp mp_alias
        (subst_dom_delta_resolver subst_resolver
          (Declarations.generic_module_body.mod_delta mb)) in
    let subst :=
      map_mp (Declarations.generic_module_body.mod_mp mb) mp new_resolver in
    let '(reso', struc') :=
      strengthen_and_subst_struct struc subst
        (Declarations.generic_module_body.mod_mp mb) mp mb_is_an_alias include_b
        (Declarations.generic_module_body.mod_delta mb) in
    Declarations.generic_module_body.with_mod_delta
      (Declarations.generic_module_body.with_mod_type
        (Declarations.generic_module_body.with_mod_expr
          (Declarations.generic_module_body.with_mod_mp mb mp)
          (Declarations.Algebraic
            (Declarations.NoFunctor
              (Declarations.MEident (Declarations.generic_module_body.mod_mp mb)))))
        (Declarations.NoFunctor struc'))
      (if include_b then
        reso'
      else
        add_delta_resolver new_resolver reso')
  | Declarations.MoreFunctor _ _ _ =&gt;
    let subst :=
      map_mp (Declarations.generic_module_body.mod_mp mb) mp
        empty_delta_resolver in
    subst_module subst do_delta_dom_codom mb
  end.

Definition subst_modtype_and_resolver
  (mtb : Declarations.module_type_body) (mp : Names.ModPath.t)
  : Declarations.module_type_body :=
  let subst :=
    map_mp (Declarations.generic_module_body.mod_mp mtb) mp empty_delta_resolver
    in
  let new_delta :=
    subst_dom_codom_delta_resolver subst
      (Declarations.generic_module_body.mod_delta mtb) in
  let full_subst :=
    map_mp (Declarations.generic_module_body.mod_mp mtb) mp new_delta in
  subst_modtype full_subst do_delta_dom_codom mtb.

Fixpoint is_bounded_expr
  (l : Names.MBIset.t) (function_parameter : Declarations.module_alg_expr)
  {struct l} : bool :=
  match function_parameter with
  | Declarations.MEident (Names.MPbound mbid) =&gt; MBIset.mem mbid l
  | Declarations.MEapply fexpr mp =&gt;
    orb (is_bounded_expr l (Declarations.MEident mp)) (is_bounded_expr l fexpr)
  | _ =&gt; false
  end.

Fixpoint clean_module_body
  (l : Names.MBIset.t)
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  {struct l}
  : Declarations.generic_module_body Declarations.module_implementation :=
  let '(impl, typ) :=
    ((Declarations.generic_module_body.mod_expr mb),
      (Declarations.generic_module_body.mod_type mb)) in
  let typ' := clean_signature l typ in
  let impl' :=
    match
      (impl,
        match impl with
        | Declarations.Algebraic (Declarations.NoFunctor m) =&gt;
          is_bounded_expr l m
        | _ =&gt; false
        end) with
    | (Declarations.Algebraic (Declarations.NoFunctor m), true) =&gt;
      Declarations.FullStruct
    | (_, _) =&gt; implem_smartmap (clean_signature l) (clean_expression l) impl
    end in
  if andb (Stdlib.op_eqeq typ typ') (Stdlib.op_eqeq impl impl') then
    mb
  else
    Declarations.generic_module_body.with_mod_type
      (Declarations.generic_module_body.with_mod_expr mb impl') typ'

with clean_module_type (l : Names.MBIset.t) (mb : Declarations.module_type_body)
  {struct l} : Declarations.module_type_body :=
  let '(_, typ) :=
    ((Declarations.generic_module_body.mod_expr mb),
      (Declarations.generic_module_body.mod_type mb)) in
  let typ' := clean_signature l typ in
  if Stdlib.op_eqeq typ typ' then
    mb
  else
    Declarations.generic_module_body.with_mod_type mb typ'

with clean_field
  (l : Names.MBIset.t)
  (field : Names.Label.t * Declarations.structure_field_body) {struct l}
  : Names.Label.t * Declarations.structure_field_body :=
  match field with
  | (lab, Declarations.SFBmodule mb) =&gt;
    let mb' := clean_module_body l mb in
    if Stdlib.op_eqeq mb mb' then
      field
    else
      (lab, (Declarations.SFBmodule mb'))
  | _ =&gt; field
  end

with clean_structure (l : Names.MBIset.t) {struct l}
  : Declarations.structure_body -&gt; Declarations.structure_body :=
  List.Smart.map (clean_field l)

with clean_signature (l : Names.MBIset.t) {struct l}
  : Declarations.module_signature -&gt; Declarations.module_signature :=
  functor_smart_map (clean_module_type l) (clean_structure l)

with clean_expression (l : Names.MBIset.t) {struct l}
  : Declarations.module_expression -&gt; Declarations.module_expression :=
  functor_smart_map (clean_module_type l) (fun me =&gt; me).

Fixpoint collect_mbid {A : Set}
  (l : Names.MBIset.t)
  (sign : Declarations.functorize A Declarations.structure_body) {struct l}
  : Declarations.functorize A Declarations.structure_body :=
  match sign with
  | Declarations.MoreFunctor mbid ty m =&gt;
    let m' := collect_mbid (MBIset.add mbid l) m in
    if Stdlib.op_eqeq m m' then
      sign
    else
      Declarations.MoreFunctor mbid ty m'
  | Declarations.NoFunctor struc =&gt;
    let struc' := clean_structure l struc in
    if Stdlib.op_eqeq struc struc' then
      sign
    else
      Declarations.NoFunctor struc'
  end.

Definition clean_bounded_mod_expr {A : Set}
  (sign : Declarations.functorize A Declarations.structure_body)
  : Declarations.functorize A Declarations.structure_body :=
  if is_functor sign then
    collect_mbid MBIset.empty sign
  else
    sign.

Definition join_constant_body
  (except : Future.UUIDSet.t) (otab : Opaqueproof.opaquetab)
  (cb : Declarations.constant_body) : unit :=
  match Declarations.constant_body.const_body cb with
  | Declarations.OpaqueDef o =&gt;
    match
      ((Opaqueproof.uuid_opaque otab o),
        match Opaqueproof.uuid_opaque otab o with
        | Some uuid =&gt; negb (Future.UUIDSet.mem uuid except)
        | _ =&gt; false
        end) with
    | (Some uuid, true) =&gt; Opaqueproof.join_opaque otab o
    | (_, _) =&gt; tt
    end
  | _ =&gt; tt
  end.

Definition join_structure
  (except : Future.UUIDSet.t) (otab : Opaqueproof.opaquetab)
  (s : Declarations.structure_body) : unit :=
  let fix join_module {a : Set} (mb : Declarations.generic_module_body a)
    {struct mb} : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    join_signature (Declarations.generic_module_body.mod_type mb)
  with join_field
    (function_parameter : Names.Label.t * Declarations.structure_field_body)
    {struct function_parameter} : unit :=
    let '(_l, body) := function_parameter in
    match body with
    | Declarations.SFBconst sb =&gt; join_constant_body except otab sb
    | Declarations.SFBmind _ =&gt; tt
    | Declarations.SFBmodule m =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      join_module m
    | Declarations.SFBmodtype m =&gt; join_module m
    end
  with join_structure (struc : Declarations.structure_body) {struct struc}
    : unit :=
    (|Util.List|).(CList.ExtS.iter) join_field struc
  with join_signature (sign : Declarations.module_signature) {struct sign}
    : unit :=
    functor_iter join_module join_structure sign
  with join_expression (me : Declarations.module_expression) {struct me}
    : unit :=
    functor_iter join_module
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        tt) me in
  join_structure s.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="modops.mli">
  <div style="margin: 20px;">
    <h3>Modops_mli</h3>
    <ul>
      <li>OCaml size: 159 lines</li>
      <li>Coq size: 176 lines (+10% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#modops.mli"><code>modops.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Environ
open Declarations
open Entries
open Mod_subst

(** {6 Various operations on modules and module types } *)

(** Functors *)

val is_functor : ('ty,'a) functorize -&gt; bool

val destr_functor : ('ty,'a) functorize -&gt; MBId.t * 'ty * ('ty,'a) functorize

val destr_nofunctor : ('ty,'a) functorize -&gt; 'a

(** Conversions between [module_body] and [module_type_body] *)

val module_type_of_module : module_body -&gt; module_type_body
val module_body_of_type : ModPath.t -&gt; module_type_body -&gt; module_body

val check_modpath_equiv : env -&gt; ModPath.t -&gt; ModPath.t -&gt; unit

val implem_smartmap :
  (module_signature -&gt; module_signature) -&gt;
  (module_expression -&gt; module_expression) -&gt;
  (module_implementation -&gt; module_implementation)

(** {6 Substitutions } *)

val subst_signature : substitution -&gt; module_signature -&gt; module_signature
val subst_structure : substitution -&gt; structure_body -&gt; structure_body

(** {6 Adding to an environment } *)

val add_structure :
  ModPath.t -&gt; structure_body -&gt; delta_resolver -&gt; env -&gt; env

(** adds a module and its components, but not the constraints *)
val add_module : module_body -&gt; env -&gt; env

(** same as add_module, but for a module whose native code has been linked by
the native compiler. The linking information is updated. *)
val add_linked_module : module_body -&gt; link_info -&gt; env -&gt; env

(** same, for a module type *)
val add_module_type : ModPath.t -&gt; module_type_body -&gt; env -&gt; env

val add_retroknowledge : module_implementation module_retroknowledge -&gt; env -&gt; env

(** {6 Strengthening } *)

val strengthen : module_type_body -&gt; ModPath.t -&gt; module_type_body

val inline_delta_resolver :
  env -&gt; inline -&gt; ModPath.t -&gt; MBId.t -&gt; module_type_body -&gt;
  delta_resolver -&gt; delta_resolver

val strengthen_and_subst_mb : module_body -&gt; ModPath.t -&gt; bool -&gt; module_body

val subst_modtype_and_resolver : module_type_body -&gt; ModPath.t -&gt;
  module_type_body

(** {6 Cleaning a module expression from bounded parts }

     For instance:
       functor(X:T)-&gt;struct module M:=X end)
     becomes:
       functor(X:T)-&gt;struct module M:=&lt;content of T&gt; end)
*)

val clean_bounded_mod_expr : module_signature -&gt; module_signature

(** {6 Stm machinery } *)

val join_structure :
  Future.UUIDSet.t -&gt; Opaqueproof.opaquetab -&gt; structure_body -&gt; unit

(** {6 Errors } *)

type signature_mismatch_error =
  | InductiveFieldExpected of mutual_inductive_body
  | DefinitionFieldExpected
  | ModuleFieldExpected
  | ModuleTypeFieldExpected
  | NotConvertibleInductiveField of Id.t
  | NotConvertibleConstructorField of Id.t
  | NotConvertibleBodyField
  | NotConvertibleTypeField of env * types * types
  | CumulativeStatusExpected of bool
  | PolymorphicStatusExpected of bool
  | NotSameConstructorNamesField
  | NotSameInductiveNameInBlockField
  | FiniteInductiveFieldExpected of bool
  | InductiveNumbersFieldExpected of int
  | InductiveParamsNumberField of int
  | RecordFieldExpected of bool
  | RecordProjectionsExpected of Name.t list
  | NotEqualInductiveAliases
  | IncompatibleUniverses of Univ.univ_inconsistency
  | IncompatiblePolymorphism of env * types * types
  | IncompatibleConstraints of { got : Univ.AUContext.t; expect : Univ.AUContext.t }
  | IncompatibleVariance

type module_typing_error =
  | SignatureMismatch of
      Label.t * structure_field_body * signature_mismatch_error
  | LabelAlreadyDeclared of Label.t
  | ApplicationToNotPath of module_struct_entry
  | NotAFunctor
  | IsAFunctor
  | IncompatibleModuleTypes of module_type_body * module_type_body
  | NotEqualModulePaths of ModPath.t * ModPath.t
  | NoSuchLabel of Label.t
  | IncompatibleLabels of Label.t * Label.t
  | NotAModule of string
  | NotAModuleType of string
  | NotAConstant of Label.t
  | IncorrectWithConstraint of Label.t
  | GenerativeModuleExpected of Label.t
  | LabelMissing of Label.t * string
  | IncludeRestrictedFunctor of ModPath.t

<abbr class="mark-warning" title="Signature item `exception` not handled">exception ModuleTypingError of module_typing_error</abbr>

val error_existing_label : Label.t -&gt; 'a

val error_incompatible_modtypes :
  module_type_body -&gt; module_type_body -&gt; 'a

val error_signature_mismatch :
  Label.t -&gt; structure_field_body -&gt; signature_mismatch_error -&gt; 'a

val error_incompatible_labels : Label.t -&gt; Label.t -&gt; 'a

val error_no_such_label : Label.t -&gt; 'a

val error_not_a_module : string -&gt; 'a

val error_not_a_constant : Label.t -&gt; 'a

val error_incorrect_with_constraint : Label.t -&gt; 'a

val error_generative_module_expected : Label.t -&gt; 'a

val error_no_such_label_sub : Label.t-&gt;string-&gt;'a

val error_include_restricted_functor : ModPath.t -&gt; 'a
</pre>
  </div>
  <div class="col-md-6">
    <a href="#modops.mli"><code>Modops_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter is_functor : forall {a ty : Set},
  Declarations.functorize ty a -&gt; bool.

Parameter destr_functor : forall {a ty : Set},
  Declarations.functorize ty a -&gt;
  Names.MBId.t * ty * Declarations.functorize ty a.

Parameter destr_nofunctor : forall {a ty : Set},
  Declarations.functorize ty a -&gt; a.

Parameter module_type_of_module :
  Declarations.module_body -&gt; Declarations.module_type_body.

Parameter module_body_of_type :
  Names.ModPath.t -&gt; Declarations.module_type_body -&gt; Declarations.module_body.

Parameter check_modpath_equiv :
  Environ.env -&gt; Names.ModPath.t -&gt; Names.ModPath.t -&gt; unit.

Parameter implem_smartmap :
  (Declarations.module_signature -&gt; Declarations.module_signature) -&gt;
  (Declarations.module_expression -&gt; Declarations.module_expression) -&gt;
  Declarations.module_implementation -&gt; Declarations.module_implementation.

Parameter subst_signature :
  Mod_subst.substitution -&gt; Declarations.module_signature -&gt;
  Declarations.module_signature.

Parameter subst_structure :
  Mod_subst.substitution -&gt; Declarations.structure_body -&gt;
  Declarations.structure_body.

Parameter add_structure :
  Names.ModPath.t -&gt; Declarations.structure_body -&gt; Mod_subst.delta_resolver -&gt;
  Environ.env -&gt; Environ.env.

Parameter add_module : Declarations.module_body -&gt; Environ.env -&gt; Environ.env.

Parameter add_linked_module :
  Declarations.module_body -&gt; Environ.link_info -&gt; Environ.env -&gt; Environ.env.

Parameter add_module_type :
  Names.ModPath.t -&gt; Declarations.module_type_body -&gt; Environ.env -&gt; Environ.env.

Parameter add_retroknowledge :
  Declarations.module_retroknowledge Declarations.module_implementation -&gt;
  Environ.env -&gt; Environ.env.

Parameter strengthen :
  Declarations.module_type_body -&gt; Names.ModPath.t -&gt;
  Declarations.module_type_body.

Parameter inline_delta_resolver :
  Environ.env -&gt; Entries.inline -&gt; Names.ModPath.t -&gt; Names.MBId.t -&gt;
  Declarations.module_type_body -&gt; Mod_subst.delta_resolver -&gt;
  Mod_subst.delta_resolver.

Parameter strengthen_and_subst_mb :
  Declarations.module_body -&gt; Names.ModPath.t -&gt; bool -&gt;
  Declarations.module_body.

Parameter subst_modtype_and_resolver :
  Declarations.module_type_body -&gt; Names.ModPath.t -&gt;
  Declarations.module_type_body.

Parameter clean_bounded_mod_expr :
  Declarations.module_signature -&gt; Declarations.module_signature.

Parameter join_structure :
  Future.UUIDSet.t -&gt; Opaqueproof.opaquetab -&gt; Declarations.structure_body -&gt;
  unit.

Module signature_mismatch_error.
  Module IncompatibleConstraints.
    Record record {got expect : Set} := {
      got : got;
      expect : expect }.
    Arguments record : clear implicits.
  End IncompatibleConstraints.
  Definition IncompatibleConstraints := IncompatibleConstraints.record.
End signature_mismatch_error.

Inductive signature_mismatch_error : Set :=
| InductiveFieldExpected :
  Declarations.mutual_inductive_body -&gt; signature_mismatch_error
| DefinitionFieldExpected : signature_mismatch_error
| ModuleFieldExpected : signature_mismatch_error
| ModuleTypeFieldExpected : signature_mismatch_error
| NotConvertibleInductiveField : Names.Id.t -&gt; signature_mismatch_error
| NotConvertibleConstructorField : Names.Id.t -&gt; signature_mismatch_error
| NotConvertibleBodyField : signature_mismatch_error
| NotConvertibleTypeField :
  Environ.env -&gt; Constr.types -&gt; Constr.types -&gt; signature_mismatch_error
| CumulativeStatusExpected : bool -&gt; signature_mismatch_error
| PolymorphicStatusExpected : bool -&gt; signature_mismatch_error
| NotSameConstructorNamesField : signature_mismatch_error
| NotSameInductiveNameInBlockField : signature_mismatch_error
| FiniteInductiveFieldExpected : bool -&gt; signature_mismatch_error
| InductiveNumbersFieldExpected : Z -&gt; signature_mismatch_error
| InductiveParamsNumberField : Z -&gt; signature_mismatch_error
| RecordFieldExpected : bool -&gt; signature_mismatch_error
| RecordProjectionsExpected : list Names.Name.t -&gt; signature_mismatch_error
| NotEqualInductiveAliases : signature_mismatch_error
| IncompatibleUniverses : Univ.univ_inconsistency -&gt; signature_mismatch_error
| IncompatiblePolymorphism :
  Environ.env -&gt; Constr.types -&gt; Constr.types -&gt; signature_mismatch_error
| IncompatibleConstraints :
  signature_mismatch_error.IncompatibleConstraints Univ.AUContext.t
    Univ.AUContext.t -&gt; signature_mismatch_error
| IncompatibleVariance : signature_mismatch_error.

Inductive module_typing_error : Set :=
| SignatureMismatch :
  Names.Label.t -&gt; Declarations.structure_field_body -&gt;
  signature_mismatch_error -&gt; module_typing_error
| LabelAlreadyDeclared : Names.Label.t -&gt; module_typing_error
| ApplicationToNotPath : Entries.module_struct_entry -&gt; module_typing_error
| NotAFunctor : module_typing_error
| IsAFunctor : module_typing_error
| IncompatibleModuleTypes :
  Declarations.module_type_body -&gt; Declarations.module_type_body -&gt;
  module_typing_error
| NotEqualModulePaths :
  Names.ModPath.t -&gt; Names.ModPath.t -&gt; module_typing_error
| NoSuchLabel : Names.Label.t -&gt; module_typing_error
| IncompatibleLabels : Names.Label.t -&gt; Names.Label.t -&gt; module_typing_error
| NotAModule : string -&gt; module_typing_error
| NotAModuleType : string -&gt; module_typing_error
| NotAConstant : Names.Label.t -&gt; module_typing_error
| IncorrectWithConstraint : Names.Label.t -&gt; module_typing_error
| GenerativeModuleExpected : Names.Label.t -&gt; module_typing_error
| LabelMissing : Names.Label.t -&gt; string -&gt; module_typing_error
| IncludeRestrictedFunctor : Names.ModPath.t -&gt; module_typing_error.

(* exception ModuleTypingError *)

Parameter error_existing_label : forall {a : Set}, Names.Label.t -&gt; a.

Parameter error_incompatible_modtypes : forall {a : Set},
  Declarations.module_type_body -&gt; Declarations.module_type_body -&gt; a.

Parameter error_signature_mismatch : forall {a : Set},
  Names.Label.t -&gt; Declarations.structure_field_body -&gt;
  signature_mismatch_error -&gt; a.

Parameter error_incompatible_labels : forall {a : Set},
  Names.Label.t -&gt; Names.Label.t -&gt; a.

Parameter error_no_such_label : forall {a : Set}, Names.Label.t -&gt; a.

Parameter error_not_a_module : forall {a : Set}, string -&gt; a.

Parameter error_not_a_constant : forall {a : Set}, Names.Label.t -&gt; a.

Parameter error_incorrect_with_constraint : forall {a : Set},
  Names.Label.t -&gt; a.

Parameter error_generative_module_expected : forall {a : Set},
  Names.Label.t -&gt; a.

Parameter error_no_such_label_sub : forall {a : Set},
  Names.Label.t -&gt; string -&gt; a.

Parameter error_include_restricted_functor : forall {a : Set},
  Names.ModPath.t -&gt; a.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="names.ml">
  <div style="margin: 20px;">
    <h3>Names</h3>
    <ul>
      <li>OCaml size: 1024 lines</li>
      <li>Coq size: 1714 lines (+67% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#names.ml"><code>names.ml</code></a>&nbsp;<span class="label label-warning">31 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* File created around Apr 1994 for CiC V5.10.5 by Chet Murthy collecting
   parts of file initial.ml from CoC V4.8, Dec 1988, by GÃ©rard Huet,
   Thierry Coquand and Christine Paulin *)
(* Hash-consing by Bruno Barras in Feb 1998 *)
(* Extra functions for splitting/generation of identifiers by Hugo Herbelin *)
(* Restructuration by Jacek Chrzaszcz as part of the implementation of
   the module system, Aug 2002 *)
(* Abstraction over the type of constant for module inlining by Claudio
   Sacerdoti, Nov 2004 *)
(* Miscellaneous features or improvements by Hugo Herbelin,
   Ãlie Soubiran, ... *)

open Pp
open Util

(** {6 Identifiers } *)

(** Representation and operations on identifiers. *)
module Id =
struct
  type t = string

  let equal = String.equal

  let compare = String.compare

  let hash = String.hash

  let check_valid ?(strict=true) x =
    let iter (fatal, x) = if fatal || strict then CErrors.user_err Pp.(str x) in
    Option.iter iter (Unicode.ident_refutation x)

  let is_valid s = match Unicode.ident_refutation s with
  | None -&gt; true
  | Some _ -&gt; false

  let of_bytes s =
    let s = Bytes.to_string s in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_valid s;
    String.hcons s</abbr>

  let of_string s =
    let () = check_valid s in
    String.hcons s

  let of_string_soft s =
    let () = check_valid ~strict:false s in
    String.hcons s

  let to_string id = id

  let print id = str id

  <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module Self =
  struct
    type t = string
    let compare = compare
  end</abbr>

  module Set = Set.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Self</abbr>)
  module Map = CMap.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Self</abbr>)

  module Pred = Predicate.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Self</abbr>)

  module List = String.List

  let hcons = String.hcons

end

(** Representation and operations on identifiers that are allowed to be anonymous
    (i.e. &quot;_&quot; in concrete syntax). *)
module Name =
struct
  type t = Anonymous     (** anonymous identifier *)
         | Name of Id.t  (** non-anonymous identifier *)

  let mk_name id =
    Name id

  let is_anonymous = function
    | Anonymous -&gt; true
    | Name _ -&gt; false

  let is_name = is_anonymous %&gt; not

  let compare n1 n2 = match n1, n2 with
    | Anonymous, Anonymous -&gt; 0
    | Name id1, Name id2 -&gt; Id.compare id1 id2
    | Anonymous, Name _ -&gt; -1
    | Name _, Anonymous -&gt; 1

  let equal n1 n2 = match n1, n2 with
    | Anonymous, Anonymous -&gt; true
    | Name id1, Name id2 -&gt; String.equal id1 id2
    | _ -&gt; false

  let hash = function
    | Anonymous -&gt; 0
    | Name id -&gt; Id.hash id

  let print = function
    | Anonymous -&gt; str &quot;_&quot;
    | Name id -&gt; Id.print id

  module Self_Hashcons =
    struct
      type nonrec t = t
      type u = Id.t -&gt; Id.t
      let hashcons hident = function
        | Name id -&gt; Name (hident id)
        | n -&gt; n
      let eq n1 n2 =
        n1 == n2 ||
        match (n1,n2) with
          | (Name id1, Name id2) -&gt; id1 == id2
          | (Anonymous,Anonymous) -&gt; true
          | _ -&gt; false
      let hash = hash
    end

  module Hname = Hashcons.Make(Self_Hashcons)

  let hcons = Hashcons.simple_hcons Hname.generate Hname.hcons Id.hcons

end

(** Alias, to import constructors. *)
type name = Name.t = Anonymous | Name of Id.t

(** {6 Various types based on identifiers } *)

type variable = Id.t

type module_ident = Id.t

module ModIdset = Id.Set
module ModIdmap = Id.Map

(** {6 Directory paths = section names paths } *)

(** Dirpaths are lists of module identifiers.
    The actual representation is reversed to optimise sharing:
    Coq.A.B is [&quot;B&quot;;&quot;A&quot;;&quot;Coq&quot;] *)

let default_module_name = &quot;If you see this, it's a bug&quot;

module DirPath =
struct
  type t = module_ident list

  let compare = List.compare Id.compare
  let equal = List.equal Id.equal

  let rec hash accu = function
  | [] -&gt; accu
  | id :: dp -&gt;
    let accu = Hashset.Combine.combine (Id.hash id) accu in
    hash accu dp

  let hash dp = hash 0 dp

  let make x = x
  let repr x = x

  let empty = []

  let is_empty = List.is_empty

  let to_string = function
    | [] -&gt; &quot;&lt;&gt;&quot;
    | sl -&gt; String.concat &quot;.&quot; (List.rev_map Id.to_string sl)

  let print dp = str (to_string dp)

  let initial = [default_module_name]

  module Hdir = Hashcons.Hlist(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Hashcons.HashedType, Util.Set.HashedType

We were looking for a module signature name for the following shape:
[ hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Id</abbr>)

  let hcons = Hashcons.recursive_hcons Hdir.generate Hdir.hcons Id.hcons

end

(** {6 Unique names for bound modules } *)

module MBId =
struct
  type t = int * Id.t * DirPath.t

  let gen =
    let seed = ref 0 in fun () -&gt;
      let ans = !seed in
      let () = incr seed in
      ans

  let make dir s = (gen(), s, dir)

  let repr mbid = mbid

  let to_string (_i, s, p) =
    DirPath.to_string p ^ &quot;.&quot; ^ s

  let debug_to_string (i, s, p) =
    &quot;&lt;&quot;^DirPath.to_string p ^&quot;#&quot; ^ s ^&quot;#&quot;^ string_of_int i^&quot;&gt;&quot;

  let compare (x : t) (y : t) =
    if x == y then 0
    else match (x, y) with
    | (nl, idl, dpl), (nr, idr, dpr) -&gt;
      let ans = Int.compare nl nr in
      if not (Int.equal ans 0) then ans
      else
        let ans = Id.compare idl idr in
        if not (Int.equal ans 0) then ans
        else
          DirPath.compare dpl dpr

  let equal x y = x == y ||
    let (i1, id1, p1) = x in
    let (i2, id2, p2) = y in
    Int.equal i1 i2 &amp;&amp; Id.equal id1 id2 &amp;&amp; DirPath.equal p1 p2

  let to_id (_, s, _) = s

  open Hashset.Combine

  let hash (i, id, dp) =
    combine3 (Int.hash i) (Id.hash id) (DirPath.hash dp)

  module Self_Hashcons =
    struct
      type nonrec t = t
      type u = (Id.t -&gt; Id.t) * (DirPath.t -&gt; DirPath.t)
      let hashcons (hid,hdir) (n,s,dir) = (n,hid s,hdir dir)
      let eq ((n1,s1,dir1) as x) ((n2,s2,dir2) as y) =
        (x == y) ||
        (Int.equal n1 n2 &amp;&amp; s1 == s2 &amp;&amp; dir1 == dir2)
      let hash = hash
    end

  module HashMBId = Hashcons.Make(Self_Hashcons)

  let hcons = Hashcons.simple_hcons HashMBId.generate HashMBId.hcons (Id.hcons, DirPath.hcons)

end

module MBImap = CMap.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">MBId</abbr>)
module MBIset = Set.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">MBId</abbr>)

(** {6 Names of structure elements } *)

module Label =
struct
  include Id
  let make = Id.of_string
  let of_id id = id
  let to_id id = id
end

(** {6 The module part of the kernel name } *)

module ModPath = struct

  type t =
    | MPfile of DirPath.t
    | MPbound of MBId.t
    | MPdot of t * Label.t

  type module_path = t

  let rec is_bound = function
    | MPbound _ -&gt; true
    | MPdot(mp,_) -&gt; is_bound mp
    | _ -&gt; false

  let rec to_string = function
    | MPfile sl -&gt; DirPath.to_string sl
    | MPbound uid -&gt; MBId.to_string uid
    | MPdot (mp,l) -&gt; to_string mp ^ &quot;.&quot; ^ Label.to_string l

  let rec debug_to_string = function
    | MPfile sl -&gt; DirPath.to_string sl
    | MPbound uid -&gt; MBId.debug_to_string uid
    | MPdot (mp,l) -&gt; debug_to_string mp ^ &quot;.&quot; ^ Label.to_string l

  (** we compare labels first if both are MPdots *)
  let rec compare mp1 mp2 =
    if mp1 == mp2 then 0
    else match mp1, mp2 with
      | MPfile p1, MPfile p2 -&gt; DirPath.compare p1 p2
      | MPbound id1, MPbound id2 -&gt; MBId.compare id1 id2
      | MPdot (mp1, l1), MPdot (mp2, l2) -&gt;
        let c = String.compare l1 l2 in
        if not (Int.equal c 0) then c
        else compare mp1 mp2
      | MPfile _, _ -&gt; -1
      | MPbound _, MPfile _ -&gt; 1
      | MPbound _, MPdot _ -&gt; -1
      | MPdot _, _ -&gt; 1

  let rec equal mp1 mp2 = mp1 == mp2 ||
    match mp1, mp2 with
    | MPfile p1, MPfile p2 -&gt; DirPath.equal p1 p2
    | MPbound id1, MPbound id2 -&gt; MBId.equal id1 id2
    | MPdot (mp1, l1), MPdot (mp2, l2) -&gt; String.equal l1 l2 &amp;&amp; equal mp1 mp2
    | (MPfile _ | MPbound _ | MPdot _), _ -&gt; false

  open Hashset.Combine

  let rec hash = function
  | MPfile dp -&gt; combinesmall 1 (DirPath.hash dp)
  | MPbound id -&gt; combinesmall 2 (MBId.hash id)
  | MPdot (mp, lbl) -&gt;
    combinesmall 3 (combine (hash mp) (Label.hash lbl))

  let initial = MPfile DirPath.initial

  let rec dp = function
  | MPfile sl -&gt; sl
  | MPbound (_,_,dp) -&gt; dp
  | MPdot (mp,_l) -&gt; dp mp

  module Self_Hashcons = struct
    type t = module_path
    type u = (DirPath.t -&gt; DirPath.t) * (MBId.t -&gt; MBId.t) *
        (string -&gt; string)
    let rec hashcons (hdir,huniqid,hstr as hfuns) = function
      | MPfile dir -&gt; MPfile (hdir dir)
      | MPbound m -&gt; MPbound (huniqid m)
      | MPdot (md,l) -&gt; MPdot (hashcons hfuns md, hstr l)
    let eq d1 d2 =
      d1 == d2 ||
      match d1,d2 with
      | MPfile dir1, MPfile dir2 -&gt; dir1 == dir2
      | MPbound m1, MPbound m2 -&gt; m1 == m2
      | MPdot (mod1,l1), MPdot (mod2,l2) -&gt; l1 == l2 &amp;&amp; equal mod1 mod2
      | _ -&gt; false
    let hash = hash
  end

  module HashMP = Hashcons.Make(Self_Hashcons)

  let hcons =
    Hashcons.simple_hcons HashMP.generate HashMP.hcons
      (DirPath.hcons,MBId.hcons,String.hcons)

end

module MPset = Set.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ModPath</abbr>)
module MPmap = CMap.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ModPath</abbr>)

(** {6 Kernel names } *)

module KerName = struct

  type t = {
    modpath : ModPath.t;
    knlabel : Label.t;
    mutable refhash : int;
    (** Lazily computed hash. If unset, it is set to negative values. *)
  }

  type kernel_name = t

  let make modpath knlabel =
    { modpath; knlabel; refhash = -1; }
  let repr kn = (kn.modpath, kn.knlabel)

  let make2 = make
  [@@ocaml.deprecated &quot;Please use [KerName.make]&quot;]

  let modpath kn = kn.modpath
  let label kn = kn.knlabel

  let to_string_gen mp_to_string kn =
    mp_to_string kn.modpath ^ &quot;.&quot; ^ Label.to_string kn.knlabel

  let to_string kn = to_string_gen ModPath.to_string kn

  let debug_to_string kn = to_string_gen ModPath.debug_to_string kn

  let print kn = str (to_string kn)

  let debug_print kn = str (debug_to_string kn)

  let compare (kn1 : kernel_name) (kn2 : kernel_name) =
    if kn1 == kn2 then 0
    else
      let c = String.compare kn1.knlabel kn2.knlabel in
      if not (Int.equal c 0) then c
      else
        ModPath.compare kn1.modpath kn2.modpath

  let equal kn1 kn2 =
    let h1 = kn1.refhash in
    let h2 = kn2.refhash in
    if 0 &lt;= h1 &amp;&amp; 0 &lt;= h2 &amp;&amp; not (Int.equal h1 h2) then false
    else
      Label.equal kn1.knlabel kn2.knlabel &amp;&amp;
      ModPath.equal kn1.modpath kn2.modpath

  open Hashset.Combine

  let hash kn =
    let h = kn.refhash in
    if h &lt; 0 then
      let { modpath = mp; knlabel = lbl; _ } = kn in
      let h = combine (ModPath.hash mp) (Label.hash lbl) in
      (* Ensure positivity on all platforms. *)
      let h = h land 0x3FFFFFFF in
      let () = <abbr class="mark-warning" title="Set record field not handled.">kn.refhash &lt;- h</abbr> in
      h
    else h

  module Self_Hashcons = struct
    type t = kernel_name
    type u = (ModPath.t -&gt; ModPath.t) * (DirPath.t -&gt; DirPath.t)
        * (string -&gt; string)
    let hashcons (hmod,_hdir,hstr) kn =
      let { modpath = mp; knlabel = l; refhash; } = kn in
      { modpath = hmod mp; knlabel = hstr l; refhash; }
    let eq kn1 kn2 =
      kn1.modpath == kn2.modpath &amp;&amp; kn1.knlabel == kn2.knlabel
    let hash = hash
  end

  module HashKN = Hashcons.Make(Self_Hashcons)

  let hcons =
    Hashcons.simple_hcons HashKN.generate HashKN.hcons
      (ModPath.hcons,DirPath.hcons,String.hcons)
end

module KNmap = HMap.Make(KerName)
module KNpred = Predicate.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">KerName</abbr>)
module KNset = KNmap.Set

(** {6 Kernel pairs } *)

(** For constant and inductive names, we use a kernel name couple (kn1,kn2)
   where kn1 corresponds to the name used at toplevel (i.e. what the user see)
   and kn2 corresponds to the canonical kernel name i.e. in the environment
   we have {% kn1 \rhd_{\delta}^* kn2 \rhd_{\delta} t %}

   Invariants :
    - the user and canonical kn may differ only on their [module_path],
      the dirpaths and labels should be the same
    - when user and canonical parts differ, we cannot be in a section
      anymore, hence the dirpath must be empty
    - two pairs with the same user part should have the same canonical part
      in a given environment (though with backtracking, the hash-table can
      contains pairs with same user part but different canonical part from
      a previous state of the session)

   Note: since most of the time the canonical and user parts are equal,
   we handle this case with a particular constructor to spare some memory *)

module KerPair = struct

  type t =
    | Same of KerName.t (** user = canonical *)
    | Dual of KerName.t * KerName.t (** user then canonical *)

  type kernel_pair = t

  let canonical = function
    | Same kn -&gt; kn
    | Dual (_,kn) -&gt; kn

  let user = function
    | Same kn -&gt; kn
    | Dual (kn,_) -&gt; kn

  let same kn = Same kn
  let make knu knc = if KerName.equal knu knc then Same knc else Dual (knu,knc)

  let make1 = same
  let make2 mp l = same (KerName.make mp l)
  let repr2 kp = KerName.repr (user kp)
  let label kp = KerName.label (user kp)
  let modpath kp = KerName.modpath (user kp)

  let change_label kp lbl =
    let <abbr class="mark-warning" title="A variable name instead of a pattern was expected.">(mp1,l1)</abbr> = KerName.repr (user kp)
    and <abbr class="mark-warning" title="A variable name instead of a pattern was expected.">(mp2,l2)</abbr> = KerName.repr (canonical kp) in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (String.equal l1 l2);
    if String.equal lbl l1 then kp
    else
      let kn = KerName.make mp1 lbl in
      if mp1 == mp2 then same kn
      else make kn (KerName.make mp2 lbl)</abbr>

  let to_string kp = KerName.to_string (user kp)
  let print kp = str (to_string kp)

  let debug_to_string = function
    | Same kn -&gt; &quot;(&quot; ^ KerName.debug_to_string kn ^ &quot;)&quot;
    | Dual (knu,knc) -&gt;
      &quot;(&quot; ^ KerName.debug_to_string knu ^ &quot;,&quot; ^ KerName.debug_to_string knc ^ &quot;)&quot;

  let debug_print kp = str (debug_to_string kp)

  (** For ordering kernel pairs, both user or canonical parts may make
      sense, according to your needs: user for the environments, canonical
      for other uses (ex: non-logical things). *)

  module UserOrd = struct
    type t = kernel_pair
    let compare x y = KerName.compare (user x) (user y)
    let equal x y = x == y || KerName.equal (user x) (user y)
    let hash x = KerName.hash (user x)
  end

  module CanOrd = struct
    type t = kernel_pair
    let compare x y = KerName.compare (canonical x) (canonical y)
    let equal x y = x == y || KerName.equal (canonical x) (canonical y)
    let hash x = KerName.hash (canonical x)
  end

  module SyntacticOrd = struct
    let compare x y = match x, y with
      | Same knx, Same kny -&gt; KerName.compare knx kny
      | Dual (knux,kncx), Dual (knuy,kncy) -&gt;
        let c = KerName.compare knux knuy in
        if not (Int.equal c 0) then c
        else KerName.compare kncx kncy
      | Same _, _ -&gt; -1
      | Dual _, _ -&gt; 1
    let equal x y = x == y || compare x y = 0
    let hash = function
      | Same kn -&gt; KerName.hash kn
      | Dual (knu, knc) -&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
  end

  (** Default (logical) comparison and hash is on the canonical part *)
  let equal = CanOrd.equal
  let hash = CanOrd.hash

  module Self_Hashcons =
    struct
      type t = kernel_pair
      type u = KerName.t -&gt; KerName.t
      let hashcons hkn = function
        | Same kn -&gt; Same (hkn kn)
        | Dual (knu,knc) -&gt; make (hkn knu) (hkn knc)
      let eq x y = (* physical comparison on subterms *)
        x == y ||
        match x,y with
        | Same x, Same y -&gt; x == y
        | Dual (ux,cx), Dual (uy,cy) -&gt; ux == uy &amp;&amp; cx == cy
        | (Same _ | Dual _), _ -&gt; false
      (** Hash-consing (despite having the same user part implies having
          the same canonical part is a logical invariant of the system, it
          is not necessarily an invariant in memory, so we treat kernel
          names as they are syntactically for hash-consing) *)
      let hash = function
      | Same kn -&gt; KerName.hash kn
      | Dual (knu, knc) -&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
    end

  module HashKP = Hashcons.Make(Self_Hashcons)

end

(** {6 Constant Names} *)

module Constant = KerPair

module Cmap = HMap.Make(Constant.CanOrd)
(** A map whose keys are constants (values of the {!Constant.t} type).
    Keys are ordered wrt. &quot;canonical form&quot; of the constant. *)

module Cmap_env = HMap.Make(Constant.UserOrd)
(** A map whose keys are constants (values of the {!Constant.t} type).
    Keys are ordered wrt. &quot;user form&quot; of the constant. *)

module Cpred = Predicate.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Constant.CanOrd</abbr>)
module Cset = Cmap.Set
module Cset_env = Cmap_env.Set

(** {6 Names of mutual inductive types } *)

module MutInd = KerPair

module Mindmap = HMap.Make(MutInd.CanOrd)
module Mindset = Mindmap.Set
module Mindmap_env = HMap.Make(MutInd.UserOrd)

(** Designation of a (particular) inductive type. *)
type inductive = MutInd.t      (* the name of the inductive type *)
               * int           (* the position of this inductive type
                                  within the block of mutually-recursive inductive types.
                                  BEWARE: indexing starts from 0. *)

(** Designation of a (particular) constructor of a (particular) inductive type. *)
type constructor = inductive   (* designates the inductive type *)
                 * int         (* the index of the constructor
                                  BEWARE: indexing starts from 1. *)

let ind_modpath (mind,_) = MutInd.modpath mind
let constr_modpath (ind,_) = ind_modpath ind

let ith_mutual_inductive (mind, _) i = (mind, i)
let ith_constructor_of_inductive ind i = (ind, i)
let inductive_of_constructor (ind, _i) = ind
let index_of_constructor (_ind, i) = i

let eq_ind (m1, i1) (m2, i2) = Int.equal i1 i2 &amp;&amp; MutInd.equal m1 m2
let eq_user_ind (m1, i1) (m2, i2) =
  Int.equal i1 i2 &amp;&amp; MutInd.UserOrd.equal m1 m2
let eq_syntactic_ind (m1, i1) (m2, i2) =
  Int.equal i1 i2 &amp;&amp; MutInd.SyntacticOrd.equal m1 m2

let ind_ord (m1, i1) (m2, i2) =
  let c = Int.compare i1 i2 in
  if Int.equal c 0 then MutInd.CanOrd.compare m1 m2 else c
let ind_user_ord (m1, i1) (m2, i2) =
  let c = Int.compare i1 i2 in
  if Int.equal c 0 then MutInd.UserOrd.compare m1 m2 else c
let ind_syntactic_ord (m1, i1) (m2, i2) =
  let c = Int.compare i1 i2 in
  if Int.equal c 0 then MutInd.SyntacticOrd.compare m1 m2 else c

let ind_hash (m, i) =
  Hashset.Combine.combine (MutInd.hash m) (Int.hash i)
let ind_user_hash (m, i) =
  Hashset.Combine.combine (MutInd.UserOrd.hash m) (Int.hash i)
let ind_syntactic_hash (m, i) =
  Hashset.Combine.combine (MutInd.SyntacticOrd.hash m) (Int.hash i)

let eq_constructor (ind1, j1) (ind2, j2) = Int.equal j1 j2 &amp;&amp; eq_ind ind1 ind2
let eq_user_constructor (ind1, j1) (ind2, j2) =
  Int.equal j1 j2 &amp;&amp; eq_user_ind ind1 ind2
let eq_syntactic_constructor (ind1, j1) (ind2, j2) =
  Int.equal j1 j2 &amp;&amp; eq_syntactic_ind ind1 ind2

let constructor_ord (ind1, j1) (ind2, j2) =
  let c = Int.compare j1 j2 in
  if Int.equal c 0 then ind_ord ind1 ind2 else c
let constructor_user_ord (ind1, j1) (ind2, j2) =
  let c = Int.compare j1 j2 in
  if Int.equal c 0 then ind_user_ord ind1 ind2 else c
let constructor_syntactic_ord (ind1, j1) (ind2, j2) =
  let c = Int.compare j1 j2 in
  if Int.equal c 0 then ind_syntactic_ord ind1 ind2 else c

let constructor_hash (ind, i) =
  Hashset.Combine.combine (ind_hash ind) (Int.hash i)
let constructor_user_hash (ind, i) =
  Hashset.Combine.combine (ind_user_hash ind) (Int.hash i)
let constructor_syntactic_hash (ind, i) =
  Hashset.Combine.combine (ind_syntactic_hash ind) (Int.hash i)

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module InductiveOrdered = struct
  type t = inductive
  let compare = ind_ord
end</abbr>

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module InductiveOrdered_env = struct
  type t = inductive
  let compare = ind_user_ord
end</abbr>

module Indmap = Map.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">InductiveOrdered</abbr>)
module Indmap_env = Map.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">InductiveOrdered_env</abbr>)

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module ConstructorOrdered = struct
  type t = constructor
  let compare = constructor_ord
end</abbr>

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module ConstructorOrdered_env = struct
  type t = constructor
  let compare = constructor_user_ord
end</abbr>

module Constrmap = Map.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ConstructorOrdered</abbr>)
module Constrmap_env = Map.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CMap.OrderedType, Predicate.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ConstructorOrdered_env</abbr>)

(** {6 Hash-consing of name objects } *)

module Hind = Hashcons.Make(
  struct
    type t = inductive
    type u = MutInd.t -&gt; MutInd.t
    let hashcons hmind (mind, i) = (hmind mind, i)
    let eq (mind1,i1) (mind2,i2) = mind1 == mind2 &amp;&amp; Int.equal i1 i2
    let hash = ind_hash
  end)

module Hconstruct = Hashcons.Make(
  struct
    type t = constructor
    type u = inductive -&gt; inductive
    let hashcons hind (ind, j) = (hind ind, j)
    let eq (ind1, j1) (ind2, j2) = ind1 == ind2 &amp;&amp; Int.equal j1 j2
    let hash = constructor_hash
  end)

let hcons_con = Hashcons.simple_hcons Constant.HashKP.generate Constant.HashKP.hcons KerName.hcons
let hcons_mind = Hashcons.simple_hcons MutInd.HashKP.generate MutInd.HashKP.hcons KerName.hcons
let hcons_ind = Hashcons.simple_hcons Hind.generate Hind.hcons hcons_mind
let hcons_construct = Hashcons.simple_hcons Hconstruct.generate Hconstruct.hcons hcons_ind

(*****************)

type 'a tableKey =
  | ConstKey of 'a
  | VarKey of Id.t
  | RelKey of Int.t

type inv_rel_key = int (* index in the [rel_context] part of environment
                          starting by the end, {\em inverse}
                          of de Bruijn indice *)

let eq_table_key f ik1 ik2 =
  if ik1 == ik2 then true
  else match ik1,ik2 with
  | ConstKey c1, ConstKey c2 -&gt; f c1 c2
  | VarKey id1, VarKey id2 -&gt; Id.equal id1 id2
  | RelKey k1, RelKey k2 -&gt; Int.equal k1 k2
  | _ -&gt; false

let eq_mind_chk = MutInd.UserOrd.equal
let eq_ind_chk (kn1,i1) (kn2,i2) = Int.equal i1 i2 &amp;&amp; eq_mind_chk kn1 kn2

(*******************************************************************)
(** Compatibility layers *)

let eq_constant_key = Constant.UserOrd.equal

(** Compatibility layer for [ModPath] *)

type module_path = ModPath.t =
  | MPfile of DirPath.t
  | MPbound of MBId.t
  | MPdot of module_path * Label.t

(** Compatibility layer for [Constant] *)

module Projection =
struct
  module Repr = struct
    type t =
      { proj_ind : inductive;
        proj_npars : int;
        proj_arg : int;
        proj_name : Label.t; }

    let make proj_ind ~proj_npars ~proj_arg proj_name =
      {proj_ind;proj_npars;proj_arg;proj_name}

    let inductive c = c.proj_ind

    let mind c = fst c.proj_ind

    let constant c = KerPair.change_label (mind c) c.proj_name

    let label c = c.proj_name

    let npars c = c.proj_npars

    let arg c = c.proj_arg

    let equal a b =
      eq_ind a.proj_ind b.proj_ind &amp;&amp; Int.equal a.proj_arg b.proj_arg

    let hash p =
      Hashset.Combine.combinesmall p.proj_arg (ind_hash p.proj_ind)

    module SyntacticOrd = struct
      let compare a b =
        let c = ind_syntactic_ord a.proj_ind b.proj_ind in
        if c == 0 then Int.compare a.proj_arg b.proj_arg
        else c

      let equal a b =
        a.proj_arg == b.proj_arg &amp;&amp; eq_syntactic_ind a.proj_ind b.proj_ind

      let hash p =
        Hashset.Combine.combinesmall p.proj_arg (ind_hash p.proj_ind)
    end
    module CanOrd = struct
      let compare a b =
        let c = ind_ord a.proj_ind b.proj_ind in
        if c == 0 then Int.compare a.proj_arg b.proj_arg
        else c

      let equal a b =
        a.proj_arg == b.proj_arg &amp;&amp; eq_ind a.proj_ind b.proj_ind

      let hash p =
        Hashset.Combine.combinesmall p.proj_arg (ind_hash p.proj_ind)
    end
    module UserOrd = struct
      let compare a b =
        let c = ind_user_ord a.proj_ind b.proj_ind in
        if c == 0 then Int.compare a.proj_arg b.proj_arg
        else c

      let equal a b =
        a.proj_arg == b.proj_arg &amp;&amp; eq_user_ind a.proj_ind b.proj_ind

      let hash p =
        Hashset.Combine.combinesmall p.proj_arg (ind_user_hash p.proj_ind)
    end

    let compare a b =
      let c = ind_ord a.proj_ind b.proj_ind in
      if c == 0 then Int.compare a.proj_arg b.proj_arg
      else c

    module Self_Hashcons = struct
      type nonrec t = t
      type u = (inductive -&gt; inductive) * (Id.t -&gt; Id.t)
      let hashcons (hind,hid) p =
        { proj_ind = hind p.proj_ind;
          proj_npars = p.proj_npars;
          proj_arg = p.proj_arg;
          proj_name = hid p.proj_name }
      let eq p p' =
        p == p' || (p.proj_ind == p'.proj_ind &amp;&amp; p.proj_npars == p'.proj_npars &amp;&amp; p.proj_arg == p'.proj_arg &amp;&amp; p.proj_name == p'.proj_name)
      let hash = hash
    end
    module HashRepr = Hashcons.Make(Self_Hashcons)
    let hcons = Hashcons.simple_hcons HashRepr.generate HashRepr.hcons (hcons_ind,Id.hcons)

    let map_npars f p =
      let ind = fst p.proj_ind in
      let npars = p.proj_npars in
      let ind', npars' = f ind npars in
      if ind == ind' &amp;&amp; npars == npars' then p
      else {p with proj_ind = (ind',snd p.proj_ind); proj_npars = npars'}

    let map f p = map_npars (fun mind n -&gt; f mind, n) p

    let to_string p = Constant.to_string (constant p)
    let print p = Constant.print (constant p)
  end

  type t = Repr.t * bool

  let make c b = (c, b)

  let mind (c,_) = Repr.mind c
  let inductive (c,_) = Repr.inductive c
  let npars (c,_) = Repr.npars c
  let arg (c,_) = Repr.arg c
  let constant (c,_) = Repr.constant c
  let label (c,_) = Repr.label c
  let repr = fst
  let unfolded = snd
  let unfold (c, b as p) = if b then p else (c, true)

  let equal (c, b) (c', b') = Repr.equal c c' &amp;&amp; b == b'

  let repr_equal p p' = Repr.equal (repr p) (repr p')

  let hash (c, b) = (if b then 0 else 1) + Repr.hash c

  module SyntacticOrd = struct
    let compare (c, b) (c', b') =
      if b = b' then Repr.SyntacticOrd.compare c c' else -1
    let equal (c, b as x) (c', b' as x') =
      x == x' || b = b' &amp;&amp; Repr.SyntacticOrd.equal c c'
    let hash (c, b) = (if b then 0 else 1) + Repr.SyntacticOrd.hash c
  end
  module CanOrd = struct
    let compare (c, b) (c', b') =
      if b = b' then Repr.CanOrd.compare c c' else -1
    let equal (c, b as x) (c', b' as x') =
      x == x' || b = b' &amp;&amp; Repr.CanOrd.equal c c'
    let hash (c, b) = (if b then 0 else 1) + Repr.CanOrd.hash c
  end

  module Self_Hashcons =
    struct
      type nonrec t = t
      type u = Repr.t -&gt; Repr.t
      let hashcons hc (c,b) = (hc c,b)
      let eq ((c,b) as x) ((c',b') as y) =
        x == y || (c == c' &amp;&amp; b == b')
      let hash = hash
    end

  module HashProjection = Hashcons.Make(Self_Hashcons)

  let hcons = Hashcons.simple_hcons HashProjection.generate HashProjection.hcons Repr.hcons

  let compare (c, b) (c', b') =
    if b == b' then Repr.compare c c'
    else if b then 1 else -1

  let map f (c, b as x) =
    let c' = Repr.map f c in
    if c' == c then x else (c', b)

  let map_npars f (c, b as x) =
    let c' = Repr.map_npars f c in
    if c' == c then x else (c', b)

  let to_string p = Constant.to_string (constant p)
  let print p = Constant.print (constant p)

end

module GlobRefInternal = struct

  type t =
    | VarRef of variable           (** A reference to the section-context. *)
    | ConstRef of Constant.t       (** A reference to the environment. *)
    | IndRef of inductive          (** A reference to an inductive type. *)
    | ConstructRef of constructor  (** A reference to a constructor of an inductive type. *)

  let equal gr1 gr2 =
    gr1 == gr2 || match gr1,gr2 with
    | ConstRef con1, ConstRef con2 -&gt; Constant.equal con1 con2
    | IndRef kn1, IndRef kn2 -&gt; eq_ind kn1 kn2
    | ConstructRef kn1, ConstructRef kn2 -&gt; eq_constructor kn1 kn2
    | VarRef v1, VarRef v2 -&gt; Id.equal v1 v2
    | (ConstRef _ | IndRef _ | ConstructRef _ | VarRef _), _ -&gt; false

  let global_eq_gen eq_cst eq_ind eq_cons x y =
    x == y ||
    match x, y with
    | ConstRef cx, ConstRef cy -&gt; eq_cst cx cy
    | IndRef indx, IndRef indy -&gt; eq_ind indx indy
    | ConstructRef consx, ConstructRef consy -&gt; eq_cons consx consy
    | VarRef v1, VarRef v2 -&gt; Id.equal v1 v2
    | (VarRef _ | ConstRef _ | IndRef _ | ConstructRef _), _ -&gt; false

  let global_ord_gen ord_cst ord_ind ord_cons x y =
    if x == y then 0
    else match x, y with
    | VarRef v1, VarRef v2 -&gt; Id.compare v1 v2
    | VarRef _, _ -&gt; -1
    | _, VarRef _ -&gt; 1
    | ConstRef cx, ConstRef cy -&gt; ord_cst cx cy
    | ConstRef _, _ -&gt; -1
    | _, ConstRef _ -&gt; 1
    | IndRef indx, IndRef indy -&gt; ord_ind indx indy
    | IndRef _, _ -&gt; -1
    | _ , IndRef _ -&gt; 1
    | ConstructRef consx, ConstructRef consy -&gt; ord_cons consx consy

  let global_hash_gen hash_cst hash_ind hash_cons gr =
    let open Hashset.Combine in
    match gr with
    | ConstRef c -&gt; combinesmall 1 (hash_cst c)
    | IndRef i -&gt; combinesmall 2 (hash_ind i)
    | ConstructRef c -&gt; combinesmall 3 (hash_cons c)
    | VarRef id -&gt; combinesmall 4 (Id.hash id)

end

module GlobRef = struct

  type t = GlobRefInternal.t =
    | VarRef of variable           (** A reference to the section-context. *)
    | ConstRef of Constant.t       (** A reference to the environment. *)
    | IndRef of inductive          (** A reference to an inductive type. *)
    | ConstructRef of constructor  (** A reference to a constructor of an inductive type. *)

  let equal = GlobRefInternal.equal

  (* By default, [global_reference] are ordered on their canonical part *)

  module Ordered = struct
    open Constant.CanOrd
    type t = GlobRefInternal.t
    let compare gr1 gr2 =
      GlobRefInternal.global_ord_gen compare ind_ord constructor_ord gr1 gr2
    let equal gr1 gr2 = GlobRefInternal.global_eq_gen equal eq_ind eq_constructor gr1 gr2
    let hash gr = GlobRefInternal.global_hash_gen hash ind_hash constructor_hash gr
  end

  module Ordered_env = struct
    open Constant.UserOrd
    type t = GlobRefInternal.t
    let compare gr1 gr2 =
      GlobRefInternal.global_ord_gen compare ind_user_ord constructor_user_ord gr1 gr2
    let equal gr1 gr2 =
      GlobRefInternal.global_eq_gen equal eq_user_ind eq_user_constructor gr1 gr2
    let hash gr = GlobRefInternal.global_hash_gen hash ind_user_hash constructor_user_hash gr
  end

  module Map = HMap.Make(Ordered)
  module Set = Map.Set

  (* Alternative sets and maps indexed by the user part of the kernel names *)

  module Map_env = HMap.Make(Ordered_env)
  module Set_env = Map_env.Set

end

type evaluable_global_reference =
  | EvalVarRef of Id.t
  | EvalConstRef of Constant.t

(* Better to have it here that in closure, since used in grammar.cma *)
let eq_egr e1 e2 = match e1, e2 with
    EvalConstRef con1, EvalConstRef con2 -&gt; Constant.equal con1 con2
  | EvalVarRef id1, EvalVarRef id2 -&gt; Id.equal id1 id2
  | _, _ -&gt; false

(** Located identifiers and objects with syntax. *)

type lident = Id.t CAst.t
type lname = Name.t CAst.t
type lstring = string CAst.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#names.ml"><code>Names.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Pp.

Import Util.

Module Id.
  Definition t := string.
  
  Definition equal
    : (|Util.String|).(CString.ExtS.t) -&gt; (|Util.String|).(CString.ExtS.t) -&gt;
    bool := (|Util.String|).(CString.ExtS.equal).
  
  Definition compare
    : (|Util.String|).(CString.ExtS.t) -&gt; (|Util.String|).(CString.ExtS.t) -&gt; Z :=
    (|Util.String|).(CString.ExtS.compare).
  
  Definition hash : string -&gt; Z := (|Util.String|).(CString.ExtS.hash).
  
  Definition check_valid (op_staroptstar : option bool) : string -&gt; unit :=
    let strict :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; true
      end in
    fun x =&gt;
      let iter (function_parameter : bool * string) : unit :=
        let '(fatal, x) := function_parameter in
        if orb fatal strict then
          CErrors.user_err None None (str x)
        else
          tt in
      Option.iter iter (Unicode.ident_refutation x).
  
  Definition is_valid (s : string) : bool :=
    match Unicode.ident_refutation s with
    | None =&gt; true
    | Some _ =&gt; false
    end.
  
  Definition of_bytes (s : string) : string :=
    let s := Stdlib.Bytes.to_string s in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Util.String|).(CString.ExtS.hcons) s.
  
  Definition of_string (s : string) : string :=
    let '_ := check_valid None s in
    (|Util.String|).(CString.ExtS.hcons) s.
  
  Definition of_string_soft (s : string) : string :=
    let '_ := check_valid (Some false) s in
    (|Util.String|).(CString.ExtS.hcons) s.
  
  Definition to_string {A : Set} (id : A) : A := id.
  
  Definition print (id : string) : Pp.t := str id.
  
  Definition Self :=
    let t := string in
    existT (fun _ =&gt; _) tt
      {|
        Util.__Set.OrderedType.compare := compare
      |}.
  
  Definition __Set :=
    __Set.Make
      (existT _ _
        {|
          Util.__Set.OrderedType.compare :=
            (|Self|).(Util.__Set.OrderedType.compare)
        |}).
  
  Definition Map :=
    CMap.Make
      (existT _ _
        {|
          CMap.OrderedType.compare := (|Self|).(CMap.OrderedType.compare)
        |}).
  
  Definition Pred :=
    Predicate.Make
      (existT _ _
        {|
          CMap.OrderedType.compare := (|Self|).(CMap.OrderedType.compare)
        |}).
  
  Module List := String.List.
  
  Definition hcons : string -&gt; string := (|Util.String|).(CString.ExtS.hcons).
End Id.

Module Name.
  Inductive t : Set :=
  | Anonymous : t
  | Name : Id.t -&gt; t.
  
  Definition mk_name (id : Id.t) : t := Name id.
  
  Definition is_anonymous (function_parameter : t) : bool :=
    match function_parameter with
    | Anonymous =&gt; true
    | Name _ =&gt; false
    end.
  
  Definition is_name : t -&gt; bool := op_percentgt is_anonymous negb.
  
  Definition compare (n1 : t) (n2 : t) : Z :=
    match (n1, n2) with
    | (Anonymous, Anonymous) =&gt; 0
    | (Name id1, Name id2) =&gt; Id.compare id1 id2
    | (Anonymous, Name _) =&gt; (-1)
    | (Name _, Anonymous) =&gt; 1
    end.
  
  Definition equal (n1 : t) (n2 : t) : bool :=
    match (n1, n2) with
    | (Anonymous, Anonymous) =&gt; true
    | (Name id1, Name id2) =&gt; (|Util.String|).(CString.ExtS.equal) id1 id2
    | _ =&gt; false
    end.
  
  Definition hash (function_parameter : t) : Z :=
    match function_parameter with
    | Anonymous =&gt; 0
    | Name id =&gt; Id.hash id
    end.
  
  Definition print (function_parameter : t) : Pp.t :=
    match function_parameter with
    | Anonymous =&gt; str &quot;_&quot;
    | Name id =&gt; Id.print id
    end.
  
  Module Self_Hashcons.
    Definition t := t.
    
    Definition u := Id.t -&gt; Id.t.
    
    Definition hashcons (hident : Id.t -&gt; Id.t) (function_parameter : t) : t :=
      match function_parameter with
      | Name id =&gt; Name (hident id)
      | n =&gt; n
      end.
    
    Definition eq (n1 : t) (n2 : t) : bool :=
      orb (Stdlib.op_eqeq n1 n2)
        match (n1, n2) with
        | (Name id1, Name id2) =&gt; Stdlib.op_eqeq id1 id2
        | (Anonymous, Anonymous) =&gt; true
        | _ =&gt; false
        end.
    
    Definition hash : t -&gt; Z := hash.
  End Self_Hashcons.
  
  Definition Hname :=
    Hashcons.Make
      (existT _ [_, _]
        {|
          Hashcons.HashconsedType.hashcons :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hashcons);
          Hashcons.HashconsedType.eq :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.eq);
          Hashcons.HashconsedType.hash :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hash)
        |}).
  
  Definition hcons : (|Hname|).(Hashcons.S.t) -&gt; (|Hname|).(Hashcons.S.t) :=
    Hashcons.simple_hcons (|Hname|).(Hashcons.S.generate)
      (|Hname|).(Hashcons.S.hcons) Id.hcons.
End Name.

Inductive name : Set :=
| Anonymous : name
| Name : Id.t -&gt; name.

Definition variable := Id.t.

Definition module_ident := Id.t.

Module ModIdset := Id.__Set.

Module ModIdmap := Id.Map.

Definition default_module_name : string := &quot;If you see this, it's a bug&quot;.

Module DirPath.
  Definition t := list module_ident.
  
  Definition compare
    : (|CList|).(CList.ExtS.cmp) (list (|Util.String|).(CString.ExtS.t)) :=
    (|Util.List|).(CList.ExtS.compare) Id.compare.
  
  Definition equal
    : (|CList|).(CList.ExtS.eq) (list (|Util.String|).(CString.ExtS.t)) :=
    (|Util.List|).(CList.ExtS.equal) Id.equal.
  
  Fixpoint hash (accu : Z) (function_parameter : list string) {struct accu}
    : Z :=
    match function_parameter with
    | [] =&gt; accu
    | cons id dp =&gt;
      let accu := Hashset.Combine.combine (Id.hash id) accu in
      hash accu dp
    end.
  
  Definition hash (dp : list string) : Z := hash 0 dp.
  
  Definition make {A : Set} (x : A) : A := x.
  
  Definition repr {A : Set} (x : A) : A := x.
  
  Definition empty {A : Set} : list A := [].
  
  Definition is_empty {A : Set} : list A -&gt; bool :=
    (|Util.List|).(CList.ExtS.is_empty).
  
  Definition to_string (function_parameter : list string) : string :=
    match function_parameter with
    | [] =&gt; &quot;&lt;&gt;&quot;
    | sl =&gt;
      (|Util.String|).(CString.ExtS.concat) &quot;.&quot;
        ((|Util.List|).(CList.ExtS.rev_map) Id.to_string sl)
    end.
  
  Definition print (dp : list string) : Pp.t := str (to_string dp).
  
  Definition initial : list string := [ default_module_name ].
  
  Definition Hdir :=
    Hashcons.Hlist
      (existT _ _
        {|
          Hashcons.HashedType.hash := Id.hash
        |}).
  
  Definition hcons : (|Hdir|).(Hashcons.S.t) -&gt; (|Hdir|).(Hashcons.S.t) :=
    Hashcons.recursive_hcons (|Hdir|).(Hashcons.S.generate)
      (|Hdir|).(Hashcons.S.hcons) Id.hcons.
End DirPath.

Module MBId.
  Definition t := Z * Id.t * DirPath.t.
  
  Definition gen : unit -&gt; Z :=
    let seed := Stdlib.__ref_value 0 in
    fun function_parameter =&gt;
      let '_ := function_parameter in
      let ans := Stdlib.op_exclamation seed in
      let '_ := Stdlib.incr seed in
      ans.
  
  Definition make {A B : Set} (dir : A) (s : B) : Z * B * A :=
    ((gen tt), s, dir).
  
  Definition repr {A : Set} (mbid : A) : A := mbid.
  
  Definition to_string {A : Set} (function_parameter : A * string * list string)
    : string :=
    let '(_i, s, p) := function_parameter in
    String.append (DirPath.to_string p) (String.append &quot;.&quot; s).
  
  Definition debug_to_string (function_parameter : Z * string * list string)
    : string :=
    let '(i, s, p) := function_parameter in
    String.append &quot;&lt;&quot;
      (String.append (DirPath.to_string p)
        (String.append &quot;#&quot;
          (String.append s
            (String.append &quot;#&quot;
              (String.append (OCaml.Stdlib.string_of_int i) &quot;&gt;&quot;))))).
  
  Definition compare (x : t) (y : t) : Z :=
    if Stdlib.op_eqeq x y then
      0
    else
      let '((nl, idl, dpl), (nr, idr, dpr)) := (x, y) in
      let ans := Int.compare nl nr in
      if negb (Int.equal ans 0) then
        ans
      else
        let ans := Id.compare idl idr in
        if negb (Int.equal ans 0) then
          ans
        else
          DirPath.compare dpl dpr.
  
  Definition equal
    (x :
      Int.t * (|Util.String|).(CString.ExtS.t) *
        list (|Util.String|).(CString.ExtS.t))
    (y :
      Int.t * (|Util.String|).(CString.ExtS.t) *
        list (|Util.String|).(CString.ExtS.t)) : bool :=
    orb (Stdlib.op_eqeq x y)
      (let '(i1, id1, p1) := x in
      let '(i2, id2, p2) := y in
      andb (Int.equal i1 i2) (andb (Id.equal id1 id2) (DirPath.equal p1 p2))).
  
  Definition to_id {A B C : Set} (function_parameter : A * B * C) : B :=
    let '(_, s, _) := function_parameter in
    s.
  
  Import Hashset.Combine.
  
  Definition hash (function_parameter : Int.t * string * list string) : Z :=
    let '(i, id, dp) := function_parameter in
    combine3 (Int.hash i) (Id.hash id) (DirPath.hash dp).
  
  Definition Self_Hashcons :=
    let t := t in
    let u := (Id.t -&gt; Id.t) * (DirPath.t -&gt; DirPath.t) in
    let hashcons {A B C D E : Set} (function_parameter : (A -&gt; B) * (C -&gt; D))
      : E * A * C -&gt; E * B * D :=
      let '(hid, hdir) := function_parameter in
      fun function_parameter =&gt;
        let '(n, s, dir) := function_parameter in
        (n, (hid s), (hdir dir)) in
    let eq {A B : Set} (function_parameter : Int.t * A * B)
      : Int.t * A * B -&gt; bool :=
      let '(n1, s1, dir1) as x := function_parameter in
      fun function_parameter =&gt;
        let '(n2, s2, dir2) as y := function_parameter in
        orb (Stdlib.op_eqeq x y)
          (andb (Int.equal n1 n2)
            (andb (Stdlib.op_eqeq s1 s2) (Stdlib.op_eqeq dir1 dir2))) in
    existT (fun _ =&gt; _) tt
      {|
        Hashcons.HashconsedType.hashcons {_ _ _ _ _} := hashcons;
        Hashcons.HashconsedType.eq {_ _} := eq;
        Hashcons.HashconsedType.hash := hash
      |}.
  
  Definition HashMBId :=
    Hashcons.Make
      (existT _ [_, _]
        {|
          Hashcons.HashconsedType.hashcons :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hashcons);
          Hashcons.HashconsedType.eq :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.eq);
          Hashcons.HashconsedType.hash :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hash)
        |}).
  
  Definition hcons
    : (|HashMBId|).(Hashcons.S.t) -&gt; (|HashMBId|).(Hashcons.S.t) :=
    Hashcons.simple_hcons (|HashMBId|).(Hashcons.S.generate)
      (|HashMBId|).(Hashcons.S.hcons) (Id.hcons, DirPath.hcons).
End MBId.

Definition MBImap :=
  CMap.Make
    (existT _ _
      {|
        CMap.OrderedType.compare := MBId.compare
      |}).

Definition MBIset :=
  __Set.Make
    (existT _ _
      {|
        CMap.OrderedType.compare := MBId.compare
      |}).

Module Label.
  Include Id.
  
  Definition make : string -&gt; string := Id.of_string.
  
  Definition of_id {A : Set} (id : A) : A := id.
  
  Definition to_id {A : Set} (id : A) : A := id.
End Label.

Module ModPath.
  Inductive t : Set :=
  | MPfile : DirPath.t -&gt; t
  | MPbound : MBId.t -&gt; t
  | MPdot : t -&gt; Label.t -&gt; t.
  
  Definition module_path := t.
  
  Fixpoint is_bound (function_parameter : t) {struct function_parameter}
    : bool :=
    match function_parameter with
    | MPbound _ =&gt; true
    | MPdot mp _ =&gt; is_bound mp
    | _ =&gt; false
    end.
  
  Fixpoint to_string (function_parameter : t) {struct function_parameter}
    : string :=
    match function_parameter with
    | MPfile sl =&gt; DirPath.to_string sl
    | MPbound uid =&gt; MBId.to_string uid
    | MPdot mp l =&gt;
      String.append (to_string mp) (String.append &quot;.&quot; (Label.to_string l))
    end.
  
  Fixpoint debug_to_string (function_parameter : t) {struct function_parameter}
    : string :=
    match function_parameter with
    | MPfile sl =&gt; DirPath.to_string sl
    | MPbound uid =&gt; MBId.debug_to_string uid
    | MPdot mp l =&gt;
      String.append (debug_to_string mp) (String.append &quot;.&quot; (Label.to_string l))
    end.
  
  Fixpoint compare (mp1 : t) (mp2 : t) {struct mp1} : Z :=
    if Stdlib.op_eqeq mp1 mp2 then
      0
    else
      match (mp1, mp2) with
      | (MPfile p1, MPfile p2) =&gt; DirPath.compare p1 p2
      | (MPbound id1, MPbound id2) =&gt; MBId.compare id1 id2
      | (MPdot mp1 l1, MPdot mp2 l2) =&gt;
        let c := (|Util.String|).(CString.ExtS.compare) l1 l2 in
        if negb (Int.equal c 0) then
          c
        else
          compare mp1 mp2
      | (MPfile _, _) =&gt; (-1)
      | (MPbound _, MPfile _) =&gt; 1
      | (MPbound _, MPdot _ _) =&gt; (-1)
      | (MPdot _ _, _) =&gt; 1
      end.
  
  Fixpoint equal (mp1 : t) (mp2 : t) {struct mp1} : bool :=
    orb (Stdlib.op_eqeq mp1 mp2)
      match (mp1, mp2) with
      | (MPfile p1, MPfile p2) =&gt; DirPath.equal p1 p2
      | (MPbound id1, MPbound id2) =&gt; MBId.equal id1 id2
      | (MPdot mp1 l1, MPdot mp2 l2) =&gt;
        andb ((|Util.String|).(CString.ExtS.equal) l1 l2) (equal mp1 mp2)
      | (MPfile _ | MPbound _ | MPdot _ _, _) =&gt; false
      end.
  
  Import Hashset.Combine.
  
  Fixpoint hash (function_parameter : t) {struct function_parameter} : Z :=
    match function_parameter with
    | MPfile dp =&gt; combinesmall 1 (DirPath.hash dp)
    | MPbound id =&gt; combinesmall 2 (MBId.hash id)
    | MPdot mp lbl =&gt; combinesmall 3 (combine (hash mp) (Label.hash lbl))
    end.
  
  Definition initial : t := MPfile DirPath.initial.
  
  Fixpoint dp (function_parameter : t) {struct function_parameter}
    : DirPath.t :=
    match function_parameter with
    | MPfile sl =&gt; sl
    | MPbound (_, _, dp) =&gt; dp
    | MPdot mp _l =&gt; dp mp
    end.
  
  Definition Self_Hashcons :=
    let t := module_path in
    let u := (DirPath.t -&gt; DirPath.t) * (MBId.t -&gt; MBId.t) * (string -&gt; string)
      in
    let fix hashcons
      (function_parameter :
        (DirPath.t -&gt; DirPath.t) * (MBId.t -&gt; MBId.t) * (Label.t -&gt; Label.t))
      {struct function_parameter} : t -&gt; t :=
      let '(hdir, huniqid, hstr) as hfuns := function_parameter in
      fun function_parameter =&gt;
        match function_parameter with
        | MPfile dir =&gt; MPfile (hdir dir)
        | MPbound m =&gt; MPbound (huniqid m)
        | MPdot md l =&gt; MPdot (hashcons hfuns md) (hstr l)
        end in
    let eq (d1 : t) (d2 : t) : bool :=
      orb (Stdlib.op_eqeq d1 d2)
        match (d1, d2) with
        | (MPfile dir1, MPfile dir2) =&gt; Stdlib.op_eqeq dir1 dir2
        | (MPbound m1, MPbound m2) =&gt; Stdlib.op_eqeq m1 m2
        | (MPdot mod1 l1, MPdot mod2 l2) =&gt;
          andb (Stdlib.op_eqeq l1 l2) (equal mod1 mod2)
        | _ =&gt; false
        end in
    existT (fun _ =&gt; _) tt
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}.
  
  Definition HashMP :=
    Hashcons.Make
      (existT _ [_, _]
        {|
          Hashcons.HashconsedType.hashcons :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hashcons);
          Hashcons.HashconsedType.eq :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.eq);
          Hashcons.HashconsedType.hash :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hash)
        |}).
  
  Definition hcons : (|HashMP|).(Hashcons.S.t) -&gt; (|HashMP|).(Hashcons.S.t) :=
    Hashcons.simple_hcons (|HashMP|).(Hashcons.S.generate)
      (|HashMP|).(Hashcons.S.hcons)
      (DirPath.hcons, MBId.hcons, (|Util.String|).(CString.ExtS.hcons)).
End ModPath.

Definition MPset :=
  __Set.Make
    (existT _ _
      {|
        CMap.OrderedType.compare := ModPath.compare
      |}).

Definition MPmap :=
  CMap.Make
    (existT _ _
      {|
        CMap.OrderedType.compare := ModPath.compare
      |}).

Module KerName.
  Module t.
    Record record := {
      modpath : ModPath.t;
      knlabel : Label.t;
      refhash : Z }.
    Definition with_modpath (r : record) modpath : record :=
      {| modpath := modpath; knlabel := knlabel r; refhash := refhash r |}.
    Definition with_knlabel (r : record) knlabel : record :=
      {| modpath := modpath r; knlabel := knlabel; refhash := refhash r |}.
    Definition with_refhash (r : record) refhash : record :=
      {| modpath := modpath r; knlabel := knlabel r; refhash := refhash |}.
  End t.
  Definition t := t.record.
  
  Definition kernel_name := t.
  
  Definition make (modpath : ModPath.t) (knlabel : Label.t) : t :=
    {| t.modpath := modpath; t.knlabel := knlabel; t.refhash := (-1) |}.
  
  Definition repr (kn : t) : ModPath.t * Label.t :=
    ((t.modpath kn), (t.knlabel kn)).
  
  Definition make2 : ModPath.t -&gt; Label.t -&gt; t := make.
  
  Definition modpath (kn : t) : ModPath.t := t.modpath kn.
  
  Definition label (kn : t) : Label.t := t.knlabel kn.
  
  Definition to_string_gen (mp_to_string : ModPath.t -&gt; string) (kn : t)
    : string :=
    String.append (mp_to_string (t.modpath kn))
      (String.append &quot;.&quot; (Label.to_string (t.knlabel kn))).
  
  Definition to_string (kn : t) : string := to_string_gen ModPath.to_string kn.
  
  Definition debug_to_string (kn : t) : string :=
    to_string_gen ModPath.debug_to_string kn.
  
  Definition print (kn : t) : Pp.t := str (to_string kn).
  
  Definition debug_print (kn : t) : Pp.t := str (debug_to_string kn).
  
  Definition compare (kn1 : kernel_name) (kn2 : kernel_name) : Z :=
    if Stdlib.op_eqeq kn1 kn2 then
      0
    else
      let c :=
        (|Util.String|).(CString.ExtS.compare) (t.knlabel kn1) (t.knlabel kn2)
        in
      if negb (Int.equal c 0) then
        c
      else
        ModPath.compare (t.modpath kn1) (t.modpath kn2).
  
  Definition equal (kn1 : t) (kn2 : t) : bool :=
    let h1 := t.refhash kn1 in
    let h2 := t.refhash kn2 in
    if
      andb (OCaml.Stdlib.le 0 h1)
        (andb (OCaml.Stdlib.le 0 h2) (negb (Int.equal h1 h2))) then
      false
    else
      andb (Label.equal (t.knlabel kn1) (t.knlabel kn2))
        (ModPath.equal (t.modpath kn1) (t.modpath kn2)).
  
  Import Hashset.Combine.
  
  Definition hash (kn : t) : Z :=
    let h := t.refhash kn in
    if OCaml.Stdlib.lt h 0 then
      let '{| t.modpath := mp; t.knlabel := lbl |} := kn in
      let h := combine (ModPath.hash mp) (Label.hash lbl) in
      let h := Z.land h 1073741823 in
      let '_ :=
        (* ❌ Set record field not handled. *)
        set_record_field kn &quot;refhash&quot; h in
      h
    else
      h.
  
  Definition Self_Hashcons :=
    let t := kernel_name in
    let u :=
      (ModPath.t -&gt; ModPath.t) * (DirPath.t -&gt; DirPath.t) * (string -&gt; string)
      in
    let hashcons {A : Set}
      (function_parameter : (ModPath.t -&gt; ModPath.t) * A * (Label.t -&gt; Label.t))
      : t -&gt; t :=
      let '(hmod, _hdir, hstr) := function_parameter in
      fun kn =&gt;
        let '{| t.modpath := mp; t.knlabel := l; t.refhash := refhash |} := kn
          in
        {| t.modpath := hmod mp; t.knlabel := hstr l; t.refhash := refhash |} in
    let eq (kn1 : t) (kn2 : t) : bool :=
      andb (Stdlib.op_eqeq (t.modpath kn1) (t.modpath kn2))
        (Stdlib.op_eqeq (t.knlabel kn1) (t.knlabel kn2)) in
    existT (fun _ =&gt; _) tt
      {|
        Hashcons.HashconsedType.hashcons {_} := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}.
  
  Definition HashKN :=
    Hashcons.Make
      (existT _ [_, _]
        {|
          Hashcons.HashconsedType.hashcons :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hashcons);
          Hashcons.HashconsedType.eq :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.eq);
          Hashcons.HashconsedType.hash :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hash)
        |}).
  
  Definition hcons : (|HashKN|).(Hashcons.S.t) -&gt; (|HashKN|).(Hashcons.S.t) :=
    Hashcons.simple_hcons (|HashKN|).(Hashcons.S.generate)
      (|HashKN|).(Hashcons.S.hcons)
      (ModPath.hcons, DirPath.hcons, (|Util.String|).(CString.ExtS.hcons)).
End KerName.

Definition KNmap :=
  HMap.Make
    (existT _ _
      {|
        HMap.HashedType.compare := KerName.compare;
        HMap.HashedType.hash := KerName.hash
      |}).

Definition KNpred :=
  Predicate.Make
    (existT _ _
      {|
        CMap.OrderedType.compare := KerName.compare
      |}).

Module KNset := KNmap.__Set.

Module KerPair.
  Inductive t : Set :=
  | Same : KerName.t -&gt; t
  | Dual : KerName.t -&gt; KerName.t -&gt; t.
  
  Definition kernel_pair := t.
  
  Definition canonical (function_parameter : t) : KerName.t :=
    match function_parameter with
    | Same kn =&gt; kn
    | Dual _ kn =&gt; kn
    end.
  
  Definition user (function_parameter : t) : KerName.t :=
    match function_parameter with
    | Same kn =&gt; kn
    | Dual kn _ =&gt; kn
    end.
  
  Definition same (kn : KerName.t) : t := Same kn.
  
  Definition make (knu : KerName.t) (knc : KerName.t) : t :=
    if KerName.equal knu knc then
      Same knc
    else
      Dual knu knc.
  
  Definition make1 : KerName.t -&gt; t := same.
  
  Definition make2 (mp : ModPath.t) (l : Label.t) : t :=
    same (KerName.make mp l).
  
  Definition repr2 (kp : t) : ModPath.t * Label.t := KerName.repr (user kp).
  
  Definition label (kp : t) : Label.t := KerName.label (user kp).
  
  Definition modpath (kp : t) : ModPath.t := KerName.modpath (user kp).
  
  Definition change_label (kp : t) (lbl : (|Util.String|).(CString.ExtS.t))
    : t :=
    in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    if (|Util.String|).(CString.ExtS.equal) lbl l1 then
      kp
    else
      let kn := KerName.make mp1 lbl in
      if Stdlib.op_eqeq mp1 mp2 then
        same kn
      else
        make kn (KerName.make mp2 lbl).
  
  Definition to_string (kp : t) : string := KerName.to_string (user kp).
  
  Definition print (kp : t) : Pp.t := str (to_string kp).
  
  Definition debug_to_string (function_parameter : t) : string :=
    match function_parameter with
    | Same kn =&gt;
      String.append &quot;(&quot; (String.append (KerName.debug_to_string kn) &quot;)&quot;)
    | Dual knu knc =&gt;
      String.append &quot;(&quot;
        (String.append (KerName.debug_to_string knu)
          (String.append &quot;,&quot; (String.append (KerName.debug_to_string knc) &quot;)&quot;)))
    end.
  
  Definition debug_print (kp : t) : Pp.t := str (debug_to_string kp).
  
  Module UserOrd.
    Definition t := kernel_pair.
    
    Definition compare (x : t) (y : t) : Z := KerName.compare (user x) (user y).
    
    Definition equal (x : t) (y : t) : bool :=
      orb (Stdlib.op_eqeq x y) (KerName.equal (user x) (user y)).
    
    Definition hash (x : t) : Z := KerName.hash (user x).
  End UserOrd.
  
  Module CanOrd.
    Definition t := kernel_pair.
    
    Definition compare (x : t) (y : t) : Z :=
      KerName.compare (canonical x) (canonical y).
    
    Definition equal (x : t) (y : t) : bool :=
      orb (Stdlib.op_eqeq x y) (KerName.equal (canonical x) (canonical y)).
    
    Definition hash (x : t) : Z := KerName.hash (canonical x).
  End CanOrd.
  
  Module SyntacticOrd.
    Definition compare (x : t) (y : t) : Z :=
      match (x, y) with
      | (Same knx, Same kny) =&gt; KerName.compare knx kny
      | (Dual knux kncx, Dual knuy kncy) =&gt;
        let c := KerName.compare knux knuy in
        if negb (Int.equal c 0) then
          c
        else
          KerName.compare kncx kncy
      | (Same _, _) =&gt; (-1)
      | (Dual _ _, _) =&gt; 1
      end.
    
    Definition equal (x : t) (y : t) : bool :=
      orb (Stdlib.op_eqeq x y) (equiv_decb (compare x y) 0).
    
    Definition hash (function_parameter : t) : Z :=
      match function_parameter with
      | Same kn =&gt; KerName.hash kn
      | Dual knu knc =&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
      end.
  End SyntacticOrd.
  
  Definition equal : t -&gt; t -&gt; bool := CanOrd.equal.
  
  Definition hash : t -&gt; Z := CanOrd.hash.
  
  Definition Self_Hashcons :=
    let t := kernel_pair in
    let u := KerName.t -&gt; KerName.t in
    let hashcons (hkn : KerName.t -&gt; KerName.t) (function_parameter : t) : t :=
      match function_parameter with
      | Same kn =&gt; Same (hkn kn)
      | Dual knu knc =&gt; make (hkn knu) (hkn knc)
      end in
    let eq (x : t) (y : t) : bool :=
      orb (Stdlib.op_eqeq x y)
        match (x, y) with
        | (Same x, Same y) =&gt; Stdlib.op_eqeq x y
        | (Dual ux cx, Dual uy cy) =&gt;
          andb (Stdlib.op_eqeq ux uy) (Stdlib.op_eqeq cx cy)
        | (Same _ | Dual _ _, _) =&gt; false
        end in
    let hash (function_parameter : t) : Z :=
      match function_parameter with
      | Same kn =&gt; KerName.hash kn
      | Dual knu knc =&gt;
        Hashset.Combine.combine (KerName.hash knu) (KerName.hash knc)
      end in
    existT (fun _ =&gt; _) tt
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}.
  
  Definition HashKP :=
    Hashcons.Make
      (existT _ [_, _]
        {|
          Hashcons.HashconsedType.hashcons :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hashcons);
          Hashcons.HashconsedType.eq :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.eq);
          Hashcons.HashconsedType.hash :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hash)
        |}).
End KerPair.

Module Constant := KerPair.

Definition Cmap :=
  HMap.Make
    (existT _ _
      {|
        HMap.HashedType.compare := Constant.CanOrd.compare;
        HMap.HashedType.hash := Constant.CanOrd.hash
      |}).

Definition Cmap_env :=
  HMap.Make
    (existT _ _
      {|
        HMap.HashedType.compare := Constant.UserOrd.compare;
        HMap.HashedType.hash := Constant.UserOrd.hash
      |}).

Definition Cpred :=
  Predicate.Make
    (existT _ _
      {|
        CMap.OrderedType.compare := Constant.CanOrd.compare
      |}).

Module Cset := Cmap.__Set.

Module Cset_env := Cmap_env.__Set.

Module MutInd := KerPair.

Definition Mindmap :=
  HMap.Make
    (existT _ _
      {|
        HMap.HashedType.compare := MutInd.CanOrd.compare;
        HMap.HashedType.hash := MutInd.CanOrd.hash
      |}).

Module Mindset := Mindmap.__Set.

Definition Mindmap_env :=
  HMap.Make
    (existT _ _
      {|
        HMap.HashedType.compare := MutInd.UserOrd.compare;
        HMap.HashedType.hash := MutInd.UserOrd.hash
      |}).

Definition inductive := MutInd.t * Z.

Definition constructor := inductive * Z.

Definition ind_modpath {A : Set} (function_parameter : MutInd.t * A)
  : ModPath.t :=
  let '(mind, _) := function_parameter in
  MutInd.modpath mind.

Definition constr_modpath {A B : Set} (function_parameter : (MutInd.t * A) * B)
  : ModPath.t :=
  let '(ind, _) := function_parameter in
  ind_modpath ind.

Definition ith_mutual_inductive {A B C : Set} (function_parameter : A * B)
  : C -&gt; A * C :=
  let '(mind, _) := function_parameter in
  fun i =&gt; (mind, i).

Definition ith_constructor_of_inductive {A B : Set} (ind : A) (i : B) : A * B :=
  (ind, i).

Definition inductive_of_constructor {A B : Set} (function_parameter : A * B)
  : A :=
  let '(ind, _i) := function_parameter in
  ind.

Definition index_of_constructor {A B : Set} (function_parameter : A * B) : B :=
  let '(_ind, i) := function_parameter in
  i.

Definition eq_ind (function_parameter : MutInd.t * Int.t)
  : MutInd.t * Int.t -&gt; bool :=
  let '(m1, i1) := function_parameter in
  fun function_parameter =&gt;
    let '(m2, i2) := function_parameter in
    andb (Int.equal i1 i2) (MutInd.equal m1 m2).

Definition eq_user_ind (function_parameter : KerPair.t * Int.t)
  : KerPair.t * Int.t -&gt; bool :=
  let '(m1, i1) := function_parameter in
  fun function_parameter =&gt;
    let '(m2, i2) := function_parameter in
    andb (Int.equal i1 i2) (MutInd.UserOrd.equal m1 m2).

Definition eq_syntactic_ind (function_parameter : KerPair.t * Int.t)
  : KerPair.t * Int.t -&gt; bool :=
  let '(m1, i1) := function_parameter in
  fun function_parameter =&gt;
    let '(m2, i2) := function_parameter in
    andb (Int.equal i1 i2) (MutInd.SyntacticOrd.equal m1 m2).

Definition ind_ord (function_parameter : KerPair.t * Int.t)
  : KerPair.t * Int.t -&gt; Z :=
  let '(m1, i1) := function_parameter in
  fun function_parameter =&gt;
    let '(m2, i2) := function_parameter in
    let c := Int.compare i1 i2 in
    if Int.equal c 0 then
      MutInd.CanOrd.compare m1 m2
    else
      c.

Definition ind_user_ord (function_parameter : KerPair.t * Int.t)
  : KerPair.t * Int.t -&gt; Z :=
  let '(m1, i1) := function_parameter in
  fun function_parameter =&gt;
    let '(m2, i2) := function_parameter in
    let c := Int.compare i1 i2 in
    if Int.equal c 0 then
      MutInd.UserOrd.compare m1 m2
    else
      c.

Definition ind_syntactic_ord (function_parameter : KerPair.t * Int.t)
  : KerPair.t * Int.t -&gt; Z :=
  let '(m1, i1) := function_parameter in
  fun function_parameter =&gt;
    let '(m2, i2) := function_parameter in
    let c := Int.compare i1 i2 in
    if Int.equal c 0 then
      MutInd.SyntacticOrd.compare m1 m2
    else
      c.

Definition ind_hash (function_parameter : MutInd.t * Int.t) : Z :=
  let '(m, i) := function_parameter in
  Hashset.Combine.combine (MutInd.hash m) (Int.hash i).

Definition ind_user_hash (function_parameter : KerPair.t * Int.t) : Z :=
  let '(m, i) := function_parameter in
  Hashset.Combine.combine (MutInd.UserOrd.hash m) (Int.hash i).

Definition ind_syntactic_hash (function_parameter : KerPair.t * Int.t) : Z :=
  let '(m, i) := function_parameter in
  Hashset.Combine.combine (MutInd.SyntacticOrd.hash m) (Int.hash i).

Definition eq_constructor (function_parameter : (MutInd.t * Int.t) * Int.t)
  : (MutInd.t * Int.t) * Int.t -&gt; bool :=
  let '(ind1, j1) := function_parameter in
  fun function_parameter =&gt;
    let '(ind2, j2) := function_parameter in
    andb (Int.equal j1 j2) (eq_ind ind1 ind2).

Definition eq_user_constructor
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : (KerPair.t * Int.t) * Int.t -&gt; bool :=
  let '(ind1, j1) := function_parameter in
  fun function_parameter =&gt;
    let '(ind2, j2) := function_parameter in
    andb (Int.equal j1 j2) (eq_user_ind ind1 ind2).

Definition eq_syntactic_constructor
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : (KerPair.t * Int.t) * Int.t -&gt; bool :=
  let '(ind1, j1) := function_parameter in
  fun function_parameter =&gt;
    let '(ind2, j2) := function_parameter in
    andb (Int.equal j1 j2) (eq_syntactic_ind ind1 ind2).

Definition constructor_ord (function_parameter : (KerPair.t * Int.t) * Int.t)
  : (KerPair.t * Int.t) * Int.t -&gt; Z :=
  let '(ind1, j1) := function_parameter in
  fun function_parameter =&gt;
    let '(ind2, j2) := function_parameter in
    let c := Int.compare j1 j2 in
    if Int.equal c 0 then
      ind_ord ind1 ind2
    else
      c.

Definition constructor_user_ord
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : (KerPair.t * Int.t) * Int.t -&gt; Z :=
  let '(ind1, j1) := function_parameter in
  fun function_parameter =&gt;
    let '(ind2, j2) := function_parameter in
    let c := Int.compare j1 j2 in
    if Int.equal c 0 then
      ind_user_ord ind1 ind2
    else
      c.

Definition constructor_syntactic_ord
  (function_parameter : (KerPair.t * Int.t) * Int.t)
  : (KerPair.t * Int.t) * Int.t -&gt; Z :=
  let '(ind1, j1) := function_parameter in
  fun function_parameter =&gt;
    let '(ind2, j2) := function_parameter in
    let c := Int.compare j1 j2 in
    if Int.equal c 0 then
      ind_syntactic_ord ind1 ind2
    else
      c.

Definition constructor_hash (function_parameter : (MutInd.t * Int.t) * Int.t)
  : Z :=
  let '(ind, i) := function_parameter in
  Hashset.Combine.combine (ind_hash ind) (Int.hash i).

Definition constructor_user_hash
  (function_parameter : (KerPair.t * Int.t) * Int.t) : Z :=
  let '(ind, i) := function_parameter in
  Hashset.Combine.combine (ind_user_hash ind) (Int.hash i).

Definition constructor_syntactic_hash
  (function_parameter : (KerPair.t * Int.t) * Int.t) : Z :=
  let '(ind, i) := function_parameter in
  Hashset.Combine.combine (ind_syntactic_hash ind) (Int.hash i).

Definition InductiveOrdered :=
  let t := inductive in
  let compare := ind_ord in
  existT (fun _ =&gt; _) tt
    {|
      CMap.OrderedType.compare := compare
    |}.

Definition InductiveOrdered_env :=
  let t := inductive in
  let compare := ind_user_ord in
  existT (fun _ =&gt; _) tt
    {|
      CMap.OrderedType.compare := compare
    |}.

Definition Indmap :=
  Map.Make
    (existT _ _
      {|
        CMap.OrderedType.compare :=
          (|InductiveOrdered|).(CMap.OrderedType.compare)
      |}).

Definition Indmap_env :=
  Map.Make
    (existT _ _
      {|
        CMap.OrderedType.compare :=
          (|InductiveOrdered_env|).(CMap.OrderedType.compare)
      |}).

Definition ConstructorOrdered :=
  let t := constructor in
  let compare := constructor_ord in
  existT (fun _ =&gt; _) tt
    {|
      CMap.OrderedType.compare := compare
    |}.

Definition ConstructorOrdered_env :=
  let t := constructor in
  let compare := constructor_user_ord in
  existT (fun _ =&gt; _) tt
    {|
      CMap.OrderedType.compare := compare
    |}.

Definition Constrmap :=
  Map.Make
    (existT _ _
      {|
        CMap.OrderedType.compare :=
          (|ConstructorOrdered|).(CMap.OrderedType.compare)
      |}).

Definition Constrmap_env :=
  Map.Make
    (existT _ _
      {|
        CMap.OrderedType.compare :=
          (|ConstructorOrdered_env|).(CMap.OrderedType.compare)
      |}).

Definition Hind :=
  Hashcons.Make
    (let t := inductive in
    let u := MutInd.t -&gt; MutInd.t in
    let hashcons {A B C : Set} (hmind : A -&gt; B) (function_parameter : A * C)
      : B * C :=
      let '(mind, i) := function_parameter in
      ((hmind mind), i) in
    let eq {A : Set} (function_parameter : A * Int.t) : A * Int.t -&gt; bool :=
      let '(mind1, i1) := function_parameter in
      fun function_parameter =&gt;
        let '(mind2, i2) := function_parameter in
        andb (Stdlib.op_eqeq mind1 mind2) (Int.equal i1 i2) in
    let hash := ind_hash in
    existT _ [_, _]
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}).

Definition Hconstruct :=
  Hashcons.Make
    (let t := constructor in
    let u := inductive -&gt; inductive in
    let hashcons {A B C : Set} (hind : A -&gt; B) (function_parameter : A * C)
      : B * C :=
      let '(ind, j) := function_parameter in
      ((hind ind), j) in
    let eq {A : Set} (function_parameter : A * Int.t) : A * Int.t -&gt; bool :=
      let '(ind1, j1) := function_parameter in
      fun function_parameter =&gt;
        let '(ind2, j2) := function_parameter in
        andb (Stdlib.op_eqeq ind1 ind2) (Int.equal j1 j2) in
    let hash := constructor_hash in
    existT _ [_, _]
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}).

Definition hcons_con
  : (|Constant.HashKP|).(Hashcons.S.t) -&gt; (|Constant.HashKP|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|Constant.HashKP|).(Hashcons.S.generate)
    (|Constant.HashKP|).(Hashcons.S.hcons) KerName.hcons.

Definition hcons_mind
  : (|MutInd.HashKP|).(Hashcons.S.t) -&gt; (|MutInd.HashKP|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|MutInd.HashKP|).(Hashcons.S.generate)
    (|MutInd.HashKP|).(Hashcons.S.hcons) KerName.hcons.

Definition hcons_ind : (|Hind|).(Hashcons.S.t) -&gt; (|Hind|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|Hind|).(Hashcons.S.generate)
    (|Hind|).(Hashcons.S.hcons) hcons_mind.

Definition hcons_construct
  : (|Hconstruct|).(Hashcons.S.t) -&gt; (|Hconstruct|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|Hconstruct|).(Hashcons.S.generate)
    (|Hconstruct|).(Hashcons.S.hcons) hcons_ind.

Inductive tableKey (a : Set) : Set :=
| ConstKey : a -&gt; tableKey a
| VarKey : Id.t -&gt; tableKey a
| RelKey : Int.t -&gt; tableKey a.

Arguments ConstKey {_}.
Arguments VarKey {_}.
Arguments RelKey {_}.

Definition inv_rel_key := Z.

Definition eq_table_key {A : Set}
  (f : A -&gt; A -&gt; bool) (ik1 : tableKey A) (ik2 : tableKey A) : bool :=
  if Stdlib.op_eqeq ik1 ik2 then
    true
  else
    match (ik1, ik2) with
    | (ConstKey c1, ConstKey c2) =&gt; f c1 c2
    | (VarKey id1, VarKey id2) =&gt; Id.equal id1 id2
    | (RelKey k1, RelKey k2) =&gt; Int.equal k1 k2
    | _ =&gt; false
    end.

Definition eq_mind_chk : KerPair.t -&gt; KerPair.t -&gt; bool := MutInd.UserOrd.equal.

Definition eq_ind_chk (function_parameter : KerPair.t * Int.t)
  : KerPair.t * Int.t -&gt; bool :=
  let '(kn1, i1) := function_parameter in
  fun function_parameter =&gt;
    let '(kn2, i2) := function_parameter in
    andb (Int.equal i1 i2) (eq_mind_chk kn1 kn2).

Definition eq_constant_key : KerPair.t -&gt; KerPair.t -&gt; bool :=
  Constant.UserOrd.equal.

Inductive module_path : Set :=
| MPfile : DirPath.t -&gt; module_path
| MPbound : MBId.t -&gt; module_path
| MPdot : module_path -&gt; Label.t -&gt; module_path.

Module Projection.
  Module Repr.
    Module t.
      Record record := {
        proj_ind : inductive;
        proj_npars : Z;
        proj_arg : Z;
        proj_name : Label.t }.
      Definition with_proj_ind (r : record) proj_ind : record :=
        {| proj_ind := proj_ind; proj_npars := proj_npars r;
          proj_arg := proj_arg r; proj_name := proj_name r |}.
      Definition with_proj_npars (r : record) proj_npars : record :=
        {| proj_ind := proj_ind r; proj_npars := proj_npars;
          proj_arg := proj_arg r; proj_name := proj_name r |}.
      Definition with_proj_arg (r : record) proj_arg : record :=
        {| proj_ind := proj_ind r; proj_npars := proj_npars r;
          proj_arg := proj_arg; proj_name := proj_name r |}.
      Definition with_proj_name (r : record) proj_name : record :=
        {| proj_ind := proj_ind r; proj_npars := proj_npars r;
          proj_arg := proj_arg r; proj_name := proj_name |}.
    End t.
    Definition t := t.record.
    
    Definition make
      (proj_ind : inductive) (proj_npars : Z) (proj_arg : Z)
      (proj_name : Label.t) : t :=
      {| t.proj_ind := proj_ind; t.proj_npars := proj_npars;
        t.proj_arg := proj_arg; t.proj_name := proj_name |}.
    
    Definition inductive (c : t) : inductive := t.proj_ind c.
    
    Definition mind (c : t) : MutInd.t := fst (t.proj_ind c).
    
    Definition constant (c : t) : MutInd.t :=
      KerPair.change_label (mind c) (t.proj_name c).
    
    Definition label (c : t) : Label.t := t.proj_name c.
    
    Definition npars (c : t) : Z := t.proj_npars c.
    
    Definition arg (c : t) : Z := t.proj_arg c.
    
    Definition equal (a : t) (b : t) : bool :=
      andb (eq_ind (t.proj_ind a) (t.proj_ind b))
        (Int.equal (t.proj_arg a) (t.proj_arg b)).
    
    Definition hash (p : t) : Z :=
      Hashset.Combine.combinesmall (t.proj_arg p) (ind_hash (t.proj_ind p)).
    
    Module SyntacticOrd.
      Definition compare (a : t) (b : t) : Z :=
        let c := ind_syntactic_ord (t.proj_ind a) (t.proj_ind b) in
        if Stdlib.op_eqeq c 0 then
          Int.compare (t.proj_arg a) (t.proj_arg b)
        else
          c.
      
      Definition equal (a : t) (b : t) : bool :=
        andb (Stdlib.op_eqeq (t.proj_arg a) (t.proj_arg b))
          (eq_syntactic_ind (t.proj_ind a) (t.proj_ind b)).
      
      Definition hash (p : t) : Z :=
        Hashset.Combine.combinesmall (t.proj_arg p) (ind_hash (t.proj_ind p)).
    End SyntacticOrd.
    
    Module CanOrd.
      Definition compare (a : t) (b : t) : Z :=
        let c := ind_ord (t.proj_ind a) (t.proj_ind b) in
        if Stdlib.op_eqeq c 0 then
          Int.compare (t.proj_arg a) (t.proj_arg b)
        else
          c.
      
      Definition equal (a : t) (b : t) : bool :=
        andb (Stdlib.op_eqeq (t.proj_arg a) (t.proj_arg b))
          (eq_ind (t.proj_ind a) (t.proj_ind b)).
      
      Definition hash (p : t) : Z :=
        Hashset.Combine.combinesmall (t.proj_arg p) (ind_hash (t.proj_ind p)).
    End CanOrd.
    
    Module UserOrd.
      Definition compare (a : t) (b : t) : Z :=
        let c := ind_user_ord (t.proj_ind a) (t.proj_ind b) in
        if Stdlib.op_eqeq c 0 then
          Int.compare (t.proj_arg a) (t.proj_arg b)
        else
          c.
      
      Definition equal (a : t) (b : t) : bool :=
        andb (Stdlib.op_eqeq (t.proj_arg a) (t.proj_arg b))
          (eq_user_ind (t.proj_ind a) (t.proj_ind b)).
      
      Definition hash (p : t) : Z :=
        Hashset.Combine.combinesmall (t.proj_arg p)
          (ind_user_hash (t.proj_ind p)).
    End UserOrd.
    
    Definition compare (a : t) (b : t) : Z :=
      let c := ind_ord (t.proj_ind a) (t.proj_ind b) in
      if Stdlib.op_eqeq c 0 then
        Int.compare (t.proj_arg a) (t.proj_arg b)
      else
        c.
    
    Definition Self_Hashcons :=
      let t := t in
      let u := (inductive -&gt; inductive) * (Id.t -&gt; Id.t) in
      let hashcons
        (function_parameter : (inductive -&gt; inductive) * (Label.t -&gt; Label.t))
        : t -&gt; t :=
        let '(hind, hid) := function_parameter in
        fun p =&gt;
          {| t.proj_ind := hind (t.proj_ind p); t.proj_npars := t.proj_npars p;
            t.proj_arg := t.proj_arg p; t.proj_name := hid (t.proj_name p) |} in
      let eq (p : t) (p' : t) : bool :=
        orb (Stdlib.op_eqeq p p')
          (andb (Stdlib.op_eqeq (t.proj_ind p) (t.proj_ind p'))
            (andb (Stdlib.op_eqeq (t.proj_npars p) (t.proj_npars p'))
              (andb (Stdlib.op_eqeq (t.proj_arg p) (t.proj_arg p'))
                (Stdlib.op_eqeq (t.proj_name p) (t.proj_name p'))))) in
      existT (fun _ =&gt; _) tt
        {|
          Hashcons.HashconsedType.hashcons := hashcons;
          Hashcons.HashconsedType.eq := eq;
          Hashcons.HashconsedType.hash := hash
        |}.
    
    Definition HashRepr :=
      Hashcons.Make
        (existT _ [_, _]
          {|
            Hashcons.HashconsedType.hashcons :=
              (|Self_Hashcons|).(Hashcons.HashconsedType.hashcons);
            Hashcons.HashconsedType.eq :=
              (|Self_Hashcons|).(Hashcons.HashconsedType.eq);
            Hashcons.HashconsedType.hash :=
              (|Self_Hashcons|).(Hashcons.HashconsedType.hash)
          |}).
    
    Definition hcons
      : (|HashRepr|).(Hashcons.S.t) -&gt; (|HashRepr|).(Hashcons.S.t) :=
      Hashcons.simple_hcons (|HashRepr|).(Hashcons.S.generate)
        (|HashRepr|).(Hashcons.S.hcons) (hcons_ind, Id.hcons).
    
    Definition map_npars (f : MutInd.t -&gt; Z -&gt; MutInd.t * Z) (p : t) : t :=
      let ind := fst (t.proj_ind p) in
      let npars := t.proj_npars p in
      let '(ind', npars') := f ind npars in
      if andb (Stdlib.op_eqeq ind ind') (Stdlib.op_eqeq npars npars') then
        p
      else
        t.with_proj_npars (t.with_proj_ind p (ind', (snd (t.proj_ind p))))
          npars'.
    
    Definition map (f : MutInd.t -&gt; MutInd.t) (p : t) : t :=
      map_npars (fun mind =&gt; fun n =&gt; ((f mind), n)) p.
    
    Definition to_string (p : t) : string := Constant.to_string (constant p).
    
    Definition print (p : t) : Pp.t := Constant.print (constant p).
  End Repr.
  
  Definition t := Repr.t * bool.
  
  Definition make {A B : Set} (c : A) (b : B) : A * B := (c, b).
  
  Definition mind {A : Set} (function_parameter : Repr.t * A) : MutInd.t :=
    let '(c, _) := function_parameter in
    Repr.mind c.
  
  Definition inductive {A : Set} (function_parameter : Repr.t * A)
    : inductive :=
    let '(c, _) := function_parameter in
    Repr.inductive c.
  
  Definition npars {A : Set} (function_parameter : Repr.t * A) : Z :=
    let '(c, _) := function_parameter in
    Repr.npars c.
  
  Definition arg {A : Set} (function_parameter : Repr.t * A) : Z :=
    let '(c, _) := function_parameter in
    Repr.arg c.
  
  Definition constant {A : Set} (function_parameter : Repr.t * A) : MutInd.t :=
    let '(c, _) := function_parameter in
    Repr.constant c.
  
  Definition label {A : Set} (function_parameter : Repr.t * A) : Label.t :=
    let '(c, _) := function_parameter in
    Repr.label c.
  
  Definition repr {A B : Set} : A * B -&gt; A := fst.
  
  Definition unfolded {A B : Set} : A * B -&gt; B := snd.
  
  Definition unfold {A : Set} (function_parameter : A * bool) : A * bool :=
    let '(c, b) as p := function_parameter in
    if b then
      p
    else
      (c, true).
  
  Definition equal {A : Set} (function_parameter : Repr.t * A)
    : Repr.t * A -&gt; bool :=
    let '(c, b) := function_parameter in
    fun function_parameter =&gt;
      let '(c', b') := function_parameter in
      andb (Repr.equal c c') (Stdlib.op_eqeq b b').
  
  Definition repr_equal {A B : Set} (p : Repr.t * A) (p' : Repr.t * B) : bool :=
    Repr.equal (repr p) (repr p').
  
  Definition hash (function_parameter : Repr.t * bool) : Z :=
    let '(c, b) := function_parameter in
    Z.add
      (if b then
        0
      else
        1) (Repr.hash c).
  
  Module SyntacticOrd.
    Definition compare {A : Set} (function_parameter : Repr.t * A)
      : Repr.t * A -&gt; Z :=
      let '(c, b) := function_parameter in
      fun function_parameter =&gt;
        let '(c', b') := function_parameter in
        if equiv_decb b b' then
          Repr.SyntacticOrd.compare c c'
        else
          (-1).
    
    Definition equal {A : Set} (function_parameter : Repr.t * A)
      : Repr.t * A -&gt; bool :=
      let '(c, b) as x := function_parameter in
      fun function_parameter =&gt;
        let '(c', b') as x' := function_parameter in
        orb (Stdlib.op_eqeq x x')
          (andb (equiv_decb b b') (Repr.SyntacticOrd.equal c c')).
    
    Definition hash (function_parameter : Repr.t * bool) : Z :=
      let '(c, b) := function_parameter in
      Z.add
        (if b then
          0
        else
          1) (Repr.SyntacticOrd.hash c).
  End SyntacticOrd.
  
  Module CanOrd.
    Definition compare {A : Set} (function_parameter : Repr.t * A)
      : Repr.t * A -&gt; Z :=
      let '(c, b) := function_parameter in
      fun function_parameter =&gt;
        let '(c', b') := function_parameter in
        if equiv_decb b b' then
          Repr.CanOrd.compare c c'
        else
          (-1).
    
    Definition equal {A : Set} (function_parameter : Repr.t * A)
      : Repr.t * A -&gt; bool :=
      let '(c, b) as x := function_parameter in
      fun function_parameter =&gt;
        let '(c', b') as x' := function_parameter in
        orb (Stdlib.op_eqeq x x')
          (andb (equiv_decb b b') (Repr.CanOrd.equal c c')).
    
    Definition hash (function_parameter : Repr.t * bool) : Z :=
      let '(c, b) := function_parameter in
      Z.add
        (if b then
          0
        else
          1) (Repr.CanOrd.hash c).
  End CanOrd.
  
  Definition Self_Hashcons :=
    let t := t in
    let u := Repr.t -&gt; Repr.t in
    let hashcons {A B C : Set} (hc : A -&gt; B) (function_parameter : A * C)
      : B * C :=
      let '(c, b) := function_parameter in
      ((hc c), b) in
    let eq {A B : Set} (function_parameter : A * B) : A * B -&gt; bool :=
      let '(c, b) as x := function_parameter in
      fun function_parameter =&gt;
        let '(c', b') as y := function_parameter in
        orb (Stdlib.op_eqeq x y)
          (andb (Stdlib.op_eqeq c c') (Stdlib.op_eqeq b b')) in
    existT (fun _ =&gt; _) tt
      {|
        Hashcons.HashconsedType.hashcons {_ _ _} := hashcons;
        Hashcons.HashconsedType.eq {_ _} := eq;
        Hashcons.HashconsedType.hash := hash
      |}.
  
  Definition HashProjection :=
    Hashcons.Make
      (existT _ [_, _]
        {|
          Hashcons.HashconsedType.hashcons :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hashcons);
          Hashcons.HashconsedType.eq :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.eq);
          Hashcons.HashconsedType.hash :=
            (|Self_Hashcons|).(Hashcons.HashconsedType.hash)
        |}).
  
  Definition hcons
    : (|HashProjection|).(Hashcons.S.t) -&gt; (|HashProjection|).(Hashcons.S.t) :=
    Hashcons.simple_hcons (|HashProjection|).(Hashcons.S.generate)
      (|HashProjection|).(Hashcons.S.hcons) Repr.hcons.
  
  Definition compare (function_parameter : Repr.t * bool)
    : Repr.t * bool -&gt; Z :=
    let '(c, b) := function_parameter in
    fun function_parameter =&gt;
      let '(c', b') := function_parameter in
      if Stdlib.op_eqeq b b' then
        Repr.compare c c'
      else
        if b then
          1
        else
          (-1).
  
  Definition map {A : Set}
    (f : MutInd.t -&gt; MutInd.t) (function_parameter : Repr.t * A) : Repr.t * A :=
    let '(c, b) as x := function_parameter in
    let c' := Repr.map f c in
    if Stdlib.op_eqeq c' c then
      x
    else
      (c', b).
  
  Definition map_npars {A : Set}
    (f : MutInd.t -&gt; Z -&gt; MutInd.t * Z) (function_parameter : Repr.t * A)
    : Repr.t * A :=
    let '(c, b) as x := function_parameter in
    let c' := Repr.map_npars f c in
    if Stdlib.op_eqeq c' c then
      x
    else
      (c', b).
  
  Definition to_string {A : Set} (p : Repr.t * A) : string :=
    Constant.to_string (constant p).
  
  Definition print {A : Set} (p : Repr.t * A) : Pp.t :=
    Constant.print (constant p).
End Projection.

Module GlobRefInternal.
  Inductive t : Set :=
  | VarRef : variable -&gt; t
  | ConstRef : Constant.t -&gt; t
  | IndRef : inductive -&gt; t
  | ConstructRef : constructor -&gt; t.
  
  Definition equal (gr1 : t) (gr2 : t) : bool :=
    orb (Stdlib.op_eqeq gr1 gr2)
      match (gr1, gr2) with
      | (ConstRef con1, ConstRef con2) =&gt; Constant.equal con1 con2
      | (IndRef kn1, IndRef kn2) =&gt; eq_ind kn1 kn2
      | (ConstructRef kn1, ConstructRef kn2) =&gt; eq_constructor kn1 kn2
      | (VarRef v1, VarRef v2) =&gt; Id.equal v1 v2
      | (ConstRef _ | IndRef _ | ConstructRef _ | VarRef _, _) =&gt; false
      end.
  
  Definition global_eq_gen
    (eq_cst : Constant.t -&gt; Constant.t -&gt; bool)
    (eq_ind : inductive -&gt; inductive -&gt; bool)
    (eq_cons : constructor -&gt; constructor -&gt; bool) (x : t) (y : t) : bool :=
    orb (Stdlib.op_eqeq x y)
      match (x, y) with
      | (ConstRef cx, ConstRef cy) =&gt; eq_cst cx cy
      | (IndRef indx, IndRef indy) =&gt; eq_ind indx indy
      | (ConstructRef consx, ConstructRef consy) =&gt; eq_cons consx consy
      | (VarRef v1, VarRef v2) =&gt; Id.equal v1 v2
      | (VarRef _ | ConstRef _ | IndRef _ | ConstructRef _, _) =&gt; false
      end.
  
  Definition global_ord_gen
    (ord_cst : Constant.t -&gt; Constant.t -&gt; Z)
    (ord_ind : inductive -&gt; inductive -&gt; Z)
    (ord_cons : constructor -&gt; constructor -&gt; Z) (x : t) (y : t) : Z :=
    if Stdlib.op_eqeq x y then
      0
    else
      match (x, y) with
      | (VarRef v1, VarRef v2) =&gt; Id.compare v1 v2
      | (VarRef _, _) =&gt; (-1)
      | (_, VarRef _) =&gt; 1
      | (ConstRef cx, ConstRef cy) =&gt; ord_cst cx cy
      | (ConstRef _, _) =&gt; (-1)
      | (_, ConstRef _) =&gt; 1
      | (IndRef indx, IndRef indy) =&gt; ord_ind indx indy
      | (IndRef _, _) =&gt; (-1)
      | (_, IndRef _) =&gt; 1
      | (ConstructRef consx, ConstructRef consy) =&gt; ord_cons consx consy
      end.
  
  Definition global_hash_gen
    (hash_cst : Constant.t -&gt; Z) (hash_ind : inductive -&gt; Z)
    (hash_cons : constructor -&gt; Z) (gr : t) : Z :=
    match gr with
    | ConstRef c =&gt; combinesmall 1 (hash_cst c)
    | IndRef i =&gt; combinesmall 2 (hash_ind i)
    | ConstructRef c =&gt; combinesmall 3 (hash_cons c)
    | VarRef id =&gt; combinesmall 4 (Id.hash id)
    end.
End GlobRefInternal.

Module GlobRef.
  Inductive t : Set :=
  | VarRef : variable -&gt; t
  | ConstRef : Constant.t -&gt; t
  | IndRef : inductive -&gt; t
  | ConstructRef : constructor -&gt; t.
  
  Definition equal : GlobRefInternal.t -&gt; GlobRefInternal.t -&gt; bool :=
    GlobRefInternal.equal.
  
  Module Ordered.
    Import Constant.CanOrd.
    
    Definition t := GlobRefInternal.t.
    
    Definition compare (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : Z :=
      GlobRefInternal.global_ord_gen compare ind_ord constructor_ord gr1 gr2.
    
    Definition equal (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : bool :=
      GlobRefInternal.global_eq_gen equal eq_ind eq_constructor gr1 gr2.
    
    Definition hash (gr : GlobRefInternal.t) : Z :=
      GlobRefInternal.global_hash_gen hash ind_hash constructor_hash gr.
  End Ordered.
  
  Module Ordered_env.
    Import Constant.UserOrd.
    
    Definition t := GlobRefInternal.t.
    
    Definition compare (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : Z :=
      GlobRefInternal.global_ord_gen compare ind_user_ord constructor_user_ord
        gr1 gr2.
    
    Definition equal (gr1 : GlobRefInternal.t) (gr2 : GlobRefInternal.t)
      : bool :=
      GlobRefInternal.global_eq_gen equal eq_user_ind eq_user_constructor gr1
        gr2.
    
    Definition hash (gr : GlobRefInternal.t) : Z :=
      GlobRefInternal.global_hash_gen hash ind_user_hash constructor_user_hash
        gr.
  End Ordered_env.
  
  Definition Map :=
    HMap.Make
      (existT _ _
        {|
          HMap.HashedType.compare := Ordered.compare;
          HMap.HashedType.hash := Ordered.hash
        |}).
  
  Module __Set := Map.__Set.
  
  Definition Map_env :=
    HMap.Make
      (existT _ _
        {|
          HMap.HashedType.compare := Ordered_env.compare;
          HMap.HashedType.hash := Ordered_env.hash
        |}).
  
  Module Set_env := Map_env.__Set.
End GlobRef.

Inductive evaluable_global_reference : Set :=
| EvalVarRef : Id.t -&gt; evaluable_global_reference
| EvalConstRef : Constant.t -&gt; evaluable_global_reference.

Definition eq_egr
  (e1 : evaluable_global_reference) (e2 : evaluable_global_reference) : bool :=
  match (e1, e2) with
  | (EvalConstRef con1, EvalConstRef con2) =&gt; Constant.equal con1 con2
  | (EvalVarRef id1, EvalVarRef id2) =&gt; Id.equal id1 id2
  | (_, _) =&gt; false
  end.

Definition lident := CAst.t Id.t.

Definition lname := CAst.t Name.t.

Definition lstring := CAst.t string.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="names.mli">
  <div style="margin: 20px;">
    <h3>Names_mli</h3>
    <ul>
      <li>OCaml size: 691 lines</li>
      <li>Coq size: 601 lines (-14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#names.mli"><code>names.mli</code></a>&nbsp;<span class="label label-warning">11 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** This file defines a lot of different notions of names used pervasively in
    the kernel as well as in other places. The essential datatypes exported by
    this API are:

    - Id.t is the type of identifiers, that is morally a subset of strings which
      only contains Unicode characters of the Letter kind (and a few more).
    - Name.t is an ad-hoc variant of Id.t option allowing to handle optionally
      named objects.
    - DirPath.t represents generic paths as sequences of identifiers.
    - Label.t is an equivalent of Id.t made distinct for semantical purposes.
    - ModPath.t are module paths.
    - KerName.t are absolute names of objects in Coq.
*)

open Util

(** {6 Identifiers } *)

(** Representation and operations on identifiers. *)
module Id :
sig
  type t
  (** Values of this type represent (Coq) identifiers. *)

  val equal : t -&gt; t -&gt; bool
  (** Equality over identifiers. *)

  val compare : t -&gt; t -&gt; int
  (** Comparison over identifiers. *)

  val hash : t -&gt; int
  (** Hash over identifiers. *)

  val is_valid : string -&gt; bool
  (** Check that a string may be converted to an identifier. *)

  val of_bytes : bytes -&gt; t
  val of_string : string -&gt; t
  (** Converts a string into an identifier.
      @raise UserError if the string is invalid as an identifier. *)

  val of_string_soft : string -&gt; t
  (** Same as {!of_string} except that any string made of supported UTF-8 characters is accepted.
      @raise UserError if the string is invalid as an UTF-8 string. *)

  val to_string : t -&gt; string
  (** Converts a identifier into an string. *)

  val print : t -&gt; Pp.t
  (** Pretty-printer. *)

  module Set : Set.S with type elt = t
  (** Finite sets of identifiers. *)

  <abbr class="mark-warning" title="Can only do `with` on types in module types">module Map : Map.ExtS with type key = t and module Set := Set</abbr>
  (** Finite maps of identifiers. *)

  module Pred : Predicate.S with type elt = t
  (** Predicates over identifiers. *)

  module List : List.MonoS with type elt = t
  (** Operations over lists of identifiers. *)

  val hcons : t -&gt; t
  (** Hashconsing of identifiers. *)

end

(** Representation and operations on identifiers that are allowed to be anonymous
    (i.e. &quot;_&quot; in concrete syntax). *)
module Name :
sig
  type t = Anonymous     (** anonymous identifier *)
         | Name of Id.t  (** non-anonymous identifier *)

  val mk_name : Id.t -&gt; t
  (** constructor *)

  val is_anonymous : t -&gt; bool
  (** Return [true] iff a given name is [Anonymous]. *)

  val is_name : t -&gt; bool
  (** Return [true] iff a given name is [Name _]. *)

  val compare : t -&gt; t -&gt; int
  (** Comparison over names. *)

  val equal : t -&gt; t -&gt; bool
  (** Equality over names. *)

  val hash : t -&gt; int
  (** Hash over names. *)

  val hcons : t -&gt; t
  (** Hashconsing over names. *)

  val print : t -&gt; Pp.t
  (** Pretty-printer (print &quot;_&quot; for [Anonymous]. *)

end

(** {6 Type aliases} *)

type name = Name.t = Anonymous | Name of Id.t
[@@ocaml.deprecated &quot;Use Name.t&quot;]

type variable = Id.t
type module_ident = Id.t

module ModIdset : Set.S with type elt = module_ident
<abbr class="mark-warning" title="Can only do `with` on types in module types">module ModIdmap : Map.ExtS with type key = module_ident and module Set := ModIdset</abbr>

(** {6 Directory paths = section names paths } *)

module DirPath :
sig
  type t
  (** Type of directory paths. Essentially a list of module identifiers. The
      order is reversed to improve sharing. E.g. A.B.C is [&quot;C&quot;;&quot;B&quot;;&quot;A&quot;] *)

  val equal : t -&gt; t -&gt; bool
  (** Equality over directory paths. *)

  val compare : t -&gt; t -&gt; int
  (** Comparison over directory paths. *)

  val hash : t -&gt; int
  (** Hash over directory paths. *)

  val make : module_ident list -&gt; t
  (** Create a directory path. (The list must be reversed). *)

  val repr : t -&gt; module_ident list
  (** Represent a directory path. (The result list is reversed). *)

  val empty : t
  (** The empty directory path. *)

  val is_empty : t -&gt; bool
  (** Test whether a directory path is empty. *)

  val initial : t
  (** Initial &quot;seed&quot; of the unique identifier generator *)

  val hcons : t -&gt; t
  (** Hashconsing of directory paths. *)

  val to_string : t -&gt; string
  (** Print non-empty directory paths as [&quot;coq_root.module.submodule&quot;] *)

  val print : t -&gt; Pp.t
end

(** {6 Names of structure elements } *)

module Label :
sig
  type t
  (** Type of labels *)

  val equal : t -&gt; t -&gt; bool
  (** Equality over labels *)

  val compare : t -&gt; t -&gt; int
  (** Comparison over labels. *)

  val hash : t -&gt; int
  (** Hash over labels. *)

  val make : string -&gt; t
  (** Create a label out of a string. *)

  val of_id : Id.t -&gt; t
  (** Conversion from an identifier. *)

  val to_id : t -&gt; Id.t
  (** Conversion to an identifier. *)

  val to_string : t -&gt; string
  (** Conversion to string. *)

  val print : t -&gt; Pp.t
  (** Pretty-printer. *)

  module Set : Set.S with type elt = t
  <abbr class="mark-warning" title="Can only do `with` on types in module types">module Map : Map.ExtS with type key = t and module Set := Set</abbr>

  val hcons : t -&gt; t

end

(** {6 Unique names for bound modules} *)

module MBId :
sig
  type t
  (** Unique names for bound modules. Each call to [make] constructs a fresh
      unique identifier. *)

  val equal : t -&gt; t -&gt; bool
  (** Equality over unique bound names. *)

  val compare : t -&gt; t -&gt; int
  (** Comparison over unique bound names. *)

  val hash : t -&gt; int
  (** Hash over unique bound names. *)

  val make : DirPath.t -&gt; Id.t -&gt; t
  (** The first argument is a file name, to prevent conflict between different
      files. *)

  val repr : t -&gt; int * Id.t * DirPath.t
  (** Reverse of [make]. *)

  val to_id : t -&gt; Id.t
  (** Return the identifier contained in the argument. *)

  val to_string : t -&gt; string
  (** Encode as a string (not to be used for user-facing messages). *)

  val debug_to_string : t -&gt; string
  (** Same as [to_string], but outputs extra information related to debug. *)

end

module MBIset : Set.S with type elt = MBId.t
<abbr class="mark-warning" title="Can only do `with` on types in module types">module MBImap : Map.ExtS with type key = MBId.t and module Set := MBIset</abbr>

(** {6 The module part of the kernel name } *)

module ModPath :
sig
  type t =
    | MPfile of DirPath.t
    | MPbound of MBId.t
    | MPdot of t * Label.t

  val compare : t -&gt; t -&gt; int
  val equal : t -&gt; t -&gt; bool
  val hash : t -&gt; int

  val is_bound : t -&gt; bool

  val initial : t
  (** Name of the toplevel structure ([= MPfile initial_dir]) *)

  val dp : t -&gt; DirPath.t

  val to_string : t -&gt; string
  (** Encode as a string (not to be used for user-facing messages). *)

  val debug_to_string : t -&gt; string
  (** Same as [to_string], but outputs extra information related to debug. *)

end

module MPset : Set.S with type elt = ModPath.t
<abbr class="mark-warning" title="Can only do `with` on types in module types">module MPmap : Map.ExtS with type key = ModPath.t and module Set := MPset</abbr>

(** {6 The absolute names of objects seen by kernel } *)

module KerName :
sig
  type t

  (** Constructor and destructor *)
  val make : ModPath.t -&gt; Label.t -&gt; t
  val repr : t -&gt; ModPath.t * Label.t

  val make2 : ModPath.t -&gt; Label.t -&gt; t
  [@@ocaml.deprecated &quot;Please use [KerName.make]&quot;]

  (** Projections *)
  val modpath : t -&gt; ModPath.t
  val label : t -&gt; Label.t

  val to_string : t -&gt; string
  (** Encode as a string (not to be used for user-facing messages). *)

  val print : t -&gt; Pp.t
  (** Print internal representation (not to be used for user-facing messages). *)

  val debug_to_string : t -&gt; string
  (** Same as [to_string], but outputs extra information related to debug. *)

  val debug_print : t -&gt; Pp.t
  (** Same as [print], but outputs extra information related to debug. *)

  (** Comparisons *)
  val compare : t -&gt; t -&gt; int
  val equal : t -&gt; t -&gt; bool
  val hash : t -&gt; int
end

module KNset  : CSig.SetS with type elt = KerName.t
module KNpred : Predicate.S with type elt = KerName.t
<abbr class="mark-warning" title="Can only do `with` on types in module types">module KNmap  : Map.ExtS with type key = KerName.t and module Set := KNset</abbr>

(** {6 Constant Names } *)

module Constant:
sig
  type t

  (** Constructors *)

  val make : KerName.t -&gt; KerName.t -&gt; t
  (** Builds a constant name from a user and a canonical kernel name. *)

  val make1 : KerName.t -&gt; t
  (** Special case of [make] where the user name is canonical.  *)

  val make2 : ModPath.t -&gt; Label.t -&gt; t
  (** Shortcut for [(make1 (KerName.make2 ...))] *)

  (** Projections *)

  val user : t -&gt; KerName.t
  val canonical : t -&gt; KerName.t

  val repr2 : t -&gt; ModPath.t * Label.t
  (** Shortcut for [KerName.repr (user ...)] *)

  val modpath : t -&gt; ModPath.t
  (** Shortcut for [KerName.modpath (user ...)] *)

  val label : t -&gt; Label.t
  (** Shortcut for [KerName.label (user ...)] *)

  (** Comparisons *)

  module CanOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  module UserOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  module SyntacticOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  val equal : t -&gt; t -&gt; bool
  (** Default comparison, alias for [CanOrd.equal] *)

  val hash : t -&gt; int
  (** Hashing function *)

  val change_label : t -&gt; Label.t -&gt; t
  (** Builds a new constant name with a different label *)

  (** Displaying *)

  val to_string : t -&gt; string
  (** Encode as a string (not to be used for user-facing messages). *)

  val print : t -&gt; Pp.t
  (** Print internal representation (not to be used for user-facing messages). *)

  val debug_to_string : t -&gt; string
  (** Same as [to_string], but outputs extra information related to debug. *)

  val debug_print : t -&gt; Pp.t
  (** Same as [print], but outputs extra information related to debug. *)

end

(** The [*_env] modules consider an order on user part of names
   the others consider an order on canonical part of names*)
module Cpred : Predicate.S with type elt = Constant.t
module Cset : CSig.SetS with type elt = Constant.t
module Cset_env  : CSig.SetS with type elt = Constant.t

<abbr class="mark-warning" title="Can only do `with` on types in module types">module Cmap : Map.ExtS with type key = Constant.t and module Set := Cset</abbr>
(** A map whose keys are constants (values of the {!Constant.t} type).
    Keys are ordered wrt. &quot;canonical form&quot; of the constant. *)

<abbr class="mark-warning" title="Can only do `with` on types in module types">module Cmap_env : Map.ExtS with type key = Constant.t and module Set := Cset_env</abbr>
(** A map whose keys are constants (values of the {!Constant.t} type).
    Keys are ordered wrt. &quot;user form&quot; of the constant. *)

(** {6 Inductive names} *)

module MutInd :
sig
  type t

  (** Constructors *)

  val make : KerName.t -&gt; KerName.t -&gt; t
  (** Builds a mutual inductive name from a user and a canonical kernel name. *)

  val make1 : KerName.t -&gt; t
  (** Special case of [make] where the user name is canonical.  *)

  val make2 : ModPath.t -&gt; Label.t -&gt; t
  (** Shortcut for [(make1 (KerName.make2 ...))] *)

  (** Projections *)

  val user : t -&gt; KerName.t
  val canonical : t -&gt; KerName.t

  val repr2 : t -&gt; ModPath.t * Label.t
  (** Shortcut for [KerName.repr (user ...)] *)

  val modpath : t -&gt; ModPath.t
  (** Shortcut for [KerName.modpath (user ...)] *)

  val label : t -&gt; Label.t
  (** Shortcut for [KerName.label (user ...)] *)

  (** Comparisons *)

  module CanOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  module UserOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  module SyntacticOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  val equal : t -&gt; t -&gt; bool
  (** Default comparison, alias for [CanOrd.equal] *)

  val hash : t -&gt; int

  (** Displaying *)

  val to_string : t -&gt; string
  (** Encode as a string (not to be used for user-facing messages). *)

  val print : t -&gt; Pp.t
  (** Print internal representation (not to be used for user-facing messages). *)

  val debug_to_string : t -&gt; string
  (** Same as [to_string], but outputs extra information related to debug. *)

  val debug_print : t -&gt; Pp.t
  (** Same as [print], but outputs extra information related to debug. *)

end

module Mindset : CSig.SetS with type elt = MutInd.t
<abbr class="mark-warning" title="Can only do `with` on types in module types">module Mindmap : Map.ExtS with type key = MutInd.t and module Set := Mindset</abbr>
module Mindmap_env : CSig.MapS with type key = MutInd.t

(** Designation of a (particular) inductive type. *)
type inductive = MutInd.t      (* the name of the inductive type *)
               * int           (* the position of this inductive type
                                  within the block of mutually-recursive inductive types.
                                  BEWARE: indexing starts from 0. *)

(** Designation of a (particular) constructor of a (particular) inductive type. *)
type constructor = inductive   (* designates the inductive type *)
                 * int         (* the index of the constructor
                                  BEWARE: indexing starts from 1. *)

module Indmap : CSig.MapS with type key = inductive
module Constrmap : CSig.MapS with type key = constructor
module Indmap_env : CSig.MapS with type key = inductive
module Constrmap_env : CSig.MapS with type key = constructor

val ind_modpath : inductive -&gt; ModPath.t
val constr_modpath : constructor -&gt; ModPath.t

val ith_mutual_inductive : inductive -&gt; int -&gt; inductive
val ith_constructor_of_inductive : inductive -&gt; int -&gt; constructor
val inductive_of_constructor : constructor -&gt; inductive
val index_of_constructor : constructor -&gt; int
val eq_ind : inductive -&gt; inductive -&gt; bool
val eq_user_ind : inductive -&gt; inductive -&gt; bool
val eq_syntactic_ind : inductive -&gt; inductive -&gt; bool
val ind_ord : inductive -&gt; inductive -&gt; int
val ind_hash : inductive -&gt; int
val ind_user_ord : inductive -&gt; inductive -&gt; int
val ind_user_hash : inductive -&gt; int
val ind_syntactic_ord : inductive -&gt; inductive -&gt; int
val ind_syntactic_hash : inductive -&gt; int
val eq_constructor : constructor -&gt; constructor -&gt; bool
val eq_user_constructor : constructor -&gt; constructor -&gt; bool
val eq_syntactic_constructor : constructor -&gt; constructor -&gt; bool
val constructor_ord : constructor -&gt; constructor -&gt; int
val constructor_hash : constructor -&gt; int
val constructor_user_ord : constructor -&gt; constructor -&gt; int
val constructor_user_hash : constructor -&gt; int
val constructor_syntactic_ord : constructor -&gt; constructor -&gt; int
val constructor_syntactic_hash : constructor -&gt; int

(** {6 Hash-consing } *)

val hcons_con : Constant.t -&gt; Constant.t
val hcons_mind : MutInd.t -&gt; MutInd.t
val hcons_ind : inductive -&gt; inductive
val hcons_construct : constructor -&gt; constructor

(******)

type 'a tableKey =
  | ConstKey of 'a
  | VarKey of Id.t
  | RelKey of Int.t

type inv_rel_key = int (** index in the [rel_context] part of environment
                          starting by the end, {e inverse}
                          of de Bruijn indice *)

val eq_table_key : ('a -&gt; 'a -&gt; bool) -&gt; 'a tableKey -&gt; 'a tableKey -&gt; bool
val eq_constant_key : Constant.t -&gt; Constant.t -&gt; bool

(** equalities on constant and inductive names (for the checker) *)

val eq_ind_chk : inductive -&gt; inductive -&gt; bool

(** {5 Module paths} *)

type module_path = ModPath.t =
  | MPfile of DirPath.t
  | MPbound of MBId.t
  | MPdot of ModPath.t * Label.t
[@@ocaml.deprecated &quot;Alias type&quot;]

module Projection : sig
  module Repr : sig
    type t

    val make : inductive -&gt; proj_npars:int -&gt; proj_arg:int -&gt; Label.t -&gt; t

    module SyntacticOrd : sig
      val compare : t -&gt; t -&gt; int
      val equal : t -&gt; t -&gt; bool
      val hash : t -&gt; int
    end
    module CanOrd : sig
      val compare : t -&gt; t -&gt; int
      val equal : t -&gt; t -&gt; bool
      val hash : t -&gt; int
    end
    module UserOrd : sig
      val compare : t -&gt; t -&gt; int
      val equal : t -&gt; t -&gt; bool
      val hash : t -&gt; int
    end

    val constant : t -&gt; Constant.t
    (** Don't use this if you don't have to. *)

    val inductive : t -&gt; inductive
    val mind : t -&gt; MutInd.t
    val npars : t -&gt; int
    val arg : t -&gt; int
    val label : t -&gt; Label.t

    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
    val compare : t -&gt; t -&gt; int

    val map : (MutInd.t -&gt; MutInd.t) -&gt; t -&gt; t
    val map_npars : (MutInd.t -&gt; int -&gt; MutInd.t * int) -&gt; t -&gt; t

    val to_string : t -&gt; string
    (** Encode as a string (not to be used for user-facing messages). *)

    val print : t -&gt; Pp.t
    (** Print internal representation (not to be used for user-facing messages). *)

  end
  type t (* = Repr.t * bool *)

  val make : Repr.t -&gt; bool -&gt; t
  val repr : t -&gt; Repr.t

  module SyntacticOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end
  module CanOrd : sig
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  val constant : t -&gt; Constant.t
  val mind : t -&gt; MutInd.t
  val inductive : t -&gt; inductive
  val npars : t -&gt; int
  val arg : t -&gt; int
  val label : t -&gt; Label.t
  val unfolded : t -&gt; bool
  val unfold : t -&gt; t

  val equal : t -&gt; t -&gt; bool
  val hash : t -&gt; int
  val hcons : t -&gt; t
  (** Hashconsing of projections. *)

  val repr_equal : t -&gt; t -&gt; bool
  (** Ignoring the unfolding boolean. *)

  val compare : t -&gt; t -&gt; int

  val map : (MutInd.t -&gt; MutInd.t) -&gt; t -&gt; t
  val map_npars : (MutInd.t -&gt; int -&gt; MutInd.t * int) -&gt; t -&gt; t

  val to_string : t -&gt; string
  (** Encode as a string (not to be used for user-facing messages). *)

  val print : t -&gt; Pp.t
  (** Print internal representation (not to be used for user-facing messages). *)

end

(** {6 Global reference is a kernel side type for all references together } *)

(* XXX: Should we define GlobRefCan GlobRefUser? *)
module GlobRef : sig

  type t =
    | VarRef of variable           (** A reference to the section-context. *)
    | ConstRef of Constant.t       (** A reference to the environment. *)
    | IndRef of inductive          (** A reference to an inductive type. *)
    | ConstructRef of constructor  (** A reference to a constructor of an inductive type. *)

  val equal : t -&gt; t -&gt; bool

  module Ordered : sig
    type nonrec t = t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  module Ordered_env : sig
    type nonrec t = t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
  end

  module Set_env : CSig.SetS with type elt = t
  <abbr class="mark-warning" title="Can only do `with` on types in module types">module Map_env : Map.ExtS
    with type key = t and module Set := Set_env</abbr>

  module Set : CSig.SetS with type elt = t
  <abbr class="mark-warning" title="Can only do `with` on types in module types">module Map : Map.ExtS
    with type key = t and module Set := Set</abbr>

end

(** Better to have it here that in Closure, since required in grammar.cma *)
(* XXX: Move to a module *)
type evaluable_global_reference =
  | EvalVarRef of Id.t
  | EvalConstRef of Constant.t

val eq_egr : evaluable_global_reference -&gt;  evaluable_global_reference -&gt; bool

(** Located identifiers and objects with syntax. *)

type lident = Id.t CAst.t
type lname = Name.t CAst.t
type lstring = string CAst.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#names.mli"><code>Names_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Module Id.
  Parameter t : Set.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter hash : t -&gt; Z.
  
  Parameter is_valid : string -&gt; bool.
  
  Parameter of_bytes : string -&gt; t.
  
  Parameter of_string : string -&gt; t.
  
  Parameter of_string_soft : string -&gt; t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter print : t -&gt; Pp.t.
  
  Parameter __Set : {t : _ &amp; __Set.S.signature t t}.
  
  Parameter Map : {'[t, __Set_t] : _ &amp; Map.ExtS.signature t t __Set_t}.
  
  Parameter Pred : {t : _ &amp; Predicate.S.signature t t}.
  
  Parameter List : {_ : unit &amp; List.MonoS.signature t}.
  
  Parameter hcons : t -&gt; t.
End Id.

Module Name.
  Inductive t : Set :=
  | Anonymous : t
  | Name : Id.t -&gt; t.
  
  Parameter mk_name : Id.t -&gt; t.
  
  Parameter is_anonymous : t -&gt; bool.
  
  Parameter is_name : t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
  
  Parameter hcons : t -&gt; t.
  
  Parameter print : t -&gt; Pp.t.
End Name.

Inductive name : Set :=
| Anonymous : name
| Name : Id.t -&gt; name.

Definition variable := Id.t.

Definition module_ident := Id.t.

Parameter ModIdset : {t : _ &amp; __Set.S.signature module_ident t}.

Parameter ModIdmap :
  {'[t, __Set_t] : _ &amp; Map.ExtS.signature module_ident t __Set_t}.

Module DirPath.
  Parameter t : Set.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter hash : t -&gt; Z.
  
  Parameter make : list module_ident -&gt; t.
  
  Parameter repr : t -&gt; list module_ident.
  
  Parameter empty : t.
  
  Parameter is_empty : t -&gt; bool.
  
  Parameter initial : t.
  
  Parameter hcons : t -&gt; t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter print : t -&gt; Pp.t.
End DirPath.

Module Label.
  Parameter t : Set.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter hash : t -&gt; Z.
  
  Parameter make : string -&gt; t.
  
  Parameter of_id : Id.t -&gt; t.
  
  Parameter to_id : t -&gt; Id.t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter print : t -&gt; Pp.t.
  
  Parameter __Set : {t : _ &amp; __Set.S.signature t t}.
  
  Parameter Map : {'[t, __Set_t] : _ &amp; Map.ExtS.signature t t __Set_t}.
  
  Parameter hcons : t -&gt; t.
End Label.

Module MBId.
  Parameter t : Set.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter hash : t -&gt; Z.
  
  Parameter make : DirPath.t -&gt; Id.t -&gt; t.
  
  Parameter repr : t -&gt; Z * Id.t * DirPath.t.
  
  Parameter to_id : t -&gt; Id.t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter debug_to_string : t -&gt; string.
End MBId.

Parameter MBIset : {t : _ &amp; __Set.S.signature MBId.t t}.

Parameter MBImap : {'[t, __Set_t] : _ &amp; Map.ExtS.signature MBId.t t __Set_t}.

Module ModPath.
  Inductive t : Set :=
  | MPfile : DirPath.t -&gt; t
  | MPbound : MBId.t -&gt; t
  | MPdot : t -&gt; Label.t -&gt; t.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
  
  Parameter is_bound : t -&gt; bool.
  
  Parameter initial : t.
  
  Parameter dp : t -&gt; DirPath.t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter debug_to_string : t -&gt; string.
End ModPath.

Parameter MPset : {t : _ &amp; __Set.S.signature ModPath.t t}.

Parameter MPmap : {'[t, __Set_t] : _ &amp; Map.ExtS.signature ModPath.t t __Set_t}.

Module KerName.
  Parameter t : Set.
  
  Parameter make : ModPath.t -&gt; Label.t -&gt; t.
  
  Parameter repr : t -&gt; ModPath.t * Label.t.
  
  Parameter make2 : ModPath.t -&gt; Label.t -&gt; t.
  
  Parameter modpath : t -&gt; ModPath.t.
  
  Parameter label : t -&gt; Label.t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter print : t -&gt; Pp.t.
  
  Parameter debug_to_string : t -&gt; string.
  
  Parameter debug_print : t -&gt; Pp.t.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
End KerName.

Parameter KNset : {t : _ &amp; CSig.SetS.signature KerName.t t}.

Parameter KNpred : {t : _ &amp; Predicate.S.signature KerName.t t}.

Parameter KNmap : {'[t, __Set_t] : _ &amp; Map.ExtS.signature KerName.t t __Set_t}.

Module Constant.
  Parameter t : Set.
  
  Parameter make : KerName.t -&gt; KerName.t -&gt; t.
  
  Parameter make1 : KerName.t -&gt; t.
  
  Parameter make2 : ModPath.t -&gt; Label.t -&gt; t.
  
  Parameter user : t -&gt; KerName.t.
  
  Parameter canonical : t -&gt; KerName.t.
  
  Parameter repr2 : t -&gt; ModPath.t * Label.t.
  
  Parameter modpath : t -&gt; ModPath.t.
  
  Parameter label : t -&gt; Label.t.
  
  Module CanOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End CanOrd.
  
  Module UserOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End UserOrd.
  
  Module SyntacticOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End SyntacticOrd.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
  
  Parameter change_label : t -&gt; Label.t -&gt; t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter print : t -&gt; Pp.t.
  
  Parameter debug_to_string : t -&gt; string.
  
  Parameter debug_print : t -&gt; Pp.t.
End Constant.

Parameter Cpred : {t : _ &amp; Predicate.S.signature Constant.t t}.

Parameter Cset : {t : _ &amp; CSig.SetS.signature Constant.t t}.

Parameter Cset_env : {t : _ &amp; CSig.SetS.signature Constant.t t}.

Parameter Cmap : {'[t, __Set_t] : _ &amp; Map.ExtS.signature Constant.t t __Set_t}.

Parameter Cmap_env :
  {'[t, __Set_t] : _ &amp; Map.ExtS.signature Constant.t t __Set_t}.

Module MutInd.
  Parameter t : Set.
  
  Parameter make : KerName.t -&gt; KerName.t -&gt; t.
  
  Parameter make1 : KerName.t -&gt; t.
  
  Parameter make2 : ModPath.t -&gt; Label.t -&gt; t.
  
  Parameter user : t -&gt; KerName.t.
  
  Parameter canonical : t -&gt; KerName.t.
  
  Parameter repr2 : t -&gt; ModPath.t * Label.t.
  
  Parameter modpath : t -&gt; ModPath.t.
  
  Parameter label : t -&gt; Label.t.
  
  Module CanOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End CanOrd.
  
  Module UserOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End UserOrd.
  
  Module SyntacticOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End SyntacticOrd.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
  
  Parameter to_string : t -&gt; string.
  
  Parameter print : t -&gt; Pp.t.
  
  Parameter debug_to_string : t -&gt; string.
  
  Parameter debug_print : t -&gt; Pp.t.
End MutInd.

Parameter Mindset : {t : _ &amp; CSig.SetS.signature MutInd.t t}.

Parameter Mindmap : {'[t, __Set_t] : _ &amp; Map.ExtS.signature MutInd.t t __Set_t}.

Parameter Mindmap_env : {t : _ &amp; CSig.MapS.signature MutInd.t t}.

Definition inductive := MutInd.t * Z.

Definition constructor := inductive * Z.

Parameter Indmap : {t : _ &amp; CSig.MapS.signature inductive t}.

Parameter Constrmap : {t : _ &amp; CSig.MapS.signature constructor t}.

Parameter Indmap_env : {t : _ &amp; CSig.MapS.signature inductive t}.

Parameter Constrmap_env : {t : _ &amp; CSig.MapS.signature constructor t}.

Parameter ind_modpath : inductive -&gt; ModPath.t.

Parameter constr_modpath : constructor -&gt; ModPath.t.

Parameter ith_mutual_inductive : inductive -&gt; Z -&gt; inductive.

Parameter ith_constructor_of_inductive : inductive -&gt; Z -&gt; constructor.

Parameter inductive_of_constructor : constructor -&gt; inductive.

Parameter index_of_constructor : constructor -&gt; Z.

Parameter eq_ind : inductive -&gt; inductive -&gt; bool.

Parameter eq_user_ind : inductive -&gt; inductive -&gt; bool.

Parameter eq_syntactic_ind : inductive -&gt; inductive -&gt; bool.

Parameter ind_ord : inductive -&gt; inductive -&gt; Z.

Parameter ind_hash : inductive -&gt; Z.

Parameter ind_user_ord : inductive -&gt; inductive -&gt; Z.

Parameter ind_user_hash : inductive -&gt; Z.

Parameter ind_syntactic_ord : inductive -&gt; inductive -&gt; Z.

Parameter ind_syntactic_hash : inductive -&gt; Z.

Parameter eq_constructor : constructor -&gt; constructor -&gt; bool.

Parameter eq_user_constructor : constructor -&gt; constructor -&gt; bool.

Parameter eq_syntactic_constructor : constructor -&gt; constructor -&gt; bool.

Parameter constructor_ord : constructor -&gt; constructor -&gt; Z.

Parameter constructor_hash : constructor -&gt; Z.

Parameter constructor_user_ord : constructor -&gt; constructor -&gt; Z.

Parameter constructor_user_hash : constructor -&gt; Z.

Parameter constructor_syntactic_ord : constructor -&gt; constructor -&gt; Z.

Parameter constructor_syntactic_hash : constructor -&gt; Z.

Parameter hcons_con : Constant.t -&gt; Constant.t.

Parameter hcons_mind : MutInd.t -&gt; MutInd.t.

Parameter hcons_ind : inductive -&gt; inductive.

Parameter hcons_construct : constructor -&gt; constructor.

Inductive tableKey (a : Set) : Set :=
| ConstKey : a -&gt; tableKey a
| VarKey : Id.t -&gt; tableKey a
| RelKey : Int.t -&gt; tableKey a.

Arguments ConstKey {_}.
Arguments VarKey {_}.
Arguments RelKey {_}.

Definition inv_rel_key := Z.

Parameter eq_table_key : forall {a : Set},
  (a -&gt; a -&gt; bool) -&gt; tableKey a -&gt; tableKey a -&gt; bool.

Parameter eq_constant_key : Constant.t -&gt; Constant.t -&gt; bool.

Parameter eq_ind_chk : inductive -&gt; inductive -&gt; bool.

Inductive module_path : Set :=
| MPfile : DirPath.t -&gt; module_path
| MPbound : MBId.t -&gt; module_path
| MPdot : ModPath.t -&gt; Label.t -&gt; module_path.

Module Projection.
  Module Repr.
    Parameter t : Set.
    
    Parameter make : inductive -&gt; Z -&gt; Z -&gt; Label.t -&gt; t.
    
    Module SyntacticOrd.
      Parameter compare : t -&gt; t -&gt; Z.
      
      Parameter equal : t -&gt; t -&gt; bool.
      
      Parameter hash : t -&gt; Z.
    End SyntacticOrd.
    
    Module CanOrd.
      Parameter compare : t -&gt; t -&gt; Z.
      
      Parameter equal : t -&gt; t -&gt; bool.
      
      Parameter hash : t -&gt; Z.
    End CanOrd.
    
    Module UserOrd.
      Parameter compare : t -&gt; t -&gt; Z.
      
      Parameter equal : t -&gt; t -&gt; bool.
      
      Parameter hash : t -&gt; Z.
    End UserOrd.
    
    Parameter constant : t -&gt; Constant.t.
    
    Parameter inductive : t -&gt; inductive.
    
    Parameter mind : t -&gt; MutInd.t.
    
    Parameter npars : t -&gt; Z.
    
    Parameter arg : t -&gt; Z.
    
    Parameter label : t -&gt; Label.t.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
    
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter map : (MutInd.t -&gt; MutInd.t) -&gt; t -&gt; t.
    
    Parameter map_npars : (MutInd.t -&gt; Z -&gt; MutInd.t * Z) -&gt; t -&gt; t.
    
    Parameter to_string : t -&gt; string.
    
    Parameter print : t -&gt; Pp.t.
  End Repr.
  
  Parameter t : Set.
  
  Parameter make : Repr.t -&gt; bool -&gt; t.
  
  Parameter repr : t -&gt; Repr.t.
  
  Module SyntacticOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End SyntacticOrd.
  
  Module CanOrd.
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End CanOrd.
  
  Parameter constant : t -&gt; Constant.t.
  
  Parameter mind : t -&gt; MutInd.t.
  
  Parameter inductive : t -&gt; inductive.
  
  Parameter npars : t -&gt; Z.
  
  Parameter arg : t -&gt; Z.
  
  Parameter label : t -&gt; Label.t.
  
  Parameter unfolded : t -&gt; bool.
  
  Parameter unfold : t -&gt; t.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
  
  Parameter hcons : t -&gt; t.
  
  Parameter repr_equal : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter map : (MutInd.t -&gt; MutInd.t) -&gt; t -&gt; t.
  
  Parameter map_npars : (MutInd.t -&gt; Z -&gt; MutInd.t * Z) -&gt; t -&gt; t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter print : t -&gt; Pp.t.
End Projection.

Module GlobRef.
  Inductive t : Set :=
  | VarRef : variable -&gt; t
  | ConstRef : Constant.t -&gt; t
  | IndRef : inductive -&gt; t
  | ConstructRef : constructor -&gt; t.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Module Ordered.
    Definition t := t.
    
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End Ordered.
  
  Module Ordered_env.
    Definition t := t.
    
    Parameter compare : t -&gt; t -&gt; Z.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
  End Ordered_env.
  
  Parameter Set_env : {t : _ &amp; CSig.SetS.signature t t}.
  
  Parameter Map_env : {'[t, __Set_t] : _ &amp; Map.ExtS.signature t t __Set_t}.
  
  Parameter __Set : {t : _ &amp; CSig.SetS.signature t t}.
  
  Parameter Map : {'[t, __Set_t] : _ &amp; Map.ExtS.signature t t __Set_t}.
End GlobRef.

Inductive evaluable_global_reference : Set :=
| EvalVarRef : Id.t -&gt; evaluable_global_reference
| EvalConstRef : Constant.t -&gt; evaluable_global_reference.

Parameter eq_egr :
  evaluable_global_reference -&gt; evaluable_global_reference -&gt; bool.

Definition lident := CAst.t Id.t.

Definition lname := CAst.t Name.t.

Definition lstring := CAst.t string.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativecode.ml">
  <div style="margin: 20px;">
    <h3>Nativecode</h3>
    <ul>
      <li>OCaml size: 2137 lines</li>
      <li>Coq size: 3688 lines (+72% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativecode.ml"><code>nativecode.ml</code></a>&nbsp;<span class="label label-warning">150 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Names
open Constr
open Context
open Declarations
open Util
open Nativevalues
open Nativelambda
open Environ

[@@@ocaml.warning &quot;-32-37&quot;]

(** This file defines the mllambda code generation phase of the native
compiler. mllambda represents a fragment of ML, and can easily be printed
to OCaml code. *)

(** Local names **)

(* The first component is there for debugging purposes only *)
type lname = { lname : Name.t; luid : int }

let eq_lname ln1 ln2 =
  Int.equal ln1.luid ln2.luid

let dummy_lname = { lname = Anonymous; luid = -1 }

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module LNord =
  struct
    type t = lname
    let compare l1 l2 = l1.luid - l2.luid
  end</abbr>
module LNmap = Map.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">LNord</abbr>)
module LNset = Set.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">LNord</abbr>)

let lname_ctr = ref (-1)

let fresh_lname n =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr lname_ctr;
  { lname = n; luid = !lname_ctr }</abbr>

(** Global names **)
type gname =
  | Gind of string * inductive (* prefix, inductive name *)
  | Gconstruct of string * constructor (* prefix, constructor name *)
  | Gconstant of string * Constant.t (* prefix, constant name *)
  | Gproj of string * inductive * int (* prefix, inductive, index (start from 0) *)
  | Gcase of Label.t option * int
  | Gpred of Label.t option * int
  | Gfixtype of Label.t option * int
  | Gnorm of Label.t option * int
  | Gnormtbl of Label.t option * int
  | Ginternal of string
  | Grel of int
  | Gnamed of Id.t

let eq_gname gn1 gn2 =
  match gn1, gn2 with
  | Gind (s1, ind1), Gind (s2, ind2) -&gt;
     String.equal s1 s2 &amp;&amp; eq_ind ind1 ind2
  | Gconstruct (s1, c1), Gconstruct (s2, c2) -&gt;
      String.equal s1 s2 &amp;&amp; eq_constructor c1 c2
  | Gconstant (s1, c1), Gconstant (s2, c2) -&gt;
      String.equal s1 s2 &amp;&amp; Constant.equal c1 c2
  | Gproj (s1, ind1, i1), Gproj (s2, ind2, i2) -&gt;
    String.equal s1 s2 &amp;&amp; eq_ind ind1 ind2 &amp;&amp; Int.equal i1 i2
  | Gcase (None, i1), Gcase (None, i2) -&gt; Int.equal i1 i2
  | Gcase (Some l1, i1), Gcase (Some l2, i2) -&gt; Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gpred (None, i1), Gpred (None, i2) -&gt; Int.equal i1 i2
  | Gpred (Some l1, i1), Gpred (Some l2, i2) -&gt; Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gfixtype (None, i1), Gfixtype (None, i2) -&gt; Int.equal i1 i2
  | Gfixtype (Some l1, i1), Gfixtype (Some l2, i2) -&gt;
      Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gnorm (None, i1), Gnorm (None, i2) -&gt; Int.equal i1 i2
  | Gnorm (Some l1, i1), Gnorm (Some l2, i2) -&gt; Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Gnormtbl (None, i1), Gnormtbl (None, i2) -&gt; Int.equal i1 i2
  | Gnormtbl (Some l1, i1), Gnormtbl (Some l2, i2) -&gt;
      Int.equal i1 i2 &amp;&amp; Label.equal l1 l2
  | Ginternal s1, Ginternal s2 -&gt; String.equal s1 s2
  | Grel i1, Grel i2 -&gt; Int.equal i1 i2
  | Gnamed id1, Gnamed id2 -&gt; Id.equal id1 id2
  | (Gind _| Gconstruct _ | Gconstant _ | Gproj _ | Gcase _ | Gpred _
    | Gfixtype _ | Gnorm _ | Gnormtbl _ | Ginternal _ | Grel _ | Gnamed _), _ -&gt;
      false

let dummy_gname =
  Grel 0

open Hashset.Combine

let gname_hash gn = match gn with
| Gind (s, ind) -&gt;
   combinesmall 1 (combine (String.hash s) (ind_hash ind))
| Gconstruct (s, c) -&gt;
   combinesmall 2 (combine (String.hash s) (constructor_hash c))
| Gconstant (s, c) -&gt;
   combinesmall 3 (combine (String.hash s) (Constant.hash c))
| Gcase (l, i) -&gt; combinesmall 4 (combine (Option.hash Label.hash l) (Int.hash i))
| Gpred (l, i) -&gt; combinesmall 5 (combine (Option.hash Label.hash l) (Int.hash i))
| Gfixtype (l, i) -&gt; combinesmall 6 (combine (Option.hash Label.hash l) (Int.hash i))
| Gnorm (l, i) -&gt; combinesmall 7 (combine (Option.hash Label.hash l) (Int.hash i))
| Gnormtbl (l, i) -&gt; combinesmall 8 (combine (Option.hash Label.hash l) (Int.hash i))
| Ginternal s -&gt; combinesmall 9 (String.hash s)
| Grel i -&gt; combinesmall 10 (Int.hash i)
| Gnamed id -&gt; combinesmall 11 (Id.hash id)
| Gproj (s, p, i) -&gt; combinesmall 12 (combine (String.hash s) (combine (ind_hash p) i))

let case_ctr = ref (-1)

let fresh_gcase l =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr case_ctr;
  Gcase (l,!case_ctr)</abbr>

let pred_ctr = ref (-1)

let fresh_gpred l =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr pred_ctr;
  Gpred (l,!pred_ctr)</abbr>

let fixtype_ctr = ref (-1)

let fresh_gfixtype l =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr fixtype_ctr;
  Gfixtype (l,!fixtype_ctr)</abbr>

let norm_ctr = ref (-1)

let fresh_gnorm l =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr norm_ctr;
  Gnorm (l,!norm_ctr)</abbr>

let normtbl_ctr = ref (-1)

let fresh_gnormtbl l =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">incr normtbl_ctr;
  Gnormtbl (l,!normtbl_ctr)</abbr>

(** Symbols (pre-computed values) **)

type symbol =
  | SymbValue of Nativevalues.t
  | SymbSort of Sorts.t
  | SymbName of Name.t
  | SymbConst of Constant.t
  | SymbMatch of annot_sw
  | SymbInd of inductive
  | SymbMeta of metavariable
  | SymbEvar of Evar.t
  | SymbLevel of Univ.Level.t
  | SymbProj of (inductive * int)

let dummy_symb = SymbValue (dummy_value ())

let eq_symbol sy1 sy2 =
  match sy1, sy2 with
  | SymbValue v1, SymbValue v2 -&gt; Pervasives.(=) v1 v2 (** FIXME: how is this even valid? *)
  | SymbSort s1, SymbSort s2 -&gt; Sorts.equal s1 s2
  | SymbName n1, SymbName n2 -&gt; Name.equal n1 n2
  | SymbConst kn1, SymbConst kn2 -&gt; Constant.equal kn1 kn2
  | SymbMatch sw1, SymbMatch sw2 -&gt; eq_annot_sw sw1 sw2
  | SymbInd ind1, SymbInd ind2 -&gt; eq_ind ind1 ind2
  | SymbMeta m1, SymbMeta m2 -&gt; Int.equal m1 m2
  | SymbEvar evk1, SymbEvar evk2 -&gt; Evar.equal evk1 evk2
  | SymbLevel l1, SymbLevel l2 -&gt; Univ.Level.equal l1 l2
  | SymbProj (i1, k1), SymbProj (i2, k2) -&gt; eq_ind i1 i2 &amp;&amp; Int.equal k1 k2
  | _, _ -&gt; false

let hash_symbol symb =
  match symb with
  | SymbValue v -&gt; combinesmall 1 (Hashtbl.hash v) (** FIXME *)
  | SymbSort s -&gt; combinesmall 2 (Sorts.hash s)
  | SymbName name -&gt; combinesmall 3 (Name.hash name)
  | SymbConst c -&gt; combinesmall 4 (Constant.hash c)
  | SymbMatch sw -&gt; combinesmall 5 (hash_annot_sw sw)
  | SymbInd ind -&gt; combinesmall 6 (ind_hash ind)
  | SymbMeta m -&gt; combinesmall 7 m
  | SymbEvar evk -&gt; combinesmall 8 (Evar.hash evk)
  | SymbLevel l -&gt; combinesmall 9 (Univ.Level.hash l)
  | SymbProj (i, k) -&gt; combinesmall 10 (combine (ind_hash i) k)

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module HashedTypeSymbol = struct
  type t = symbol
  let equal = eq_symbol
  let hash = hash_symbol
end</abbr>

module HashtblSymbol = Hashtbl.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashedTypeSymbol</abbr>)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">symb_tbl</abbr> = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashtblSymbol.create</abbr> 211

let clear_symbols () = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashtblSymbol.clear</abbr> symb_tbl

type symbols = symbol array

let empty_symbols = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

let get_value tbl i =
  match tbl.(i) with
    | SymbValue v -&gt; v
    | _ -&gt; anomaly (Pp.str &quot;get_value failed.&quot;)

let get_sort tbl i =
  match tbl.(i) with
    | SymbSort s -&gt; s
    | _ -&gt; anomaly (Pp.str &quot;get_sort failed.&quot;)

let get_name tbl i =
  match tbl.(i) with
    | SymbName id -&gt; id
    | _ -&gt; anomaly (Pp.str &quot;get_name failed.&quot;)

let get_const tbl i =
  match tbl.(i) with
    | SymbConst kn -&gt; kn
    | _ -&gt; anomaly (Pp.str &quot;get_const failed.&quot;)

let get_match tbl i =
  match tbl.(i) with
    | SymbMatch case_info -&gt; case_info
    | _ -&gt; anomaly (Pp.str &quot;get_match failed.&quot;)

let get_ind tbl i =
  match tbl.(i) with
    | SymbInd ind -&gt; ind
    | _ -&gt; anomaly (Pp.str &quot;get_ind failed.&quot;)

let get_meta tbl i =
  match tbl.(i) with
    | SymbMeta m -&gt; m
    | _ -&gt; anomaly (Pp.str &quot;get_meta failed.&quot;)

let get_evar tbl i =
  match tbl.(i) with
    | SymbEvar ev -&gt; ev
    | _ -&gt; anomaly (Pp.str &quot;get_evar failed.&quot;)

let get_level tbl i =
  match tbl.(i) with
    | SymbLevel u -&gt; u
    | _ -&gt; anomaly (Pp.str &quot;get_level failed.&quot;)

let get_proj tbl i =
  match tbl.(i) with
    | SymbProj p -&gt; p
    | _ -&gt; anomaly (Pp.str &quot;get_proj failed.&quot;)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">push_symbol</abbr> x =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashtblSymbol.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> symb_tbl x
  with Not_found -&gt;
    let i = HashtblSymbol.length symb_tbl in
    HashtblSymbol.add symb_tbl x i; i</abbr>

let symbols_tbl_name = Ginternal &quot;symbols_tbl&quot;

let get_symbols () =
  let tbl = Array.make (<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashtblSymbol.length</abbr> symb_tbl) dummy_symb in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">HashtblSymbol.iter (fun x i -&gt; tbl.(i) &lt;- x) symb_tbl; tbl</abbr>

(** Lambda to Mllambda **)

type primitive =
  | Mk_prod
  | Mk_sort
  | Mk_ind
  | Mk_const
  | Mk_sw
  | Mk_fix of rec_pos * int
  | Mk_cofix of int
  | Mk_rel of int
  | Mk_var of Id.t
  | Mk_proj
  | Is_int
  | Cast_accu
  | Upd_cofix
  | Force_cofix
  | Mk_uint
  | Mk_int
  | Mk_bool
  | Val_to_int
  | Mk_meta
  | Mk_evar
  | MLand
  | MLle
  | MLlt
  | MLinteq
  | MLlsl
  | MLlsr
  | MLland
  | MLlor
  | MLlxor
  | MLadd
  | MLsub
  | MLmul
  | MLmagic
  | MLarrayget
  | Mk_empty_instance
  | Coq_primitive of CPrimitives.t * (prefix * pconstant) option

let eq_primitive p1 p2 =
  match p1, p2 with
  | Mk_prod, Mk_prod -&gt; true
  | Mk_sort, Mk_sort -&gt; true
  | Mk_ind, Mk_ind -&gt; true
  | Mk_const, Mk_const -&gt; true
  | Mk_sw, Mk_sw -&gt; true
  | Mk_fix (rp1, i1), Mk_fix (rp2, i2) -&gt; Int.equal i1 i2 &amp;&amp; eq_rec_pos rp1 rp2
  | Mk_cofix i1, Mk_cofix i2 -&gt; Int.equal i1 i2
  | Mk_rel i1, Mk_rel i2 -&gt; Int.equal i1 i2
  | Mk_var id1, Mk_var id2 -&gt; Id.equal id1 id2
  | Cast_accu, Cast_accu -&gt; true
  | Upd_cofix, Upd_cofix -&gt; true
  | Force_cofix, Force_cofix -&gt; true
  | Mk_meta, Mk_meta -&gt; true
  | Mk_evar, Mk_evar -&gt; true
  | Mk_proj, Mk_proj -&gt; true
  | MLarrayget, MLarrayget -&gt; true

  | _ -&gt; false

let primitive_hash = function
  | Mk_prod -&gt; 1
  | Mk_sort -&gt; 2
  | Mk_ind -&gt; 3
  | Mk_const -&gt; 4
  | Mk_sw -&gt; 5
  | Mk_fix (r, i) -&gt;
     let h = Array.fold_left (fun h i -&gt; combine h (Int.hash i)) 0 r in
     combinesmall 6 (combine h (Int.hash i))
  | Mk_cofix i -&gt;
     combinesmall 7 (Int.hash i)
  | Mk_rel i -&gt;
     combinesmall 8 (Int.hash i)
  | Mk_var id -&gt;
     combinesmall 9 (Id.hash id)
  | Is_int -&gt; 11
  | Cast_accu -&gt; 12
  | Upd_cofix -&gt; 13
  | Force_cofix -&gt; 14
  | Mk_uint -&gt; 15
  | Mk_int -&gt; 16
  | Mk_bool -&gt; 17
  | Val_to_int -&gt; 18
  | Mk_meta -&gt; 19
  | Mk_evar -&gt; 20
  | MLand -&gt; 21
  | MLle -&gt; 22
  | MLlt -&gt; 23
  | MLinteq -&gt; 24
  | MLlsl -&gt; 25
  | MLlsr -&gt; 26
  | MLland -&gt; 27
  | MLlor -&gt; 28
  | MLlxor -&gt; 29
  | MLadd -&gt; 30
  | MLsub -&gt; 31
  | MLmul -&gt; 32
  | MLmagic -&gt; 33
  | Coq_primitive (prim, None) -&gt; combinesmall 34 (CPrimitives.hash prim)
  | Coq_primitive (prim, Some (prefix,(kn,_))) -&gt;
     combinesmall 35 (combine3 (String.hash prefix) (Constant.hash kn) (CPrimitives.hash prim))
  | Mk_proj -&gt; 36
  | MLarrayget -&gt; 37
  | Mk_empty_instance -&gt; 38

type mllambda =
  | MLlocal        of lname
  | MLglobal       of gname
  | MLprimitive    of primitive
  | MLlam          of lname array * mllambda
  | MLletrec       of (lname * lname array * mllambda) array * mllambda
  | MLlet          of lname * mllambda * mllambda
  | MLapp          of mllambda * mllambda array
  | MLif           of mllambda * mllambda * mllambda
  | MLmatch        of annot_sw * mllambda * mllambda * mllam_branches
                              (* argument, prefix, accu branch, branches *)
  | MLconstruct    of string * constructor * mllambda array
                   (* prefix, constructor name, arguments *)
  | MLint          of int
  | MLuint         of Uint63.t
  | MLsetref       of string * mllambda
  | MLsequence     of mllambda * mllambda
  | MLarray        of mllambda array
  | MLisaccu       of string * inductive * mllambda

and mllam_branches = ((constructor * lname option array) list * mllambda) array

let push_lnames n env lns =
  snd (Array.fold_left (fun (i,r) x -&gt; (i+1, LNmap.add x i r)) (n,env) lns)

let opush_lnames n env lns =
  let oadd x i r = match x with Some ln -&gt; LNmap.add ln i r | None -&gt; r in
  snd (Array.fold_left (fun (i,r) x -&gt; (i+1, oadd x i r)) (n,env) lns)

(* Alpha-equivalence on mllambda *)
(* eq_mllambda gn1 gn2 n env1 env2 t1 t2 tests if t1 = t2 modulo gn1 = gn2 *)
let rec eq_mllambda gn1 gn2 n env1 env2 t1 t2 =
  match t1, t2 with
  | MLlocal ln1, MLlocal ln2 -&gt;
     <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
      Int.equal (LNmap.find ln1 env1) (LNmap.find ln2 env2)
     with Not_found -&gt;
      eq_lname ln1 ln2)</abbr>
  | MLglobal gn1', MLglobal gn2' -&gt;
      eq_gname gn1' gn2' || (eq_gname gn1 gn1' &amp;&amp; eq_gname gn2 gn2')
      || (eq_gname gn1 gn2' &amp;&amp; eq_gname gn2 gn1')
  | MLprimitive prim1, MLprimitive prim2 -&gt; eq_primitive prim1 prim2
  | MLlam (lns1, ml1), MLlam (lns2, ml2) -&gt;
      Int.equal (Array.length lns1) (Array.length lns2) &amp;&amp;
      let env1 = push_lnames n env1 lns1 in
      let env2 = push_lnames n env2 lns2 in
      eq_mllambda gn1 gn2 (n+Array.length lns1) env1 env2 ml1 ml2
  | MLletrec (defs1, body1), MLletrec (defs2, body2) -&gt;
      Int.equal (Array.length defs1) (Array.length defs2) &amp;&amp;
      let lns1 = Array.map (fun (x,_,_) -&gt; x) defs1 in
      let lns2 = Array.map (fun (x,_,_) -&gt; x) defs2 in
      let env1 = push_lnames n env1 lns1 in
      let env2 = push_lnames n env2 lns2 in
      let n = n + Array.length defs1 in
      eq_letrec gn1 gn2 n env1 env2 defs1 defs2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 body1 body2
  | MLlet (ln1, def1, body1), MLlet (ln2, def2, body2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 def1 def2 &amp;&amp;
      let env1 = LNmap.add ln1 n env1 in
      let env2 = LNmap.add ln2 n env2 in
      eq_mllambda gn1 gn2 (n+1) env1 env2 body1 body2
  | MLapp (ml1, args1), MLapp (ml2, args2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 ml1 ml2 &amp;&amp;
      Array.equal (eq_mllambda gn1 gn2 n env1 env2) args1 args2
  | MLif (cond1,br1,br'1), MLif (cond2,br2,br'2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 cond1 cond2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 br1 br2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 br'1 br'2
  | MLmatch (annot1, c1, accu1, br1), MLmatch (annot2, c2, accu2, br2) -&gt;
      eq_annot_sw annot1 annot2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 c1 c2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 accu1 accu2 &amp;&amp;
      eq_mllam_branches gn1 gn2 n env1 env2 br1 br2
  | MLconstruct (pf1, cs1, args1), MLconstruct (pf2, cs2, args2) -&gt;
      String.equal pf1 pf2 &amp;&amp;
      eq_constructor cs1 cs2 &amp;&amp;
      Array.equal (eq_mllambda gn1 gn2 n env1 env2) args1 args2
  | MLint i1, MLint i2 -&gt;
      Int.equal i1 i2
  | MLuint i1, MLuint i2 -&gt;
      Uint63.equal i1 i2
  | MLsetref (id1, ml1), MLsetref (id2, ml2) -&gt;
      String.equal id1 id2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 ml1 ml2
  | MLsequence (ml1, ml'1), MLsequence (ml2, ml'2) -&gt;
      eq_mllambda gn1 gn2 n env1 env2 ml1 ml2 &amp;&amp;
      eq_mllambda gn1 gn2 n env1 env2 ml'1 ml'2
  | MLarray arr1, MLarray arr2 -&gt;
      Array.equal (eq_mllambda gn1 gn2 n env1 env2) arr1 arr2

  | MLisaccu (s1, ind1, ml1), MLisaccu (s2, ind2, ml2) -&gt;
    String.equal s1 s2 &amp;&amp; eq_ind ind1 ind2 &amp;&amp;
    eq_mllambda gn1 gn2 n env1 env2 ml1 ml2
  | (MLlocal _ | MLglobal _ | MLprimitive _ | MLlam _ | MLletrec _ | MLlet _ |
    MLapp _ | MLif _ | MLmatch _ | MLconstruct _ | MLint _ | MLuint _ |
    MLsetref _ | MLsequence _ | MLarray _ | MLisaccu _), _ -&gt; false

and eq_letrec gn1 gn2 n env1 env2 defs1 defs2 =
  let eq_def (_,args1,ml1) (_,args2,ml2) =
    Int.equal (Array.length args1) (Array.length args2) &amp;&amp;
    let env1 = push_lnames n env1 args1 in
    let env2 = push_lnames n env2 args2 in
    eq_mllambda gn1 gn2 (n + Array.length args1) env1 env2 ml1 ml2
  in
  Array.equal eq_def defs1 defs2

(* we require here that patterns have the same order, which may be too strong *)
and eq_mllam_branches gn1 gn2 n env1 env2 br1 br2 =
  let eq_cargs (cs1, args1) (cs2, args2) body1 body2 =
    Int.equal (Array.length args1) (Array.length args2) &amp;&amp;
    eq_constructor cs1 cs2 &amp;&amp;
    let env1 = opush_lnames n env1 args1 in
    let env2 = opush_lnames n env2 args2 in
    eq_mllambda gn1 gn2 (n + Array.length args1) env1 env2 body1 body2
  in
  let eq_branch (ptl1,body1) (ptl2,body2) =
   List.equal (fun pt1 pt2 -&gt; eq_cargs pt1 pt2 body1 body2) ptl1 ptl2
  in
  Array.equal eq_branch br1 br2

(* hash_mllambda gn n env t computes the hash for t ignoring occurrences of gn *)
let rec hash_mllambda gn n env t =
  match t with
  | MLlocal ln -&gt; combinesmall 1 (LNmap.find ln env)
  | MLglobal gn' -&gt; combinesmall 2 (if eq_gname gn gn' then 0 else gname_hash gn')
  | MLprimitive prim -&gt; combinesmall 3 (primitive_hash prim)
  | MLlam (lns, ml) -&gt;
      let env = push_lnames n env lns in
      combinesmall 4 (combine (Array.length lns) (hash_mllambda gn (n+1) env ml))
  | MLletrec (defs, body) -&gt;
      let lns = Array.map (fun (x,_,_) -&gt; x) defs in
      let env = push_lnames n env lns in
      let n = n + Array.length defs in
      let h = combine (hash_mllambda gn n env body) (Array.length defs) in
      combinesmall 5 (hash_mllambda_letrec gn n env h defs)
  | MLlet (ln, def, body) -&gt;
      let hdef = hash_mllambda gn n env def in
      let env = LNmap.add ln n env in
      combinesmall 6 (combine hdef (hash_mllambda gn (n+1) env body))
  | MLapp (ml, args) -&gt;
      let h = hash_mllambda gn n env ml in
      combinesmall 7 (hash_mllambda_array gn n env h args)
  | MLif (cond,br,br') -&gt;
      let hcond = hash_mllambda gn n env cond in
      let hbr = hash_mllambda gn n env br in
      let hbr' = hash_mllambda gn n env br' in
      combinesmall 8 (combine3 hcond hbr hbr')
  | MLmatch (annot, c, accu, br) -&gt;
      let hannot = hash_annot_sw annot in
      let hc = hash_mllambda gn n env c in
      let haccu = hash_mllambda gn n env accu in
      combinesmall 9 (hash_mllam_branches gn n env (combine3 hannot hc haccu) br)
  | MLconstruct (pf, cs, args) -&gt;
      let hpf = String.hash pf in
      let hcs = constructor_hash cs in
      combinesmall 10 (hash_mllambda_array gn n env (combine hpf hcs) args)
  | MLint i -&gt;
      combinesmall 11 i
  | MLuint i -&gt;
      combinesmall 12 (Uint63.hash i)
  | MLsetref (id, ml) -&gt;
      let hid = String.hash id in
      let hml = hash_mllambda gn n env ml in
      combinesmall 13 (combine hid hml)
  | MLsequence (ml, ml') -&gt;
      let hml = hash_mllambda gn n env ml in
      let hml' = hash_mllambda gn n env ml' in
      combinesmall 14 (combine hml hml')
  | MLarray arr -&gt;
      combinesmall 15 (hash_mllambda_array gn n env 1 arr)
  | MLisaccu (s, ind, c) -&gt;
      combinesmall 16 (combine (String.hash s) (combine (ind_hash ind) (hash_mllambda gn n env c)))

and hash_mllambda_letrec gn n env init defs =
  let hash_def (_,args,ml) =
    let env = push_lnames n env args in
    let nargs = Array.length args in
    combine nargs (hash_mllambda gn (n + nargs) env ml)
  in
  Array.fold_left (fun acc t -&gt; combine (hash_def t) acc) init defs

and hash_mllambda_array gn n env init arr =
  Array.fold_left (fun acc t -&gt; combine (hash_mllambda gn n env t) acc) init arr

and hash_mllam_branches gn n env init br =
  let hash_cargs (cs, args) body =
    let nargs = Array.length args in
    let hcs = constructor_hash cs in
    let env = opush_lnames n env args in
    let hbody = hash_mllambda gn (n + nargs) env body in
    combine3 nargs hcs hbody
  in
  let hash_branch acc (ptl,body) =
    List.fold_left (fun acc t -&gt; combine (hash_cargs t body) acc) acc ptl
  in
  Array.fold_left hash_branch init br

let fv_lam l =
  let rec aux l bind fv =
    match l with
    | MLlocal l -&gt;
        if LNset.mem l bind then fv else LNset.add l fv
    | MLglobal _ | MLprimitive _  | MLint _ | MLuint _ -&gt; fv
    | MLlam (ln,body) -&gt;
        let bind = Array.fold_right LNset.add ln bind in
        aux body bind fv
    | MLletrec(bodies,def) -&gt;
        let bind =
          Array.fold_right (fun (id,_,_) b -&gt; LNset.add id b) bodies bind in
        let fv_body (_,ln,body) fv =
          let bind = Array.fold_right LNset.add ln bind in
          aux body bind fv in
        Array.fold_right fv_body bodies (aux def bind fv)
    | MLlet(l,def,body) -&gt;
        aux body (LNset.add l bind) (aux def bind fv)
    | MLapp(f,args) -&gt;
        let fv_arg arg fv = aux arg bind fv in
        Array.fold_right fv_arg args (aux f bind fv)
    | MLif(t,b1,b2) -&gt;
        aux t bind (aux b1 bind (aux b2 bind fv))
    | MLmatch(_,a,p,bs) -&gt;
      let fv = aux a bind (aux p bind fv) in
      let fv_bs (cargs, body) fv =
        let bind =
          List.fold_right (fun (_,args) bind -&gt;
            Array.fold_right
              (fun o bind -&gt; match o with
              | Some l -&gt; LNset.add l bind
              | _ -&gt; bind) args bind)
            cargs bind in
        aux body bind fv in
      Array.fold_right fv_bs bs fv
          (* argument, accu branch, branches *)
    | MLconstruct (_,_,p) -&gt;
        Array.fold_right (fun a fv -&gt; aux a bind fv) p fv
    | MLsetref(_,l) -&gt; aux l bind fv
    | MLsequence(l1,l2) -&gt; aux l1 bind (aux l2 bind fv)
    | MLarray arr -&gt; Array.fold_right (fun a fv -&gt; aux a bind fv) arr fv
    | MLisaccu (_, _, body) -&gt; aux body bind fv
  in
  aux l LNset.empty LNset.empty


let mkMLlam params body =
  if Array.is_empty params then body
  else
    match body with
    | MLlam (params', body) -&gt; MLlam(Array.append params params', body)
    | _ -&gt; MLlam(params,body)

let mkMLapp f args =
  if Array.is_empty args then f
  else
    match f with
    | MLapp(f,args') -&gt; MLapp(f,Array.append args' args)
    | _ -&gt; MLapp(f,args)

let mkForceCofix prefix ind arg =
  let name = fresh_lname Anonymous in
  MLlet (name, arg,
    MLif (
      MLisaccu (prefix, ind, MLlocal name),
      MLapp (MLprimitive Force_cofix, <abbr class="mark-warning" title="Arrays not handled.">[|MLlocal name|]</abbr>),
      MLlocal name))

let empty_params = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

let decompose_MLlam c =
  match c with
  | MLlam(ids,c) -&gt; ids,c
  | _ -&gt; empty_params,c

(*s Global declaration *)
type global =
(*  | Gtblname of gname * Id.t array *)
  | Gtblnorm of gname * lname array * mllambda array
  | Gtblfixtype of gname * lname array * mllambda array
  | Glet of gname * mllambda
  | Gletcase of
      gname * lname array * annot_sw * mllambda * mllambda * mllam_branches
  | Gopen of string
  | Gtype of inductive * int array
    (* ind name, arities of constructors *)
  | Gcomment of string

(* Alpha-equivalence on globals *)
let eq_global g1 g2 =
  match g1, g2 with
  | Gtblnorm (gn1,lns1,mls1), Gtblnorm (gn2,lns2,mls2)
  | Gtblfixtype (gn1,lns1,mls1), Gtblfixtype (gn2,lns2,mls2) -&gt;
      Int.equal (Array.length lns1) (Array.length lns2) &amp;&amp;
      Int.equal (Array.length mls1) (Array.length mls2) &amp;&amp;
      let env1 = push_lnames 0 LNmap.empty lns1 in
      let env2 = push_lnames 0 LNmap.empty lns2 in
      Array.for_all2 (eq_mllambda gn1 gn2 (Array.length lns1) env1 env2) mls1 mls2
  | Glet (gn1, def1), Glet (gn2, def2) -&gt;
      eq_mllambda gn1 gn2 0 LNmap.empty LNmap.empty def1 def2
  | Gletcase (gn1,lns1,annot1,c1,accu1,br1),
      Gletcase (gn2,lns2,annot2,c2,accu2,br2) -&gt;
      Int.equal (Array.length lns1) (Array.length lns2) &amp;&amp;
      let env1 = push_lnames 0 LNmap.empty lns1 in
      let env2 = push_lnames 0 LNmap.empty lns2 in
      let t1 = MLmatch (annot1,c1,accu1,br1) in
      let t2 = MLmatch (annot2,c2,accu2,br2) in
      eq_mllambda gn1 gn2 (Array.length lns1) env1 env2 t1 t2
  | Gopen s1, Gopen s2 -&gt; String.equal s1 s2
  | Gtype (ind1, arr1), Gtype (ind2, arr2) -&gt;
      eq_ind ind1 ind2 &amp;&amp; Array.equal Int.equal arr1 arr2
  | Gcomment s1, Gcomment s2 -&gt; String.equal s1 s2
  | _, _ -&gt; false

let hash_global g =
  match g with
  | Gtblnorm (gn,lns,mls) -&gt;
      let nlns = Array.length lns in
      let nmls = Array.length mls in
      let env = push_lnames 0 LNmap.empty lns in
      let hmls = hash_mllambda_array gn nlns env (combine nlns nmls) mls in
      combinesmall 1 hmls
  | Gtblfixtype (gn,lns,mls) -&gt;
      let nlns = Array.length lns in
      let nmls = Array.length mls in
      let env = push_lnames 0 LNmap.empty lns in
      let hmls = hash_mllambda_array gn nlns env (combine nlns nmls) mls in
      combinesmall 2 hmls
  | Glet (gn, def) -&gt;
      combinesmall 3 (hash_mllambda gn 0 LNmap.empty def)
  | Gletcase (gn,lns,annot,c,accu,br) -&gt;
      let nlns = Array.length lns in
      let env = push_lnames 0 LNmap.empty lns in
      let t = MLmatch (annot,c,accu,br) in
      combinesmall 4 (combine nlns (hash_mllambda gn nlns env t))
  | Gopen s -&gt; combinesmall 5 (String.hash s)
  | Gtype (ind, arr) -&gt;
      combinesmall 6 (combine (ind_hash ind) (Array.fold_left combine 0 arr))
  | Gcomment s -&gt; combinesmall 7 (String.hash s)

let global_stack = ref ([] : global list)

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module HashedTypeGlobal = struct
  type t = global
  let equal = eq_global
  let hash = hash_global
end</abbr>

module HashtblGlobal = Hashtbl.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashedTypeGlobal</abbr>)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">global_tbl</abbr> = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashtblGlobal.create</abbr> 19991

let clear_global_tbl () = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashtblGlobal.clear</abbr> global_tbl

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">push_global</abbr> gn t =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">HashtblGlobal.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> global_tbl t
  with Not_found -&gt;
    (global_stack := t :: !global_stack;
    HashtblGlobal.add global_tbl t gn; gn)</abbr>

let push_global_let gn body =
  push_global gn (Glet (gn,body))

let push_global_fixtype gn params body =
  push_global gn (Gtblfixtype (gn,params,body))

let push_global_norm gn params body =
  push_global gn (Gtblnorm (gn, params, body))

let push_global_case gn params annot a accu bs =
  push_global gn (Gletcase (gn, params, annot, a, accu, bs))

(* Compares [t1] and [t2] up to alpha-equivalence. [t1] and [t2] may contain
   free variables. *)
let eq_mllambda t1 t2 =
  eq_mllambda dummy_gname dummy_gname 0 LNmap.empty LNmap.empty t1 t2

(*s Compilation environment *)

type env =
    { env_rel : mllambda list; (* (MLlocal lname) list *)
      env_bound : int; (* length of env_rel *)
      (* free variables *)
      env_urel : (int * mllambda) list ref; (* list of unbound rel *)
      env_named : (Id.t * mllambda) list ref;
      env_univ : lname option}

let empty_env univ () =
  { env_rel = [];
    env_bound = 0;
    env_urel = ref [];
    env_named = ref [];
    env_univ = univ
  }

let push_rel env id =
  let local = fresh_lname id.binder_name in
  local, { env with
           env_rel = MLlocal local :: env.env_rel;
           env_bound = env.env_bound + 1
         }

let push_rels env ids =
  let lnames, env_rel =
    Array.fold_left (fun (names,env_rel) id -&gt;
      let local = fresh_lname id.binder_name in
      (local::names, MLlocal local::env_rel)) ([],env.env_rel) ids in
  Array.of_list (List.rev lnames), { env with
                          env_rel = env_rel;
                          env_bound = env.env_bound + Array.length ids
                        }

let get_rel env id i =
  if i &lt;= env.env_bound then
    List.nth env.env_rel (i-1)
  else
    let i = i - env.env_bound in
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Int.List.assoc i !(env.env_urel)
    with Not_found -&gt;
      let local = MLlocal (fresh_lname id) in
      env.env_urel := (i,local) :: !(env.env_urel);
      local</abbr>

let get_var env id =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Id.List.assoc id !(env.env_named)
  with Not_found -&gt;
    let local = MLlocal (fresh_lname (Name id)) in
    env.env_named := (id, local)::!(env.env_named);
    local</abbr>

let fresh_univ () =
  fresh_lname (Name (Id.of_string &quot;univ&quot;))

(*s Traduction of lambda to mllambda *)

let get_prod_name codom =
  match codom with
  | MLlam(ids,_) -&gt; ids.(0).lname
  | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let get_lname (_,l) =
  match l with
  | MLlocal id -&gt; id
  | _ -&gt; invalid_arg &quot;Nativecode.get_lname&quot;

(* Collects free variables from env in an array of local names *)
let fv_params env =
  let fvn, fvr = !(env.env_named), !(env.env_urel) in
  let size = List.length fvn + List.length fvr in
  let start,params = match env.env_univ with
    | None -&gt; 0, Array.make size dummy_lname
    | Some u -&gt; 1, let t = Array.make (size + 1) dummy_lname in <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">t.(0) &lt;- u; t</abbr>
  in
  if Array.is_empty params then empty_params
  else begin
    let fvn = ref fvn in
    let i = ref start in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">while not (List.is_empty !fvn) do
      params.(!i) &lt;- get_lname (List.hd !fvn);
      fvn := List.tl !fvn;
      incr i
    done;
    let fvr = ref fvr in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">while not (List.is_empty !fvr) do
      params.(!i) &lt;- get_lname (List.hd !fvr);
      fvr := List.tl !fvr;
      incr i
    done;
    params</abbr>
  end

let generalize_fv env body =
  mkMLlam (fv_params env) body

let empty_args = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

let fv_args env fvn fvr =
  let size = List.length fvn + List.length fvr in
  let start,args = match env.env_univ with
    | None -&gt; 0, Array.make size (MLint 0)
    | Some u -&gt; 1, let t = Array.make (size + 1) (MLint 0) in <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">t.(0) &lt;- MLlocal u; t</abbr>
  in
  if Array.is_empty args then empty_args
  else
    begin
      let fvn = ref fvn in
      let i = ref start in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">while not (List.is_empty !fvn) do
        args.(!i) &lt;- get_var env (fst (List.hd !fvn));
        fvn := List.tl !fvn;
        incr i
      done;
      let fvr = ref fvr in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">while not (List.is_empty !fvr) do
        let (k,_ as kml) = List.hd !fvr in
        let n = get_lname kml in
        args.(!i) &lt;- get_rel env n.lname k;
        fvr := List.tl !fvr;
        incr i
      done;
      args</abbr>
    end

let get_value_code i =
  MLapp (MLglobal (Ginternal &quot;get_value&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_sort_code i =
  MLapp (MLglobal (Ginternal &quot;get_sort&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_name_code i =
  MLapp (MLglobal (Ginternal &quot;get_name&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_const_code i =
  MLapp (MLglobal (Ginternal &quot;get_const&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_match_code i =
  MLapp (MLglobal (Ginternal &quot;get_match&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_ind_code i =
  MLapp (MLglobal (Ginternal &quot;get_ind&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_meta_code i =
  MLapp (MLglobal (Ginternal &quot;get_meta&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_evar_code i =
  MLapp (MLglobal (Ginternal &quot;get_evar&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_level_code i =
  MLapp (MLglobal (Ginternal &quot;get_level&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

let get_proj_code i =
  MLapp (MLglobal (Ginternal &quot;get_proj&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal symbols_tbl_name; MLint i|]</abbr>)

type rlist =
  | Rnil
  | Rcons of (constructor * lname option array) list ref * LNset.t * mllambda * rlist'
and rlist' = rlist ref

let rm_params fv params =
  Array.map (fun l -&gt; if LNset.mem l fv then Some l else None) params

let rec insert cargs body rl =
 match !rl with
 | Rnil -&gt;
     let fv = fv_lam body in
     let (c,params) = cargs in
     let params = rm_params fv params in
     rl:= Rcons(ref [(c,params)], fv, body, ref Rnil)
 | Rcons(l,fv,body',rl) -&gt;
     if eq_mllambda body body' then
       let (c,params) = cargs in
       let params = rm_params fv params in
       l := (c,params)::!l
     else insert cargs body rl

let rec to_list rl =
  match !rl with
  | Rnil -&gt; []
  | Rcons(l,_,body,tl) -&gt; (!l,body)::to_list tl

let merge_branches t =
  let newt = ref Rnil in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter (fun (c,args,body) -&gt; insert (c,args) body newt) t;
  Array.of_list (to_list newt)</abbr>

let app_prim p args = MLapp(MLprimitive p, args)

type prim_aux =
  | PAprim of string * pconstant * CPrimitives.t * prim_aux array
  | PAml of mllambda

let add_check cond args =
  let aux cond a =
    match a with
    | PAml(MLint _) -&gt; cond
    | PAml ml -&gt;
       (* FIXME: use explicit equality function *)
       if List.mem ml cond then cond else ml::cond
    | _ -&gt; cond
  in
  Array.fold_left aux cond args

let extract_prim ml_of l =
  let decl = ref [] in
  let cond = ref [] in
  let rec aux l =
    match l with
    | Lprim(prefix,kn,p,args) -&gt;
      let args = Array.map aux args in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">cond := add_check !cond args;
      PAprim(prefix,kn,p,args)</abbr>
    | Lrel _ | Lvar _ | Luint _ | Lval _ | Lconst _ -&gt; PAml (ml_of l)
    | _ -&gt;
      let x = fresh_lname Anonymous in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">decl := (x,ml_of l)::!decl;
      PAml (MLlocal x)</abbr> in
  let res = aux l in
  (!decl, !cond, res)

let cast_to_int v =
  match v with
  | MLint _ -&gt; v
  | _ -&gt; MLapp(MLprimitive Val_to_int, <abbr class="mark-warning" title="Arrays not handled.">[|v|]</abbr>)

let compile_prim decl cond paux =

  <abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">let rec opt_prim_aux paux =
    match paux with
    | PAprim(_prefix, _kn, op, args) -&gt;
      let args = Array.map opt_prim_aux args in
      app_prim (Coq_primitive(op,None)) args
    | PAml ml -&gt; ml

  and naive_prim_aux paux =
    match paux with
    | PAprim(prefix, kn, op, args) -&gt;
      app_prim (Coq_primitive(op, Some (prefix,kn))) (Array.map naive_prim_aux args)
    | PAml ml -&gt; ml
  in

  let compile_cond cond paux =
    match cond with
    | [] -&gt; opt_prim_aux paux
    | [c1] -&gt;
      MLif(app_prim Is_int </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Arrays not handled.">[|c1|]</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">, opt_prim_aux paux, naive_prim_aux paux)
    | c1::cond -&gt;
      let cond =
        List.fold_left
          (fun ml c -&gt; app_prim MLland </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Arrays not handled.">[| ml; cast_to_int c|]</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">)
          (app_prim MLland </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Arrays not handled.">[| cast_to_int c1; MLint 0 |]</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">) cond in
      let cond = app_prim MLmagic </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Arrays not handled.">[|cond|]</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
      MLif(cond, naive_prim_aux paux, opt_prim_aux paux) in

  let add_decl decl body =
    List.fold_left (fun body (x,d) -&gt; MLlet(x,d,body)) body decl in

  (* The optimizations done for checking if integer values are closed are valid
     only on 64-bit architectures. So on 32-bit architectures, we fall back to less optimized checks. *)
  if max_int = 1073741823 (* 32-bits *) then
    add_decl decl (naive_prim_aux paux)
  else
    add_decl decl (compile_cond cond paux)</abbr>

let ml_of_instance instance u =
  let ml_of_level l =
    match Univ.Level.var_index l with
    | Some i -&gt;
       let univ = MLapp(MLprimitive MLmagic, <abbr class="mark-warning" title="Arrays not handled.">[|MLlocal (Option.get instance)|]</abbr>) in
       mkMLapp (MLprimitive MLarrayget) <abbr class="mark-warning" title="Arrays not handled.">[|univ; MLint i|]</abbr>
    | None -&gt; let i = push_symbol (SymbLevel l) in get_level_code i
  in
  let u = Univ.Instance.to_array u in
  if Array.is_empty u then <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>
  else let u = Array.map ml_of_level u in
       <abbr class="mark-warning" title="Arrays not handled.">[|MLapp (MLprimitive MLmagic, </abbr><abbr class="mark-warning" title="Arrays not handled.

——————————

Arrays not handled.">[|MLarray u|]</abbr><abbr class="mark-warning" title="Arrays not handled.">)|]</abbr>

 let rec ml_of_lam env l t =
  match t with
  | Lrel(id ,i) -&gt; get_rel env id i
  | Lvar id -&gt; get_var env id
  | Lmeta(mv,_ty) -&gt;
     let tyn = fresh_lname Anonymous in
     let i = push_symbol (SymbMeta mv) in
     MLapp(MLprimitive Mk_meta, <abbr class="mark-warning" title="Arrays not handled.">[|get_meta_code i; MLlocal tyn|]</abbr>)
  | Levar(evk, args) -&gt;
     let i = push_symbol (SymbEvar evk) in
     (** Arguments are *not* reversed in evar instances in native compilation *)
     let args = MLarray(Array.map (ml_of_lam env l) args) in
     MLapp(MLprimitive Mk_evar, <abbr class="mark-warning" title="Arrays not handled.">[|get_evar_code i; args|]</abbr>)
  | Lprod(dom,codom) -&gt;
      let dom = ml_of_lam env l dom in
      let codom = ml_of_lam env l codom in
      let n = get_prod_name codom in
      let i = push_symbol (SymbName n) in
      MLapp(MLprimitive Mk_prod, <abbr class="mark-warning" title="Arrays not handled.">[|get_name_code i;dom;codom|]</abbr>)
  | Llam(ids,body) -&gt;
    let lnames,env = push_rels env ids in
    MLlam(lnames, ml_of_lam env l body)
  | Lrec(id,body) -&gt;
      let ids,body = decompose_Llam body in
      let lname, env = push_rel env id in
      let lnames, env = push_rels env ids in
      MLletrec(<abbr class="mark-warning" title="Arrays not handled.">[|lname, lnames, ml_of_lam env l body|]</abbr>, MLlocal lname)
  | Llet(id,def,body) -&gt;
      let def = ml_of_lam env l def in
      let lname, env = push_rel env id in
      let body = ml_of_lam env l body in
      MLlet(lname,def,body)
  | Lapp(f,args) -&gt;
      MLapp(ml_of_lam env l f, Array.map (ml_of_lam env l) args)
  | Lconst (prefix, (c, u)) -&gt;
     let args = ml_of_instance env.env_univ u in
     mkMLapp (MLglobal(Gconstant (prefix, c))) args
  | Lproj (prefix, ind, i) -&gt; MLglobal(Gproj (prefix, ind, i))
  | Lprim _ -&gt;
    let decl,cond,paux = extract_prim (ml_of_lam env l) t in
    compile_prim decl cond paux
  | Lcase (annot,p,a,bs) -&gt;
      (* let predicate_uid fv_pred = compilation of p
         let rec case_uid fv a_uid =
           match a_uid with
           | Accu _ =&gt; mk_sw (predicate_uid fv_pred) (case_uid fv) a_uid
           | Ci argsi =&gt; compilation of branches
         compile case = case_uid fv (compilation of a) *)
      (* Compilation of the predicate *)
         (* Remark: if we do not want to compile the predicate we
            should a least compute the fv, then store the lambda representation
            of the predicate (not the mllambda) *)
      let env_p = empty_env env.env_univ () in
      let pn = fresh_gpred l in
      let mlp = ml_of_lam env_p l p in
      let mlp = generalize_fv env_p mlp in
      let (pfvn,pfvr) = !(env_p.env_named), !(env_p.env_urel) in
      let pn = push_global_let pn mlp in
      (* Compilation of the case *)
      let env_c = empty_env env.env_univ () in
      let a_uid = fresh_lname Anonymous in
      let la_uid = MLlocal a_uid in
      (* compilation of branches *)
      let ml_br (c,params, body) =
        let lnames, env_c = push_rels env_c params in
        (c, lnames, ml_of_lam env_c l body)
      in
      let bs = Array.map ml_br bs in
      let cn = fresh_gcase l in
      (* Compilation of accu branch *)
      let pred = MLapp(MLglobal pn, fv_args env_c pfvn pfvr) in
      let (fvn, fvr) = !(env_c.env_named), !(env_c.env_urel) in
      let cn_fv = mkMLapp (MLglobal cn) (fv_args env_c fvn fvr) in
         (* remark : the call to fv_args does not add free variables in env_c *)
      let i = push_symbol (SymbMatch annot) in
      let accu =
        MLapp(MLprimitive Mk_sw,
              <abbr class="mark-warning" title="Arrays not handled.">[| get_match_code i; MLapp (MLprimitive Cast_accu, </abbr><abbr class="mark-warning" title="Arrays not handled.

——————————

Arrays not handled.">[|la_uid|]</abbr><abbr class="mark-warning" title="Arrays not handled.">);
                 pred;
                 cn_fv |]</abbr>) in
(*      let body = MLlam([|a_uid|], MLmatch(annot, la_uid, accu, bs)) in
      let case = generalize_fv env_c body in *)
      let cn = push_global_case cn (Array.append (fv_params env_c) <abbr class="mark-warning" title="Arrays not handled.">[|a_uid|]</abbr>)
        annot la_uid accu (merge_branches bs)
      in
      (* Final result *)
      let arg = ml_of_lam env l a in
      let force =
        if annot.asw_finite then arg
        else mkForceCofix annot.asw_prefix annot.asw_ind arg in
      mkMLapp (MLapp (MLglobal cn, fv_args env fvn fvr)) <abbr class="mark-warning" title="Arrays not handled.">[|force|]</abbr>
  | Lif(t,bt,bf) -&gt;
      MLif(ml_of_lam env l t, ml_of_lam env l bt, ml_of_lam env l bf)
  | Lfix ((rec_pos, inds, start), (ids, tt, tb)) -&gt;
      (* let type_f fvt = [| type fix |]
         let norm_f1 fv f1 .. fn params1 = body1
         ..
         let norm_fn fv f1 .. fn paramsn = bodyn
         let norm fv f1 .. fn =
            [|norm_f1 fv f1 .. fn; ..; norm_fn fv f1 .. fn|]
         compile fix =
           let rec f1 params1 =
             if is_accu rec_pos.(1) then mk_fix (type_f fvt) (norm fv) params1
             else norm_f1 fv f1 .. fn params1
           and .. and fn paramsn =
             if is_accu rec_pos.(n) then mk_fix (type_f fvt) (norm fv) paramsn
             else norm_fn fv f1 .. fv paramsn in
           start
      *)
      (* Compilation of type *)
      let env_t = empty_env env.env_univ () in
      let ml_t = Array.map (ml_of_lam env_t l) tt in
      let params_t = fv_params env_t in
      let args_t = fv_args env !(env_t.env_named) !(env_t.env_urel) in
      let gft = fresh_gfixtype l in
      let gft = push_global_fixtype gft params_t ml_t in
      let mk_type = MLapp(MLglobal gft, args_t) in
      (* Compilation of norm_i *)
      let ndef = Array.length ids in
      let lf,env_n = push_rels (empty_env env.env_univ ()) ids in
      let t_params = Array.make ndef <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr> in
      let t_norm_f = Array.make ndef (Gnorm (l,-1)) in
      let mk_let _envi (id,def) t = MLlet (id,def,t) in
      let mk_lam_or_let (params,lets,env) (id,def) =
        let ln,env' = push_rel env id in
        match def with
        | None -&gt; (ln::params,lets,env')
        | Some lam -&gt; (params, (ln,ml_of_lam env l lam)::lets,env')
      in
      let ml_of_fix i body =
        let varsi, bodyi = decompose_Llam_Llet body in
        let paramsi,letsi,envi =
          Array.fold_left mk_lam_or_let ([],[],env_n) varsi
        in
        let paramsi,letsi =
          Array.of_list (List.rev paramsi), Array.of_list (List.rev letsi)
        in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">t_norm_f.(i) &lt;- fresh_gnorm l;
        let bodyi = ml_of_lam envi l bodyi in
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">t_params.(i) &lt;- paramsi;
        let bodyi = Array.fold_right (mk_let envi) letsi bodyi in
        mkMLlam paramsi bodyi</abbr>
      in
      let tnorm = Array.mapi ml_of_fix tb in
      let fvn,fvr = !(env_n.env_named), !(env_n.env_urel) in
      let fv_params = fv_params env_n in
      let fv_args' = Array.map (fun id -&gt; MLlocal id) fv_params in
      let norm_params = Array.append fv_params lf in
      let t_norm_f = Array.mapi (fun i body -&gt;
        push_global_let (t_norm_f.(i)) (mkMLlam norm_params body)) tnorm in
      let norm = fresh_gnormtbl l in
      let norm = push_global_norm norm fv_params
         (Array.map (fun g -&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
      (* Compilation of fix *)
      let fv_args = fv_args env fvn fvr in
      let lf, _env = push_rels env ids in
      let lf_args = Array.map (fun id -&gt; MLlocal id) lf in
      let mk_norm = MLapp(MLglobal norm, fv_args) in
      let mkrec i lname =
        let paramsi = t_params.(i) in
        let reci = MLlocal (paramsi.(rec_pos.(i))) in
        let pargsi = Array.map (fun id -&gt; MLlocal id) paramsi in
        let (prefix, ind) = inds.(i) in
        let body =
          MLif(MLisaccu (prefix, ind, reci),
               mkMLapp
                 (MLapp(MLprimitive (Mk_fix(rec_pos,i)),
                        <abbr class="mark-warning" title="Arrays not handled.">[|mk_type; mk_norm|]</abbr>))
                 pargsi,
               MLapp(MLglobal t_norm_f.(i),
                     Array.concat [fv_args;lf_args;pargsi]))
        in
        (lname, paramsi, body) in
      MLletrec(Array.mapi mkrec lf, lf_args.(start))
  | Lcofix (start, (ids, tt, tb)) -&gt;
      (* Compilation of type *)
      let env_t = empty_env env.env_univ () in
      let ml_t = Array.map (ml_of_lam env_t l) tt in
      let params_t = fv_params env_t in
      let args_t = fv_args env !(env_t.env_named) !(env_t.env_urel) in
      let gft = fresh_gfixtype l in
      let gft = push_global_fixtype gft params_t ml_t in
      let mk_type = MLapp(MLglobal gft, args_t) in
      (* Compilation of norm_i *)
      let ndef = Array.length ids in
      let lf,env_n = push_rels (empty_env env.env_univ ()) ids in
      let t_params = Array.make ndef <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr> in
      let t_norm_f = Array.make ndef (Gnorm (l,-1)) in
      let ml_of_fix i body =
        let idsi,bodyi = decompose_Llam body in
        let paramsi, envi = push_rels env_n idsi in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">t_norm_f.(i) &lt;- fresh_gnorm l;
        let bodyi = ml_of_lam envi l bodyi in
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">t_params.(i) &lt;- paramsi;
        mkMLlam paramsi bodyi</abbr> in
      let tnorm = Array.mapi ml_of_fix tb in
      let fvn,fvr = !(env_n.env_named), !(env_n.env_urel) in
      let fv_params = fv_params env_n in
      let fv_args' = Array.map (fun id -&gt; MLlocal id) fv_params in
      let norm_params = Array.append fv_params lf in
      let t_norm_f = Array.mapi (fun i body -&gt;
        push_global_let (t_norm_f.(i)) (mkMLlam norm_params body)) tnorm in
      let norm = fresh_gnormtbl l in
      let norm = push_global_norm norm fv_params
        (Array.map (fun g -&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
      (* Compilation of fix *)
      let fv_args = fv_args env fvn fvr in
      let mk_norm = MLapp(MLglobal norm, fv_args) in
      let lnorm = fresh_lname Anonymous in
      let ltype = fresh_lname Anonymous in
      let lf, _env = push_rels env ids in
      let lf_args = Array.map (fun id -&gt; MLlocal id) lf in
      let upd i _lname cont =
        let paramsi = t_params.(i) in
        let pargsi = Array.map (fun id -&gt; MLlocal id) paramsi in
        let uniti = fresh_lname Anonymous in
        let body =
          MLlam(Array.append paramsi <abbr class="mark-warning" title="Arrays not handled.">[|uniti|]</abbr>,
                MLapp(MLglobal t_norm_f.(i),
                      Array.concat [fv_args;lf_args;pargsi])) in
        MLsequence(MLapp(MLprimitive Upd_cofix, <abbr class="mark-warning" title="Arrays not handled.">[|lf_args.(i);body|]</abbr>),
                   cont) in
      let upd = Array.fold_right_i upd lf lf_args.(start) in
      let mk_let i lname cont =
        MLlet(lname,
              MLapp(MLprimitive(Mk_cofix i),<abbr class="mark-warning" title="Arrays not handled.">[| MLlocal ltype; MLlocal lnorm|]</abbr>),
              cont) in
      let init = Array.fold_right_i mk_let lf upd in
      MLlet(lnorm, mk_norm, MLlet(ltype, mk_type, init))
  (*
      let mkrec i lname =
        let paramsi = t_params.(i) in
        let pargsi = Array.map (fun id -&gt; MLlocal id) paramsi in
        let uniti = fresh_lname Anonymous in
        let body =
          MLapp( MLprimitive(Mk_cofix i),
                 [|mk_type;mk_norm;
                   MLlam([|uniti|],
                         MLapp(MLglobal t_norm_f.(i),
                               Array.concat [fv_args;lf_args;pargsi]))|]) in
        (lname, paramsi, body) in
      MLletrec(Array.mapi mkrec lf, lf_args.(start)) *)

  | Lmakeblock (prefix,(cn,_u),_,args) -&gt;
     let args = Array.map (ml_of_lam env l) args in
     MLconstruct(prefix,cn,args)
  | Lconstruct (prefix, (cn,u)) -&gt;
     let uargs = ml_of_instance env.env_univ u in
      mkMLapp (MLglobal (Gconstruct (prefix, cn))) uargs
  | Luint i -&gt; MLapp(MLprimitive Mk_uint, <abbr class="mark-warning" title="Arrays not handled.">[|MLuint i|]</abbr>)
  | Lval v -&gt;
      let i = push_symbol (SymbValue v) in get_value_code i
  | Lsort s -&gt;
    let i = push_symbol (SymbSort s) in
    let uarg = match env.env_univ with
      | None -&gt; MLarray <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>
      | Some u -&gt; MLlocal u
    in
    let uarg = MLapp(MLprimitive MLmagic, <abbr class="mark-warning" title="Arrays not handled.">[|uarg|]</abbr>) in
    MLapp(MLprimitive Mk_sort, <abbr class="mark-warning" title="Arrays not handled.">[|get_sort_code i; uarg|]</abbr>)
  | Lind (prefix, (ind, u)) -&gt;
     let uargs = ml_of_instance env.env_univ u in
     mkMLapp (MLglobal (Gind (prefix, ind))) uargs
  | Llazy -&gt; MLglobal (Ginternal &quot;lazy&quot;)
  | Lforce -&gt; MLglobal (Ginternal &quot;Lazy.force&quot;)

let mllambda_of_lambda univ auxdefs l t =
  let env = empty_env univ () in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">global_stack := auxdefs;
  let ml = ml_of_lam env l t in
  let fv_rel = !(env.env_urel) in
  let fv_named = !(env.env_named) in
  (* build the free variables *)
  let get_lname (_,t) =
   match t with
   | MLlocal x -&gt; x
   | _ -&gt; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert false</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> in
  let params =
    List.append (List.map get_lname fv_rel) (List.map get_lname fv_named) in
  if List.is_empty params then
    (!global_stack, ([],[]), ml)
  (* final result : global list, fv, ml *)
  else
    (!global_stack, (fv_named, fv_rel), mkMLlam (Array.of_list params) ml)</abbr>

(** Code optimization **)

(** Optimization of match and fix *)

let can_subst l =
  match l with
  | MLlocal _ | MLint _ | MLuint _ | MLglobal _ -&gt; true
  | _ -&gt; false

let subst s l =
  if LNmap.is_empty s then l
  else
    let rec aux l =
      match l with
      | MLlocal id -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try LNmap.find id s with Not_found -&gt; l)</abbr>
      | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ -&gt; l
      | MLlam(params,body) -&gt; MLlam(params, aux body)
      | MLletrec(defs,body) -&gt;
        let arec (f,params,body) = (f,params,aux body) in
        MLletrec(Array.map arec defs, aux body)
      | MLlet(id,def,body) -&gt; MLlet(id,aux def, aux body)
      | MLapp(f,args) -&gt; MLapp(aux f, Array.map aux args)
      | MLif(t,b1,b2) -&gt; MLif(aux t, aux b1, aux b2)
      | MLmatch(annot,a,accu,bs) -&gt;
          let auxb (cargs,body) = (cargs,aux body) in
          MLmatch(annot,a,aux accu, Array.map auxb bs)
      | MLconstruct(prefix,c,args) -&gt; MLconstruct(prefix,c,Array.map aux args)
      | MLsetref(s,l1) -&gt; MLsetref(s,aux l1)
      | MLsequence(l1,l2) -&gt; MLsequence(aux l1, aux l2)
      | MLarray arr -&gt; MLarray (Array.map aux arr)
      | MLisaccu (s, ind, l) -&gt; MLisaccu (s, ind, aux l)
    in
    aux l

let add_subst id v s =
  match v with
  | MLlocal id' when Int.equal id.luid id'.luid -&gt; s
  | _ -&gt; LNmap.add id v s

let subst_norm params args s =
  let len = Array.length params in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Int.equal (Array.length args) len &amp;&amp; Array.for_all can_subst args);
  let s = ref s in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to len - 1 do
    s := add_subst params.(i) args.(i) !s
  done;
  !s</abbr>

let subst_case params args s =
  let len = Array.length params in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (len &gt; 0 &amp;&amp;
          Int.equal (Array.length args) len &amp;&amp;
          let r = ref true and i = ref 0 in
          (* we test all arguments excepted the last *)
          while !i &lt; len - 1  &amp;&amp; !r do r := can_subst args.(!i); incr i done;
          !r);
  let s = ref s in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to len - 2 do
    s := add_subst params.(i) args.(i) !s
  done;
  !s, params.(len-1), args.(len-1)</abbr>

let empty_gdef = Int.Map.empty, Int.Map.empty
let get_norm (gnorm, _) i = Int.Map.find i gnorm
let get_case (_, gcase) i = Int.Map.find i gcase

let all_lam n bs =
  let f (_, l) =
    match l with
    | MLlam(params, _) -&gt; Int.equal (Array.length params) n
    | _ -&gt; false in
  Array.for_all f bs

let commutative_cut annot a accu bs args =
  let mkb (c,b) =
     match b with
     | MLlam(params, body) -&gt;
         (c, Array.fold_left2 (fun body x v -&gt; MLlet(x,v,body)) body params args)
     | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> in
  MLmatch(annot, a, mkMLapp accu args, Array.map mkb bs)

let optimize gdef l =
  let rec optimize s l =
    match l with
    | MLlocal id -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try LNmap.find id s with Not_found -&gt; l)</abbr>
    | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ -&gt; l
    | MLlam(params,body) -&gt;
        MLlam(params, optimize s body)
    | MLletrec(decls,body) -&gt;
        let opt_rec (f,params,body) = (f,params,optimize s body ) in
        MLletrec(Array.map opt_rec decls, optimize s body)
    | MLlet(id,def,body) -&gt;
        let def = optimize s def in
        if can_subst def then optimize (add_subst id def s) body
        else MLlet(id,def,optimize s body)
    | MLapp(f, args) -&gt;
        let args = Array.map (optimize s) args in
        begin match f with
        | MLglobal (Gnorm (_,i)) -&gt;
            <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
              let params,body = get_norm gdef i in
              let s = subst_norm params args s in
              optimize s body
            with Not_found -&gt; MLapp(optimize s f, args))</abbr>
        | MLglobal (Gcase (_,i)) -&gt;
            <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
              let params,body = get_case gdef i in
              let s, id, arg = subst_case params args s in
              if can_subst arg then optimize (add_subst id arg s) body
              else MLlet(id, arg, optimize s body)
            with Not_found -&gt;  MLapp(optimize s f, args))</abbr>
        | _ -&gt;
            let f = optimize s f in
            match f with
            | MLmatch (annot,a,accu,bs) -&gt;
              if all_lam (Array.length args) bs then
                commutative_cut annot a accu bs args
              else MLapp(f, args)
            | _ -&gt; MLapp(f, args)

        end
    | MLif(t,b1,b2) -&gt;
       (* This optimization is critical: it applies to all fixpoints that start
       by matching on their recursive argument *)
        let t = optimize s t in
        let b1 = optimize s b1 in
        let b2 = optimize s b2 in
        begin match t, b2 with
        | MLisaccu (_, _, l1), MLmatch(annot, l2, _, bs)
            when eq_mllambda l1 l2 -&gt; MLmatch(annot, l1, b1, bs)
        | _, _ -&gt; MLif(t, b1, b2)
        end
    | MLmatch(annot,a,accu,bs) -&gt;
        let opt_b (cargs,body) = (cargs,optimize s body) in
        MLmatch(annot, optimize s a, subst s accu, Array.map opt_b bs)
    | MLconstruct(prefix,c,args) -&gt;
        MLconstruct(prefix,c,Array.map (optimize s) args)
    | MLsetref(r,l) -&gt; MLsetref(r, optimize s l)
    | MLsequence(l1,l2) -&gt; MLsequence(optimize s l1, optimize s l2)
    | MLarray arr -&gt; MLarray (Array.map (optimize s) arr)
    | MLisaccu (pf, ind, l) -&gt; MLisaccu (pf, ind, optimize s l)
  in
  optimize LNmap.empty l

let optimize_stk stk =
  let add_global gdef g =
    match g with
    | Glet (Gnorm (_,i), body) -&gt;
        let (gnorm, gcase) = gdef in
        (Int.Map.add i (decompose_MLlam body) gnorm, gcase)
    | Gletcase(Gcase (_,i), params, annot,a,accu,bs) -&gt;
        let (gnorm,gcase) = gdef in
        (gnorm, Int.Map.add i (params,MLmatch(annot,a,accu,bs)) gcase)
    | Gletcase _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    | _ -&gt; gdef in
  let gdef = List.fold_left add_global empty_gdef stk in
  let optimize_global g =
    match g with
    | Glet(Gconstant (prefix, c), body) -&gt;
        Glet(Gconstant (prefix, c), optimize gdef body)
    | _ -&gt; g in
  List.map optimize_global stk

(** Printing to ocaml **)
(* Redefine a bunch of functions in module Names to generate names
   acceptable to OCaml. *)
let string_of_id s = Unicode.ascii_of_ident (Id.to_string s)
let string_of_label l = string_of_id (Label.to_id l)

let string_of_dirpath = function
  | [] -&gt; &quot;_&quot;
  | sl -&gt; String.concat &quot;_&quot; (List.rev_map string_of_id sl)

(* The first letter of the file name has to be a capital to be accepted by *)
(* OCaml as a module identifier.                                           *)
let string_of_dirpath s = &quot;N&quot;^string_of_dirpath s

let mod_uid_of_dirpath dir = string_of_dirpath (DirPath.repr dir)

let link_info_of_dirpath dir =
  Linked (mod_uid_of_dirpath dir ^ &quot;.&quot;)

let string_of_name x =
  match x with
    | Anonymous -&gt; &quot;anonymous&quot; (* assert false *)
    | Name id -&gt; string_of_id id

let string_of_label_def l =
  match l with
    | None -&gt; &quot;&quot;
    | Some l -&gt; string_of_label l

(* Relativization of module paths *)
let rec list_of_mp acc = function
  | MPdot (mp,l) -&gt; list_of_mp (string_of_label l::acc) mp
  | MPfile dp -&gt;
      let dp = DirPath.repr dp in
      string_of_dirpath dp :: acc
  | MPbound mbid -&gt; (&quot;X&quot;^string_of_id (MBId.to_id mbid))::acc

let list_of_mp mp = list_of_mp [] mp

let string_of_kn kn =
  let (mp,l) = KerName.repr kn in
  let mp = list_of_mp mp in
  String.concat &quot;_&quot; mp ^ &quot;_&quot; ^ string_of_label l

let string_of_con c = string_of_kn (Constant.user c)
let string_of_mind mind = string_of_kn (MutInd.user mind)

let string_of_gname g =
  match g with
  | Gind (prefix, (mind, i)) -&gt;
      Format.sprintf &quot;%sindaccu_%s_%i&quot; prefix (string_of_mind mind) i
  | Gconstruct (prefix, ((mind, i), j)) -&gt;
      Format.sprintf &quot;%sconstruct_%s_%i_%i&quot; prefix (string_of_mind mind) i (j-1)
  | Gconstant (prefix, c) -&gt;
      Format.sprintf &quot;%sconst_%s&quot; prefix (string_of_con c)
  | Gproj (prefix, (mind, n), i) -&gt;
      Format.sprintf &quot;%sproj_%s_%i_%i&quot; prefix (string_of_mind mind) n i
  | Gcase (l,i) -&gt;
      Format.sprintf &quot;case_%s_%i&quot; (string_of_label_def l) i
  | Gpred (l,i) -&gt;
      Format.sprintf &quot;pred_%s_%i&quot; (string_of_label_def l) i
  | Gfixtype (l,i) -&gt;
      Format.sprintf &quot;fixtype_%s_%i&quot; (string_of_label_def l) i
  | Gnorm (l,i) -&gt;
      Format.sprintf &quot;norm_%s_%i&quot; (string_of_label_def l) i
  | Ginternal s -&gt; Format.sprintf &quot;%s&quot; s
  | Gnormtbl (l,i) -&gt;
      Format.sprintf &quot;normtbl_%s_%i&quot; (string_of_label_def l) i
  | Grel i -&gt;
      Format.sprintf &quot;rel_%i&quot; i
  | Gnamed id -&gt;
      Format.sprintf &quot;named_%s&quot; (string_of_id id)

let pp_gname fmt g =
  Format.fprintf fmt &quot;%s&quot; (string_of_gname g)

let pp_lname fmt ln =
  Format.fprintf fmt &quot;x_%s_%i&quot; (string_of_name ln.lname) ln.luid

let pp_ldecls fmt ids =
  let len = Array.length ids in
  <abbr class="mark-warning" title="For loops not handled.">for i = 0 to len - 1 do
    Format.fprintf fmt &quot; (%a : Nativevalues.t)&quot; pp_lname ids.(i)
  done</abbr>

let string_of_construct prefix ((mind,i),j) =
  let id = Format.sprintf &quot;Construct_%s_%i_%i&quot; (string_of_mind mind) i (j-1) in
  prefix ^ id

let pp_int fmt i =
  if i &lt; 0 then Format.fprintf fmt &quot;(%i)&quot; i else Format.fprintf fmt &quot;%i&quot; i

let pp_mllam fmt l =

  <abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">let rec pp_mllam fmt l =
    match l with
    | MLlocal ln -&gt; Format.fprintf fmt &quot;@[%a@]&quot; pp_lname ln
    | MLglobal g -&gt; Format.fprintf fmt &quot;@[%a@]&quot; pp_gname g
    | MLprimitive p -&gt; Format.fprintf fmt &quot;@[%a@]&quot; pp_primitive p
    | MLlam(ids,body) -&gt;
        Format.fprintf fmt &quot;@[(fun%a@ -&gt;@\n %a)@]&quot;
          pp_ldecls ids pp_mllam body
    | MLletrec(defs, body) -&gt;
        Format.fprintf fmt &quot;@[%a@ in@\n%a@]&quot; pp_letrec defs
          pp_mllam body
    | MLlet(id,def,body) -&gt;
        Format.fprintf fmt &quot;@[(let@ %a@ =@\n %a@ in@\n%a)@]&quot;
          pp_lname id pp_mllam def pp_mllam body
    | MLapp(f, args) -&gt;
        Format.fprintf fmt &quot;@[%a@ %a@]&quot; pp_mllam f (pp_args true) args
    | MLif(t,l1,l2) -&gt;
        Format.fprintf fmt &quot;@[(if %a then@\n  %a@\nelse@\n  %a)@]&quot;
          pp_mllam t pp_mllam l1 pp_mllam l2
    | MLmatch (annot, c, accu_br, br) -&gt;
          let mind,i = annot.asw_ind in
      let prefix = annot.asw_prefix in
          let accu = Format.sprintf &quot;%sAccu_%s_%i&quot; prefix (string_of_mind mind) i in
          Format.fprintf fmt
            &quot;@[begin match Obj.magic (%a) with@\n| %s _ -&gt;@\n  %a@\n%aend@]&quot;
          pp_mllam c accu pp_mllam accu_br (pp_branches prefix) br

    | MLconstruct(prefix,c,args) -&gt;
        Format.fprintf fmt &quot;@[(Obj.magic (%s%a) : Nativevalues.t)@]&quot;
          (string_of_construct prefix c) pp_cargs args
    | MLint i -&gt; pp_int fmt i
    | MLuint i -&gt; Format.fprintf fmt &quot;(%s)&quot; (Uint63.compile i)
    | MLsetref (s, body) -&gt;
        Format.fprintf fmt &quot;@[%s@ :=@\n %a@]&quot; s pp_mllam body
    | MLsequence(l1,l2) -&gt;
        Format.fprintf fmt &quot;@[%a;@\n%a@]&quot; pp_mllam l1 pp_mllam l2
    | MLarray arr -&gt;
       let len = Array.length arr in
       </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.fprintf fmt &quot;@[[|&quot;;
       </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if 0 &lt; len then begin
         for i = 0 to len - 2 do
           Format.fprintf fmt &quot;%a;&quot; pp_mllam arr.(i)
         done;
         pp_mllam fmt arr.(len-1)
       end;
       Format.fprintf fmt &quot;|]@]&quot;</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">
    | MLisaccu (prefix, (mind, i), c) -&gt;
        let accu = Format.sprintf &quot;%sAccu_%s_%i&quot; prefix (string_of_mind mind) i in
        Format.fprintf fmt
          &quot;@[begin match Obj.magic (%a) with@\n| %s _ -&gt;@\n  true@\n| _ -&gt;@\n  false@\nend@]&quot;
        pp_mllam c accu

  and pp_letrec fmt defs =
    let len = Array.length defs in
    let pp_one_rec (fn, argsn, body) =
      Format.fprintf fmt &quot;%a%a =@\n  %a&quot;
        pp_lname fn
        pp_ldecls argsn pp_mllam body in
    </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.fprintf fmt &quot;@[let rec &quot;;
    </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">pp_one_rec defs.(0);
    </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

For loops not handled.">for i = 1 to len - 1 do
      Format.fprintf fmt &quot;@\nand &quot;;
      pp_one_rec defs.(i)
    done</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">;</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

  and pp_blam fmt l =
    match l with
    | MLprimitive (Mk_prod | Mk_sort) (* FIXME: why this special case? *)
    | MLlam _ | MLletrec _ | MLlet _ | MLapp _ | MLif _ -&gt;
        Format.fprintf fmt &quot;(%a)&quot; pp_mllam l
    | MLconstruct(_,_,args) when Array.length args &gt; 0 -&gt;
        Format.fprintf fmt &quot;(%a)&quot; pp_mllam l
    | _ -&gt; pp_mllam fmt l

  and pp_args sep fmt args =
    let sep = if sep then &quot; &quot; else &quot;,&quot; in
    let len = Array.length args in
    if len &gt; 0 then </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
      Format.fprintf fmt &quot;%a&quot; pp_blam args.(0);
      </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

For loops not handled.">for i = 1 to len - 1 do
        Format.fprintf fmt &quot;%s%a&quot; sep pp_blam args.(i)
      done</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
    end</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level">

  and pp_cargs fmt args =
    let len = Array.length args in
    match len with
    | 0 -&gt; ()
    | 1 -&gt; Format.fprintf fmt &quot; %a&quot; pp_blam args.(0)
    | _ -&gt; Format.fprintf fmt &quot;(%a)&quot; (pp_args false) args

  and pp_cparam fmt param =
    match param with
    | Some l -&gt; pp_mllam fmt (MLlocal l)
    | None -&gt; Format.fprintf fmt &quot;_&quot;

  and pp_cparams fmt params =
    let len = Array.length params in
    match len with
    | 0 -&gt; ()
    | 1 -&gt; Format.fprintf fmt &quot; %a&quot; pp_cparam params.(0)
    | _ -&gt;
        let aux fmt params =
          </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.fprintf fmt &quot;%a&quot; pp_cparam params.(0);
          </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

For loops not handled.">for i = 1 to len - 1 do
            Format.fprintf fmt &quot;,%a&quot; pp_cparam params.(i)
          done</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
        Format.fprintf fmt &quot;(%a)&quot; aux params

  and pp_branches prefix fmt bs =
    let pp_branch (cargs,body) =
      let pp_c fmt (cn,args) =
        Format.fprintf fmt &quot;| %s%a &quot;
      (string_of_construct prefix cn) pp_cparams args in
      let rec pp_cargs fmt cargs =
        match cargs with
    | [] -&gt; ()
    | cargs::cargs' -&gt;
        Format.fprintf fmt &quot;%a%a&quot; pp_c cargs pp_cargs cargs' in
      Format.fprintf fmt &quot;%a -&gt;@\n  %a@\n&quot;
    pp_cargs cargs pp_mllam body
      in
    Array.iter pp_branch bs

  and pp_primitive fmt = function
    | Mk_prod -&gt; Format.fprintf fmt &quot;mk_prod_accu&quot;
    | Mk_sort -&gt; Format.fprintf fmt &quot;mk_sort_accu&quot;
    | Mk_ind -&gt; Format.fprintf fmt &quot;mk_ind_accu&quot;
    | Mk_const -&gt; Format.fprintf fmt &quot;mk_constant_accu&quot;
    | Mk_sw -&gt; Format.fprintf fmt &quot;mk_sw_accu&quot;
    | Mk_fix(rec_pos,start) -&gt;
        let pp_rec_pos fmt rec_pos =
          </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.fprintf fmt &quot;@[[| %i&quot; rec_pos.(0);
          </abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 1 to Array.length rec_pos - 1 do
            Format.fprintf fmt &quot;; %i&quot; rec_pos.(i)
          done;
          Format.fprintf fmt &quot; |]@]&quot;</abbr><abbr class="mark-warning" title="Mutually recursive definition are only handled at top-level"> in
        Format.fprintf fmt &quot;mk_fix_accu %a %i&quot; pp_rec_pos rec_pos start
    | Mk_cofix(start) -&gt; Format.fprintf fmt &quot;mk_cofix_accu %i&quot; start
    | Mk_rel i -&gt; Format.fprintf fmt &quot;mk_rel_accu %i&quot; i
    | Mk_var id -&gt;
        Format.fprintf fmt &quot;mk_var_accu (Names.Id.of_string \&quot;%s\&quot;)&quot; (string_of_id id)
    | Mk_proj -&gt; Format.fprintf fmt &quot;mk_proj_accu&quot;
    | Is_int -&gt; Format.fprintf fmt &quot;is_int&quot;
    | Cast_accu -&gt; Format.fprintf fmt &quot;cast_accu&quot;
    | Upd_cofix -&gt; Format.fprintf fmt &quot;upd_cofix&quot;
    | Force_cofix -&gt; Format.fprintf fmt &quot;force_cofix&quot;
    | Mk_uint -&gt; Format.fprintf fmt &quot;mk_uint&quot;
    | Mk_int -&gt; Format.fprintf fmt &quot;mk_int&quot;
    | Mk_bool -&gt; Format.fprintf fmt &quot;mk_bool&quot;
    | Val_to_int -&gt; Format.fprintf fmt &quot;val_to_int&quot;
    | Mk_meta -&gt; Format.fprintf fmt &quot;mk_meta_accu&quot;
    | Mk_evar -&gt; Format.fprintf fmt &quot;mk_evar_accu&quot;
    | MLand -&gt; Format.fprintf fmt &quot;(&amp;&amp;)&quot;
    | MLle -&gt; Format.fprintf fmt &quot;(&lt;=)&quot;
    | MLlt -&gt; Format.fprintf fmt &quot;(&lt;)&quot;
    | MLinteq -&gt; Format.fprintf fmt &quot;(==)&quot;
    | MLlsl -&gt; Format.fprintf fmt &quot;(lsl)&quot;
    | MLlsr -&gt; Format.fprintf fmt &quot;(lsr)&quot;
    | MLland -&gt; Format.fprintf fmt &quot;(land)&quot;
    | MLlor -&gt; Format.fprintf fmt &quot;(lor)&quot;
    | MLlxor -&gt; Format.fprintf fmt &quot;(lxor)&quot;
    | MLadd -&gt; Format.fprintf fmt &quot;(+)&quot;
    | MLsub -&gt; Format.fprintf fmt &quot;(-)&quot;
    | MLmul -&gt; Format.fprintf fmt &quot;( * )&quot;
    | MLmagic -&gt; Format.fprintf fmt &quot;Obj.magic&quot;
    | MLarrayget -&gt; Format.fprintf fmt &quot;Array.get&quot;
    | Mk_empty_instance -&gt; Format.fprintf fmt &quot;Univ.Instance.empty&quot;
    | Coq_primitive (op,None) -&gt;
       Format.fprintf fmt &quot;no_check_%s&quot; (CPrimitives.to_string op)
    | Coq_primitive (op, Some (prefix,(c,_))) -&gt;
        Format.fprintf fmt &quot;%s %a&quot; (CPrimitives.to_string op)
                       pp_mllam (MLglobal (Gconstant (prefix,c)))
  in
  Format.fprintf fmt &quot;@[%a@]&quot; pp_mllam l</abbr>

let pp_array fmt t =
  let len = Array.length t in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.fprintf fmt &quot;@[[|&quot;;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to len - 2 do
    Format.fprintf fmt &quot;%a; &quot; pp_mllam t.(i)
  done;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if len &gt; 0 then
    Format.fprintf fmt &quot;%a&quot; pp_mllam t.(len - 1);
  Format.fprintf fmt &quot;|]@]&quot;</abbr>

let pp_global fmt g =
  match g with
  | Glet (gn, c) -&gt;
      let ids, c = decompose_MLlam c in
      Format.fprintf fmt &quot;@[let %a%a =@\n  %a@]@\n@.&quot; pp_gname gn
        pp_ldecls ids
        pp_mllam c
  | Gopen s -&gt;
      Format.fprintf fmt &quot;@[open %s@]@.&quot; s
  | Gtype ((mind, i), lar) -&gt;
      let l = string_of_mind mind in
      let rec aux s ar =
        if Int.equal ar 0 then s else aux (s^&quot; * Nativevalues.t&quot;) (ar-1) in
      let pp_const_sig i fmt j ar =
        let sig_str = if ar &gt; 0 then aux &quot;of Nativevalues.t&quot; (ar-1) else &quot;&quot; in
        Format.fprintf fmt &quot;  | Construct_%s_%i_%i %s@\n&quot; l i j sig_str
      in
      let pp_const_sigs i fmt lar =
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.fprintf fmt &quot;  | Accu_%s_%i of Nativevalues.t@\n&quot; l i;
        Array.iteri (pp_const_sig i fmt) lar</abbr>
      in
      Format.fprintf fmt &quot;@[type ind_%s_%i =@\n%a@]@\n@.&quot; l i (pp_const_sigs i) lar
  | Gtblfixtype (g, params, t) -&gt;
      Format.fprintf fmt &quot;@[let %a %a =@\n  %a@]@\n@.&quot; pp_gname g
        pp_ldecls params pp_array t
  | Gtblnorm (g, params, t) -&gt;
      Format.fprintf fmt &quot;@[let %a %a =@\n  %a@]@\n@.&quot; pp_gname g
        pp_ldecls params pp_array t
  | Gletcase(gn,params,annot,a,accu,bs) -&gt;
      Format.fprintf fmt &quot;@[(* Hash = %i *)@\nlet rec %a %a =@\n  %a@]@\n@.&quot;
      (hash_global g)
        pp_gname gn pp_ldecls params
        pp_mllam (MLmatch(annot,a,accu,bs))
  | Gcomment s -&gt;
      Format.fprintf fmt &quot;@[(* %s *)@]@.&quot; s

(** Compilation of elements in environment **)
let rec compile_with_fv env sigma univ auxdefs l t =
  let (auxdefs,(fv_named,fv_rel),ml) = mllambda_of_lambda univ auxdefs l t in
  if List.is_empty fv_named &amp;&amp; List.is_empty fv_rel then (auxdefs,ml)
  else apply_fv env sigma univ (fv_named,fv_rel) auxdefs ml

and apply_fv env sigma univ (fv_named,fv_rel) auxdefs ml =
  let get_rel_val (n,_) auxdefs =
    (*
    match !(lookup_rel_native_val n env) with
    | NVKnone -&gt;
    *)
        compile_rel env sigma univ auxdefs n
(*    | NVKvalue (v,d) -&gt; assert false *)
  in
  let get_named_val (id,_) auxdefs =
    (*
    match !(lookup_named_native_val id env) with
    | NVKnone -&gt;
        *)
        compile_named env sigma univ auxdefs id
(*    | NVKvalue (v,d) -&gt; assert false *)
  in
  let auxdefs = List.fold_right get_rel_val fv_rel auxdefs in
  let auxdefs = List.fold_right get_named_val fv_named auxdefs in
  let lvl = Context.Rel.length (rel_context env) in
  let fv_rel = List.map (fun (n,_) -&gt; MLglobal (Grel (lvl-n))) fv_rel in
  let fv_named = List.map (fun (id,_) -&gt; MLglobal (Gnamed id)) fv_named in
  let aux_name = fresh_lname Anonymous in
  auxdefs, MLlet(aux_name, ml, mkMLapp (MLlocal aux_name) (Array.of_list (fv_rel@fv_named)))

and compile_rel env sigma univ auxdefs n =
  let open Context.Rel.Declaration in
  let decl = lookup_rel n env in
  let n = List.length (rel_context env) - n in
  match decl with
  | LocalDef (_,t,_) -&gt;
      let code = lambda_of_constr env sigma t in
      let auxdefs,code = compile_with_fv env sigma univ auxdefs None code in
      Glet(Grel n, code)::auxdefs
  | LocalAssum _ -&gt;
      Glet(Grel n, MLprimitive (Mk_rel n))::auxdefs

and compile_named env sigma univ auxdefs id =
  let open Context.Named.Declaration in
  match lookup_named id env with
  | LocalDef (_,t,_) -&gt;
      let code = lambda_of_constr env sigma t in
      let auxdefs,code = compile_with_fv env sigma univ auxdefs None code in
      Glet(Gnamed id, code)::auxdefs
  | LocalAssum _ -&gt;
      Glet(Gnamed id, MLprimitive (Mk_var id))::auxdefs

let compile_constant env sigma prefix ~interactive con cb =
    let no_univs = 0 = Univ.AUContext.size (Declareops.constant_polymorphic_context cb) in
    begin match cb.const_body with
    | Def t -&gt;
      let t = Mod_subst.force_constr t in
      let code = lambda_of_constr env sigma t in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Generated lambda code&quot;);
      let is_lazy = is_lazy t in
      let code = if is_lazy then mk_lazy code else code in
      let name =
        if interactive then LinkedInteractive prefix
        else Linked prefix
      in
      let l = Constant.label con in
      let auxdefs,code =
        if no_univs then compile_with_fv env sigma None [] (Some l) code
        else
          let univ = fresh_univ () in
          let (auxdefs,code) = compile_with_fv env sigma (Some univ) [] (Some l) code in
          (auxdefs,mkMLlam </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|univ|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> code)
      in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Generated mllambda code&quot;);
      let code =
        optimize_stk (Glet(Gconstant (&quot;&quot;, con),code)::auxdefs)
      in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Optimized mllambda code&quot;);
      code, name</abbr>
    | _ -&gt;
        let i = push_symbol (SymbConst con) in
        let args =
          if no_univs then <abbr class="mark-warning" title="Arrays not handled.">[|get_const_code i; MLarray </abbr><abbr class="mark-warning" title="Arrays not handled.

——————————

Arrays not handled.">[||]</abbr><abbr class="mark-warning" title="Arrays not handled.">|]</abbr>
          else <abbr class="mark-warning" title="Arrays not handled.">[|get_const_code i|]</abbr>
        in
        (*
        let t = mkMLlam [|univ|] (mkMLapp (MLprimitive Mk_const)
         *)
        [Glet(Gconstant (&quot;&quot;, con), mkMLapp (MLprimitive Mk_const) args)],
          if interactive then LinkedInteractive prefix
          else Linked prefix
    end

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module StringOrd = struct type t = string let compare = String.compare end</abbr>
module StringSet = Set.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__set.OrderedType, Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">StringOrd</abbr>)

let loaded_native_files = ref StringSet.empty

let is_loaded_native_file s = StringSet.mem s !loaded_native_files

let register_native_file s =
  loaded_native_files := StringSet.add s !loaded_native_files

let is_code_loaded ~interactive name =
  match !name with
  | NotLinked -&gt; false
  | LinkedInteractive s -&gt;
      if (interactive &amp;&amp; is_loaded_native_file s) then true
      else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(name := NotLinked; false)</abbr>
  | Linked s -&gt;
      if is_loaded_native_file s then true
      else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(name := NotLinked; false)</abbr>

let param_name = Name (Id.of_string &quot;params&quot;)
let arg_name = Name (Id.of_string &quot;arg&quot;)

let compile_mind mb mind stack =
  let u = Declareops.inductive_polymorphic_context mb in
  (** Generate data for every block *)
  let f i stack ob =
    let ind = (mind, i) in
    let gtype = Gtype(ind, Array.map snd ob.mind_reloc_tbl) in
    let j = push_symbol (SymbInd ind) in
    let name = Gind (&quot;&quot;, ind) in
    let accu =
      let args =
        if Int.equal (Univ.AUContext.size u) 0 then
          <abbr class="mark-warning" title="Arrays not handled.">[|get_ind_code j; MLarray </abbr><abbr class="mark-warning" title="Arrays not handled.

——————————

Arrays not handled.">[||]</abbr><abbr class="mark-warning" title="Arrays not handled.">|]</abbr>
        else <abbr class="mark-warning" title="Arrays not handled.">[|get_ind_code j|]</abbr>
      in
      Glet(name, MLapp (MLprimitive Mk_ind, args))
    in
    let nparams = mb.mind_nparams in
    let params =
      Array.init nparams (fun i -&gt; {lname = param_name; luid = i}) in
    let add_construct j acc (_,arity) =
      let args = Array.init arity (fun k -&gt; {lname = arg_name; luid = k}) in
      let c = ind, (j+1) in
          Glet(Gconstruct (&quot;&quot;, c),
             mkMLlam (Array.append params args)
               (MLconstruct(&quot;&quot;, c, Array.map (fun id -&gt; MLlocal id) args)))::acc
    in
    let constructors = Array.fold_left_i add_construct [] ob.mind_reloc_tbl in
    let add_proj proj_arg acc _pb =
      let tbl = ob.mind_reloc_tbl in
      (* Building info *)
      let ci = { ci_ind = ind; ci_npar = nparams;
                 ci_cstr_nargs = <abbr class="mark-warning" title="Arrays not handled.">[|0|]</abbr>; ci_relevance = ob.mind_relevance;
                 ci_cstr_ndecls = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr> (*FIXME*);
                 ci_pp_info = { ind_tags = []; cstr_tags = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr> (*FIXME*); style = RegularStyle } } in
      let asw = { asw_ind = ind; asw_prefix = &quot;&quot;; asw_ci = ci;
                  asw_reloc = tbl; asw_finite = true } in
      let c_uid = fresh_lname Anonymous in
      let cf_uid = fresh_lname Anonymous in
      let _, arity = tbl.(0) in
      let ci_uid = fresh_lname Anonymous in
      let cargs = Array.init arity
        (fun i -&gt; if Int.equal i proj_arg then Some ci_uid else None)
      in
      let i = push_symbol (SymbProj (ind, proj_arg)) in
      let accu = MLapp (MLprimitive Cast_accu, <abbr class="mark-warning" title="Arrays not handled.">[|MLlocal cf_uid|]</abbr>) in
      let accu_br = MLapp (MLprimitive Mk_proj, <abbr class="mark-warning" title="Arrays not handled.">[|get_proj_code i;accu|]</abbr>) in
      let code = MLmatch(asw,MLlocal cf_uid,accu_br,<abbr class="mark-warning" title="Arrays not handled.">[|[((ind,1),cargs)],MLlocal ci_uid|]</abbr>) in
      let code = MLlet(cf_uid, mkForceCofix &quot;&quot; ind (MLlocal c_uid), code) in
      let gn = Gproj (&quot;&quot;, ind, proj_arg) in
      Glet (gn, mkMLlam <abbr class="mark-warning" title="Arrays not handled.">[|c_uid|]</abbr> code) :: acc
    in
    let projs = match mb.mind_record with
    | NotRecord | FakeRecord -&gt; []
    | PrimRecord info -&gt;
      let _, _, _, pbs = info.(i) in
      Array.fold_left_i add_proj [] pbs
    in
    projs @ constructors @ gtype :: accu :: stack
  in
  Array.fold_left_i f stack mb.mind_packets

type code_location_update =
    link_info ref * link_info
type code_location_updates =
  code_location_update Mindmap_env.t * code_location_update Cmap_env.t

type linkable_code = global list * code_location_updates

let empty_updates = Mindmap_env.empty, Cmap_env.empty

let compile_mind_deps env prefix ~interactive
    (comp_stack, (mind_updates, const_updates) as init) mind =
  let mib,nameref = lookup_mind_key mind env in
  if is_code_loaded ~interactive nameref
    || Mindmap_env.mem mind mind_updates
  then init
  else
    let comp_stack =
      compile_mind mib mind comp_stack
    in
    let name =
      if interactive then LinkedInteractive prefix
      else Linked prefix
    in
    let upd = (nameref, name) in
    let mind_updates = Mindmap_env.add mind upd mind_updates in
    (comp_stack, (mind_updates, const_updates))

(* This function compiles all necessary dependencies of t, and generates code in
   reverse order, as well as linking information updates *)
let compile_deps env sigma prefix ~interactive init t =
  let rec aux env lvl init t =
  match kind t with
  | Ind ((mind,_),_u) -&gt; compile_mind_deps env prefix ~interactive init mind
  | Const c -&gt;
    let c,_u = get_alias env c in
    let cb,(nameref,_) = lookup_constant_key c env in
    let (_, (_, const_updates)) = init in
    if is_code_loaded ~interactive nameref
    || (Cmap_env.mem c const_updates)
    then init
    else
      let comp_stack, (mind_updates, const_updates) =
        match cb.const_body with
        | Def t -&gt;
           aux env lvl init (Mod_subst.force_constr t)
        | _ -&gt; init
      in
      let code, name =
        compile_constant env sigma prefix ~interactive c cb
      in
      let comp_stack = code@comp_stack in
      let const_updates = Cmap_env.add c (nameref, name) const_updates in
      comp_stack, (mind_updates, const_updates)
  | Construct (((mind,_),_),_u) -&gt; compile_mind_deps env prefix ~interactive init mind
  | Proj (p,c) -&gt;
    let init = compile_mind_deps env prefix ~interactive init (Projection.mind p) in
    aux env lvl init c
  | Case (ci, _p, _c, _ac) -&gt;
      let mind = fst ci.ci_ind in
      let init = compile_mind_deps env prefix ~interactive init mind in
      fold_constr_with_binders succ (aux env) lvl init t
  | Var id -&gt;
    let open Context.Named.Declaration in
    begin match lookup_named id env with
      | LocalDef (_,t,_) -&gt;
        aux env lvl init t
      | _ -&gt; init
    end
  | Rel n when n &gt; lvl -&gt;
    let open Context.Rel.Declaration in
    let decl = lookup_rel n env in
    let env = env_of_rel n env in
    begin match decl with
    | LocalDef (_,t,_) -&gt;
      aux env lvl init t
    | LocalAssum _ -&gt; init
    end
  | _ -&gt; fold_constr_with_binders succ (aux env) lvl init t
  in
  aux env 0 init t

let compile_constant_field env prefix con acc cb =
    let (gl, _) =
      compile_constant ~interactive:false env empty_evars prefix
        con cb
    in
    gl@acc

let compile_mind_field mp l acc mb =
  let mind = MutInd.make2 mp l in
  compile_mind mb mind acc

let mk_open s = Gopen s

let mk_internal_let s code =
  Glet(Ginternal s, code)

(* ML Code for conversion function *)
let mk_conv_code env sigma prefix t1 t2 =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">clear_symbols ();
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">clear_global_tbl ();
  let gl, (mind_updates, const_updates) =
    let init = ([], empty_updates) in
    compile_deps env sigma prefix ~interactive:true init t1
  in
  let gl, (mind_updates, const_updates) =
    let init = (gl, (mind_updates, const_updates)) in
    compile_deps env sigma prefix ~interactive:true init t2
  in
  let code1 = lambda_of_constr env sigma t1 in
  let code2 = lambda_of_constr env sigma t2 in
  let (gl,code1) = compile_with_fv env sigma None gl None code1 in
  let (gl,code2) = compile_with_fv env sigma None gl None code2 in
  let t1 = mk_internal_let &quot;t1&quot; code1 in
  let t2 = mk_internal_let &quot;t2&quot; code2 in
  let g1 = MLglobal (Ginternal &quot;t1&quot;) in
  let g2 = MLglobal (Ginternal &quot;t2&quot;) in
  let setref1 = Glet(Ginternal &quot;_&quot;, MLsetref(&quot;rt1&quot;,g1)) in
  let setref2 = Glet(Ginternal &quot;_&quot;, MLsetref(&quot;rt2&quot;,g2)) in
  let gl = List.rev (setref2 :: setref1 :: t2 :: t1 :: gl) in
  let header = Glet(Ginternal &quot;symbols_tbl&quot;,
    MLapp (MLglobal (Ginternal &quot;get_symbols&quot;),
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|MLglobal (Ginternal &quot;()&quot;)|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)) in
  header::gl, (mind_updates, const_updates)</abbr>

let mk_norm_code env sigma prefix t =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">clear_symbols ();
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">clear_global_tbl ();
  let gl, (mind_updates, const_updates) =
    let init = ([], empty_updates) in
    compile_deps env sigma prefix ~interactive:true init t
  in
  let code = lambda_of_constr env sigma t in
  let (gl,code) = compile_with_fv env sigma None gl None code in
  let t1 = mk_internal_let &quot;t1&quot; code in
  let g1 = MLglobal (Ginternal &quot;t1&quot;) in
  let setref = Glet(Ginternal &quot;_&quot;, MLsetref(&quot;rt1&quot;,g1)) in
  let gl = List.rev (setref :: t1 :: gl) in
  let header = Glet(Ginternal &quot;symbols_tbl&quot;,
    MLapp (MLglobal (Ginternal &quot;get_symbols&quot;),
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|MLglobal (Ginternal &quot;()&quot;)|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)) in
  header::gl, (mind_updates, const_updates)</abbr>

let mk_library_header dir =
  let libname = Format.sprintf &quot;(str_decode \&quot;%s\&quot;)&quot; (str_encode dir) in
  [Glet(Ginternal &quot;symbols_tbl&quot;,
    MLapp (MLglobal (Ginternal &quot;get_library_native_symbols&quot;),
    <abbr class="mark-warning" title="Arrays not handled.">[|MLglobal (Ginternal libname)|]</abbr>))]

let update_location (r,v) = r := v

let update_locations (ind_updates,const_updates) =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Mindmap_env.iter (fun _ -&gt; update_location) ind_updates;
  Cmap_env.iter (fun _ -&gt; update_location) const_updates</abbr>

let add_header_comment mlcode s =
  Gcomment s :: mlcode

(* vim: set filetype=ocaml foldmethod=marker: *)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativecode.ml"><code>Nativecode.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Names.

Import Constr.

Import Context.

Import Declarations.

Import Util.

Import Nativevalues.

Import Nativelambda.

Import Environ.

Module lname.
  Record record := {
    lname : Names.Name.t;
    luid : Z }.
  Definition with_lname (r : record) lname : record :=
    {| lname := lname; luid := luid r |}.
  Definition with_luid (r : record) luid : record :=
    {| lname := lname r; luid := luid |}.
End lname.
Definition lname := lname.record.

Definition eq_lname (ln1 : lname) (ln2 : lname) : bool :=
  Int.equal (lname.luid ln1) (lname.luid ln2).

Definition dummy_lname : lname :=
  {| lname.lname := Names.Anonymous; lname.luid := (-1) |}.

Definition LNord :=
  let t := lname in
  let compare (l1 : lname) (l2 : lname) : Z :=
    Z.sub (lname.luid l1) (lname.luid l2) in
  existT (fun _ =&gt; _) tt
    {|
      Stdlib__set.OrderedType.compare := compare
    |}.

Definition LNmap :=
  Map.Make
    (existT _ _
      {|
        Stdlib__set.OrderedType.compare :=
          (|LNord|).(Stdlib__set.OrderedType.compare)
      |}).

Definition LNset :=
  __Set.Make
    (existT _ _
      {|
        Stdlib__set.OrderedType.compare :=
          (|LNord|).(Stdlib__set.OrderedType.compare)
      |}).

Definition lname_ctr : Stdlib.ref Z := Stdlib.__ref_value (-1).

Definition fresh_lname (n : Names.Name.t) : lname :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  {| lname.lname := n; lname.luid := Stdlib.op_exclamation lname_ctr |}.

Inductive gname : Set :=
| Gind : string -&gt; Names.inductive -&gt; gname
| Gconstruct : string -&gt; Names.constructor -&gt; gname
| Gconstant : string -&gt; Names.Constant.t -&gt; gname
| Gproj : string -&gt; Names.inductive -&gt; Z -&gt; gname
| Gcase : option Names.Label.t -&gt; Z -&gt; gname
| Gpred : option Names.Label.t -&gt; Z -&gt; gname
| Gfixtype : option Names.Label.t -&gt; Z -&gt; gname
| Gnorm : option Names.Label.t -&gt; Z -&gt; gname
| Gnormtbl : option Names.Label.t -&gt; Z -&gt; gname
| Ginternal : string -&gt; gname
| Grel : Z -&gt; gname
| Gnamed : Names.Id.t -&gt; gname.

Definition eq_gname (gn1 : gname) (gn2 : gname) : bool :=
  match (gn1, gn2) with
  | (Gind s1 ind1, Gind s2 ind2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) s1 s2) (eq_ind ind1 ind2)
  | (Gconstruct s1 c1, Gconstruct s2 c2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) s1 s2) (eq_constructor c1 c2)
  | (Gconstant s1 c1, Gconstant s2 c2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) s1 s2) (Constant.equal c1 c2)
  | (Gproj s1 ind1 i1, Gproj s2 ind2 i2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) s1 s2)
      (andb (eq_ind ind1 ind2) (Int.equal i1 i2))
  | (Gcase None i1, Gcase None i2) =&gt; Int.equal i1 i2
  | (Gcase (Some l1) i1, Gcase (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Label.equal l1 l2)
  | (Gpred None i1, Gpred None i2) =&gt; Int.equal i1 i2
  | (Gpred (Some l1) i1, Gpred (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Label.equal l1 l2)
  | (Gfixtype None i1, Gfixtype None i2) =&gt; Int.equal i1 i2
  | (Gfixtype (Some l1) i1, Gfixtype (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Label.equal l1 l2)
  | (Gnorm None i1, Gnorm None i2) =&gt; Int.equal i1 i2
  | (Gnorm (Some l1) i1, Gnorm (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Label.equal l1 l2)
  | (Gnormtbl None i1, Gnormtbl None i2) =&gt; Int.equal i1 i2
  | (Gnormtbl (Some l1) i1, Gnormtbl (Some l2) i2) =&gt;
    andb (Int.equal i1 i2) (Label.equal l1 l2)
  | (Ginternal s1, Ginternal s2) =&gt; (|Util.String|).(CString.ExtS.equal) s1 s2
  | (Grel i1, Grel i2) =&gt; Int.equal i1 i2
  | (Gnamed id1, Gnamed id2) =&gt; Id.equal id1 id2
  |
    (Gind _ _ | Gconstruct _ _ | Gconstant _ _ | Gproj _ _ _ | Gcase _ _ |
    Gpred _ _ | Gfixtype _ _ | Gnorm _ _ | Gnormtbl _ _ | Ginternal _ | Grel _ |
    Gnamed _, _) =&gt; false
  end.

Definition dummy_gname : gname := Grel 0.

Import Hashset.Combine.

Definition gname_hash (gn : gname) : Z :=
  match gn with
  | Gind s ind =&gt;
    combinesmall 1
      (combine ((|Util.String|).(CString.ExtS.hash) s) (ind_hash ind))
  | Gconstruct s c =&gt;
    combinesmall 2
      (combine ((|Util.String|).(CString.ExtS.hash) s) (constructor_hash c))
  | Gconstant s c =&gt;
    combinesmall 3
      (combine ((|Util.String|).(CString.ExtS.hash) s) (Constant.hash c))
  | Gcase l i =&gt;
    combinesmall 4 (combine (Option.hash Label.hash l) (Int.hash i))
  | Gpred l i =&gt;
    combinesmall 5 (combine (Option.hash Label.hash l) (Int.hash i))
  | Gfixtype l i =&gt;
    combinesmall 6 (combine (Option.hash Label.hash l) (Int.hash i))
  | Gnorm l i =&gt;
    combinesmall 7 (combine (Option.hash Label.hash l) (Int.hash i))
  | Gnormtbl l i =&gt;
    combinesmall 8 (combine (Option.hash Label.hash l) (Int.hash i))
  | Ginternal s =&gt; combinesmall 9 ((|Util.String|).(CString.ExtS.hash) s)
  | Grel i =&gt; combinesmall 10 (Int.hash i)
  | Gnamed id =&gt; combinesmall 11 (Id.hash id)
  | Gproj s p i =&gt;
    combinesmall 12
      (combine ((|Util.String|).(CString.ExtS.hash) s) (combine (ind_hash p) i))
  end.

Definition case_ctr : Stdlib.ref Z := Stdlib.__ref_value (-1).

Definition fresh_gcase (l : option Names.Label.t) : gname :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Gcase l (Stdlib.op_exclamation case_ctr).

Definition pred_ctr : Stdlib.ref Z := Stdlib.__ref_value (-1).

Definition fresh_gpred (l : option Names.Label.t) : gname :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Gpred l (Stdlib.op_exclamation pred_ctr).

Definition fixtype_ctr : Stdlib.ref Z := Stdlib.__ref_value (-1).

Definition fresh_gfixtype (l : option Names.Label.t) : gname :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Gfixtype l (Stdlib.op_exclamation fixtype_ctr).

Definition norm_ctr : Stdlib.ref Z := Stdlib.__ref_value (-1).

Definition fresh_gnorm (l : option Names.Label.t) : gname :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Gnorm l (Stdlib.op_exclamation norm_ctr).

Definition normtbl_ctr : Stdlib.ref Z := Stdlib.__ref_value (-1).

Definition fresh_gnormtbl (l : option Names.Label.t) : gname :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Gnormtbl l (Stdlib.op_exclamation normtbl_ctr).

Inductive symbol : Set :=
| SymbValue : Nativevalues.t -&gt; symbol
| SymbSort : Sorts.t -&gt; symbol
| SymbName : Names.Name.t -&gt; symbol
| SymbConst : Names.Constant.t -&gt; symbol
| SymbMatch : Nativevalues.annot_sw -&gt; symbol
| SymbInd : Names.inductive -&gt; symbol
| SymbMeta : Constr.metavariable -&gt; symbol
| SymbEvar : Evar.t -&gt; symbol
| SymbLevel : Univ.Level.t -&gt; symbol
| SymbProj : Names.inductive * Z -&gt; symbol.

Definition dummy_symb : symbol := SymbValue (dummy_value tt).

Definition eq_symbol (sy1 : symbol) (sy2 : symbol) : bool :=
  match (sy1, sy2) with
  | (SymbValue v1, SymbValue v2) =&gt; Pervasives.op_eq v1 v2
  | (SymbSort s1, SymbSort s2) =&gt; Sorts.equal s1 s2
  | (SymbName n1, SymbName n2) =&gt; Name.equal n1 n2
  | (SymbConst kn1, SymbConst kn2) =&gt; Constant.equal kn1 kn2
  | (SymbMatch sw1, SymbMatch sw2) =&gt; eq_annot_sw sw1 sw2
  | (SymbInd ind1, SymbInd ind2) =&gt; eq_ind ind1 ind2
  | (SymbMeta m1, SymbMeta m2) =&gt; Int.equal m1 m2
  | (SymbEvar evk1, SymbEvar evk2) =&gt; Evar.equal evk1 evk2
  | (SymbLevel l1, SymbLevel l2) =&gt; Univ.Level.equal l1 l2
  | (SymbProj (i1, k1), SymbProj (i2, k2)) =&gt;
    andb (eq_ind i1 i2) (Int.equal k1 k2)
  | (_, _) =&gt; false
  end.

Definition hash_symbol (symb : symbol) : Z :=
  match symb with
  | SymbValue v =&gt; combinesmall 1 (Hashtbl.hash v)
  | SymbSort s =&gt; combinesmall 2 (Sorts.hash s)
  | SymbName name =&gt; combinesmall 3 (Name.hash name)
  | SymbConst c =&gt; combinesmall 4 (Constant.hash c)
  | SymbMatch sw =&gt; combinesmall 5 (hash_annot_sw sw)
  | SymbInd ind =&gt; combinesmall 6 (ind_hash ind)
  | SymbMeta m =&gt; combinesmall 7 m
  | SymbEvar evk =&gt; combinesmall 8 (Evar.hash evk)
  | SymbLevel l =&gt; combinesmall 9 (Univ.Level.hash l)
  | SymbProj (i, k) =&gt; combinesmall 10 (combine (ind_hash i) k)
  end.

Definition HashedTypeSymbol :=
  let t := symbol in
  let equal := eq_symbol in
  let hash := hash_symbol in
  existT (fun _ =&gt; _) tt
    {|
      Stdlib__hashtbl.HashedType.equal := equal;
      Stdlib__hashtbl.HashedType.hash := hash
    |}.

Definition HashtblSymbol :=
  Hashtbl.Make
    (existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal :=
          (|HashedTypeSymbol|).(Stdlib__hashtbl.HashedType.equal);
        Stdlib__hashtbl.HashedType.hash :=
          (|HashedTypeSymbol|).(Stdlib__hashtbl.HashedType.hash)
      |}).

Definition symb_tbl : (|HashtblSymbol|).(Stdlib__hashtbl.S.t) Z :=
  (|HashtblSymbol|).(Stdlib__hashtbl.S.create) 211.

Definition clear_symbols (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (|HashtblSymbol|).(Stdlib__hashtbl.S.clear) symb_tbl.

Definition symbols := array symbol.

Definition empty_symbols {A : Set} : array A :=
  (* ❌ Arrays not handled. *)
  [ ].

Definition get_value (tbl : array symbol) (i : Z) : Nativevalues.t :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbValue v =&gt; v
  | _ =&gt; anomaly None None (Pp.str &quot;get_value failed.&quot;)
  end.

Definition get_sort (tbl : array symbol) (i : Z) : Sorts.t :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbSort s =&gt; s
  | _ =&gt; anomaly None None (Pp.str &quot;get_sort failed.&quot;)
  end.

Definition get_name (tbl : array symbol) (i : Z) : Names.Name.t :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbName id =&gt; id
  | _ =&gt; anomaly None None (Pp.str &quot;get_name failed.&quot;)
  end.

Definition get_const (tbl : array symbol) (i : Z) : Names.Constant.t :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbConst kn =&gt; kn
  | _ =&gt; anomaly None None (Pp.str &quot;get_const failed.&quot;)
  end.

Definition get_match (tbl : array symbol) (i : Z) : Nativevalues.annot_sw :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbMatch case_info =&gt; case_info
  | _ =&gt; anomaly None None (Pp.str &quot;get_match failed.&quot;)
  end.

Definition get_ind (tbl : array symbol) (i : Z) : Names.inductive :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbInd ind =&gt; ind
  | _ =&gt; anomaly None None (Pp.str &quot;get_ind failed.&quot;)
  end.

Definition get_meta (tbl : array symbol) (i : Z) : Constr.metavariable :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbMeta m =&gt; m
  | _ =&gt; anomaly None None (Pp.str &quot;get_meta failed.&quot;)
  end.

Definition get_evar (tbl : array symbol) (i : Z) : Evar.t :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbEvar ev =&gt; ev
  | _ =&gt; anomaly None None (Pp.str &quot;get_evar failed.&quot;)
  end.

Definition get_level (tbl : array symbol) (i : Z) : Univ.Level.t :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbLevel u =&gt; u
  | _ =&gt; anomaly None None (Pp.str &quot;get_level failed.&quot;)
  end.

Definition get_proj (tbl : array symbol) (i : Z) : Names.inductive * Z :=
  match (|Util.Array|).(CArray.ExtS.get) tbl i with
  | SymbProj p =&gt; p
  | _ =&gt; anomaly None None (Pp.str &quot;get_proj failed.&quot;)
  end.

Definition push_symbol (x : (|HashtblSymbol|).(Stdlib__hashtbl.S.key)) : Z :=
  (* ❌ Try-with are not handled *)
  try ((|HashtblSymbol|).(Stdlib__hashtbl.S.find) symb_tbl x).

Definition symbols_tbl_name : gname := Ginternal &quot;symbols_tbl&quot;.

Definition get_symbols (function_parameter : unit) : array symbol :=
  let '_ := function_parameter in
  let tbl :=
    (|Util.Array|).(CArray.ExtS.make)
      ((|HashtblSymbol|).(Stdlib__hashtbl.S.length) symb_tbl) dummy_symb in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  tbl.

Inductive primitive : Set :=
| Mk_prod : primitive
| Mk_sort : primitive
| Mk_ind : primitive
| Mk_const : primitive
| Mk_sw : primitive
| Mk_fix : Nativevalues.rec_pos -&gt; Z -&gt; primitive
| Mk_cofix : Z -&gt; primitive
| Mk_rel : Z -&gt; primitive
| Mk_var : Names.Id.t -&gt; primitive
| Mk_proj : primitive
| Is_int : primitive
| Cast_accu : primitive
| Upd_cofix : primitive
| Force_cofix : primitive
| Mk_uint : primitive
| Mk_int : primitive
| Mk_bool : primitive
| Val_to_int : primitive
| Mk_meta : primitive
| Mk_evar : primitive
| MLand : primitive
| MLle : primitive
| MLlt : primitive
| MLinteq : primitive
| MLlsl : primitive
| MLlsr : primitive
| MLland : primitive
| MLlor : primitive
| MLlxor : primitive
| MLadd : primitive
| MLsub : primitive
| MLmul : primitive
| MLmagic : primitive
| MLarrayget : primitive
| Mk_empty_instance : primitive
| Coq_primitive :
  CPrimitives.t -&gt; option (Nativelambda.prefix * Constr.pconstant) -&gt; primitive.

Definition eq_primitive (p1 : primitive) (p2 : primitive) : bool :=
  match (p1, p2) with
  | (Mk_prod, Mk_prod) =&gt; true
  | (Mk_sort, Mk_sort) =&gt; true
  | (Mk_ind, Mk_ind) =&gt; true
  | (Mk_const, Mk_const) =&gt; true
  | (Mk_sw, Mk_sw) =&gt; true
  | (Mk_fix rp1 i1, Mk_fix rp2 i2) =&gt;
    andb (Int.equal i1 i2) (eq_rec_pos rp1 rp2)
  | (Mk_cofix i1, Mk_cofix i2) =&gt; Int.equal i1 i2
  | (Mk_rel i1, Mk_rel i2) =&gt; Int.equal i1 i2
  | (Mk_var id1, Mk_var id2) =&gt; Id.equal id1 id2
  | (Cast_accu, Cast_accu) =&gt; true
  | (Upd_cofix, Upd_cofix) =&gt; true
  | (Force_cofix, Force_cofix) =&gt; true
  | (Mk_meta, Mk_meta) =&gt; true
  | (Mk_evar, Mk_evar) =&gt; true
  | (Mk_proj, Mk_proj) =&gt; true
  | (MLarrayget, MLarrayget) =&gt; true
  | _ =&gt; false
  end.

Definition primitive_hash (function_parameter : primitive) : Z :=
  match function_parameter with
  | Mk_prod =&gt; 1
  | Mk_sort =&gt; 2
  | Mk_ind =&gt; 3
  | Mk_const =&gt; 4
  | Mk_sw =&gt; 5
  | Mk_fix r i =&gt;
    let h :=
      (|Util.Array|).(CArray.ExtS.fold_left)
        (fun h =&gt; fun i =&gt; combine h (Int.hash i)) 0 r in
    combinesmall 6 (combine h (Int.hash i))
  | Mk_cofix i =&gt; combinesmall 7 (Int.hash i)
  | Mk_rel i =&gt; combinesmall 8 (Int.hash i)
  | Mk_var id =&gt; combinesmall 9 (Id.hash id)
  | Is_int =&gt; 11
  | Cast_accu =&gt; 12
  | Upd_cofix =&gt; 13
  | Force_cofix =&gt; 14
  | Mk_uint =&gt; 15
  | Mk_int =&gt; 16
  | Mk_bool =&gt; 17
  | Val_to_int =&gt; 18
  | Mk_meta =&gt; 19
  | Mk_evar =&gt; 20
  | MLand =&gt; 21
  | MLle =&gt; 22
  | MLlt =&gt; 23
  | MLinteq =&gt; 24
  | MLlsl =&gt; 25
  | MLlsr =&gt; 26
  | MLland =&gt; 27
  | MLlor =&gt; 28
  | MLlxor =&gt; 29
  | MLadd =&gt; 30
  | MLsub =&gt; 31
  | MLmul =&gt; 32
  | MLmagic =&gt; 33
  | Coq_primitive prim None =&gt; combinesmall 34 (CPrimitives.hash prim)
  | Coq_primitive prim (Some (prefix, (kn, _))) =&gt;
    combinesmall 35
      (combine3 ((|Util.String|).(CString.ExtS.hash) prefix) (Constant.hash kn)
        (CPrimitives.hash prim))
  | Mk_proj =&gt; 36
  | MLarrayget =&gt; 37
  | Mk_empty_instance =&gt; 38
  end.

Reserved Notation &quot;'mllam_branches&quot;.

Inductive mllambda : Set :=
| MLlocal : lname -&gt; mllambda
| MLglobal : gname -&gt; mllambda
| MLprimitive : primitive -&gt; mllambda
| MLlam : array lname -&gt; mllambda -&gt; mllambda
| MLletrec : array (lname * array lname * mllambda) -&gt; mllambda -&gt; mllambda
| MLlet : lname -&gt; mllambda -&gt; mllambda -&gt; mllambda
| MLapp : mllambda -&gt; array mllambda -&gt; mllambda
| MLif : mllambda -&gt; mllambda -&gt; mllambda -&gt; mllambda
| MLmatch :
  Nativevalues.annot_sw -&gt; mllambda -&gt; mllambda -&gt; 'mllam_branches -&gt; mllambda
| MLconstruct : string -&gt; Names.constructor -&gt; array mllambda -&gt; mllambda
| MLint : Z -&gt; mllambda
| MLuint : Uint63.t -&gt; mllambda
| MLsetref : string -&gt; mllambda -&gt; mllambda
| MLsequence : mllambda -&gt; mllambda -&gt; mllambda
| MLarray : array mllambda -&gt; mllambda
| MLisaccu : string -&gt; Names.inductive -&gt; mllambda -&gt; mllambda

where &quot;'mllam_branches&quot; :=
  (array (list (Names.constructor * array (option lname)) * mllambda)).

Definition mllam_branches := 'mllam_branches.

Definition push_lnames (n : Z) (env : LNmap.t Z) (lns : array LNmap.key)
  : LNmap.t Z :=
  snd
    ((|Util.Array|).(CArray.ExtS.fold_left)
      (fun function_parameter =&gt;
        let '(i, r) := function_parameter in
        fun x =&gt; ((Z.add i 1), (LNmap.add x i r))) (n, env) lns).

Definition opush_lnames
  (n : Z) (env : LNmap.t Z) (lns : array (option LNmap.key)) : LNmap.t Z :=
  let oadd {A : Set} (x : option LNmap.key) (i : A) (r : LNmap.t A)
    : LNmap.t A :=
    match x with
    | Some ln =&gt; LNmap.add ln i r
    | None =&gt; r
    end in
  snd
    ((|Util.Array|).(CArray.ExtS.fold_left)
      (fun function_parameter =&gt;
        let '(i, r) := function_parameter in
        fun x =&gt; ((Z.add i 1), (oadd x i r))) (n, env) lns).

Fixpoint eq_mllambda
  (gn1 : gname) (gn2 : gname) (n : Int.t) (env1 : LNmap.t Int.t)
  (env2 : LNmap.t Int.t) (t1 : mllambda) (t2 : mllambda) {struct gn1} : bool :=
  match (t1, t2) with
  | (MLlocal ln1, MLlocal ln2) =&gt;
    (* ❌ Try-with are not handled *)
    try (Int.equal (LNmap.find ln1 env1) (LNmap.find ln2 env2))
  | (MLglobal gn1', MLglobal gn2') =&gt;
    orb (eq_gname gn1' gn2')
      (orb (andb (eq_gname gn1 gn1') (eq_gname gn2 gn2'))
        (andb (eq_gname gn1 gn2') (eq_gname gn2 gn1')))
  | (MLprimitive prim1, MLprimitive prim2) =&gt; eq_primitive prim1 prim2
  | (MLlam lns1 ml1, MLlam lns2 ml2) =&gt;
    andb
      (Int.equal ((|Util.Array|).(CArray.ExtS.length) lns1)
        ((|Util.Array|).(CArray.ExtS.length) lns2))
      (let env1 := push_lnames n env1 lns1 in
      let env2 := push_lnames n env2 lns2 in
      eq_mllambda gn1 gn2 (Z.add n ((|Util.Array|).(CArray.ExtS.length) lns1))
        env1 env2 ml1 ml2)
  | (MLletrec defs1 body1, MLletrec defs2 body2) =&gt;
    andb
      (Int.equal ((|Util.Array|).(CArray.ExtS.length) defs1)
        ((|Util.Array|).(CArray.ExtS.length) defs2))
      (let lns1 :=
        (|Util.Array|).(CArray.ExtS.map)
          (fun function_parameter =&gt;
            let '(x, _, _) := function_parameter in
            x) defs1 in
      let lns2 :=
        (|Util.Array|).(CArray.ExtS.map)
          (fun function_parameter =&gt;
            let '(x, _, _) := function_parameter in
            x) defs2 in
      let env1 := push_lnames n env1 lns1 in
      let env2 := push_lnames n env2 lns2 in
      let n := Z.add n ((|Util.Array|).(CArray.ExtS.length) defs1) in
      andb (eq_letrec gn1 gn2 n env1 env2 defs1 defs2)
        (eq_mllambda gn1 gn2 n env1 env2 body1 body2))
  | (MLlet ln1 def1 body1, MLlet ln2 def2 body2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 def1 def2)
      (let env1 := LNmap.add ln1 n env1 in
      let env2 := LNmap.add ln2 n env2 in
      eq_mllambda gn1 gn2 (Z.add n 1) env1 env2 body1 body2)
  | (MLapp ml1 args1, MLapp ml2 args2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2)
      ((|Util.Array|).(CArray.ExtS.equal) (eq_mllambda gn1 gn2 n env1 env2)
        args1 args2)
  | (MLif cond1 br1 br'1, MLif cond2 br2 br'2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 cond1 cond2)
      (andb (eq_mllambda gn1 gn2 n env1 env2 br1 br2)
        (eq_mllambda gn1 gn2 n env1 env2 br'1 br'2))
  | (MLmatch annot1 c1 accu1 br1, MLmatch annot2 c2 accu2 br2) =&gt;
    andb (eq_annot_sw annot1 annot2)
      (andb (eq_mllambda gn1 gn2 n env1 env2 c1 c2)
        (andb (eq_mllambda gn1 gn2 n env1 env2 accu1 accu2)
          (eq_mllam_branches gn1 gn2 n env1 env2 br1 br2)))
  | (MLconstruct pf1 cs1 args1, MLconstruct pf2 cs2 args2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) pf1 pf2)
      (andb (eq_constructor cs1 cs2)
        ((|Util.Array|).(CArray.ExtS.equal) (eq_mllambda gn1 gn2 n env1 env2)
          args1 args2))
  | (MLint i1, MLint i2) =&gt; Int.equal i1 i2
  | (MLuint i1, MLuint i2) =&gt; Uint63.equal i1 i2
  | (MLsetref id1 ml1, MLsetref id2 ml2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) id1 id2)
      (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2)
  | (MLsequence ml1 ml'1, MLsequence ml2 ml'2) =&gt;
    andb (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2)
      (eq_mllambda gn1 gn2 n env1 env2 ml'1 ml'2)
  | (MLarray arr1, MLarray arr2) =&gt;
    (|Util.Array|).(CArray.ExtS.equal) (eq_mllambda gn1 gn2 n env1 env2) arr1
      arr2
  | (MLisaccu s1 ind1 ml1, MLisaccu s2 ind2 ml2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) s1 s2)
      (andb (eq_ind ind1 ind2) (eq_mllambda gn1 gn2 n env1 env2 ml1 ml2))
  |
    (MLlocal _ | MLglobal _ | MLprimitive _ | MLlam _ _ | MLletrec _ _ |
    MLlet _ _ _ | MLapp _ _ | MLif _ _ _ | MLmatch _ _ _ _ | MLconstruct _ _ _ |
    MLint _ | MLuint _ | MLsetref _ _ | MLsequence _ _ | MLarray _ |
    MLisaccu _ _ _, _) =&gt; false
  end

with eq_letrec
  (gn1 : gname) (gn2 : gname) (n : Int.t) (env1 : LNmap.t Int.t)
  (env2 : LNmap.t Int.t) (defs1 : array (lname * array LNmap.key * mllambda))
  (defs2 : array (lname * array LNmap.key * mllambda)) {struct gn1} : bool :=
  let eq_def {A B : Set} (function_parameter : A * array LNmap.key * mllambda)
    : B * array LNmap.key * mllambda -&gt; bool :=
    let '(_, args1, ml1) := function_parameter in
    fun function_parameter =&gt;
      let '(_, args2, ml2) := function_parameter in
      andb
        (Int.equal ((|Util.Array|).(CArray.ExtS.length) args1)
          ((|Util.Array|).(CArray.ExtS.length) args2))
        (let env1 := push_lnames n env1 args1 in
        let env2 := push_lnames n env2 args2 in
        eq_mllambda gn1 gn2
          (Z.add n ((|Util.Array|).(CArray.ExtS.length) args1)) env1 env2 ml1
          ml2) in
  (|Util.Array|).(CArray.ExtS.equal) eq_def defs1 defs2

with eq_mllam_branches
  (gn1 : gname) (gn2 : gname) (n : Int.t) (env1 : LNmap.t Int.t)
  (env2 : LNmap.t Int.t) (br1 : mllam_branches) (br2 : mllam_branches)
  {struct gn1} : bool :=
  let eq_cargs
    (function_parameter : Names.constructor * array (option LNmap.key))
    : Names.constructor * array (option LNmap.key) -&gt; mllambda -&gt; mllambda -&gt;
    bool :=
    let '(cs1, args1) := function_parameter in
    fun function_parameter =&gt;
      let '(cs2, args2) := function_parameter in
      fun body1 =&gt;
        fun body2 =&gt;
          andb
            (Int.equal ((|Util.Array|).(CArray.ExtS.length) args1)
              ((|Util.Array|).(CArray.ExtS.length) args2))
            (andb (eq_constructor cs1 cs2)
              (let env1 := opush_lnames n env1 args1 in
              let env2 := opush_lnames n env2 args2 in
              eq_mllambda gn1 gn2
                (Z.add n ((|Util.Array|).(CArray.ExtS.length) args1)) env1 env2
                body1 body2)) in
  let eq_branch
    (function_parameter :
      list (Names.constructor * array (option LNmap.key)) * mllambda)
    : list (Names.constructor * array (option LNmap.key)) * mllambda -&gt; bool :=
    let '(ptl1, body1) := function_parameter in
    fun function_parameter =&gt;
      let '(ptl2, body2) := function_parameter in
      (|Util.List|).(CList.ExtS.equal)
        (fun pt1 =&gt; fun pt2 =&gt; eq_cargs pt1 pt2 body1 body2) ptl1 ptl2 in
  (|Util.Array|).(CArray.ExtS.equal) eq_branch br1 br2.

Fixpoint hash_mllambda (gn : gname) (n : Z) (env : LNmap.t Z) (t : mllambda)
  {struct gn} : Z :=
  match t with
  | MLlocal ln =&gt; combinesmall 1 (LNmap.find ln env)
  | MLglobal gn' =&gt;
    combinesmall 2
      (if eq_gname gn gn' then
        0
      else
        gname_hash gn')
  | MLprimitive prim =&gt; combinesmall 3 (primitive_hash prim)
  | MLlam lns ml =&gt;
    let env := push_lnames n env lns in
    combinesmall 4
      (combine ((|Util.Array|).(CArray.ExtS.length) lns)
        (hash_mllambda gn (Z.add n 1) env ml))
  | MLletrec defs body =&gt;
    let lns :=
      (|Util.Array|).(CArray.ExtS.map)
        (fun function_parameter =&gt;
          let '(x, _, _) := function_parameter in
          x) defs in
    let env := push_lnames n env lns in
    let n := Z.add n ((|Util.Array|).(CArray.ExtS.length) defs) in
    let h :=
      combine (hash_mllambda gn n env body)
        ((|Util.Array|).(CArray.ExtS.length) defs) in
    combinesmall 5 (hash_mllambda_letrec gn n env h defs)
  | MLlet ln def body =&gt;
    let hdef := hash_mllambda gn n env def in
    let env := LNmap.add ln n env in
    combinesmall 6 (combine hdef (hash_mllambda gn (Z.add n 1) env body))
  | MLapp ml args =&gt;
    let h := hash_mllambda gn n env ml in
    combinesmall 7 (hash_mllambda_array gn n env h args)
  | MLif cond br br' =&gt;
    let hcond := hash_mllambda gn n env cond in
    let hbr := hash_mllambda gn n env br in
    let hbr' := hash_mllambda gn n env br' in
    combinesmall 8 (combine3 hcond hbr hbr')
  | MLmatch annot c accu br =&gt;
    let hannot := hash_annot_sw annot in
    let hc := hash_mllambda gn n env c in
    let haccu := hash_mllambda gn n env accu in
    combinesmall 9 (hash_mllam_branches gn n env (combine3 hannot hc haccu) br)
  | MLconstruct pf cs args =&gt;
    let hpf := (|Util.String|).(CString.ExtS.hash) pf in
    let hcs := constructor_hash cs in
    combinesmall 10 (hash_mllambda_array gn n env (combine hpf hcs) args)
  | MLint i =&gt; combinesmall 11 i
  | MLuint i =&gt; combinesmall 12 (Uint63.hash i)
  | MLsetref id ml =&gt;
    let hid := (|Util.String|).(CString.ExtS.hash) id in
    let hml := hash_mllambda gn n env ml in
    combinesmall 13 (combine hid hml)
  | MLsequence ml ml' =&gt;
    let hml := hash_mllambda gn n env ml in
    let hml' := hash_mllambda gn n env ml' in
    combinesmall 14 (combine hml hml')
  | MLarray arr =&gt; combinesmall 15 (hash_mllambda_array gn n env 1 arr)
  | MLisaccu s ind c =&gt;
    combinesmall 16
      (combine ((|Util.String|).(CString.ExtS.hash) s)
        (combine (ind_hash ind) (hash_mllambda gn n env c)))
  end

with hash_mllambda_letrec
  (gn : gname) (n : Z) (env : LNmap.t Z) (init : Z)
  (defs : array (lname * array LNmap.key * mllambda)) {struct gn} : Z :=
  let hash_def {A : Set} (function_parameter : A * array LNmap.key * mllambda)
    : Z :=
    let '(_, args, ml) := function_parameter in
    let env := push_lnames n env args in
    let nargs := (|Util.Array|).(CArray.ExtS.length) args in
    combine nargs (hash_mllambda gn (Z.add n nargs) env ml) in
  (|Util.Array|).(CArray.ExtS.fold_left)
    (fun acc =&gt; fun t =&gt; combine (hash_def t) acc) init defs

with hash_mllambda_array
  (gn : gname) (n : Z) (env : LNmap.t Z) (init : Z) (arr : array mllambda)
  {struct gn} : Z :=
  (|Util.Array|).(CArray.ExtS.fold_left)
    (fun acc =&gt; fun t =&gt; combine (hash_mllambda gn n env t) acc) init arr

with hash_mllam_branches
  (gn : gname) (n : Z) (env : LNmap.t Z) (init : Z) (br : mllam_branches)
  {struct gn} : Z :=
  let hash_cargs
    (function_parameter : Names.constructor * array (option LNmap.key))
    : mllambda -&gt; Z :=
    let '(cs, args) := function_parameter in
    fun body =&gt;
      let nargs := (|Util.Array|).(CArray.ExtS.length) args in
      let hcs := constructor_hash cs in
      let env := opush_lnames n env args in
      let hbody := hash_mllambda gn (Z.add n nargs) env body in
      combine3 nargs hcs hbody in
  let hash_branch
    (acc : Z)
    (function_parameter :
      list (Names.constructor * array (option LNmap.key)) * mllambda) : Z :=
    let '(ptl, body) := function_parameter in
    (|Util.List|).(CList.ExtS.fold_left)
      (fun acc =&gt; fun t =&gt; combine (hash_cargs t body) acc) acc ptl in
  (|Util.Array|).(CArray.ExtS.fold_left) hash_branch init br.

Definition fv_lam (l : mllambda) : (|LNset|).(Stdlib__set.S.t) :=
  let fix aux
    (l : mllambda) (bind : (|LNset|).(Stdlib__set.S.t))
    (fv : (|LNset|).(Stdlib__set.S.t)) {struct l}
    : (|LNset|).(Stdlib__set.S.t) :=
    match l with
    | MLlocal l =&gt;
      if (|LNset|).(Stdlib__set.S.mem) l bind then
        fv
      else
        (|LNset|).(Stdlib__set.S.add) l fv
    | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ =&gt; fv
    | MLlam ln body =&gt;
      let bind :=
        (|Util.Array|).(CArray.ExtS.fold_right) (|LNset|).(Stdlib__set.S.add) ln
          bind in
      aux body bind fv
    | MLletrec bodies def =&gt;
      let bind :=
        (|Util.Array|).(CArray.ExtS.fold_right)
          (fun function_parameter =&gt;
            let '(id, _, _) := function_parameter in
            fun b =&gt; (|LNset|).(Stdlib__set.S.add) id b) bodies bind in
      let fv_body {A : Set}
        (function_parameter : A * array (|LNset|).(Stdlib__set.S.elt) * mllambda)
        : (|LNset|).(Stdlib__set.S.t) -&gt; (|LNset|).(Stdlib__set.S.t) :=
        let '(_, ln, body) := function_parameter in
        fun fv =&gt;
          let bind :=
            (|Util.Array|).(CArray.ExtS.fold_right)
              (|LNset|).(Stdlib__set.S.add) ln bind in
          aux body bind fv in
      (|Util.Array|).(CArray.ExtS.fold_right) fv_body bodies (aux def bind fv)
    | MLlet l def body =&gt;
      aux body ((|LNset|).(Stdlib__set.S.add) l bind) (aux def bind fv)
    | MLapp f args =&gt;
      let fv_arg (arg : mllambda) (fv : (|LNset|).(Stdlib__set.S.t))
        : (|LNset|).(Stdlib__set.S.t) :=
        aux arg bind fv in
      (|Util.Array|).(CArray.ExtS.fold_right) fv_arg args (aux f bind fv)
    | MLif t b1 b2 =&gt; aux t bind (aux b1 bind (aux b2 bind fv))
    | MLmatch _ a p bs =&gt;
      let fv := aux a bind (aux p bind fv) in
      let fv_bs {A : Set}
        (function_parameter :
          list (A * array (option (|LNset|).(Stdlib__set.S.elt))) * mllambda)
        : (|LNset|).(Stdlib__set.S.t) -&gt; (|LNset|).(Stdlib__set.S.t) :=
        let '(cargs, body) := function_parameter in
        fun fv =&gt;
          let bind :=
            (|Util.List|).(CList.ExtS.fold_right)
              (fun function_parameter =&gt;
                let '(_, args) := function_parameter in
                fun bind =&gt;
                  (|Util.Array|).(CArray.ExtS.fold_right)
                    (fun o =&gt;
                      fun bind =&gt;
                        match o with
                        | Some l =&gt; (|LNset|).(Stdlib__set.S.add) l bind
                        | _ =&gt; bind
                        end) args bind) cargs bind in
          aux body bind fv in
      (|Util.Array|).(CArray.ExtS.fold_right) fv_bs bs fv
    | MLconstruct _ _ p =&gt;
      (|Util.Array|).(CArray.ExtS.fold_right) (fun a =&gt; fun fv =&gt; aux a bind fv)
        p fv
    | MLsetref _ l =&gt; aux l bind fv
    | MLsequence l1 l2 =&gt; aux l1 bind (aux l2 bind fv)
    | MLarray arr =&gt;
      (|Util.Array|).(CArray.ExtS.fold_right) (fun a =&gt; fun fv =&gt; aux a bind fv)
        arr fv
    | MLisaccu _ _ body =&gt; aux body bind fv
    end in
  aux l (|LNset|).(Stdlib__set.S.empty) (|LNset|).(Stdlib__set.S.empty).

Definition mkMLlam (params : array lname) (body : mllambda) : mllambda :=
  if (|Util.Array|).(CArray.ExtS.is_empty) params then
    body
  else
    match body with
    | MLlam params' body =&gt;
      MLlam ((|Util.Array|).(CArray.ExtS.append) params params') body
    | _ =&gt; MLlam params body
    end.

Definition mkMLapp (f : mllambda) (args : array mllambda) : mllambda :=
  if (|Util.Array|).(CArray.ExtS.is_empty) args then
    f
  else
    match f with
    | MLapp f args' =&gt; MLapp f ((|Util.Array|).(CArray.ExtS.append) args' args)
    | _ =&gt; MLapp f args
    end.

Definition mkForceCofix
  (prefix : string) (ind : Names.inductive) (arg : mllambda) : mllambda :=
  let name := fresh_lname Names.Anonymous in
  MLlet name arg
    (MLif (MLisaccu prefix ind (MLlocal name))
      (MLapp (MLprimitive Force_cofix)
        (* ❌ Arrays not handled. *)
        [ MLlocal name ]) (MLlocal name)).

Definition empty_params {A : Set} : array A :=
  (* ❌ Arrays not handled. *)
  [ ].

Definition decompose_MLlam (c : mllambda) : array lname * mllambda :=
  match c with
  | MLlam ids c =&gt; (ids, c)
  | _ =&gt; (empty_params, c)
  end.

Inductive global : Set :=
| Gtblnorm : gname -&gt; array lname -&gt; array mllambda -&gt; global
| Gtblfixtype : gname -&gt; array lname -&gt; array mllambda -&gt; global
| Glet : gname -&gt; mllambda -&gt; global
| Gletcase :
  gname -&gt; array lname -&gt; Nativevalues.annot_sw -&gt; mllambda -&gt; mllambda -&gt;
  mllam_branches -&gt; global
| Gopen : string -&gt; global
| Gtype : Names.inductive -&gt; array Z -&gt; global
| Gcomment : string -&gt; global.

Definition eq_global (g1 : global) (g2 : global) : bool :=
  match (g1, g2) with
  |
    (Gtblnorm gn1 lns1 mls1, Gtblnorm gn2 lns2 mls2) |
    (Gtblfixtype gn1 lns1 mls1, Gtblfixtype gn2 lns2 mls2) =&gt;
    andb
      (Int.equal ((|Util.Array|).(CArray.ExtS.length) lns1)
        ((|Util.Array|).(CArray.ExtS.length) lns2))
      (andb
        (Int.equal ((|Util.Array|).(CArray.ExtS.length) mls1)
          ((|Util.Array|).(CArray.ExtS.length) mls2))
        (let env1 := push_lnames 0 LNmap.empty lns1 in
        let env2 := push_lnames 0 LNmap.empty lns2 in
        (|Util.Array|).(CArray.ExtS.for_all2)
          (eq_mllambda gn1 gn2 ((|Util.Array|).(CArray.ExtS.length) lns1) env1
            env2) mls1 mls2))
  | (Glet gn1 def1, Glet gn2 def2) =&gt;
    eq_mllambda gn1 gn2 0 LNmap.empty LNmap.empty def1 def2
  |
    (Gletcase gn1 lns1 annot1 c1 accu1 br1,
      Gletcase gn2 lns2 annot2 c2 accu2 br2) =&gt;
    andb
      (Int.equal ((|Util.Array|).(CArray.ExtS.length) lns1)
        ((|Util.Array|).(CArray.ExtS.length) lns2))
      (let env1 := push_lnames 0 LNmap.empty lns1 in
      let env2 := push_lnames 0 LNmap.empty lns2 in
      let t1 := MLmatch annot1 c1 accu1 br1 in
      let t2 := MLmatch annot2 c2 accu2 br2 in
      eq_mllambda gn1 gn2 ((|Util.Array|).(CArray.ExtS.length) lns1) env1 env2
        t1 t2)
  | (Gopen s1, Gopen s2) =&gt; (|Util.String|).(CString.ExtS.equal) s1 s2
  | (Gtype ind1 arr1, Gtype ind2 arr2) =&gt;
    andb (eq_ind ind1 ind2)
      ((|Util.Array|).(CArray.ExtS.equal) Int.equal arr1 arr2)
  | (Gcomment s1, Gcomment s2) =&gt; (|Util.String|).(CString.ExtS.equal) s1 s2
  | (_, _) =&gt; false
  end.

Definition hash_global (g : global) : Z :=
  match g with
  | Gtblnorm gn lns mls =&gt;
    let nlns := (|Util.Array|).(CArray.ExtS.length) lns in
    let nmls := (|Util.Array|).(CArray.ExtS.length) mls in
    let env := push_lnames 0 LNmap.empty lns in
    let hmls := hash_mllambda_array gn nlns env (combine nlns nmls) mls in
    combinesmall 1 hmls
  | Gtblfixtype gn lns mls =&gt;
    let nlns := (|Util.Array|).(CArray.ExtS.length) lns in
    let nmls := (|Util.Array|).(CArray.ExtS.length) mls in
    let env := push_lnames 0 LNmap.empty lns in
    let hmls := hash_mllambda_array gn nlns env (combine nlns nmls) mls in
    combinesmall 2 hmls
  | Glet gn def =&gt; combinesmall 3 (hash_mllambda gn 0 LNmap.empty def)
  | Gletcase gn lns annot c accu br =&gt;
    let nlns := (|Util.Array|).(CArray.ExtS.length) lns in
    let env := push_lnames 0 LNmap.empty lns in
    let t := MLmatch annot c accu br in
    combinesmall 4 (combine nlns (hash_mllambda gn nlns env t))
  | Gopen s =&gt; combinesmall 5 ((|Util.String|).(CString.ExtS.hash) s)
  | Gtype ind arr =&gt;
    combinesmall 6
      (combine (ind_hash ind)
        ((|Util.Array|).(CArray.ExtS.fold_left) combine 0 arr))
  | Gcomment s =&gt; combinesmall 7 ((|Util.String|).(CString.ExtS.hash) s)
  end.

Definition global_stack : Stdlib.ref (list global) := Stdlib.__ref_value [].

Definition HashedTypeGlobal :=
  let t := global in
  let equal := eq_global in
  let hash := hash_global in
  existT (fun _ =&gt; _) tt
    {|
      Stdlib__hashtbl.HashedType.equal := equal;
      Stdlib__hashtbl.HashedType.hash := hash
    |}.

Definition HashtblGlobal :=
  Hashtbl.Make
    (existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal :=
          (|HashedTypeGlobal|).(Stdlib__hashtbl.HashedType.equal);
        Stdlib__hashtbl.HashedType.hash :=
          (|HashedTypeGlobal|).(Stdlib__hashtbl.HashedType.hash)
      |}).

Definition global_tbl : (|HashtblGlobal|).(Stdlib__hashtbl.S.t) gname :=
  (|HashtblGlobal|).(Stdlib__hashtbl.S.create) 19991.

Definition clear_global_tbl (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (|HashtblGlobal|).(Stdlib__hashtbl.S.clear) global_tbl.

Definition push_global
  (gn : gname) (t : (|HashtblGlobal|).(Stdlib__hashtbl.S.key)) : gname :=
  (* ❌ Try-with are not handled *)
  try ((|HashtblGlobal|).(Stdlib__hashtbl.S.find) global_tbl t).

Definition push_global_let (gn : gname) (body : mllambda) : gname :=
  push_global gn (Glet gn body).

Definition push_global_fixtype
  (gn : gname) (params : array lname) (body : array mllambda) : gname :=
  push_global gn (Gtblfixtype gn params body).

Definition push_global_norm
  (gn : gname) (params : array lname) (body : array mllambda) : gname :=
  push_global gn (Gtblnorm gn params body).

Definition push_global_case
  (gn : gname) (params : array lname) (annot : Nativevalues.annot_sw)
  (a : mllambda) (accu : mllambda) (bs : mllam_branches) : gname :=
  push_global gn (Gletcase gn params annot a accu bs).

Definition eq_mllambda (t1 : mllambda) (t2 : mllambda) : bool :=
  eq_mllambda dummy_gname dummy_gname 0 LNmap.empty LNmap.empty t1 t2.

Module env.
  Record record := {
    env_rel : list mllambda;
    env_bound : Z;
    env_urel : Stdlib.ref (list (Z * mllambda));
    env_named : Stdlib.ref (list (Names.Id.t * mllambda));
    env_univ : option lname }.
  Definition with_env_rel (r : record) env_rel : record :=
    {| env_rel := env_rel; env_bound := env_bound r; env_urel := env_urel r;
      env_named := env_named r; env_univ := env_univ r |}.
  Definition with_env_bound (r : record) env_bound : record :=
    {| env_rel := env_rel r; env_bound := env_bound; env_urel := env_urel r;
      env_named := env_named r; env_univ := env_univ r |}.
  Definition with_env_urel (r : record) env_urel : record :=
    {| env_rel := env_rel r; env_bound := env_bound r; env_urel := env_urel;
      env_named := env_named r; env_univ := env_univ r |}.
  Definition with_env_named (r : record) env_named : record :=
    {| env_rel := env_rel r; env_bound := env_bound r; env_urel := env_urel r;
      env_named := env_named; env_univ := env_univ r |}.
  Definition with_env_univ (r : record) env_univ : record :=
    {| env_rel := env_rel r; env_bound := env_bound r; env_urel := env_urel r;
      env_named := env_named r; env_univ := env_univ |}.
End env.
Definition env := env.record.

Definition empty_env (univ : option lname) (function_parameter : unit) : env :=
  let '_ := function_parameter in
  {| env.env_rel := []; env.env_bound := 0;
    env.env_urel := Stdlib.__ref_value [];
    env.env_named := Stdlib.__ref_value []; env.env_univ := univ |}.

Definition push_rel (env : env) (id : Context.binder_annot Names.Name.t)
  : lname * env :=
  let local := fresh_lname (Context.binder_annot.binder_name id) in
  (local,
    (env.with_env_bound
      (env.with_env_rel env (cons (MLlocal local) (env.env_rel env)))
      (Z.add (env.env_bound env) 1))).

Definition push_rels
  (env : env) (ids : array (Context.binder_annot Names.Name.t))
  : array lname * env :=
  let '(lnames, env_rel) :=
    (|Util.Array|).(CArray.ExtS.fold_left)
      (fun function_parameter =&gt;
        let '(names, env_rel) := function_parameter in
        fun id =&gt;
          let local := fresh_lname (Context.binder_annot.binder_name id) in
          ((cons local names), (cons (MLlocal local) env_rel)))
      ([], (env.env_rel env)) ids in
  (((|Util.Array|).(CArray.ExtS.of_list) ((|Util.List|).(CList.ExtS.rev) lnames)),
    (env.with_env_bound (env.with_env_rel env env_rel)
      (Z.add (env.env_bound env) ((|Util.Array|).(CArray.ExtS.length) ids)))).

Definition get_rel (env : env) (id : Names.Name.t) (i : Z) : mllambda :=
  if OCaml.Stdlib.le i (env.env_bound env) then
    (|Util.List|).(CList.ExtS.nth) (env.env_rel env) (Z.sub i 1)
  else
    let i := Z.sub i (env.env_bound env) in
    (* ❌ Try-with are not handled *)
    try (Int.List.assoc i (Stdlib.op_exclamation (env.env_urel env))).

Definition get_var (env : env) (id : (|Names.Id.List|).(CList.MonoS.elt))
  : mllambda :=
  (* ❌ Try-with are not handled *)
  try
    ((|Names.Id.List|).(CList.MonoS.assoc) id
      (Stdlib.op_exclamation (env.env_named env))).

Definition fresh_univ (function_parameter : unit) : lname :=
  let '_ := function_parameter in
  fresh_lname (Names.Name (Id.of_string &quot;univ&quot;)).

Definition get_prod_name (codom : mllambda) : Names.Name.t :=
  match codom with
  | MLlam ids _ =&gt; lname.lname ((|Util.Array|).(CArray.ExtS.get) ids 0)
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition get_lname {A : Set} (function_parameter : A * mllambda) : lname :=
  let '(_, l) := function_parameter in
  match l with
  | MLlocal id =&gt; id
  | _ =&gt; invalid_arg None &quot;Nativecode.get_lname&quot;
  end.

Definition fv_params (env : env) : array lname :=
  let '(fvn, fvr) :=
    ((Stdlib.op_exclamation (env.env_named env)),
      (Stdlib.op_exclamation (env.env_urel env))) in
  let size :=
    Z.add ((|Util.List|).(CList.ExtS.length) fvn)
      ((|Util.List|).(CList.ExtS.length) fvr) in
  let '(start, params) :=
    match env.env_univ env with
    | None =&gt; (0, ((|Util.Array|).(CArray.ExtS.make) size dummy_lname))
    | Some u =&gt;
      (1,
        (let t := (|Util.Array|).(CArray.ExtS.make) (Z.add size 1) dummy_lname
          in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        t))
    end in
  if (|Util.Array|).(CArray.ExtS.is_empty) params then
    empty_params
  else
    let fvn := Stdlib.__ref_value fvn in
    let i := Stdlib.__ref_value start in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let fvr := Stdlib.__ref_value fvr in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    params.

Definition generalize_fv (env : env) (body : mllambda) : mllambda :=
  mkMLlam (fv_params env) body.

Definition empty_args {A : Set} : array A :=
  (* ❌ Arrays not handled. *)
  [ ].

Definition fv_args {A : Set}
  (env : env) (fvn : list ((|Names.Id.List|).(CList.MonoS.elt) * A))
  (fvr : list (Z * mllambda)) : array mllambda :=
  let size :=
    Z.add ((|Util.List|).(CList.ExtS.length) fvn)
      ((|Util.List|).(CList.ExtS.length) fvr) in
  let '(start, args) :=
    match env.env_univ env with
    | None =&gt; (0, ((|Util.Array|).(CArray.ExtS.make) size (MLint 0)))
    | Some u =&gt;
      (1,
        (let t := (|Util.Array|).(CArray.ExtS.make) (Z.add size 1) (MLint 0) in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        t))
    end in
  if (|Util.Array|).(CArray.ExtS.is_empty) args then
    empty_args
  else
    let fvn := Stdlib.__ref_value fvn in
    let i := Stdlib.__ref_value start in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let fvr := Stdlib.__ref_value fvr in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    args.

Definition get_value_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_value&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_sort_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_sort&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_name_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_name&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_const_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_const&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_match_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_match&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_ind_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_ind&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_meta_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_meta&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_evar_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_evar&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_level_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_level&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Definition get_proj_code (i : Z) : mllambda :=
  MLapp (MLglobal (Ginternal &quot;get_proj&quot;))
    (* ❌ Arrays not handled. *)
    [ MLglobal symbols_tbl_name; MLint i ].

Reserved Notation &quot;'rlist'&quot;.

Inductive rlist : Set :=
| Rnil : rlist
| Rcons :
  Stdlib.ref (list (Names.constructor * array (option lname))) -&gt;
  (|LNset|).(Stdlib__set.S.t) -&gt; mllambda -&gt; 'rlist' -&gt; rlist

where &quot;'rlist'&quot; := (Stdlib.ref rlist).

Definition rlist' := 'rlist'.

Definition rm_params
  (fv : (|LNset|).(Stdlib__set.S.t))
  (params : array (|LNset|).(Stdlib__set.S.elt))
  : array (option (|LNset|).(Stdlib__set.S.elt)) :=
  (|Util.Array|).(CArray.ExtS.map)
    (fun l =&gt;
      if (|LNset|).(Stdlib__set.S.mem) l fv then
        Some l
      else
        None) params.

Fixpoint insert
  (cargs : Names.constructor * array (|LNset|).(Stdlib__set.S.elt))
  (body : mllambda) (rl : Stdlib.ref rlist) {struct cargs} : unit :=
  match Stdlib.op_exclamation rl with
  | Rnil =&gt;
    let fv := fv_lam body in
    let '(c, params) := cargs in
    let params := rm_params fv params in
    Stdlib.op_coloneq rl
      (Rcons (Stdlib.__ref_value [ (c, params) ]) fv body
        (Stdlib.__ref_value Rnil))
  | Rcons l fv body' rl =&gt;
    if eq_mllambda body body' then
      let '(c, params) := cargs in
      let params := rm_params fv params in
      Stdlib.op_coloneq l (cons (c, params) (Stdlib.op_exclamation l))
    else
      insert cargs body rl
  end.

Fixpoint to_list (rl : Stdlib.ref rlist) {struct rl}
  : list (list (Names.constructor * array (option lname)) * mllambda) :=
  match Stdlib.op_exclamation rl with
  | Rnil =&gt; []
  | Rcons l _ body tl =&gt; cons ((Stdlib.op_exclamation l), body) (to_list tl)
  end.

Definition merge_branches
  (t :
    array (Names.constructor * array (|LNset|).(Stdlib__set.S.elt) * mllambda))
  : array (list (Names.constructor * array (option lname)) * mllambda) :=
  let newt := Stdlib.__ref_value Rnil in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (|Util.Array|).(CArray.ExtS.of_list) (to_list newt).

Definition app_prim (p : primitive) (args : array mllambda) : mllambda :=
  MLapp (MLprimitive p) args.

Inductive prim_aux : Set :=
| PAprim :
  string -&gt; Constr.pconstant -&gt; CPrimitives.t -&gt; array prim_aux -&gt; prim_aux
| PAml : mllambda -&gt; prim_aux.

Definition add_check (cond : list mllambda) (args : array prim_aux)
  : list mllambda :=
  let aux (cond : list mllambda) (a : prim_aux) : list mllambda :=
    match a with
    | PAml (MLint _) =&gt; cond
    | PAml ml =&gt;
      if (|Util.List|).(CList.ExtS.mem) ml cond then
        cond
      else
        cons ml cond
    | _ =&gt; cond
    end in
  (|Util.Array|).(CArray.ExtS.fold_left) aux cond args.

Definition extract_prim
  (ml_of : Nativelambda.lambda -&gt; mllambda) (l : Nativelambda.lambda)
  : list (lname * mllambda) * list mllambda * prim_aux :=
  let decl := Stdlib.__ref_value [] in
  let cond := Stdlib.__ref_value [] in
  let fix aux (l : Nativelambda.lambda) {struct l} : prim_aux :=
    match l with
    | Nativelambda.Lprim prefix kn p args =&gt;
      let args := (|Util.Array|).(CArray.ExtS.map) aux args in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      PAprim prefix kn p args
    |
      Nativelambda.Lrel _ _ | Nativelambda.Lvar _ | Nativelambda.Luint _ |
      Nativelambda.Lval _ | Nativelambda.Lconst _ _ =&gt; PAml (ml_of l)
    | _ =&gt;
      let x := fresh_lname Names.Anonymous in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      PAml (MLlocal x)
    end in
  let res := aux l in
  ((Stdlib.op_exclamation decl), (Stdlib.op_exclamation cond), res).

Definition cast_to_int (v : mllambda) : mllambda :=
  match v with
  | MLint _ =&gt; v
  | _ =&gt;
    MLapp (MLprimitive Val_to_int)
      (* ❌ Arrays not handled. *)
      [ v ]
  end.

Definition compile_prim
  (decl : list (lname * mllambda)) (cond : list mllambda) (paux : prim_aux)
  : mllambda :=
  let fix opt_prim_aux (paux : prim_aux) {struct paux} : mllambda :=
    match paux with
    | PAprim _prefix _kn op args =&gt;
      let args := (|Util.Array|).(CArray.ExtS.map) opt_prim_aux args in
      app_prim (Coq_primitive op None) args
    | PAml ml =&gt; ml
    end
  with naive_prim_aux (paux : prim_aux) {struct paux} : mllambda :=
    match paux with
    | PAprim prefix kn op args =&gt;
      app_prim (Coq_primitive op (Some (prefix, kn)))
        ((|Util.Array|).(CArray.ExtS.map) naive_prim_aux args)
    | PAml ml =&gt; ml
    end in
  let compile_cond (cond : list mllambda) (paux : prim_aux) : mllambda :=
    match cond with
    | [] =&gt; opt_prim_aux paux
    | cons c1 [] =&gt;
      MLif
        (app_prim Is_int
          (* ❌ Arrays not handled. *)
          [ c1 ]) (opt_prim_aux paux) (naive_prim_aux paux)
    | cons c1 cond =&gt;
      let cond :=
        (|Util.List|).(CList.ExtS.fold_left)
          (fun ml =&gt;
            fun c =&gt;
              app_prim MLland
                (* ❌ Arrays not handled. *)
                [ ml; cast_to_int c ])
          (app_prim MLland
            (* ❌ Arrays not handled. *)
            [ cast_to_int c1; MLint 0 ]) cond in
      let cond :=
        app_prim MLmagic
          (* ❌ Arrays not handled. *)
          [ cond ] in
      MLif cond (naive_prim_aux paux) (opt_prim_aux paux)
    end in
  let add_decl (decl : list (lname * mllambda)) (body : mllambda) : mllambda :=
    (|Util.List|).(CList.ExtS.fold_left)
      (fun body =&gt;
        fun function_parameter =&gt;
          let '(x, d) := function_parameter in
          MLlet x d body) body decl in
  if equiv_decb Stdlib.max_int 1073741823 then
    add_decl decl (naive_prim_aux paux)
  else
    add_decl decl (compile_cond cond paux).

Definition ml_of_instance (instance : option lname) (u : Univ.Instance.t)
  : array mllambda :=
  let ml_of_level (l : Univ.Level.t) : mllambda :=
    match Univ.Level.var_index l with
    | Some i =&gt;
      let univ :=
        MLapp (MLprimitive MLmagic)
          (* ❌ Arrays not handled. *)
          [ MLlocal (Option.get instance) ] in
      mkMLapp (MLprimitive MLarrayget)
        (* ❌ Arrays not handled. *)
        [ univ; MLint i ]
    | None =&gt;
      let i := push_symbol (SymbLevel l) in
      get_level_code i
    end in
  let u := Univ.Instance.to_array u in
  if (|Util.Array|).(CArray.ExtS.is_empty) u then
    (* ❌ Arrays not handled. *)
    [ ]
  else
    let u := (|Util.Array|).(CArray.ExtS.map) ml_of_level u in
    (* ❌ Arrays not handled. *)
    [
      MLapp (MLprimitive MLmagic)
        (* ❌ Arrays not handled. *)
        [ MLarray u ]
    ].

Fixpoint ml_of_lam
  (env : env) (l : option Names.Label.t) (t : Nativelambda.lambda) {struct env}
  : mllambda :=
  match t with
  | Nativelambda.Lrel id i =&gt; get_rel env id i
  | Nativelambda.Lvar id =&gt; get_var env id
  | Nativelambda.Lmeta mv _ty =&gt;
    let tyn := fresh_lname Names.Anonymous in
    let i := push_symbol (SymbMeta mv) in
    MLapp (MLprimitive Mk_meta)
      (* ❌ Arrays not handled. *)
      [ get_meta_code i; MLlocal tyn ]
  | Nativelambda.Levar evk args =&gt;
    let i := push_symbol (SymbEvar evk) in
    let args :=
      MLarray ((|Util.Array|).(CArray.ExtS.map) (ml_of_lam env l) args) in
    MLapp (MLprimitive Mk_evar)
      (* ❌ Arrays not handled. *)
      [ get_evar_code i; args ]
  | Nativelambda.Lprod dom codom =&gt;
    let dom := ml_of_lam env l dom in
    let codom := ml_of_lam env l codom in
    let n := get_prod_name codom in
    let i := push_symbol (SymbName n) in
    MLapp (MLprimitive Mk_prod)
      (* ❌ Arrays not handled. *)
      [ get_name_code i; dom; codom ]
  | Nativelambda.Llam ids body =&gt;
    let '(lnames, env) := push_rels env ids in
    MLlam lnames (ml_of_lam env l body)
  | Nativelambda.Lrec id body =&gt;
    let '(ids, body) := decompose_Llam body in
    let '(lname, env) := push_rel env id in
    let '(lnames, env) := push_rels env ids in
    MLletrec
      (* ❌ Arrays not handled. *)
      [ (lname, lnames, (ml_of_lam env l body)) ] (MLlocal lname)
  | Nativelambda.Llet id def body =&gt;
    let def := ml_of_lam env l def in
    let '(lname, env) := push_rel env id in
    let body := ml_of_lam env l body in
    MLlet lname def body
  | Nativelambda.Lapp f args =&gt;
    MLapp (ml_of_lam env l f)
      ((|Util.Array|).(CArray.ExtS.map) (ml_of_lam env l) args)
  | Nativelambda.Lconst prefix (c, u) =&gt;
    let args := ml_of_instance (env.env_univ env) u in
    mkMLapp (MLglobal (Gconstant prefix c)) args
  | Nativelambda.Lproj prefix ind i =&gt; MLglobal (Gproj prefix ind i)
  | Nativelambda.Lprim _ _ _ _ =&gt;
    let '(decl, cond, paux) := extract_prim (ml_of_lam env l) t in
    compile_prim decl cond paux
  | Nativelambda.Lcase annot p a bs =&gt;
    let env_p := empty_env (env.env_univ env) tt in
    let pn := fresh_gpred l in
    let mlp := ml_of_lam env_p l p in
    let mlp := generalize_fv env_p mlp in
    let '(pfvn, pfvr) :=
      ((Stdlib.op_exclamation (env.env_named env_p)),
        (Stdlib.op_exclamation (env.env_urel env_p))) in
    let pn := push_global_let pn mlp in
    let env_c := empty_env (env.env_univ env) tt in
    let a_uid := fresh_lname Names.Anonymous in
    let la_uid := MLlocal a_uid in
    let ml_br {A : Set}
      (function_parameter :
        A * array (Context.binder_annot Names.Name.t) * Nativelambda.lambda)
      : A * array lname * mllambda :=
      let '(c, params, body) := function_parameter in
      let '(lnames, env_c) := push_rels env_c params in
      (c, lnames, (ml_of_lam env_c l body)) in
    let bs := (|Util.Array|).(CArray.ExtS.map) ml_br bs in
    let cn := fresh_gcase l in
    let pred := MLapp (MLglobal pn) (fv_args env_c pfvn pfvr) in
    let '(fvn, fvr) :=
      ((Stdlib.op_exclamation (env.env_named env_c)),
        (Stdlib.op_exclamation (env.env_urel env_c))) in
    let cn_fv := mkMLapp (MLglobal cn) (fv_args env_c fvn fvr) in
    let i := push_symbol (SymbMatch annot) in
    let accu :=
      MLapp (MLprimitive Mk_sw)
        (* ❌ Arrays not handled. *)
        [
          get_match_code i;
          MLapp (MLprimitive Cast_accu)
            (* ❌ Arrays not handled. *)
            [ la_uid ];
          pred;
          cn_fv
        ] in
    let cn :=
      push_global_case cn
        ((|Util.Array|).(CArray.ExtS.append) (fv_params env_c)
          (* ❌ Arrays not handled. *)
          [ a_uid ]) annot la_uid accu (merge_branches bs) in
    let arg := ml_of_lam env l a in
    let force :=
      if Nativevalues.annot_sw.asw_finite annot then
        arg
      else
        mkForceCofix (Nativevalues.annot_sw.asw_prefix annot)
          (Nativevalues.annot_sw.asw_ind annot) arg in
    mkMLapp (MLapp (MLglobal cn) (fv_args env fvn fvr))
      (* ❌ Arrays not handled. *)
      [ force ]
  | Nativelambda.Lif t bt bf =&gt;
    MLif (ml_of_lam env l t) (ml_of_lam env l bt) (ml_of_lam env l bf)
  | Nativelambda.Lfix (rec_pos, inds, start) (ids, tt, tb) =&gt;
    let env_t := empty_env (env.env_univ env) tt in
    let ml_t := (|Util.Array|).(CArray.ExtS.map) (ml_of_lam env_t l) tt in
    let params_t := fv_params env_t in
    let args_t :=
      fv_args env (Stdlib.op_exclamation (env.env_named env_t))
        (Stdlib.op_exclamation (env.env_urel env_t)) in
    let gft := fresh_gfixtype l in
    let gft := push_global_fixtype gft params_t ml_t in
    let mk_type := MLapp (MLglobal gft) args_t in
    let ndef := (|Util.Array|).(CArray.ExtS.length) ids in
    let '(lf, env_n) := push_rels (empty_env (env.env_univ env) tt) ids in
    let t_params :=
      (|Util.Array|).(CArray.ExtS.make) ndef
        (* ❌ Arrays not handled. *)
        [ ] in
    let t_norm_f := (|Util.Array|).(CArray.ExtS.make) ndef (Gnorm l (-1)) in
    let mk_let {A : Set} (_envi : A) (function_parameter : lname * mllambda)
      : mllambda -&gt; mllambda :=
      let '(id, def) := function_parameter in
      fun t =&gt; MLlet id def t in
    let mk_lam_or_let
      (function_parameter : list lname * list (lname * mllambda) * env)
      : Context.binder_annot Names.Name.t * option Nativelambda.lambda -&gt;
      list lname * list (lname * mllambda) * env :=
      let '(params, lets, env) := function_parameter in
      fun function_parameter =&gt;
        let '(id, def) := function_parameter in
        let '(ln, env') := push_rel env id in
        match def with
        | None =&gt; ((cons ln params), lets, env')
        | Some lam =&gt; (params, (cons (ln, (ml_of_lam env l lam)) lets), env')
        end in
    let ml_of_fix (i : Z) (body : Nativelambda.lambda) : mllambda :=
      let '(varsi, bodyi) := decompose_Llam_Llet body in
      let '(paramsi, letsi, envi) :=
        (|Util.Array|).(CArray.ExtS.fold_left) mk_lam_or_let ([], [], env_n)
          varsi in
      let '(paramsi, letsi) :=
        (((|Util.Array|).(CArray.ExtS.of_list)
          ((|Util.List|).(CList.ExtS.rev) paramsi)),
          ((|Util.Array|).(CArray.ExtS.of_list)
            ((|Util.List|).(CList.ExtS.rev) letsi))) in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let bodyi := ml_of_lam envi l bodyi in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let bodyi :=
        (|Util.Array|).(CArray.ExtS.fold_right) (mk_let envi) letsi bodyi in
      mkMLlam paramsi bodyi in
    let tnorm := (|Util.Array|).(CArray.ExtS.mapi) ml_of_fix tb in
    let '(fvn, fvr) :=
      ((Stdlib.op_exclamation (env.env_named env_n)),
        (Stdlib.op_exclamation (env.env_urel env_n))) in
    let fv_params := fv_params env_n in
    let fv_args' :=
      (|Util.Array|).(CArray.ExtS.map) (fun id =&gt; MLlocal id) fv_params in
    let norm_params := (|Util.Array|).(CArray.ExtS.append) fv_params lf in
    let t_norm_f :=
      (|Util.Array|).(CArray.ExtS.mapi)
        (fun i =&gt;
          fun body =&gt;
            push_global_let ((|Util.Array|).(CArray.ExtS.get) t_norm_f i)
              (mkMLlam norm_params body)) tnorm in
    let norm := fresh_gnormtbl l in
    let norm :=
      push_global_norm norm fv_params
        ((|Util.Array|).(CArray.ExtS.map)
          (fun g =&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
    let fv_args := fv_args env fvn fvr in
    let '(lf, _env) := push_rels env ids in
    let lf_args := (|Util.Array|).(CArray.ExtS.map) (fun id =&gt; MLlocal id) lf in
    let mk_norm := MLapp (MLglobal norm) fv_args in
    let mkrec {A : Set} (i : Z) (lname : A) : A * array lname * mllambda :=
      let paramsi := (|Util.Array|).(CArray.ExtS.get) t_params i in
      let reci :=
        MLlocal
          ((|Util.Array|).(CArray.ExtS.get) paramsi
            ((|Util.Array|).(CArray.ExtS.get) rec_pos i)) in
      let pargsi :=
        (|Util.Array|).(CArray.ExtS.map) (fun id =&gt; MLlocal id) paramsi in
      let '(prefix, ind) := (|Util.Array|).(CArray.ExtS.get) inds i in
      let body :=
        MLif (MLisaccu prefix ind reci)
          (mkMLapp
            (MLapp (MLprimitive (Mk_fix rec_pos i))
              (* ❌ Arrays not handled. *)
              [ mk_type; mk_norm ]) pargsi)
          (MLapp (MLglobal ((|Util.Array|).(CArray.ExtS.get) t_norm_f i))
            ((|Util.Array|).(CArray.ExtS.concat) [ fv_args; lf_args; pargsi ]))
        in
      (lname, paramsi, body) in
    MLletrec ((|Util.Array|).(CArray.ExtS.mapi) mkrec lf)
      ((|Util.Array|).(CArray.ExtS.get) lf_args start)
  | Nativelambda.Lcofix start (ids, tt, tb) =&gt;
    let env_t := empty_env (env.env_univ env) tt in
    let ml_t := (|Util.Array|).(CArray.ExtS.map) (ml_of_lam env_t l) tt in
    let params_t := fv_params env_t in
    let args_t :=
      fv_args env (Stdlib.op_exclamation (env.env_named env_t))
        (Stdlib.op_exclamation (env.env_urel env_t)) in
    let gft := fresh_gfixtype l in
    let gft := push_global_fixtype gft params_t ml_t in
    let mk_type := MLapp (MLglobal gft) args_t in
    let ndef := (|Util.Array|).(CArray.ExtS.length) ids in
    let '(lf, env_n) := push_rels (empty_env (env.env_univ env) tt) ids in
    let t_params :=
      (|Util.Array|).(CArray.ExtS.make) ndef
        (* ❌ Arrays not handled. *)
        [ ] in
    let t_norm_f := (|Util.Array|).(CArray.ExtS.make) ndef (Gnorm l (-1)) in
    let ml_of_fix (i : Z) (body : Nativelambda.lambda) : mllambda :=
      let '(idsi, bodyi) := decompose_Llam body in
      let '(paramsi, envi) := push_rels env_n idsi in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let bodyi := ml_of_lam envi l bodyi in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      mkMLlam paramsi bodyi in
    let tnorm := (|Util.Array|).(CArray.ExtS.mapi) ml_of_fix tb in
    let '(fvn, fvr) :=
      ((Stdlib.op_exclamation (env.env_named env_n)),
        (Stdlib.op_exclamation (env.env_urel env_n))) in
    let fv_params := fv_params env_n in
    let fv_args' :=
      (|Util.Array|).(CArray.ExtS.map) (fun id =&gt; MLlocal id) fv_params in
    let norm_params := (|Util.Array|).(CArray.ExtS.append) fv_params lf in
    let t_norm_f :=
      (|Util.Array|).(CArray.ExtS.mapi)
        (fun i =&gt;
          fun body =&gt;
            push_global_let ((|Util.Array|).(CArray.ExtS.get) t_norm_f i)
              (mkMLlam norm_params body)) tnorm in
    let norm := fresh_gnormtbl l in
    let norm :=
      push_global_norm norm fv_params
        ((|Util.Array|).(CArray.ExtS.map)
          (fun g =&gt; mkMLapp (MLglobal g) fv_args') t_norm_f) in
    let fv_args := fv_args env fvn fvr in
    let mk_norm := MLapp (MLglobal norm) fv_args in
    let lnorm := fresh_lname Names.Anonymous in
    let ltype := fresh_lname Names.Anonymous in
    let '(lf, _env) := push_rels env ids in
    let lf_args := (|Util.Array|).(CArray.ExtS.map) (fun id =&gt; MLlocal id) lf in
    let upd {A : Set} (i : Z) (_lname : A) (cont : mllambda) : mllambda :=
      let paramsi := (|Util.Array|).(CArray.ExtS.get) t_params i in
      let pargsi :=
        (|Util.Array|).(CArray.ExtS.map) (fun id =&gt; MLlocal id) paramsi in
      let uniti := fresh_lname Names.Anonymous in
      let body :=
        MLlam
          ((|Util.Array|).(CArray.ExtS.append) paramsi
            (* ❌ Arrays not handled. *)
            [ uniti ])
          (MLapp (MLglobal ((|Util.Array|).(CArray.ExtS.get) t_norm_f i))
            ((|Util.Array|).(CArray.ExtS.concat) [ fv_args; lf_args; pargsi ]))
        in
      MLsequence
        (MLapp (MLprimitive Upd_cofix)
          (* ❌ Arrays not handled. *)
          [ (|Util.Array|).(CArray.ExtS.get) lf_args i; body ]) cont in
    let upd :=
      (|Util.Array|).(CArray.ExtS.fold_right_i) upd lf
        ((|Util.Array|).(CArray.ExtS.get) lf_args start) in
    let mk_let (i : Z) (lname : lname) (cont : mllambda) : mllambda :=
      MLlet lname
        (MLapp (MLprimitive (Mk_cofix i))
          (* ❌ Arrays not handled. *)
          [ MLlocal ltype; MLlocal lnorm ]) cont in
    let init := (|Util.Array|).(CArray.ExtS.fold_right_i) mk_let lf upd in
    MLlet lnorm mk_norm (MLlet ltype mk_type init)
  | Nativelambda.Lmakeblock prefix (cn, _u) _ args =&gt;
    let args := (|Util.Array|).(CArray.ExtS.map) (ml_of_lam env l) args in
    MLconstruct prefix cn args
  | Nativelambda.Lconstruct prefix (cn, u) =&gt;
    let uargs := ml_of_instance (env.env_univ env) u in
    mkMLapp (MLglobal (Gconstruct prefix cn)) uargs
  | Nativelambda.Luint i =&gt;
    MLapp (MLprimitive Mk_uint)
      (* ❌ Arrays not handled. *)
      [ MLuint i ]
  | Nativelambda.Lval v =&gt;
    let i := push_symbol (SymbValue v) in
    get_value_code i
  | Nativelambda.Lsort s =&gt;
    let i := push_symbol (SymbSort s) in
    let uarg :=
      match env.env_univ env with
      | None =&gt;
        MLarray
          (* ❌ Arrays not handled. *)
          [ ]
      | Some u =&gt; MLlocal u
      end in
    let uarg :=
      MLapp (MLprimitive MLmagic)
        (* ❌ Arrays not handled. *)
        [ uarg ] in
    MLapp (MLprimitive Mk_sort)
      (* ❌ Arrays not handled. *)
      [ get_sort_code i; uarg ]
  | Nativelambda.Lind prefix (ind, u) =&gt;
    let uargs := ml_of_instance (env.env_univ env) u in
    mkMLapp (MLglobal (Gind prefix ind)) uargs
  | Nativelambda.Llazy =&gt; MLglobal (Ginternal &quot;lazy&quot;)
  | Nativelambda.Lforce =&gt; MLglobal (Ginternal &quot;Lazy.force&quot;)
  end.

Definition mllambda_of_lambda
  (univ : option lname) (auxdefs : list global) (l : option Names.Label.t)
  (t : Nativelambda.lambda)
  : list global * (list (Names.Id.t * mllambda) * list (Z * mllambda)) *
    mllambda :=
  let env := empty_env univ tt in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let ml := ml_of_lam env l t in
  let fv_rel := Stdlib.op_exclamation (env.env_urel env) in
  let fv_named := Stdlib.op_exclamation (env.env_named env) in
  let get_lname {A : Set} (function_parameter : A * mllambda) : lname :=
    let '(_, t) := function_parameter in
    match t with
    | MLlocal x =&gt; x
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  let params :=
    (|Util.List|).(CList.ExtS.append)
      ((|Util.List|).(CList.ExtS.map) get_lname fv_rel)
      ((|Util.List|).(CList.ExtS.map) get_lname fv_named) in
  if (|Util.List|).(CList.ExtS.is_empty) params then
    ((Stdlib.op_exclamation global_stack), ([], []), ml)
  else
    ((Stdlib.op_exclamation global_stack), (fv_named, fv_rel),
      (mkMLlam ((|Util.Array|).(CArray.ExtS.of_list) params) ml)).

Definition can_subst (l : mllambda) : bool :=
  match l with
  | MLlocal _ | MLint _ | MLuint _ | MLglobal _ =&gt; true
  | _ =&gt; false
  end.

Definition subst (s : LNmap.t mllambda) (l : mllambda) : mllambda :=
  if LNmap.is_empty s then
    l
  else
    let fix aux (l : mllambda) {struct l} : mllambda :=
      match l with
      | MLlocal id =&gt;
        (* ❌ Try-with are not handled *)
        try (LNmap.find id s)
      | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ =&gt; l
      | MLlam params body =&gt; MLlam params (aux body)
      | MLletrec defs body =&gt;
        let arec {A B : Set} (function_parameter : A * B * mllambda)
          : A * B * mllambda :=
          let '(f, params, body) := function_parameter in
          (f, params, (aux body)) in
        MLletrec ((|Util.Array|).(CArray.ExtS.map) arec defs) (aux body)
      | MLlet id def body =&gt; MLlet id (aux def) (aux body)
      | MLapp f args =&gt;
        MLapp (aux f) ((|Util.Array|).(CArray.ExtS.map) aux args)
      | MLif t b1 b2 =&gt; MLif (aux t) (aux b1) (aux b2)
      | MLmatch annot a accu bs =&gt;
        let auxb {A : Set} (function_parameter : A * mllambda) : A * mllambda :=
          let '(cargs, body) := function_parameter in
          (cargs, (aux body)) in
        MLmatch annot a (aux accu) ((|Util.Array|).(CArray.ExtS.map) auxb bs)
      | MLconstruct prefix c args =&gt;
        MLconstruct prefix c ((|Util.Array|).(CArray.ExtS.map) aux args)
      | MLsetref s l1 =&gt; MLsetref s (aux l1)
      | MLsequence l1 l2 =&gt; MLsequence (aux l1) (aux l2)
      | MLarray arr =&gt; MLarray ((|Util.Array|).(CArray.ExtS.map) aux arr)
      | MLisaccu s ind l =&gt; MLisaccu s ind (aux l)
      end in
    aux l.

Definition add_subst (id : LNmap.key) (v : mllambda) (s : LNmap.t mllambda)
  : LNmap.t mllambda :=
  match
    (v,
      match v with
      | MLlocal id' =&gt; Int.equal (lname.luid id) (lname.luid id')
      | _ =&gt; false
      end) with
  | (MLlocal id', true) =&gt; s
  | (_, _) =&gt; LNmap.add id v s
  end.

Definition subst_norm
  (params : array LNmap.key) (args : array mllambda) (s : LNmap.t mllambda)
  : LNmap.t mllambda :=
  let len := (|Util.Array|).(CArray.ExtS.length) params in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let s := Stdlib.__ref_value s in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.op_exclamation s.

Definition subst_case
  (params : array LNmap.key) (args : array mllambda) (s : LNmap.t mllambda)
  : LNmap.t mllambda * LNmap.key * mllambda :=
  let len := (|Util.Array|).(CArray.ExtS.length) params in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let s := Stdlib.__ref_value s in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  ((Stdlib.op_exclamation s),
    ((|Util.Array|).(CArray.ExtS.get) params (Z.sub len 1)),
    ((|Util.Array|).(CArray.ExtS.get) args (Z.sub len 1))).

Definition empty_gdef {A B : Set} : Int.Map.t A * Int.Map.t B :=
  (Int.Map.empty, Int.Map.empty).

Definition get_norm {A B : Set} (function_parameter : Int.Map.t A * B)
  : Int.Map.key -&gt; A :=
  let '(gnorm, _) := function_parameter in
  fun i =&gt; Int.Map.find i gnorm.

Definition get_case {A B : Set} (function_parameter : A * Int.Map.t B)
  : Int.Map.key -&gt; B :=
  let '(_, gcase) := function_parameter in
  fun i =&gt; Int.Map.find i gcase.

Definition all_lam {A : Set} (n : Int.t) (bs : array (A * mllambda)) : bool :=
  let f {B : Set} (function_parameter : B * mllambda) : bool :=
    let '(_, l) := function_parameter in
    match l with
    | MLlam params _ =&gt; Int.equal ((|Util.Array|).(CArray.ExtS.length) params) n
    | _ =&gt; false
    end in
  (|Util.Array|).(CArray.ExtS.for_all) f bs.

Definition commutative_cut
  (annot : Nativevalues.annot_sw) (a : mllambda) (accu : mllambda)
  (bs : array (list (Names.constructor * array (option lname)) * mllambda))
  (args : array mllambda) : mllambda :=
  let mkb {A : Set} (function_parameter : A * mllambda) : A * mllambda :=
    let '(c, b) := function_parameter in
    match b with
    | MLlam params body =&gt;
      (c,
        ((|Util.Array|).(CArray.ExtS.fold_left2)
          (fun body =&gt; fun x =&gt; fun v =&gt; MLlet x v body) body params args))
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  MLmatch annot a (mkMLapp accu args) ((|Util.Array|).(CArray.ExtS.map) mkb bs).

Definition optimize
  (gdef :
    Int.Map.t (array LNmap.key * mllambda) *
      Int.Map.t (array LNmap.key * mllambda)) (l : mllambda) : mllambda :=
  let fix optimize (s : LNmap.t mllambda) (l : mllambda) {struct s}
    : mllambda :=
    match l with
    | MLlocal id =&gt;
      (* ❌ Try-with are not handled *)
      try (LNmap.find id s)
    | MLglobal _ | MLprimitive _ | MLint _ | MLuint _ =&gt; l
    | MLlam params body =&gt; MLlam params (optimize s body)
    | MLletrec decls body =&gt;
      let opt_rec {A B : Set} (function_parameter : A * B * mllambda)
        : A * B * mllambda :=
        let '(f, params, body) := function_parameter in
        (f, params, (optimize s body)) in
      MLletrec ((|Util.Array|).(CArray.ExtS.map) opt_rec decls)
        (optimize s body)
    | MLlet id def body =&gt;
      let def := optimize s def in
      if can_subst def then
        optimize (add_subst id def s) body
      else
        MLlet id def (optimize s body)
    | MLapp f args =&gt;
      let args := (|Util.Array|).(CArray.ExtS.map) (optimize s) args in
      match f with
      | MLglobal (Gnorm _ i) =&gt;
        (* ❌ Try-with are not handled *)
        try
          (let '(params, body) := get_norm gdef i in
          let s := subst_norm params args s in
          optimize s body)
      | MLglobal (Gcase _ i) =&gt;
        (* ❌ Try-with are not handled *)
        try
          (let '(params, body) := get_case gdef i in
          let '(s, id, arg) := subst_case params args s in
          if can_subst arg then
            optimize (add_subst id arg s) body
          else
            MLlet id arg (optimize s body))
      | _ =&gt;
        let f := optimize s f in
        match f with
        | MLmatch annot a accu bs =&gt;
          if all_lam ((|Util.Array|).(CArray.ExtS.length) args) bs then
            commutative_cut annot a accu bs args
          else
            MLapp f args
        | _ =&gt; MLapp f args
        end
      end
    | MLif t b1 b2 =&gt;
      let t := optimize s t in
      let b1 := optimize s b1 in
      let b2 := optimize s b2 in
      match
        ((t, b2),
          match (t, b2) with
          | (MLisaccu _ _ l1, MLmatch annot l2 _ bs) =&gt; eq_mllambda l1 l2
          | _ =&gt; false
          end) with
      | ((MLisaccu _ _ l1, MLmatch annot l2 _ bs), true) =&gt;
        MLmatch annot l1 b1 bs
      | ((_, _), _) =&gt; MLif t b1 b2
      end
    | MLmatch annot a accu bs =&gt;
      let opt_b {A : Set} (function_parameter : A * mllambda) : A * mllambda :=
        let '(cargs, body) := function_parameter in
        (cargs, (optimize s body)) in
      MLmatch annot (optimize s a) (subst s accu)
        ((|Util.Array|).(CArray.ExtS.map) opt_b bs)
    | MLconstruct prefix c args =&gt;
      MLconstruct prefix c ((|Util.Array|).(CArray.ExtS.map) (optimize s) args)
    | MLsetref r l =&gt; MLsetref r (optimize s l)
    | MLsequence l1 l2 =&gt; MLsequence (optimize s l1) (optimize s l2)
    | MLarray arr =&gt; MLarray ((|Util.Array|).(CArray.ExtS.map) (optimize s) arr)
    | MLisaccu pf ind l =&gt; MLisaccu pf ind (optimize s l)
    end in
  optimize LNmap.empty l.

Definition optimize_stk (stk : list global) : list global :=
  let add_global
    (gdef :
      Int.Map.t (array lname * mllambda) * Int.Map.t (array lname * mllambda))
    (g : global)
    : Int.Map.t (array lname * mllambda) * Int.Map.t (array lname * mllambda) :=
    match g with
    | Glet (Gnorm _ i) body =&gt;
      let '(gnorm, gcase) := gdef in
      ((Int.Map.add i (decompose_MLlam body) gnorm), gcase)
    | Gletcase (Gcase _ i) params annot a accu bs =&gt;
      let '(gnorm, gcase) := gdef in
      (gnorm, (Int.Map.add i (params, (MLmatch annot a accu bs)) gcase))
    | Gletcase _ _ _ _ _ _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    | _ =&gt; gdef
    end in
  let gdef := (|Util.List|).(CList.ExtS.fold_left) add_global empty_gdef stk in
  let optimize_global (g : global) : global :=
    match g with
    | Glet (Gconstant prefix c) body =&gt;
      Glet (Gconstant prefix c) (optimize gdef body)
    | _ =&gt; g
    end in
  (|Util.List|).(CList.ExtS.map) optimize_global stk.

Definition string_of_id (s : Names.Id.t) : string :=
  Unicode.ascii_of_ident (Id.to_string s).

Definition string_of_label (l : Names.Label.t) : string :=
  string_of_id (Label.to_id l).

Definition string_of_dirpath (function_parameter : list Names.Id.t) : string :=
  match function_parameter with
  | [] =&gt; &quot;_&quot;
  | sl =&gt;
    (|Util.String|).(CString.ExtS.concat) &quot;_&quot;
      ((|Util.List|).(CList.ExtS.rev_map) string_of_id sl)
  end.

Definition string_of_dirpath (s : list Names.Id.t) : string :=
  String.append &quot;N&quot; (string_of_dirpath s).

Definition mod_uid_of_dirpath (dir : Names.DirPath.t) : string :=
  string_of_dirpath (DirPath.repr dir).

Definition link_info_of_dirpath (dir : Names.DirPath.t) : Environ.link_info :=
  Environ.Linked (String.append (mod_uid_of_dirpath dir) &quot;.&quot;).

Definition string_of_name (x : Names.name) : string :=
  match x with
  | Names.Anonymous =&gt; &quot;anonymous&quot;
  | Names.Name id =&gt; string_of_id id
  end.

Definition string_of_label_def (l : option Names.Label.t) : string :=
  match l with
  | None =&gt; &quot;&quot;
  | Some l =&gt; string_of_label l
  end.

Fixpoint list_of_mp (acc : list string) (function_parameter : Names.module_path)
  {struct acc} : list string :=
  match function_parameter with
  | Names.MPdot mp l =&gt; list_of_mp (cons (string_of_label l) acc) mp
  | Names.MPfile dp =&gt;
    let dp := DirPath.repr dp in
    cons (string_of_dirpath dp) acc
  | Names.MPbound mbid =&gt;
    cons (String.append &quot;X&quot; (string_of_id (MBId.to_id mbid))) acc
  end.

Definition list_of_mp (mp : Names.module_path) : list string := list_of_mp [] mp.

Definition string_of_kn (kn : Names.KerName.t) : string :=
  let '(mp, l) := KerName.repr kn in
  let mp := list_of_mp mp in
  String.append ((|Util.String|).(CString.ExtS.concat) &quot;_&quot; mp)
    (String.append &quot;_&quot; (string_of_label l)).

Definition string_of_con (c : Names.Constant.t) : string :=
  string_of_kn (Constant.user c).

Definition string_of_mind (mind : Names.MutInd.t) : string :=
  string_of_kn (MutInd.user mind).

Definition string_of_gname (g : gname) : string :=
  match g with
  | Gind prefix (mind, i) =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;indaccu_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format))))) &quot;%sindaccu_%s_%i&quot;)
      prefix (string_of_mind mind) i
  | Gconstruct prefix ((mind, i), j) =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;construct_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      CamlinternalFormatBasics.End_of_format)))))))
        &quot;%sconstruct_%s_%i_%i&quot;) prefix (string_of_mind mind) i (Z.sub j 1)
  | Gconstant prefix c =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;const_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.End_of_format))) &quot;%sconst_%s&quot;) prefix
      (string_of_con c)
  | Gproj prefix (mind, n) i =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;proj_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      CamlinternalFormatBasics.End_of_format)))))))
        &quot;%sproj_%s_%i_%i&quot;) prefix (string_of_mind mind) n i
  | Gcase l i =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;case_&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;case_%s_%i&quot;)
      (string_of_label_def l) i
  | Gpred l i =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;pred_&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;pred_%s_%i&quot;)
      (string_of_label_def l) i
  | Gfixtype l i =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;fixtype_&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;fixtype_%s_%i&quot;)
      (string_of_label_def l) i
  | Gnorm l i =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;norm_&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;norm_%s_%i&quot;)
      (string_of_label_def l) i
  | Ginternal s =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.End_of_format) &quot;%s&quot;) s
  | Gnormtbl l i =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;normtbl_&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format)))) &quot;normtbl_%s_%i&quot;)
      (string_of_label_def l) i
  | Grel i =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;rel_&quot;
          (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
            CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.No_precision
            CamlinternalFormatBasics.End_of_format)) &quot;rel_%i&quot;) i
  | Gnamed id =&gt;
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;named_&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.End_of_format)) &quot;named_%s&quot;)
      (string_of_id id)
  end.

Definition pp_gname (fmt : Stdlib.Format.formatter) (g : gname) : unit :=
  Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.End_of_format) &quot;%s&quot;) (string_of_gname g).

Definition pp_lname (fmt : Stdlib.Format.formatter) (ln : lname) : unit :=
  Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;x_&quot;
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              CamlinternalFormatBasics.End_of_format)))) &quot;x_%s_%i&quot;)
    (string_of_name (lname.lname ln)) (lname.luid ln).

Definition pp_ldecls (fmt : Stdlib.Format.formatter) (ids : array lname)
  : unit :=
  let len := (|Util.Array|).(CArray.ExtS.length) ids in
  (* ❌ For loops not handled. *)
  for.

Definition string_of_construct
  (prefix : string) (function_parameter : (Names.MutInd.t * Z) * Z) : string :=
  let '((mind, i), j) := function_parameter in
  let id :=
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Construct_&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                  (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.No_precision
                    CamlinternalFormatBasics.End_of_format))))))
        &quot;Construct_%s_%i_%i&quot;) (string_of_mind mind) i (Z.sub j 1) in
  String.append prefix id.

Definition pp_int (fmt : Stdlib.Format.formatter) (i : Z) : unit :=
  if OCaml.Stdlib.lt i 0 then
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
          (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
            CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.No_precision
            (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
              CamlinternalFormatBasics.End_of_format))) &quot;(%i)&quot;) i
  else
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          CamlinternalFormatBasics.End_of_format) &quot;%i&quot;) i.

Definition pp_mllam (fmt : Stdlib.Format.formatter) (l : mllambda) : unit :=
  let fix pp_mllam (fmt : Stdlib.Format.formatter) (l : mllambda) {struct fmt}
    : unit :=
    match l with
    | MLlocal ln =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot;) pp_lname ln
    | MLglobal g =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot;) pp_gname g
    | MLprimitive p =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot;) pp_primitive
        p
    | MLlam ids body =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.String_literal &quot;(fun&quot;
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Formatting_lit
                  (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
                  (CamlinternalFormatBasics.String_literal &quot;-&gt;&quot;
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Close_box
                              CamlinternalFormatBasics.End_of_format))))))))))
          &quot;@[(fun%a@ -&gt;@\n %a)@]&quot;) pp_ldecls ids pp_mllam body
    | MLletrec defs body =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
                (CamlinternalFormatBasics.String_literal &quot;in&quot;
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.Alpha
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Close_box
                        CamlinternalFormatBasics.End_of_format)))))))
          &quot;@[%a@ in@\n%a@]&quot;) pp_letrec defs pp_mllam body
    | MLlet id def body =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.String_literal &quot;(let&quot;
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.Formatting_lit
                    (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
                    (CamlinternalFormatBasics.Char_literal &quot;=&quot; % char
                      (CamlinternalFormatBasics.Formatting_lit
                        CamlinternalFormatBasics.Force_newline
                        (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                          (CamlinternalFormatBasics.Alpha
                            (CamlinternalFormatBasics.Formatting_lit
                              (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
                              (CamlinternalFormatBasics.String_literal &quot;in&quot;
                                (CamlinternalFormatBasics.Formatting_lit
                                  CamlinternalFormatBasics.Force_newline
                                  (CamlinternalFormatBasics.Alpha
                                    (CamlinternalFormatBasics.Char_literal
                                      &quot;)&quot; % char
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Close_box
                                        CamlinternalFormatBasics.End_of_format)))))))))))))))
          &quot;@[(let@ %a@ =@\n %a@ in@\n%a)@]&quot;) pp_lname id pp_mllam def pp_mllam
        body
    | MLapp f args =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Close_box
                    CamlinternalFormatBasics.End_of_format))))) &quot;@[%a@ %a@]&quot;)
        pp_mllam f (pp_args true) args
    | MLif t l1 l2 =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.String_literal &quot;(if &quot;
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot; then&quot;
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;  &quot;
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Formatting_lit
                          CamlinternalFormatBasics.Force_newline
                          (CamlinternalFormatBasics.String_literal &quot;else&quot;
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.String_literal &quot;  &quot;
                                (CamlinternalFormatBasics.Alpha
                                  (CamlinternalFormatBasics.Char_literal
                                    &quot;)&quot; % char
                                    (CamlinternalFormatBasics.Formatting_lit
                                      CamlinternalFormatBasics.Close_box
                                      CamlinternalFormatBasics.End_of_format))))))))))))))
          &quot;@[(if %a then@\n  %a@\nelse@\n  %a)@]&quot;) pp_mllam t pp_mllam l1
        pp_mllam l2
    | MLmatch annot c accu_br br =&gt;
      let '(mind, i) := Nativevalues.annot_sw.asw_ind annot in
      let prefix := Nativevalues.annot_sw.asw_prefix annot in
      let accu :=
        Format.sprintf
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot;Accu_&quot;
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      CamlinternalFormatBasics.End_of_format))))) &quot;%sAccu_%s_%i&quot;)
          prefix (string_of_mind mind) i in
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.String_literal &quot;begin match Obj.magic (&quot;
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot;) with&quot;
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;| &quot;
                      (CamlinternalFormatBasics.String
                        CamlinternalFormatBasics.No_padding
                        (CamlinternalFormatBasics.String_literal &quot; _ -&gt;&quot;
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Force_newline
                            (CamlinternalFormatBasics.String_literal &quot;  &quot;
                              (CamlinternalFormatBasics.Alpha
                                (CamlinternalFormatBasics.Formatting_lit
                                  CamlinternalFormatBasics.Force_newline
                                  (CamlinternalFormatBasics.Alpha
                                    (CamlinternalFormatBasics.String_literal
                                      &quot;end&quot;
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Close_box
                                        CamlinternalFormatBasics.End_of_format)))))))))))))))
          &quot;@[begin match Obj.magic (%a) with@\n| %s _ -&gt;@\n  %a@\n%aend@]&quot;)
        pp_mllam c accu pp_mllam accu_br (pp_branches prefix) br
    | MLconstruct prefix c args =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.String_literal &quot;(Obj.magic (&quot;
              (CamlinternalFormatBasics.String
                CamlinternalFormatBasics.No_padding
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.String_literal &quot;) : Nativevalues.t)&quot;
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Close_box
                      CamlinternalFormatBasics.End_of_format))))))
          &quot;@[(Obj.magic (%s%a) : Nativevalues.t)@]&quot;)
        (string_of_construct prefix c) pp_cargs args
    | MLint i =&gt; pp_int fmt i
    | MLuint i =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%s)&quot;)
        (Uint63.compile i)
    | MLsetref s body =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Formatting_lit
                (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
                (CamlinternalFormatBasics.String_literal &quot;:=&quot;
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Formatting_lit
                          CamlinternalFormatBasics.Close_box
                          CamlinternalFormatBasics.End_of_format))))))))
          &quot;@[%s@ :=@\n %a@]&quot;) s pp_mllam body
    | MLsequence l1 l2 =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;;&quot; % char
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  (CamlinternalFormatBasics.Alpha
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Close_box
                      CamlinternalFormatBasics.End_of_format))))))
          &quot;@[%a;@\n%a@]&quot;) pp_mllam l1 pp_mllam l2
    | MLarray arr =&gt;
      let len := (|Util.Array|).(CArray.ExtS.length) arr in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;|]&quot;
            (CamlinternalFormatBasics.Formatting_lit
              CamlinternalFormatBasics.Close_box
              CamlinternalFormatBasics.End_of_format)) &quot;|]@]&quot;)
    | MLisaccu prefix (mind, i) c =&gt;
      let accu :=
        Format.sprintf
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot;Accu_&quot;
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      CamlinternalFormatBasics.End_of_format))))) &quot;%sAccu_%s_%i&quot;)
          prefix (string_of_mind mind) i in
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Formatting_gen
            (CamlinternalFormatBasics.Open_box
              (CamlinternalFormatBasics.Format
                CamlinternalFormatBasics.End_of_format &quot;&quot;))
            (CamlinternalFormatBasics.String_literal &quot;begin match Obj.magic (&quot;
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot;) with&quot;
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;| &quot;
                      (CamlinternalFormatBasics.String
                        CamlinternalFormatBasics.No_padding
                        (CamlinternalFormatBasics.String_literal &quot; _ -&gt;&quot;
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Force_newline
                            (CamlinternalFormatBasics.String_literal &quot;  true&quot;
                              (CamlinternalFormatBasics.Formatting_lit
                                CamlinternalFormatBasics.Force_newline
                                (CamlinternalFormatBasics.String_literal
                                  &quot;| _ -&gt;&quot;
                                  (CamlinternalFormatBasics.Formatting_lit
                                    CamlinternalFormatBasics.Force_newline
                                    (CamlinternalFormatBasics.String_literal
                                      &quot;  false&quot;
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Force_newline
                                        (CamlinternalFormatBasics.String_literal
                                          &quot;end&quot;
                                          (CamlinternalFormatBasics.Formatting_lit
                                            CamlinternalFormatBasics.Close_box
                                            CamlinternalFormatBasics.End_of_format)))))))))))))))))
          &quot;@[begin match Obj.magic (%a) with@\n| %s _ -&gt;@\n  true@\n| _ -&gt;@\n  false@\nend@]&quot;)
        pp_mllam c accu
    end
  with pp_letrec
    (fmt : Stdlib.Format.formatter)
    (defs : array (lname * array lname * mllambda)) {struct fmt} : unit :=
    let len := (|Util.Array|).(CArray.ExtS.length) defs in
    let pp_one_rec (function_parameter : lname * array lname * mllambda)
      : unit :=
      let '(fn, argsn, body) := function_parameter in
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Alpha
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.String_literal &quot; =&quot;
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  (CamlinternalFormatBasics.String_literal &quot;  &quot;
                    (CamlinternalFormatBasics.Alpha
                      CamlinternalFormatBasics.End_of_format))))))
          &quot;%a%a =@\n  %a&quot;) pp_lname fn pp_ldecls argsn pp_mllam body in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ For loops not handled. *)
    for
  with pp_blam (fmt : Stdlib.Format.formatter) (l : mllambda) {struct fmt}
    : unit :=
    match
      (l,
        match l with
        | MLconstruct _ _ args =&gt;
          OCaml.Stdlib.gt ((|Util.Array|).(CArray.ExtS.length) args) 0
        | _ =&gt; false
        end) with
    |
      (MLprimitive (Mk_prod | Mk_sort) | MLlam _ _ | MLletrec _ _ | MLlet _ _ _
      | MLapp _ _ | MLif _ _ _, _) =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%a)&quot;) pp_mllam l
    | (MLconstruct _ _ args, true) =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%a)&quot;) pp_mllam l
    | (_, _) =&gt; pp_mllam fmt l
    end
  with pp_args
    (sep : bool) (fmt : Stdlib.Format.formatter) (args : array mllambda)
    {struct sep} : unit :=
    let sep :=
      if sep then
        &quot; &quot;
      else
        &quot;,&quot; in
    let len := (|Util.Array|).(CArray.ExtS.length) args in
    if OCaml.Stdlib.gt len 0 then
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ For loops not handled. *)
      for
    else
      tt
  with pp_cargs (fmt : Stdlib.Format.formatter) (args : array mllambda)
    {struct fmt} : unit :=
    let len := (|Util.Array|).(CArray.ExtS.length) args in
    match len with
    | 0 =&gt; tt
    | 1 =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
            (CamlinternalFormatBasics.Alpha
              CamlinternalFormatBasics.End_of_format)) &quot; %a&quot;) pp_blam
        ((|Util.Array|).(CArray.ExtS.get) args 0)
    | _ =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%a)&quot;)
        (pp_args false) args
    end
  with pp_cparam (fmt : Stdlib.Format.formatter) (param : option lname)
    {struct fmt} : unit :=
    match param with
    | Some l =&gt; pp_mllam fmt (MLlocal l)
    | None =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
            CamlinternalFormatBasics.End_of_format) &quot;_&quot;)
    end
  with pp_cparams
    (fmt : Stdlib.Format.formatter) (params : array (option lname)) {struct fmt}
    : unit :=
    let len := (|Util.Array|).(CArray.ExtS.length) params in
    match len with
    | 0 =&gt; tt
    | 1 =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
            (CamlinternalFormatBasics.Alpha
              CamlinternalFormatBasics.End_of_format)) &quot; %a&quot;) pp_cparam
        ((|Util.Array|).(CArray.ExtS.get) params 0)
    | _ =&gt;
      let aux (fmt : Stdlib.Format.formatter) (params : array (option lname))
        : unit :=
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ For loops not handled. *)
        for in
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;(&quot; % char
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;(%a)&quot;) aux params
    end
  with pp_branches
    (prefix : string) (fmt : Stdlib.Format.formatter) (bs : mllam_branches)
    {struct prefix} : unit :=
    let pp_branch
      (function_parameter :
        list (((Names.MutInd.t * Z) * Z) * array (option lname)) * mllambda)
      : unit :=
      let '(cargs, body) := function_parameter in
      let pp_c
        (fmt : Stdlib.Format.formatter)
        (function_parameter : ((Names.MutInd.t * Z) * Z) * array (option lname))
        : unit :=
        let '(cn, args) := function_parameter in
        Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;| &quot;
              (CamlinternalFormatBasics.String
                CamlinternalFormatBasics.No_padding
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                    CamlinternalFormatBasics.End_of_format)))) &quot;| %s%a &quot;)
          (string_of_construct prefix cn) pp_cparams args in
      let fix pp_cargs
        (fmt : Stdlib.Format.formatter)
        (cargs : list (((Names.MutInd.t * Z) * Z) * array (option lname)))
        {struct fmt} : unit :=
        match cargs with
        | [] =&gt; tt
        | cons cargs cargs' =&gt;
          Format.fprintf fmt
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Alpha
                  CamlinternalFormatBasics.End_of_format)) &quot;%a%a&quot;) pp_c cargs
            pp_cargs cargs'
        end in
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Alpha
            (CamlinternalFormatBasics.String_literal &quot; -&gt;&quot;
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Force_newline
                (CamlinternalFormatBasics.String_literal &quot;  &quot;
                  (CamlinternalFormatBasics.Alpha
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      CamlinternalFormatBasics.End_of_format))))))
          &quot;%a -&gt;@\n  %a@\n&quot;) pp_cargs cargs pp_mllam body in
    (|Util.Array|).(CArray.ExtS.iter) pp_branch bs
  with pp_primitive
    (fmt : Stdlib.Format.formatter) (function_parameter : primitive)
    {struct fmt} : unit :=
    match function_parameter with
    | Mk_prod =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_prod_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_prod_accu&quot;)
    | Mk_sort =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_sort_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_sort_accu&quot;)
    | Mk_ind =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_ind_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_ind_accu&quot;)
    | Mk_const =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_constant_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_constant_accu&quot;)
    | Mk_sw =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_sw_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_sw_accu&quot;)
    | Mk_fix rec_pos start =&gt;
      let pp_rec_pos (fmt : Stdlib.Format.formatter) (rec_pos : array Z)
        : unit :=
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        Format.fprintf fmt
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot; |]&quot;
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format)) &quot; |]@]&quot;) in
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_fix_accu &quot;
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format)))) &quot;mk_fix_accu %a %i&quot;)
        pp_rec_pos rec_pos start
    | Mk_cofix start =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_cofix_accu &quot;
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              CamlinternalFormatBasics.End_of_format)) &quot;mk_cofix_accu %i&quot;) start
    | Mk_rel i =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_rel_accu &quot;
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              CamlinternalFormatBasics.End_of_format)) &quot;mk_rel_accu %i&quot;) i
    | Mk_var id =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal
            &quot;mk_var_accu (Names.Id.of_string \&quot;&quot;&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot;\&quot;&quot;)&quot;
                CamlinternalFormatBasics.End_of_format)))
          &quot;mk_var_accu (Names.Id.of_string \&quot;&quot;%s\&quot;&quot;)&quot;) (string_of_id id)
    | Mk_proj =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_proj_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_proj_accu&quot;)
    | Is_int =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;is_int&quot;
            CamlinternalFormatBasics.End_of_format) &quot;is_int&quot;)
    | Cast_accu =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;cast_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;cast_accu&quot;)
    | Upd_cofix =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;upd_cofix&quot;
            CamlinternalFormatBasics.End_of_format) &quot;upd_cofix&quot;)
    | Force_cofix =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;force_cofix&quot;
            CamlinternalFormatBasics.End_of_format) &quot;force_cofix&quot;)
    | Mk_uint =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_uint&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_uint&quot;)
    | Mk_int =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_int&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_int&quot;)
    | Mk_bool =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_bool&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_bool&quot;)
    | Val_to_int =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;val_to_int&quot;
            CamlinternalFormatBasics.End_of_format) &quot;val_to_int&quot;)
    | Mk_meta =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_meta_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_meta_accu&quot;)
    | Mk_evar =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;mk_evar_accu&quot;
            CamlinternalFormatBasics.End_of_format) &quot;mk_evar_accu&quot;)
    | MLand =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(&amp;&amp;)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(&amp;&amp;)&quot;)
    | MLle =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(&lt;=)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(&lt;=)&quot;)
    | MLlt =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(&lt;)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(&lt;)&quot;)
    | MLinteq =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(==)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(==)&quot;)
    | MLlsl =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lsl)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(lsl)&quot;)
    | MLlsr =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lsr)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(lsr)&quot;)
    | MLland =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(land)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(land)&quot;)
    | MLlor =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lor)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(lor)&quot;)
    | MLlxor =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(lxor)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(lxor)&quot;)
    | MLadd =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(+)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(+)&quot;)
    | MLsub =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;(-)&quot;
            CamlinternalFormatBasics.End_of_format) &quot;(-)&quot;)
    | MLmul =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;( * )&quot;
            CamlinternalFormatBasics.End_of_format) &quot;( * )&quot;)
    | MLmagic =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;Obj.magic&quot;
            CamlinternalFormatBasics.End_of_format) &quot;Obj.magic&quot;)
    | MLarrayget =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;Array.get&quot;
            CamlinternalFormatBasics.End_of_format) &quot;Array.get&quot;)
    | Mk_empty_instance =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;Univ.Instance.empty&quot;
            CamlinternalFormatBasics.End_of_format) &quot;Univ.Instance.empty&quot;)
    | Coq_primitive op None =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;no_check_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.End_of_format)) &quot;no_check_%s&quot;)
        (CPrimitives.to_string op)
    | Coq_primitive op (Some (prefix, (c, _))) =&gt;
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
              (CamlinternalFormatBasics.Alpha
                CamlinternalFormatBasics.End_of_format))) &quot;%s %a&quot;)
        (CPrimitives.to_string op) pp_mllam (MLglobal (Gconstant prefix c))
    end in
  Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Formatting_gen
        (CamlinternalFormatBasics.Open_box
          (CamlinternalFormatBasics.Format
            CamlinternalFormatBasics.End_of_format &quot;&quot;))
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.Formatting_lit
            CamlinternalFormatBasics.Close_box
            CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot;) pp_mllam l.

Definition pp_array (fmt : Stdlib.Format.formatter) (t : array mllambda)
  : unit :=
  let len := (|Util.Array|).(CArray.ExtS.length) t in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Format.fprintf fmt
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;|]&quot;
        (CamlinternalFormatBasics.Formatting_lit
          CamlinternalFormatBasics.Close_box
          CamlinternalFormatBasics.End_of_format)) &quot;|]@]&quot;).

Definition pp_global (fmt : Stdlib.Format.formatter) (g : global) : unit :=
  match g with
  | Glet gn c =&gt;
    let '(ids, c) := decompose_MLlam c in
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot;))
          (CamlinternalFormatBasics.String_literal &quot;let &quot;
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.String_literal &quot; =&quot;
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Force_newline
                    (CamlinternalFormatBasics.String_literal &quot;  &quot;
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Formatting_lit
                          CamlinternalFormatBasics.Close_box
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Force_newline
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Flush_newline
                              CamlinternalFormatBasics.End_of_format)))))))))))
        &quot;@[let %a%a =@\n  %a@]@\n@.&quot;) pp_gname gn pp_ldecls ids pp_mllam c
  | Gopen s =&gt;
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot;))
          (CamlinternalFormatBasics.String_literal &quot;open &quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Flush_newline
                  CamlinternalFormatBasics.End_of_format))))) &quot;@[open %s@]@.&quot;) s
  | Gtype (mind, i) lar =&gt;
    let l := string_of_mind mind in
    let fix aux (s : string) (ar : Int.t) {struct s} : string :=
      if Int.equal ar 0 then
        s
      else
        aux (String.append s &quot; * Nativevalues.t&quot;) (Z.sub ar 1) in
    let pp_const_sig (i : Z) (fmt : Stdlib.Format.formatter) (j : Z) (ar : Z)
      : unit :=
      let sig_str :=
        if OCaml.Stdlib.gt ar 0 then
          aux &quot;of Nativevalues.t&quot; (Z.sub ar 1)
        else
          &quot;&quot; in
      Format.fprintf fmt
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;  | Construct_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                        (CamlinternalFormatBasics.String
                          CamlinternalFormatBasics.No_padding
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Force_newline
                            CamlinternalFormatBasics.End_of_format)))))))))
          &quot;  | Construct_%s_%i_%i %s@\n&quot;) l i j sig_str in
    let pp_const_sigs (i : Z) (fmt : Stdlib.Format.formatter) (lar : array Z)
      : unit :=
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (|Util.Array|).(CArray.ExtS.iteri) (pp_const_sig i fmt) lar in
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot;))
          (CamlinternalFormatBasics.String_literal &quot;type ind_&quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;_&quot; % char
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.String_literal &quot; =&quot;
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Formatting_lit
                          CamlinternalFormatBasics.Close_box
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Force_newline
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Flush_newline
                              CamlinternalFormatBasics.End_of_format)))))))))))
        &quot;@[type ind_%s_%i =@\n%a@]@\n@.&quot;) l i (pp_const_sigs i) lar
  | Gtblfixtype g params t =&gt;
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot;))
          (CamlinternalFormatBasics.String_literal &quot;let &quot;
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.String_literal &quot; =&quot;
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.String_literal &quot;  &quot;
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Close_box
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.Formatting_lit
                                CamlinternalFormatBasics.Flush_newline
                                CamlinternalFormatBasics.End_of_format))))))))))))
        &quot;@[let %a %a =@\n  %a@]@\n@.&quot;) pp_gname g pp_ldecls params pp_array t
  | Gtblnorm g params t =&gt;
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot;))
          (CamlinternalFormatBasics.String_literal &quot;let &quot;
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                (CamlinternalFormatBasics.Alpha
                  (CamlinternalFormatBasics.String_literal &quot; =&quot;
                    (CamlinternalFormatBasics.Formatting_lit
                      CamlinternalFormatBasics.Force_newline
                      (CamlinternalFormatBasics.String_literal &quot;  &quot;
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.Formatting_lit
                            CamlinternalFormatBasics.Close_box
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.Formatting_lit
                                CamlinternalFormatBasics.Flush_newline
                                CamlinternalFormatBasics.End_of_format))))))))))))
        &quot;@[let %a %a =@\n  %a@]@\n@.&quot;) pp_gname g pp_ldecls params pp_array t
  | Gletcase gn params annot a accu bs =&gt;
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot;))
          (CamlinternalFormatBasics.String_literal &quot;(* Hash = &quot;
            (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              (CamlinternalFormatBasics.String_literal &quot; *)&quot;
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Force_newline
                  (CamlinternalFormatBasics.String_literal &quot;let rec &quot;
                    (CamlinternalFormatBasics.Alpha
                      (CamlinternalFormatBasics.Char_literal &quot; &quot; % char
                        (CamlinternalFormatBasics.Alpha
                          (CamlinternalFormatBasics.String_literal &quot; =&quot;
                            (CamlinternalFormatBasics.Formatting_lit
                              CamlinternalFormatBasics.Force_newline
                              (CamlinternalFormatBasics.String_literal &quot;  &quot;
                                (CamlinternalFormatBasics.Alpha
                                  (CamlinternalFormatBasics.Formatting_lit
                                    CamlinternalFormatBasics.Close_box
                                    (CamlinternalFormatBasics.Formatting_lit
                                      CamlinternalFormatBasics.Force_newline
                                      (CamlinternalFormatBasics.Formatting_lit
                                        CamlinternalFormatBasics.Flush_newline
                                        CamlinternalFormatBasics.End_of_format))))))))))))))))
        &quot;@[(* Hash = %i *)@\nlet rec %a %a =@\n  %a@]@\n@.&quot;) (hash_global g)
      pp_gname gn pp_ldecls params pp_mllam (MLmatch annot a accu bs)
  | Gcomment s =&gt;
    Format.fprintf fmt
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              CamlinternalFormatBasics.End_of_format &quot;&quot;))
          (CamlinternalFormatBasics.String_literal &quot;(* &quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot; *)&quot;
                (CamlinternalFormatBasics.Formatting_lit
                  CamlinternalFormatBasics.Close_box
                  (CamlinternalFormatBasics.Formatting_lit
                    CamlinternalFormatBasics.Flush_newline
                    CamlinternalFormatBasics.End_of_format))))))
        &quot;@[(* %s *)@]@.&quot;) s
  end.

Fixpoint compile_with_fv
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (auxdefs : list global) (l : option Names.Label.t) (t : Nativelambda.lambda)
  {struct env} : list global * mllambda :=
  let '(auxdefs, (fv_named, fv_rel), ml) := mllambda_of_lambda univ auxdefs l t
    in
  if
    andb ((|Util.List|).(CList.ExtS.is_empty) fv_named)
      ((|Util.List|).(CList.ExtS.is_empty) fv_rel) then
    (auxdefs, ml)
  else
    apply_fv env sigma univ (fv_named, fv_rel) auxdefs ml

with apply_fv
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (function_parameter : list (Names.variable * mllambda) * list (Z * mllambda))
  {struct env} : list global -&gt; mllambda -&gt; list global * mllambda :=
  let '(fv_named, fv_rel) := function_parameter in
  fun auxdefs =&gt;
    fun ml =&gt;
      let get_rel_val {A : Set} (function_parameter : Z * A)
        : list global -&gt; list global :=
        let '(n, _) := function_parameter in
        fun auxdefs =&gt; compile_rel env sigma univ auxdefs n in
      let get_named_val {A : Set} (function_parameter : Names.variable * A)
        : list global -&gt; list global :=
        let '(id, _) := function_parameter in
        fun auxdefs =&gt; compile_named env sigma univ auxdefs id in
      let auxdefs :=
        (|Util.List|).(CList.ExtS.fold_right) get_rel_val fv_rel auxdefs in
      let auxdefs :=
        (|Util.List|).(CList.ExtS.fold_right) get_named_val fv_named auxdefs in
      let lvl := Context.Rel.length (rel_context env) in
      let fv_rel :=
        (|Util.List|).(CList.ExtS.map)
          (fun function_parameter =&gt;
            let '(n, _) := function_parameter in
            MLglobal (Grel (Z.sub lvl n))) fv_rel in
      let fv_named :=
        (|Util.List|).(CList.ExtS.map)
          (fun function_parameter =&gt;
            let '(id, _) := function_parameter in
            MLglobal (Gnamed id)) fv_named in
      let aux_name := fresh_lname Names.Anonymous in
      (auxdefs,
        (MLlet aux_name ml
          (mkMLapp (MLlocal aux_name)
            ((|Util.Array|).(CArray.ExtS.of_list) (op_at fv_rel fv_named)))))

with compile_rel
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (auxdefs : list global) (n : Z) {struct env} : list global :=
  let decl := lookup_rel n env in
  let n := Z.sub ((|Util.List|).(CList.ExtS.length) (rel_context env)) n in
  match decl with
  | Context.Rel.Declaration.LocalDef _ t _ =&gt;
    let code := lambda_of_constr env sigma t in
    let '(auxdefs, code) := compile_with_fv env sigma univ auxdefs None code in
    cons (Glet (Grel n) code) auxdefs
  | Context.Rel.Declaration.LocalAssum _ _ =&gt;
    cons (Glet (Grel n) (MLprimitive (Mk_rel n))) auxdefs
  end

with compile_named
  (env : Environ.env) (sigma : Nativelambda.evars) (univ : option lname)
  (auxdefs : list global) (id : Names.variable) {struct env} : list global :=
  match lookup_named id env with
  | Context.Named.Declaration.LocalDef _ t _ =&gt;
    let code := lambda_of_constr env sigma t in
    let '(auxdefs, code) := compile_with_fv env sigma univ auxdefs None code in
    cons (Glet (Gnamed id) code) auxdefs
  | Context.Named.Declaration.LocalAssum _ _ =&gt;
    cons (Glet (Gnamed id) (MLprimitive (Mk_var id))) auxdefs
  end.

Definition compile_constant
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (interactive : bool) (con : Names.Constant.t)
  (cb : Declarations.constant_body) : list global * Environ.link_info :=
  let no_univs :=
    equiv_decb 0
      (Univ.AUContext.size (Declareops.constant_polymorphic_context cb)) in
  match Declarations.constant_body.const_body cb with
  | Declarations.Def t =&gt;
    let t := Mod_subst.force_constr t in
    let code := lambda_of_constr env sigma t in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let is_lazy := is_lazy t in
    let code :=
      if is_lazy then
        mk_lazy code
      else
        code in
    let name :=
      if interactive then
        Environ.LinkedInteractive prefix
      else
        Environ.Linked prefix in
    let l := Constant.label con in
    let '(auxdefs, code) :=
      if no_univs then
        compile_with_fv env sigma None [] (Some l) code
      else
        let univ := fresh_univ tt in
        let '(auxdefs, code) :=
          compile_with_fv env sigma (Some univ) [] (Some l) code in
        (auxdefs,
          (mkMLlam
            (* ❌ Arrays not handled. *)
            [ univ ] code)) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let code := optimize_stk (cons (Glet (Gconstant &quot;&quot; con) code) auxdefs) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (code, name)
  | _ =&gt;
    let i := push_symbol (SymbConst con) in
    let args :=
      if no_univs then
        (* ❌ Arrays not handled. *)
        [
          get_const_code i;
          MLarray
            (* ❌ Arrays not handled. *)
            [ ]
        ]
      else
        (* ❌ Arrays not handled. *)
        [ get_const_code i ] in
    ([ Glet (Gconstant &quot;&quot; con) (mkMLapp (MLprimitive Mk_const) args) ],
      (if interactive then
        Environ.LinkedInteractive prefix
      else
        Environ.Linked prefix))
  end.

Definition StringOrd :=
  let t := string in
  let compare := (|Util.String|).(CString.ExtS.compare) in
  existT (fun _ =&gt; _) tt
    {|
      Stdlib__set.OrderedType.compare := compare
    |}.

Definition StringSet :=
  __Set.Make
    (existT _ _
      {|
        Stdlib__set.OrderedType.compare :=
          (|StringOrd|).(Stdlib__set.OrderedType.compare)
      |}).

Definition loaded_native_files : Stdlib.ref (|StringSet|).(Stdlib__set.S.t) :=
  Stdlib.__ref_value (|StringSet|).(Stdlib__set.S.empty).

Definition is_loaded_native_file (s : (|StringSet|).(Stdlib__set.S.elt))
  : bool :=
  (|StringSet|).(Stdlib__set.S.mem) s
    (Stdlib.op_exclamation loaded_native_files).

Definition register_native_file (s : (|StringSet|).(Stdlib__set.S.elt))
  : unit :=
  Stdlib.op_coloneq loaded_native_files
    ((|StringSet|).(Stdlib__set.S.add) s
      (Stdlib.op_exclamation loaded_native_files)).

Definition is_code_loaded
  (interactive : bool) (name : Stdlib.ref Environ.link_info) : bool :=
  match Stdlib.op_exclamation name with
  | Environ.NotLinked =&gt; false
  | Environ.LinkedInteractive s =&gt;
    if andb interactive (is_loaded_native_file s) then
      true
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      false
  | Environ.Linked s =&gt;
    if is_loaded_native_file s then
      true
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      false
  end.

Definition param_name : Names.name := Names.Name (Id.of_string &quot;params&quot;).

Definition arg_name : Names.name := Names.Name (Id.of_string &quot;arg&quot;).

Definition compile_mind
  (mb : Declarations.mutual_inductive_body) (mind : Names.MutInd.t)
  (stack : list global) : list global :=
  let u := Declareops.inductive_polymorphic_context mb in
  let f (i : Z) (stack : list global) (ob : Declarations.one_inductive_body)
    : list global :=
    let ind := (mind, i) in
    let gtype :=
      Gtype ind
        ((|Util.Array|).(CArray.ExtS.map) snd
          (Declarations.one_inductive_body.mind_reloc_tbl ob)) in
    let j := push_symbol (SymbInd ind) in
    let name := Gind &quot;&quot; ind in
    let accu :=
      let args :=
        if Int.equal (Univ.AUContext.size u) 0 then
          (* ❌ Arrays not handled. *)
          [
            get_ind_code j;
            MLarray
              (* ❌ Arrays not handled. *)
              [ ]
          ]
        else
          (* ❌ Arrays not handled. *)
          [ get_ind_code j ] in
      Glet name (MLapp (MLprimitive Mk_ind) args) in
    let nparams := Declarations.mutual_inductive_body.mind_nparams mb in
    let params :=
      (|Util.Array|).(CArray.ExtS.init) nparams
        (fun i =&gt; {| lname.lname := param_name; lname.luid := i |}) in
    let add_construct {A : Set}
      (j : Z) (acc : list global) (function_parameter : A * Z) : list global :=
      let '(_, arity) := function_parameter in
      let args :=
        (|Util.Array|).(CArray.ExtS.init) arity
          (fun k =&gt; {| lname.lname := arg_name; lname.luid := k |}) in
      let c := (ind, (Z.add j 1)) in
      cons
        (Glet (Gconstruct &quot;&quot; c)
          (mkMLlam ((|Util.Array|).(CArray.ExtS.append) params args)
            (MLconstruct &quot;&quot; c
              ((|Util.Array|).(CArray.ExtS.map) (fun id =&gt; MLlocal id) args))))
        acc in
    let constructors :=
      (|Util.Array|).(CArray.ExtS.fold_left_i) add_construct []
        (Declarations.one_inductive_body.mind_reloc_tbl ob) in
    let add_proj {A : Set} (proj_arg : Int.t) (acc : list global) (_pb : A)
      : list global :=
      let tbl := Declarations.one_inductive_body.mind_reloc_tbl ob in
      let ci :=
        {| Constr.case_info.ci_ind := ind; Constr.case_info.ci_npar := nparams;
          Constr.case_info.ci_cstr_ndecls :=
            (* ❌ Arrays not handled. *)
            [ ];
          Constr.case_info.ci_cstr_nargs :=
            (* ❌ Arrays not handled. *)
            [ 0 ];
          Constr.case_info.ci_relevance :=
            Declarations.one_inductive_body.mind_relevance ob;
          Constr.case_info.ci_pp_info :=
            {| Constr.case_printing.ind_tags := [];
              Constr.case_printing.cstr_tags :=
                (* ❌ Arrays not handled. *)
                [ ]; Constr.case_printing.style := Constr.RegularStyle |} |} in
      let asw :=
        {| Nativevalues.annot_sw.asw_ind := ind;
          Nativevalues.annot_sw.asw_ci := ci;
          Nativevalues.annot_sw.asw_reloc := tbl;
          Nativevalues.annot_sw.asw_finite := true;
          Nativevalues.annot_sw.asw_prefix := &quot;&quot; |} in
      let c_uid := fresh_lname Names.Anonymous in
      let cf_uid := fresh_lname Names.Anonymous in
      let '(_, arity) := (|Util.Array|).(CArray.ExtS.get) tbl 0 in
      let ci_uid := fresh_lname Names.Anonymous in
      let cargs :=
        (|Util.Array|).(CArray.ExtS.init) arity
          (fun i =&gt;
            if Int.equal i proj_arg then
              Some ci_uid
            else
              None) in
      let i := push_symbol (SymbProj (ind, proj_arg)) in
      let accu :=
        MLapp (MLprimitive Cast_accu)
          (* ❌ Arrays not handled. *)
          [ MLlocal cf_uid ] in
      let accu_br :=
        MLapp (MLprimitive Mk_proj)
          (* ❌ Arrays not handled. *)
          [ get_proj_code i; accu ] in
      let code :=
        MLmatch asw (MLlocal cf_uid) accu_br
          (* ❌ Arrays not handled. *)
          [ ([ ((ind, 1), cargs) ], (MLlocal ci_uid)) ] in
      let code := MLlet cf_uid (mkForceCofix &quot;&quot; ind (MLlocal c_uid)) code in
      let gn := Gproj &quot;&quot; ind proj_arg in
      cons
        (Glet gn
          (mkMLlam
            (* ❌ Arrays not handled. *)
            [ c_uid ] code)) acc in
    let projs :=
      match Declarations.mutual_inductive_body.mind_record mb with
      | Declarations.NotRecord | Declarations.FakeRecord =&gt; []
      | Declarations.PrimRecord info =&gt;
        let '(_, _, _, pbs) := (|Util.Array|).(CArray.ExtS.get) info i in
        (|Util.Array|).(CArray.ExtS.fold_left_i) add_proj [] pbs
      end in
    op_at projs (op_at constructors (cons gtype (cons accu stack))) in
  (|Util.Array|).(CArray.ExtS.fold_left_i) f stack
    (Declarations.mutual_inductive_body.mind_packets mb).

Definition code_location_update :=
  Stdlib.ref Environ.link_info * Environ.link_info.

Definition code_location_updates :=
  Names.Mindmap_env.t code_location_update *
    Names.Cmap_env.t code_location_update.

Definition linkable_code := list global * code_location_updates.

Definition empty_updates {A B : Set}
  : Names.Mindmap_env.t A * Names.Cmap_env.t B :=
  (Mindmap_env.empty, Cmap_env.empty).

Definition compile_mind_deps {A : Set}
  (env : Environ.env) (prefix : string) (interactive : bool)
  (function_parameter :
    list global *
      (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info) *
        A))
  : Names.Mindmap_env.key -&gt;
  list global *
    (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info) * A) :=
  let '(comp_stack, (mind_updates, const_updates)) as init := function_parameter
    in
  fun mind =&gt;
    let '(mib, nameref) := lookup_mind_key mind env in
    if
      orb (is_code_loaded interactive nameref)
        (Mindmap_env.mem mind mind_updates) then
      init
    else
      let comp_stack := compile_mind mib mind comp_stack in
      let name :=
        if interactive then
          Environ.LinkedInteractive prefix
        else
          Environ.Linked prefix in
      let upd := (nameref, name) in
      let mind_updates := Mindmap_env.add mind upd mind_updates in
      (comp_stack, (mind_updates, const_updates)).

Definition compile_deps
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (interactive : bool)
  (init :
    list global *
      (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info) *
        Names.Cmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info)))
  (t : Constr.constr)
  : list global *
    (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info) *
      Names.Cmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info)) :=
  let fix aux
    (env : Environ.env) (lvl : Z)
    (init :
      list global *
        (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info)
          * Names.Cmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info)))
    (t : Constr.constr) {struct env}
    : list global *
      (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info) *
        Names.Cmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info)) :=
    match
      ((kind t),
        match kind t with
        | Constr.Rel n =&gt; OCaml.Stdlib.gt n lvl
        | _ =&gt; false
        end) with
    | (Constr.Ind ((mind, _), _u), _) =&gt;
      compile_mind_deps env prefix interactive init mind
    | (Constr.Const c, _) =&gt;
      let '(c, _u) := get_alias env c in
      let '(cb, (nameref, _)) := lookup_constant_key c env in
      let '(_, (_, const_updates)) := init in
      if orb (is_code_loaded interactive nameref) (Cmap_env.mem c const_updates)
        then
        init
      else
        let '(comp_stack, (mind_updates, const_updates)) :=
          match Declarations.constant_body.const_body cb with
          | Declarations.Def t =&gt; aux env lvl init (Mod_subst.force_constr t)
          | _ =&gt; init
          end in
        let '(code, name) := compile_constant env sigma prefix interactive c cb
          in
        let comp_stack := op_at code comp_stack in
        let const_updates := Cmap_env.add c (nameref, name) const_updates in
        (comp_stack, (mind_updates, const_updates))
    | (Constr.Construct (((mind, _), _), _u), _) =&gt;
      compile_mind_deps env prefix interactive init mind
    | (Constr.Proj p c, _) =&gt;
      let init :=
        compile_mind_deps env prefix interactive init (Projection.mind p) in
      aux env lvl init c
    | (Constr.Case ci _p _c _ac, _) =&gt;
      let mind := fst (Constr.case_info.ci_ind ci) in
      let init := compile_mind_deps env prefix interactive init mind in
      fold_constr_with_binders Z.succ (aux env) lvl init t
    | (Constr.Var id, _) =&gt;
      match lookup_named id env with
      | Context.Named.Declaration.LocalDef _ t _ =&gt; aux env lvl init t
      | _ =&gt; init
      end
    | (Constr.Rel n, true) =&gt;
      let decl := lookup_rel n env in
      let env := env_of_rel n env in
      match decl with
      | Context.Rel.Declaration.LocalDef _ t _ =&gt; aux env lvl init t
      | Context.Rel.Declaration.LocalAssum _ _ =&gt; init
      end
    | (_, _) =&gt; fold_constr_with_binders Z.succ (aux env) lvl init t
    end in
  aux env 0 init t.

Definition compile_constant_field
  (env : Environ.env) (prefix : string) (con : Names.Constant.t)
  (acc : list global) (cb : Declarations.constant_body) : list global :=
  let '(gl, _) := compile_constant env empty_evars prefix false con cb in
  op_at gl acc.

Definition compile_mind_field
  (mp : Names.ModPath.t) (l : Names.Label.t) (acc : list global)
  (mb : Declarations.mutual_inductive_body) : list global :=
  let mind := MutInd.make2 mp l in
  compile_mind mb mind acc.

Definition mk_open (s : string) : global := Gopen s.

Definition mk_internal_let (s : string) (code : mllambda) : global :=
  Glet (Ginternal s) code.

Definition mk_conv_code
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (t1 : Constr.constr) (t2 : Constr.constr)
  : list global *
    (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info) *
      Names.Cmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info)) :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let '(gl, (mind_updates, const_updates)) :=
    let init := ([], empty_updates) in
    compile_deps env sigma prefix true init t1 in
  let '(gl, (mind_updates, const_updates)) :=
    let init := (gl, (mind_updates, const_updates)) in
    compile_deps env sigma prefix true init t2 in
  let code1 := lambda_of_constr env sigma t1 in
  let code2 := lambda_of_constr env sigma t2 in
  let '(gl, code1) := compile_with_fv env sigma None gl None code1 in
  let '(gl, code2) := compile_with_fv env sigma None gl None code2 in
  let t1 := mk_internal_let &quot;t1&quot; code1 in
  let t2 := mk_internal_let &quot;t2&quot; code2 in
  let g1 := MLglobal (Ginternal &quot;t1&quot;) in
  let g2 := MLglobal (Ginternal &quot;t2&quot;) in
  let setref1 := Glet (Ginternal &quot;_&quot;) (MLsetref &quot;rt1&quot; g1) in
  let setref2 := Glet (Ginternal &quot;_&quot;) (MLsetref &quot;rt2&quot; g2) in
  let gl :=
    (|Util.List|).(CList.ExtS.rev)
      (cons setref2 (cons setref1 (cons t2 (cons t1 gl)))) in
  let header :=
    Glet (Ginternal &quot;symbols_tbl&quot;)
      (MLapp (MLglobal (Ginternal &quot;get_symbols&quot;))
        (* ❌ Arrays not handled. *)
        [ MLglobal (Ginternal &quot;()&quot;) ]) in
  ((cons header gl), (mind_updates, const_updates)).

Definition mk_norm_code
  (env : Environ.env) (sigma : Nativelambda.evars) (prefix : string)
  (t : Constr.constr)
  : list global *
    (Names.Mindmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info) *
      Names.Cmap_env.t (Stdlib.ref Environ.link_info * Environ.link_info)) :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let '(gl, (mind_updates, const_updates)) :=
    let init := ([], empty_updates) in
    compile_deps env sigma prefix true init t in
  let code := lambda_of_constr env sigma t in
  let '(gl, code) := compile_with_fv env sigma None gl None code in
  let t1 := mk_internal_let &quot;t1&quot; code in
  let g1 := MLglobal (Ginternal &quot;t1&quot;) in
  let setref := Glet (Ginternal &quot;_&quot;) (MLsetref &quot;rt1&quot; g1) in
  let gl := (|Util.List|).(CList.ExtS.rev) (cons setref (cons t1 gl)) in
  let header :=
    Glet (Ginternal &quot;symbols_tbl&quot;)
      (MLapp (MLglobal (Ginternal &quot;get_symbols&quot;))
        (* ❌ Arrays not handled. *)
        [ MLglobal (Ginternal &quot;()&quot;) ]) in
  ((cons header gl), (mind_updates, const_updates)).

Definition mk_library_header {A : Set} (dir : A) : list global :=
  let libname :=
    Format.sprintf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;(str_decode \&quot;&quot;&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;\&quot;&quot;)&quot;
              CamlinternalFormatBasics.End_of_format))) &quot;(str_decode \&quot;&quot;%s\&quot;&quot;)&quot;)
      (str_encode dir) in
  [
    Glet (Ginternal &quot;symbols_tbl&quot;)
      (MLapp (MLglobal (Ginternal &quot;get_library_native_symbols&quot;))
        (* ❌ Arrays not handled. *)
        [ MLglobal (Ginternal libname) ])
  ].

Definition update_location {A : Set} (function_parameter : Stdlib.ref A * A)
  : unit :=
  let '(r, v) := function_parameter in
  Stdlib.op_coloneq r v.

Definition update_locations {A B : Set}
  (function_parameter :
    Names.Mindmap_env.t (Stdlib.ref A * A) * Names.Cmap_env.t (Stdlib.ref B * B))
  : unit :=
  let '(ind_updates, const_updates) := function_parameter in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Cmap_env.iter
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      update_location) const_updates.

Definition add_header_comment (mlcode : list global) (s : string)
  : list global := cons (Gcomment s) mlcode.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativecode.mli">
  <div style="margin: 20px;">
    <h3>Nativecode_mli</h3>
    <ul>
      <li>OCaml size: 84 lines</li>
      <li>Coq size: 85 lines (+1% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativecode.mli"><code>nativecode.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Names
open Constr
open Declarations
open Environ
open Nativelambda

(** This file defines the mllambda code generation phase of the native
compiler. mllambda represents a fragment of ML, and can easily be printed
to OCaml code. *)

type mllambda
type global

val pp_global : Format.formatter -&gt; global -&gt; unit

val mk_open : string -&gt; global

(* Precomputed values for a compilation unit *)
type symbol
type symbols

val empty_symbols : symbols

val clear_symbols : unit -&gt; unit

val get_value : symbols -&gt; int -&gt; Nativevalues.t

val get_sort : symbols -&gt; int -&gt; Sorts.t

val get_name : symbols -&gt; int -&gt; Name.t

val get_const : symbols -&gt; int -&gt; Constant.t

val get_match : symbols -&gt; int -&gt; Nativevalues.annot_sw

val get_ind : symbols -&gt; int -&gt; inductive

val get_meta : symbols -&gt; int -&gt; metavariable

val get_evar : symbols -&gt; int -&gt; Evar.t

val get_level : symbols -&gt; int -&gt; Univ.Level.t

val get_proj : symbols -&gt; int -&gt; inductive * int

val get_symbols : unit -&gt; symbols

type code_location_update
type code_location_updates
type linkable_code = global list * code_location_updates

val clear_global_tbl : unit -&gt; unit

val empty_updates : code_location_updates

val register_native_file : string -&gt; unit

val compile_constant_field : env -&gt; string -&gt; Constant.t -&gt;
  global list -&gt; constant_body -&gt; global list

val compile_mind_field : ModPath.t -&gt; Label.t -&gt;
  global list -&gt; mutual_inductive_body -&gt; global list

val mk_conv_code : env -&gt; evars -&gt; string -&gt; constr -&gt; constr -&gt; linkable_code
val mk_norm_code : env -&gt; evars -&gt; string -&gt; constr -&gt; linkable_code

val mk_library_header : DirPath.t -&gt; global list

val mod_uid_of_dirpath : DirPath.t -&gt; string

val link_info_of_dirpath : DirPath.t -&gt; link_info

val update_locations : code_location_updates -&gt; unit

val add_header_comment : global list -&gt; string -&gt; global list
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativecode.mli"><code>Nativecode_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter mllambda : Set.

Parameter global : Set.

Parameter pp_global : Stdlib.Format.formatter -&gt; global -&gt; unit.

Parameter mk_open : string -&gt; global.

Parameter symbol : Set.

Parameter symbols : Set.

Parameter empty_symbols : symbols.

Parameter clear_symbols : unit -&gt; unit.

Parameter get_value : symbols -&gt; Z -&gt; Nativevalues.t.

Parameter get_sort : symbols -&gt; Z -&gt; Sorts.t.

Parameter get_name : symbols -&gt; Z -&gt; Names.Name.t.

Parameter get_const : symbols -&gt; Z -&gt; Names.Constant.t.

Parameter get_match : symbols -&gt; Z -&gt; Nativevalues.annot_sw.

Parameter get_ind : symbols -&gt; Z -&gt; Names.inductive.

Parameter get_meta : symbols -&gt; Z -&gt; Constr.metavariable.

Parameter get_evar : symbols -&gt; Z -&gt; Evar.t.

Parameter get_level : symbols -&gt; Z -&gt; Univ.Level.t.

Parameter get_proj : symbols -&gt; Z -&gt; Names.inductive * Z.

Parameter get_symbols : unit -&gt; symbols.

Parameter code_location_update : Set.

Parameter code_location_updates : Set.

Definition linkable_code := list global * code_location_updates.

Parameter clear_global_tbl : unit -&gt; unit.

Parameter empty_updates : code_location_updates.

Parameter register_native_file : string -&gt; unit.

Parameter compile_constant_field :
  Environ.env -&gt; string -&gt; Names.Constant.t -&gt; list global -&gt;
  Declarations.constant_body -&gt; list global.

Parameter compile_mind_field :
  Names.ModPath.t -&gt; Names.Label.t -&gt; list global -&gt;
  Declarations.mutual_inductive_body -&gt; list global.

Parameter mk_conv_code :
  Environ.env -&gt; Nativelambda.evars -&gt; string -&gt; Constr.constr -&gt;
  Constr.constr -&gt; linkable_code.

Parameter mk_norm_code :
  Environ.env -&gt; Nativelambda.evars -&gt; string -&gt; Constr.constr -&gt; linkable_code.

Parameter mk_library_header : Names.DirPath.t -&gt; list global.

Parameter mod_uid_of_dirpath : Names.DirPath.t -&gt; string.

Parameter link_info_of_dirpath : Names.DirPath.t -&gt; Environ.link_info.

Parameter update_locations : code_location_updates -&gt; unit.

Parameter add_header_comment : list global -&gt; string -&gt; list global.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativeconv.ml">
  <div style="margin: 20px;">
    <h3>Nativeconv</h3>
    <ul>
      <li>OCaml size: 175 lines</li>
      <li>Coq size: 287 lines (+64% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativeconv.ml"><code>nativeconv.ml</code></a>&nbsp;<span class="label label-warning">21 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Nativelib
open Reduction
open Util
open Nativevalues
open Nativecode
open Environ

(** This module implements the conversion test by compiling to OCaml code *)

let rec conv_val env pb lvl v1 v2 cu =
  if v1 == v2 then cu
  else
    match kind_of_value v1, kind_of_value v2 with
    | Vfun f1, Vfun f2 -&gt;
        let v = mk_rel_accu lvl in
        conv_val env CONV (lvl+1) (f1 v) (f2 v) cu
    | Vfun _f1, _ -&gt;
        conv_val env CONV lvl v1 (fun x -&gt; v2 x) cu
    | _, Vfun _f2 -&gt;
        conv_val env CONV lvl (fun x -&gt; v1 x) v2 cu
    | Vaccu k1, Vaccu k2 -&gt;
        conv_accu env pb lvl k1 k2 cu
    | Vconst i1, Vconst i2 -&gt;
        if Int.equal i1 i2 then cu else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Vint64 i1, Vint64 i2 -&gt;
      if Int64.equal i1 i2 then cu else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Vblock b1, Vblock b2 -&gt;
        let n1 = block_size b1 in
        let n2 = block_size b2 in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (Int.equal (block_tag b1) (block_tag b2)) || not (Int.equal n1 n2) then
          raise NotConvertible;
        let rec aux lvl max b1 b2 i cu =
          if Int.equal i max then
            conv_val env CONV lvl (block_field b1 i) (block_field b2 i) cu
          else
            let cu = conv_val env CONV lvl (block_field b1 i) (block_field b2 i) cu in
            aux lvl max b1 b2 (i+1) cu
        in
        aux lvl (n1-1) b1 b2 0 cu</abbr>
    | Vaccu _, _ | Vconst _, _ | Vint64 _, _ | Vblock _, _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

and conv_accu env pb lvl k1 k2 cu =
  let n1 = accu_nargs k1 in
  let n2 = accu_nargs k2 in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (Int.equal n1 n2) then raise NotConvertible;
  if Int.equal n1 0 then
    conv_atom env pb lvl (atom_of_accu k1) (atom_of_accu k2) cu
  else
    let cu = conv_atom env pb lvl (atom_of_accu k1) (atom_of_accu k2) cu in
    Array.fold_right2 (conv_val env CONV lvl) (args_of_accu k1) (args_of_accu k2) cu</abbr>

and conv_atom env pb lvl a1 a2 cu =
  if a1 == a2 then cu
  else
    match a1, a2 with
    | Ameta (m1,_), Ameta (m2,_) -&gt;
      if Int.equal m1 m2 then cu else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Aevar (ev1, args1), Aevar (ev2, args2) -&gt;
      if Evar.equal ev1 ev2 then
        Array.fold_right2 (conv_val env CONV lvl) args1 args2 cu
      else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Arel i1, Arel i2 -&gt;
        if Int.equal i1 i2 then cu else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Aind (ind1,u1), Aind (ind2,u2) -&gt;
       if eq_ind ind1 ind2 then convert_instances ~flex:false u1 u2 cu
       else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Aconstant (c1,u1), Aconstant (c2,u2) -&gt;
       if Constant.equal c1 c2 then convert_instances ~flex:true u1 u2 cu
       else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Asort s1, Asort s2 -&gt;
        sort_cmp_universes env pb s1 s2 cu
    | Avar id1, Avar id2 -&gt;
        if Id.equal id1 id2 then cu else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Acase(a1,ac1,p1,bs1), Acase(a2,ac2,p2,bs2) -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (eq_ind a1.asw_ind a2.asw_ind) then raise NotConvertible;
        let cu = conv_accu env CONV lvl ac1 ac2 cu in
        let tbl = a1.asw_reloc in
        let len = Array.length tbl in
        if Int.equal len 0 then conv_val env CONV lvl p1 p2 cu
        else begin
            let cu = conv_val env CONV lvl p1 p2 cu in
            let max = len - 1 in
            let rec aux i cu =
              let tag,arity = tbl.(i) in
              let ci =
                if Int.equal arity 0 then mk_const tag
                else mk_block tag (mk_rels_accu lvl arity) in
              let bi1 = bs1 ci and bi2 = bs2 ci in
              if Int.equal i max then conv_val env CONV (lvl + arity) bi1 bi2 cu
              else aux (i+1) (conv_val env CONV (lvl + arity) bi1 bi2 cu) in
            aux 0 cu
          end</abbr>
    | Afix(t1,f1,rp1,s1), Afix(t2,f2,rp2,s2) -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (Int.equal s1 s2) || not (Array.equal Int.equal rp1 rp2) then raise NotConvertible;
        if f1 == f2 then cu
        else conv_fix env lvl t1 f1 t2 f2 cu</abbr>
    | (Acofix(t1,f1,s1,_) | Acofixe(t1,f1,s1,_)),
      (Acofix(t2,f2,s2,_) | Acofixe(t2,f2,s2,_)) -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (Int.equal s1 s2) then raise NotConvertible;
        if f1 == f2 then cu
        else
          if not (Int.equal (Array.length f1) (Array.length f2)) then raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
          else conv_fix env lvl t1 f1 t2 f2 cu</abbr>
    | Aprod(_,d1,_c1), Aprod(_,d2,_c2) -&gt;
       let cu = conv_val env CONV lvl d1 d2 cu in
       let v = mk_rel_accu lvl in
       conv_val env pb (lvl + 1) (d1 v) (d2 v) cu
    | Aproj((ind1, i1), ac1), Aproj((ind2, i2), ac2) -&gt;
       if not (eq_ind ind1 ind2 &amp;&amp; Int.equal i1 i2) then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
       else conv_accu env CONV lvl ac1 ac2 cu
    | Arel _, _ | Aind _, _ | Aconstant _, _ | Asort _, _ | Avar _, _
    | Acase _, _ | Afix _, _ | Acofix _, _ | Acofixe _, _ | Aprod _, _
    | Aproj _, _ | Ameta _, _ | Aevar _, _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

(* Precondition length t1 = length f1 = length f2 = length t2 *)
and conv_fix env lvl t1 f1 t2 f2 cu =
  let len = Array.length f1 in
  let max = len - 1 in
  let fargs = mk_rels_accu lvl len in
  let flvl = lvl + len in
  let rec aux i cu =
    let cu = conv_val env CONV lvl t1.(i) t2.(i) cu in
    let fi1 = napply f1.(i) fargs in
    let fi2 = napply f2.(i) fargs in
    if Int.equal i max then conv_val env CONV flvl fi1 fi2 cu
    else aux (i+1) (conv_val env CONV flvl fi1 fi2 cu) in
  aux 0 cu

let warn_no_native_compiler =
  let open Pp in
  CWarnings.create ~name:&quot;native-compiler-disabled&quot; ~category:&quot;native-compiler&quot;
         (fun () -&gt; strbrk &quot;Native compiler is disabled,&quot; ++
                      strbrk &quot; falling back to VM conversion test.&quot;)

let native_conv_gen pb sigma env univs t1 t2 =
  if not (typing_flags env).Declarations.enable_native_compiler then <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
    warn_no_native_compiler ();
    Vconv.vm_conv_gen pb env univs t1 t2
  end</abbr>
  else
  let ml_filename, prefix = get_ml_filename () in
  let code, upds = mk_conv_code env sigma prefix t1 t2 in
  let fn = compile ml_filename code ~profile:false in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Running test...&quot;);
  let t0 = Sys.time () in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">call_linker ~fatal:true prefix fn (Some upds);
  let t1 = Sys.time () in
  let time_info = Format.sprintf &quot;Evaluation done in %.5f@.&quot; (t1 -. t0) in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !Flags.debug then Feedback.msg_debug (Pp.str time_info);
  (* TODO change 0 when we can have de Bruijn *)
  fst (conv_val env pb 0 !rt1 !rt2 univs)</abbr>

(* Wrapper for [native_conv] above *)
let native_conv cv_pb sigma env t1 t2 =
  let univs = Environ.universes env in
  let b =
    if cv_pb = CUMUL then Constr.leq_constr_univs univs t1 t2
    else Constr.eq_constr_univs univs t1 t2
  in
  if not b then
    let univs = (univs, checked_universes) in
    let t1 = Term.it_mkLambda_or_LetIn t1 (Environ.rel_context env) in
    let t2 = Term.it_mkLambda_or_LetIn t2 (Environ.rel_context env) in
    let _ = native_conv_gen cv_pb sigma env univs t1 t2 in ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativeconv.ml"><code>Nativeconv.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Nativelib.

Import Reduction.

Import Util.

Import Nativevalues.

Import Nativecode.

Import Environ.

Fixpoint conv_val {A : Set}
  (env : Environ.env) (pb : Reduction.conv_pb) (lvl : Z) (v1 : Nativevalues.t)
  (v2 : Nativevalues.t) (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  if Stdlib.op_eqeq v1 v2 then
    cu
  else
    match ((kind_of_value v1), (kind_of_value v2)) with
    | (Nativevalues.Vfun f1, Nativevalues.Vfun f2) =&gt;
      let v := mk_rel_accu lvl in
      conv_val env Reduction.CONV (Z.add lvl 1) (f1 v) (f2 v) cu
    | (Nativevalues.Vfun _f1, _) =&gt;
      conv_val env Reduction.CONV lvl v1 (fun x =&gt; v2 x) cu
    | (_, Nativevalues.Vfun _f2) =&gt;
      conv_val env Reduction.CONV lvl (fun x =&gt; v1 x) v2 cu
    | (Nativevalues.Vaccu k1, Nativevalues.Vaccu k2) =&gt;
      conv_accu env pb lvl k1 k2 cu
    | (Nativevalues.Vconst i1, Nativevalues.Vconst i2) =&gt;
      if Int.equal i1 i2 then
        cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Vint64 i1, Nativevalues.Vint64 i2) =&gt;
      if Int64.equal i1 i2 then
        cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Vblock b1, Nativevalues.Vblock b2) =&gt;
      let n1 := block_size b1 in
      let n2 := block_size b2 in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let fix aux
        (lvl : Z) (max : Int.t) (b1 : Nativevalues.block)
        (b2 : Nativevalues.block) (i : Int.t)
        (cu : A * Reduction.universe_compare A) {struct lvl}
        : A * Reduction.universe_compare A :=
        if Int.equal i max then
          conv_val env Reduction.CONV lvl (block_field b1 i) (block_field b2 i)
            cu
        else
          let cu :=
            conv_val env Reduction.CONV lvl (block_field b1 i)
              (block_field b2 i) cu in
          aux lvl max b1 b2 (Z.add i 1) cu in
      aux lvl (Z.sub n1 1) b1 b2 0 cu
    |
      (Nativevalues.Vaccu _, _) | (Nativevalues.Vconst _, _) |
      (Nativevalues.Vint64 _, _) | (Nativevalues.Vblock _, _) =&gt;
      Stdlib.raise extensible_type_value
    end

with conv_accu {A : Set}
  (env : Environ.env) (pb : Reduction.conv_pb) (lvl : Z)
  (k1 : Nativevalues.accumulator) (k2 : Nativevalues.accumulator)
  (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  let n1 := accu_nargs k1 in
  let n2 := accu_nargs k2 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  if Int.equal n1 0 then
    conv_atom env pb lvl (atom_of_accu k1) (atom_of_accu k2) cu
  else
    let cu := conv_atom env pb lvl (atom_of_accu k1) (atom_of_accu k2) cu in
    (|Util.Array|).(CArray.ExtS.fold_right2) (conv_val env Reduction.CONV lvl)
      (args_of_accu k1) (args_of_accu k2) cu

with conv_atom {A : Set}
  (env : Environ.env) (pb : Reduction.conv_pb) (lvl : Z)
  (a1 : Nativevalues.atom) (a2 : Nativevalues.atom)
  (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  if Stdlib.op_eqeq a1 a2 then
    cu
  else
    match (a1, a2) with
    | (Nativevalues.Ameta m1 _, Nativevalues.Ameta m2 _) =&gt;
      if Int.equal m1 m2 then
        cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Aevar ev1 args1, Nativevalues.Aevar ev2 args2) =&gt;
      if Evar.equal ev1 ev2 then
        (|Util.Array|).(CArray.ExtS.fold_right2)
          (conv_val env Reduction.CONV lvl) args1 args2 cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Arel i1, Nativevalues.Arel i2) =&gt;
      if Int.equal i1 i2 then
        cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Aind (ind1, u1), Nativevalues.Aind (ind2, u2)) =&gt;
      if eq_ind ind1 ind2 then
        convert_instances false u1 u2 cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Aconstant (c1, u1), Nativevalues.Aconstant (c2, u2)) =&gt;
      if Constant.equal c1 c2 then
        convert_instances true u1 u2 cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Asort s1, Nativevalues.Asort s2) =&gt;
      sort_cmp_universes env pb s1 s2 cu
    | (Nativevalues.Avar id1, Nativevalues.Avar id2) =&gt;
      if Id.equal id1 id2 then
        cu
      else
        Stdlib.raise extensible_type_value
    | (Nativevalues.Acase a1 ac1 p1 bs1, Nativevalues.Acase a2 ac2 p2 bs2) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let cu := conv_accu env Reduction.CONV lvl ac1 ac2 cu in
      let tbl := Nativevalues.annot_sw.asw_reloc a1 in
      let len := (|Util.Array|).(CArray.ExtS.length) tbl in
      if Int.equal len 0 then
        conv_val env Reduction.CONV lvl p1 p2 cu
      else
        let cu := conv_val env Reduction.CONV lvl p1 p2 cu in
        let max := Z.sub len 1 in
        let fix aux (i : Int.t) (cu : A * Reduction.universe_compare A)
          {struct i} : A * Reduction.universe_compare A :=
          let '(tag, arity) := (|Util.Array|).(CArray.ExtS.get) tbl i in
          let ci :=
            if Int.equal arity 0 then
              mk_const tag
            else
              mk_block tag (mk_rels_accu lvl arity) in
          let bi1 : Nativevalues.t :=
            bs1 ci
          with bi2 : Nativevalues.t :=
            bs2 ci in
          if Int.equal i max then
            conv_val env Reduction.CONV (Z.add lvl arity) bi1 bi2 cu
          else
            aux (Z.add i 1)
              (conv_val env Reduction.CONV (Z.add lvl arity) bi1 bi2 cu) in
        aux 0 cu
    | (Nativevalues.Afix t1 f1 rp1 s1, Nativevalues.Afix t2 f2 rp2 s2) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      if Stdlib.op_eqeq f1 f2 then
        cu
      else
        conv_fix env lvl t1 f1 t2 f2 cu
    |
      (Nativevalues.Acofix t1 f1 s1 _ | Nativevalues.Acofixe t1 f1 s1 _,
        Nativevalues.Acofix t2 f2 s2 _ | Nativevalues.Acofixe t2 f2 s2 _) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      if Stdlib.op_eqeq f1 f2 then
        cu
      else
        if
          negb
            (Int.equal ((|Util.Array|).(CArray.ExtS.length) f1)
              ((|Util.Array|).(CArray.ExtS.length) f2)) then
          Stdlib.raise extensible_type_value
        else
          conv_fix env lvl t1 f1 t2 f2 cu
    | (Nativevalues.Aprod _ d1 _c1, Nativevalues.Aprod _ d2 _c2) =&gt;
      let cu := conv_val env Reduction.CONV lvl d1 d2 cu in
      let v := mk_rel_accu lvl in
      conv_val env pb (Z.add lvl 1) (d1 v) (d2 v) cu
    | (Nativevalues.Aproj (ind1, i1) ac1, Nativevalues.Aproj (ind2, i2) ac2) =&gt;
      if negb (andb (eq_ind ind1 ind2) (Int.equal i1 i2)) then
        Stdlib.raise extensible_type_value
      else
        conv_accu env Reduction.CONV lvl ac1 ac2 cu
    |
      (Nativevalues.Arel _, _) | (Nativevalues.Aind _, _) |
      (Nativevalues.Aconstant _, _) | (Nativevalues.Asort _, _) |
      (Nativevalues.Avar _, _) | (Nativevalues.Acase _ _ _ _, _) |
      (Nativevalues.Afix _ _ _ _, _) | (Nativevalues.Acofix _ _ _ _, _) |
      (Nativevalues.Acofixe _ _ _ _, _) | (Nativevalues.Aprod _ _ _, _) |
      (Nativevalues.Aproj _ _, _) | (Nativevalues.Ameta _ _, _) |
      (Nativevalues.Aevar _ _, _) =&gt; Stdlib.raise extensible_type_value
    end

with conv_fix {A : Set}
  (env : Environ.env) (lvl : Z) (t1 : array Nativevalues.t)
  (f1 : array Nativevalues.t) (t2 : array Nativevalues.t)
  (f2 : array Nativevalues.t) (cu : A * Reduction.universe_compare A)
  {struct env} : A * Reduction.universe_compare A :=
  let len := (|Util.Array|).(CArray.ExtS.length) f1 in
  let max := Z.sub len 1 in
  let fargs := mk_rels_accu lvl len in
  let flvl := Z.add lvl len in
  let fix aux (i : Int.t) (cu : A * Reduction.universe_compare A) {struct i}
    : A * Reduction.universe_compare A :=
    let cu :=
      conv_val env Reduction.CONV lvl ((|Util.Array|).(CArray.ExtS.get) t1 i)
        ((|Util.Array|).(CArray.ExtS.get) t2 i) cu in
    let fi1 := napply ((|Util.Array|).(CArray.ExtS.get) f1 i) fargs in
    let fi2 := napply ((|Util.Array|).(CArray.ExtS.get) f2 i) fargs in
    if Int.equal i max then
      conv_val env Reduction.CONV flvl fi1 fi2 cu
    else
      aux (Z.add i 1) (conv_val env Reduction.CONV flvl fi1 fi2 cu) in
  aux 0 cu.

Definition warn_no_native_compiler : option Loc.t -&gt; unit -&gt; unit :=
  CWarnings.create &quot;native-compiler-disabled&quot; &quot;native-compiler&quot; None
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      op_plusplus (strbrk &quot;Native compiler is disabled,&quot;)
        (strbrk &quot; falling back to VM conversion test.&quot;)).

Definition native_conv_gen {A : Set}
  (pb : Reduction.conv_pb) (sigma : Nativelambda.evars) (env : Environ.env)
  (univs : Reduction.universe_state A) (t1 : Constr.types) (t2 : Constr.types)
  : A :=
  if negb (Declarations.typing_flags.enable_native_compiler (typing_flags env))
    then
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Vconv.vm_conv_gen pb env univs t1 t2
  else
    let '(ml_filename, prefix) := get_ml_filename tt in
    let '(code, upds) := mk_conv_code env sigma prefix t1 t2 in
    let fn := compile ml_filename code false in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let t0 := Sys.time tt in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let t1 := Sys.time tt in
    let time_info :=
      Format.sprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;Evaluation done in &quot;
            (CamlinternalFormatBasics.Float CamlinternalFormatBasics.Float_f
              CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Lit_precision 5)
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Flush_newline
                CamlinternalFormatBasics.End_of_format)))
          &quot;Evaluation done in %.5f@.&quot;) (Stdlib.op_minuspoint t1 t0) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    fst
      (conv_val env pb 0 (Stdlib.op_exclamation rt1) (Stdlib.op_exclamation rt2)
        univs).

Definition native_conv
  (cv_pb : Reduction.conv_pb) (sigma : Nativelambda.evars) (env : Environ.env)
  (t1 : Constr.constr) (t2 : Constr.constr) : unit :=
  let univs := Environ.universes env in
  let b :=
    if equiv_decb cv_pb Reduction.CUMUL then
      Constr.leq_constr_univs univs t1 t2
    else
      Constr.eq_constr_univs univs t1 t2 in
  if negb b then
    let univs := (univs, checked_universes) in
    let t1 := Term.it_mkLambda_or_LetIn t1 (Environ.rel_context env) in
    let t2 := Term.it_mkLambda_or_LetIn t2 (Environ.rel_context env) in
    let '_ := native_conv_gen cv_pb sigma env univs t1 t2 in
    tt
  else
    tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativeconv.mli">
  <div style="margin: 20px;">
    <h3>Nativeconv_mli</h3>
    <ul>
      <li>OCaml size: 20 lines</li>
      <li>Coq size: 18 lines (-10% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativeconv.mli"><code>nativeconv.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Constr
open Reduction
open Nativelambda

(** This module implements the conversion test by compiling to OCaml code *)

val native_conv : conv_pb -&gt; evars -&gt; types kernel_conversion_function

(** A conversion function parametrized by a universe comparator. Used outside of
    the kernel. *)
val native_conv_gen : conv_pb -&gt; evars -&gt; (types, 'a) generic_conversion_function
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativeconv.mli"><code>Nativeconv_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter native_conv :
  Reduction.conv_pb -&gt; Nativelambda.evars -&gt;
  Reduction.kernel_conversion_function Constr.types.

Parameter native_conv_gen : forall {a : Set},
  Reduction.conv_pb -&gt; Nativelambda.evars -&gt;
  Reduction.generic_conversion_function Constr.types a.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativelambda.ml">
  <div style="margin: 20px;">
    <h3>Nativelambda</h3>
    <ul>
      <li>OCaml size: 617 lines</li>
      <li>Coq size: 804 lines (+30% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativelambda.ml"><code>nativelambda.ml</code></a>&nbsp;<span class="label label-warning">26 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Util
open Names
open Esubst
open Constr
open Declarations
open Environ
open Nativevalues

module RelDecl = Context.Rel.Declaration

(** This file defines the lambda code generation phase of the native compiler *)
type prefix = string

type lambda =
  | Lrel          of Name.t * int
  | Lvar          of Id.t
  | Lmeta         of metavariable * lambda (* type *)
  | Levar         of Evar.t * lambda array (* arguments *)
  | Lprod         of lambda * lambda
  | Llam          of Name.t Context.binder_annot array * lambda
  | Lrec          of Name.t Context.binder_annot * lambda
  | Llet          of Name.t Context.binder_annot * lambda * lambda
  | Lapp          of lambda * lambda array
  | Lconst        of prefix * pconstant
  | Lproj         of prefix * inductive * int (* prefix, inductive, index starting from 0 *)
  | Lprim         of prefix * pconstant * CPrimitives.t * lambda array
        (* No check if None *)
  | Lcase         of annot_sw * lambda * lambda * lam_branches
                  (* annotations, term being matched, accu, branches *)
  | Lif           of lambda * lambda * lambda
  | Lfix          of (int array * (string * inductive) array * int) * fix_decl
  | Lcofix        of int * fix_decl
  | Lmakeblock    of prefix * pconstructor * int * lambda array
                  (* prefix, constructor Name.t, constructor tag, arguments *)
        (* A fully applied constructor *)
  | Lconstruct    of prefix * pconstructor (* prefix, constructor Name.t *)
        (* A partially applied constructor *)
  | Luint         of Uint63.t
  | Lval          of Nativevalues.t
  | Lsort         of Sorts.t
  | Lind          of prefix * pinductive
  | Llazy
  | Lforce

and lam_branches = (constructor * Name.t Context.binder_annot array * lambda) array

and fix_decl =  Name.t Context.binder_annot array * lambda array * lambda array

type evars =
    { evars_val : existential -&gt; constr option;
      evars_metas : metavariable -&gt; types }

(*s Constructors *)

let mkLapp f args =
  if Array.is_empty args then f
  else
    match f with
    | Lapp(f', args') -&gt; Lapp (f', Array.append args' args)
    | _ -&gt; Lapp(f, args)

let mkLlam ids body =
  if Array.is_empty ids then body
  else
    match body with
    | Llam(ids', body) -&gt; Llam(Array.append ids ids', body)
    | _ -&gt; Llam(ids, body)

let decompose_Llam lam =
  match lam with
  | Llam(ids,body) -&gt; ids, body
  | _ -&gt; <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>, lam

let rec decompose_Llam_Llet lam =
  match lam with
  | Llam(ids,body) -&gt;
      let vars, body = decompose_Llam_Llet body in
      Array.fold_right (fun x l -&gt; (x, None) :: l) ids vars, body
  | Llet(id,def,body) -&gt;
      let vars, body = decompose_Llam_Llet body in
      (id,Some def) :: vars, body
  | _ -&gt; [], lam

let decompose_Llam_Llet lam =
  let vars, body = decompose_Llam_Llet lam in
  Array.of_list vars, body

(*s Operators on substitution *)
let subst_id = subs_id 0
let lift = subs_lift
let liftn = subs_liftn
let cons v subst = subs_cons(<abbr class="mark-warning" title="Arrays not handled.">[|v|]</abbr>, subst)
let shift subst = subs_shft (1, subst)

(* Linked code location utilities *)
let get_mind_prefix env mind =
   let _,name = lookup_mind_key mind env in
   match !name with
   | NotLinked -&gt; &quot;&quot;
   | Linked s -&gt; s
   | LinkedInteractive s -&gt; s

let get_const_prefix env c =
   let _,(nameref,_) = lookup_constant_key c env in
   match !nameref with
   | NotLinked -&gt; &quot;&quot;
   | Linked s -&gt; s
   | LinkedInteractive s -&gt; s

(* A generic map function *)

let map_lam_with_binders g f n lam =
  match lam with
  | Lrel _ | Lvar _  | Lconst _ | Lproj _ | Lval _ | Lsort _ | Lind _ | Luint _
  | Lconstruct _ | Llazy | Lforce | Lmeta _ -&gt; lam
  | Lprod(dom,codom) -&gt;
      let dom' = f n dom in
      let codom' = f n codom in
      if dom == dom' &amp;&amp; codom == codom' then lam else Lprod(dom',codom')
  | Llam(ids,body) -&gt;
      let body' = f (g (Array.length ids) n) body in
      if body == body' then lam else mkLlam ids body'
  | Lrec(id,body) -&gt;
      let body' = f (g 1 n) body in
      if body == body' then lam else Lrec(id,body')
  | Llet(id,def,body) -&gt;
      let def' = f n def in
      let body' = f (g 1 n) body in
      if body == body' &amp;&amp; def == def' then lam else Llet(id,def',body')
  | Lapp(fct,args) -&gt;
      let fct' = f n fct in
      let args' = Array.Smart.map (f n) args in
      if fct == fct' &amp;&amp; args == args' then lam else mkLapp fct' args'
  | Lprim(prefix,kn,op,args) -&gt;
      let args' = Array.Smart.map (f n) args in
      if args == args' then lam else Lprim(prefix,kn,op,args')
  | Lcase(annot,t,a,br) -&gt;
      let t' = f n t in
      let a' = f n a in
      let on_b b =
        let (cn,ids,body) = b in
        let body' =
          if Array.is_empty ids then f n body
          else f (g (Array.length ids) n) body in
        if body == body' then b else (cn,ids,body') in
      let br' = Array.Smart.map on_b br in
      if t == t' &amp;&amp; a == a' &amp;&amp; br == br' then lam else Lcase(annot,t',a',br')
  | Lif(t,bt,bf) -&gt;
      let t' = f n t in
      let bt' = f n bt in
      let bf' = f n bf in
      if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam else Lif(t',bt',bf')
  | Lfix(init,(ids,ltypes,lbodies)) -&gt;
      let ltypes' = Array.Smart.map (f n) ltypes in
      let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
      if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
      else Lfix(init,(ids,ltypes',lbodies'))
  | Lcofix(init,(ids,ltypes,lbodies)) -&gt;
      let ltypes' = Array.Smart.map (f n) ltypes in
      let lbodies' = Array.Smart.map (f (g (Array.length ids) n)) lbodies in
      if ltypes == ltypes' &amp;&amp; lbodies == lbodies' then lam
      else Lcofix(init,(ids,ltypes',lbodies'))
  | Lmakeblock(prefix,cn,tag,args) -&gt;
      let args' = Array.Smart.map (f n) args in
      if args == args' then lam else Lmakeblock(prefix,cn,tag,args')
  | Levar (evk, args) -&gt;
    let args' = Array.Smart.map (f n) args in
    if args == args' then lam else Levar (evk, args')

(*s Lift and substitution *)

let rec lam_exlift el lam =
  match lam with
  | Lrel(id,i) -&gt;
      let i' = reloc_rel i el in
      if i == i' then lam else Lrel(id,i')
  | _ -&gt; map_lam_with_binders el_liftn lam_exlift el lam

let lam_lift k lam =
  if Int.equal k 0 then lam
  else lam_exlift (el_shft k el_id) lam

let lam_subst_rel lam id n subst =
  match expand_rel n subst with
  | Inl(k,v) -&gt; lam_lift k v
  | Inr(n',_) -&gt;
      if n == n' then lam
      else Lrel(id, n')

let rec lam_exsubst subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst
  | _ -&gt; map_lam_with_binders liftn lam_exsubst subst lam

let lam_subst_args subst args =
  if is_subs_id subst then args
  else Array.Smart.map (lam_exsubst subst) args

(** Simplification of lambda expression *)

(* [simplify subst lam] simplify the expression [lam_subst subst lam] *)
(* that is :                                                          *)
(* - Reduce [let] is the definition can be substituted i.e:           *)
(*    - a variable (rel or Id.t)                                *)
 (*    - a constant                                                    *)
(*    - a structured constant                                         *)
(*    - a function                                                    *)
(* - Transform beta redex into [let] expression                       *)
(* - Move arguments under [let]                                       *)
(* Invariant : Terms in [subst] are already simplified and can be     *)
(*             substituted                                            *)

let can_subst lam =
  match lam with
  | Lrel _ | Lvar _ | Lconst _ | Lproj _ | Lval _ | Lsort _ | Lind _ | Llam _
  | Lconstruct _ | Lmeta _ | Levar _ -&gt; true
  | _ -&gt; false

let can_merge_if bt bf =
  match bt, bf with
  | Llam(_idst,_), Llam(_idsf,_) -&gt; true
  | _ -&gt; false

let merge_if t bt bf =
  let (idst,bodyt) = decompose_Llam bt in
  let (idsf,bodyf) = decompose_Llam bf in
  let nt = Array.length idst in
  let nf = Array.length idsf in
  let common,idst,idsf =
    if Int.equal nt nf then idst, <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>, <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>
    else
      if nt &lt; nf then idst,<abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>, Array.sub idsf nt (nf - nt)
      else idsf, Array.sub idst nf (nt - nf), <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr> in
  Llam(common,
       Lif(lam_lift (Array.length common) t,
           mkLlam idst bodyt,
           mkLlam idsf bodyf))

let rec simplify subst lam =
  match lam with
  | Lrel(id,i) -&gt; lam_subst_rel lam id i subst

  | Llet(id,def,body) -&gt;
      let def' = simplify subst def in
      if can_subst def' then simplify (cons def' subst) body
      else
        let body' = simplify (lift subst) body in
        if def == def' &amp;&amp; body == body' then lam
        else Llet(id,def',body')

  | Lapp(f,args) -&gt;
      begin match simplify_app subst f subst args with
      | Lapp(f',args') when f == f' &amp;&amp; args == args' -&gt; lam
      | lam' -&gt; lam'
      end

  | Lif(t,bt,bf) -&gt;
      let t' = simplify subst t in
      let bt' = simplify subst bt in
      let bf' = simplify subst bf in
      if can_merge_if bt' bf' then merge_if t' bt' bf'
      else
        if t == t' &amp;&amp; bt == bt' &amp;&amp; bf == bf' then lam
        else Lif(t',bt',bf')
  | _ -&gt; map_lam_with_binders liftn simplify subst lam

and simplify_app substf f substa args =
  match f with
  | Lrel(id, i) -&gt;
      begin match lam_subst_rel f id i substf with
      | Llam(ids, body) -&gt;
          reduce_lapp
            subst_id (Array.to_list ids) body
            substa (Array.to_list args)
      | f' -&gt; mkLapp f' (simplify_args substa args)
      end
  | Llam(ids, body) -&gt;
      reduce_lapp substf (Array.to_list ids) body substa (Array.to_list args)
  | Llet(id, def, body) -&gt;
      let def' = simplify substf def in
      if can_subst def' then
        simplify_app (cons def' substf) body substa args
      else
        Llet(id, def', simplify_app (lift substf) body (shift substa) args)
  | Lapp(f, args') -&gt;
      let args = Array.append
          (lam_subst_args substf args') (lam_subst_args substa args) in
      simplify_app substf f subst_id args
  (* TODO | Lproj -&gt; simplify if the argument is known or a known global *)
  | _ -&gt; mkLapp (simplify substf f) (simplify_args substa args)

and simplify_args subst args = Array.Smart.map (simplify subst) args

and reduce_lapp substf lids body substa largs =
  match lids, largs with
  | id::lids, a::largs -&gt;
      let a = simplify substa a in
      if can_subst a then
        reduce_lapp (cons a substf) lids body substa largs
      else
        let body = reduce_lapp (lift substf) lids body (shift substa) largs in
        Llet(id, a, body)
  | [], [] -&gt; simplify substf body
  | _::_, _ -&gt;
      Llam(Array.of_list lids,  simplify (liftn (List.length lids) substf) body)
  | [], _::_ -&gt; simplify_app substf body substa (Array.of_list largs)

(*s Translation from [constr] to [lambda] *)

(* Translation of constructor *)

let is_value lc =
  match lc with
  | Lval _ -&gt; true
  | Lmakeblock(_,_,_,args) when Array.is_empty args -&gt; true
  | Luint _ -&gt; true
  | _ -&gt; false

let get_value lc =
  match lc with
  | Lval v -&gt; v
  | Lmakeblock(_,_,tag,args) when Array.is_empty args -&gt;
      Nativevalues.mk_int tag
  | Luint i -&gt; Nativevalues.mk_uint i
  | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>

let make_args start _end =
  Array.init (start - _end + 1) (fun i -&gt; Lrel (Anonymous, start - i))

(* Translation of constructors *)

let makeblock env cn u tag args =
  if Array.for_all is_value args &amp;&amp; Array.length args &gt; 0 then
    let args = Array.map get_value args in
    Lval (Nativevalues.mk_block tag args)
  else
    let prefix = get_mind_prefix env (fst (fst cn)) in
    Lmakeblock(prefix, (cn,u), tag, args)

(* Translation of constants *)

let rec get_alias env (kn, u as p) =
  let tps = (lookup_constant kn env).const_body_code in
    match tps with
    | None -&gt; p
    | Some tps -&gt;
       match Cemitcodes.force tps with
       | Cemitcodes.BCalias kn' -&gt; get_alias env (kn', u)
       | _ -&gt; p

let prim env kn p args =
  let prefix = get_const_prefix env (fst kn) in
  Lprim(prefix, kn, p, args)

let expand_prim env kn op arity =
  (* primitives are always Relevant *)
  let ids = Array.make arity Context.anonR in
  let args = make_args arity 1 in
  Llam(ids, prim env kn op args)

let lambda_of_prim env kn op args =
  let arity = CPrimitives.arity op in
  if Array.length args &gt;= arity then prim env kn op args
  else mkLapp (expand_prim env kn op arity) args

(*i Global environment *)

let get_names decl =
  let decl = Array.of_list decl in
  Array.map fst decl

let empty_args = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

module Cache =
  struct

    module ConstrHash =
    struct
      type t = constructor
      let equal = eq_constructor
      let hash = constructor_hash
    end

    module ConstrTable = Hashtbl.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ConstrHash</abbr>)

    type constructor_info = tag * int * int (* nparam nrealargs *)

    let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">get_construct_info</abbr> cache env c : constructor_info =
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">ConstrTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> cache c
      with Not_found -&gt;
        let ((mind,j), i) = c in
        let oib = lookup_mind mind env in
        let oip = oib.mind_packets.(j) in
        let tag,arity = oip.mind_reloc_tbl.(i-1) in
        let nparams = oib.mind_nparams in
        let r = (tag, nparams, arity) in
        ConstrTable.add cache c r;
        r</abbr>
  end

let is_lazy t =
  match Constr.kind t with
  | App _ | LetIn _ | Case _ | Proj _ -&gt; true
  | _ -&gt; false

let evar_value sigma ev = sigma.evars_val ev

let meta_type sigma mv = sigma.evars_metas mv

let empty_evars =
  { evars_val = (fun _ -&gt; None);
    evars_metas = (fun _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>) }

let empty_ids = <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>

(** Extract the inductive type over which a fixpoint is decreasing *)
let rec get_fix_struct env i t = match kind (Reduction.whd_all env t) with
| Prod (na, dom, t) -&gt;
  if Int.equal i 0 then
    let dom = Reduction.whd_all env dom in
    let (dom, _) = decompose_appvect dom in
    match kind dom with
    | Ind (ind, _) -&gt; ind
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  else
    let env = Environ.push_rel (RelDecl.LocalAssum (na, dom)) env in
    get_fix_struct env (i - 1) t
| _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let rec <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">lambda_of_constr</abbr> cache env sigma c =
  match kind c with
  | Meta mv -&gt;
     let ty = meta_type sigma mv in
     Lmeta (mv, lambda_of_constr cache env sigma ty)

  | Evar (evk,args as ev) -&gt;
     (match evar_value sigma ev with
     | None -&gt;
        let args = Array.map (lambda_of_constr cache env sigma) args in
        Levar(evk, args)
     | Some t -&gt; lambda_of_constr cache env sigma t)

  | Cast (c, _, _) -&gt; lambda_of_constr cache env sigma c

  | Rel i -&gt; Lrel (RelDecl.get_name (Environ.lookup_rel i env), i)

  | Var id -&gt; Lvar id

  | Sort s -&gt; Lsort s

  | Ind (ind,_u as pind) -&gt;
      let prefix = get_mind_prefix env (fst ind) in
      Lind (prefix, pind)

  | Prod(id, dom, codom) -&gt;
      let ld = lambda_of_constr cache env sigma dom in
      let env = Environ.push_rel (RelDecl.LocalAssum (id, dom)) env in
      let lc = lambda_of_constr cache env sigma codom in
      Lprod(ld,  Llam(<abbr class="mark-warning" title="Arrays not handled.">[|id|]</abbr>, lc))

  | Lambda _ -&gt;
      let params, body = Term.decompose_lam c in
      let fold (na, t) env = Environ.push_rel (RelDecl.LocalAssum (na, t)) env in
      let env = List.fold_right fold params env in
      let lb = lambda_of_constr cache env sigma body in
      let ids = get_names (List.rev params) in
      mkLlam ids lb

  | LetIn(id, def, t, body) -&gt;
      let ld = lambda_of_constr cache env sigma def in
      let env = Environ.push_rel (RelDecl.LocalDef (id, def, t)) env in
      let lb = lambda_of_constr cache env sigma body in
      Llet(id, ld, lb)

  | App(f, args) -&gt; lambda_of_app cache env sigma f args

  | Const _ -&gt; lambda_of_app cache env sigma c empty_args

  | Construct _ -&gt;  lambda_of_app cache env sigma c empty_args

  | Proj (p, c) -&gt;
    let ind = Projection.inductive p in
    let prefix = get_mind_prefix env (fst ind) in
    mkLapp (Lproj (prefix, ind, Projection.arg p)) <abbr class="mark-warning" title="Arrays not handled.">[|lambda_of_constr cache env sigma c|]</abbr>

  | Case(ci,t,a,branches) -&gt;
      let (mind,i as ind) = ci.ci_ind in
      let mib = lookup_mind mind env in
      let oib = mib.mind_packets.(i) in
      let tbl = oib.mind_reloc_tbl in
      (* Building info *)
      let prefix = get_mind_prefix env mind in
      let annot_sw =
            { asw_ind = ind;
          asw_ci = ci;
          asw_reloc = tbl;
          asw_finite = mib.mind_finite &lt;&gt; CoFinite;
          asw_prefix = prefix}
      in
      (* translation of the argument *)
      let la = lambda_of_constr cache env sigma a in
      (* translation of the type *)
      let lt = lambda_of_constr cache env sigma t in
      (* translation of branches *)
      let mk_branch i b =
        let cn = (ind,i+1) in
        let _, arity = tbl.(i) in
        let b = lambda_of_constr cache env sigma b in
        if Int.equal arity 0 then (cn, empty_ids, b)
        else
          match b with
          | Llam(ids, body) when Int.equal (Array.length ids) arity -&gt; (cn, ids, body)
          | _ -&gt;
              (** TODO relevance *)
              let anon = Context.make_annot Anonymous Sorts.Relevant in
              let ids = Array.make arity anon in
              let args = make_args arity 1 in
              let ll = lam_lift arity b in
              (cn, ids, mkLapp  ll args) in
      let bs = Array.mapi mk_branch branches in
      Lcase(annot_sw, lt, la, bs)

  | Fix((pos, i), (names,type_bodies,rec_bodies)) -&gt;
      let ltypes = lambda_of_args cache env sigma 0 type_bodies in
      let map i t =
        let ind = get_fix_struct env i t in
        let prefix = get_mind_prefix env (fst ind) in
        (prefix, ind)
      in
      let inds = Array.map2 map pos type_bodies in
      let env = Environ.push_rec_types (names, type_bodies, rec_bodies) env in
      let lbodies = lambda_of_args cache env sigma 0 rec_bodies in
      Lfix((pos, inds, i), (names, ltypes, lbodies))

  | CoFix(init,(names,type_bodies,rec_bodies)) -&gt;
      let rec_bodies = Array.map2 (Reduction.eta_expand env) rec_bodies type_bodies in
      let ltypes = lambda_of_args cache env sigma 0 type_bodies in
      let env = Environ.push_rec_types (names, type_bodies, rec_bodies) env in
      let lbodies = lambda_of_args cache env sigma 0 rec_bodies in
      Lcofix(init, (names, ltypes, lbodies))

  | Int i -&gt; Luint i

and <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">lambda_of_app</abbr> cache env sigma f args =
  match kind f with
  | Const (_kn,_u as c) -&gt;
      let kn,u = get_alias env c in
      let cb = lookup_constant kn env in
      begin match cb.const_body with
      | Primitive op -&gt; lambda_of_prim env c op (lambda_of_args cache env sigma 0 args)
      | Def csubst -&gt; (* TODO optimize if f is a proj and argument is known *)
          if cb.const_inline_code then
            lambda_of_app cache env sigma (Mod_subst.force_constr csubst) args
          else
          let prefix = get_const_prefix env kn in
          let t =
            if is_lazy (Mod_subst.force_constr csubst) then
              mkLapp Lforce <abbr class="mark-warning" title="Arrays not handled.">[|Lconst (prefix, (kn,u))|]</abbr>
            else Lconst (prefix, (kn,u))
          in
        mkLapp t (lambda_of_args cache env sigma 0 args)
      | OpaqueDef _ | Undef _ -&gt;
          let prefix = get_const_prefix env kn in
          mkLapp (Lconst (prefix, (kn,u))) (lambda_of_args cache env sigma 0 args)
      end
  | Construct (c,u) -&gt;
      let tag, nparams, arity = Cache.get_construct_info cache env c in
      let expected = nparams + arity in
      let nargs = Array.length args in
      let prefix = get_mind_prefix env (fst (fst c)) in
      if Int.equal nargs expected then
          let args = lambda_of_args cache env sigma nparams args in
          makeblock env c u tag args
      else
        let args = lambda_of_args cache env sigma 0 args in
            mkLapp (Lconstruct (prefix, (c,u))) args
  | _ -&gt;
      let f = lambda_of_constr cache env sigma f in
      let args = lambda_of_args cache env sigma 0 args in
      mkLapp f args

and <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">lambda_of_args</abbr> cache env sigma start args =
  let nargs = Array.length args in
  if start &lt; nargs then
    Array.init (nargs - start)
      (fun i -&gt; lambda_of_constr cache env sigma args.(start + i))
  else empty_args

let optimize lam =
  let lam = simplify subst_id lam in
(*  if Flags.vm_draw_opt () then
    (msgerrnl (str &quot;Simplify = \n&quot; ++ pp_lam lam);flush_all());
  let lam = remove_let subst_id lam in
  if Flags.vm_draw_opt () then
    (msgerrnl (str &quot;Remove let = \n&quot; ++ pp_lam lam);flush_all()); *)
  lam

let lambda_of_constr env sigma c =
  let cache = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Cache.ConstrTable.create</abbr> 91 in
  let lam = lambda_of_constr cache env sigma c in
(*  if Flags.vm_draw_opt () then begin
    (msgerrnl (str &quot;Constr = \n&quot; ++ pr_constr c);flush_all());
    (msgerrnl (str &quot;Lambda = \n&quot; ++ pp_lam lam);flush_all());
  end; *)
  optimize lam

let mk_lazy c =
  mkLapp Llazy <abbr class="mark-warning" title="Arrays not handled.">[|c|]</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativelambda.ml"><code>Nativelambda.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Esubst.

Import Constr.

Import Declarations.

Import Environ.

Import Nativevalues.

Module RelDecl := Context.Rel.Declaration.

Definition prefix := string.

Reserved Notation &quot;'lam_branches&quot;.
Reserved Notation &quot;'fix_decl&quot;.

Inductive lambda : Set :=
| Lrel : Names.Name.t -&gt; Z -&gt; lambda
| Lvar : Names.Id.t -&gt; lambda
| Lmeta : Constr.metavariable -&gt; lambda -&gt; lambda
| Levar : Evar.t -&gt; array lambda -&gt; lambda
| Lprod : lambda -&gt; lambda -&gt; lambda
| Llam : array (Context.binder_annot Names.Name.t) -&gt; lambda -&gt; lambda
| Lrec : Context.binder_annot Names.Name.t -&gt; lambda -&gt; lambda
| Llet : Context.binder_annot Names.Name.t -&gt; lambda -&gt; lambda -&gt; lambda
| Lapp : lambda -&gt; array lambda -&gt; lambda
| Lconst : prefix -&gt; Constr.pconstant -&gt; lambda
| Lproj : prefix -&gt; Names.inductive -&gt; Z -&gt; lambda
| Lprim : prefix -&gt; Constr.pconstant -&gt; CPrimitives.t -&gt; array lambda -&gt; lambda
| Lcase : Nativevalues.annot_sw -&gt; lambda -&gt; lambda -&gt; 'lam_branches -&gt; lambda
| Lif : lambda -&gt; lambda -&gt; lambda -&gt; lambda
| Lfix : array Z * array (string * Names.inductive) * Z -&gt; 'fix_decl -&gt; lambda
| Lcofix : Z -&gt; 'fix_decl -&gt; lambda
| Lmakeblock : prefix -&gt; Constr.pconstructor -&gt; Z -&gt; array lambda -&gt; lambda
| Lconstruct : prefix -&gt; Constr.pconstructor -&gt; lambda
| Luint : Uint63.t -&gt; lambda
| Lval : Nativevalues.t -&gt; lambda
| Lsort : Sorts.t -&gt; lambda
| Lind : prefix -&gt; Constr.pinductive -&gt; lambda
| Llazy : lambda
| Lforce : lambda

where &quot;'lam_branches&quot; :=
  (array
    (Names.constructor * array (Context.binder_annot Names.Name.t) * lambda))
and &quot;'fix_decl&quot; :=
  (array (Context.binder_annot Names.Name.t) * array lambda * array lambda).

Definition lam_branches := 'lam_branches.
Definition fix_decl := 'fix_decl.

Module evars.
  Record record := {
    evars_val : Constr.existential -&gt; option Constr.constr;
    evars_metas : Constr.metavariable -&gt; Constr.types }.
  Definition with_evars_val (r : record) evars_val : record :=
    {| evars_val := evars_val; evars_metas := evars_metas r |}.
  Definition with_evars_metas (r : record) evars_metas : record :=
    {| evars_val := evars_val r; evars_metas := evars_metas |}.
End evars.
Definition evars := evars.record.

Definition mkLapp (f : lambda) (args : array lambda) : lambda :=
  if (|Util.Array|).(CArray.ExtS.is_empty) args then
    f
  else
    match f with
    | Lapp f' args' =&gt; Lapp f' ((|Util.Array|).(CArray.ExtS.append) args' args)
    | _ =&gt; Lapp f args
    end.

Definition mkLlam
  (ids : array (Context.binder_annot Names.Name.t)) (body : lambda) : lambda :=
  if (|Util.Array|).(CArray.ExtS.is_empty) ids then
    body
  else
    match body with
    | Llam ids' body =&gt; Llam ((|Util.Array|).(CArray.ExtS.append) ids ids') body
    | _ =&gt; Llam ids body
    end.

Definition decompose_Llam (lam : lambda)
  : array (Context.binder_annot Names.Name.t) * lambda :=
  match lam with
  | Llam ids body =&gt; (ids, body)
  | _ =&gt;
    ((* ❌ Arrays not handled. *)
    [ ], lam)
  end.

Fixpoint decompose_Llam_Llet (lam : lambda) {struct lam}
  : list (Context.binder_annot Names.Name.t * option lambda) * lambda :=
  match lam with
  | Llam ids body =&gt;
    let '(vars, body) := decompose_Llam_Llet body in
    (((|Util.Array|).(CArray.ExtS.fold_right)
      (fun x =&gt; fun l =&gt; cons (x, None) l) ids vars), body)
  | Llet id def body =&gt;
    let '(vars, body) := decompose_Llam_Llet body in
    ((cons (id, (Some def)) vars), body)
  | _ =&gt; ([], lam)
  end.

Definition decompose_Llam_Llet (lam : lambda)
  : array (Context.binder_annot Names.Name.t * option lambda) * lambda :=
  let '(vars, body) := decompose_Llam_Llet lam in
  (((|Util.Array|).(CArray.ExtS.of_list) vars), body).

Definition subst_id : Esubst.subs lambda := subs_id 0.

Definition lift {A : Set} : Esubst.subs A -&gt; Esubst.subs A := subs_lift.

Definition liftn {A : Set} : Z -&gt; Esubst.subs A -&gt; Esubst.subs A := subs_liftn.

Definition cons {A : Set} (v : A) (subst : Esubst.subs A) : Esubst.subs A :=
  subs_cons
    ((* ❌ Arrays not handled. *)
    [ v ], subst).

Definition shift {A : Set} (subst : Esubst.subs A) : Esubst.subs A :=
  subs_shft (1, subst).

Definition get_mind_prefix (env : Environ.env) (mind : Names.MutInd.t)
  : string :=
  let '(_, name) := lookup_mind_key mind env in
  match Stdlib.op_exclamation name with
  | Environ.NotLinked =&gt; &quot;&quot;
  | Environ.Linked s =&gt; s
  | Environ.LinkedInteractive s =&gt; s
  end.

Definition get_const_prefix (env : Environ.env) (c : Names.Constant.t)
  : string :=
  let '(_, (nameref, _)) := lookup_constant_key c env in
  match Stdlib.op_exclamation nameref with
  | Environ.NotLinked =&gt; &quot;&quot;
  | Environ.Linked s =&gt; s
  | Environ.LinkedInteractive s =&gt; s
  end.

Definition map_lam_with_binders {A : Set}
  (g : Z -&gt; A -&gt; A) (f : A -&gt; lambda -&gt; lambda) (n : A) (lam : lambda)
  : lambda :=
  match lam with
  |
    Lrel _ _ | Lvar _ | Lconst _ _ | Lproj _ _ _ | Lval _ | Lsort _ | Lind _ _ |
    Luint _ | Lconstruct _ _ | Llazy | Lforce | Lmeta _ _ =&gt; lam
  | Lprod dom codom =&gt;
    let dom' := f n dom in
    let codom' := f n codom in
    if andb (Stdlib.op_eqeq dom dom') (Stdlib.op_eqeq codom codom') then
      lam
    else
      Lprod dom' codom'
  | Llam ids body =&gt;
    let body' := f (g ((|Util.Array|).(CArray.ExtS.length) ids) n) body in
    if Stdlib.op_eqeq body body' then
      lam
    else
      mkLlam ids body'
  | Lrec id body =&gt;
    let body' := f (g 1 n) body in
    if Stdlib.op_eqeq body body' then
      lam
    else
      Lrec id body'
  | Llet id def body =&gt;
    let def' := f n def in
    let body' := f (g 1 n) body in
    if andb (Stdlib.op_eqeq body body') (Stdlib.op_eqeq def def') then
      lam
    else
      Llet id def' body'
  | Lapp fct args =&gt;
    let fct' := f n fct in
    let args' := Array.Smart.map (f n) args in
    if andb (Stdlib.op_eqeq fct fct') (Stdlib.op_eqeq args args') then
      lam
    else
      mkLapp fct' args'
  | Lprim prefix kn op args =&gt;
    let args' := Array.Smart.map (f n) args in
    if Stdlib.op_eqeq args args' then
      lam
    else
      Lprim prefix kn op args'
  | Lcase annot t a br =&gt;
    let t' := f n t in
    let a' := f n a in
    let on_b {B C : Set} (b : B * array C * lambda) : B * array C * lambda :=
      let '(cn, ids, body) := b in
      let body' :=
        if (|Util.Array|).(CArray.ExtS.is_empty) ids then
          f n body
        else
          f (g ((|Util.Array|).(CArray.ExtS.length) ids) n) body in
      if Stdlib.op_eqeq body body' then
        b
      else
        (cn, ids, body') in
    let br' := Array.Smart.map on_b br in
    if
      andb (Stdlib.op_eqeq t t')
        (andb (Stdlib.op_eqeq a a') (Stdlib.op_eqeq br br')) then
      lam
    else
      Lcase annot t' a' br'
  | Lif t bt bf =&gt;
    let t' := f n t in
    let bt' := f n bt in
    let bf' := f n bf in
    if
      andb (Stdlib.op_eqeq t t')
        (andb (Stdlib.op_eqeq bt bt') (Stdlib.op_eqeq bf bf')) then
      lam
    else
      Lif t' bt' bf'
  | Lfix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Array.Smart.map (f (g ((|Util.Array|).(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eqeq ltypes ltypes') (Stdlib.op_eqeq lbodies lbodies')
      then
      lam
    else
      Lfix init (ids, ltypes', lbodies')
  | Lcofix init (ids, ltypes, lbodies) =&gt;
    let ltypes' := Array.Smart.map (f n) ltypes in
    let lbodies' :=
      Array.Smart.map (f (g ((|Util.Array|).(CArray.ExtS.length) ids) n))
        lbodies in
    if andb (Stdlib.op_eqeq ltypes ltypes') (Stdlib.op_eqeq lbodies lbodies')
      then
      lam
    else
      Lcofix init (ids, ltypes', lbodies')
  | Lmakeblock prefix cn tag args =&gt;
    let args' := Array.Smart.map (f n) args in
    if Stdlib.op_eqeq args args' then
      lam
    else
      Lmakeblock prefix cn tag args'
  | Levar evk args =&gt;
    let args' := Array.Smart.map (f n) args in
    if Stdlib.op_eqeq args args' then
      lam
    else
      Levar evk args'
  end.

Fixpoint lam_exlift (el : Esubst.lift) (lam : lambda) {struct el} : lambda :=
  match lam with
  | Lrel id i =&gt;
    let i' := reloc_rel i el in
    if Stdlib.op_eqeq i i' then
      lam
    else
      Lrel id i'
  | _ =&gt; map_lam_with_binders el_liftn lam_exlift el lam
  end.

Definition lam_lift (k : Int.t) (lam : lambda) : lambda :=
  if Int.equal k 0 then
    lam
  else
    lam_exlift (el_shft k el_id) lam.

Definition lam_subst_rel
  (lam : lambda) (id : Names.Name.t) (n : Z) (subst : Esubst.subs lambda)
  : lambda :=
  match expand_rel n subst with
  | Util.Inl (k, v) =&gt; lam_lift k v
  | Util.Inr (n', _) =&gt;
    if Stdlib.op_eqeq n n' then
      lam
    else
      Lrel id n'
  end.

Fixpoint lam_exsubst (subst : Esubst.subs lambda) (lam : lambda) {struct subst}
  : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | _ =&gt; map_lam_with_binders liftn lam_exsubst subst lam
  end.

Definition lam_subst_args (subst : Esubst.subs lambda) (args : array lambda)
  : array lambda :=
  if is_subs_id subst then
    args
  else
    Array.Smart.map (lam_exsubst subst) args.

Definition can_subst (lam : lambda) : bool :=
  match lam with
  |
    Lrel _ _ | Lvar _ | Lconst _ _ | Lproj _ _ _ | Lval _ | Lsort _ | Lind _ _ |
    Llam _ _ | Lconstruct _ _ | Lmeta _ _ | Levar _ _ =&gt; true
  | _ =&gt; false
  end.

Definition can_merge_if (bt : lambda) (bf : lambda) : bool :=
  match (bt, bf) with
  | (Llam _idst _, Llam _idsf _) =&gt; true
  | _ =&gt; false
  end.

Definition merge_if (t : lambda) (bt : lambda) (bf : lambda) : lambda :=
  let '(idst, bodyt) := decompose_Llam bt in
  let '(idsf, bodyf) := decompose_Llam bf in
  let nt := (|Util.Array|).(CArray.ExtS.length) idst in
  let nf := (|Util.Array|).(CArray.ExtS.length) idsf in
  let '(common, idst, idsf) :=
    if Int.equal nt nf then
      (idst,
        (* ❌ Arrays not handled. *)
        [ ],
        (* ❌ Arrays not handled. *)
        [ ])
    else
      if OCaml.Stdlib.lt nt nf then
        (idst,
          (* ❌ Arrays not handled. *)
          [ ], ((|Util.Array|).(CArray.ExtS.sub) idsf nt (Z.sub nf nt)))
      else
        (idsf, ((|Util.Array|).(CArray.ExtS.sub) idst nf (Z.sub nt nf)),
          (* ❌ Arrays not handled. *)
          [ ]) in
  Llam common
    (Lif (lam_lift ((|Util.Array|).(CArray.ExtS.length) common) t)
      (mkLlam idst bodyt) (mkLlam idsf bodyf)).

Fixpoint simplify (subst : Esubst.subs lambda) (lam : lambda) {struct subst}
  : lambda :=
  match lam with
  | Lrel id i =&gt; lam_subst_rel lam id i subst
  | Llet id def body =&gt;
    let def' := simplify subst def in
    if can_subst def' then
      simplify (cons def' subst) body
    else
      let body' := simplify (lift subst) body in
      if andb (Stdlib.op_eqeq def def') (Stdlib.op_eqeq body body') then
        lam
      else
        Llet id def' body'
  | Lapp f args =&gt;
    match
      ((simplify_app subst f subst args),
        match simplify_app subst f subst args with
        | Lapp f' args' =&gt;
          andb (Stdlib.op_eqeq f f') (Stdlib.op_eqeq args args')
        | _ =&gt; false
        end) with
    | (Lapp f' args', true) =&gt; lam
    | (lam', _) =&gt; lam'
    end
  | Lif t bt bf =&gt;
    let t' := simplify subst t in
    let bt' := simplify subst bt in
    let bf' := simplify subst bf in
    if can_merge_if bt' bf' then
      merge_if t' bt' bf'
    else
      if
        andb (Stdlib.op_eqeq t t')
          (andb (Stdlib.op_eqeq bt bt') (Stdlib.op_eqeq bf bf')) then
        lam
      else
        Lif t' bt' bf'
  | _ =&gt; map_lam_with_binders liftn simplify subst lam
  end

with simplify_app
  (substf : Esubst.subs lambda) (f : lambda) (substa : Esubst.subs lambda)
  (args : array lambda) {struct substf} : lambda :=
  match f with
  | Lrel id i =&gt;
    match lam_subst_rel f id i substf with
    | Llam ids body =&gt;
      reduce_lapp subst_id ((|Util.Array|).(CArray.ExtS.to_list) ids) body
        substa ((|Util.Array|).(CArray.ExtS.to_list) args)
    | f' =&gt; mkLapp f' (simplify_args substa args)
    end
  | Llam ids body =&gt;
    reduce_lapp substf ((|Util.Array|).(CArray.ExtS.to_list) ids) body substa
      ((|Util.Array|).(CArray.ExtS.to_list) args)
  | Llet id def body =&gt;
    let def' := simplify substf def in
    if can_subst def' then
      simplify_app (cons def' substf) body substa args
    else
      Llet id def' (simplify_app (lift substf) body (shift substa) args)
  | Lapp f args' =&gt;
    let args :=
      (|Util.Array|).(CArray.ExtS.append) (lam_subst_args substf args')
        (lam_subst_args substa args) in
    simplify_app substf f subst_id args
  | _ =&gt; mkLapp (simplify substf f) (simplify_args substa args)
  end

with simplify_args (subst : Esubst.subs lambda) (args : array lambda)
  {struct subst} : array lambda := Array.Smart.map (simplify subst) args

with reduce_lapp
  (substf : Esubst.subs lambda)
  (lids : list (Context.binder_annot Names.Name.t)) (body : lambda)
  (substa : Esubst.subs lambda) (largs : list lambda) {struct substf}
  : lambda :=
  match (lids, largs) with
  | (cons id lids, cons a largs) =&gt;
    let a := simplify substa a in
    if can_subst a then
      reduce_lapp (cons a substf) lids body substa largs
    else
      let body := reduce_lapp (lift substf) lids body (shift substa) largs in
      Llet id a body
  | ([], []) =&gt; simplify substf body
  | (cons _ _, _) =&gt;
    Llam ((|Util.Array|).(CArray.ExtS.of_list) lids)
      (simplify (liftn ((|Util.List|).(CList.ExtS.length) lids) substf) body)
  | ([], cons _ _) =&gt;
    simplify_app substf body substa ((|Util.Array|).(CArray.ExtS.of_list) largs)
  end.

Definition is_value (lc : lambda) : bool :=
  match
    (lc,
      match lc with
      | Lmakeblock _ _ _ args =&gt; (|Util.Array|).(CArray.ExtS.is_empty) args
      | _ =&gt; false
      end) with
  | (Lval _, _) =&gt; true
  | (Lmakeblock _ _ _ args, true) =&gt; true
  | (Luint _, _) =&gt; true
  | (_, _) =&gt; false
  end.

Definition get_value (lc : lambda) : Nativevalues.t :=
  match
    (lc,
      match lc with
      | Lmakeblock _ _ tag args =&gt; (|Util.Array|).(CArray.ExtS.is_empty) args
      | _ =&gt; false
      end) with
  | (Lval v, _) =&gt; v
  | (Lmakeblock _ _ tag args, true) =&gt; Nativevalues.mk_int tag
  | (Luint i, _) =&gt; Nativevalues.mk_uint i
  | (_, _) =&gt; Stdlib.raise extensible_type_value
  end.

Definition make_args (start : Z) (_end : Z) : array lambda :=
  (|Util.Array|).(CArray.ExtS.init) (Z.add (Z.sub start _end) 1)
    (fun i =&gt; Lrel Names.Anonymous (Z.sub start i)).

Definition makeblock
  (env : Environ.env) (cn : Names.constructor) (u : Univ.Instance.t)
  (tag : Nativevalues.tag) (args : array lambda) : lambda :=
  if
    andb ((|Util.Array|).(CArray.ExtS.for_all) is_value args)
      (OCaml.Stdlib.gt ((|Util.Array|).(CArray.ExtS.length) args) 0) then
    let args := (|Util.Array|).(CArray.ExtS.map) get_value args in
    Lval (Nativevalues.mk_block tag args)
  else
    let prefix := get_mind_prefix env (fst (fst cn)) in
    Lmakeblock prefix (cn, u) tag args.

Fixpoint get_alias {A : Set}
  (env : Environ.env) (function_parameter : Names.Constant.t * A) {struct env}
  : Names.Constant.t * A :=
  let '(kn, u) as p := function_parameter in
  let tps := Declarations.constant_body.const_body_code (lookup_constant kn env)
    in
  match tps with
  | None =&gt; p
  | Some tps =&gt;
    match Cemitcodes.force tps with
    | Cemitcodes.BCalias kn' =&gt; get_alias env (kn', u)
    | _ =&gt; p
    end
  end.

Definition prim
  (env : Environ.env) (kn : Constr.pconstant) (p : CPrimitives.t)
  (args : array lambda) : lambda :=
  let prefix := get_const_prefix env (fst kn) in
  Lprim prefix kn p args.

Definition expand_prim
  (env : Environ.env) (kn : Constr.pconstant) (op : CPrimitives.t) (arity : Z)
  : lambda :=
  let ids := (|Util.Array|).(CArray.ExtS.make) arity Context.anonR in
  let args := make_args arity 1 in
  Llam ids (prim env kn op args).

Definition lambda_of_prim
  (env : Environ.env) (kn : Constr.pconstant) (op : CPrimitives.t)
  (args : array lambda) : lambda :=
  let arity := CPrimitives.arity op in
  if OCaml.Stdlib.ge ((|Util.Array|).(CArray.ExtS.length) args) arity then
    prim env kn op args
  else
    mkLapp (expand_prim env kn op arity) args.

Definition get_names {A B : Set} (decl : list (A * B)) : array A :=
  let decl := (|Util.Array|).(CArray.ExtS.of_list) decl in
  (|Util.Array|).(CArray.ExtS.map) fst decl.

Definition empty_args {A : Set} : array A :=
  (* ❌ Arrays not handled. *)
  [ ].

Module Cache.
  Module ConstrHash.
    Definition t := Names.constructor.
    
    Definition equal : Names.constructor -&gt; Names.constructor -&gt; bool :=
      eq_constructor.
    
    Definition hash : Names.constructor -&gt; Z := constructor_hash.
  End ConstrHash.
  
  Definition ConstrTable :=
    Hashtbl.Make
      (existT _ _
        {|
          Stdlib__hashtbl.HashedType.equal :=
            (|ConstrHash|).(Stdlib__hashtbl.HashedType.equal);
          Stdlib__hashtbl.HashedType.hash :=
            (|ConstrHash|).(Stdlib__hashtbl.HashedType.hash)
        |}).
  
  Definition constructor_info := Nativevalues.tag * Z * Z.
  
  Definition get_construct_info
    (cache : (|ConstrTable|).(Stdlib__hashtbl.S.t) constructor_info)
    (env : Environ.env) (c : (|ConstrTable|).(Stdlib__hashtbl.S.key))
    : constructor_info :=
    (* ❌ Try-with are not handled *)
    try ((|ConstrTable|).(Stdlib__hashtbl.S.find) cache c).
End Cache.

Definition is_lazy (t : Constr.constr) : bool :=
  match Constr.kind t with
  |
    Constr.App _ _ | Constr.LetIn _ _ _ _ | Constr.Case _ _ _ _ |
    Constr.Proj _ _ =&gt; true
  | _ =&gt; false
  end.

Definition evar_value (sigma : evars) (ev : Constr.existential)
  : option Constr.constr := (evars.evars_val sigma) ev.

Definition meta_type (sigma : evars) (mv : Constr.metavariable)
  : Constr.types := (evars.evars_metas sigma) mv.

Definition empty_evars : evars :=
  {|
    evars.evars_val :=
      fun function_parameter =&gt;
        let '_ := function_parameter in
        None;
    evars.evars_metas :=
      fun function_parameter =&gt;
        let '_ := function_parameter in
        (* ❌ Assert instruction is not handled. *)
        assert false |}.

Definition empty_ids {A : Set} : array A :=
  (* ❌ Arrays not handled. *)
  [ ].

Fixpoint get_fix_struct (env : Environ.env) (i : Int.t) (t : Constr.constr)
  {struct env} : Names.inductive :=
  match kind (Reduction.whd_all env t) with
  | Constr.Prod na dom t =&gt;
    if Int.equal i 0 then
      let dom := Reduction.whd_all env dom in
      let '(dom, _) := decompose_appvect dom in
      match kind dom with
      | Constr.Ind (ind, _) =&gt; ind
      | _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end
    else
      let env := Environ.push_rel (RelDecl.LocalAssum na dom) env in
      get_fix_struct env (Z.sub i 1) t
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Fixpoint lambda_of_constr
  (cache : (|Cache.ConstrTable|).(Stdlib__hashtbl.S.t) Cache.constructor_info)
  (env : Environ.env) (sigma : evars) (c : Constr.constr) {struct cache}
  : lambda :=
  match kind c with
  | Constr.Meta mv =&gt;
    let ty := meta_type sigma mv in
    Lmeta mv (lambda_of_constr cache env sigma ty)
  | Constr.Evar ((evk, args) as ev) =&gt;
    match evar_value sigma ev with
    | None =&gt;
      let args :=
        (|Util.Array|).(CArray.ExtS.map) (lambda_of_constr cache env sigma) args
        in
      Levar evk args
    | Some t =&gt; lambda_of_constr cache env sigma t
    end
  | Constr.Cast c _ _ =&gt; lambda_of_constr cache env sigma c
  | Constr.Rel i =&gt; Lrel (RelDecl.get_name (Environ.lookup_rel i env)) i
  | Constr.Var id =&gt; Lvar id
  | Constr.Sort s =&gt; Lsort s
  | Constr.Ind ((ind, _u) as pind) =&gt;
    let prefix := get_mind_prefix env (fst ind) in
    Lind prefix pind
  | Constr.Prod id dom codom =&gt;
    let ld := lambda_of_constr cache env sigma dom in
    let env := Environ.push_rel (RelDecl.LocalAssum id dom) env in
    let lc := lambda_of_constr cache env sigma codom in
    Lprod ld
      (Llam
        (* ❌ Arrays not handled. *)
        [ id ] lc)
  | Constr.Lambda _ _ _ =&gt;
    let '(params, body) := Term.decompose_lam c in
    let fold
      (function_parameter : Context.binder_annot Names.Name.t * Constr.types)
      : Environ.env -&gt; Environ.env :=
      let '(na, t) := function_parameter in
      fun env =&gt; Environ.push_rel (RelDecl.LocalAssum na t) env in
    let env := (|Util.List|).(CList.ExtS.fold_right) fold params env in
    let lb := lambda_of_constr cache env sigma body in
    let ids := get_names ((|Util.List|).(CList.ExtS.rev) params) in
    mkLlam ids lb
  | Constr.LetIn id def t body =&gt;
    let ld := lambda_of_constr cache env sigma def in
    let env := Environ.push_rel (RelDecl.LocalDef id def t) env in
    let lb := lambda_of_constr cache env sigma body in
    Llet id ld lb
  | Constr.App f args =&gt; lambda_of_app cache env sigma f args
  | Constr.Const _ =&gt; lambda_of_app cache env sigma c empty_args
  | Constr.Construct _ =&gt; lambda_of_app cache env sigma c empty_args
  | Constr.Proj p c =&gt;
    let ind := Projection.inductive p in
    let prefix := get_mind_prefix env (fst ind) in
    mkLapp (Lproj prefix ind (Projection.arg p))
      (* ❌ Arrays not handled. *)
      [ lambda_of_constr cache env sigma c ]
  | Constr.Case ci t a branches =&gt;
    let '(mind, i) as ind := Constr.case_info.ci_ind ci in
    let mib := lookup_mind mind env in
    let oib :=
      (|Util.Array|).(CArray.ExtS.get)
        (Declarations.mutual_inductive_body.mind_packets mib) i in
    let tbl := Declarations.one_inductive_body.mind_reloc_tbl oib in
    let prefix := get_mind_prefix env mind in
    let annot_sw :=
      {| Nativevalues.annot_sw.asw_ind := ind;
        Nativevalues.annot_sw.asw_ci := ci;
        Nativevalues.annot_sw.asw_reloc := tbl;
        Nativevalues.annot_sw.asw_finite :=
          nequiv_decb (Declarations.mutual_inductive_body.mind_finite mib)
            Declarations.CoFinite; Nativevalues.annot_sw.asw_prefix := prefix |}
      in
    let la := lambda_of_constr cache env sigma a in
    let lt := lambda_of_constr cache env sigma t in
    let mk_branch (i : Z) (b : Constr.constr)
      : ((Names.MutInd.t * Z) * Z) * array (Context.binder_annot Names.name) *
        lambda :=
      let cn := (ind, (Z.add i 1)) in
      let '(_, arity) := (|Util.Array|).(CArray.ExtS.get) tbl i in
      let b := lambda_of_constr cache env sigma b in
      if Int.equal arity 0 then
        (cn, empty_ids, b)
      else
        match
          (b,
            match b with
            | Llam ids body =&gt;
              Int.equal ((|Util.Array|).(CArray.ExtS.length) ids) arity
            | _ =&gt; false
            end) with
        | (Llam ids body, true) =&gt; (cn, ids, body)
        | (_, _) =&gt;
          let anon := Context.make_annot Names.Anonymous Sorts.Relevant in
          let ids := (|Util.Array|).(CArray.ExtS.make) arity anon in
          let args := make_args arity 1 in
          let ll := lam_lift arity b in
          (cn, ids, (mkLapp ll args))
        end in
    let bs := (|Util.Array|).(CArray.ExtS.mapi) mk_branch branches in
    Lcase annot_sw lt la bs
  | Constr.Fix ((pos, i), (names, type_bodies, rec_bodies)) =&gt;
    let ltypes := lambda_of_args cache env sigma 0 type_bodies in
    let map (i : Int.t) (t : Constr.constr) : string * Names.inductive :=
      let ind := get_fix_struct env i t in
      let prefix := get_mind_prefix env (fst ind) in
      (prefix, ind) in
    let inds := (|Util.Array|).(CArray.ExtS.map2) map pos type_bodies in
    let env := Environ.push_rec_types (names, type_bodies, rec_bodies) env in
    let lbodies := lambda_of_args cache env sigma 0 rec_bodies in
    Lfix (pos, inds, i) (names, ltypes, lbodies)
  | Constr.CoFix (init, (names, type_bodies, rec_bodies)) =&gt;
    let rec_bodies :=
      (|Util.Array|).(CArray.ExtS.map2) (Reduction.eta_expand env) rec_bodies
        type_bodies in
    let ltypes := lambda_of_args cache env sigma 0 type_bodies in
    let env := Environ.push_rec_types (names, type_bodies, rec_bodies) env in
    let lbodies := lambda_of_args cache env sigma 0 rec_bodies in
    Lcofix init (names, ltypes, lbodies)
  | Constr.Int i =&gt; Luint i
  end

with lambda_of_app
  (cache : (|Cache.ConstrTable|).(Stdlib__hashtbl.S.t) Cache.constructor_info)
  (env : Environ.env) (sigma : evars) (f : Constr.constr)
  (args : array Constr.constr) {struct cache} : lambda :=
  match kind f with
  | Constr.Const ((_kn, _u) as c) =&gt;
    let '(kn, u) := get_alias env c in
    let cb := lookup_constant kn env in
    match Declarations.constant_body.const_body cb with
    | Declarations.Primitive op =&gt;
      lambda_of_prim env c op (lambda_of_args cache env sigma 0 args)
    | Declarations.Def csubst =&gt;
      if Declarations.constant_body.const_inline_code cb then
        lambda_of_app cache env sigma (Mod_subst.force_constr csubst) args
      else
        let prefix := get_const_prefix env kn in
        let t :=
          if is_lazy (Mod_subst.force_constr csubst) then
            mkLapp Lforce
              (* ❌ Arrays not handled. *)
              [ Lconst prefix (kn, u) ]
          else
            Lconst prefix (kn, u) in
        mkLapp t (lambda_of_args cache env sigma 0 args)
    | Declarations.OpaqueDef _ | Declarations.Undef _ =&gt;
      let prefix := get_const_prefix env kn in
      mkLapp (Lconst prefix (kn, u)) (lambda_of_args cache env sigma 0 args)
    end
  | Constr.Construct (c, u) =&gt;
    let '(tag, nparams, arity) := Cache.get_construct_info cache env c in
    let expected := Z.add nparams arity in
    let nargs := (|Util.Array|).(CArray.ExtS.length) args in
    let prefix := get_mind_prefix env (fst (fst c)) in
    if Int.equal nargs expected then
      let args := lambda_of_args cache env sigma nparams args in
      makeblock env c u tag args
    else
      let args := lambda_of_args cache env sigma 0 args in
      mkLapp (Lconstruct prefix (c, u)) args
  | _ =&gt;
    let f := lambda_of_constr cache env sigma f in
    let args := lambda_of_args cache env sigma 0 args in
    mkLapp f args
  end

with lambda_of_args
  (cache : (|Cache.ConstrTable|).(Stdlib__hashtbl.S.t) Cache.constructor_info)
  (env : Environ.env) (sigma : evars) (start : Z) (args : array Constr.types)
  {struct cache} : array lambda :=
  let nargs := (|Util.Array|).(CArray.ExtS.length) args in
  if OCaml.Stdlib.lt start nargs then
    (|Util.Array|).(CArray.ExtS.init) (Z.sub nargs start)
      (fun i =&gt;
        lambda_of_constr cache env sigma
          ((|Util.Array|).(CArray.ExtS.get) args (Z.add start i)))
  else
    empty_args.

Definition optimize (lam : lambda) : lambda :=
  let lam := simplify subst_id lam in
  lam.

Definition lambda_of_constr
  (env : Environ.env) (sigma : evars) (c : Constr.constr) : lambda :=
  let cache := (|Cache.ConstrTable|).(Stdlib__hashtbl.S.create) 91 in
  let lam := lambda_of_constr cache env sigma c in
  optimize lam.

Definition mk_lazy (c : lambda) : lambda :=
  mkLapp Llazy
    (* ❌ Arrays not handled. *)
    [ c ].
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativelambda.mli">
  <div style="margin: 20px;">
    <h3>Nativelambda_mli</h3>
    <ul>
      <li>OCaml size: 68 lines</li>
      <li>Coq size: 79 lines (+16% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativelambda.mli"><code>nativelambda.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Names
open Constr
open Environ
open Nativevalues

(** This file defines the lambda code generation phase of the native compiler *)
type prefix = string

type lambda =
  | Lrel          of Name.t * int
  | Lvar          of Id.t
  | Lmeta         of metavariable * lambda (* type *)
  | Levar         of Evar.t * lambda array (* arguments *)
  | Lprod         of lambda * lambda
  | Llam          of Name.t Context.binder_annot array * lambda
  | Lrec          of Name.t Context.binder_annot * lambda
  | Llet          of Name.t Context.binder_annot * lambda * lambda
  | Lapp          of lambda * lambda array
  | Lconst        of prefix * pconstant
  | Lproj         of prefix * inductive * int (* prefix, inductive, index starting from 0 *)
  | Lprim         of prefix * pconstant * CPrimitives.t * lambda array
  | Lcase         of annot_sw * lambda * lambda * lam_branches
                  (* annotations, term being matched, accu, branches *)
  | Lif           of lambda * lambda * lambda
  | Lfix          of (int array * (string * inductive) array * int) * fix_decl
  | Lcofix        of int * fix_decl
  | Lmakeblock    of prefix * pconstructor * int * lambda array
                  (* prefix, constructor Name.t, constructor tag, arguments *)
        (* A fully applied constructor *)
  | Lconstruct    of prefix * pconstructor (* prefix, constructor Name.t *)
        (* A partially applied constructor *)
  | Luint         of Uint63.t
  | Lval          of Nativevalues.t
  | Lsort         of Sorts.t
  | Lind          of prefix * pinductive
  | Llazy
  | Lforce

and lam_branches = (constructor * Name.t Context.binder_annot array * lambda) array

and fix_decl =  Name.t Context.binder_annot array * lambda array * lambda array

type evars =
    { evars_val : existential -&gt; constr option;
      evars_metas : metavariable -&gt; types }

val empty_evars : evars

val decompose_Llam : lambda -&gt; Name.t Context.binder_annot array * lambda
val decompose_Llam_Llet : lambda -&gt; (Name.t Context.binder_annot * lambda option) array * lambda

val is_lazy : constr -&gt; bool
val mk_lazy : lambda -&gt; lambda

val get_mind_prefix : env -&gt; MutInd.t -&gt; string

val get_alias : env -&gt; pconstant -&gt; pconstant

val lambda_of_constr : env -&gt; evars -&gt; Constr.constr -&gt; lambda
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativelambda.mli"><code>Nativelambda_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition prefix := string.

Reserved Notation &quot;'lam_branches&quot;.
Reserved Notation &quot;'fix_decl&quot;.

Inductive lambda : Set :=
| Lrel : Names.Name.t -&gt; Z -&gt; lambda
| Lvar : Names.Id.t -&gt; lambda
| Lmeta : Constr.metavariable -&gt; lambda -&gt; lambda
| Levar : Evar.t -&gt; array lambda -&gt; lambda
| Lprod : lambda -&gt; lambda -&gt; lambda
| Llam : array (Context.binder_annot Names.Name.t) -&gt; lambda -&gt; lambda
| Lrec : Context.binder_annot Names.Name.t -&gt; lambda -&gt; lambda
| Llet : Context.binder_annot Names.Name.t -&gt; lambda -&gt; lambda -&gt; lambda
| Lapp : lambda -&gt; array lambda -&gt; lambda
| Lconst : prefix -&gt; Constr.pconstant -&gt; lambda
| Lproj : prefix -&gt; Names.inductive -&gt; Z -&gt; lambda
| Lprim : prefix -&gt; Constr.pconstant -&gt; CPrimitives.t -&gt; array lambda -&gt; lambda
| Lcase : Nativevalues.annot_sw -&gt; lambda -&gt; lambda -&gt; 'lam_branches -&gt; lambda
| Lif : lambda -&gt; lambda -&gt; lambda -&gt; lambda
| Lfix : array Z * array (string * Names.inductive) * Z -&gt; 'fix_decl -&gt; lambda
| Lcofix : Z -&gt; 'fix_decl -&gt; lambda
| Lmakeblock : prefix -&gt; Constr.pconstructor -&gt; Z -&gt; array lambda -&gt; lambda
| Lconstruct : prefix -&gt; Constr.pconstructor -&gt; lambda
| Luint : Uint63.t -&gt; lambda
| Lval : Nativevalues.t -&gt; lambda
| Lsort : Sorts.t -&gt; lambda
| Lind : prefix -&gt; Constr.pinductive -&gt; lambda
| Llazy : lambda
| Lforce : lambda

where &quot;'lam_branches&quot; :=
  (array
    (Names.constructor * array (Context.binder_annot Names.Name.t) * lambda))
and &quot;'fix_decl&quot; :=
  (array (Context.binder_annot Names.Name.t) * array lambda * array lambda).

Definition lam_branches := 'lam_branches.
Definition fix_decl := 'fix_decl.

Module evars.
  Record record := {
    evars_val : Constr.existential -&gt; option Constr.constr;
    evars_metas : Constr.metavariable -&gt; Constr.types }.
  Definition with_evars_val (r : record) evars_val : record :=
    {| evars_val := evars_val; evars_metas := evars_metas r |}.
  Definition with_evars_metas (r : record) evars_metas : record :=
    {| evars_val := evars_val r; evars_metas := evars_metas |}.
End evars.
Definition evars := evars.record.

Parameter empty_evars : evars.

Parameter decompose_Llam :
  lambda -&gt; array (Context.binder_annot Names.Name.t) * lambda.

Parameter decompose_Llam_Llet :
  lambda -&gt; array (Context.binder_annot Names.Name.t * option lambda) * lambda.

Parameter is_lazy : Constr.constr -&gt; bool.

Parameter mk_lazy : lambda -&gt; lambda.

Parameter get_mind_prefix : Environ.env -&gt; Names.MutInd.t -&gt; string.

Parameter get_alias : Environ.env -&gt; Constr.pconstant -&gt; Constr.pconstant.

Parameter lambda_of_constr : Environ.env -&gt; evars -&gt; Constr.constr -&gt; lambda.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativelib.ml">
  <div style="margin: 20px;">
    <h3>Nativelib</h3>
    <ul>
      <li>OCaml size: 155 lines</li>
      <li>Coq size: 218 lines (+40% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativelib.ml"><code>nativelib.ml</code></a>&nbsp;<span class="label label-warning">12 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Util
open Nativevalues
open Nativecode
open CErrors

(** This file provides facilities to access OCaml compiler and dynamic linker,
used by the native compiler. *)

let get_load_paths =
  ref (fun _ -&gt; anomaly (Pp.str &quot;get_load_paths not initialized.&quot;) : unit -&gt; string list)

let open_header = [&quot;Nativevalues&quot;;
                   &quot;Nativecode&quot;;
                   &quot;Nativelib&quot;;
                   &quot;Nativeconv&quot;;
                   &quot;Declaremods&quot;]
let open_header = List.map mk_open open_header

(* Directory where compiled files are stored *)
let output_dir = &quot;.coq-native&quot;

(* Extension of genereted ml files, stored for debugging purposes *)
let source_ext = &quot;.native&quot;

let ( / ) = Filename.concat

(* We have to delay evaluation of include_dirs because coqlib cannot be guessed
until flags have been properly initialized *)
let include_dirs () =
  [Filename.get_temp_dir_name (); Envars.coqlib () / &quot;kernel&quot;; Envars.coqlib () / &quot;library&quot;]

(* Pointer to the function linking an ML object into coq's toplevel *)
let load_obj = ref (fun _x -&gt; () : string -&gt; unit)

let rt1 = ref (dummy_value ())
let rt2 = ref (dummy_value ())

let get_ml_filename () =
  let filename = Filename.temp_file &quot;Coq_native&quot; source_ext in
  let prefix = Filename.chop_extension (Filename.basename filename) ^ &quot;.&quot; in
  filename, prefix

let write_ml_code fn ?(header=[]) code =
  let header = open_header@header in
  let ch_out = open_out fn in
  let fmt = Format.formatter_of_out_channel ch_out in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">List.iter (pp_global fmt) (header@code);
  close_out ch_out</abbr>

let error_native_compiler_failed e =
  let msg = match e with
  | Inl (Unix.WEXITED 127) -&gt; Pp.(strbrk &quot;The OCaml compiler was not found. Make sure it is installed, together with findlib.&quot;)
  | Inl (Unix.WEXITED n) -&gt; Pp.(strbrk &quot;Native compiler exited with status&quot; ++ str&quot; &quot; ++ int n)
  | Inl (Unix.WSIGNALED n) -&gt; Pp.(strbrk &quot;Native compiler killed by signal&quot; ++ str&quot; &quot; ++ int n)
  | Inl (Unix.WSTOPPED n) -&gt; Pp.(strbrk &quot;Native compiler stopped by signal&quot; ++ str&quot; &quot; ++ int n)
  | Inr e -&gt; Pp.(strbrk &quot;Native compiler failed with error: &quot; ++ strbrk (Unix.error_message e))
  in
  CErrors.user_err msg

let call_compiler ?profile:(profile=false) ml_filename =
  let load_path = !get_load_paths () in
  let load_path = List.map (fun dn -&gt; dn / output_dir) load_path in
  let include_dirs = List.flatten (List.map (fun x -&gt; [&quot;-I&quot;; x]) (include_dirs () @ load_path)) in
  let f = Filename.chop_extension ml_filename in
  let link_filename = f ^ &quot;.cmo&quot; in
  let link_filename = Dynlink.adapt_filename link_filename in
  let remove f = if Sys.file_exists f then Sys.remove f in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">remove link_filename;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">remove (f ^ &quot;.cmi&quot;);
  let initial_args =
    if Dynlink.is_native then
      [&quot;opt&quot;; &quot;-shared&quot;]
     else
      [&quot;ocamlc&quot;; &quot;-c&quot;]
  in
  let profile_args =
    if profile then
      [&quot;-g&quot;]
    else
      []
  in
  let flambda_args = if Sys.(backend_type = Native) then [&quot;-Oclassic&quot;] else [] in
  let args =
    initial_args @
      profile_args @
        flambda_args @
      (&quot;-o&quot;::link_filename
       ::&quot;-rectypes&quot;
       ::&quot;-w&quot;::&quot;a&quot;
       ::include_dirs) @
      [&quot;-impl&quot;; ml_filename] in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !Flags.debug then Feedback.msg_debug (Pp.str (Envars.ocamlfind () ^ &quot; &quot; ^ (String.concat &quot; &quot; args)));
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let res = CUnix.sys_command (Envars.ocamlfind ()) args in
    match res with
    | Unix.WEXITED 0 -&gt; link_filename
    | Unix.WEXITED _n | Unix.WSIGNALED _n | Unix.WSTOPPED _n -&gt;
      error_native_compiler_failed (Inl res)
  with Unix.Unix_error (e,_,_) -&gt;
    error_native_compiler_failed (Inr e)</abbr>

let compile fn code ~profile:profile =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">write_ml_code fn code;
  let r = call_compiler ~profile fn in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if (not !Flags.debug) &amp;&amp; Sys.file_exists fn then Sys.remove fn;
  r</abbr>

let compile_library dir code fn =
  let header = mk_library_header dir in
  let fn = fn ^ source_ext in
  let basename = Filename.basename fn in
  let dirname = Filename.dirname fn in
  let dirname = dirname / output_dir in
  let () =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Unix.mkdir dirname 0o755
    with Unix.Unix_error (Unix.EEXIST, _, _) -&gt; ()</abbr>
  in
  let fn = dirname / basename in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">write_ml_code fn ~header code;
  let _ = call_compiler fn in
  if (not !Flags.debug) &amp;&amp; Sys.file_exists fn then Sys.remove fn</abbr>

(* call_linker links dynamically the code for constants in environment or a  *)
(* conversion test. *)
let call_linker ?(fatal=true) prefix f upds =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">rt1 := dummy_value ();
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">rt2 := dummy_value ();
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (Sys.file_exists f) then
    begin
      let msg = &quot;Cannot find native compiler file &quot; ^ f in
      if fatal then CErrors.user_err Pp.(str msg)
      else if !Flags.debug then Feedback.msg_debug (Pp.str msg)
    end
  else
  (try
    if Dynlink.is_native then Dynlink.loadfile f else !load_obj f;
    register_native_file prefix
   with Dynlink.Error _ as exn -&gt;
     let exn = CErrors.push exn in
     if fatal then iraise exn
     else if !Flags.debug then Feedback.msg_debug CErrors.(iprint exn));
  match upds with Some upds -&gt; update_locations upds | _ -&gt; ()</abbr>

let link_library ~prefix ~dirname ~basename =
  let f = dirname / output_dir / basename in
  call_linker ~fatal:false prefix f None
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativelib.ml"><code>Nativelib.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Nativevalues.

Import Nativecode.

Import CErrors.

Definition get_load_paths : Stdlib.ref (unit -&gt; list string) :=
  Stdlib.__ref_value
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      anomaly None None (Pp.str &quot;get_load_paths not initialized.&quot;)).

Definition open_header : list string :=
  [ &quot;Nativevalues&quot;; &quot;Nativecode&quot;; &quot;Nativelib&quot;; &quot;Nativeconv&quot;; &quot;Declaremods&quot; ].

Definition open_header : list Nativecode.global :=
  (|Util.List|).(CList.ExtS.map) mk_open open_header.

Definition output_dir : string := &quot;.coq-native&quot;.

Definition source_ext : string := &quot;.native&quot;.

Definition op_div : string -&gt; string -&gt; string := Filename.concat.

Definition include_dirs (function_parameter : unit) : list string :=
  let '_ := function_parameter in
  [
    Filename.get_temp_dir_name tt;
    op_div (Envars.coqlib tt) &quot;kernel&quot;;
    op_div (Envars.coqlib tt) &quot;library&quot;
  ].

Definition load_obj : Stdlib.ref (string -&gt; unit) :=
  Stdlib.__ref_value (fun _x =&gt; tt).

Definition rt1 : Stdlib.ref Nativevalues.t :=
  Stdlib.__ref_value (dummy_value tt).

Definition rt2 : Stdlib.ref Nativevalues.t :=
  Stdlib.__ref_value (dummy_value tt).

Definition get_ml_filename (function_parameter : unit) : string * string :=
  let '_ := function_parameter in
  let filename := Filename.temp_file None &quot;Coq_native&quot; source_ext in
  let prefix :=
    String.append (Filename.chop_extension (Filename.basename filename)) &quot;.&quot; in
  (filename, prefix).

Definition write_ml_code
  (fn : string) (op_staroptstar : option (list Nativecode.global))
  : list Nativecode.global -&gt; unit :=
  let header :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; []
    end in
  fun code =&gt;
    let header := op_at open_header header in
    let ch_out := Stdlib.open_out fn in
    let fmt := Format.formatter_of_out_channel ch_out in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.close_out ch_out.

Definition error_native_compiler_failed {A : Set}
  (e : Util.union Unix.process_status Unix.__error) : A :=
  let msg :=
    match e with
    | Util.Inl (Unix.WEXITED 127) =&gt;
      strbrk
        &quot;The OCaml compiler was not found. Make sure it is installed, together with findlib.&quot;
    | Util.Inl (Unix.WEXITED n) =&gt;
      op_plusplus
        (op_plusplus (strbrk &quot;Native compiler exited with status&quot;) (str &quot; &quot;))
        (int n)
    | Util.Inl (Unix.WSIGNALED n) =&gt;
      op_plusplus
        (op_plusplus (strbrk &quot;Native compiler killed by signal&quot;) (str &quot; &quot;))
        (int n)
    | Util.Inl (Unix.WSTOPPED n) =&gt;
      op_plusplus
        (op_plusplus (strbrk &quot;Native compiler stopped by signal&quot;) (str &quot; &quot;))
        (int n)
    | Util.Inr e =&gt;
      op_plusplus (strbrk &quot;Native compiler failed with error: &quot;)
        (strbrk (Unix.error_message e))
    end in
  CErrors.user_err None None msg.

Definition call_compiler (op_staroptstar : option bool) : string -&gt; string :=
  let profile :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun ml_filename =&gt;
    let load_path := (Stdlib.op_exclamation get_load_paths) tt in
    let load_path :=
      (|Util.List|).(CList.ExtS.map) (fun dn =&gt; op_div dn output_dir) load_path
      in
    let include_dirs :=
      (|Util.List|).(CList.ExtS.flatten)
        ((|Util.List|).(CList.ExtS.map) (fun x =&gt; [ &quot;-I&quot;; x ])
          (op_at (include_dirs tt) load_path)) in
    let f := Filename.chop_extension ml_filename in
    let link_filename := String.append f &quot;.cmo&quot; in
    let link_filename := Dynlink.adapt_filename link_filename in
    let remove (f : string) : unit :=
      if Sys.file_exists f then
        Sys.remove f
      else
        tt in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let initial_args :=
      if Dynlink.is_native then
        [ &quot;opt&quot;; &quot;-shared&quot; ]
      else
        [ &quot;ocamlc&quot;; &quot;-c&quot; ] in
    let profile_args :=
      if profile then
        [ &quot;-g&quot; ]
      else
        [] in
    let flambda_args :=
      if equiv_decb backend_type Stdlib.Sys.Native then
        [ &quot;-Oclassic&quot; ]
      else
        [] in
    let args :=
      op_at initial_args
        (op_at profile_args
          (op_at flambda_args
            (op_at
              (cons &quot;-o&quot;
                (cons link_filename
                  (cons &quot;-rectypes&quot; (cons &quot;-w&quot; (cons &quot;a&quot; include_dirs)))))
              [ &quot;-impl&quot;; ml_filename ]))) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Try-with are not handled *)
    try
      (let res := CUnix.sys_command (Envars.ocamlfind tt) args in
      match res with
      | Unix.WEXITED 0 =&gt; link_filename
      | Unix.WEXITED _n | Unix.WSIGNALED _n | Unix.WSTOPPED _n =&gt;
        error_native_compiler_failed (Util.Inl res)
      end).

Definition compile
  (fn : string) (code : list Nativecode.global) (profile : bool) : string :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let r := call_compiler (Some profile) fn in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  r.

Definition compile_library
  (dir : Names.DirPath.t) (code : list Nativecode.global) (fn : string)
  : unit :=
  let header := mk_library_header dir in
  let fn := String.append fn source_ext in
  let basename := Filename.basename fn in
  let dirname := Filename.dirname fn in
  let dirname := op_div dirname output_dir in
  let '_ :=
    (* ❌ Try-with are not handled *)
    try (Unix.mkdir dirname 493) in
  let fn := op_div dirname basename in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let '_ := call_compiler None fn in
  if andb (negb (Stdlib.op_exclamation Flags.debug)) (Sys.file_exists fn) then
    Sys.remove fn
  else
    tt.

Definition call_linker (op_staroptstar : option bool)
  : string -&gt; string -&gt; option Nativecode.code_location_updates -&gt; unit :=
  let fatal :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; true
    end in
  fun prefix =&gt;
    fun f =&gt;
      fun upds =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        match upds with
        | Some upds =&gt; update_locations upds
        | _ =&gt; tt
        end.

Definition link_library (prefix : string) (dirname : string) (basename : string)
  : unit :=
  let f := op_div (op_div dirname output_dir) basename in
  call_linker (Some false) prefix f None.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativelib.mli">
  <div style="margin: 20px;">
    <h3>Nativelib_mli</h3>
    <ul>
      <li>OCaml size: 39 lines</li>
      <li>Coq size: 33 lines (-16% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativelib.mli"><code>nativelib.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Nativecode

(** This file provides facilities to access OCaml compiler and dynamic linker,
used by the native compiler. *)

(* Directory where compiled files are stored *)
val output_dir : string

val get_load_paths : (unit -&gt; string list) ref

val load_obj : (string -&gt; unit) ref

val get_ml_filename : unit -&gt; string * string

(** [compile file code ~profile] will compile native [code] to [file],
   and return the name of the object file; this name depends on
   whether are in byte mode or not; file is expected to be .ml file *)
val compile : string -&gt; global list -&gt; profile:bool -&gt; string

(** [compile_library lib code file] is similar to [compile file code]
   but will perform some extra tweaks to handle [code] as a Coq lib. *)
val compile_library : Names.DirPath.t -&gt; global list -&gt; string -&gt; unit

val call_linker :
  ?fatal:bool -&gt; string -&gt; string -&gt; code_location_updates option -&gt; unit

val link_library : prefix:string -&gt; dirname:string -&gt; basename:string -&gt; unit

val rt1 : Nativevalues.t ref
val rt2 : Nativevalues.t ref
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativelib.mli"><code>Nativelib_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter output_dir : string.

Parameter get_load_paths : Stdlib.ref (unit -&gt; list string).

Parameter load_obj : Stdlib.ref (string -&gt; unit).

Parameter get_ml_filename : unit -&gt; string * string.

Parameter compile : string -&gt; list Nativecode.global -&gt; bool -&gt; string.

Parameter compile_library :
  Names.DirPath.t -&gt; list Nativecode.global -&gt; string -&gt; unit.

Parameter call_linker :
  option bool -&gt; string -&gt; string -&gt; option Nativecode.code_location_updates -&gt;
  unit.

Parameter link_library : string -&gt; string -&gt; string -&gt; unit.

Parameter rt1 : Stdlib.ref Nativevalues.t.

Parameter rt2 : Stdlib.ref Nativevalues.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativelibrary.ml">
  <div style="margin: 20px;">
    <h3>Nativelibrary</h3>
    <ul>
      <li>OCaml size: 74 lines</li>
      <li>Coq size: 100 lines (+35% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativelibrary.ml"><code>nativelibrary.ml</code></a>&nbsp;<span class="label label-warning">8 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Declarations
open Mod_subst
open Modops
open Nativecode

(** This file implements separate compilation for libraries in the native
compiler *)

let rec translate_mod prefix mp env mod_expr acc =
  match mod_expr with
  | NoFunctor struc -&gt;
      let env' = add_structure mp struc empty_delta_resolver env in
      List.fold_left (translate_field prefix mp env') acc struc
  | MoreFunctor _ -&gt; acc

and translate_field prefix mp env acc (l,x) =
  match x with
  | SFBconst cb -&gt;
     let con = Constant.make2 mp l in
     <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(if !Flags.debug then
        let msg = Printf.sprintf &quot;Compiling constant %s...&quot; (Constant.to_string con) in
        Feedback.msg_debug (Pp.str msg));
     compile_constant_field env prefix con acc cb</abbr>
  | SFBmind mb -&gt;
     <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(if !Flags.debug then
        let id = mb.mind_packets.(0).mind_typename in
        let msg = Printf.sprintf &quot;Compiling inductive %s...&quot; (Id.to_string id) in
        Feedback.msg_debug (Pp.str msg));
     compile_mind_field mp l acc mb</abbr>
  | SFBmodule md -&gt;
     let mp = md.mod_mp in
     <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(if !Flags.debug then
        let msg =
          Printf.sprintf &quot;Compiling module %s...&quot; (ModPath.to_string mp)
        in
        Feedback.msg_debug (Pp.str msg));
     translate_mod prefix mp env md.mod_type acc</abbr>
  | SFBmodtype mdtyp -&gt;
     let mp = mdtyp.mod_mp in
     <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(if !Flags.debug then
        let msg =
          Printf.sprintf &quot;Compiling module type %s...&quot; (ModPath.to_string mp)
        in
        Feedback.msg_debug (Pp.str msg));
     translate_mod prefix mp env mdtyp.mod_type acc</abbr>

let dump_library mp dp env mod_expr =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !Flags.debug then Feedback.msg_debug (Pp.str &quot;Compiling library...&quot;);
  match mod_expr with
  | NoFunctor struc -&gt;
      let env = add_structure mp struc empty_delta_resolver env in
      let prefix = mod_uid_of_dirpath dp ^ &quot;.&quot; in
      let t0 = Sys.time () in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">clear_global_tbl ();
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">clear_symbols ();
      let mlcode =
        List.fold_left (translate_field prefix mp env) [] struc
      in
      let t1 = Sys.time () in
      let time_info = Format.sprintf &quot;Time spent generating this code: %.5fs&quot; (t1-.t0) in
      let mlcode = add_header_comment (List.rev mlcode) time_info in
      mlcode, get_symbols ()</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  | _ -&gt; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert false</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativelibrary.ml"><code>Nativelibrary.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Declarations.

Import Mod_subst.

Import Modops.

Import Nativecode.

Fixpoint translate_mod
  (prefix : string) (mp : Names.ModPath.t) (env : Environ.env)
  (mod_expr :
    Declarations.functorize Declarations.module_type_body
      Declarations.structure_body) (acc : list Nativecode.global)
  {struct prefix} : list Nativecode.global :=
  match mod_expr with
  | Declarations.NoFunctor struc =&gt;
    let env' := add_structure mp struc empty_delta_resolver env in
    Stdlib.List.fold_left (translate_field prefix mp env') acc struc
  | Declarations.MoreFunctor _ _ _ =&gt; acc
  end

with translate_field
  (prefix : string) (mp : Names.ModPath.t) (env : Environ.env)
  (acc : list Nativecode.global)
  (function_parameter : Names.Label.t * Declarations.structure_field_body)
  {struct prefix} : list Nativecode.global :=
  let '(l, x) := function_parameter in
  match x with
  | Declarations.SFBconst cb =&gt;
    let con := Constant.make2 mp l in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    compile_constant_field env prefix con acc cb
  | Declarations.SFBmind mb =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    compile_mind_field mp l acc mb
  | Declarations.SFBmodule md =&gt;
    let mp := Declarations.generic_module_body.mod_mp md in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    translate_mod prefix mp env (Declarations.generic_module_body.mod_type md)
      acc
  | Declarations.SFBmodtype mdtyp =&gt;
    let mp := Declarations.generic_module_body.mod_mp mdtyp in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    translate_mod prefix mp env
      (Declarations.generic_module_body.mod_type mdtyp) acc
  end.

Definition dump_library {A : Set}
  (mp : Names.ModPath.t) (dp : Names.DirPath.t) (env : Environ.env)
  (mod_expr : Declarations.functorize A Declarations.structure_body)
  : list Nativecode.global * Nativecode.symbols :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  match mod_expr with
  | Declarations.NoFunctor struc =&gt;
    let env := add_structure mp struc empty_delta_resolver env in
    let prefix := String.append (mod_uid_of_dirpath dp) &quot;.&quot; in
    let t0 := Sys.time tt in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let mlcode := Stdlib.List.fold_left (translate_field prefix mp env) [] struc
      in
    let t1 := Sys.time tt in
    let time_info :=
      Format.sprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal
            &quot;Time spent generating this code: &quot;
            (CamlinternalFormatBasics.Float CamlinternalFormatBasics.Float_f
              CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Lit_precision 5)
              (CamlinternalFormatBasics.Char_literal &quot;s&quot; % char
                CamlinternalFormatBasics.End_of_format)))
          &quot;Time spent generating this code: %.5fs&quot;) (Stdlib.op_minuspoint t1 t0)
      in
    let mlcode := add_header_comment (List.rev mlcode) time_info in
    (mlcode, (get_symbols tt))
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativelibrary.mli">
  <div style="margin: 20px;">
    <h3>Nativelibrary_mli</h3>
    <ul>
      <li>OCaml size: 19 lines</li>
      <li>Coq size: 14 lines (-27% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativelibrary.mli"><code>nativelibrary.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Names
open Declarations
open Environ
open Nativecode

(** This file implements separate compilation for libraries in the native
compiler *)

val dump_library : ModPath.t -&gt; DirPath.t -&gt; env -&gt; module_signature -&gt;
  global list * symbols
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativelibrary.mli"><code>Nativelibrary_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter dump_library :
  Names.ModPath.t -&gt; Names.DirPath.t -&gt; Environ.env -&gt;
  Declarations.module_signature -&gt; list Nativecode.global * Nativecode.symbols.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativevalues.ml">
  <div style="margin: 20px;">
    <h3>Nativevalues</h3>
    <ul>
      <li>OCaml size: 517 lines</li>
      <li>Coq size: 606 lines (+17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativevalues.ml"><code>nativevalues.ml</code></a>&nbsp;<span class="label label-warning">8 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open CErrors
open Names
open Constr

(** This module defines the representation of values internally used by
the native compiler *)

type t = t -&gt; t

type accumulator (* = t (* a block [0:code;atom;arguments] *) *)

type tag = int

type arity = int

type reloc_table = (tag * arity) array

type annot_sw = {
    asw_ind : inductive;
    asw_ci : case_info;
    asw_reloc : reloc_table;
    asw_finite : bool;
    asw_prefix : string
  }

(* We compare only what is relevant for generation of ml code *)
let eq_annot_sw asw1 asw2 =
  eq_ind asw1.asw_ind asw2.asw_ind &amp;&amp;
  String.equal asw1.asw_prefix asw2.asw_prefix

open Hashset.Combine

let hash_annot_sw asw =
  combine (ind_hash asw.asw_ind) (String.hash asw.asw_prefix)

type sort_annot = string * int

type rec_pos = int array

let eq_rec_pos = Array.equal Int.equal

type atom =
  | Arel of int
  | Aconstant of pconstant
  | Aind of pinductive
  | Asort of Sorts.t
  | Avar of Id.t
  | Acase of annot_sw * accumulator * t * (t -&gt; t)
  | Afix of t array * t array * rec_pos * int
            (* types, bodies, rec_pos, pos *)
  | Acofix of t array * t array * int * t
  | Acofixe of t array * t array * int * t
  | Aprod of Name.t * t * (t -&gt; t)
  | Ameta of metavariable * t
  | Aevar of Evar.t * t array
  | Aproj of (inductive * int) * accumulator

let accumulate_tag = 0

(** Unique pointer used to drive the accumulator function *)
let ret_accu = Obj.repr (ref ())

type accu_val = { mutable acc_atm : atom; acc_arg : Obj.t list }

let mk_accu (a : atom) : t =
  let rec accumulate data x =
    if x == ret_accu then Obj.repr data
    else
      let data = { data with acc_arg = x :: data.acc_arg } in
      let ans = Obj.repr (accumulate data) in
      let () = Obj.set_tag ans accumulate_tag in
      ans
  in
  let acc = { acc_atm = a; acc_arg = [] } in
  let ans = Obj.repr (accumulate acc) in
  (** FIXME: use another representation for accumulators, this causes naked
      pointers. *)
  let () = Obj.set_tag ans accumulate_tag in
  (Obj.obj ans : t)

let get_accu (k : accumulator) =
  (Obj.magic k : Obj.t -&gt; accu_val) ret_accu

let mk_rel_accu i =
  mk_accu (Arel i)

let rel_tbl_size = 100
let rel_tbl = Array.init rel_tbl_size mk_rel_accu

let mk_rel_accu i =
  if i &lt; rel_tbl_size then rel_tbl.(i)
  else mk_rel_accu i

let mk_rels_accu lvl len =
  Array.init len (fun i -&gt; mk_rel_accu (lvl + i))

let napply (f:t) (args: t array) =
  Array.fold_left (fun f a -&gt; f a) f args

let mk_constant_accu kn u =
  mk_accu (Aconstant (kn,Univ.Instance.of_array u))

let mk_ind_accu ind u =
  mk_accu (Aind (ind,Univ.Instance.of_array u))

let mk_sort_accu s u =
  let open Sorts in
  match s with
  | SProp | Prop | Set -&gt; mk_accu (Asort s)
  | Type s -&gt;
     let u = Univ.Instance.of_array u in
     let s = Sorts.sort_of_univ (Univ.subst_instance_universe u s) in
     mk_accu (Asort s)

let mk_var_accu id =
  mk_accu (Avar id)

let mk_sw_accu annot c p ac =
  mk_accu (Acase(annot,c,p,ac))

let mk_prod_accu s dom codom =
  mk_accu (Aprod (s,dom,codom))

let mk_meta_accu mv ty =
  mk_accu (Ameta (mv,ty))

let mk_evar_accu ev args =
  mk_accu (Aevar (ev, args))

let mk_proj_accu kn c =
  mk_accu (Aproj (kn,c))

let atom_of_accu (k:accumulator) =
  (get_accu k).acc_atm

let set_atom_of_accu (k:accumulator) (a:atom) =
  <abbr class="mark-warning" title="Set record field not handled.">(get_accu k).acc_atm &lt;- a</abbr>

let accu_nargs (k:accumulator) =
  List.length (get_accu k).acc_arg

let args_of_accu (k:accumulator) =
  let acc = (get_accu k).acc_arg in
  (Obj.magic (Array.of_list acc) : t array)

let mk_fix_accu rec_pos pos types bodies =
  mk_accu (Afix(types,bodies,rec_pos, pos))

let mk_cofix_accu pos types norm =
  mk_accu (Acofix(types,norm,pos,(Obj.magic 0 : t)))

let upd_cofix (cofix :t) (cofix_fun : t) =
  let atom = atom_of_accu (Obj.magic cofix) in
  match atom with
  | Acofix (typ,norm,pos,_) -&gt;
      set_atom_of_accu (Obj.magic cofix) (Acofix(typ,norm,pos,cofix_fun))
  | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let force_cofix (cofix : t) =
  let accu = (Obj.magic cofix : accumulator) in
  let atom = atom_of_accu accu in
  match atom with
  | Acofix(typ,norm,pos,f) -&gt;
    let args = args_of_accu accu in
    let f = Array.fold_right (fun arg f -&gt; f arg) args f in
    let v = f (Obj.magic ()) in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_atom_of_accu accu (Acofixe(typ,norm,pos,v));
      v</abbr>
  | Acofixe(_,_,_,v) -&gt; v
  | _ -&gt; cofix

let mk_const tag = Obj.magic tag

let mk_block tag args =
  let nargs = Array.length args in
  let r = Obj.new_block tag nargs in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to nargs - 1 do
    Obj.set_field r i (Obj.magic args.(i))
  done;
  (Obj.magic r : t)</abbr>

(* Two instances of dummy_value should not be pointer equal, otherwise
 comparing them as terms would succeed *)
let dummy_value : unit -&gt; t =
  fun () _ -&gt; anomaly ~label:&quot;native&quot; (Pp.str &quot;Evaluation failed.&quot;)

let cast_accu v = (Obj.magic v:accumulator)
[@@ocaml.inline always]

let mk_int (x : int) = (Obj.magic x : t)
[@@ocaml.inline always]

(* Coq's booleans are reversed... *)
let mk_bool (b : bool) = (Obj.magic (not b) : t)
[@@ocaml.inline always]

let mk_uint (x : Uint63.t) = (Obj.magic x : t)
[@@ocaml.inline always]

type block

let block_size (b:block) =
  Obj.size (Obj.magic b)

let block_field (b:block) i = (Obj.magic (Obj.field (Obj.magic b) i) : t)

let block_tag (b:block) =
  Obj.tag (Obj.magic b)

type kind_of_value =
  | Vaccu of accumulator
  | Vfun of (t -&gt; t)
  | Vconst of int
  | Vint64 of int64
  | Vblock of block

let kind_of_value (v:t) =
  let o = Obj.repr v in
  if Obj.is_int o then Vconst (Obj.magic v)
  else
    let tag = Obj.tag o in
    if Int.equal tag accumulate_tag then
      Vaccu (Obj.magic v)
    else if Int.equal tag Obj.custom_tag then Vint64 (Obj.magic v)
    else if (tag &lt; Obj.lazy_tag) then Vblock (Obj.magic v)
      else
        (* assert (tag = Obj.closure_tag || tag = Obj.infix_tag);
           or ??? what is 1002*)
        Vfun v

(** Support for machine integers *)

let is_int (x:t) =
  let o = Obj.repr x in
  Obj.is_int o || Int.equal (Obj.tag o) Obj.custom_tag

let val_to_int (x:t) = (Obj.magic x : int)
[@@ocaml.inline always]

let to_uint (x:t) = (Obj.magic x : Uint63.t)
[@@ocaml.inline always]

let no_check_head0 x =
 mk_uint (Uint63.head0 (to_uint x))
[@@ocaml.inline always]

let head0 accu x =
 if is_int x then  no_check_head0 x
 else accu x

let no_check_tail0 x =
  mk_uint (Uint63.tail0 (to_uint x))
[@@ocaml.inline always]

let tail0 accu x =
 if is_int x then no_check_tail0 x
 else accu x

let no_check_add  x y =
  mk_uint (Uint63.add (to_uint x) (to_uint y))
[@@ocaml.inline always]

let add accu x y =
  if is_int x &amp;&amp; is_int y then no_check_add x y
  else accu x y

let no_check_sub x y =
  mk_uint (Uint63.sub (to_uint x) (to_uint y))
[@@ocaml.inline always]

let sub accu x y =
  if is_int x &amp;&amp; is_int y then no_check_sub x y
  else accu x y

let no_check_mul x y =
  mk_uint (Uint63.mul (to_uint x) (to_uint y))
[@@ocaml.inline always]

let mul accu x y =
  if is_int x &amp;&amp; is_int y then no_check_mul x y
  else accu x y

let no_check_div x y =
  mk_uint (Uint63.div (to_uint x) (to_uint y))
[@@ocaml.inline always]

let div accu x y =
  if is_int x &amp;&amp; is_int y then no_check_div x y
  else accu x y

let no_check_rem x y =
  mk_uint (Uint63.rem (to_uint x) (to_uint y))
[@@ocaml.inline always]

let rem accu x y =
  if is_int x &amp;&amp; is_int y then no_check_rem x y
  else accu x y

let no_check_l_sr x y =
  mk_uint (Uint63.l_sr (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_sr accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_sr x y
  else accu x y

let no_check_l_sl x y =
  mk_uint (Uint63.l_sl (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_sl accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_sl x y
  else accu x y

let no_check_l_and x y =
  mk_uint (Uint63.l_and (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_and accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_and x y
  else accu x y

let no_check_l_xor x y =
  mk_uint (Uint63.l_xor (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_xor accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_xor x y
  else accu x y

let no_check_l_or x y =
  mk_uint (Uint63.l_or (to_uint x) (to_uint y))
[@@ocaml.inline always]

let l_or accu x y =
  if is_int x &amp;&amp; is_int y then no_check_l_or x y
  else accu x y

[@@@ocaml.warning &quot;-37&quot;]
type coq_carry =
  | Caccu of t
  | C0 of t
  | C1 of t

type coq_pair =
  | Paccu of t
  | PPair of t * t

let mkCarry b i =
  if b then (Obj.magic (C1(mk_uint i)):t)
  else (Obj.magic (C0(mk_uint i)):t)

let no_check_addc x y =
  let s = Uint63.add (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt s (to_uint x)) s
[@@ocaml.inline always]

let addc accu x y =
  if is_int x &amp;&amp; is_int y then no_check_addc x y
  else accu x y

let no_check_subc x y =
  let s = Uint63.sub (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt (to_uint x) (to_uint y)) s
[@@ocaml.inline always]

let subc accu x y =
  if is_int x &amp;&amp; is_int y then no_check_subc x y
  else accu x y

let no_check_addCarryC x y =
  let s =
    Uint63.add (Uint63.add (to_uint x) (to_uint y))
      (Uint63.of_int 1) in
  mkCarry (Uint63.le s (to_uint x)) s
[@@ocaml.inline always]

let addCarryC accu x y =
  if is_int x &amp;&amp; is_int y then no_check_addCarryC x y
  else accu x y

let no_check_subCarryC x y =
  let s =
    Uint63.sub (Uint63.sub (to_uint x) (to_uint y))
      (Uint63.of_int 1) in
  mkCarry (Uint63.le (to_uint x) (to_uint y)) s
[@@ocaml.inline always]

let subCarryC accu x y =
  if is_int x &amp;&amp; is_int y then no_check_subCarryC x y
  else accu x y

let of_pair (x, y) =
  (Obj.magic (PPair(mk_uint x, mk_uint y)):t)
[@@ocaml.inline always]

let no_check_mulc x y =
  of_pair (Uint63.mulc (to_uint x) (to_uint y))
[@@ocaml.inline always]

let mulc accu x y =
  if is_int x &amp;&amp; is_int y then no_check_mulc x y
  else accu x y

let no_check_diveucl x y =
  let i1, i2 = to_uint x, to_uint y in
  of_pair(Uint63.div i1 i2, Uint63.rem i1 i2)
[@@ocaml.inline always]

let diveucl accu x y =
  if is_int x &amp;&amp; is_int y then no_check_diveucl x y
  else accu x y

let no_check_div21 x y z =
  let i1, i2, i3 = to_uint x, to_uint y, to_uint z in
  of_pair (Uint63.div21 i1 i2 i3)
[@@ocaml.inline always]

let div21 accu x y z =
  if is_int x &amp;&amp; is_int y &amp;&amp; is_int z then no_check_div21 x y z
  else accu x y z

let no_check_addMulDiv x y z =
  let p, i, j = to_uint x, to_uint y, to_uint z in
  mk_uint (Uint63.addmuldiv p i j)
[@@ocaml.inline always]

let addMulDiv accu x y z =
  if is_int x &amp;&amp; is_int y &amp;&amp; is_int z then no_check_addMulDiv x y z
  else accu x y z

[@@@ocaml.warning &quot;-34&quot;]
type coq_bool =
  | Baccu of t
  | Btrue
  | Bfalse

type coq_cmp =
  | CmpAccu of t
  | CmpEq
  | CmpLt
  | CmpGt

let no_check_eq x y =
  mk_bool (Uint63.equal (to_uint x) (to_uint y))
[@@ocaml.inline always]

let eq accu x y =
  if is_int x &amp;&amp; is_int y then no_check_eq x y
  else accu x y

let no_check_lt x y =
  mk_bool (Uint63.lt (to_uint x) (to_uint y))
[@@ocaml.inline always]

let lt accu x y =
  if is_int x &amp;&amp; is_int y then no_check_lt x y
  else accu x y

let no_check_le x y =
  mk_bool (Uint63.le (to_uint x) (to_uint y))
[@@ocaml.inline always]

let le accu x y =
  if is_int x &amp;&amp; is_int y then no_check_le x y
  else accu x y

let no_check_compare x y =
  match Uint63.compare (to_uint x) (to_uint y) with
  | x when x &lt; 0 -&gt; (Obj.magic CmpLt:t)
  | 0 -&gt; (Obj.magic CmpEq:t)
  | _ -&gt; (Obj.magic CmpGt:t)

let compare accu x y =
  if is_int x &amp;&amp; is_int y then no_check_compare x y
  else accu x y

let print x =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Printf.fprintf stderr &quot;%s&quot; (Uint63.to_string (to_uint x));
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">flush stderr;
  x</abbr>

let hobcnv = Array.init 256 (fun i -&gt; Printf.sprintf &quot;%02x&quot; i)
let bohcnv = Array.init 256 (fun i -&gt; i -
                                      (if 0x30 &lt;= i then 0x30 else 0) -
                                      (if 0x41 &lt;= i then 0x7 else 0) -
                                      (if 0x61 &lt;= i then 0x20 else 0))

let hex_of_bin ch = hobcnv.(int_of_char ch)
let bin_of_hex s = char_of_int (bohcnv.(int_of_char s.[0]) * 16 + bohcnv.(int_of_char s.[1]))

let str_encode expr =
  let mshl_expr = Marshal.to_string expr [] in
  let payload = Buffer.create (String.length mshl_expr * 2) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">String.iter (fun c -&gt; Buffer.add_string payload (hex_of_bin c)) mshl_expr;
  Buffer.contents payload</abbr>

let str_decode s =
  let mshl_expr_len = String.length s / 2 in
  let mshl_expr = Buffer.create mshl_expr_len in
  let buf = Bytes.create 2 in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to mshl_expr_len - 1 do
    Bytes.blit_string s (2*i) buf 0 2;
    Buffer.add_char mshl_expr (bin_of_hex (Bytes.to_string buf))
  done;
  Marshal.from_bytes (Buffer.to_bytes mshl_expr) 0</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativevalues.ml"><code>Nativevalues.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import CErrors.

Import Names.

Import Constr.

Definition t := t -&gt; t.

Parameter accumulator : Set.

Definition tag := Z.

Definition arity := Z.

Definition reloc_table := array (tag * arity).

Module annot_sw.
  Record record := {
    asw_ind : Names.inductive;
    asw_ci : Constr.case_info;
    asw_reloc : reloc_table;
    asw_finite : bool;
    asw_prefix : string }.
  Definition with_asw_ind (r : record) asw_ind : record :=
    {| asw_ind := asw_ind; asw_ci := asw_ci r; asw_reloc := asw_reloc r;
      asw_finite := asw_finite r; asw_prefix := asw_prefix r |}.
  Definition with_asw_ci (r : record) asw_ci : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci; asw_reloc := asw_reloc r;
      asw_finite := asw_finite r; asw_prefix := asw_prefix r |}.
  Definition with_asw_reloc (r : record) asw_reloc : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci r; asw_reloc := asw_reloc;
      asw_finite := asw_finite r; asw_prefix := asw_prefix r |}.
  Definition with_asw_finite (r : record) asw_finite : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci r; asw_reloc := asw_reloc r;
      asw_finite := asw_finite; asw_prefix := asw_prefix r |}.
  Definition with_asw_prefix (r : record) asw_prefix : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci r; asw_reloc := asw_reloc r;
      asw_finite := asw_finite r; asw_prefix := asw_prefix |}.
End annot_sw.
Definition annot_sw := annot_sw.record.

Definition eq_annot_sw (asw1 : annot_sw) (asw2 : annot_sw) : bool :=
  andb (eq_ind (annot_sw.asw_ind asw1) (annot_sw.asw_ind asw2))
    ((|Util.String|).(CString.ExtS.equal) (annot_sw.asw_prefix asw1)
      (annot_sw.asw_prefix asw2)).

Import Hashset.Combine.

Definition hash_annot_sw (asw : annot_sw) : Z :=
  combine (ind_hash (annot_sw.asw_ind asw))
    ((|Util.String|).(CString.ExtS.hash) (annot_sw.asw_prefix asw)).

Definition sort_annot := string * Z.

Definition rec_pos := array Z.

Definition eq_rec_pos : array Int.t -&gt; array Int.t -&gt; bool :=
  (|Util.Array|).(CArray.ExtS.equal) Int.equal.

Inductive atom : Set :=
| Arel : Z -&gt; atom
| Aconstant : Constr.pconstant -&gt; atom
| Aind : Constr.pinductive -&gt; atom
| Asort : Sorts.t -&gt; atom
| Avar : Names.Id.t -&gt; atom
| Acase : annot_sw -&gt; accumulator -&gt; t -&gt; (t -&gt; t) -&gt; atom
| Afix : array t -&gt; array t -&gt; rec_pos -&gt; Z -&gt; atom
| Acofix : array t -&gt; array t -&gt; Z -&gt; t -&gt; atom
| Acofixe : array t -&gt; array t -&gt; Z -&gt; t -&gt; atom
| Aprod : Names.Name.t -&gt; t -&gt; (t -&gt; t) -&gt; atom
| Ameta : Constr.metavariable -&gt; t -&gt; atom
| Aevar : Evar.t -&gt; array t -&gt; atom
| Aproj : Names.inductive * Z -&gt; accumulator -&gt; atom.

Definition accumulate_tag : Z := 0.

Definition ret_accu : Stdlib.Obj.t := Obj.repr (Stdlib.__ref_value tt).

Module accu_val.
  Record record := {
    acc_atm : atom;
    acc_arg : list Stdlib.Obj.t }.
  Definition with_acc_atm (r : record) acc_atm : record :=
    {| acc_atm := acc_atm; acc_arg := acc_arg r |}.
  Definition with_acc_arg (r : record) acc_arg : record :=
    {| acc_atm := acc_atm r; acc_arg := acc_arg |}.
End accu_val.
Definition accu_val := accu_val.record.

Definition mk_accu (a : atom) : t :=
  let fix accumulate (data : accu_val) (x : Stdlib.Obj.t) {struct data}
    : Stdlib.Obj.t :=
    if Stdlib.op_eqeq x ret_accu then
      Obj.repr data
    else
      let data := accu_val.with_acc_arg data (cons x (accu_val.acc_arg data)) in
      let ans := Obj.repr (accumulate data) in
      let '_ := Obj.set_tag ans accumulate_tag in
      ans in
  let acc := {| accu_val.acc_atm := a; accu_val.acc_arg := [] |} in
  let ans := Obj.repr (accumulate acc) in
  let '_ := Obj.set_tag ans accumulate_tag in
  Obj.obj ans.

Definition get_accu (k : accumulator) : accu_val := (Obj.magic k) ret_accu.

Definition mk_rel_accu (i : Z) : t := mk_accu (Arel i).

Definition rel_tbl_size : Z := 100.

Definition rel_tbl : array t :=
  (|Util.Array|).(CArray.ExtS.init) rel_tbl_size mk_rel_accu.

Definition mk_rel_accu (i : Z) : t :=
  if OCaml.Stdlib.lt i rel_tbl_size then
    (|Util.Array|).(CArray.ExtS.get) rel_tbl i
  else
    mk_rel_accu i.

Definition mk_rels_accu (lvl : Z) (len : Z) : array t :=
  (|Util.Array|).(CArray.ExtS.init) len (fun i =&gt; mk_rel_accu (Z.add lvl i)).

Definition napply (f : t) (args : array t) : t :=
  (|Util.Array|).(CArray.ExtS.fold_left) (fun f =&gt; fun a =&gt; f a) f args.

Definition mk_constant_accu (kn : Names.Constant.t) (u : array Univ.Level.t)
  : t := mk_accu (Aconstant (kn, (Univ.Instance.of_array u))).

Definition mk_ind_accu (ind : Names.inductive) (u : array Univ.Level.t) : t :=
  mk_accu (Aind (ind, (Univ.Instance.of_array u))).

Definition mk_sort_accu (s : Sorts.t) (u : array Univ.Level.t) : t :=
  match s with
  | Sorts.SProp | Sorts.Prop | Sorts.__Set =&gt; mk_accu (Asort s)
  | Sorts.Type s =&gt;
    let u := Univ.Instance.of_array u in
    let s := Sorts.sort_of_univ (Univ.subst_instance_universe u s) in
    mk_accu (Asort s)
  end.

Definition mk_var_accu (id : Names.Id.t) : t := mk_accu (Avar id).

Definition mk_sw_accu (annot : annot_sw) (c : accumulator) (p : t) (ac : t -&gt; t)
  : t := mk_accu (Acase annot c p ac).

Definition mk_prod_accu (s : Names.Name.t) (dom : t) (codom : t -&gt; t) : t :=
  mk_accu (Aprod s dom codom).

Definition mk_meta_accu (mv : Constr.metavariable) (ty : t) : t :=
  mk_accu (Ameta mv ty).

Definition mk_evar_accu (ev : Evar.t) (args : array t) : t :=
  mk_accu (Aevar ev args).

Definition mk_proj_accu (kn : Names.inductive * Z) (c : accumulator) : t :=
  mk_accu (Aproj kn c).

Definition atom_of_accu (k : accumulator) : atom :=
  accu_val.acc_atm (get_accu k).

Definition set_atom_of_accu (k : accumulator) (a : atom) : unit :=
  (* ❌ Set record field not handled. *)
  set_record_field (get_accu k) &quot;acc_atm&quot; a.

Definition accu_nargs (k : accumulator) : Z :=
  (|Util.List|).(CList.ExtS.length) (accu_val.acc_arg (get_accu k)).

Definition args_of_accu (k : accumulator) : array t :=
  let acc := accu_val.acc_arg (get_accu k) in
  Obj.magic ((|Util.Array|).(CArray.ExtS.of_list) acc).

Definition mk_fix_accu
  (rec_pos : rec_pos) (pos : Z) (types : array t) (bodies : array t) : t :=
  mk_accu (Afix types bodies rec_pos pos).

Definition mk_cofix_accu (pos : Z) (types : array t) (norm : array t) : t :=
  mk_accu (Acofix types norm pos (Obj.magic 0)).

Definition upd_cofix (cofix : t) (cofix_fun : t) : unit :=
  let atom := atom_of_accu (Obj.magic cofix) in
  match atom with
  | Acofix typ norm pos _ =&gt;
    set_atom_of_accu (Obj.magic cofix) (Acofix typ norm pos cofix_fun)
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition force_cofix (cofix : t) : t :=
  let accu := Obj.magic cofix in
  let atom := atom_of_accu accu in
  match atom with
  | Acofix typ norm pos f =&gt;
    let args := args_of_accu accu in
    let f :=
      (|Util.Array|).(CArray.ExtS.fold_right) (fun arg =&gt; fun f =&gt; f arg) args f
      in
    let v := f (Obj.magic tt) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    v
  | Acofixe _ _ _ v =&gt; v
  | _ =&gt; cofix
  end.

Definition mk_const {A B : Set} (tag : A) : B := Obj.magic tag.

Definition mk_block {A : Set} (tag : Z) (args : array A) : t :=
  let nargs := (|Util.Array|).(CArray.ExtS.length) args in
  let r := Obj.new_block tag nargs in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Obj.magic r.

Definition dummy_value (function_parameter : unit) : t :=
  let '_ := function_parameter in
  fun function_parameter =&gt;
    let '_ := function_parameter in
    anomaly None (Some &quot;native&quot;) (Pp.str &quot;Evaluation failed.&quot;).

Definition cast_accu {A : Set} (v : A) : accumulator := Obj.magic v.

Definition mk_int (x : Z) : t := Obj.magic x.

Definition mk_bool (b : bool) : t := Obj.magic (negb b).

Definition mk_uint (x : Uint63.t) : t := Obj.magic x.

Parameter block : Set.

Definition block_size (b : block) : Z := Obj.size (Obj.magic b).

Definition block_field (b : block) (i : Z) : t :=
  Obj.magic (Obj.field (Obj.magic b) i).

Definition block_tag (b : block) : Z := Obj.tag (Obj.magic b).

Inductive kind_of_value : Set :=
| Vaccu : accumulator -&gt; kind_of_value
| Vfun : (t -&gt; t) -&gt; kind_of_value
| Vconst : Z -&gt; kind_of_value
| Vint64 : int64 -&gt; kind_of_value
| Vblock : block -&gt; kind_of_value.

Definition kind_of_value (v : t) : kind_of_value :=
  let o := Obj.repr v in
  if Obj.is_int o then
    Vconst (Obj.magic v)
  else
    let tag := Obj.tag o in
    if Int.equal tag accumulate_tag then
      Vaccu (Obj.magic v)
    else
      if Int.equal tag Obj.custom_tag then
        Vint64 (Obj.magic v)
      else
        if OCaml.Stdlib.lt tag Obj.lazy_tag then
          Vblock (Obj.magic v)
        else
          Vfun v.

Definition is_int (x : t) : bool :=
  let o := Obj.repr x in
  orb (Obj.is_int o) (Int.equal (Obj.tag o) Obj.custom_tag).

Definition val_to_int (x : t) : Z := Obj.magic x.

Definition to_uint (x : t) : Uint63.t := Obj.magic x.

Definition no_check_head0 (x : t) : t := mk_uint (Uint63.head0 (to_uint x)).

Definition head0 (accu : t -&gt; t) (x : t) : t :=
  if is_int x then
    no_check_head0 x
  else
    accu x.

Definition no_check_tail0 (x : t) : t := mk_uint (Uint63.tail0 (to_uint x)).

Definition tail0 (accu : t -&gt; t) (x : t) : t :=
  if is_int x then
    no_check_tail0 x
  else
    accu x.

Definition no_check_add (x : t) (y : t) : t :=
  mk_uint (Uint63.add (to_uint x) (to_uint y)).

Definition add (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_add x y
  else
    accu x y.

Definition no_check_sub (x : t) (y : t) : t :=
  mk_uint (Uint63.sub (to_uint x) (to_uint y)).

Definition sub (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_sub x y
  else
    accu x y.

Definition no_check_mul (x : t) (y : t) : t :=
  mk_uint (Uint63.mul (to_uint x) (to_uint y)).

Definition mul (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_mul x y
  else
    accu x y.

Definition no_check_div (x : t) (y : t) : t :=
  mk_uint (Uint63.div (to_uint x) (to_uint y)).

Definition div (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_div x y
  else
    accu x y.

Definition no_check_rem (x : t) (y : t) : t :=
  mk_uint (Uint63.rem (to_uint x) (to_uint y)).

Definition rem (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_rem x y
  else
    accu x y.

Definition no_check_l_sr (x : t) (y : t) : t :=
  mk_uint (Uint63.l_sr (to_uint x) (to_uint y)).

Definition l_sr (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_sr x y
  else
    accu x y.

Definition no_check_l_sl (x : t) (y : t) : t :=
  mk_uint (Uint63.l_sl (to_uint x) (to_uint y)).

Definition l_sl (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_sl x y
  else
    accu x y.

Definition no_check_l_and (x : t) (y : t) : t :=
  mk_uint (Uint63.l_and (to_uint x) (to_uint y)).

Definition l_and (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_and x y
  else
    accu x y.

Definition no_check_l_xor (x : t) (y : t) : t :=
  mk_uint (Uint63.l_xor (to_uint x) (to_uint y)).

Definition l_xor (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_xor x y
  else
    accu x y.

Definition no_check_l_or (x : t) (y : t) : t :=
  mk_uint (Uint63.l_or (to_uint x) (to_uint y)).

Definition l_or (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_l_or x y
  else
    accu x y.

Inductive coq_carry : Set :=
| Caccu : t -&gt; coq_carry
| C0 : t -&gt; coq_carry
| C1 : t -&gt; coq_carry.

Inductive coq_pair : Set :=
| Paccu : t -&gt; coq_pair
| PPair : t -&gt; t -&gt; coq_pair.

Definition mkCarry (b : bool) (i : Uint63.t) : t :=
  if b then
    Obj.magic (C1 (mk_uint i))
  else
    Obj.magic (C0 (mk_uint i)).

Definition no_check_addc (x : t) (y : t) : t :=
  let s := Uint63.add (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt s (to_uint x)) s.

Definition addc (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_addc x y
  else
    accu x y.

Definition no_check_subc (x : t) (y : t) : t :=
  let s := Uint63.sub (to_uint x) (to_uint y) in
  mkCarry (Uint63.lt (to_uint x) (to_uint y)) s.

Definition subc (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_subc x y
  else
    accu x y.

Definition no_check_addCarryC (x : t) (y : t) : t :=
  let s := Uint63.add (Uint63.add (to_uint x) (to_uint y)) (Uint63.of_int 1) in
  mkCarry (Uint63.le s (to_uint x)) s.

Definition addCarryC (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_addCarryC x y
  else
    accu x y.

Definition no_check_subCarryC (x : t) (y : t) : t :=
  let s := Uint63.sub (Uint63.sub (to_uint x) (to_uint y)) (Uint63.of_int 1) in
  mkCarry (Uint63.le (to_uint x) (to_uint y)) s.

Definition subCarryC (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_subCarryC x y
  else
    accu x y.

Definition of_pair (function_parameter : Uint63.t * Uint63.t) : t :=
  let '(x, y) := function_parameter in
  Obj.magic (PPair (mk_uint x) (mk_uint y)).

Definition no_check_mulc (x : t) (y : t) : t :=
  of_pair (Uint63.mulc (to_uint x) (to_uint y)).

Definition mulc (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_mulc x y
  else
    accu x y.

Definition no_check_diveucl (x : t) (y : t) : t :=
  let '(i1, i2) := ((to_uint x), (to_uint y)) in
  of_pair ((Uint63.div i1 i2), (Uint63.rem i1 i2)).

Definition diveucl (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_diveucl x y
  else
    accu x y.

Definition no_check_div21 (x : t) (y : t) (z : t) : t :=
  let '(i1, i2, i3) := ((to_uint x), (to_uint y), (to_uint z)) in
  of_pair (Uint63.div21 i1 i2 i3).

Definition div21 (accu : t -&gt; t -&gt; t -&gt; t) (x : t) (y : t) (z : t) : t :=
  if andb (is_int x) (andb (is_int y) (is_int z)) then
    no_check_div21 x y z
  else
    accu x y z.

Definition no_check_addMulDiv (x : t) (y : t) (z : t) : t :=
  let '(p, i, j) := ((to_uint x), (to_uint y), (to_uint z)) in
  mk_uint (Uint63.addmuldiv p i j).

Definition addMulDiv (accu : t -&gt; t -&gt; t -&gt; t) (x : t) (y : t) (z : t) : t :=
  if andb (is_int x) (andb (is_int y) (is_int z)) then
    no_check_addMulDiv x y z
  else
    accu x y z.

Inductive coq_bool : Set :=
| Baccu : t -&gt; coq_bool
| Btrue : coq_bool
| Bfalse : coq_bool.

Inductive coq_cmp : Set :=
| CmpAccu : t -&gt; coq_cmp
| CmpEq : coq_cmp
| CmpLt : coq_cmp
| CmpGt : coq_cmp.

Definition no_check_eq (x : t) (y : t) : t :=
  mk_bool (Uint63.equal (to_uint x) (to_uint y)).

Definition eq (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_eq x y
  else
    accu x y.

Definition no_check_lt (x : t) (y : t) : t :=
  mk_bool (Uint63.lt (to_uint x) (to_uint y)).

Definition lt (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_lt x y
  else
    accu x y.

Definition no_check_le (x : t) (y : t) : t :=
  mk_bool (Uint63.le (to_uint x) (to_uint y)).

Definition le (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_le x y
  else
    accu x y.

Definition no_check_compare (x : t) (y : t) : t :=
  match
    ((Uint63.compare (to_uint x) (to_uint y)),
      match Uint63.compare (to_uint x) (to_uint y) with
      | x =&gt; OCaml.Stdlib.lt x 0
      | _ =&gt; false
      end) with
  | (x, true) =&gt; Obj.magic CmpLt
  | (0, _) =&gt; Obj.magic CmpEq
  | (_, _) =&gt; Obj.magic CmpGt
  end.

Definition compare (accu : t -&gt; t -&gt; t) (x : t) (y : t) : t :=
  if andb (is_int x) (is_int y) then
    no_check_compare x y
  else
    accu x y.

Definition print (x : t) : t :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  x.

Definition hobcnv : array string :=
  (|Util.Array|).(CArray.ExtS.init) 256
    (fun i =&gt;
      Printf.sprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_x
            (CamlinternalFormatBasics.Lit_padding CamlinternalFormatBasics.Zeros
              2) CamlinternalFormatBasics.No_precision
            CamlinternalFormatBasics.End_of_format) &quot;%02x&quot;) i).

Definition bohcnv : array Z :=
  (|Util.Array|).(CArray.ExtS.init) 256
    (fun i =&gt;
      Z.sub
        (Z.sub
          (Z.sub i
            (if OCaml.Stdlib.le 48 i then
              48
            else
              0))
          (if OCaml.Stdlib.le 65 i then
            7
          else
            0))
        (if OCaml.Stdlib.le 97 i then
          32
        else
          0)).

Definition hex_of_bin (ch : ascii) : string :=
  (|Util.Array|).(CArray.ExtS.get) hobcnv (OCaml.Stdlib.int_of_char ch).

Definition bin_of_hex (s : string) : ascii :=
  OCaml.Stdlib.char_of_int
    (Z.add
      (Z.mul
        ((|Util.Array|).(CArray.ExtS.get) bohcnv
          (OCaml.Stdlib.int_of_char ((|Util.String|).(CString.ExtS.get) s 0)))
        16)
      ((|Util.Array|).(CArray.ExtS.get) bohcnv
        (OCaml.Stdlib.int_of_char ((|Util.String|).(CString.ExtS.get) s 1)))).

Definition str_encode {A : Set} (expr : A) : string :=
  let mshl_expr := Marshal.to_string expr [] in
  let payload :=
    Buffer.create (Z.mul ((|Util.String|).(CString.ExtS.length) mshl_expr) 2) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Buffer.contents payload.

Definition str_decode {A : Set} (s : string) : A :=
  let mshl_expr_len := Z.div ((|Util.String|).(CString.ExtS.length) s) 2 in
  let mshl_expr := Buffer.create mshl_expr_len in
  let buf := Stdlib.Bytes.create 2 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Marshal.from_bytes (Buffer.to_bytes mshl_expr) 0.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nativevalues.mli">
  <div style="margin: 20px;">
    <h3>Nativevalues_mli</h3>
    <ul>
      <li>OCaml size: 233 lines</li>
      <li>Coq size: 247 lines (+6% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nativevalues.mli"><code>nativevalues.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Constr
open Names

(** This modules defines the representation of values internally used by
the native compiler. Be careful when removing apparently dead code from this
interface, as it may be used by programs generated at runtime. *)

type t = t -&gt; t

type accumulator

type tag = int
type arity = int

type reloc_table = (tag * arity) array

type annot_sw = {
    asw_ind : inductive;
    asw_ci : case_info;
    asw_reloc : reloc_table;
    asw_finite : bool;
    asw_prefix : string
  }

val eq_annot_sw : annot_sw -&gt; annot_sw -&gt; bool

val hash_annot_sw : annot_sw -&gt; int

type sort_annot = string * int

type rec_pos = int array

val eq_rec_pos : rec_pos -&gt; rec_pos -&gt; bool

type atom =
  | Arel of int
  | Aconstant of pconstant
  | Aind of pinductive
  | Asort of Sorts.t
  | Avar of Id.t
  | Acase of annot_sw * accumulator * t * (t -&gt; t)
  | Afix of t array * t array * rec_pos * int
  | Acofix of t array * t array * int * t
  | Acofixe of t array * t array * int * t
  | Aprod of Name.t * t * (t -&gt; t)
  | Ameta of metavariable * t
  | Aevar of Evar.t * t array (* arguments *)
  | Aproj of (inductive * int) * accumulator

(* Constructors *)

val mk_accu : atom -&gt; t
val mk_rel_accu : int -&gt; t
val mk_rels_accu : int -&gt; int -&gt; t array
val mk_constant_accu : Constant.t -&gt; Univ.Level.t array -&gt; t
val mk_ind_accu : inductive -&gt; Univ.Level.t array -&gt; t
val mk_sort_accu : Sorts.t -&gt; Univ.Level.t array -&gt; t
val mk_var_accu : Id.t -&gt; t
val mk_sw_accu : annot_sw -&gt; accumulator -&gt; t -&gt; (t -&gt; t)
val mk_prod_accu : Name.t -&gt; t -&gt; t -&gt; t
val mk_fix_accu : rec_pos  -&gt; int -&gt; t array -&gt; t array -&gt; t
val mk_cofix_accu : int -&gt; t array -&gt; t array -&gt; t
val mk_meta_accu : metavariable -&gt; t
val mk_evar_accu : Evar.t -&gt; t array -&gt; t
val mk_proj_accu : (inductive * int) -&gt; accumulator -&gt; t
val upd_cofix : t -&gt; t -&gt; unit
val force_cofix : t -&gt; t
val mk_const : tag -&gt; t
val mk_block : tag -&gt; t array -&gt; t

val mk_bool : bool -&gt; t
[@@ocaml.inline always]

val mk_int : int -&gt; t
[@@ocaml.inline always]

val mk_uint : Uint63.t -&gt; t
[@@ocaml.inline always]

val napply : t -&gt; t array -&gt; t
(* Functions over accumulators *)

val dummy_value : unit -&gt; t
val atom_of_accu : accumulator -&gt; atom
val args_of_accu : accumulator -&gt; t array
val accu_nargs : accumulator -&gt; int

val cast_accu : t -&gt; accumulator
[@@ocaml.inline always]

(* Functions over block: i.e constructors *)

type block

val block_size : block -&gt; int
val block_field : block -&gt; int -&gt; t
val block_tag : block -&gt; int



(* kind_of_value *)

type kind_of_value =
  | Vaccu of accumulator
  | Vfun of (t -&gt; t)
  | Vconst of int
  | Vint64 of int64
  | Vblock of block

val kind_of_value : t -&gt; kind_of_value

val str_encode : 'a -&gt; string
val str_decode : string -&gt; 'a

(** Support for machine integers *)

val val_to_int : t -&gt; int
val is_int : t -&gt; bool

(* function with check *)
val head0 : t -&gt; t -&gt; t
val tail0 : t -&gt; t -&gt; t

val add : t -&gt; t -&gt; t -&gt; t
val sub : t -&gt; t -&gt; t -&gt; t
val mul : t -&gt; t -&gt; t -&gt; t
val div : t -&gt; t -&gt; t -&gt; t
val rem : t -&gt; t -&gt; t -&gt; t

val l_sr  : t -&gt; t -&gt; t -&gt; t
val l_sl  : t -&gt; t -&gt; t -&gt; t
val l_and : t -&gt; t -&gt; t -&gt; t
val l_xor : t -&gt; t -&gt; t -&gt; t
val l_or  : t -&gt; t -&gt; t -&gt; t

val addc      : t -&gt; t -&gt; t -&gt; t
val subc      : t -&gt; t -&gt; t -&gt; t
val addCarryC : t -&gt; t -&gt; t -&gt; t
val subCarryC : t -&gt; t -&gt; t -&gt; t

val mulc    : t -&gt; t -&gt; t -&gt; t
val diveucl : t -&gt; t -&gt; t -&gt; t

val div21     : t -&gt; t -&gt; t -&gt; t -&gt; t
val addMulDiv : t -&gt; t -&gt; t -&gt; t -&gt; t

val eq      : t -&gt; t -&gt; t -&gt; t
val lt      : t -&gt; t -&gt; t -&gt; t
val le      : t -&gt; t -&gt; t -&gt; t
val compare : t -&gt; t -&gt; t -&gt; t

val print : t -&gt; t

(* Function without check *)
val no_check_head0 : t -&gt; t
[@@ocaml.inline always]

val no_check_tail0 : t -&gt; t
[@@ocaml.inline always]

val no_check_add : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_sub : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_mul : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_div : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_rem : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_l_sr  : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_l_sl  : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_l_and : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_l_xor : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_l_or  : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_addc      : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_subc      : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_addCarryC : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_subCarryC : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_mulc    : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_diveucl : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_div21     : t -&gt; t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_addMulDiv : t -&gt; t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_eq      : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_lt      : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_le      : t -&gt; t -&gt; t
[@@ocaml.inline always]

val no_check_compare : t -&gt; t -&gt; t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nativevalues.mli"><code>Nativevalues_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition t := t -&gt; t.

Parameter accumulator : Set.

Definition tag := Z.

Definition arity := Z.

Definition reloc_table := array (tag * arity).

Module annot_sw.
  Record record := {
    asw_ind : Names.inductive;
    asw_ci : Constr.case_info;
    asw_reloc : reloc_table;
    asw_finite : bool;
    asw_prefix : string }.
  Definition with_asw_ind (r : record) asw_ind : record :=
    {| asw_ind := asw_ind; asw_ci := asw_ci r; asw_reloc := asw_reloc r;
      asw_finite := asw_finite r; asw_prefix := asw_prefix r |}.
  Definition with_asw_ci (r : record) asw_ci : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci; asw_reloc := asw_reloc r;
      asw_finite := asw_finite r; asw_prefix := asw_prefix r |}.
  Definition with_asw_reloc (r : record) asw_reloc : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci r; asw_reloc := asw_reloc;
      asw_finite := asw_finite r; asw_prefix := asw_prefix r |}.
  Definition with_asw_finite (r : record) asw_finite : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci r; asw_reloc := asw_reloc r;
      asw_finite := asw_finite; asw_prefix := asw_prefix r |}.
  Definition with_asw_prefix (r : record) asw_prefix : record :=
    {| asw_ind := asw_ind r; asw_ci := asw_ci r; asw_reloc := asw_reloc r;
      asw_finite := asw_finite r; asw_prefix := asw_prefix |}.
End annot_sw.
Definition annot_sw := annot_sw.record.

Parameter eq_annot_sw : annot_sw -&gt; annot_sw -&gt; bool.

Parameter hash_annot_sw : annot_sw -&gt; Z.

Definition sort_annot := string * Z.

Definition rec_pos := array Z.

Parameter eq_rec_pos : rec_pos -&gt; rec_pos -&gt; bool.

Inductive atom : Set :=
| Arel : Z -&gt; atom
| Aconstant : Constr.pconstant -&gt; atom
| Aind : Constr.pinductive -&gt; atom
| Asort : Sorts.t -&gt; atom
| Avar : Names.Id.t -&gt; atom
| Acase : annot_sw -&gt; accumulator -&gt; t -&gt; (t -&gt; t) -&gt; atom
| Afix : array t -&gt; array t -&gt; rec_pos -&gt; Z -&gt; atom
| Acofix : array t -&gt; array t -&gt; Z -&gt; t -&gt; atom
| Acofixe : array t -&gt; array t -&gt; Z -&gt; t -&gt; atom
| Aprod : Names.Name.t -&gt; t -&gt; (t -&gt; t) -&gt; atom
| Ameta : Constr.metavariable -&gt; t -&gt; atom
| Aevar : Evar.t -&gt; array t -&gt; atom
| Aproj : Names.inductive * Z -&gt; accumulator -&gt; atom.

Parameter mk_accu : atom -&gt; t.

Parameter mk_rel_accu : Z -&gt; t.

Parameter mk_rels_accu : Z -&gt; Z -&gt; array t.

Parameter mk_constant_accu : Names.Constant.t -&gt; array Univ.Level.t -&gt; t.

Parameter mk_ind_accu : Names.inductive -&gt; array Univ.Level.t -&gt; t.

Parameter mk_sort_accu : Sorts.t -&gt; array Univ.Level.t -&gt; t.

Parameter mk_var_accu : Names.Id.t -&gt; t.

Parameter mk_sw_accu : annot_sw -&gt; accumulator -&gt; t -&gt; t -&gt; t.

Parameter mk_prod_accu : Names.Name.t -&gt; t -&gt; t -&gt; t.

Parameter mk_fix_accu : rec_pos -&gt; Z -&gt; array t -&gt; array t -&gt; t.

Parameter mk_cofix_accu : Z -&gt; array t -&gt; array t -&gt; t.

Parameter mk_meta_accu : Constr.metavariable -&gt; t.

Parameter mk_evar_accu : Evar.t -&gt; array t -&gt; t.

Parameter mk_proj_accu : Names.inductive * Z -&gt; accumulator -&gt; t.

Parameter upd_cofix : t -&gt; t -&gt; unit.

Parameter force_cofix : t -&gt; t.

Parameter mk_const : tag -&gt; t.

Parameter mk_block : tag -&gt; array t -&gt; t.

Parameter mk_bool : bool -&gt; t.

Parameter mk_int : Z -&gt; t.

Parameter mk_uint : Uint63.t -&gt; t.

Parameter napply : t -&gt; array t -&gt; t.

Parameter dummy_value : unit -&gt; t.

Parameter atom_of_accu : accumulator -&gt; atom.

Parameter args_of_accu : accumulator -&gt; array t.

Parameter accu_nargs : accumulator -&gt; Z.

Parameter cast_accu : t -&gt; accumulator.

Parameter block : Set.

Parameter block_size : block -&gt; Z.

Parameter block_field : block -&gt; Z -&gt; t.

Parameter block_tag : block -&gt; Z.

Inductive kind_of_value : Set :=
| Vaccu : accumulator -&gt; kind_of_value
| Vfun : (t -&gt; t) -&gt; kind_of_value
| Vconst : Z -&gt; kind_of_value
| Vint64 : int64 -&gt; kind_of_value
| Vblock : block -&gt; kind_of_value.

Parameter kind_of_value : t -&gt; kind_of_value.

Parameter str_encode : forall {a : Set}, a -&gt; string.

Parameter str_decode : forall {a : Set}, string -&gt; a.

Parameter val_to_int : t -&gt; Z.

Parameter is_int : t -&gt; bool.

Parameter head0 : t -&gt; t -&gt; t.

Parameter tail0 : t -&gt; t -&gt; t.

Parameter add : t -&gt; t -&gt; t -&gt; t.

Parameter sub : t -&gt; t -&gt; t -&gt; t.

Parameter mul : t -&gt; t -&gt; t -&gt; t.

Parameter div : t -&gt; t -&gt; t -&gt; t.

Parameter rem : t -&gt; t -&gt; t -&gt; t.

Parameter l_sr : t -&gt; t -&gt; t -&gt; t.

Parameter l_sl : t -&gt; t -&gt; t -&gt; t.

Parameter l_and : t -&gt; t -&gt; t -&gt; t.

Parameter l_xor : t -&gt; t -&gt; t -&gt; t.

Parameter l_or : t -&gt; t -&gt; t -&gt; t.

Parameter addc : t -&gt; t -&gt; t -&gt; t.

Parameter subc : t -&gt; t -&gt; t -&gt; t.

Parameter addCarryC : t -&gt; t -&gt; t -&gt; t.

Parameter subCarryC : t -&gt; t -&gt; t -&gt; t.

Parameter mulc : t -&gt; t -&gt; t -&gt; t.

Parameter diveucl : t -&gt; t -&gt; t -&gt; t.

Parameter div21 : t -&gt; t -&gt; t -&gt; t -&gt; t.

Parameter addMulDiv : t -&gt; t -&gt; t -&gt; t -&gt; t.

Parameter eq : t -&gt; t -&gt; t -&gt; t.

Parameter lt : t -&gt; t -&gt; t -&gt; t.

Parameter le : t -&gt; t -&gt; t -&gt; t.

Parameter compare : t -&gt; t -&gt; t -&gt; t.

Parameter print : t -&gt; t.

Parameter no_check_head0 : t -&gt; t.

Parameter no_check_tail0 : t -&gt; t.

Parameter no_check_add : t -&gt; t -&gt; t.

Parameter no_check_sub : t -&gt; t -&gt; t.

Parameter no_check_mul : t -&gt; t -&gt; t.

Parameter no_check_div : t -&gt; t -&gt; t.

Parameter no_check_rem : t -&gt; t -&gt; t.

Parameter no_check_l_sr : t -&gt; t -&gt; t.

Parameter no_check_l_sl : t -&gt; t -&gt; t.

Parameter no_check_l_and : t -&gt; t -&gt; t.

Parameter no_check_l_xor : t -&gt; t -&gt; t.

Parameter no_check_l_or : t -&gt; t -&gt; t.

Parameter no_check_addc : t -&gt; t -&gt; t.

Parameter no_check_subc : t -&gt; t -&gt; t.

Parameter no_check_addCarryC : t -&gt; t -&gt; t.

Parameter no_check_subCarryC : t -&gt; t -&gt; t.

Parameter no_check_mulc : t -&gt; t -&gt; t.

Parameter no_check_diveucl : t -&gt; t -&gt; t.

Parameter no_check_div21 : t -&gt; t -&gt; t -&gt; t.

Parameter no_check_addMulDiv : t -&gt; t -&gt; t -&gt; t.

Parameter no_check_eq : t -&gt; t -&gt; t.

Parameter no_check_lt : t -&gt; t -&gt; t.

Parameter no_check_le : t -&gt; t -&gt; t.

Parameter no_check_compare : t -&gt; t -&gt; t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="opaqueproof.ml">
  <div style="margin: 20px;">
    <h3>Opaqueproof</h3>
    <ul>
      <li>OCaml size: 166 lines</li>
      <li>Coq size: 282 lines (+69% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#opaqueproof.ml"><code>opaqueproof.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Univ
open Constr
open Mod_subst

type work_list = (Instance.t * Id.t array) Cmap.t *
  (Instance.t * Id.t array) Mindmap.t

type cooking_info = {
  modlist : work_list;
  abstract : Constr.named_context * Univ.Instance.t * Univ.AUContext.t }
type proofterm = (constr * Univ.ContextSet.t) Future.computation
type opaque =
  | Indirect of substitution list * DirPath.t * int (* subst, lib, index *)
  | Direct of cooking_info list * proofterm
type opaquetab = {
  opaque_val : (cooking_info list * proofterm) Int.Map.t;
  (** Actual proof terms *)
  opaque_len : int;
  (** Size of the above map *)
  opaque_dir : DirPath.t;
}
let empty_opaquetab = {
  opaque_val = Int.Map.empty;
  opaque_len = 0;
  opaque_dir = DirPath.initial;
}

(* hooks *)
let default_get_opaque dp _ =
  CErrors.user_err Pp.(pr_sequence str [&quot;Cannot access opaque proofs in library&quot;; DirPath.to_string dp])
let default_get_univ dp _ =
  CErrors.user_err (Pp.pr_sequence Pp.str [
    &quot;Cannot access universe constraints of opaque proofs in library &quot;;
    DirPath.to_string dp])

let get_opaque = ref default_get_opaque
let get_univ = ref default_get_univ

let set_indirect_opaque_accessor f = (get_opaque := f)
let set_indirect_univ_accessor f = (get_univ := f)
(* /hooks *)

let create cu = Direct ([],cu)

let turn_indirect dp o tab = match o with
  | Indirect (_,_,i) -&gt;
      if not (Int.Map.mem i tab.opaque_val)
      then CErrors.anomaly (Pp.str &quot;Indirect in a different table.&quot;)
      else CErrors.anomaly (Pp.str &quot;Already an indirect opaque.&quot;)
  | Direct (d,cu) -&gt;
    (* Invariant: direct opaques only exist inside sections, we turn them
      indirect as soon as we are at toplevel. At this moment, we perform
      hashconsing of their contents, potentially as a future. *)
      let hcons (c, u) =
        let c = Constr.hcons c in
        let u = Univ.hcons_universe_context_set u in
        (c, u)
      in
      let cu = Future.chain cu hcons in
      let id = tab.opaque_len in
      let opaque_val = Int.Map.add id (d,cu) tab.opaque_val in
      let opaque_dir =
        if DirPath.equal dp tab.opaque_dir then tab.opaque_dir
        else if DirPath.equal tab.opaque_dir DirPath.initial then dp
        else CErrors.anomaly
          (Pp.str &quot;Using the same opaque table for multiple dirpaths.&quot;) in
      let ntab = { opaque_val; opaque_dir; opaque_len = id + 1 } in
      Indirect ([],dp,id), ntab

let subst_opaque sub = function
  | Indirect (s,dp,i) -&gt; Indirect (sub::s,dp,i)
  | Direct _ -&gt; CErrors.anomaly (Pp.str &quot;Substituting a Direct opaque.&quot;)

let iter_direct_opaque f = function
  | Indirect _ -&gt; CErrors.anomaly (Pp.str &quot;Not a direct opaque.&quot;)
  | Direct (d,cu) -&gt;
      Direct (d,Future.chain cu (fun (c, u) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">f c; c, u</abbr>))

let discharge_direct_opaque ~cook_constr ci = function
  | Indirect _ -&gt; CErrors.anomaly (Pp.str &quot;Not a direct opaque.&quot;)
  | Direct (d,cu) -&gt;
      Direct (ci::d,Future.chain cu (fun (c, u) -&gt; cook_constr c, u))

let join_opaque { opaque_val = prfs; opaque_dir = odp; _ } = function
  | Direct (_,cu) -&gt; ignore(Future.join cu)
  | Indirect (_,dp,i) -&gt;
      if DirPath.equal dp odp then
        let fp = snd (Int.Map.find i prfs) in
        ignore(Future.join fp)

let uuid_opaque { opaque_val = prfs; opaque_dir = odp; _ } = function
  | Direct (_,cu) -&gt; Some (Future.uuid cu)
  | Indirect (_,dp,i) -&gt;
      if DirPath.equal dp odp
      then Some (Future.uuid (snd (Int.Map.find i prfs)))
      else None

let force_proof { opaque_val = prfs; opaque_dir = odp; _ } = function
  | Direct (_,cu) -&gt;
      fst(Future.force cu)
  | Indirect (l,dp,i) -&gt;
      let pt =
        if DirPath.equal dp odp
        then Future.chain (snd (Int.Map.find i prfs)) fst
        else !get_opaque dp i in
      let c = Future.force pt in
      force_constr (List.fold_right subst_substituted l (from_val c))

let force_constraints { opaque_val = prfs; opaque_dir = odp; _ } = function
  | Direct (_,cu) -&gt; snd(Future.force cu)
  | Indirect (_,dp,i) -&gt;
      if DirPath.equal dp odp
      then snd (Future.force (snd (Int.Map.find i prfs)))
      else match !get_univ dp i with
        | None -&gt; Univ.ContextSet.empty
        | Some u -&gt; Future.force u

let get_constraints { opaque_val = prfs; opaque_dir = odp; _ } = function
  | Direct (_,cu) -&gt; Some(Future.chain cu snd)
  | Indirect (_,dp,i) -&gt;
      if DirPath.equal dp odp
      then Some(Future.chain (snd (Int.Map.find i prfs)) snd)
      else !get_univ dp i

let get_proof { opaque_val = prfs; opaque_dir = odp; _ } = function
  | Direct (_,cu) -&gt; Future.chain cu fst
  | Indirect (l,dp,i) -&gt;
      let pt =
        if DirPath.equal dp odp
        then Future.chain (snd (Int.Map.find i prfs)) fst
        else !get_opaque dp i in
      Future.chain pt (fun c -&gt;
        force_constr (List.fold_right subst_substituted l (from_val c)))

module FMap = Future.UUIDMap

let a_constr = Future.from_val (mkRel 1)
let a_univ = Future.from_val Univ.ContextSet.empty
let a_discharge : cooking_info list = []

let dump { opaque_val = otab; opaque_len = n; _ } =
  let opaque_table = Array.make n a_constr in
  let univ_table = Array.make n a_univ in
  let disch_table = Array.make n a_discharge in
  let f2t_map = ref FMap.empty in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Int.Map.iter (fun n (d,cu) -&gt;
    let c, u = Future.split2 cu in
    Future.sink u;
    Future.sink c;
    opaque_table.(n) &lt;- c;
    univ_table.(n) &lt;- u;
    disch_table.(n) &lt;- d;
    f2t_map := FMap.add (Future.uuid cu) n !f2t_map)
  otab;
  opaque_table, univ_table, disch_table, !f2t_map</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#opaqueproof.ml"><code>Opaqueproof.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Univ.

Import Constr.

Import Mod_subst.

Definition work_list :=
  Names.Cmap.t (Univ.Instance.t * array Names.Id.t) *
    Names.Mindmap.t (Univ.Instance.t * array Names.Id.t).

Module cooking_info.
  Record record := {
    modlist : work_list;
    abstract : Constr.named_context * Univ.Instance.t * Univ.AUContext.t }.
  Definition with_modlist (r : record) modlist : record :=
    {| modlist := modlist; abstract := abstract r |}.
  Definition with_abstract (r : record) abstract : record :=
    {| modlist := modlist r; abstract := abstract |}.
End cooking_info.
Definition cooking_info := cooking_info.record.

Definition proofterm := Future.computation (Constr.constr * Univ.ContextSet.t).

Inductive opaque : Set :=
| Indirect : list Mod_subst.substitution -&gt; Names.DirPath.t -&gt; Z -&gt; opaque
| Direct : list cooking_info -&gt; proofterm -&gt; opaque.

Module opaquetab.
  Record record := {
    opaque_val : Int.Map.t (list cooking_info * proofterm);
    opaque_len : Z;
    opaque_dir : Names.DirPath.t }.
  Definition with_opaque_val (r : record) opaque_val : record :=
    {| opaque_val := opaque_val; opaque_len := opaque_len r;
      opaque_dir := opaque_dir r |}.
  Definition with_opaque_len (r : record) opaque_len : record :=
    {| opaque_val := opaque_val r; opaque_len := opaque_len;
      opaque_dir := opaque_dir r |}.
  Definition with_opaque_dir (r : record) opaque_dir : record :=
    {| opaque_val := opaque_val r; opaque_len := opaque_len r;
      opaque_dir := opaque_dir |}.
End opaquetab.
Definition opaquetab := opaquetab.record.

Definition empty_opaquetab : opaquetab :=
  {| opaquetab.opaque_val := Int.Map.empty; opaquetab.opaque_len := 0;
    opaquetab.opaque_dir := DirPath.initial |}.

Definition default_get_opaque {A B : Set}
  (dp : Names.DirPath.t) (function_parameter : A) : B :=
  let '_ := function_parameter in
  CErrors.user_err None None
    (pr_sequence str
      [ &quot;Cannot access opaque proofs in library&quot;; DirPath.to_string dp ]).

Definition default_get_univ {A B : Set}
  (dp : Names.DirPath.t) (function_parameter : A) : B :=
  let '_ := function_parameter in
  CErrors.user_err None None
    (Pp.pr_sequence Pp.str
      [
        &quot;Cannot access universe constraints of opaque proofs in library &quot;;
        DirPath.to_string dp
      ]).

Definition get_opaque
  : Stdlib.ref (Names.DirPath.t -&gt; Z -&gt; Future.computation Constr.constr) :=
  Stdlib.__ref_value default_get_opaque.

Definition get_univ
  : Stdlib.ref
    (Names.DirPath.t -&gt; Z -&gt; option (Future.computation Univ.ContextSet.t)) :=
  Stdlib.__ref_value default_get_univ.

Definition set_indirect_opaque_accessor
  (f : Names.DirPath.t -&gt; Z -&gt; Future.computation Constr.constr) : unit :=
  Stdlib.op_coloneq get_opaque f.

Definition set_indirect_univ_accessor
  (f : Names.DirPath.t -&gt; Z -&gt; option (Future.computation Univ.ContextSet.t))
  : unit := Stdlib.op_coloneq get_univ f.

Definition create (cu : proofterm) : opaque := Direct [] cu.

Definition turn_indirect (dp : Names.DirPath.t) (o : opaque) (tab : opaquetab)
  : opaque * opaquetab :=
  match o with
  | Indirect _ _ i =&gt;
    if negb (Int.Map.mem i (opaquetab.opaque_val tab)) then
      CErrors.anomaly None None (Pp.str &quot;Indirect in a different table.&quot;)
    else
      CErrors.anomaly None None (Pp.str &quot;Already an indirect opaque.&quot;)
  | Direct d cu =&gt;
    let hcons (function_parameter : Constr.constr * Univ.ContextSet.t)
      : Constr.constr * Univ.ContextSet.t :=
      let '(c, u) := function_parameter in
      let c := Constr.hcons c in
      let u := Univ.hcons_universe_context_set u in
      (c, u) in
    let cu := Future.chain cu hcons in
    let id := opaquetab.opaque_len tab in
    let opaque_val := Int.Map.add id (d, cu) (opaquetab.opaque_val tab) in
    let opaque_dir :=
      if DirPath.equal dp (opaquetab.opaque_dir tab) then
        opaquetab.opaque_dir tab
      else
        if DirPath.equal (opaquetab.opaque_dir tab) DirPath.initial then
          dp
        else
          CErrors.anomaly None None
            (Pp.str &quot;Using the same opaque table for multiple dirpaths.&quot;) in
    let ntab :=
      {| opaquetab.opaque_val := opaque_val; opaquetab.opaque_len := Z.add id 1;
        opaquetab.opaque_dir := opaque_dir |} in
    ((Indirect [] dp id), ntab)
  end.

Definition subst_opaque
  (sub : Mod_subst.substitution) (function_parameter : opaque) : opaque :=
  match function_parameter with
  | Indirect s dp i =&gt; Indirect (cons sub s) dp i
  | Direct _ _ =&gt;
    CErrors.anomaly None None (Pp.str &quot;Substituting a Direct opaque.&quot;)
  end.

Definition iter_direct_opaque {A : Set}
  (f : Constr.constr -&gt; A) (function_parameter : opaque) : opaque :=
  match function_parameter with
  | Indirect _ _ _ =&gt; CErrors.anomaly None None (Pp.str &quot;Not a direct opaque.&quot;)
  | Direct d cu =&gt;
    Direct d
      (Future.chain cu
        (fun function_parameter =&gt;
          let '(c, u) := function_parameter in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (c, u)))
  end.

Definition discharge_direct_opaque
  (cook_constr : Constr.constr -&gt; Constr.constr) (ci : cooking_info)
  (function_parameter : opaque) : opaque :=
  match function_parameter with
  | Indirect _ _ _ =&gt; CErrors.anomaly None None (Pp.str &quot;Not a direct opaque.&quot;)
  | Direct d cu =&gt;
    Direct (cons ci d)
      (Future.chain cu
        (fun function_parameter =&gt;
          let '(c, u) := function_parameter in
          ((cook_constr c), u)))
  end.

Definition join_opaque (function_parameter : opaquetab) : opaque -&gt; unit :=
  let '{| opaquetab.opaque_val := prfs; opaquetab.opaque_dir := odp |} :=
    function_parameter in
  fun function_parameter =&gt;
    match function_parameter with
    | Direct _ cu =&gt; OCaml.Stdlib.ignore (Future.join cu)
    | Indirect _ dp i =&gt;
      if DirPath.equal dp odp then
        let fp := snd (Int.Map.find i prfs) in
        OCaml.Stdlib.ignore (Future.join fp)
      else
        tt
    end.

Definition uuid_opaque (function_parameter : opaquetab)
  : opaque -&gt; option Future.UUID.t :=
  let '{| opaquetab.opaque_val := prfs; opaquetab.opaque_dir := odp |} :=
    function_parameter in
  fun function_parameter =&gt;
    match function_parameter with
    | Direct _ cu =&gt; Some (Future.uuid cu)
    | Indirect _ dp i =&gt;
      if DirPath.equal dp odp then
        Some (Future.uuid (snd (Int.Map.find i prfs)))
      else
        None
    end.

Definition force_proof (function_parameter : opaquetab)
  : opaque -&gt; Constr.constr :=
  let '{| opaquetab.opaque_val := prfs; opaquetab.opaque_dir := odp |} :=
    function_parameter in
  fun function_parameter =&gt;
    match function_parameter with
    | Direct _ cu =&gt; fst (Future.force cu)
    | Indirect l dp i =&gt;
      let pt :=
        if DirPath.equal dp odp then
          Future.chain (snd (Int.Map.find i prfs)) fst
        else
          (Stdlib.op_exclamation get_opaque) dp i in
      let c := Future.force pt in
      force_constr (Stdlib.List.fold_right subst_substituted l (from_val c))
    end.

Definition force_constraints (function_parameter : opaquetab)
  : opaque -&gt; Univ.ContextSet.t :=
  let '{| opaquetab.opaque_val := prfs; opaquetab.opaque_dir := odp |} :=
    function_parameter in
  fun function_parameter =&gt;
    match function_parameter with
    | Direct _ cu =&gt; snd (Future.force cu)
    | Indirect _ dp i =&gt;
      if DirPath.equal dp odp then
        snd (Future.force (snd (Int.Map.find i prfs)))
      else
        match (Stdlib.op_exclamation get_univ) dp i with
        | None =&gt; Univ.ContextSet.empty
        | Some u =&gt; Future.force u
        end
    end.

Definition get_constraints (function_parameter : opaquetab)
  : opaque -&gt; option (Future.computation Univ.ContextSet.t) :=
  let '{| opaquetab.opaque_val := prfs; opaquetab.opaque_dir := odp |} :=
    function_parameter in
  fun function_parameter =&gt;
    match function_parameter with
    | Direct _ cu =&gt; Some (Future.chain cu snd)
    | Indirect _ dp i =&gt;
      if DirPath.equal dp odp then
        Some (Future.chain (snd (Int.Map.find i prfs)) snd)
      else
        (Stdlib.op_exclamation get_univ) dp i
    end.

Definition get_proof (function_parameter : opaquetab)
  : opaque -&gt; Future.computation Constr.constr :=
  let '{| opaquetab.opaque_val := prfs; opaquetab.opaque_dir := odp |} :=
    function_parameter in
  fun function_parameter =&gt;
    match function_parameter with
    | Direct _ cu =&gt; Future.chain cu fst
    | Indirect l dp i =&gt;
      let pt :=
        if DirPath.equal dp odp then
          Future.chain (snd (Int.Map.find i prfs)) fst
        else
          (Stdlib.op_exclamation get_opaque) dp i in
      Future.chain pt
        (fun c =&gt;
          force_constr (Stdlib.List.fold_right subst_substituted l (from_val c)))
    end.

Module FMap := Future.UUIDMap.

Definition a_constr : Future.computation Constr.constr :=
  Future.from_val None (mkRel 1).

Definition a_univ : Future.computation Univ.ContextSet.t :=
  Future.from_val None Univ.ContextSet.empty.

Definition a_discharge : list cooking_info := [].

Definition dump (function_parameter : opaquetab)
  : array (Future.computation Constr.constr) *
    array (Future.computation Univ.ContextSet.t) * array (list cooking_info) *
    FMap.t Int.Map.key :=
  let '{| opaquetab.opaque_val := otab; opaquetab.opaque_len := n |} :=
    function_parameter in
  let opaque_table := Array.make n a_constr in
  let univ_table := Array.make n a_univ in
  let disch_table := Array.make n a_discharge in
  let f2t_map := Stdlib.__ref_value FMap.empty in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (opaque_table, univ_table, disch_table, (Stdlib.op_exclamation f2t_map)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="opaqueproof.mli">
  <div style="margin: 20px;">
    <h3>Opaqueproof_mli</h3>
    <ul>
      <li>OCaml size: 82 lines</li>
      <li>Coq size: 71 lines (-14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#opaqueproof.mli"><code>opaqueproof.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Mod_subst

(** This module implements the handling of opaque proof terms.
    Opaque proof terms are special since:
    - they can be lazily computed and substituted
    - they are stored in an optionally loaded segment of .vo files
    An [opaque] proof terms holds the real data until fully discharged.
    In this case it is called [direct].
    When it is [turn_indirect] the data is relocated to an opaque table
    and the [opaque] is turned into an index. *)

type proofterm = (constr * Univ.ContextSet.t) Future.computation
type opaquetab
type opaque

val empty_opaquetab : opaquetab

(** From a [proofterm] to some [opaque]. *)
val create : proofterm -&gt; opaque

(** Turn a direct [opaque] into an indirect one. It is your responsibility to
  hashcons the inner term beforehand. The integer is an hint of the maximum id
  used so far *)
val turn_indirect : DirPath.t -&gt; opaque -&gt; opaquetab -&gt; opaque * opaquetab

(** From a [opaque] back to a [constr]. This might use the
    indirect opaque accessor configured below. *)
val force_proof : opaquetab -&gt; opaque -&gt; constr
val force_constraints : opaquetab -&gt; opaque -&gt; Univ.ContextSet.t
val get_proof : opaquetab -&gt; opaque -&gt; constr Future.computation
val get_constraints :
  opaquetab -&gt; opaque -&gt; Univ.ContextSet.t Future.computation option

val subst_opaque : substitution -&gt; opaque -&gt; opaque
val iter_direct_opaque : (constr -&gt; unit) -&gt; opaque -&gt; opaque

type work_list = (Univ.Instance.t * Id.t array) Cmap.t *
  (Univ.Instance.t * Id.t array) Mindmap.t

type cooking_info = {
  modlist : work_list;
  abstract : Constr.named_context * Univ.Instance.t * Univ.AUContext.t }

(* The type has two caveats:
   1) cook_constr is defined after
   2) we have to store the input in the [opaque] in order to be able to
      discharge it when turning a .vi into a .vo *)
val discharge_direct_opaque :
  cook_constr:(constr -&gt; constr) -&gt; cooking_info -&gt; opaque -&gt; opaque

val uuid_opaque : opaquetab -&gt; opaque -&gt; Future.UUID.t option
val join_opaque : opaquetab -&gt; opaque -&gt; unit

val dump : opaquetab -&gt;
  Constr.t Future.computation array *
  Univ.ContextSet.t Future.computation array *
  cooking_info list array *
  int Future.UUIDMap.t

(** When stored indirectly, opaque terms are indexed by their library
    dirpath and an integer index. The following two functions activate
    this indirect storage, by telling how to store and retrieve terms.
    Default creator always returns [None], preventing the creation of
    any indirect link, and default accessor always raises an error.
*)

val set_indirect_opaque_accessor :
  (DirPath.t -&gt; int -&gt; constr Future.computation) -&gt; unit
val set_indirect_univ_accessor :
  (DirPath.t -&gt; int -&gt; Univ.ContextSet.t Future.computation option) -&gt; unit

</pre>
  </div>
  <div class="col-md-6">
    <a href="#opaqueproof.mli"><code>Opaqueproof_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition proofterm := Future.computation (Constr.constr * Univ.ContextSet.t).

Parameter opaquetab : Set.

Parameter opaque : Set.

Parameter empty_opaquetab : opaquetab.

Parameter create : proofterm -&gt; opaque.

Parameter turn_indirect :
  Names.DirPath.t -&gt; opaque -&gt; opaquetab -&gt; opaque * opaquetab.

Parameter force_proof : opaquetab -&gt; opaque -&gt; Constr.constr.

Parameter force_constraints : opaquetab -&gt; opaque -&gt; Univ.ContextSet.t.

Parameter get_proof : opaquetab -&gt; opaque -&gt; Future.computation Constr.constr.

Parameter get_constraints :
  opaquetab -&gt; opaque -&gt; option (Future.computation Univ.ContextSet.t).

Parameter subst_opaque : Mod_subst.substitution -&gt; opaque -&gt; opaque.

Parameter iter_direct_opaque : (Constr.constr -&gt; unit) -&gt; opaque -&gt; opaque.

Definition work_list :=
  Names.Cmap.t (Univ.Instance.t * array Names.Id.t) *
    Names.Mindmap.t (Univ.Instance.t * array Names.Id.t).

Module cooking_info.
  Record record := {
    modlist : work_list;
    abstract : Constr.named_context * Univ.Instance.t * Univ.AUContext.t }.
  Definition with_modlist (r : record) modlist : record :=
    {| modlist := modlist; abstract := abstract r |}.
  Definition with_abstract (r : record) abstract : record :=
    {| modlist := modlist r; abstract := abstract |}.
End cooking_info.
Definition cooking_info := cooking_info.record.

Parameter discharge_direct_opaque :
  (Constr.constr -&gt; Constr.constr) -&gt; cooking_info -&gt; opaque -&gt; opaque.

Parameter uuid_opaque : opaquetab -&gt; opaque -&gt; option Future.UUID.t.

Parameter join_opaque : opaquetab -&gt; opaque -&gt; unit.

Parameter dump :
  opaquetab -&gt;
  array (Future.computation Constr.t) *
    array (Future.computation Univ.ContextSet.t) * array (list cooking_info) *
    Future.UUIDMap.t Z.

Parameter set_indirect_opaque_accessor :
  (Names.DirPath.t -&gt; Z -&gt; Future.computation Constr.constr) -&gt; unit.

Parameter set_indirect_univ_accessor :
  (Names.DirPath.t -&gt; Z -&gt; option (Future.computation Univ.ContextSet.t)) -&gt;
  unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="primred.ml">
  <div style="margin: 20px;">
    <h3>Primred</h3>
    <ul>
      <li>OCaml size: 204 lines</li>
      <li>Coq size: 301 lines (+47% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#primred.ml"><code>primred.ml</code></a>&nbsp;<span class="label label-warning">8 warnings</span>
    
    <pre>(* Reduction of native operators *)
open Names
open CPrimitives
open Retroknowledge
open Environ
open CErrors

let add_retroknowledge env action =
  match action with
  | Register_type(PT_int63,c) -&gt;
    let retro = env.retroknowledge in
    let retro =
      match retro.retro_int63 with
      | None -&gt; { retro with retro_int63 = Some c }
      | Some c' -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Constant.equal c c'); retro</abbr> in
    set_retroknowledge env retro
  | Register_ind(pit,ind) -&gt;
    let retro = env.retroknowledge in
    let retro =
      match pit with
      | PIT_bool -&gt;
        let r =
          match retro.retro_bool with
          | None -&gt; ((ind,1), (ind,2))
          | Some (((ind',_),_) as t) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (eq_ind ind ind'); t</abbr> in
        { retro with retro_bool = Some r }
      | PIT_carry -&gt;
        let r =
          match retro.retro_carry with
          | None -&gt; ((ind,1), (ind,2))
          | Some (((ind',_),_) as t) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (eq_ind ind ind'); t</abbr> in
        { retro with retro_carry = Some r }
      | PIT_pair -&gt;
        let r =
          match retro.retro_pair with
          | None -&gt; (ind,1)
          | Some ((ind',_) as t) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (eq_ind ind ind'); t</abbr> in
        { retro with retro_pair = Some r }
      | PIT_cmp -&gt;
        let r =
          match retro.retro_cmp with
          | None -&gt; ((ind,1), (ind,2), (ind,3))
          | Some (((ind',_),_,_) as t) -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (eq_ind ind ind'); t</abbr> in
        { retro with retro_cmp = Some r }
    in
    set_retroknowledge env retro

let get_int_type env =
  match env.retroknowledge.retro_int63 with
  | Some c -&gt; c
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: int63 not registered&quot;)

let get_bool_constructors env =
  match env.retroknowledge.retro_bool with
  | Some r -&gt; r
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: bool not registered&quot;)

let get_carry_constructors env =
  match env.retroknowledge.retro_carry with
  | Some r -&gt; r
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: carry not registered&quot;)

let get_pair_constructor env =
  match env.retroknowledge.retro_pair with
  | Some c  -&gt; c
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: pair not registered&quot;)

let get_cmp_constructors env =
  match env.retroknowledge.retro_cmp with
  | Some r -&gt; r
  | None -&gt; anomaly Pp.(str&quot;Reduction of primitive: cmp not registered&quot;)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception NativeDestKO</abbr>

module type RedNativeEntries =
  sig
    type elem
    type args
    type evd (* will be unit in kernel, evar_map outside *)

    val get : args -&gt; int -&gt; elem
    val get_int : evd -&gt; elem -&gt; Uint63.t
    val mkInt : env -&gt; Uint63.t -&gt; elem
    val mkBool : env -&gt; bool -&gt; elem
    val mkCarry : env -&gt; bool -&gt; elem -&gt; elem (* true if carry *)
    val mkIntPair : env -&gt; elem -&gt; elem -&gt; elem
    val mkLt : env -&gt; elem
    val mkEq : env -&gt; elem
    val mkGt : env -&gt; elem

  end

module type RedNative =
 sig
   type elem
   type args
   type evd
   val red_prim : env -&gt; evd -&gt; CPrimitives.t -&gt; args -&gt; elem option
 end

module RedNative (E:RedNativeEntries) :
  <abbr class="mark-warning" title="Operator 'with' on something else than a signature name is not handled">RedNative with type elem = E.elem
  with type args = E.args
  with type evd = E.evd</abbr> =
struct
  type elem = E.elem
  type args = E.args
  type evd = E.evd

  let get_int evd args i = E.get_int evd (E.get args i)

  let get_int1 evd args = get_int evd args 0

  let get_int2 evd args = get_int evd args 0, get_int evd args 1

  let get_int3 evd args =
    get_int evd args 0, get_int evd args 1, get_int evd args 2

  let red_prim_aux env evd op args =
    let open CPrimitives in
    match op with
    | Int63head0 -&gt;
      let i = get_int1 evd args in E.mkInt env (Uint63.head0 i)
    | Int63tail0 -&gt;
      let i = get_int1 evd args in E.mkInt env (Uint63.tail0 i)
    | Int63add -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.add i1 i2)
    | Int63sub -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.sub i1 i2)
    | Int63mul -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.mul i1 i2)
    | Int63div -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.div i1 i2)
    | Int63mod -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.rem i1 i2)
    | Int63lsr -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_sr i1 i2)
    | Int63lsl -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_sl i1 i2)
    | Int63land -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_and i1 i2)
    | Int63lor -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_or i1 i2)
    | Int63lxor -&gt;
      let i1, i2 = get_int2 evd args in E.mkInt env (Uint63.l_xor i1 i2)
    | Int63addc -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.add i1 i2 in
      E.mkCarry env (Uint63.lt s i1) (E.mkInt env s)
    | Int63subc -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.sub i1 i2 in
      E.mkCarry env (Uint63.lt i1 i2) (E.mkInt env s)
    | Int63addCarryC  -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.add (Uint63.add i1 i2) (Uint63.of_int 1) in
      E.mkCarry env (Uint63.le s i1) (E.mkInt env s)
    | Int63subCarryC  -&gt;
      let i1, i2 = get_int2 evd args in
      let s = Uint63.sub (Uint63.sub i1 i2) (Uint63.of_int 1) in
      E.mkCarry env (Uint63.le i1 i2) (E.mkInt env s)
    | Int63mulc -&gt;
      let i1, i2 = get_int2 evd args in
      let (h, l) = Uint63.mulc i1 i2 in
      E.mkIntPair env (E.mkInt env h) (E.mkInt env l)
    | Int63diveucl -&gt;
      let i1, i2 = get_int2 evd args in
      let q,r = Uint63.div i1 i2, Uint63.rem i1 i2 in
      E.mkIntPair env (E.mkInt env q) (E.mkInt env r)
    | Int63div21 -&gt;
      let i1, i2, i3 = get_int3 evd args in
      let q,r = Uint63.div21 i1 i2 i3 in
      E.mkIntPair env (E.mkInt env q) (E.mkInt env r)
    | Int63addMulDiv -&gt;
      let p, i, j = get_int3 evd args in
      E.mkInt env
        (Uint63.l_or
           (Uint63.l_sl i p)
           (Uint63.l_sr j (Uint63.sub (Uint63.of_int Uint63.uint_size) p)))
    | Int63eq -&gt;
      let i1, i2 = get_int2 evd args in
      E.mkBool env (Uint63.equal i1 i2)
    | Int63lt -&gt;
      let i1, i2 = get_int2 evd args in
      E.mkBool env (Uint63.lt i1 i2)
    | Int63le -&gt;
      let i1, i2 = get_int2 evd args in
      E.mkBool env (Uint63.le i1 i2)
    | Int63compare -&gt;
      let i1, i2 = get_int2 evd args in
      begin match Uint63.compare i1 i2 with
        | x when x &lt; 0 -&gt;  E.mkLt env
        | 0 -&gt; E.mkEq env
        | _ -&gt; E.mkGt env
      end

  let red_prim env evd p args =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
      let r =
        red_prim_aux env evd p args
      in Some r
    with NativeDestKO -&gt; None</abbr>

end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#primred.ml"><code>Primred.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import CPrimitives.

Import Retroknowledge.

Import Environ.

Import CErrors.

Definition add_retroknowledge
  (env : Environ.env) (action : Retroknowledge.action) : Environ.env :=
  match action with
  | Retroknowledge.Register_type CPrimitives.PT_int63 c =&gt;
    let retro := Environ.env.retroknowledge env in
    let retro :=
      match Retroknowledge.retroknowledge.retro_int63 retro with
      | None =&gt; Retroknowledge.retroknowledge.with_retro_int63 retro (Some c)
      | Some c' =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        retro
      end in
    set_retroknowledge env retro
  | Retroknowledge.Register_ind pit ind =&gt;
    let retro := Environ.env.retroknowledge env in
    let retro :=
      match pit with
      | CPrimitives.PIT_bool =&gt;
        let r :=
          match Retroknowledge.retroknowledge.retro_bool retro with
          | None =&gt; ((ind, 1), (ind, 2))
          | Some (((ind', _), _) as t) =&gt;
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            t
          end in
        Retroknowledge.retroknowledge.with_retro_bool retro (Some r)
      | CPrimitives.PIT_carry =&gt;
        let r :=
          match Retroknowledge.retroknowledge.retro_carry retro with
          | None =&gt; ((ind, 1), (ind, 2))
          | Some (((ind', _), _) as t) =&gt;
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            t
          end in
        Retroknowledge.retroknowledge.with_retro_carry retro (Some r)
      | CPrimitives.PIT_pair =&gt;
        let r :=
          match Retroknowledge.retroknowledge.retro_pair retro with
          | None =&gt; (ind, 1)
          | Some ((ind', _) as t) =&gt;
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            t
          end in
        Retroknowledge.retroknowledge.with_retro_pair retro (Some r)
      | CPrimitives.PIT_cmp =&gt;
        let r :=
          match Retroknowledge.retroknowledge.retro_cmp retro with
          | None =&gt; ((ind, 1), (ind, 2), (ind, 3))
          | Some (((ind', _), _, _) as t) =&gt;
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            t
          end in
        Retroknowledge.retroknowledge.with_retro_cmp retro (Some r)
      end in
    set_retroknowledge env retro
  end.

Definition get_int_type (env : Environ.env) : Names.Constant.t :=
  match
    Retroknowledge.retroknowledge.retro_int63 (Environ.env.retroknowledge env)
    with
  | Some c =&gt; c
  | None =&gt;
    anomaly None None (str &quot;Reduction of primitive: int63 not registered&quot;)
  end.

Definition get_bool_constructors (env : Environ.env)
  : Names.constructor * Names.constructor :=
  match
    Retroknowledge.retroknowledge.retro_bool (Environ.env.retroknowledge env)
    with
  | Some r =&gt; r
  | None =&gt;
    anomaly None None (str &quot;Reduction of primitive: bool not registered&quot;)
  end.

Definition get_carry_constructors (env : Environ.env)
  : Names.constructor * Names.constructor :=
  match
    Retroknowledge.retroknowledge.retro_carry (Environ.env.retroknowledge env)
    with
  | Some r =&gt; r
  | None =&gt;
    anomaly None None (str &quot;Reduction of primitive: carry not registered&quot;)
  end.

Definition get_pair_constructor (env : Environ.env) : Names.constructor :=
  match
    Retroknowledge.retroknowledge.retro_pair (Environ.env.retroknowledge env)
    with
  | Some c =&gt; c
  | None =&gt;
    anomaly None None (str &quot;Reduction of primitive: pair not registered&quot;)
  end.

Definition get_cmp_constructors (env : Environ.env)
  : Names.constructor * Names.constructor * Names.constructor :=
  match Retroknowledge.retroknowledge.retro_cmp (Environ.env.retroknowledge env)
    with
  | Some r =&gt; r
  | None =&gt; anomaly None None (str &quot;Reduction of primitive: cmp not registered&quot;)
  end.

(* ❌ The definition of exceptions is not handled. *)
(* exception NativeDestKO *)

Module RedNativeEntries.
  Record signature {elem args evd : Set} := {
    elem := elem;
    args := args;
    evd := evd;
    get : args -&gt; Z -&gt; elem;
    get_int : evd -&gt; elem -&gt; Uint63.t;
    mkInt : Environ.env -&gt; Uint63.t -&gt; elem;
    mkBool : Environ.env -&gt; bool -&gt; elem;
    mkCarry : Environ.env -&gt; bool -&gt; elem -&gt; elem;
    mkIntPair : Environ.env -&gt; elem -&gt; elem -&gt; elem;
    mkLt : Environ.env -&gt; elem;
    mkEq : Environ.env -&gt; elem;
    mkGt : Environ.env -&gt; elem;
  }.
  Arguments signature : clear implicits.
End RedNativeEntries.

Module RedNative.
  Record signature {elem args evd : Set} := {
    elem := elem;
    args := args;
    evd := evd;
    red_prim : Environ.env -&gt; evd -&gt; CPrimitives.t -&gt; args -&gt; option elem;
  }.
  Arguments signature : clear implicits.
End RedNative.

Definition RedNative :=
  fun (E : {'[elem, args, evd] : _ &amp; RedNativeEntries.signature elem args evd})
    =&gt;
    (let elem := (|E|).(RedNativeEntries.elem) in
    let args := (|E|).(RedNativeEntries.args) in
    let evd := (|E|).(RedNativeEntries.evd) in
    let get_int
      (evd : (|E|).(RedNativeEntries.evd))
      (args : (|E|).(RedNativeEntries.args)) (i : Z) : Uint63.t :=
      (|E|).(RedNativeEntries.get_int) evd ((|E|).(RedNativeEntries.get) args i)
      in
    let get_int1
      (evd : (|E|).(RedNativeEntries.evd))
      (args : (|E|).(RedNativeEntries.args)) : Uint63.t :=
      get_int evd args 0 in
    let get_int2
      (evd : (|E|).(RedNativeEntries.evd))
      (args : (|E|).(RedNativeEntries.args)) : Uint63.t * Uint63.t :=
      ((get_int evd args 0), (get_int evd args 1)) in
    let get_int3
      (evd : (|E|).(RedNativeEntries.evd))
      (args : (|E|).(RedNativeEntries.args)) : Uint63.t * Uint63.t * Uint63.t :=
      ((get_int evd args 0), (get_int evd args 1), (get_int evd args 2)) in
    let red_prim_aux
      (env : Environ.env) (evd : (|E|).(RedNativeEntries.evd))
      (op : CPrimitives.t) (args : (|E|).(RedNativeEntries.args))
      : (|E|).(RedNativeEntries.elem) :=
      match op with
      | CPrimitives.Int63head0 =&gt;
        let i := get_int1 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.head0 i)
      | CPrimitives.Int63tail0 =&gt;
        let i := get_int1 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.tail0 i)
      | CPrimitives.Int63add =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.add i1 i2)
      | CPrimitives.Int63sub =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.sub i1 i2)
      | CPrimitives.Int63mul =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.mul i1 i2)
      | CPrimitives.Int63div =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.div i1 i2)
      | CPrimitives.Int63mod =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.rem i1 i2)
      | CPrimitives.Int63lsr =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.l_sr i1 i2)
      | CPrimitives.Int63lsl =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.l_sl i1 i2)
      | CPrimitives.Int63land =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.l_and i1 i2)
      | CPrimitives.Int63lor =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.l_or i1 i2)
      | CPrimitives.Int63lxor =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkInt) env (Uint63.l_xor i1 i2)
      | CPrimitives.Int63addc =&gt;
        let '(i1, i2) := get_int2 evd args in
        let s := Uint63.add i1 i2 in
        (|E|).(RedNativeEntries.mkCarry) env (Uint63.lt s i1)
          ((|E|).(RedNativeEntries.mkInt) env s)
      | CPrimitives.Int63subc =&gt;
        let '(i1, i2) := get_int2 evd args in
        let s := Uint63.sub i1 i2 in
        (|E|).(RedNativeEntries.mkCarry) env (Uint63.lt i1 i2)
          ((|E|).(RedNativeEntries.mkInt) env s)
      | CPrimitives.Int63addCarryC =&gt;
        let '(i1, i2) := get_int2 evd args in
        let s := Uint63.add (Uint63.add i1 i2) (Uint63.of_int 1) in
        (|E|).(RedNativeEntries.mkCarry) env (Uint63.le s i1)
          ((|E|).(RedNativeEntries.mkInt) env s)
      | CPrimitives.Int63subCarryC =&gt;
        let '(i1, i2) := get_int2 evd args in
        let s := Uint63.sub (Uint63.sub i1 i2) (Uint63.of_int 1) in
        (|E|).(RedNativeEntries.mkCarry) env (Uint63.le i1 i2)
          ((|E|).(RedNativeEntries.mkInt) env s)
      | CPrimitives.Int63mulc =&gt;
        let '(i1, i2) := get_int2 evd args in
        let '(h, l) := Uint63.mulc i1 i2 in
        (|E|).(RedNativeEntries.mkIntPair) env
          ((|E|).(RedNativeEntries.mkInt) env h)
          ((|E|).(RedNativeEntries.mkInt) env l)
      | CPrimitives.Int63diveucl =&gt;
        let '(i1, i2) := get_int2 evd args in
        let '(q, r) := ((Uint63.div i1 i2), (Uint63.rem i1 i2)) in
        (|E|).(RedNativeEntries.mkIntPair) env
          ((|E|).(RedNativeEntries.mkInt) env q)
          ((|E|).(RedNativeEntries.mkInt) env r)
      | CPrimitives.Int63div21 =&gt;
        let '(i1, i2, i3) := get_int3 evd args in
        let '(q, r) := Uint63.div21 i1 i2 i3 in
        (|E|).(RedNativeEntries.mkIntPair) env
          ((|E|).(RedNativeEntries.mkInt) env q)
          ((|E|).(RedNativeEntries.mkInt) env r)
      | CPrimitives.Int63addMulDiv =&gt;
        let '(p, i, j) := get_int3 evd args in
        (|E|).(RedNativeEntries.mkInt) env
          (Uint63.l_or (Uint63.l_sl i p)
            (Uint63.l_sr j (Uint63.sub (Uint63.of_int Uint63.uint_size) p)))
      | CPrimitives.Int63eq =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkBool) env (Uint63.equal i1 i2)
      | CPrimitives.Int63lt =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkBool) env (Uint63.lt i1 i2)
      | CPrimitives.Int63le =&gt;
        let '(i1, i2) := get_int2 evd args in
        (|E|).(RedNativeEntries.mkBool) env (Uint63.le i1 i2)
      | CPrimitives.Int63compare =&gt;
        let '(i1, i2) := get_int2 evd args in
        match
          ((Uint63.compare i1 i2),
            match Uint63.compare i1 i2 with
            | x =&gt; OCaml.Stdlib.lt x 0
            | _ =&gt; false
            end) with
        | (x, true) =&gt; (|E|).(RedNativeEntries.mkLt) env
        | (0, _) =&gt; (|E|).(RedNativeEntries.mkEq) env
        | (_, _) =&gt; (|E|).(RedNativeEntries.mkGt) env
        end
      end in
    let red_prim
      (env : Environ.env) (evd : (|E|).(RedNativeEntries.evd))
      (p : CPrimitives.t) (args : (|E|).(RedNativeEntries.args))
      : option (|E|).(RedNativeEntries.elem) :=
      (* ❌ Try-with are not handled *)
      try
        (let r := red_prim_aux env evd p args in
        Some r) in
    existT (fun _ =&gt; _) tt
      {|
        RedNative.red_prim := red_prim
      |} : signature).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="primred.mli">
  <div style="margin: 20px;">
    <h3>Primred_mli</h3>
    <ul>
      <li>OCaml size: 44 lines</li>
      <li>Coq size: 61 lines (+38% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#primred.mli"><code>primred.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>open Names
open Environ

(** {5 Reduction of primitives} *)
val add_retroknowledge : env -&gt; Retroknowledge.action -&gt; env

val get_int_type : env -&gt; Constant.t
val get_bool_constructors : env -&gt; constructor * constructor
val get_carry_constructors : env -&gt; constructor * constructor
val get_pair_constructor : env -&gt; constructor
val get_cmp_constructors : env -&gt; constructor * constructor * constructor

<abbr class="mark-warning" title="Signature item `exception` not handled">exception NativeDestKO</abbr> (* Should be raised by get_* functions on failure *)

module type RedNativeEntries =
  sig
    type elem
    type args
    type evd (* will be unit in kernel, evar_map outside *)

    val get : args -&gt; int -&gt; elem
    val get_int : evd -&gt; elem -&gt; Uint63.t
    val mkInt : env -&gt; Uint63.t -&gt; elem
    val mkBool : env -&gt; bool -&gt; elem
    val mkCarry : env -&gt; bool -&gt; elem -&gt; elem (* true if carry *)
    val mkIntPair : env -&gt; elem -&gt; elem -&gt; elem
    val mkLt : env -&gt; elem
    val mkEq : env -&gt; elem
    val mkGt : env -&gt; elem
  end

module type RedNative =
 sig
   type elem
   type args
   type evd
   val red_prim : env -&gt; evd -&gt; CPrimitives.t -&gt; args -&gt; elem option
 end

module RedNative :
  functor (E:RedNativeEntries) -&gt;
    <abbr class="mark-warning" title="Operator 'with' on something else than a signature name is not handled">RedNative with type elem = E.elem
    with type args = E.args
    with type evd = E.evd</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#primred.mli"><code>Primred_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter add_retroknowledge :
  Environ.env -&gt; Retroknowledge.action -&gt; Environ.env.

Parameter get_int_type : Environ.env -&gt; Names.Constant.t.

Parameter get_bool_constructors :
  Environ.env -&gt; Names.constructor * Names.constructor.

Parameter get_carry_constructors :
  Environ.env -&gt; Names.constructor * Names.constructor.

Parameter get_pair_constructor : Environ.env -&gt; Names.constructor.

Parameter get_cmp_constructors :
  Environ.env -&gt; Names.constructor * Names.constructor * Names.constructor.

(* exception NativeDestKO *)

Module RedNativeEntries.
  Record signature {elem args evd : Set} := {
    elem := elem;
    args := args;
    evd := evd;
    get : args -&gt; Z -&gt; elem;
    get_int : evd -&gt; elem -&gt; Uint63.t;
    mkInt : Environ.env -&gt; Uint63.t -&gt; elem;
    mkBool : Environ.env -&gt; bool -&gt; elem;
    mkCarry : Environ.env -&gt; bool -&gt; elem -&gt; elem;
    mkIntPair : Environ.env -&gt; elem -&gt; elem -&gt; elem;
    mkLt : Environ.env -&gt; elem;
    mkEq : Environ.env -&gt; elem;
    mkGt : Environ.env -&gt; elem;
  }.
  Arguments signature : clear implicits.
End RedNativeEntries.

Module RedNative.
  Record signature {elem args evd : Set} := {
    elem := elem;
    args := args;
    evd := evd;
    red_prim : Environ.env -&gt; evd -&gt; CPrimitives.t -&gt; args -&gt; option elem;
  }.
  Arguments signature : clear implicits.
End RedNative.

Parameter RedNative :
  forall (E :
    {'[elem, args, evd] : _ &amp; RedNativeEntries.signature elem args evd}),
    signature.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="reduction.ml">
  <div style="margin: 20px;">
    <h3>Reduction</h3>
    <ul>
      <li>OCaml size: 991 lines</li>
      <li>Coq size: 1473 lines (+48% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#reduction.ml"><code>reduction.ml</code></a>&nbsp;<span class="label label-warning">76 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created under Benjamin Werner account by Bruno Barras to implement
   a call-by-value conversion algorithm and a lazy reduction machine
   with sharing, Nov 1996 *)
(* Addition of zeta-reduction (let-in contraction) by Hugo Herbelin, Oct 2000 *)
(* Irreversibility of opacity by Bruno Barras *)
(* Cleaning and lightening of the kernel by Bruno Barras, Nov 2001 *)
(* Equal inductive types by Jacek Chrzaszcz as part of the module
   system, Aug 2002 *)

open CErrors
open Util
open Names
open Constr
open Declarations
open Vars
open Environ
open CClosure
open Esubst
open Context.Rel.Declaration

let rec is_empty_stack = function
  [] -&gt; true
  | Zupdate _::s -&gt; is_empty_stack s
  | Zshift _::s -&gt; is_empty_stack s
  | _ -&gt; false

(* Compute the lift to be performed on a term placed in a given stack *)
let el_stack el stk =
  let n =
    List.fold_left
      (fun i z -&gt;
        match z with
            Zshift n -&gt; i+n
          | _ -&gt; i)
      0
      stk in
  el_shft n el

let compare_stack_shape stk1 stk2 =
  let rec compare_rec bal stk1 stk2 =
  match (stk1,stk2) with
      ([],[]) -&gt; Int.equal bal 0
    | ((Zupdate _|Zshift _)::s1, _) -&gt; compare_rec bal s1 stk2
    | (_, (Zupdate _|Zshift _)::s2) -&gt; compare_rec bal stk1 s2
    | (Zapp l1::s1, _) -&gt; compare_rec (bal+Array.length l1) s1 stk2
    | (_, Zapp l2::s2) -&gt; compare_rec (bal-Array.length l2) stk1 s2
    | (Zproj _p1::s1, Zproj _p2::s2) -&gt;
        Int.equal bal 0 &amp;&amp; compare_rec 0 s1 s2
    | (ZcaseT(_c1,_,_,_)::s1, ZcaseT(_c2,_,_,_)::s2) -&gt;
        Int.equal bal 0 (* &amp;&amp; c1.ci_ind  = c2.ci_ind *) &amp;&amp; compare_rec 0 s1 s2
    | (Zfix(_,a1)::s1, Zfix(_,a2)::s2) -&gt;
        Int.equal bal 0 &amp;&amp; compare_rec 0 a1 a2 &amp;&amp; compare_rec 0 s1 s2
    | Zprimitive(op1,_,rargs1, _kargs1)::s1, Zprimitive(op2,_,rargs2, _kargs2)::s2 -&gt;
        bal=0 &amp;&amp; op1=op2 &amp;&amp; List.length rargs1=List.length rargs2 &amp;&amp;
        compare_rec 0 s1 s2
    | [], _ :: _
    | (Zproj _ | ZcaseT _ | Zfix _ | Zprimitive _) :: _, _ -&gt; false
  in
  compare_rec 0 stk1 stk2

type lft_fconstr = lift * fconstr

type lft_constr_stack_elt =
    Zlapp of (lift * fconstr) array
  | Zlproj of Projection.Repr.t * lift
  | Zlfix of (lift * fconstr) * lft_constr_stack
  | Zlcase of case_info * lift * constr * constr array * fconstr subs
  | Zlprimitive of
     CPrimitives.t * pconstant * lft_fconstr list * lft_fconstr next_native_args
and lft_constr_stack = lft_constr_stack_elt list

let rec zlapp v = function
    Zlapp v2 :: s -&gt; zlapp (Array.append v v2) s
  | s -&gt; Zlapp v :: s

(** Hand-unrolling of the map function to bypass the call to the generic array
    allocation. Type annotation is required to tell OCaml that the array does
    not contain floats. *)
let map_lift (l : lift) (v : fconstr array) = match v with
| <abbr class="mark-warning" title="Patterns on array are not supported">[||]</abbr> -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|c0|]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[|(l, c0)|]</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|c0; c1|]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[|(l, c0); (l, c1)|]</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|c0; c1; c2|]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[|(l, c0); (l, c1); (l, c2)|]</abbr>
| <abbr class="mark-warning" title="Patterns on array are not supported">[|c0; c1; c2; c3|]</abbr> -&gt; <abbr class="mark-warning" title="Arrays not handled.">[|(l, c0); (l, c1); (l, c2); (l, c3)|]</abbr>
| v -&gt; Array.Fun1.map (fun l t -&gt; (l, t)) l v

let pure_stack lfts stk =
  let rec pure_rec lfts stk =
    match stk with
        [] -&gt; (lfts,[])
      | zi::s -&gt;
          (match (zi,pure_rec lfts s) with
              (Zupdate _,lpstk)  -&gt; lpstk
            | (Zshift n,(l,pstk)) -&gt; (el_shft n l, pstk)
            | (Zapp a, (l,pstk)) -&gt;
                (l,zlapp (map_lift l a) pstk)
            | (Zproj p, (l,pstk)) -&gt;
                (l, Zlproj (p,l)::pstk)
            | (Zfix(fx,a),(l,pstk)) -&gt;
                let (lfx,pa) = pure_rec l a in
                (l, Zlfix((lfx,fx),pa)::pstk)
            | (ZcaseT(ci,p,br,e),(l,pstk)) -&gt;
                (l,Zlcase(ci,l,p,br,e)::pstk)
            | (Zprimitive(op,c,rargs,kargs),(l,pstk)) -&gt;
                (l,Zlprimitive(op,c,List.map (fun t -&gt; (l,t)) rargs,
                            List.map (fun (k,t) -&gt; (k,(l,t))) kargs)::pstk))
  in
  snd (pure_rec lfts stk)

(****************************************************************************)
(*                   Reduction Functions                                    *)
(****************************************************************************)

let whd_betaiota env t =
  match kind t with
    | (Sort _|Var _|Meta _|Evar _|Const _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _) -&gt; t
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | Const _ | LetIn _ -&gt; t
      | _ -&gt; whd_val (create_clos_infos betaiota env) (create_tab ()) (inject t)
      end
    | _ -&gt; whd_val (create_clos_infos betaiota env) (create_tab ()) (inject t)

let nf_betaiota env t =
  norm_val (create_clos_infos betaiota env) (create_tab ()) (inject t)

let whd_betaiotazeta env x =
  match kind x with
  | (Sort _|Var _|Meta _|Evar _|Const _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _|Int _) -&gt; x
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | Const _ | Int _ -&gt; x
      | Sort _ | Rel _ | Var _ | Cast _ | Prod _ | Lambda _ | LetIn _ | App _
        | Case _ | Fix _ | CoFix _ | Proj _ -&gt;
         whd_val (create_clos_infos betaiotazeta env) (create_tab ()) (inject x)
      end
    | Rel _ | Cast _ | LetIn _ | Case _ | Proj _ -&gt;
        whd_val (create_clos_infos betaiotazeta env) (create_tab ()) (inject x)

let whd_all env t =
  match kind t with
    | (Sort _|Meta _|Evar _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _|Int _) -&gt; t
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | Int _ -&gt; t
      | Sort _ | Rel _ | Var _ | Cast _ | Prod _ | Lambda _ | LetIn _ | App _
        | Const _ |Case _ | Fix _ | CoFix _ | Proj _ -&gt;
         whd_val (create_clos_infos all env) (create_tab ()) (inject t)
      end
    | Rel _ | Cast _ | LetIn _ | Case _ | Proj _ | Const _ | Var _ -&gt;
        whd_val (create_clos_infos all env) (create_tab ()) (inject t)

let whd_allnolet env t =
  match kind t with
    | (Sort _|Meta _|Evar _|Ind _|Construct _|
       Prod _|Lambda _|Fix _|CoFix _|LetIn _|Int _) -&gt; t
    | App (c, _) -&gt;
      begin match kind c with
      | Ind _ | Construct _ | Evar _ | Meta _ | LetIn _ | Int _ -&gt; t
      | Sort _ | Rel _ | Var _ | Cast _ | Prod _ | Lambda _ | App _
        | Const _ | Case _ | Fix _ | CoFix _ | Proj _ -&gt;
         whd_val (create_clos_infos allnolet env) (create_tab ()) (inject t)
      end
    | Rel _ | Cast _ | Case _ | Proj _ | Const _ | Var _ -&gt;
        whd_val (create_clos_infos allnolet env) (create_tab ()) (inject t)

(********************************************************************)
(*                         Conversion                               *)
(********************************************************************)

(* Conversion utility functions *)

(* functions of this type are called from the kernel *)
type 'a kernel_conversion_function = env -&gt; 'a -&gt; 'a -&gt; unit

(* functions of this type can be called from outside the kernel *)
type 'a extended_conversion_function =
  ?l2r:bool -&gt; ?reds:TransparentState.t -&gt; env -&gt;
  ?evars:((existential-&gt;constr option) * UGraph.t) -&gt;
  'a -&gt; 'a -&gt; unit

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception NotConvertible</abbr>

(* Convertibility of sorts *)

(* The sort cumulativity is

    Prop &lt;= Set &lt;= Type 1 &lt;= ... &lt;= Type i &lt;= ...

    and this holds whatever Set is predicative or impredicative
*)

type conv_pb =
  | CONV
  | CUMUL

let is_cumul = function CUMUL -&gt; true | CONV -&gt; false

type 'a universe_compare =
  { (* Might raise NotConvertible *)
    compare_sorts : env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt; 'a -&gt; 'a;
    compare_instances: flex:bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; 'a -&gt; 'a;
    compare_cumul_instances : conv_pb -&gt; Univ.Variance.t array -&gt;
      Univ.Instance.t -&gt; Univ.Instance.t -&gt; 'a -&gt; 'a }

type 'a universe_state = 'a * 'a universe_compare

type ('a,'b) generic_conversion_function = env -&gt; 'b universe_state -&gt; 'a -&gt; 'a -&gt; 'b

type 'a infer_conversion_function = env -&gt; UGraph.t -&gt; 'a -&gt; 'a -&gt; Univ.Constraint.t

let sort_cmp_universes env pb s0 s1 (u, check) =
  (check.compare_sorts env pb s0 s1 u, check)

(* [flex] should be true for constants, false for inductive types and
   constructors. *)
let convert_instances ~flex u u' (s, check) =
  (check.compare_instances ~flex u u' s, check)

let get_cumulativity_constraints cv_pb variance u u' =
  match cv_pb with
  | CONV -&gt;
    Univ.enforce_eq_variance_instances variance u u' Univ.Constraint.empty
  | CUMUL -&gt;
    Univ.enforce_leq_variance_instances variance u u' Univ.Constraint.empty

let inductive_cumulativity_arguments (mind,ind) =
  mind.Declarations.mind_nparams +
  mind.Declarations.mind_packets.(ind).Declarations.mind_nrealargs

let convert_inductives_gen cmp_instances cmp_cumul cv_pb (mind,ind) nargs u1 u2 s =
  match mind.Declarations.mind_variance with
  | None -&gt; cmp_instances u1 u2 s
  | Some variances -&gt;
    let num_param_arity = inductive_cumulativity_arguments (mind,ind) in
    if not (Int.equal num_param_arity nargs) then
      cmp_instances u1 u2 s
    else
      cmp_cumul cv_pb variances u1 u2 s

let convert_inductives cv_pb ind nargs u1 u2 (s, check) =
  convert_inductives_gen (check.compare_instances ~flex:false) check.compare_cumul_instances
    cv_pb ind nargs u1 u2 s, check

let constructor_cumulativity_arguments (mind, ind, ctor) =
  mind.Declarations.mind_nparams +
  mind.Declarations.mind_packets.(ind).Declarations.mind_consnrealargs.(ctor - 1)

let convert_constructors_gen cmp_instances cmp_cumul (mind, ind, cns) nargs u1 u2 s =
  match mind.Declarations.mind_variance with
  | None -&gt; cmp_instances u1 u2 s
  | Some _ -&gt;
    let num_cnstr_args = constructor_cumulativity_arguments (mind,ind,cns) in
    if not (Int.equal num_cnstr_args nargs) then
      cmp_instances u1 u2 s
    else
      (** By invariant, both constructors have a common supertype,
          so they are convertible _at that type_. *)
      let variance = Array.make (Univ.Instance.length u1) Univ.Variance.Irrelevant in
      cmp_cumul CONV variance u1 u2 s

let convert_constructors ctor nargs u1 u2 (s, check) =
  convert_constructors_gen (check.compare_instances ~flex:false) check.compare_cumul_instances
    ctor nargs u1 u2 s, check

let conv_table_key infos k1 k2 cuniv =
  if k1 == k2 then cuniv else
  match k1, k2 with
  | ConstKey (cst, u), ConstKey (cst', u') when Constant.equal cst cst' -&gt;
    if Univ.Instance.equal u u' then cuniv
    else
      let flex = evaluable_constant cst (info_env infos)
        &amp;&amp; <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CClosure.RedFlagsSig, CClosure.RedFlagsSig

We were looking for a module signature name for the following shape:
[
  fBETA;
  fDELTA;
  fETA;
  fMATCH;
  fFIX;
  fCOFIX;
  fZETA;
  fCONST;
  fVAR;
  no_red;
  red_add;
  red_sub;
  red_add_transparent;
  red_transparent;
  mkflags;
  red_set;
  red_projection
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RedFlags.red_set</abbr> (info_flags infos) (<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CClosure.RedFlagsSig, CClosure.RedFlagsSig

We were looking for a module signature name for the following shape:
[
  fBETA;
  fDELTA;
  fETA;
  fMATCH;
  fFIX;
  fCOFIX;
  fZETA;
  fCONST;
  fVAR;
  no_red;
  red_add;
  red_sub;
  red_add_transparent;
  red_transparent;
  mkflags;
  red_set;
  red_projection
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RedFlags.fCONST</abbr> cst)
      in convert_instances ~flex u u' cuniv
  | VarKey id, VarKey id' when Id.equal id id' -&gt; cuniv
  | RelKey n, RelKey n' when Int.equal n n' -&gt; cuniv
  | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception IrregularPatternShape</abbr>

let unfold_ref_with_args infos tab fl v =
  match unfold_reference infos tab fl with
  | Def def -&gt; Some (def, v)
  | Primitive op when check_native_args op v -&gt;
    let c = match fl with ConstKey c -&gt; c | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> in
    let rargs, a, nargs, v = get_native_args1 op c v in
    Some (whd_stack infos tab a (Zupdate a::(Zprimitive(op,c,rargs,nargs)::v)))
  | Undef _ | OpaqueDef _ | Primitive _ -&gt; None

type conv_tab = {
  cnv_inf : clos_infos;
  relevances : Sorts.relevance Range.t;
  lft_tab : clos_tab;
  rgt_tab : clos_tab;
}
(** Invariant: for any tl â lft_tab and tr â rgt_tab, there is no mutable memory
    location contained both in tl and in tr. *)

(** The same heap separation invariant must hold for the fconstr arguments
    passed to each respective side of the conversion function below. *)

let push_relevance infos r =
  { infos with relevances = Range.cons r.Context.binder_relevance infos.relevances }

let push_relevances infos nas =
  { infos with relevances = Array.fold_left (fun l x -&gt; Range.cons x.Context.binder_relevance l) infos.relevances nas }

let rec skip_pattern infos relevances n c1 c2 =
  if Int.equal n 0 then {infos with relevances}, c1, c2
  else match kind c1, kind c2 with
    | Lambda (x, _, c1), Lambda (_, _, c2) -&gt;
      skip_pattern infos (Range.cons x.Context.binder_relevance relevances) (pred n) c1 c2
    | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">IrregularPatternShape</abbr>

let skip_pattern infos n c1 c2 =
  if Int.equal n 0 then infos, c1, c2
  else skip_pattern infos infos.relevances n c1 c2

let is_irrelevant infos lft c =
  let env = info_env infos.cnv_inf in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Retypeops.relevance_of_fterm env infos.relevances lft c == Sorts.Irrelevant with _ -&gt; false</abbr>

(* Conversion between  [lft1]term1 and [lft2]term2 *)
let rec ccnv cv_pb l2r infos lft1 lft2 term1 term2 cuniv =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try eqappr cv_pb l2r infos (lft1, (term1,[])) (lft2, (term2,[])) cuniv
  with NotConvertible when is_irrelevant infos lft1 term1 &amp;&amp; is_irrelevant infos lft2 term2 -&gt; cuniv</abbr>

(* Conversion between [lft1](hd1 v1) and [lft2](hd2 v2) *)
and eqappr cv_pb l2r infos (lft1,st1) (lft2,st2) cuniv =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Control.check_for_interrupt ();
  (* First head reduce both terms *)
  let ninfos = infos_with_reds infos.cnv_inf betaiotazeta in
  let (hd1, v1 as appr1) = whd_stack ninfos infos.lft_tab (fst st1) (snd st1) in
  let (hd2, v2 as appr2) = whd_stack ninfos infos.rgt_tab (fst st2) (snd st2) in
  let appr1 = (lft1, appr1) and appr2 = (lft2, appr2) in
  (** We delay the computation of the lifts that apply to the head of the term
      with [el_stack] inside the branches where they are actually used. *)
  match (fterm_of hd1, fterm_of hd2) with
    (* case of leaves *)
    | (FAtom a1, FAtom a2) -&gt;
        (match kind a1, kind a2 with
           | (Sort s1, Sort s2) -&gt;
               </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (is_empty_stack v1 &amp;&amp; is_empty_stack v2) then
                 anomaly (Pp.str &quot;conversion was given ill-typed terms (Sort).&quot;);
              sort_cmp_universes (info_env infos.cnv_inf) cv_pb s1 s2 cuniv</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
           | (Meta n, Meta m) -&gt;
               if Int.equal n m
               then convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
               else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
           | _ -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)
    | (FEvar ((ev1,args1),env1), FEvar ((ev2,args2),env2)) -&gt;
        if Evar.equal ev1 ev2 then
          let el1 = el_stack lft1 v1 in
          let el2 = el_stack lft2 v2 in
          let cuniv = convert_stacks l2r infos lft1 lft2 v1 v2 cuniv in
          convert_vect l2r infos el1 el2
            (Array.map (mk_clos env1) args1)
            (Array.map (mk_clos env2) args2) cuniv
        else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    (* 2 index known to be bound to no constant *)
    | (FRel n, FRel m) -&gt;
        let el1 = el_stack lft1 v1 in
        let el2 = el_stack lft2 v2 in
        if Int.equal (reloc_rel n el1) (reloc_rel m el2)
        then convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    (* 2 constants, 2 local defined vars or 2 defined rels *)
    | (FFlex fl1, FFlex fl2) -&gt;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
         let cuniv = conv_table_key infos.cnv_inf fl1 fl2 cuniv in
         convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       with NotConvertible | Univ.UniverseInconsistency _ -&gt;
         (* else the oracle tells which constant is to be expanded *)
         let oracle = CClosure.oracle_of_infos infos.cnv_inf in
         let (app1,app2) =
           let aux appr1 lft1 fl1 tab1 v1 appr2 lft2 fl2 tab2 v2 =
             match unfold_ref_with_args infos.cnv_inf tab1 fl1 v1 with
             | Some t1 -&gt; ((lft1, t1), appr2)
             | None -&gt; match unfold_ref_with_args infos.cnv_inf tab2 fl2 v2 with
               | Some t2 -&gt; (appr1, (lft2, t2))
               | None -&gt; raise NotConvertible
           in
           if Conv_oracle.oracle_order Univ.out_punivs oracle l2r fl1 fl2 then
             aux appr1 lft1 fl1 infos.lft_tab v1 appr2 lft2 fl2 infos.rgt_tab v2
           else
             let (app2,app1) = aux appr2 lft2 fl2 infos.rgt_tab v2 appr1 lft1 fl1 infos.lft_tab v1 in
             (app1,app2)
         in
         eqappr cv_pb l2r infos app1 app2 cuniv)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    | (FProj (p1,c1), FProj (p2, c2)) -&gt;
      (* Projections: prefer unfolding to first-order unification,
         which will happen naturally if the terms c1, c2 are not in constructor
         form *)
      (match unfold_projection infos.cnv_inf p1 with
      | Some s1 -&gt;
        eqappr cv_pb l2r infos (lft1, (c1, (s1 :: v1))) appr2 cuniv
      | None -&gt;
        match unfold_projection infos.cnv_inf p2 with
        | Some s2 -&gt;
          eqappr cv_pb l2r infos appr1 (lft2, (c2, (s2 :: v2))) cuniv
        | None -&gt;
          if Projection.Repr.equal (Projection.repr p1) (Projection.repr p2)
             &amp;&amp; compare_stack_shape v1 v2 then
            let el1 = el_stack lft1 v1 in
            let el2 = el_stack lft2 v2 in
            let u1 = ccnv CONV l2r infos el1 el2 c1 c2 cuniv in
              convert_stacks l2r infos lft1 lft2 v1 v2 u1
          else (* Two projections in WHNF: unfold *)
            raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)

    | (FProj (p1,c1), t2) -&gt;
      begin match unfold_projection infos.cnv_inf p1 with
       | Some s1 -&gt;
         eqappr cv_pb l2r infos (lft1, (c1, (s1 :: v1))) appr2 cuniv
       | None -&gt;
         begin match t2 with
          | FFlex fl2 -&gt;
            begin match unfold_ref_with_args infos.cnv_inf infos.rgt_tab fl2 v2 with
             | Some t2 -&gt;
               eqappr cv_pb l2r infos appr1 (lft2, t2) cuniv
             | None -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
            end
          | _ -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
         end
      end

    | (t1, FProj (p2,c2)) -&gt;
      begin match unfold_projection infos.cnv_inf p2 with
       | Some s2 -&gt;
         eqappr cv_pb l2r infos appr1 (lft2, (c2, (s2 :: v2))) cuniv
       | None -&gt;
         begin match t1 with
          | FFlex fl1 -&gt;
            begin match unfold_ref_with_args infos.cnv_inf infos.lft_tab fl1 v1 with
             | Some t1 -&gt;
               eqappr cv_pb l2r infos (lft1, t1) appr2 cuniv
             | None -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
            end
          | _ -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
         end
      end

    (* other constructors *)
    | (FLambda _, FLambda _) -&gt;
        (* Inconsistency: we tolerate that v1, v2 contain shift and update but
           we throw them away *)
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (is_empty_stack v1 &amp;&amp; is_empty_stack v2) then
          anomaly (Pp.str &quot;conversion was given ill-typed terms (FLambda).&quot;);
        let (x1,ty1,bd1) = destFLambda mk_clos hd1 in
        let (_,ty2,bd2) = destFLambda mk_clos hd2 in
        let el1 = el_stack lft1 v1 in
        let el2 = el_stack lft2 v2 in
        let cuniv = ccnv CONV l2r infos el1 el2 ty1 ty2 cuniv in
        ccnv CONV l2r (push_relevance infos x1) (el_lift el1) (el_lift el2) bd1 bd2 cuniv</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    | (FProd (x1, c1, c2, e), FProd (_, c'1, c'2, e')) -&gt;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (is_empty_stack v1 &amp;&amp; is_empty_stack v2) then
          anomaly (Pp.str &quot;conversion was given ill-typed terms (FProd).&quot;);
        (* Luo's system *)
        let el1 = el_stack lft1 v1 in
        let el2 = el_stack lft2 v2 in
        let cuniv = ccnv CONV l2r infos el1 el2 c1 c'1 cuniv in
        ccnv cv_pb l2r (push_relevance infos x1) (el_lift el1) (el_lift el2) (mk_clos (subs_lift e) c2) (mk_clos (subs_lift e') c'2) cuniv</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    (* Eta-expansion on the fly *)
    | (FLambda _, _) -&gt;
        let () = match v1 with
        | [] -&gt; ()
        | _ -&gt;
          anomaly (Pp.str &quot;conversion was given unreduced term (FLambda).&quot;)
        in
        let (x1,_ty1,bd1) = destFLambda mk_clos hd1 in
        let infos = push_relevance infos x1 in
        eqappr CONV l2r infos
          (el_lift lft1, (bd1, [])) (el_lift lft2, (hd2, eta_expand_stack v2)) cuniv
    | (_, FLambda _) -&gt;
        let () = match v2 with
        | [] -&gt; ()
        | _ -&gt;
          anomaly (Pp.str &quot;conversion was given unreduced term (FLambda).&quot;)
        in
        let (x2,_ty2,bd2) = destFLambda mk_clos hd2 in
        let infos = push_relevance infos x2 in
        eqappr CONV l2r infos
          (el_lift lft1, (hd1, eta_expand_stack v1)) (el_lift lft2, (bd2, [])) cuniv

    (* only one constant, defined var or defined rel *)
    | (FFlex fl1, c2)      -&gt;
      begin match unfold_ref_with_args infos.cnv_inf infos.lft_tab fl1 v1 with
        | Some (def1,v1) -&gt;
          (** By virtue of the previous case analyses, we know [c2] is rigid.
              Conversion check to rigid terms eventually implies full weak-head
              reduction, so instead of repeatedly performing small-step
              unfoldings, we perform reduction with all flags on. *)
            let all = </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CClosure.RedFlagsSig, CClosure.RedFlagsSig

We were looking for a module signature name for the following shape:
[
  fBETA;
  fDELTA;
  fETA;
  fMATCH;
  fFIX;
  fCOFIX;
  fZETA;
  fCONST;
  fVAR;
  no_red;
  red_add;
  red_sub;
  red_add_transparent;
  red_transparent;
  mkflags;
  red_set;
  red_projection
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RedFlags.red_add_transparent</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> all (</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CClosure.RedFlagsSig, CClosure.RedFlagsSig

We were looking for a module signature name for the following shape:
[
  fBETA;
  fDELTA;
  fETA;
  fMATCH;
  fFIX;
  fCOFIX;
  fZETA;
  fCONST;
  fVAR;
  no_red;
  red_add;
  red_sub;
  red_add_transparent;
  red_transparent;
  mkflags;
  red_set;
  red_projection
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RedFlags.red_transparent</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> (info_flags infos.cnv_inf)) in
            let r1 = whd_stack (infos_with_reds infos.cnv_inf all) infos.lft_tab def1 v1 in
            eqappr cv_pb l2r infos (lft1, r1) appr2 cuniv
        | None -&gt;
          (match c2 with
           | FConstruct ((ind2,_j2),_u2) -&gt;
             </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
                let v2, v1 =
                  eta_expand_ind_stack (info_env infos.cnv_inf) ind2 hd2 v2 (snd appr1)
                in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
              with Not_found -&gt; raise NotConvertible)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
           | _ -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)
      end

    | (c1, FFlex fl2)      -&gt;
       begin match unfold_ref_with_args infos.cnv_inf infos.rgt_tab fl2 v2 with
        | Some (def2, v2) -&gt;
          (** Symmetrical case of above. *)
          let all = </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CClosure.RedFlagsSig, CClosure.RedFlagsSig

We were looking for a module signature name for the following shape:
[
  fBETA;
  fDELTA;
  fETA;
  fMATCH;
  fFIX;
  fCOFIX;
  fZETA;
  fCONST;
  fVAR;
  no_red;
  red_add;
  red_sub;
  red_add_transparent;
  red_transparent;
  mkflags;
  red_set;
  red_projection
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RedFlags.red_add_transparent</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> all (</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
CClosure.RedFlagsSig, CClosure.RedFlagsSig

We were looking for a module signature name for the following shape:
[
  fBETA;
  fDELTA;
  fETA;
  fMATCH;
  fFIX;
  fCOFIX;
  fZETA;
  fCONST;
  fVAR;
  no_red;
  red_add;
  red_sub;
  red_add_transparent;
  red_transparent;
  mkflags;
  red_set;
  red_projection
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">RedFlags.red_transparent</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> (info_flags infos.cnv_inf)) in
          let r2 = whd_stack (infos_with_reds infos.cnv_inf all) infos.rgt_tab def2 v2 in
          eqappr cv_pb l2r infos appr1 (lft2, r2) cuniv
        | None -&gt;
          match c1 with
          | FConstruct ((ind1,_j1),_u1) -&gt;
            </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try let v1, v2 =
                   eta_expand_ind_stack (info_env infos.cnv_inf) ind1 hd1 v1 (snd appr2)
               in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
             with Not_found -&gt; raise NotConvertible)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
          | _ -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
       end

    (* Inductive types:  MutInd MutConstruct Fix Cofix *)
    | (FInd (ind1,u1), FInd (ind2,u2)) -&gt;
      if eq_ind ind1 ind2 then
        if Univ.Instance.length u1 = 0 || Univ.Instance.length u2 = 0 then
          let cuniv = convert_instances ~flex:false u1 u2 cuniv in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          let mind = Environ.lookup_mind (fst ind1) (info_env infos.cnv_inf) in
          let nargs = CClosure.stack_args_size v1 in
          if not (Int.equal nargs (CClosure.stack_args_size v2))
          then raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
          else
            let cuniv = convert_inductives cv_pb (mind, snd ind1) nargs u1 u2 cuniv in
            convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
      else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    | (FConstruct ((ind1,j1),u1), FConstruct ((ind2,j2),u2)) -&gt;
      if Int.equal j1 j2 &amp;&amp; eq_ind ind1 ind2 then
        if Univ.Instance.length u1 = 0 || Univ.Instance.length u2 = 0 then
          let cuniv = convert_instances ~flex:false u1 u2 cuniv in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          let mind = Environ.lookup_mind (fst ind1) (info_env infos.cnv_inf) in
          let nargs = CClosure.stack_args_size v1 in
          if not (Int.equal nargs (CClosure.stack_args_size v2))
          then raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
          else
            let cuniv = convert_constructors (mind, snd ind1, j1) nargs u1 u2 cuniv in
            convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
      else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    (* Eta expansion of records *)
    | (FConstruct ((ind1,_j1),_u1), _) -&gt;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
         let v1, v2 =
            eta_expand_ind_stack (info_env infos.cnv_inf) ind1 hd1 v1 (snd appr2)
         in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       with Not_found -&gt; raise NotConvertible)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    | (_, FConstruct ((ind2,_j2),_u2)) -&gt;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try
         let v2, v1 =
            eta_expand_ind_stack (info_env infos.cnv_inf) ind2 hd2 v2 (snd appr1)
         in convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       with Not_found -&gt; raise NotConvertible)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    | (FFix (((op1, i1),(na1,tys1,cl1)),e1), FFix(((op2, i2),(_,tys2,cl2)),e2)) -&gt;
        if Int.equal i1 i2 &amp;&amp; Array.equal Int.equal op1 op2
        then
          let n = Array.length cl1 in
          let fty1 = Array.map (mk_clos e1) tys1 in
          let fty2 = Array.map (mk_clos e2) tys2 in
          let fcl1 = Array.map (mk_clos (subs_liftn n e1)) cl1 in
          let fcl2 = Array.map (mk_clos (subs_liftn n e2)) cl2 in
          let el1 = el_stack lft1 v1 in
          let el2 = el_stack lft2 v2 in
          let cuniv = convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
          let cuniv =
            let infos = push_relevances infos na1 in
            convert_vect l2r infos
                         (el_liftn n el1) (el_liftn n el2) fcl1 fcl2 cuniv
          in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    | (FCoFix ((op1,(na1,tys1,cl1)),e1), FCoFix((op2,(_,tys2,cl2)),e2)) -&gt;
        if Int.equal op1 op2
        then
          let n = Array.length cl1 in
          let fty1 = Array.map (mk_clos e1) tys1 in
          let fty2 = Array.map (mk_clos e2) tys2 in
          let fcl1 = Array.map (mk_clos (subs_liftn n e1)) cl1 in
          let fcl2 = Array.map (mk_clos (subs_liftn n e2)) cl2 in
          let el1 = el_stack lft1 v1 in
          let el2 = el_stack lft2 v2 in
          let cuniv = convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
          let cuniv =
            let infos = push_relevances infos na1 in
            convert_vect l2r infos
                         (el_liftn n el1) (el_liftn n el2) fcl1 fcl2 cuniv
          in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

    | FInt i1, FInt i2 -&gt;
       if Uint63.equal i1 i2 then convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
       else raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

     (* Should not happen because both (hd1,v1) and (hd2,v2) are in whnf *)
     | ( (FLetIn _, _) | (FCaseT _,_) | (FApp _,_) | (FCLOS _,_) | (FLIFT _,_)
       | (_, FLetIn _) | (_,FCaseT _) | (_,FApp _) | (_,FCLOS _) | (_,FLIFT _)
       | (FLOCKED,_) | (_,FLOCKED) ) -&gt; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert false</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">

     | (FRel _ | FAtom _ | FInd _ | FFix _ | FCoFix _
        | FProd _ | FEvar _ | FInt _), _ -&gt; raise </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr>

and convert_stacks l2r infos lft1 lft2 stk1 stk2 cuniv =
  let f (l1, t1) (l2, t2) cuniv = ccnv CONV l2r infos l1 l2 t1 t2 cuniv in
  let rec cmp_rec pstk1 pstk2 cuniv =
    match (pstk1,pstk2) with
      | (z1::s1, z2::s2) -&gt;
          let cu1 = cmp_rec s1 s2 cuniv in
          (match (z1,z2) with
            | (Zlapp a1,Zlapp a2) -&gt;
               Array.fold_right2 f a1 a2 cu1
            | (Zlproj (c1,_l1),Zlproj (c2,_l2)) -&gt;
              if not (Projection.Repr.equal c1 c2) then
                raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
              else cu1
            | (Zlfix(fx1,a1),Zlfix(fx2,a2)) -&gt;
                let cu2 = f fx1 fx2 cu1 in
                cmp_rec a1 a2 cu2
            | (Zlcase(ci1,l1,p1,br1,e1),Zlcase(ci2,l2,p2,br2,e2)) -&gt;
                <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (eq_ind ci1.ci_ind ci2.ci_ind) then
                  raise NotConvertible;
                let cu2 = f (l1, mk_clos e1 p1) (l2, mk_clos e2 p2) cu1 in
                convert_branches l2r infos ci1 e1 e2 l1 l2 br1 br2 cu2</abbr>
            | (Zlprimitive(op1,_,rargs1,kargs1),Zlprimitive(op2,_,rargs2,kargs2)) -&gt;
              if not (CPrimitives.equal op1 op2) then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr> else
                let cu2 = List.fold_right2 f rargs1 rargs2 cu1 in
                let fk (_,a1) (_,a2) cu = f a1 a2 cu in
                List.fold_right2 fk kargs1 kargs2 cu2
            | ((Zlapp _ | Zlproj _ | Zlfix _| Zlcase _| Zlprimitive _), _) -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>)
      | _ -&gt; cuniv in
  if compare_stack_shape stk1 stk2 then
    cmp_rec (pure_stack lft1 stk1) (pure_stack lft2 stk2) cuniv
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

and convert_vect l2r infos lft1 lft2 v1 v2 cuniv =
  let lv1 = Array.length v1 in
  let lv2 = Array.length v2 in
  if Int.equal lv1 lv2
  then
    let rec fold n cuniv =
      if n &gt;= lv1 then cuniv
      else
        let cuniv = ccnv CONV l2r infos lft1 lft2 v1.(n) v2.(n) cuniv in
        fold (n+1) cuniv in
    fold 0 cuniv
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

and convert_branches l2r infos ci e1 e2 lft1 lft2 br1 br2 cuniv =
  (** Skip comparison of the pattern types. We know that the two terms are
      living in a common type, thus this check is useless. *)
  let fold n c1 c2 cuniv = match skip_pattern infos n c1 c2 with
  | (infos, c1, c2) -&gt;
    let lft1 = el_liftn n lft1 in
    let lft2 = el_liftn n lft2 in
    let e1 = subs_liftn n e1 in
    let e2 = subs_liftn n e2 in
    ccnv CONV l2r infos lft1 lft2 (mk_clos e1 c1) (mk_clos e2 c2) cuniv
  | exception <abbr class="mark-warning" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">IrregularPatternShape</abbr> -&gt;
    (** Might happen due to a shape invariant that is not enforced *)
    ccnv CONV l2r infos lft1 lft2 (mk_clos e1 c1) (mk_clos e2 c2) cuniv
  in
  Array.fold_right3 fold ci.ci_cstr_nargs br1 br2 cuniv

let clos_gen_conv trans cv_pb l2r evars env univs t1 t2 =
  let reds = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
CClosure.RedFlagsSig, CClosure.RedFlagsSig

We were looking for a module signature name for the following shape:
[
  fBETA;
  fDELTA;
  fETA;
  fMATCH;
  fFIX;
  fCOFIX;
  fZETA;
  fCONST;
  fVAR;
  no_red;
  red_add;
  red_sub;
  red_add_transparent;
  red_transparent;
  mkflags;
  red_set;
  red_projection
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">CClosure.RedFlags.red_add_transparent</abbr> betaiotazeta trans in
  let infos = create_clos_infos ~evars reds env in
  let infos = {
    cnv_inf = infos;
    relevances = Range.empty;
    lft_tab = create_tab ();
    rgt_tab = create_tab ();
  } in
  ccnv cv_pb l2r infos el_id el_id (inject t1) (inject t2) univs


let check_eq univs u u' =
  if not (UGraph.check_eq univs u u') then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

let check_leq univs u u' =
  if not (UGraph.check_leq univs u u') then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

let check_sort_cmp_universes env pb s0 s1 univs =
  let open Sorts in
  if not (type_in_type env) then
    let check_pb u0 u1 =
      match pb with
      | CUMUL -&gt; check_leq univs u0 u1
      | CONV -&gt; check_eq univs u0 u1
    in
    match (s0,s1) with
    | SProp, SProp | Prop, Prop | Set, Set -&gt; ()
    | SProp, _ | _, SProp -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Prop, (Set | Type _) -&gt; if not (is_cumul pb) then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Set, Prop -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Set, Type u -&gt; check_pb Univ.type0_univ u
    | Type _u, Prop -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Type u, Set -&gt; check_pb u Univ.type0_univ
    | Type u0, Type u1 -&gt; check_pb u0 u1

let checked_sort_cmp_universes env pb s0 s1 univs =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_sort_cmp_universes env pb s0 s1 univs; univs</abbr>

let check_convert_instances ~flex:_ u u' univs =
  if UGraph.check_eq_instances univs u u' then univs
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

(* general conversion and inference functions *)
let check_inductive_instances cv_pb variance u1 u2 univs =
  let csts = get_cumulativity_constraints cv_pb variance u1 u2 in
  if (UGraph.check_constraints csts univs) then univs
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

let checked_universes =
  { compare_sorts = checked_sort_cmp_universes;
    compare_instances = check_convert_instances;
    compare_cumul_instances = check_inductive_instances; }

let infer_eq (univs, cstrs as cuniv) u u' =
  if UGraph.check_eq univs u u' then cuniv
  else
    univs, (Univ.enforce_eq u u' cstrs)

let infer_leq (univs, cstrs as cuniv) u u' =
  if UGraph.check_leq univs u u' then cuniv
  else
    let cstrs', _ = UGraph.enforce_leq_alg u u' univs in
      univs, Univ.Constraint.union cstrs cstrs'

let infer_cmp_universes env pb s0 s1 univs =
  if type_in_type env
  then univs
  else
    let open Sorts in
    let infer_pb u0 u1 =
      match pb with
      | CUMUL -&gt; infer_leq univs u0 u1
      | CONV -&gt; infer_eq univs u0 u1
    in
    match (s0,s1) with
    | SProp, SProp | Prop, Prop | Set, Set -&gt; univs
    | SProp, _ | _, SProp -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Prop, (Set | Type _) -&gt; if not (is_cumul pb) then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr> else univs
    | Set, Prop -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    | Set, Type u -&gt; infer_pb Univ.type0_univ u
    | Type u, Prop -&gt; infer_pb u Univ.type0m_univ
    | Type u, Set -&gt; infer_pb u Univ.type0_univ
    | Type u0, Type u1 -&gt; infer_pb u0 u1

let infer_convert_instances ~flex u u' (univs,cstrs) =
  let cstrs' =
    if flex then
      if UGraph.check_eq_instances univs u u' then cstrs
      else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
    else Univ.enforce_eq_instances u u' cstrs
  in (univs, cstrs')

let infer_inductive_instances cv_pb variance u1 u2 (univs,csts') =
  let csts = get_cumulativity_constraints cv_pb variance u1 u2 in
  (univs, Univ.Constraint.union csts csts')

let inferred_universes : (UGraph.t * Univ.Constraint.t) universe_compare =
  { compare_sorts = infer_cmp_universes;
    compare_instances = infer_convert_instances;
    compare_cumul_instances = infer_inductive_instances; }

let gen_conv cv_pb l2r reds env evars univs t1 t2 =
  let b =
    if cv_pb = CUMUL then leq_constr_univs univs t1 t2
    else eq_constr_univs univs t1 t2
  in
    if b then ()
    else
      let _ = clos_gen_conv reds cv_pb l2r evars env (univs, checked_universes) t1 t2 in
        ()

(* Profiling *)
let gen_conv cv_pb ?(l2r=false) ?(reds=TransparentState.full) env ?(evars=(fun _-&gt;None), universes env) =
  let evars, univs = evars in
  if Flags.profile then
    let fconv_universes_key = CProfile.declare_profile &quot;trans_fconv_universes&quot; in
      CProfile.profile8 fconv_universes_key gen_conv cv_pb l2r reds env evars univs
  else gen_conv cv_pb l2r reds env evars univs

let conv = gen_conv CONV

let conv_leq = gen_conv CUMUL

let generic_conv cv_pb ~l2r evars reds env univs t1 t2 =
  let (s, _) =
    clos_gen_conv reds cv_pb l2r evars env univs t1 t2
  in s

let infer_conv_universes cv_pb l2r evars reds env univs t1 t2 =
  let b, cstrs =
    if cv_pb == CUMUL then Constr.leq_constr_univs_infer univs t1 t2
    else Constr.eq_constr_univs_infer univs t1 t2
  in
    if b then cstrs
    else
      let univs = ((univs, Univ.Constraint.empty), inferred_universes) in
      let ((_,cstrs), _) = clos_gen_conv reds cv_pb l2r evars env univs t1 t2 in
        cstrs

(* Profiling *)
let infer_conv_universes =
  if Flags.profile then
    let infer_conv_universes_key = CProfile.declare_profile &quot;infer_conv_universes&quot; in
      CProfile.profile8 infer_conv_universes_key infer_conv_universes
  else infer_conv_universes

let infer_conv ?(l2r=false) ?(evars=fun _ -&gt; None) ?(ts=TransparentState.full)
    env univs t1 t2 =
  infer_conv_universes CONV l2r evars ts env univs t1 t2

let infer_conv_leq ?(l2r=false) ?(evars=fun _ -&gt; None) ?(ts=TransparentState.full)
    env univs t1 t2 =
  infer_conv_universes CUMUL l2r evars ts env univs t1 t2

let default_conv cv_pb ?l2r:_ env t1 t2 =
    gen_conv cv_pb env t1 t2

let default_conv_leq = default_conv CUMUL
(*
let convleqkey = CProfile.declare_profile &quot;Kernel_reduction.conv_leq&quot;;;
let conv_leq env t1 t2 =
  CProfile.profile4 convleqkey conv_leq env t1 t2;;

let convkey = CProfile.declare_profile &quot;Kernel_reduction.conv&quot;;;
let conv env t1 t2 =
  CProfile.profile4 convleqkey conv env t1 t2;;
*)

(* Application with on-the-fly reduction *)

let beta_applist c l =
  let rec app subst c l =
    match kind c, l with
    | Lambda(_,_,c), arg::l -&gt; app (arg::subst) c l
    | _ -&gt; Term.applist (substl subst c, l) in
  app [] c l

let beta_appvect c v = beta_applist c (Array.to_list v)

let beta_app c a = beta_applist c [a]

(* Compatibility *)
let betazeta_appvect = Term.lambda_appvect_assum

(********************************************************************)
(*             Special-Purpose Reduction                            *)
(********************************************************************)

(* pseudo-reduction rule:
 * [hnf_prod_app env (Prod(_,B)) N --&gt; B[N]
 * with an HNF on the first argument to produce a product.
 * if this does not work, then we use the string S as part of our
 * error message. *)

let hnf_prod_app env t n =
  match kind (whd_all env t) with
    | Prod (_,_,b) -&gt; subst1 n b
    | _ -&gt; anomaly ~label:&quot;hnf_prod_app&quot; (Pp.str &quot;Need a product.&quot;)

let hnf_prod_applist env t nl =
  List.fold_left (hnf_prod_app env) t nl

let hnf_prod_applist_assum env n c l =
  let rec app n subst t l =
    if Int.equal n 0 then
      if l == [] then substl subst t
      else anomaly (Pp.str &quot;Too many arguments.&quot;)
    else match kind (whd_allnolet env t), l with
    | Prod(_,_,c), arg::l -&gt; app (n-1) (arg::subst) c l
    | LetIn(_,b,_,c), _ -&gt; app (n-1) (substl subst b::subst) c l
    | _, [] -&gt; anomaly (Pp.str &quot;Not enough arguments.&quot;)
    | _ -&gt; anomaly (Pp.str &quot;Not enough prod/let's.&quot;) in
  app n [] c l

(* Dealing with arities *)

let dest_prod env =
  let rec decrec env m c =
    let t = whd_all env c in
    match kind t with
      | Prod (n,a,c0) -&gt;
          let d = LocalAssum (n,a) in
          decrec (push_rel d env) (Context.Rel.add d m) c0
      | _ -&gt; m,t
  in
  decrec env Context.Rel.empty

let dest_lam env =
  let rec decrec env m c =
    let t = whd_all env c in
    match kind t with
      | Lambda (n,a,c0) -&gt;
          let d = LocalAssum (n,a) in
          decrec (push_rel d env) (Context.Rel.add d m) c0
      | _ -&gt; m,t
  in
  decrec env Context.Rel.empty

(* The same but preserving lets in the context, not internal ones. *)
let dest_prod_assum env =
  let rec prodec_rec env l ty =
    let rty = whd_allnolet env ty in
    match kind rty with
    | Prod (x,t,c)  -&gt;
        let d = LocalAssum (x,t) in
        prodec_rec (push_rel d env) (Context.Rel.add d l) c
    | LetIn (x,b,t,c) -&gt;
        let d = LocalDef (x,b,t) in
        prodec_rec (push_rel d env) (Context.Rel.add d l) c
    | _               -&gt;
      let rty' = whd_all env rty in
        if Constr.equal rty' rty then l, rty
        else prodec_rec env l rty'
  in
  prodec_rec env Context.Rel.empty

let dest_lam_assum env =
  let rec lamec_rec env l ty =
    let rty = whd_allnolet env ty in
    match kind rty with
    | Lambda (x,t,c)  -&gt;
        let d = LocalAssum (x,t) in
        lamec_rec (push_rel d env) (Context.Rel.add d l) c
    | LetIn (x,b,t,c) -&gt;
        let d = LocalDef (x,b,t) in
        lamec_rec (push_rel d env) (Context.Rel.add d l) c
    | _               -&gt; l,rty
  in
  lamec_rec env Context.Rel.empty

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception NotArity</abbr>

let dest_arity env c =
  let l, c = dest_prod_assum env c in
  match kind c with
    | Sort s -&gt; l,s
    | _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotArity</abbr>

let is_arity env c =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let _ = dest_arity env c in
    true
  with NotArity -&gt; false</abbr>

let eta_expand env t ty =
  let ctxt, _codom = dest_prod env ty in
  let ctxt',t = dest_lam env t in
  let d = Context.Rel.nhyps ctxt - Context.Rel.nhyps ctxt' in
  let eta_args = List.rev_map mkRel (List.interval 1 d) in
  let t = Term.applistc (Vars.lift d t) eta_args in
  let t = Term.it_mkLambda_or_LetIn t (List.firstn d ctxt) in
  Term.it_mkLambda_or_LetIn t ctxt'
</pre>
  </div>
  <div class="col-md-6">
    <a href="#reduction.ml"><code>Reduction.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Vars.

Import Environ.

Import CClosure.

Import Esubst.

Import Context.Rel.Declaration.

Fixpoint is_empty_stack (function_parameter : list CClosure.stack_member)
  {struct function_parameter} : bool :=
  match function_parameter with
  | [] =&gt; true
  | cons (CClosure.Zupdate _) s =&gt; is_empty_stack s
  | cons (CClosure.Zshift _) s =&gt; is_empty_stack s
  | _ =&gt; false
  end.

Definition el_stack (el : Esubst.lift) (stk : list CClosure.stack_member)
  : Esubst.lift :=
  let n :=
    (|Util.List|).(CList.ExtS.fold_left)
      (fun i =&gt;
        fun z =&gt;
          match z with
          | CClosure.Zshift n =&gt; Z.add i n
          | _ =&gt; i
          end) 0 stk in
  el_shft n el.

Definition compare_stack_shape (stk1 : CClosure.stack) (stk2 : CClosure.stack)
  : bool :=
  let fix compare_rec
    (bal : Int.t) (stk1 : CClosure.stack) (stk2 : CClosure.stack) {struct bal}
    : bool :=
    match (stk1, stk2) with
    | ([], []) =&gt; Int.equal bal 0
    | (cons (CClosure.Zupdate _ | CClosure.Zshift _) s1, _) =&gt;
      compare_rec bal s1 stk2
    | (_, cons (CClosure.Zupdate _ | CClosure.Zshift _) s2) =&gt;
      compare_rec bal stk1 s2
    | (cons (CClosure.Zapp l1) s1, _) =&gt;
      compare_rec (Z.add bal ((|Util.Array|).(CArray.ExtS.length) l1)) s1 stk2
    | (_, cons (CClosure.Zapp l2) s2) =&gt;
      compare_rec (Z.sub bal ((|Util.Array|).(CArray.ExtS.length) l2)) stk1 s2
    | (cons (CClosure.Zproj _p1) s1, cons (CClosure.Zproj _p2) s2) =&gt;
      andb (Int.equal bal 0) (compare_rec 0 s1 s2)
    | (cons (CClosure.ZcaseT _c1 _ _ _) s1, cons (CClosure.ZcaseT _c2 _ _ _) s2)
      =&gt; andb (Int.equal bal 0) (compare_rec 0 s1 s2)
    | (cons (CClosure.Zfix _ a1) s1, cons (CClosure.Zfix _ a2) s2) =&gt;
      andb (Int.equal bal 0) (andb (compare_rec 0 a1 a2) (compare_rec 0 s1 s2))
    |
      (cons (CClosure.Zprimitive op1 _ rargs1 _kargs1) s1,
        cons (CClosure.Zprimitive op2 _ rargs2 _kargs2) s2) =&gt;
      andb (equiv_decb bal 0)
        (andb (equiv_decb op1 op2)
          (andb
            (equiv_decb ((|Util.List|).(CList.ExtS.length) rargs1)
              ((|Util.List|).(CList.ExtS.length) rargs2)) (compare_rec 0 s1 s2)))
    |
      ([], cons _ _) |
      (cons
        (CClosure.Zproj _ | CClosure.ZcaseT _ _ _ _ | CClosure.Zfix _ _ |
        CClosure.Zprimitive _ _ _ _) _, _) =&gt; false
    end in
  compare_rec 0 stk1 stk2.

Definition lft_fconstr := Esubst.lift * CClosure.fconstr.

Reserved Notation &quot;'lft_constr_stack&quot;.

Inductive lft_constr_stack_elt : Set :=
| Zlapp : array (Esubst.lift * CClosure.fconstr) -&gt; lft_constr_stack_elt
| Zlproj : Names.Projection.Repr.t -&gt; Esubst.lift -&gt; lft_constr_stack_elt
| Zlfix :
  Esubst.lift * CClosure.fconstr -&gt; 'lft_constr_stack -&gt; lft_constr_stack_elt
| Zlcase :
  Constr.case_info -&gt; Esubst.lift -&gt; Constr.constr -&gt; array Constr.constr -&gt;
  Esubst.subs CClosure.fconstr -&gt; lft_constr_stack_elt
| Zlprimitive :
  CPrimitives.t -&gt; Constr.pconstant -&gt; list lft_fconstr -&gt;
  CClosure.next_native_args lft_fconstr -&gt; lft_constr_stack_elt

where &quot;'lft_constr_stack&quot; := (list lft_constr_stack_elt).

Definition lft_constr_stack := 'lft_constr_stack.

Fixpoint zlapp
  (v : array (Esubst.lift * CClosure.fconstr))
  (function_parameter : list lft_constr_stack_elt) {struct v}
  : list lft_constr_stack_elt :=
  match function_parameter with
  | cons (Zlapp v2) s =&gt; zlapp ((|Util.Array|).(CArray.ExtS.append) v v2) s
  | s =&gt; cons (Zlapp v) s
  end.

Definition map_lift (l : Esubst.lift) (v : array CClosure.fconstr)
  : array (Esubst.lift * CClosure.fconstr) :=
  match v with
  | tt =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | (c0) =&gt;
    (* ❌ Arrays not handled. *)
    [ (l, c0) ]
  | (c0, c1) =&gt;
    (* ❌ Arrays not handled. *)
    [ (l, c0); (l, c1) ]
  | (c0, c1, c2) =&gt;
    (* ❌ Arrays not handled. *)
    [ (l, c0); (l, c1); (l, c2) ]
  | (c0, c1, c2, c3) =&gt;
    (* ❌ Arrays not handled. *)
    [ (l, c0); (l, c1); (l, c2); (l, c3) ]
  | v =&gt; Array.Fun1.map (fun l =&gt; fun t =&gt; (l, t)) l v
  end.

Definition pure_stack (lfts : Esubst.lift) (stk : list CClosure.stack_member)
  : list lft_constr_stack_elt :=
  let fix pure_rec (lfts : Esubst.lift) (stk : list CClosure.stack_member)
    {struct lfts} : Esubst.lift * list lft_constr_stack_elt :=
    match stk with
    | [] =&gt; (lfts, [])
    | cons zi s =&gt;
      match (zi, (pure_rec lfts s)) with
      | (CClosure.Zupdate _, lpstk) =&gt; lpstk
      | (CClosure.Zshift n, (l, pstk)) =&gt; ((el_shft n l), pstk)
      | (CClosure.Zapp a, (l, pstk)) =&gt; (l, (zlapp (map_lift l a) pstk))
      | (CClosure.Zproj p, (l, pstk)) =&gt; (l, (cons (Zlproj p l) pstk))
      | (CClosure.Zfix fx a, (l, pstk)) =&gt;
        let '(lfx, pa) := pure_rec l a in
        (l, (cons (Zlfix (lfx, fx) pa) pstk))
      | (CClosure.ZcaseT ci p br e, (l, pstk)) =&gt;
        (l, (cons (Zlcase ci l p br e) pstk))
      | (CClosure.Zprimitive op c rargs kargs, (l, pstk)) =&gt;
        (l,
          (cons
            (Zlprimitive op c
              ((|Util.List|).(CList.ExtS.map) (fun t =&gt; (l, t)) rargs)
              ((|Util.List|).(CList.ExtS.map)
                (fun function_parameter =&gt;
                  let '(k, t) := function_parameter in
                  (k, (l, t))) kargs)) pstk))
      end
    end in
  snd (pure_rec lfts stk).

Definition whd_betaiota (env : Environ.env) (t : Constr.constr)
  : Constr.constr :=
  match kind t with
  |
    Constr.Sort _ | Constr.Var _ | Constr.Meta _ | Constr.Evar _ |
    Constr.Const _ | Constr.Ind _ | Constr.Construct _ | Constr.Prod _ _ _ |
    Constr.Lambda _ _ _ | Constr.Fix _ | Constr.CoFix _ =&gt; t
  | Constr.App c _ =&gt;
    match kind c with
    |
      Constr.Ind _ | Constr.Construct _ | Constr.Evar _ | Constr.Meta _ |
      Constr.Const _ | Constr.LetIn _ _ _ _ =&gt; t
    | _ =&gt;
      whd_val (create_clos_infos None betaiota env) (create_tab tt) (inject t)
    end
  | _ =&gt;
    whd_val (create_clos_infos None betaiota env) (create_tab tt) (inject t)
  end.

Definition nf_betaiota (env : Environ.env) (t : Constr.constr)
  : Constr.constr :=
  norm_val (create_clos_infos None betaiota env) (create_tab tt) (inject t).

Definition whd_betaiotazeta (env : Environ.env) (x : Constr.constr)
  : Constr.constr :=
  match kind x with
  |
    Constr.Sort _ | Constr.Var _ | Constr.Meta _ | Constr.Evar _ |
    Constr.Const _ | Constr.Ind _ | Constr.Construct _ | Constr.Prod _ _ _ |
    Constr.Lambda _ _ _ | Constr.Fix _ | Constr.CoFix _ | Constr.Int _ =&gt; x
  | Constr.App c _ =&gt;
    match kind c with
    |
      Constr.Ind _ | Constr.Construct _ | Constr.Evar _ | Constr.Meta _ |
      Constr.Const _ | Constr.Int _ =&gt; x
    |
      Constr.Sort _ | Constr.Rel _ | Constr.Var _ | Constr.Cast _ _ _ |
      Constr.Prod _ _ _ | Constr.Lambda _ _ _ | Constr.LetIn _ _ _ _ |
      Constr.App _ _ | Constr.Case _ _ _ _ | Constr.Fix _ | Constr.CoFix _ |
      Constr.Proj _ _ =&gt;
      whd_val (create_clos_infos None betaiotazeta env) (create_tab tt)
        (inject x)
    end
  |
    Constr.Rel _ | Constr.Cast _ _ _ | Constr.LetIn _ _ _ _ |
    Constr.Case _ _ _ _ | Constr.Proj _ _ =&gt;
    whd_val (create_clos_infos None betaiotazeta env) (create_tab tt) (inject x)
  end.

Definition whd_all (env : Environ.env) (t : Constr.constr) : Constr.constr :=
  match kind t with
  |
    Constr.Sort _ | Constr.Meta _ | Constr.Evar _ | Constr.Ind _ |
    Constr.Construct _ | Constr.Prod _ _ _ | Constr.Lambda _ _ _ | Constr.Fix _
    | Constr.CoFix _ | Constr.Int _ =&gt; t
  | Constr.App c _ =&gt;
    match kind c with
    |
      Constr.Ind _ | Constr.Construct _ | Constr.Evar _ | Constr.Meta _ |
      Constr.Int _ =&gt; t
    |
      Constr.Sort _ | Constr.Rel _ | Constr.Var _ | Constr.Cast _ _ _ |
      Constr.Prod _ _ _ | Constr.Lambda _ _ _ | Constr.LetIn _ _ _ _ |
      Constr.App _ _ | Constr.Const _ | Constr.Case _ _ _ _ | Constr.Fix _ |
      Constr.CoFix _ | Constr.Proj _ _ =&gt;
      whd_val (create_clos_infos None all env) (create_tab tt) (inject t)
    end
  |
    Constr.Rel _ | Constr.Cast _ _ _ | Constr.LetIn _ _ _ _ |
    Constr.Case _ _ _ _ | Constr.Proj _ _ | Constr.Const _ | Constr.Var _ =&gt;
    whd_val (create_clos_infos None all env) (create_tab tt) (inject t)
  end.

Definition whd_allnolet (env : Environ.env) (t : Constr.constr)
  : Constr.constr :=
  match kind t with
  |
    Constr.Sort _ | Constr.Meta _ | Constr.Evar _ | Constr.Ind _ |
    Constr.Construct _ | Constr.Prod _ _ _ | Constr.Lambda _ _ _ | Constr.Fix _
    | Constr.CoFix _ | Constr.LetIn _ _ _ _ | Constr.Int _ =&gt; t
  | Constr.App c _ =&gt;
    match kind c with
    |
      Constr.Ind _ | Constr.Construct _ | Constr.Evar _ | Constr.Meta _ |
      Constr.LetIn _ _ _ _ | Constr.Int _ =&gt; t
    |
      Constr.Sort _ | Constr.Rel _ | Constr.Var _ | Constr.Cast _ _ _ |
      Constr.Prod _ _ _ | Constr.Lambda _ _ _ | Constr.App _ _ | Constr.Const _
      | Constr.Case _ _ _ _ | Constr.Fix _ | Constr.CoFix _ | Constr.Proj _ _ =&gt;
      whd_val (create_clos_infos None allnolet env) (create_tab tt) (inject t)
    end
  |
    Constr.Rel _ | Constr.Cast _ _ _ | Constr.Case _ _ _ _ | Constr.Proj _ _ |
    Constr.Const _ | Constr.Var _ =&gt;
    whd_val (create_clos_infos None allnolet env) (create_tab tt) (inject t)
  end.

Definition kernel_conversion_function (a : Set) :=
  Environ.env -&gt; a -&gt; a -&gt; unit.

Definition extended_conversion_function (a : Set) :=
  option bool -&gt; option TransparentState.t -&gt; Environ.env -&gt;
  option ((Constr.existential -&gt; option Constr.constr) * UGraph.t) -&gt; a -&gt; a -&gt;
  unit.

(* ❌ The definition of exceptions is not handled. *)
(* exception NotConvertible *)

Inductive conv_pb : Set :=
| CONV : conv_pb
| CUMUL : conv_pb.

Definition is_cumul (function_parameter : conv_pb) : bool :=
  match function_parameter with
  | CUMUL =&gt; true
  | CONV =&gt; false
  end.

Module universe_compare.
  Record record {a : Set} := {
    compare_sorts : Environ.env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt; a -&gt; a;
    compare_instances : bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; a -&gt; a;
    compare_cumul_instances :
      conv_pb -&gt; array Univ.Variance.t -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt;
      a -&gt; a }.
  Arguments record : clear implicits.
  Definition with_compare_sorts {a_type : Set} (r : record a_type) compare_sorts
    : record a_type :=
    {| compare_sorts := compare_sorts; compare_instances := compare_instances r;
      compare_cumul_instances := compare_cumul_instances r |}.
  Definition with_compare_instances {a_type : Set} (r : record a_type)
    compare_instances : record a_type :=
    {| compare_sorts := compare_sorts r; compare_instances := compare_instances;
      compare_cumul_instances := compare_cumul_instances r |}.
  Definition with_compare_cumul_instances {a_type : Set} (r : record a_type)
    compare_cumul_instances : record a_type :=
    {| compare_sorts := compare_sorts r;
      compare_instances := compare_instances r;
      compare_cumul_instances := compare_cumul_instances |}.
End universe_compare.
Definition universe_compare := universe_compare.record.

Definition universe_state (a : Set) := a * universe_compare a.

Definition generic_conversion_function (a b : Set) :=
  Environ.env -&gt; universe_state b -&gt; a -&gt; a -&gt; b.

Definition infer_conversion_function (a : Set) :=
  Environ.env -&gt; UGraph.t -&gt; a -&gt; a -&gt; Univ.Constraint.t.

Definition sort_cmp_universes {A : Set}
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (function_parameter : A * universe_compare A) : A * universe_compare A :=
  let '(u, check) := function_parameter in
  (((universe_compare.compare_sorts check) env pb s0 s1 u), check).

Definition convert_instances {A : Set}
  (flex : bool) (u : Univ.Instance.t) (u' : Univ.Instance.t)
  (function_parameter : A * universe_compare A) : A * universe_compare A :=
  let '(s, check) := function_parameter in
  (((universe_compare.compare_instances check) flex u u' s), check).

Definition get_cumulativity_constraints
  (cv_pb : conv_pb) (variance : array Univ.Variance.t) (u : Univ.Instance.t)
  (u' : Univ.Instance.t) : Univ.Constraint.t :=
  match cv_pb with
  | CONV =&gt;
    Univ.enforce_eq_variance_instances variance u u' Univ.Constraint.empty
  | CUMUL =&gt;
    Univ.enforce_leq_variance_instances variance u u' Univ.Constraint.empty
  end.

Definition inductive_cumulativity_arguments
  (function_parameter : Declarations.mutual_inductive_body * Z) : Z :=
  let '(mind, ind) := function_parameter in
  Z.add (Declarations.mutual_inductive_body.mind_nparams mind)
    (Declarations.one_inductive_body.mind_nrealargs
      ((|Util.Array|).(CArray.ExtS.get)
        (Declarations.mutual_inductive_body.mind_packets mind) ind)).

Definition convert_inductives_gen {A B C D E : Set}
  (cmp_instances : A -&gt; B -&gt; C -&gt; D)
  (cmp_cumul : E -&gt; array Univ.Variance.t -&gt; A -&gt; B -&gt; C -&gt; D) (cv_pb : E)
  (function_parameter : Declarations.mutual_inductive_body * Z)
  : Int.t -&gt; A -&gt; B -&gt; C -&gt; D :=
  let '(mind, ind) := function_parameter in
  fun nargs =&gt;
    fun u1 =&gt;
      fun u2 =&gt;
        fun s =&gt;
          match Declarations.mutual_inductive_body.mind_variance mind with
          | None =&gt; cmp_instances u1 u2 s
          | Some variances =&gt;
            let num_param_arity := inductive_cumulativity_arguments (mind, ind)
              in
            if negb (Int.equal num_param_arity nargs) then
              cmp_instances u1 u2 s
            else
              cmp_cumul cv_pb variances u1 u2 s
          end.

Definition convert_inductives {A : Set}
  (cv_pb : conv_pb) (ind : Declarations.mutual_inductive_body * Z)
  (nargs : Int.t) (u1 : Univ.Instance.t) (u2 : Univ.Instance.t)
  (function_parameter : A * universe_compare A) : A * universe_compare A :=
  let '(s, check) := function_parameter in
  ((convert_inductives_gen ((universe_compare.compare_instances check) false)
    (universe_compare.compare_cumul_instances check) cv_pb ind nargs u1 u2 s),
    check).

Definition constructor_cumulativity_arguments
  (function_parameter : Declarations.mutual_inductive_body * Z * Z) : Z :=
  let '(mind, ind, ctor) := function_parameter in
  Z.add (Declarations.mutual_inductive_body.mind_nparams mind)
    ((|Util.Array|).(CArray.ExtS.get)
      (Declarations.one_inductive_body.mind_consnrealargs
        ((|Util.Array|).(CArray.ExtS.get)
          (Declarations.mutual_inductive_body.mind_packets mind) ind))
      (Z.sub ctor 1)).

Definition convert_constructors_gen {A B C : Set}
  (cmp_instances : Univ.Instance.t -&gt; A -&gt; B -&gt; C)
  (cmp_cumul :
    conv_pb -&gt; array Univ.Variance.t -&gt; Univ.Instance.t -&gt; A -&gt; B -&gt; C)
  (function_parameter : Declarations.mutual_inductive_body * Z * Z)
  : Int.t -&gt; Univ.Instance.t -&gt; A -&gt; B -&gt; C :=
  let '(mind, ind, cns) := function_parameter in
  fun nargs =&gt;
    fun u1 =&gt;
      fun u2 =&gt;
        fun s =&gt;
          match Declarations.mutual_inductive_body.mind_variance mind with
          | None =&gt; cmp_instances u1 u2 s
          | Some _ =&gt;
            let num_cnstr_args :=
              constructor_cumulativity_arguments (mind, ind, cns) in
            if negb (Int.equal num_cnstr_args nargs) then
              cmp_instances u1 u2 s
            else
              let variance :=
                (|Util.Array|).(CArray.ExtS.make) (Univ.Instance.length u1)
                  Univ.Variance.Irrelevant in
              cmp_cumul CONV variance u1 u2 s
          end.

Definition convert_constructors {A : Set}
  (ctor : Declarations.mutual_inductive_body * Z * Z) (nargs : Int.t)
  (u1 : Univ.Instance.t) (u2 : Univ.Instance.t)
  (function_parameter : A * universe_compare A) : A * universe_compare A :=
  let '(s, check) := function_parameter in
  ((convert_constructors_gen ((universe_compare.compare_instances check) false)
    (universe_compare.compare_cumul_instances check) ctor nargs u1 u2 s), check).

Definition conv_table_key {A : Set}
  (infos : CClosure.clos_infos)
  (k1 : Names.tableKey (Names.Constant.t * Univ.Instance.t))
  (k2 : Names.tableKey (Names.Constant.t * Univ.Instance.t))
  (cuniv : A * universe_compare A) : A * universe_compare A :=
  if Stdlib.op_eqeq k1 k2 then
    cuniv
  else
    match
      ((k1, k2),
        match (k1, k2) with
        | (Names.ConstKey (cst, u), Names.ConstKey (cst', u')) =&gt;
          Constant.equal cst cst'
        | _ =&gt; false
        end,
        match (k1, k2) with
        | (Names.VarKey id, Names.VarKey id') =&gt; Id.equal id id'
        | _ =&gt; false
        end,
        match (k1, k2) with
        | (Names.RelKey n, Names.RelKey n') =&gt; Int.equal n n'
        | _ =&gt; false
        end) with
    | ((Names.ConstKey (cst, u), Names.ConstKey (cst', u')), true, _, _) =&gt;
      if Univ.Instance.equal u u' then
        cuniv
      else
        let flex :=
          andb (evaluable_constant cst (info_env infos))
            ((|CClosure.RedFlags|).(CClosure.RedFlagsSig.red_set)
              (info_flags infos)
              ((|CClosure.RedFlags|).(CClosure.RedFlagsSig.fCONST) cst)) in
        convert_instances flex u u' cuniv
    | ((Names.VarKey id, Names.VarKey id'), _, true, _) =&gt; cuniv
    | ((Names.RelKey n, Names.RelKey n'), _, _, true) =&gt; cuniv
    | (_, _, _, _) =&gt; Stdlib.raise extensible_type_value
    end.

(* ❌ The definition of exceptions is not handled. *)
(* exception IrregularPatternShape *)

Definition unfold_ref_with_args
  (infos : CClosure.clos_infos) (tab : CClosure.clos_tab)
  (fl : CClosure.table_key) (v : CClosure.stack)
  : option (CClosure.fconstr * CClosure.stack) :=
  match
    ((unfold_reference infos tab fl),
      match unfold_reference infos tab fl with
      | Declarations.Primitive op =&gt; check_native_args op v
      | _ =&gt; false
      end) with
  | (Declarations.Def def, _) =&gt; Some (def, v)
  | (Declarations.Primitive op, true) =&gt;
    let c :=
      match fl with
      | Names.ConstKey c =&gt; c
      | _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end in
    let '(rargs, a, nargs, v) := get_native_args1 op c v in
    Some
      (whd_stack infos tab a
        (cons (CClosure.Zupdate a)
          (cons (CClosure.Zprimitive op c rargs nargs) v)))
  |
    (Declarations.Undef _ | Declarations.OpaqueDef _ | Declarations.Primitive _,
      _) =&gt; None
  end.

Module conv_tab.
  Record record := {
    cnv_inf : CClosure.clos_infos;
    relevances : Range.t Sorts.relevance;
    lft_tab : CClosure.clos_tab;
    rgt_tab : CClosure.clos_tab }.
  Definition with_cnv_inf (r : record) cnv_inf : record :=
    {| cnv_inf := cnv_inf; relevances := relevances r; lft_tab := lft_tab r;
      rgt_tab := rgt_tab r |}.
  Definition with_relevances (r : record) relevances : record :=
    {| cnv_inf := cnv_inf r; relevances := relevances; lft_tab := lft_tab r;
      rgt_tab := rgt_tab r |}.
  Definition with_lft_tab (r : record) lft_tab : record :=
    {| cnv_inf := cnv_inf r; relevances := relevances r; lft_tab := lft_tab;
      rgt_tab := rgt_tab r |}.
  Definition with_rgt_tab (r : record) rgt_tab : record :=
    {| cnv_inf := cnv_inf r; relevances := relevances r; lft_tab := lft_tab r;
      rgt_tab := rgt_tab |}.
End conv_tab.
Definition conv_tab := conv_tab.record.

Definition push_relevance {A : Set}
  (infos : conv_tab) (r : Context.binder_annot A) : conv_tab :=
  conv_tab.with_relevances infos
    (Range.cons (Context.binder_annot.binder_relevance r)
      (conv_tab.relevances infos)).

Definition push_relevances {A : Set}
  (infos : conv_tab) (nas : array (Context.binder_annot A)) : conv_tab :=
  conv_tab.with_relevances infos
    ((|Util.Array|).(CArray.ExtS.fold_left)
      (fun l =&gt; fun x =&gt; Range.cons (Context.binder_annot.binder_relevance x) l)
      (conv_tab.relevances infos) nas).

Fixpoint skip_pattern
  (infos : conv_tab) (relevances : Range.t Sorts.relevance) (n : Int.t)
  (c1 : Constr.constr) (c2 : Constr.constr) {struct infos}
  : conv_tab * Constr.constr * Constr.constr :=
  if Int.equal n 0 then
    ((conv_tab.with_relevances infos relevances), c1, c2)
  else
    match ((kind c1), (kind c2)) with
    | (Constr.Lambda x _ c1, Constr.Lambda _ _ c2) =&gt;
      skip_pattern infos
        (Range.cons (Context.binder_annot.binder_relevance x) relevances)
        (Z.pred n) c1 c2
    | _ =&gt; Stdlib.raise extensible_type_value
    end.

Definition skip_pattern
  (infos : conv_tab) (n : Int.t) (c1 : Constr.constr) (c2 : Constr.constr)
  : conv_tab * Constr.constr * Constr.constr :=
  if Int.equal n 0 then
    (infos, c1, c2)
  else
    skip_pattern infos (conv_tab.relevances infos) n c1 c2.

Definition is_irrelevant
  (infos : conv_tab) (lft : Esubst.lift) (c : CClosure.fconstr) : bool :=
  let env := info_env (conv_tab.cnv_inf infos) in
  (* ❌ Try-with are not handled *)
  try
    (Stdlib.op_eqeq
      (Retypeops.relevance_of_fterm env (conv_tab.relevances infos) lft c)
      Sorts.Irrelevant).

Fixpoint ccnv {A : Set}
  (cv_pb : conv_pb) (l2r : bool) (infos : conv_tab) (lft1 : Esubst.lift)
  (lft2 : Esubst.lift) (term1 : CClosure.fconstr) (term2 : CClosure.fconstr)
  (cuniv : A * universe_compare A) {struct cv_pb} : A * universe_compare A :=
  (* ❌ Try-with are not handled *)
  try (eqappr cv_pb l2r infos (lft1, (term1, [])) (lft2, (term2, [])) cuniv)

with eqappr {A : Set}
  (cv_pb : conv_pb) (l2r : bool) (infos : conv_tab)
  (function_parameter : Esubst.lift * (CClosure.fconstr * CClosure.stack))
  {struct cv_pb}
  : Esubst.lift * (CClosure.fconstr * CClosure.stack) -&gt;
  A * universe_compare A -&gt; A * universe_compare A :=
  let '(lft1, st1) := function_parameter in
  fun function_parameter =&gt;
    let '(lft2, st2) := function_parameter in
    fun cuniv =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let ninfos := infos_with_reds (conv_tab.cnv_inf infos) betaiotazeta in
      let '(hd1, v1) as appr1 :=
        whd_stack ninfos (conv_tab.lft_tab infos) (fst st1) (snd st1) in
      let '(hd2, v2) as appr2 :=
        whd_stack ninfos (conv_tab.rgt_tab infos) (fst st2) (snd st2) in
      let appr1 : Esubst.lift * (CClosure.fconstr * CClosure.stack) :=
        (lft1, appr1)
      with appr2 : Esubst.lift * (CClosure.fconstr * CClosure.stack) :=
        (lft2, appr2) in
      match ((fterm_of hd1), (fterm_of hd2)) with
      | (CClosure.FAtom a1, CClosure.FAtom a2) =&gt;
        match ((kind a1), (kind a2)) with
        | (Constr.Sort s1, Constr.Sort s2) =&gt;
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          sort_cmp_universes (info_env (conv_tab.cnv_inf infos)) cv_pb s1 s2
            cuniv
        | (Constr.Meta n, Constr.Meta m) =&gt;
          if Int.equal n m then
            convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
          else
            Stdlib.raise extensible_type_value
        | _ =&gt; Stdlib.raise extensible_type_value
        end
      | (CClosure.FEvar (ev1, args1) env1, CClosure.FEvar (ev2, args2) env2) =&gt;
        if Evar.equal ev1 ev2 then
          let el1 := el_stack lft1 v1 in
          let el2 := el_stack lft2 v2 in
          let cuniv := convert_stacks l2r infos lft1 lft2 v1 v2 cuniv in
          convert_vect l2r infos el1 el2
            ((|Util.Array|).(CArray.ExtS.map) (mk_clos env1) args1)
            ((|Util.Array|).(CArray.ExtS.map) (mk_clos env2) args2) cuniv
        else
          Stdlib.raise extensible_type_value
      | (CClosure.FRel n, CClosure.FRel m) =&gt;
        let el1 := el_stack lft1 v1 in
        let el2 := el_stack lft2 v2 in
        if Int.equal (reloc_rel n el1) (reloc_rel m el2) then
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          Stdlib.raise extensible_type_value
      | (CClosure.FFlex fl1, CClosure.FFlex fl2) =&gt;
        (* ❌ Try-with are not handled *)
        try
          (let cuniv := conv_table_key (conv_tab.cnv_inf infos) fl1 fl2 cuniv in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv)
      | (CClosure.FProj p1 c1, CClosure.FProj p2 c2) =&gt;
        match unfold_projection (conv_tab.cnv_inf infos) p1 with
        | Some s1 =&gt;
          eqappr cv_pb l2r infos (lft1, (c1, (cons s1 v1))) appr2 cuniv
        | None =&gt;
          match unfold_projection (conv_tab.cnv_inf infos) p2 with
          | Some s2 =&gt;
            eqappr cv_pb l2r infos appr1 (lft2, (c2, (cons s2 v2))) cuniv
          | None =&gt;
            if
              andb
                (Projection.Repr.equal (Projection.repr p1) (Projection.repr p2))
                (compare_stack_shape v1 v2) then
              let el1 := el_stack lft1 v1 in
              let el2 := el_stack lft2 v2 in
              let u1 := ccnv CONV l2r infos el1 el2 c1 c2 cuniv in
              convert_stacks l2r infos lft1 lft2 v1 v2 u1
            else
              Stdlib.raise extensible_type_value
          end
        end
      | (CClosure.FProj p1 c1, t2) =&gt;
        match unfold_projection (conv_tab.cnv_inf infos) p1 with
        | Some s1 =&gt;
          eqappr cv_pb l2r infos (lft1, (c1, (cons s1 v1))) appr2 cuniv
        | None =&gt;
          match t2 with
          | CClosure.FFlex fl2 =&gt;
            match
              unfold_ref_with_args (conv_tab.cnv_inf infos)
                (conv_tab.rgt_tab infos) fl2 v2 with
            | Some t2 =&gt; eqappr cv_pb l2r infos appr1 (lft2, t2) cuniv
            | None =&gt; Stdlib.raise extensible_type_value
            end
          | _ =&gt; Stdlib.raise extensible_type_value
          end
        end
      | (t1, CClosure.FProj p2 c2) =&gt;
        match unfold_projection (conv_tab.cnv_inf infos) p2 with
        | Some s2 =&gt;
          eqappr cv_pb l2r infos appr1 (lft2, (c2, (cons s2 v2))) cuniv
        | None =&gt;
          match t1 with
          | CClosure.FFlex fl1 =&gt;
            match
              unfold_ref_with_args (conv_tab.cnv_inf infos)
                (conv_tab.lft_tab infos) fl1 v1 with
            | Some t1 =&gt; eqappr cv_pb l2r infos (lft1, t1) appr2 cuniv
            | None =&gt; Stdlib.raise extensible_type_value
            end
          | _ =&gt; Stdlib.raise extensible_type_value
          end
        end
      | (CClosure.FLambda _ _ _ _, CClosure.FLambda _ _ _ _) =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let '(x1, ty1, bd1) := destFLambda mk_clos hd1 in
        let '(_, ty2, bd2) := destFLambda mk_clos hd2 in
        let el1 := el_stack lft1 v1 in
        let el2 := el_stack lft2 v2 in
        let cuniv := ccnv CONV l2r infos el1 el2 ty1 ty2 cuniv in
        ccnv CONV l2r (push_relevance infos x1) (el_lift el1) (el_lift el2) bd1
          bd2 cuniv
      | (CClosure.FProd x1 c1 c2 e, CClosure.FProd _ c'1 c'2 e') =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let el1 := el_stack lft1 v1 in
        let el2 := el_stack lft2 v2 in
        let cuniv := ccnv CONV l2r infos el1 el2 c1 c'1 cuniv in
        ccnv cv_pb l2r (push_relevance infos x1) (el_lift el1) (el_lift el2)
          (mk_clos (subs_lift e) c2) (mk_clos (subs_lift e') c'2) cuniv
      | (CClosure.FLambda _ _ _ _, _) =&gt;
        let '_ :=
          match v1 with
          | [] =&gt; tt
          | _ =&gt;
            anomaly None None
              (Pp.str &quot;conversion was given unreduced term (FLambda).&quot;)
          end in
        let '(x1, _ty1, bd1) := destFLambda mk_clos hd1 in
        let infos := push_relevance infos x1 in
        eqappr CONV l2r infos ((el_lift lft1), (bd1, []))
          ((el_lift lft2), (hd2, (eta_expand_stack v2))) cuniv
      | (_, CClosure.FLambda _ _ _ _) =&gt;
        let '_ :=
          match v2 with
          | [] =&gt; tt
          | _ =&gt;
            anomaly None None
              (Pp.str &quot;conversion was given unreduced term (FLambda).&quot;)
          end in
        let '(x2, _ty2, bd2) := destFLambda mk_clos hd2 in
        let infos := push_relevance infos x2 in
        eqappr CONV l2r infos ((el_lift lft1), (hd1, (eta_expand_stack v1)))
          ((el_lift lft2), (bd2, [])) cuniv
      | (CClosure.FFlex fl1, c2) =&gt;
        match
          unfold_ref_with_args (conv_tab.cnv_inf infos) (conv_tab.lft_tab infos)
            fl1 v1 with
        | Some (def1, v1) =&gt;
          let all :=
            (|CClosure.RedFlags|).(CClosure.RedFlagsSig.red_add_transparent) all
              ((|CClosure.RedFlags|).(CClosure.RedFlagsSig.red_transparent)
                (info_flags (conv_tab.cnv_inf infos))) in
          let r1 :=
            whd_stack (infos_with_reds (conv_tab.cnv_inf infos) all)
              (conv_tab.lft_tab infos) def1 v1 in
          eqappr cv_pb l2r infos (lft1, r1) appr2 cuniv
        | None =&gt;
          match c2 with
          | CClosure.FConstruct ((ind2, _j2), _u2) =&gt;
            (* ❌ Try-with are not handled *)
            try
              (let '(v2, v1) :=
                eta_expand_ind_stack (info_env (conv_tab.cnv_inf infos)) ind2
                  hd2 v2 (snd appr1) in
              convert_stacks l2r infos lft1 lft2 v1 v2 cuniv)
          | _ =&gt; Stdlib.raise extensible_type_value
          end
        end
      | (c1, CClosure.FFlex fl2) =&gt;
        match
          unfold_ref_with_args (conv_tab.cnv_inf infos) (conv_tab.rgt_tab infos)
            fl2 v2 with
        | Some (def2, v2) =&gt;
          let all :=
            (|CClosure.RedFlags|).(CClosure.RedFlagsSig.red_add_transparent) all
              ((|CClosure.RedFlags|).(CClosure.RedFlagsSig.red_transparent)
                (info_flags (conv_tab.cnv_inf infos))) in
          let r2 :=
            whd_stack (infos_with_reds (conv_tab.cnv_inf infos) all)
              (conv_tab.rgt_tab infos) def2 v2 in
          eqappr cv_pb l2r infos appr1 (lft2, r2) cuniv
        | None =&gt;
          match c1 with
          | CClosure.FConstruct ((ind1, _j1), _u1) =&gt;
            (* ❌ Try-with are not handled *)
            try
              (let '(v1, v2) :=
                eta_expand_ind_stack (info_env (conv_tab.cnv_inf infos)) ind1
                  hd1 v1 (snd appr2) in
              convert_stacks l2r infos lft1 lft2 v1 v2 cuniv)
          | _ =&gt; Stdlib.raise extensible_type_value
          end
        end
      | (CClosure.FInd (ind1, u1), CClosure.FInd (ind2, u2)) =&gt;
        if eq_ind ind1 ind2 then
          if
            orb (equiv_decb (Univ.Instance.length u1) 0)
              (equiv_decb (Univ.Instance.length u2) 0) then
            let cuniv := convert_instances false u1 u2 cuniv in
            convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
          else
            let mind :=
              Environ.lookup_mind (fst ind1) (info_env (conv_tab.cnv_inf infos))
              in
            let nargs := CClosure.stack_args_size v1 in
            if negb (Int.equal nargs (CClosure.stack_args_size v2)) then
              Stdlib.raise extensible_type_value
            else
              let cuniv :=
                convert_inductives cv_pb (mind, (snd ind1)) nargs u1 u2 cuniv in
              convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          Stdlib.raise extensible_type_value
      |
        (CClosure.FConstruct ((ind1, j1), u1),
          CClosure.FConstruct ((ind2, j2), u2)) =&gt;
        if andb (Int.equal j1 j2) (eq_ind ind1 ind2) then
          if
            orb (equiv_decb (Univ.Instance.length u1) 0)
              (equiv_decb (Univ.Instance.length u2) 0) then
            let cuniv := convert_instances false u1 u2 cuniv in
            convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
          else
            let mind :=
              Environ.lookup_mind (fst ind1) (info_env (conv_tab.cnv_inf infos))
              in
            let nargs := CClosure.stack_args_size v1 in
            if negb (Int.equal nargs (CClosure.stack_args_size v2)) then
              Stdlib.raise extensible_type_value
            else
              let cuniv :=
                convert_constructors (mind, (snd ind1), j1) nargs u1 u2 cuniv in
              convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          Stdlib.raise extensible_type_value
      | (CClosure.FConstruct ((ind1, _j1), _u1), _) =&gt;
        (* ❌ Try-with are not handled *)
        try
          (let '(v1, v2) :=
            eta_expand_ind_stack (info_env (conv_tab.cnv_inf infos)) ind1 hd1 v1
              (snd appr2) in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv)
      | (_, CClosure.FConstruct ((ind2, _j2), _u2)) =&gt;
        (* ❌ Try-with are not handled *)
        try
          (let '(v2, v1) :=
            eta_expand_ind_stack (info_env (conv_tab.cnv_inf infos)) ind2 hd2 v2
              (snd appr1) in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv)
      |
        (CClosure.FFix ((op1, i1), (na1, tys1, cl1)) e1,
          CClosure.FFix ((op2, i2), (_, tys2, cl2)) e2) =&gt;
        if
          andb (Int.equal i1 i2)
            ((|Util.Array|).(CArray.ExtS.equal) Int.equal op1 op2) then
          let n := (|Util.Array|).(CArray.ExtS.length) cl1 in
          let fty1 := (|Util.Array|).(CArray.ExtS.map) (mk_clos e1) tys1 in
          let fty2 := (|Util.Array|).(CArray.ExtS.map) (mk_clos e2) tys2 in
          let fcl1 :=
            (|Util.Array|).(CArray.ExtS.map) (mk_clos (subs_liftn n e1)) cl1 in
          let fcl2 :=
            (|Util.Array|).(CArray.ExtS.map) (mk_clos (subs_liftn n e2)) cl2 in
          let el1 := el_stack lft1 v1 in
          let el2 := el_stack lft2 v2 in
          let cuniv := convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
          let cuniv :=
            let infos := push_relevances infos na1 in
            convert_vect l2r infos (el_liftn n el1) (el_liftn n el2) fcl1 fcl2
              cuniv in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          Stdlib.raise extensible_type_value
      |
        (CClosure.FCoFix (op1, (na1, tys1, cl1)) e1,
          CClosure.FCoFix (op2, (_, tys2, cl2)) e2) =&gt;
        if Int.equal op1 op2 then
          let n := (|Util.Array|).(CArray.ExtS.length) cl1 in
          let fty1 := (|Util.Array|).(CArray.ExtS.map) (mk_clos e1) tys1 in
          let fty2 := (|Util.Array|).(CArray.ExtS.map) (mk_clos e2) tys2 in
          let fcl1 :=
            (|Util.Array|).(CArray.ExtS.map) (mk_clos (subs_liftn n e1)) cl1 in
          let fcl2 :=
            (|Util.Array|).(CArray.ExtS.map) (mk_clos (subs_liftn n e2)) cl2 in
          let el1 := el_stack lft1 v1 in
          let el2 := el_stack lft2 v2 in
          let cuniv := convert_vect l2r infos el1 el2 fty1 fty2 cuniv in
          let cuniv :=
            let infos := push_relevances infos na1 in
            convert_vect l2r infos (el_liftn n el1) (el_liftn n el2) fcl1 fcl2
              cuniv in
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          Stdlib.raise extensible_type_value
      | (CClosure.FInt i1, CClosure.FInt i2) =&gt;
        if Uint63.equal i1 i2 then
          convert_stacks l2r infos lft1 lft2 v1 v2 cuniv
        else
          Stdlib.raise extensible_type_value
      |
        (CClosure.FLetIn _ _ _ _ _, _) | (CClosure.FCaseT _ _ _ _ _, _) |
        (CClosure.FApp _ _, _) | (CClosure.FCLOS _ _, _) |
        (CClosure.FLIFT _ _, _) | (_, CClosure.FLetIn _ _ _ _ _) |
        (_, CClosure.FCaseT _ _ _ _ _) | (_, CClosure.FApp _ _) |
        (_, CClosure.FCLOS _ _) | (_, CClosure.FLIFT _ _) |
        (CClosure.FLOCKED, _) | (_, CClosure.FLOCKED) =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      |
        (CClosure.FRel _ | CClosure.FAtom _ | CClosure.FInd _ |
        CClosure.FFix _ _ | CClosure.FCoFix _ _ | CClosure.FProd _ _ _ _ |
        CClosure.FEvar _ _ | CClosure.FInt _, _) =&gt;
        Stdlib.raise extensible_type_value
      end

with convert_stacks {A : Set}
  (l2r : bool) (infos : conv_tab) (lft1 : Esubst.lift) (lft2 : Esubst.lift)
  (stk1 : CClosure.stack) (stk2 : CClosure.stack)
  (cuniv : A * universe_compare A) {struct l2r} : A * universe_compare A :=
  let f (function_parameter : Esubst.lift * CClosure.fconstr)
    : Esubst.lift * CClosure.fconstr -&gt; A * universe_compare A -&gt;
    A * universe_compare A :=
    let '(l1, t1) := function_parameter in
    fun function_parameter =&gt;
      let '(l2, t2) := function_parameter in
      fun cuniv =&gt; ccnv CONV l2r infos l1 l2 t1 t2 cuniv in
  let fix cmp_rec
    (pstk1 : list lft_constr_stack_elt) (pstk2 : list lft_constr_stack_elt)
    (cuniv : A * universe_compare A) {struct pstk1} : A * universe_compare A :=
    match (pstk1, pstk2) with
    | (cons z1 s1, cons z2 s2) =&gt;
      let cu1 := cmp_rec s1 s2 cuniv in
      match (z1, z2) with
      | (Zlapp a1, Zlapp a2) =&gt;
        (|Util.Array|).(CArray.ExtS.fold_right2) f a1 a2 cu1
      | (Zlproj c1 _l1, Zlproj c2 _l2) =&gt;
        if negb (Projection.Repr.equal c1 c2) then
          Stdlib.raise extensible_type_value
        else
          cu1
      | (Zlfix fx1 a1, Zlfix fx2 a2) =&gt;
        let cu2 := f fx1 fx2 cu1 in
        cmp_rec a1 a2 cu2
      | (Zlcase ci1 l1 p1 br1 e1, Zlcase ci2 l2 p2 br2 e2) =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let cu2 := f (l1, (mk_clos e1 p1)) (l2, (mk_clos e2 p2)) cu1 in
        convert_branches l2r infos ci1 e1 e2 l1 l2 br1 br2 cu2
      | (Zlprimitive op1 _ rargs1 kargs1, Zlprimitive op2 _ rargs2 kargs2) =&gt;
        if negb (CPrimitives.equal op1 op2) then
          Stdlib.raise extensible_type_value
        else
          let cu2 := (|Util.List|).(CList.ExtS.fold_right2) f rargs1 rargs2 cu1
            in
          let fk {B C : Set}
            (function_parameter : B * (Esubst.lift * CClosure.fconstr))
            : C * (Esubst.lift * CClosure.fconstr) -&gt; A * universe_compare A -&gt;
            A * universe_compare A :=
            let '(_, a1) := function_parameter in
            fun function_parameter =&gt;
              let '(_, a2) := function_parameter in
              fun cu =&gt; f a1 a2 cu in
          (|Util.List|).(CList.ExtS.fold_right2) fk kargs1 kargs2 cu2
      |
        (Zlapp _ | Zlproj _ _ | Zlfix _ _ | Zlcase _ _ _ _ _ |
        Zlprimitive _ _ _ _, _) =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end
    | _ =&gt; cuniv
    end in
  if compare_stack_shape stk1 stk2 then
    cmp_rec (pure_stack lft1 stk1) (pure_stack lft2 stk2) cuniv
  else
    Stdlib.raise extensible_type_value

with convert_vect {A : Set}
  (l2r : bool) (infos : conv_tab) (lft1 : Esubst.lift) (lft2 : Esubst.lift)
  (v1 : array CClosure.fconstr) (v2 : array CClosure.fconstr)
  (cuniv : A * universe_compare A) {struct l2r} : A * universe_compare A :=
  let lv1 := (|Util.Array|).(CArray.ExtS.length) v1 in
  let lv2 := (|Util.Array|).(CArray.ExtS.length) v2 in
  if Int.equal lv1 lv2 then
    let fix fold (n : Z) (cuniv : A * universe_compare A) {struct n}
      : A * universe_compare A :=
      if OCaml.Stdlib.ge n lv1 then
        cuniv
      else
        let cuniv :=
          ccnv CONV l2r infos lft1 lft2 ((|Util.Array|).(CArray.ExtS.get) v1 n)
            ((|Util.Array|).(CArray.ExtS.get) v2 n) cuniv in
        fold (Z.add n 1) cuniv in
    fold 0 cuniv
  else
    Stdlib.raise extensible_type_value

with convert_branches {A : Set}
  (l2r : bool) (infos : conv_tab) (ci : Constr.case_info)
  (e1 : Esubst.subs CClosure.fconstr) (e2 : Esubst.subs CClosure.fconstr)
  (lft1 : Esubst.lift) (lft2 : Esubst.lift) (br1 : array Constr.constr)
  (br2 : array Constr.constr) (cuniv : A * universe_compare A) {struct l2r}
  : A * universe_compare A :=
  let fold
    (n : Int.t) (c1 : Constr.constr) (c2 : Constr.constr)
    (cuniv : A * universe_compare A) : A * universe_compare A :=
    let '(infos, c1, c2) := skip_pattern infos n c1 c2 in
    let lft1 := el_liftn n lft1 in
    let lft2 := el_liftn n lft2 in
    let e1 := subs_liftn n e1 in
    let e2 := subs_liftn n e2 in
    ccnv CONV l2r infos lft1 lft2 (mk_clos e1 c1) (mk_clos e2 c2) cuniv in
  (|Util.Array|).(CArray.ExtS.fold_right3) fold
    (Constr.case_info.ci_cstr_nargs ci) br1 br2 cuniv.

Definition clos_gen_conv {A : Set}
  (trans : TransparentState.t) (cv_pb : conv_pb) (l2r : bool)
  (evars : Constr.existential -&gt; option Constr.constr) (env : Environ.env)
  (univs : A * universe_compare A) (t1 : Constr.constr) (t2 : Constr.constr)
  : A * universe_compare A :=
  let reds :=
    (|CClosure.RedFlags|).(CClosure.RedFlagsSig.red_add_transparent)
      betaiotazeta trans in
  let infos := create_clos_infos (Some evars) reds env in
  let infos :=
    {| conv_tab.cnv_inf := infos; conv_tab.relevances := Range.empty;
      conv_tab.lft_tab := create_tab tt; conv_tab.rgt_tab := create_tab tt |} in
  ccnv cv_pb l2r infos el_id el_id (inject t1) (inject t2) univs.

Definition check_eq
  (univs : UGraph.t) (u : Univ.Universe.t) (u' : Univ.Universe.t) : unit :=
  if negb (UGraph.check_eq univs u u') then
    Stdlib.raise extensible_type_value
  else
    tt.

Definition check_leq
  (univs : UGraph.t) (u : Univ.Universe.t) (u' : Univ.Universe.t) : unit :=
  if negb (UGraph.check_leq univs u u') then
    Stdlib.raise extensible_type_value
  else
    tt.

Definition check_sort_cmp_universes
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (univs : UGraph.t) : unit :=
  if negb (type_in_type env) then
    let check_pb (u0 : Univ.Universe.t) (u1 : Univ.Universe.t) : unit :=
      match pb with
      | CUMUL =&gt; check_leq univs u0 u1
      | CONV =&gt; check_eq univs u0 u1
      end in
    match (s0, s1) with
    |
      (Sorts.SProp, Sorts.SProp) | (Sorts.Prop, Sorts.Prop) |
      (Sorts.__Set, Sorts.__Set) =&gt; tt
    | (Sorts.SProp, _) | (_, Sorts.SProp) =&gt; Stdlib.raise extensible_type_value
    | (Sorts.Prop, Sorts.__Set | Sorts.Type _) =&gt;
      if negb (is_cumul pb) then
        Stdlib.raise extensible_type_value
      else
        tt
    | (Sorts.__Set, Sorts.Prop) =&gt; Stdlib.raise extensible_type_value
    | (Sorts.__Set, Sorts.Type u) =&gt; check_pb Univ.type0_univ u
    | (Sorts.Type _u, Sorts.Prop) =&gt; Stdlib.raise extensible_type_value
    | (Sorts.Type u, Sorts.__Set) =&gt; check_pb u Univ.type0_univ
    | (Sorts.Type u0, Sorts.Type u1) =&gt; check_pb u0 u1
    end
  else
    tt.

Definition checked_sort_cmp_universes
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (univs : UGraph.t) : UGraph.t :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  univs.

Definition check_convert_instances {A : Set} (function_parameter : A)
  : Univ.Instance.t -&gt; Univ.Instance.t -&gt; UGraph.t -&gt; UGraph.t :=
  let '_ := function_parameter in
  fun u =&gt;
    fun u' =&gt;
      fun univs =&gt;
        if UGraph.check_eq_instances univs u u' then
          univs
        else
          Stdlib.raise extensible_type_value.

Definition check_inductive_instances
  (cv_pb : conv_pb) (variance : array Univ.Variance.t) (u1 : Univ.Instance.t)
  (u2 : Univ.Instance.t) (univs : UGraph.t) : UGraph.t :=
  let csts := get_cumulativity_constraints cv_pb variance u1 u2 in
  if UGraph.check_constraints csts univs then
    univs
  else
    Stdlib.raise extensible_type_value.

Definition checked_universes : universe_compare UGraph.t :=
  {| universe_compare.compare_sorts := checked_sort_cmp_universes;
    universe_compare.compare_instances := check_convert_instances;
    universe_compare.compare_cumul_instances := check_inductive_instances |}.

Definition infer_eq (function_parameter : UGraph.t * Univ.Constraint.t)
  : Univ.Universe.t -&gt; Univ.Universe.t -&gt; UGraph.t * Univ.Constraint.t :=
  let '(univs, cstrs) as cuniv := function_parameter in
  fun u =&gt;
    fun u' =&gt;
      if UGraph.check_eq univs u u' then
        cuniv
      else
        (univs, (Univ.enforce_eq u u' cstrs)).

Definition infer_leq (function_parameter : UGraph.t * Univ.Constraint.t)
  : Univ.Universe.t -&gt; Univ.Universe.t -&gt; UGraph.t * Univ.Constraint.t :=
  let '(univs, cstrs) as cuniv := function_parameter in
  fun u =&gt;
    fun u' =&gt;
      if UGraph.check_leq univs u u' then
        cuniv
      else
        let '(cstrs', _) := UGraph.enforce_leq_alg u u' univs in
        (univs, (Univ.Constraint.union cstrs cstrs')).

Definition infer_cmp_universes
  (env : Environ.env) (pb : conv_pb) (s0 : Sorts.t) (s1 : Sorts.t)
  (univs : UGraph.t * Univ.Constraint.t) : UGraph.t * Univ.Constraint.t :=
  if type_in_type env then
    univs
  else
    let infer_pb (u0 : Univ.Universe.t) (u1 : Univ.Universe.t)
      : UGraph.t * Univ.Constraint.t :=
      match pb with
      | CUMUL =&gt; infer_leq univs u0 u1
      | CONV =&gt; infer_eq univs u0 u1
      end in
    match (s0, s1) with
    |
      (Sorts.SProp, Sorts.SProp) | (Sorts.Prop, Sorts.Prop) |
      (Sorts.__Set, Sorts.__Set) =&gt; univs
    | (Sorts.SProp, _) | (_, Sorts.SProp) =&gt; Stdlib.raise extensible_type_value
    | (Sorts.Prop, Sorts.__Set | Sorts.Type _) =&gt;
      if negb (is_cumul pb) then
        Stdlib.raise extensible_type_value
      else
        univs
    | (Sorts.__Set, Sorts.Prop) =&gt; Stdlib.raise extensible_type_value
    | (Sorts.__Set, Sorts.Type u) =&gt; infer_pb Univ.type0_univ u
    | (Sorts.Type u, Sorts.Prop) =&gt; infer_pb u Univ.type0m_univ
    | (Sorts.Type u, Sorts.__Set) =&gt; infer_pb u Univ.type0_univ
    | (Sorts.Type u0, Sorts.Type u1) =&gt; infer_pb u0 u1
    end.

Definition infer_convert_instances
  (flex : bool) (u : Univ.Instance.t) (u' : Univ.Instance.t)
  (function_parameter : UGraph.t * Univ.Constraint.t)
  : UGraph.t * Univ.Constraint.t :=
  let '(univs, cstrs) := function_parameter in
  let cstrs' :=
    if flex then
      if UGraph.check_eq_instances univs u u' then
        cstrs
      else
        Stdlib.raise extensible_type_value
    else
      Univ.enforce_eq_instances u u' cstrs in
  (univs, cstrs').

Definition infer_inductive_instances {A : Set}
  (cv_pb : conv_pb) (variance : array Univ.Variance.t) (u1 : Univ.Instance.t)
  (u2 : Univ.Instance.t) (function_parameter : A * Univ.Constraint.t)
  : A * Univ.Constraint.t :=
  let '(univs, csts') := function_parameter in
  let csts := get_cumulativity_constraints cv_pb variance u1 u2 in
  (univs, (Univ.Constraint.union csts csts')).

Definition inferred_universes
  : universe_compare (UGraph.t * Univ.Constraint.t) :=
  {| universe_compare.compare_sorts := infer_cmp_universes;
    universe_compare.compare_instances := infer_convert_instances;
    universe_compare.compare_cumul_instances := infer_inductive_instances |}.

Definition gen_conv
  (cv_pb : conv_pb) (l2r : bool) (reds : TransparentState.t) (env : Environ.env)
  (evars : Constr.existential -&gt; option Constr.constr) (univs : UGraph.t)
  (t1 : Constr.constr) (t2 : Constr.constr) : unit :=
  let b :=
    if equiv_decb cv_pb CUMUL then
      leq_constr_univs univs t1 t2
    else
      eq_constr_univs univs t1 t2 in
  if b then
    tt
  else
    let '_ :=
      clos_gen_conv reds cv_pb l2r evars env (univs, checked_universes) t1 t2 in
    tt.

Definition gen_conv (cv_pb : conv_pb) (op_staroptstar : option bool)
  : option TransparentState.t -&gt; Environ.env -&gt;
  option ((Constr.existential -&gt; option Constr.constr) * UGraph.t) -&gt;
  Constr.constr -&gt; Constr.constr -&gt; unit :=
  let l2r :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun op_staroptstar =&gt;
    let reds :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; TransparentState.full
      end in
    fun env =&gt;
      fun op_staroptstar =&gt;
        let evars :=
          match op_staroptstar with
          | Some op_starsthstar =&gt; op_starsthstar
          | None =&gt;
            ((fun function_parameter =&gt;
              let '_ := function_parameter in
              None), (universes env))
          end in
        let '(evars, univs) := evars in
        if Flags.profile then
          let fconv_universes_key :=
            CProfile.declare_profile &quot;trans_fconv_universes&quot; in
          CProfile.profile8 fconv_universes_key gen_conv cv_pb l2r reds env
            evars univs
        else
          gen_conv cv_pb l2r reds env evars univs.

Definition conv
  : option bool -&gt; option TransparentState.t -&gt; Environ.env -&gt;
  option ((Constr.existential -&gt; option Constr.constr) * UGraph.t) -&gt;
  Constr.constr -&gt; Constr.constr -&gt; unit := gen_conv CONV.

Definition conv_leq
  : option bool -&gt; option TransparentState.t -&gt; Environ.env -&gt;
  option ((Constr.existential -&gt; option Constr.constr) * UGraph.t) -&gt;
  Constr.constr -&gt; Constr.constr -&gt; unit := gen_conv CUMUL.

Definition generic_conv {A : Set}
  (cv_pb : conv_pb) (l2r : bool)
  (evars : Constr.existential -&gt; option Constr.constr)
  (reds : TransparentState.t) (env : Environ.env)
  (univs : A * universe_compare A) (t1 : Constr.constr) (t2 : Constr.constr)
  : A :=
  let '(s, _) := clos_gen_conv reds cv_pb l2r evars env univs t1 t2 in
  s.

Definition infer_conv_universes
  (cv_pb : conv_pb) (l2r : bool)
  (evars : Constr.existential -&gt; option Constr.constr)
  (reds : TransparentState.t) (env : Environ.env) (univs : UGraph.t)
  (t1 : Constr.constr) (t2 : Constr.constr) : Univ.Constraint.t :=
  let '(b, cstrs) :=
    if Stdlib.op_eqeq cv_pb CUMUL then
      Constr.leq_constr_univs_infer univs t1 t2
    else
      Constr.eq_constr_univs_infer univs t1 t2 in
  if b then
    cstrs
  else
    let univs := ((univs, Univ.Constraint.empty), inferred_universes) in
    let '((_, cstrs), _) := clos_gen_conv reds cv_pb l2r evars env univs t1 t2
      in
    cstrs.

Definition infer_conv_universes
  : conv_pb -&gt; bool -&gt; (Constr.existential -&gt; option Constr.constr) -&gt;
  TransparentState.t -&gt; Environ.env -&gt; UGraph.t -&gt; Constr.constr -&gt;
  Constr.constr -&gt; Univ.Constraint.t :=
  if Flags.profile then
    let infer_conv_universes_key :=
      CProfile.declare_profile &quot;infer_conv_universes&quot; in
    CProfile.profile8 infer_conv_universes_key infer_conv_universes
  else
    infer_conv_universes.

Definition infer_conv (op_staroptstar : option bool)
  : option (Constr.existential -&gt; option Constr.constr) -&gt;
  option TransparentState.t -&gt; Environ.env -&gt; UGraph.t -&gt; Constr.constr -&gt;
  Constr.constr -&gt; Univ.Constraint.t :=
  let l2r :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun op_staroptstar =&gt;
    let evars :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt;
        fun function_parameter =&gt;
          let '_ := function_parameter in
          None
      end in
    fun op_staroptstar =&gt;
      let ts :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; TransparentState.full
        end in
      fun env =&gt;
        fun univs =&gt;
          fun t1 =&gt;
            fun t2 =&gt; infer_conv_universes CONV l2r evars ts env univs t1 t2.

Definition infer_conv_leq (op_staroptstar : option bool)
  : option (Constr.existential -&gt; option Constr.constr) -&gt;
  option TransparentState.t -&gt; Environ.env -&gt; UGraph.t -&gt; Constr.constr -&gt;
  Constr.constr -&gt; Univ.Constraint.t :=
  let l2r :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun op_staroptstar =&gt;
    let evars :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt;
        fun function_parameter =&gt;
          let '_ := function_parameter in
          None
      end in
    fun op_staroptstar =&gt;
      let ts :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; TransparentState.full
        end in
      fun env =&gt;
        fun univs =&gt;
          fun t1 =&gt;
            fun t2 =&gt; infer_conv_universes CUMUL l2r evars ts env univs t1 t2.

Definition default_conv {A : Set}
  (cv_pb : conv_pb) (function_parameter : option A)
  : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; unit :=
  let '_ := function_parameter in
  fun env =&gt; fun t1 =&gt; fun t2 =&gt; gen_conv cv_pb None None env None t1 t2.

Definition default_conv_leq {A : Set}
  : option A -&gt; Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; unit :=
  default_conv CUMUL.

Definition beta_applist (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app (subst : Vars.substl) (c : Constr.constr) (l : list Constr.constr)
    {struct subst} : Constr.constr :=
    match ((kind c), l) with
    | (Constr.Lambda _ _ c, cons arg l) =&gt; app (cons arg subst) c l
    | _ =&gt; Term.applist ((substl subst c), l)
    end in
  app [] c l.

Definition beta_appvect (c : Constr.constr) (v : array Constr.constr)
  : Constr.constr := beta_applist c ((|Util.Array|).(CArray.ExtS.to_list) v).

Definition beta_app (c : Constr.constr) (a : Constr.constr) : Constr.constr :=
  beta_applist c [ a ].

Definition betazeta_appvect
  : Z -&gt; Constr.constr -&gt; array Constr.constr -&gt; Constr.constr :=
  Term.lambda_appvect_assum.

Definition hnf_prod_app
  (env : Environ.env) (t : Constr.constr) (n : Constr.constr) : Constr.constr :=
  match kind (whd_all env t) with
  | Constr.Prod _ _ b =&gt; subst1 n b
  | _ =&gt; anomaly None (Some &quot;hnf_prod_app&quot;) (Pp.str &quot;Need a product.&quot;)
  end.

Definition hnf_prod_applist
  (env : Environ.env) (t : Constr.constr) (nl : list Constr.constr)
  : Constr.constr :=
  (|Util.List|).(CList.ExtS.fold_left) (hnf_prod_app env) t nl.

Definition hnf_prod_applist_assum
  (env : Environ.env) (n : Int.t) (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app
    (n : Int.t) (subst : Vars.substl) (t : Constr.constr)
    (l : list Constr.constr) {struct n} : Constr.constr :=
    if Int.equal n 0 then
      if Stdlib.op_eqeq l [] then
        substl subst t
      else
        anomaly None None (Pp.str &quot;Too many arguments.&quot;)
    else
      match ((kind (whd_allnolet env t)), l) with
      | (Constr.Prod _ _ c, cons arg l) =&gt; app (Z.sub n 1) (cons arg subst) c l
      | (Constr.LetIn _ b _ c, _) =&gt;
        app (Z.sub n 1) (cons (substl subst b) subst) c l
      | (_, []) =&gt; anomaly None None (Pp.str &quot;Not enough arguments.&quot;)
      | _ =&gt; anomaly None None (Pp.str &quot;Not enough prod/let's.&quot;)
      end in
  app n [] c l.

Definition dest_prod {A : Set} (env : Environ.env)
  : Constr.constr -&gt; Context.Rel.pt A Constr.types * Constr.constr :=
  let fix decrec {B : Set}
    (env : Environ.env) (m : Context.Rel.pt B Constr.types) (c : Constr.constr)
    {struct env} : Context.Rel.pt B Constr.types * Constr.constr :=
    let t := whd_all env c in
    match kind t with
    | Constr.Prod n a c0 =&gt;
      let d := Context.Rel.Declaration.LocalAssum n a in
      decrec (push_rel d env) (Context.Rel.add d m) c0
    | _ =&gt; (m, t)
    end in
  decrec env Context.Rel.empty.

Definition dest_lam {A : Set} (env : Environ.env)
  : Constr.constr -&gt; Context.Rel.pt A Constr.types * Constr.constr :=
  let fix decrec {B : Set}
    (env : Environ.env) (m : Context.Rel.pt B Constr.types) (c : Constr.constr)
    {struct env} : Context.Rel.pt B Constr.types * Constr.constr :=
    let t := whd_all env c in
    match kind t with
    | Constr.Lambda n a c0 =&gt;
      let d := Context.Rel.Declaration.LocalAssum n a in
      decrec (push_rel d env) (Context.Rel.add d m) c0
    | _ =&gt; (m, t)
    end in
  decrec env Context.Rel.empty.

Definition dest_prod_assum (env : Environ.env)
  : Constr.constr -&gt; Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
  let fix prodec_rec
    (env : Environ.env) (l : Context.Rel.pt Constr.constr Constr.types)
    (ty : Constr.constr) {struct env}
    : Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
    let rty := whd_allnolet env ty in
    match kind rty with
    | Constr.Prod x t c =&gt;
      let d := Context.Rel.Declaration.LocalAssum x t in
      prodec_rec (push_rel d env) (Context.Rel.add d l) c
    | Constr.LetIn x b t c =&gt;
      let d := Context.Rel.Declaration.LocalDef x b t in
      prodec_rec (push_rel d env) (Context.Rel.add d l) c
    | _ =&gt;
      let rty' := whd_all env rty in
      if Constr.equal rty' rty then
        (l, rty)
      else
        prodec_rec env l rty'
    end in
  prodec_rec env Context.Rel.empty.

Definition dest_lam_assum (env : Environ.env)
  : Constr.constr -&gt; Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
  let fix lamec_rec
    (env : Environ.env) (l : Context.Rel.pt Constr.constr Constr.types)
    (ty : Constr.constr) {struct env}
    : Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
    let rty := whd_allnolet env ty in
    match kind rty with
    | Constr.Lambda x t c =&gt;
      let d := Context.Rel.Declaration.LocalAssum x t in
      lamec_rec (push_rel d env) (Context.Rel.add d l) c
    | Constr.LetIn x b t c =&gt;
      let d := Context.Rel.Declaration.LocalDef x b t in
      lamec_rec (push_rel d env) (Context.Rel.add d l) c
    | _ =&gt; (l, rty)
    end in
  lamec_rec env Context.Rel.empty.

(* ❌ The definition of exceptions is not handled. *)
(* exception NotArity *)

Definition dest_arity (env : Environ.env) (c : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types * Sorts.t :=
  let '(l, c) := dest_prod_assum env c in
  match kind c with
  | Constr.Sort s =&gt; (l, s)
  | _ =&gt; Stdlib.raise extensible_type_value
  end.

Definition is_arity (env : Environ.env) (c : Constr.constr) : bool :=
  (* ❌ Try-with are not handled *)
  try
    (let '_ := dest_arity env c in
    true).

Definition eta_expand
  (env : Environ.env) (t : Constr.constr) (ty : Constr.constr)
  : Constr.constr :=
  let '(ctxt, _codom) := dest_prod env ty in
  let '(ctxt', t) := dest_lam env t in
  let d := Z.sub (Context.Rel.nhyps ctxt) (Context.Rel.nhyps ctxt') in
  let eta_args :=
    (|Util.List|).(CList.ExtS.rev_map) mkRel
      ((|Util.List|).(CList.ExtS.interval) 1 d) in
  let t := Term.applistc (Vars.lift d t) eta_args in
  let t :=
    Term.it_mkLambda_or_LetIn t ((|Util.List|).(CList.ExtS.firstn) d ctxt) in
  Term.it_mkLambda_or_LetIn t ctxt'.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="reduction.mli">
  <div style="margin: 20px;">
    <h3>Reduction_mli</h3>
    <ul>
      <li>OCaml size: 128 lines</li>
      <li>Coq size: 146 lines (+14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#reduction.mli"><code>reduction.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Constr
open Environ

(***********************************************************************
  s Reduction functions *)

(* None of these functions do eta reduction *)

val whd_betaiotazeta        : env -&gt; constr -&gt; constr
val whd_all                 : env -&gt; constr -&gt; constr
val whd_allnolet : env -&gt; constr -&gt; constr

val whd_betaiota     : env -&gt; constr -&gt; constr
val nf_betaiota      : env -&gt; constr -&gt; constr

(***********************************************************************
  s conversion functions *)

<abbr class="mark-warning" title="Signature item `exception` not handled">exception NotConvertible</abbr>

type 'a kernel_conversion_function = env -&gt; 'a -&gt; 'a -&gt; unit
type 'a extended_conversion_function =
  ?l2r:bool -&gt; ?reds:TransparentState.t -&gt; env -&gt;
  ?evars:((existential-&gt;constr option) * UGraph.t) -&gt;
  'a -&gt; 'a -&gt; unit

type conv_pb = CONV | CUMUL

type 'a universe_compare =
  { (* Might raise NotConvertible *)
    compare_sorts : env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt; 'a -&gt; 'a;
    compare_instances: flex:bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; 'a -&gt; 'a;
    compare_cumul_instances : conv_pb -&gt; Univ.Variance.t array -&gt;
      Univ.Instance.t -&gt; Univ.Instance.t -&gt; 'a -&gt; 'a }

type 'a universe_state = 'a * 'a universe_compare

type ('a,'b) generic_conversion_function = env -&gt; 'b universe_state -&gt; 'a -&gt; 'a -&gt; 'b

type 'a infer_conversion_function = env -&gt; UGraph.t -&gt; 'a -&gt; 'a -&gt; Univ.Constraint.t

val get_cumulativity_constraints : conv_pb -&gt; Univ.Variance.t array -&gt;
  Univ.Instance.t -&gt; Univ.Instance.t -&gt; Univ.Constraint.t

val inductive_cumulativity_arguments : (Declarations.mutual_inductive_body * int) -&gt; int
val constructor_cumulativity_arguments : (Declarations.mutual_inductive_body * int * int) -&gt; int

val sort_cmp_universes : env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt;
  'a * 'a universe_compare -&gt; 'a * 'a universe_compare

(* [flex] should be true for constants, false for inductive types and
constructors. *)
val convert_instances : flex:bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt;
  'a * 'a universe_compare -&gt; 'a * 'a universe_compare

(** These two never raise UnivInconsistency, inferred_universes
    just gathers the constraints. *)
val checked_universes : UGraph.t universe_compare
val inferred_universes : (UGraph.t * Univ.Constraint.t) universe_compare

(** These two functions can only raise NotConvertible *)
val conv : constr extended_conversion_function

val conv_leq : types extended_conversion_function

(** These conversion functions are used by module subtyping, which needs to infer
    universe constraints inside the kernel *)
val infer_conv : ?l2r:bool -&gt; ?evars:(existential-&gt;constr option) -&gt;
  ?ts:TransparentState.t -&gt; constr infer_conversion_function
val infer_conv_leq : ?l2r:bool -&gt; ?evars:(existential-&gt;constr option) -&gt;
  ?ts:TransparentState.t -&gt; types infer_conversion_function

(** Depending on the universe state functions, this might raise
  [UniverseInconsistency] in addition to [NotConvertible] (for better error
  messages). *)
val generic_conv : conv_pb -&gt; l2r:bool -&gt; (existential-&gt;constr option) -&gt;
  TransparentState.t -&gt; (constr,'a) generic_conversion_function

val default_conv     : conv_pb -&gt; ?l2r:bool -&gt; types kernel_conversion_function
val default_conv_leq : ?l2r:bool -&gt; types kernel_conversion_function

(************************************************************************)

(** Builds an application node, reducing beta redexes it may produce. *)
val beta_applist : constr -&gt; constr list -&gt; constr

(** Builds an application node, reducing beta redexes it may produce. *)
val beta_appvect : constr -&gt; constr array -&gt; constr

(** Builds an application node, reducing beta redexe it may produce. *)
val beta_app : constr -&gt; constr -&gt; constr

(** Pseudo-reduction rule  Prod(x,A,B) a --&gt; B[x\a] *)
val hnf_prod_applist : env -&gt; types -&gt; constr list -&gt; types

(** In [hnf_prod_applist_assum n c args], [c] is supposed to (whd-)reduce to
    the form [âÎ.t] with [Î] of length [n] and possibly with let-ins; it
    returns [t] with the assumptions of [Î] instantiated by [args] and
    the local definitions of [Î] expanded. *)
val hnf_prod_applist_assum : env -&gt; int -&gt; types -&gt; constr list -&gt; types

(** Compatibility alias for Term.lambda_appvect_assum *)
val betazeta_appvect : int -&gt; constr -&gt; constr array -&gt; constr

(***********************************************************************
  s Recognizing products and arities modulo reduction *)

val dest_prod       : env -&gt; types -&gt; Constr.rel_context * types
val dest_prod_assum : env -&gt; types -&gt; Constr.rel_context * types
val dest_lam        : env -&gt; constr -&gt; Constr.rel_context * constr
val dest_lam_assum  : env -&gt; constr -&gt; Constr.rel_context * constr

<abbr class="mark-warning" title="Signature item `exception` not handled">exception NotArity</abbr>

val dest_arity : env -&gt; types -&gt; Term.arity (* raises NotArity if not an arity *)
val is_arity   : env -&gt; types -&gt; bool

val eta_expand : env -&gt; constr -&gt; types -&gt; constr
</pre>
  </div>
  <div class="col-md-6">
    <a href="#reduction.mli"><code>Reduction_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter whd_betaiotazeta : Environ.env -&gt; Constr.constr -&gt; Constr.constr.

Parameter whd_all : Environ.env -&gt; Constr.constr -&gt; Constr.constr.

Parameter whd_allnolet : Environ.env -&gt; Constr.constr -&gt; Constr.constr.

Parameter whd_betaiota : Environ.env -&gt; Constr.constr -&gt; Constr.constr.

Parameter nf_betaiota : Environ.env -&gt; Constr.constr -&gt; Constr.constr.

(* exception NotConvertible *)

Definition kernel_conversion_function (a : Set) :=
  Environ.env -&gt; a -&gt; a -&gt; unit.

Definition extended_conversion_function (a : Set) :=
  option bool -&gt; option TransparentState.t -&gt; Environ.env -&gt;
  option ((Constr.existential -&gt; option Constr.constr) * UGraph.t) -&gt; a -&gt; a -&gt;
  unit.

Inductive conv_pb : Set :=
| CONV : conv_pb
| CUMUL : conv_pb.

Module universe_compare.
  Record record {a : Set} := {
    compare_sorts : Environ.env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt; a -&gt; a;
    compare_instances : bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; a -&gt; a;
    compare_cumul_instances :
      conv_pb -&gt; array Univ.Variance.t -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt;
      a -&gt; a }.
  Arguments record : clear implicits.
  Definition with_compare_sorts {a_type : Set} (r : record a_type) compare_sorts
    : record a_type :=
    {| compare_sorts := compare_sorts; compare_instances := compare_instances r;
      compare_cumul_instances := compare_cumul_instances r |}.
  Definition with_compare_instances {a_type : Set} (r : record a_type)
    compare_instances : record a_type :=
    {| compare_sorts := compare_sorts r; compare_instances := compare_instances;
      compare_cumul_instances := compare_cumul_instances r |}.
  Definition with_compare_cumul_instances {a_type : Set} (r : record a_type)
    compare_cumul_instances : record a_type :=
    {| compare_sorts := compare_sorts r;
      compare_instances := compare_instances r;
      compare_cumul_instances := compare_cumul_instances |}.
End universe_compare.
Definition universe_compare := universe_compare.record.

Definition universe_state (a : Set) := a * universe_compare a.

Definition generic_conversion_function (a b : Set) :=
  Environ.env -&gt; universe_state b -&gt; a -&gt; a -&gt; b.

Definition infer_conversion_function (a : Set) :=
  Environ.env -&gt; UGraph.t -&gt; a -&gt; a -&gt; Univ.Constraint.t.

Parameter get_cumulativity_constraints :
  conv_pb -&gt; array Univ.Variance.t -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt;
  Univ.Constraint.t.

Parameter inductive_cumulativity_arguments :
  Declarations.mutual_inductive_body * Z -&gt; Z.

Parameter constructor_cumulativity_arguments :
  Declarations.mutual_inductive_body * Z * Z -&gt; Z.

Parameter sort_cmp_universes : forall {a : Set},
  Environ.env -&gt; conv_pb -&gt; Sorts.t -&gt; Sorts.t -&gt; a * universe_compare a -&gt;
  a * universe_compare a.

Parameter convert_instances : forall {a : Set},
  bool -&gt; Univ.Instance.t -&gt; Univ.Instance.t -&gt; a * universe_compare a -&gt;
  a * universe_compare a.

Parameter checked_universes : universe_compare UGraph.t.

Parameter inferred_universes : universe_compare (UGraph.t * Univ.Constraint.t).

Parameter conv : extended_conversion_function Constr.constr.

Parameter conv_leq : extended_conversion_function Constr.types.

Parameter infer_conv :
  option bool -&gt; option (Constr.existential -&gt; option Constr.constr) -&gt;
  option TransparentState.t -&gt; infer_conversion_function Constr.constr.

Parameter infer_conv_leq :
  option bool -&gt; option (Constr.existential -&gt; option Constr.constr) -&gt;
  option TransparentState.t -&gt; infer_conversion_function Constr.types.

Parameter generic_conv : forall {a : Set},
  conv_pb -&gt; bool -&gt; (Constr.existential -&gt; option Constr.constr) -&gt;
  TransparentState.t -&gt; generic_conversion_function Constr.constr a.

Parameter default_conv :
  conv_pb -&gt; option bool -&gt; kernel_conversion_function Constr.types.

Parameter default_conv_leq :
  option bool -&gt; kernel_conversion_function Constr.types.

Parameter beta_applist : Constr.constr -&gt; list Constr.constr -&gt; Constr.constr.

Parameter beta_appvect : Constr.constr -&gt; array Constr.constr -&gt; Constr.constr.

Parameter beta_app : Constr.constr -&gt; Constr.constr -&gt; Constr.constr.

Parameter hnf_prod_applist :
  Environ.env -&gt; Constr.types -&gt; list Constr.constr -&gt; Constr.types.

Parameter hnf_prod_applist_assum :
  Environ.env -&gt; Z -&gt; Constr.types -&gt; list Constr.constr -&gt; Constr.types.

Parameter betazeta_appvect :
  Z -&gt; Constr.constr -&gt; array Constr.constr -&gt; Constr.constr.

Parameter dest_prod :
  Environ.env -&gt; Constr.types -&gt; Constr.rel_context * Constr.types.

Parameter dest_prod_assum :
  Environ.env -&gt; Constr.types -&gt; Constr.rel_context * Constr.types.

Parameter dest_lam :
  Environ.env -&gt; Constr.constr -&gt; Constr.rel_context * Constr.constr.

Parameter dest_lam_assum :
  Environ.env -&gt; Constr.constr -&gt; Constr.rel_context * Constr.constr.

(* exception NotArity *)

Parameter dest_arity : Environ.env -&gt; Constr.types -&gt; Term.arity.

Parameter is_arity : Environ.env -&gt; Constr.types -&gt; bool.

Parameter eta_expand :
  Environ.env -&gt; Constr.constr -&gt; Constr.types -&gt; Constr.constr.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="retroknowledge.ml">
  <div style="margin: 20px;">
    <h3>Retroknowledge</h3>
    <ul>
      <li>OCaml size: 40 lines</li>
      <li>Coq size: 57 lines (+42% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#retroknowledge.ml"><code>retroknowledge.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Arnaud Spiwack, May 2007 *)
(* Addition of native Head (nb of heading 0) and Tail (nb of trailing 0) by
   Benjamin GrÃ©goire, Jun 2007 *)

(* This file defines the knowledge that the kernel is able to optimize. *)

open Names

type retroknowledge = {
    retro_int63 : Constant.t option;
    retro_bool : (constructor * constructor) option; (* true, false *)
    retro_carry : (constructor * constructor) option; (* C0, C1 *)
    retro_pair : constructor option;
    retro_cmp : (constructor * constructor * constructor) option;
                    (* Eq, Lt, Gt *)
    retro_refl : constructor option;
}

let empty = {
    retro_int63 = None;
    retro_bool = None;
    retro_carry = None;
    retro_pair = None;
    retro_cmp = None;
    retro_refl = None;
}

type action =
  | Register_ind of CPrimitives.prim_ind * inductive
  | Register_type of CPrimitives.prim_type * Constant.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#retroknowledge.ml"><code>Retroknowledge.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Module retroknowledge.
  Record record := {
    retro_int63 : option Names.Constant.t;
    retro_bool : option (Names.constructor * Names.constructor);
    retro_carry : option (Names.constructor * Names.constructor);
    retro_pair : option Names.constructor;
    retro_cmp :
      option (Names.constructor * Names.constructor * Names.constructor);
    retro_refl : option Names.constructor }.
  Definition with_retro_int63 (r : record) retro_int63 : record :=
    {| retro_int63 := retro_int63; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_bool (r : record) retro_bool : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_carry (r : record) retro_carry : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_pair (r : record) retro_pair : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_cmp (r : record) retro_cmp : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp; retro_refl := retro_refl r |}.
  Definition with_retro_refl (r : record) retro_refl : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl |}.
End retroknowledge.
Definition retroknowledge := retroknowledge.record.

Definition empty : retroknowledge :=
  {| retroknowledge.retro_int63 := None; retroknowledge.retro_bool := None;
    retroknowledge.retro_carry := None; retroknowledge.retro_pair := None;
    retroknowledge.retro_cmp := None; retroknowledge.retro_refl := None |}.

Inductive action : Set :=
| Register_ind : CPrimitives.prim_ind -&gt; Names.inductive -&gt; action
| Register_type : CPrimitives.prim_type -&gt; Names.Constant.t -&gt; action.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="retroknowledge.mli">
  <div style="margin: 20px;">
    <h3>Retroknowledge_mli</h3>
    <ul>
      <li>OCaml size: 27 lines</li>
      <li>Coq size: 52 lines (+92% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#retroknowledge.mli"><code>retroknowledge.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

type retroknowledge = {
    retro_int63 : Constant.t option;
    retro_bool : (constructor * constructor) option; (* true, false *)
    retro_carry : (constructor * constructor) option; (* C0, C1 *)
    retro_pair : constructor option;
    retro_cmp : (constructor * constructor * constructor) option;
                    (* Eq, Lt, Gt *)
    retro_refl : constructor option;
}

val empty : retroknowledge

type action =
  | Register_ind of CPrimitives.prim_ind * inductive
  | Register_type of CPrimitives.prim_type * Constant.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#retroknowledge.mli"><code>Retroknowledge_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Module retroknowledge.
  Record record := {
    retro_int63 : option Names.Constant.t;
    retro_bool : option (Names.constructor * Names.constructor);
    retro_carry : option (Names.constructor * Names.constructor);
    retro_pair : option Names.constructor;
    retro_cmp :
      option (Names.constructor * Names.constructor * Names.constructor);
    retro_refl : option Names.constructor }.
  Definition with_retro_int63 (r : record) retro_int63 : record :=
    {| retro_int63 := retro_int63; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_bool (r : record) retro_bool : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_carry (r : record) retro_carry : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_pair (r : record) retro_pair : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair;
      retro_cmp := retro_cmp r; retro_refl := retro_refl r |}.
  Definition with_retro_cmp (r : record) retro_cmp : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp; retro_refl := retro_refl r |}.
  Definition with_retro_refl (r : record) retro_refl : record :=
    {| retro_int63 := retro_int63 r; retro_bool := retro_bool r;
      retro_carry := retro_carry r; retro_pair := retro_pair r;
      retro_cmp := retro_cmp r; retro_refl := retro_refl |}.
End retroknowledge.
Definition retroknowledge := retroknowledge.record.

Parameter empty : retroknowledge.

Inductive action : Set :=
| Register_ind : CPrimitives.prim_ind -&gt; Names.inductive -&gt; action
| Register_type : CPrimitives.prim_type -&gt; Names.Constant.t -&gt; action.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="retypeops.ml">
  <div style="margin: 20px;">
    <h3>Retypeops</h3>
    <ul>
      <li>OCaml size: 113 lines</li>
      <li>Coq size: 166 lines (+46% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#retypeops.ml"><code>retypeops.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
(* &lt;O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2016     *)
(*   \VV/  **************************************************************)
(*    //   *      This file is distributed under the terms of the       *)
(*         *       GNU Lesser General Public License Version 2.1        *)
(************************************************************************)

open Util
open Names
open Constr
open Declarations
open Environ
open Context

module RelDecl = Context.Rel.Declaration

let relevance_of_rel env n =
  let decl = lookup_rel n env in
  RelDecl.get_relevance decl

let relevance_of_var env x =
  let decl = lookup_named x env in
  Context.Named.Declaration.get_relevance decl

let relevance_of_constant env c =
  let decl = lookup_constant c env in
  decl.const_relevance

let relevance_of_constructor env ((mi,i),_) =
  let decl = lookup_mind mi env in
  let packet = decl.mind_packets.(i) in
  packet.mind_relevance

let relevance_of_projection env p =
  let mind = Projection.mind p in
  let mib = lookup_mind mind env in
  Declareops.relevance_of_projection_repr mib (Projection.repr p)

let relevance_of_flex env = function
  | ConstKey (c,_) -&gt; relevance_of_constant env c
  | VarKey x -&gt; relevance_of_var env x
  | RelKey p -&gt; relevance_of_rel env p

let rec relevance_of_fterm env extra lft f =
  let open CClosure in
  match CClosure.relevance_of f with
  | KnownR -&gt; Sorts.Relevant
  | KnownI -&gt; Sorts.Irrelevant
  | Unknown -&gt;
    let r = match fterm_of f with
      | FRel n -&gt; Range.get extra (Esubst.reloc_rel n lft - 1)
      | FAtom c -&gt; relevance_of_term_extra env extra lft (Esubst.subs_id 0) c
      | FFlex key -&gt; relevance_of_flex env key
      | FInt _ -&gt; Sorts.Relevant
      | FInd _ | FProd _ -&gt; Sorts.Relevant (* types are always relevant *)
      | FConstruct (c,_) -&gt; relevance_of_constructor env c
      | FApp (f, _) -&gt; relevance_of_fterm env extra lft f
      | FProj (p, _) -&gt; relevance_of_projection env p
      | FFix (((_,i),(lna,_,_)), _) -&gt; (lna.(i)).binder_relevance
      | FCoFix ((i,(lna,_,_)), _) -&gt; (lna.(i)).binder_relevance
      | FCaseT (ci, _, _, _, _) -&gt; ci.ci_relevance
      | FLambda (len, tys, bdy, e) -&gt;
        let extra = List.fold_left (fun accu (x, _) -&gt; Range.cons (binder_relevance x) accu) extra tys in
        let lft = Esubst.el_liftn len lft in
        let e = Esubst.subs_liftn len e in
        relevance_of_term_extra env extra lft e bdy
      | FLetIn (x, _, _, bdy, e) -&gt;
        relevance_of_term_extra env (Range.cons x.binder_relevance extra)
          (Esubst.el_lift lft) (Esubst.subs_lift e) bdy
      | FLIFT (k, f) -&gt; relevance_of_fterm env extra (Esubst.el_shft k lft) f
      | FCLOS (c, e) -&gt; relevance_of_term_extra env extra lft e c

      | FEvar (_, _) -&gt; Sorts.Relevant (* let's assume evars are relevant for now *)
      | FLOCKED -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">CClosure.set_relevance r f;
    r</abbr>

and relevance_of_term_extra env extra lft subs c =
  match kind c with
  | Rel n -&gt;
    begin match Esubst.expand_rel n subs with
     | Inl (k, f) -&gt; relevance_of_fterm env extra (Esubst.el_liftn k lft) f
     | Inr (n, None) -&gt; Range.get extra (Esubst.reloc_rel n lft - 1)
     | Inr (_, Some p) -&gt; relevance_of_rel env p
    end
  | Var x -&gt; relevance_of_var env x
  | Sort _ | Ind _ | Prod _ -&gt; Sorts.Relevant (* types are always relevant *)
  | Cast (c, _, _) -&gt; relevance_of_term_extra env extra lft subs c
  | Lambda ({binder_relevance=r;_}, _, bdy) -&gt;
    relevance_of_term_extra env (Range.cons r extra) (Esubst.el_lift lft) (Esubst.subs_lift subs) bdy
  | LetIn ({binder_relevance=r;_}, _, _, bdy) -&gt;
    relevance_of_term_extra env (Range.cons r extra) (Esubst.el_lift lft) (Esubst.subs_lift subs) bdy
  | App (c, _) -&gt; relevance_of_term_extra env extra lft subs c
  | Const (c,_) -&gt; relevance_of_constant env c
  | Construct (c,_) -&gt; relevance_of_constructor env c
  | Case (ci, _, _, _) -&gt; ci.ci_relevance
  | Fix ((_,i),(lna,_,_)) -&gt; (lna.(i)).binder_relevance
  | CoFix (i,(lna,_,_)) -&gt; (lna.(i)).binder_relevance
  | Proj (p, _) -&gt; relevance_of_projection env p
  | Int _ -&gt; Sorts.Relevant

  | Meta _ | Evar _ -&gt; Sorts.Relevant (* let's assume metas and evars are relevant for now *)

let relevance_of_fterm env extra lft c =
  if Environ.sprop_allowed env then relevance_of_fterm env extra lft c
  else Sorts.Relevant

let relevance_of_term env c =
  if Environ.sprop_allowed env
  then relevance_of_term_extra env Range.empty Esubst.el_id (Esubst.subs_id 0) c
  else Sorts.Relevant
</pre>
  </div>
  <div class="col-md-6">
    <a href="#retypeops.ml"><code>Retypeops.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Environ.

Import Context.

Module RelDecl := Context.Rel.Declaration.

Definition relevance_of_rel (env : Environ.env) (n : Z) : Sorts.relevance :=
  let decl := lookup_rel n env in
  RelDecl.get_relevance decl.

Definition relevance_of_var (env : Environ.env) (x : Names.variable)
  : Sorts.relevance :=
  let decl := lookup_named x env in
  Context.Named.Declaration.get_relevance decl.

Definition relevance_of_constant (env : Environ.env) (c : Names.Constant.t)
  : Sorts.relevance :=
  let decl := lookup_constant c env in
  Declarations.constant_body.const_relevance decl.

Definition relevance_of_constructor {A : Set}
  (env : Environ.env) (function_parameter : (Names.MutInd.t * Z) * A)
  : Sorts.relevance :=
  let '((mi, i), _) := function_parameter in
  let decl := lookup_mind mi env in
  let packet :=
    (|Util.Array|).(CArray.ExtS.get)
      (Declarations.mutual_inductive_body.mind_packets decl) i in
  Declarations.one_inductive_body.mind_relevance packet.

Definition relevance_of_projection (env : Environ.env) (p : Names.Projection.t)
  : Sorts.relevance :=
  let mind := Projection.mind p in
  let mib := lookup_mind mind env in
  Declareops.relevance_of_projection_repr mib (Projection.repr p).

Definition relevance_of_flex {A : Set}
  (env : Environ.env)
  (function_parameter : Names.tableKey (Names.Constant.t * A))
  : Sorts.relevance :=
  match function_parameter with
  | Names.ConstKey (c, _) =&gt; relevance_of_constant env c
  | Names.VarKey x =&gt; relevance_of_var env x
  | Names.RelKey p =&gt; relevance_of_rel env p
  end.

Fixpoint relevance_of_fterm
  (env : Environ.env) (extra : Range.t Sorts.relevance) (lft : Esubst.lift)
  (f : CClosure.fconstr) {struct env} : Sorts.relevance :=
  match CClosure.relevance_of f with
  | CClosure.KnownR =&gt; Sorts.Relevant
  | CClosure.KnownI =&gt; Sorts.Irrelevant
  | CClosure.Unknown =&gt;
    let r :=
      match fterm_of f with
      | CClosure.FRel n =&gt; Range.get extra (Z.sub (Esubst.reloc_rel n lft) 1)
      | CClosure.FAtom c =&gt;
        relevance_of_term_extra env extra lft (Esubst.subs_id 0) c
      | CClosure.FFlex key =&gt; relevance_of_flex env key
      | CClosure.FInt _ =&gt; Sorts.Relevant
      | CClosure.FInd _ | CClosure.FProd _ _ _ _ =&gt; Sorts.Relevant
      | CClosure.FConstruct (c, _) =&gt; relevance_of_constructor env c
      | CClosure.FApp f _ =&gt; relevance_of_fterm env extra lft f
      | CClosure.FProj p _ =&gt; relevance_of_projection env p
      | CClosure.FFix ((_, i), (lna, _, _)) _ =&gt;
        Context.binder_annot.binder_relevance
          ((|Util.Array|).(CArray.ExtS.get) lna i)
      | CClosure.FCoFix (i, (lna, _, _)) _ =&gt;
        Context.binder_annot.binder_relevance
          ((|Util.Array|).(CArray.ExtS.get) lna i)
      | CClosure.FCaseT ci _ _ _ _ =&gt; Constr.case_info.ci_relevance ci
      | CClosure.FLambda len tys bdy e =&gt;
        let extra :=
          (|Util.List|).(CList.ExtS.fold_left)
            (fun accu =&gt;
              fun function_parameter =&gt;
                let '(x, _) := function_parameter in
                Range.cons (binder_relevance x) accu) extra tys in
        let lft := Esubst.el_liftn len lft in
        let e := Esubst.subs_liftn len e in
        relevance_of_term_extra env extra lft e bdy
      | CClosure.FLetIn x _ _ bdy e =&gt;
        relevance_of_term_extra env
          (Range.cons (Context.binder_annot.binder_relevance x) extra)
          (Esubst.el_lift lft) (Esubst.subs_lift e) bdy
      | CClosure.FLIFT k f =&gt;
        relevance_of_fterm env extra (Esubst.el_shft k lft) f
      | CClosure.FCLOS c e =&gt; relevance_of_term_extra env extra lft e c
      | CClosure.FEvar _ _ =&gt; Sorts.Relevant
      | CClosure.FLOCKED =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    r
  end

with relevance_of_term_extra
  (env : Environ.env) (extra : Range.t Sorts.relevance) (lft : Esubst.lift)
  (subs : Esubst.subs CClosure.fconstr) (c : Constr.constr) {struct env}
  : Sorts.relevance :=
  match kind c with
  | Constr.Rel n =&gt;
    match Esubst.expand_rel n subs with
    | Util.Inl (k, f) =&gt; relevance_of_fterm env extra (Esubst.el_liftn k lft) f
    | Util.Inr (n, None) =&gt; Range.get extra (Z.sub (Esubst.reloc_rel n lft) 1)
    | Util.Inr (_, Some p) =&gt; relevance_of_rel env p
    end
  | Constr.Var x =&gt; relevance_of_var env x
  | Constr.Sort _ | Constr.Ind _ | Constr.Prod _ _ _ =&gt; Sorts.Relevant
  | Constr.Cast c _ _ =&gt; relevance_of_term_extra env extra lft subs c
  | Constr.Lambda {| Context.binder_annot.binder_relevance := r |} _ bdy =&gt;
    relevance_of_term_extra env (Range.cons r extra) (Esubst.el_lift lft)
      (Esubst.subs_lift subs) bdy
  | Constr.LetIn {| Context.binder_annot.binder_relevance := r |} _ _ bdy =&gt;
    relevance_of_term_extra env (Range.cons r extra) (Esubst.el_lift lft)
      (Esubst.subs_lift subs) bdy
  | Constr.App c _ =&gt; relevance_of_term_extra env extra lft subs c
  | Constr.Const (c, _) =&gt; relevance_of_constant env c
  | Constr.Construct (c, _) =&gt; relevance_of_constructor env c
  | Constr.Case ci _ _ _ =&gt; Constr.case_info.ci_relevance ci
  | Constr.Fix ((_, i), (lna, _, _)) =&gt;
    Context.binder_annot.binder_relevance
      ((|Util.Array|).(CArray.ExtS.get) lna i)
  | Constr.CoFix (i, (lna, _, _)) =&gt;
    Context.binder_annot.binder_relevance
      ((|Util.Array|).(CArray.ExtS.get) lna i)
  | Constr.Proj p _ =&gt; relevance_of_projection env p
  | Constr.Int _ =&gt; Sorts.Relevant
  | Constr.Meta _ | Constr.Evar _ =&gt; Sorts.Relevant
  end.

Definition relevance_of_fterm
  (env : Environ.env) (extra : Range.t Sorts.relevance) (lft : Esubst.lift)
  (c : CClosure.fconstr) : Sorts.relevance :=
  if Environ.sprop_allowed env then
    relevance_of_fterm env extra lft c
  else
    Sorts.Relevant.

Definition relevance_of_term (env : Environ.env) (c : Constr.constr)
  : Sorts.relevance :=
  if Environ.sprop_allowed env then
    relevance_of_term_extra env Range.empty Esubst.el_id (Esubst.subs_id 0) c
  else
    Sorts.Relevant.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="retypeops.mli">
  <div style="margin: 20px;">
    <h3>Retypeops_mli</h3>
    <ul>
      <li>OCaml size: 26 lines</li>
      <li>Coq size: 29 lines (+11% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#retypeops.mli"><code>retypeops.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
(* &lt;O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2016     *)
(*   \VV/  **************************************************************)
(*    //   *      This file is distributed under the terms of the       *)
(*         *       GNU Lesser General Public License Version 2.1        *)
(************************************************************************)

(** We can take advantage of non-cumulativity of SProp to avoid fully
   retyping terms when we just want to know if they inhabit some
   proof-irrelevant type. *)

val relevance_of_term : Environ.env -&gt; Constr.constr -&gt; Sorts.relevance

val relevance_of_fterm : Environ.env -&gt; Sorts.relevance Range.t -&gt;
  Esubst.lift -&gt; CClosure.fconstr -&gt;
  Sorts.relevance


(** Helpers *)
open Names
val relevance_of_rel : Environ.env -&gt; int -&gt; Sorts.relevance
val relevance_of_var : Environ.env -&gt; Id.t -&gt; Sorts.relevance
val relevance_of_constant : Environ.env -&gt; Constant.t -&gt; Sorts.relevance
val relevance_of_constructor : Environ.env -&gt; constructor -&gt; Sorts.relevance
val relevance_of_projection : Environ.env -&gt; Projection.t -&gt; Sorts.relevance
</pre>
  </div>
  <div class="col-md-6">
    <a href="#retypeops.mli"><code>Retypeops_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter relevance_of_term : Environ.env -&gt; Constr.constr -&gt; Sorts.relevance.

Parameter relevance_of_fterm :
  Environ.env -&gt; Range.t Sorts.relevance -&gt; Esubst.lift -&gt; CClosure.fconstr -&gt;
  Sorts.relevance.

Parameter relevance_of_rel : Environ.env -&gt; Z -&gt; Sorts.relevance.

Parameter relevance_of_var : Environ.env -&gt; Names.Id.t -&gt; Sorts.relevance.

Parameter relevance_of_constant :
  Environ.env -&gt; Names.Constant.t -&gt; Sorts.relevance.

Parameter relevance_of_constructor :
  Environ.env -&gt; Names.constructor -&gt; Sorts.relevance.

Parameter relevance_of_projection :
  Environ.env -&gt; Names.Projection.t -&gt; Sorts.relevance.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="safe_typing.ml">
  <div style="margin: 20px;">
    <h3>Safe_typing</h3>
    <ul>
      <li>OCaml size: 1313 lines</li>
      <li>Coq size: 2136 lines (+62% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#safe_typing.ml"><code>safe_typing.ml</code></a>&nbsp;<span class="label label-warning">95 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jean-Christophe FilliÃ¢tre as part of the rebuilding of
   Coq around a purely functional abstract type-checker, Dec 1999 *)

(* This file provides the entry points to the kernel type-checker. It
   defines the abstract type of well-formed environments and
   implements the rules that build well-formed environments.

   An environment is made of constants and inductive types (E), of
   section declarations (Delta), of local bound-by-index declarations
   (Gamma) and of universe constraints (C). Below E[Delta,Gamma] |-_C
   means that the tuple E, Delta, Gamma, C is a well-formed
   environment. Main rules are:

   empty_environment:

     ------
     [,] |-

   push_named_assum(a,T):

     E[Delta,Gamma] |-_G
     ------------------------
     E[Delta,Gamma,a:T] |-_G'

   push_named_def(a,t,T):

     E[Delta,Gamma] |-_G
     ---------------------------
     E[Delta,Gamma,a:=t:T] |-_G'

   add_constant(ConstantEntry(DefinitionEntry(c,t,T))):

     E[Delta,Gamma] |-_G
     ---------------------------
     E,c:=t:T[Delta,Gamma] |-_G'

   add_constant(ConstantEntry(ParameterEntry(c,T))):

     E[Delta,Gamma] |-_G
     ------------------------
     E,c:T[Delta,Gamma] |-_G'

   add_mind(Ind(Ind[Gamma_p](Gamma_I:=Gamma_C))):

     E[Delta,Gamma] |-_G
     ------------------------
     E,Ind[Gamma_p](Gamma_I:=Gamma_C)[Delta,Gamma] |-_G'

   etc.
*)

open Util
open Names
open Declarations
open Constr
open Context.Named.Declaration

module NamedDecl = Context.Named.Declaration

(** {6 Safe environments }

  Fields of [safe_environment] :

  - [env] : the underlying environment (cf Environ)
  - [modpath] : the current module name
  - [modvariant] :
    * NONE before coqtop initialization
    * LIBRARY at toplevel of a compilation or a regular coqtop session
    * STRUCT (params,oldsenv) : inside a local module, with
      module parameters [params] and earlier environment [oldsenv]
    * SIG (params,oldsenv) : same for a local module type
  - [modresolver] : delta_resolver concerning the module content
  - [paramresolver] : delta_resolver concerning the module parameters
  - [revstruct] : current module content, most recent declarations first
  - [modlabels] and [objlabels] : names defined in the current module,
      either for modules/modtypes or for constants/inductives.
      These fields could be deduced from [revstruct], but they allow faster
      name freshness checks.
 - [univ] and [future_cst] : current and future universe constraints
 - [engagement] : are we Set-impredicative? does the universe hierarchy collapse?
 - [required] : names and digests of Require'd libraries since big-bang.
      This field will only grow
 - [loads] : list of libraries Require'd inside the current module.
      They will be propagated to the upper module level when
      the current module ends.
 - [local_retroknowledge]

*)

type vodigest =
  | Dvo_or_vi of Digest.t        (* The digest of the seg_lib part *)
  | Dvivo of Digest.t * Digest.t (* The digest of the seg_lib + seg_univ part *)

let digest_match ~actual ~required =
  match actual, required with
  | Dvo_or_vi d1, Dvo_or_vi d2
  | Dvivo (d1,_), Dvo_or_vi d2 -&gt; String.equal d1 d2
  | Dvivo (d1,e1), Dvivo (d2,e2) -&gt; String.equal d1 d2 &amp;&amp; String.equal e1 e2
  | Dvo_or_vi _, Dvivo _ -&gt; false

type library_info = DirPath.t * vodigest

(** Functor and funsig parameters, most recent first *)
type module_parameters = (MBId.t * module_type_body) list

module DPMap = Map.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">DirPath</abbr>)

type safe_environment =
  { env : Environ.env;
    modpath : ModPath.t;
    modvariant : modvariant;
    modresolver : Mod_subst.delta_resolver;
    paramresolver : Mod_subst.delta_resolver;
    revstruct : structure_body;
    modlabels : Label.Set.t;
    objlabels : Label.Set.t;
    univ : Univ.ContextSet.t;
    future_cst : Univ.ContextSet.t Future.computation list;
    engagement : engagement option;
    required : vodigest DPMap.t;
    loads : (ModPath.t * module_body) list;
    local_retroknowledge : Retroknowledge.action list;
    native_symbols : Nativecode.symbols DPMap.t }

and modvariant =
  | NONE
  | LIBRARY
  | SIG of module_parameters * safe_environment (** saved env *)
  | STRUCT of module_parameters * safe_environment (** saved env *)

let rec library_dp_of_senv senv =
  match senv.modvariant with
  | NONE | LIBRARY -&gt; ModPath.dp senv.modpath
  | SIG(_,senv) -&gt; library_dp_of_senv senv
  | STRUCT(_,senv) -&gt; library_dp_of_senv senv

let empty_environment =
  { env = Environ.empty_env;
    modpath = ModPath.initial;
    modvariant = NONE;
    modresolver = Mod_subst.empty_delta_resolver;
    paramresolver = Mod_subst.empty_delta_resolver;
    revstruct = [];
    modlabels = Label.Set.empty;
    objlabels = Label.Set.empty;
    future_cst = [];
    univ = Univ.ContextSet.empty;
    engagement = None;
    required = DPMap.empty;
    loads = [];
    local_retroknowledge = [];
    native_symbols = DPMap.empty }

let is_initial senv =
  match senv.revstruct, senv.modvariant with
  | [], NONE -&gt; ModPath.equal senv.modpath ModPath.initial
  | _ -&gt; false

let delta_of_senv senv = senv.modresolver,senv.paramresolver

let constant_of_delta_kn_senv senv kn =
  Mod_subst.constant_of_deltas_kn senv.paramresolver senv.modresolver kn

let mind_of_delta_kn_senv senv kn =
  Mod_subst.mind_of_deltas_kn senv.paramresolver senv.modresolver kn

(** The safe_environment state monad *)

type safe_transformer0 = safe_environment -&gt; safe_environment
type 'a safe_transformer = safe_environment -&gt; 'a * safe_environment


(** {6 Engagement } *)

let set_engagement_opt env = function
  | Some c -&gt; Environ.set_engagement c env
  | None -&gt; env

let set_engagement c senv =
  { senv with
    env = Environ.set_engagement c senv.env;
    engagement = Some c }

let set_typing_flags c senv =
  let env = Environ.set_typing_flags c senv.env in
  if env == senv.env then senv
  else { senv with env }

let set_indices_matter indices_matter senv =
  set_typing_flags { (Environ.typing_flags senv.env) with indices_matter } senv

let set_share_reduction b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with share_reduction = b } senv

let set_VM b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with enable_VM = b } senv

let set_native_compiler b senv =
  let flags = Environ.typing_flags senv.env in
  set_typing_flags { flags with enable_native_compiler = b } senv

let make_sprop_cumulative senv = { senv with env = Environ.make_sprop_cumulative senv.env }

let set_allow_sprop b senv = { senv with env = Environ.set_allow_sprop b senv.env }

(** Check that the engagement [c] expected by a library matches
    the current (initial) one *)
let check_engagement env expected_impredicative_set =
  let impredicative_set = Environ.engagement env in
  begin
    match impredicative_set, expected_impredicative_set with
    | PredicativeSet, ImpredicativeSet -&gt;
        CErrors.user_err Pp.(str &quot;Needs option -impredicative-set.&quot;)
    | _ -&gt; ()
  end

(** {6 Stm machinery } *)

let <abbr class="mark-warning" title="Polymorphic variant types are not handled">get_opaque_body</abbr> env cbo =
  match cbo.const_body with
  | Undef _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Primitive _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Def _ -&gt; <abbr class="mark-warning" title="Variants not supported">`Nothing</abbr>
  | OpaqueDef opaque -&gt;
      <abbr class="mark-warning" title="Variants not supported">`Opaque
        (Opaqueproof.force_proof (Environ.opaque_tables env) opaque,
         Opaqueproof.force_constraints (Environ.opaque_tables env) opaque)</abbr>

type side_effect = {
  from_env : Declarations.structure_body CEphemeron.key;
  eff      : Entries.side_eff list;
}

module SideEffects :
sig
  type t
  val repr : t -&gt; side_effect list
  val empty : t
  val add : side_effect -&gt; t -&gt; t
  val concat : t -&gt; t -&gt; t
end =
struct

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module SeffOrd = struct
</abbr><abbr class="mark-warning" title="Open not handled in module with a named signature

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">open Entries</abbr><abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">
type t = side_effect
let compare e1 e2 =
  let cmp e1 e2 = Constant.CanOrd.compare e1.seff_constant e2.seff_constant in
  List.compare cmp e1.eff e2.eff
end</abbr>

module SeffSet = Set.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__map.OrderedType, Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">SeffOrd</abbr>)

type t = { seff : side_effect list; elts : SeffSet.t }
(** Invariant: [seff] is a permutation of the elements of [elts] *)

let repr eff = eff.seff
let empty = { seff = []; elts = SeffSet.empty }
let add x es =
  if SeffSet.mem x es.elts then es
  else { seff = x :: es.seff; elts = SeffSet.add x es.elts }
let concat xes yes =
  List.fold_right add xes.seff yes

end

type private_constants = SideEffects.t

let side_effects_of_private_constants l =
  let ans = List.rev (SideEffects.repr l) in
  List.map_append (fun { eff; _ } -&gt; eff) ans

let empty_private_constants = SideEffects.empty
let add_private mb eff effs =
  let from_env = CEphemeron.create mb in
  SideEffects.add { eff; from_env } effs
let concat_private = SideEffects.concat

let make_eff env cst r =
  let open Entries in
  let cbo = Environ.lookup_constant cst env.env in
  {
    seff_constant = cst;
    seff_body = cbo;
    seff_env = get_opaque_body env.env cbo;
    seff_role = r;
  }

let private_con_of_con env c =
  let open Entries in
  let eff = [make_eff env c Subproof] in
  add_private env.revstruct eff empty_private_constants

let private_con_of_scheme ~kind env cl =
  let open Entries in
  let eff = List.map (fun (i, c) -&gt; make_eff env c (Schema (i, kind))) cl in
  add_private env.revstruct eff empty_private_constants

let universes_of_private eff =
  let open Entries in
  let fold acc eff =
    let acc = match eff.seff_env with
    | <abbr class="mark-warning" title="Patterns on variants are not supported">`Nothing</abbr> -&gt; acc
    | <abbr class="mark-warning" title="Patterns on variants are not supported">`Opaque (_, ctx)</abbr> -&gt; ctx :: acc
    in
    match eff.seff_body.const_universes with
    | Monomorphic ctx -&gt; ctx :: acc
    | Polymorphic _ -&gt; acc
  in
  List.fold_left fold [] (side_effects_of_private_constants eff)

let env_of_safe_env senv = senv.env
let env_of_senv = env_of_safe_env

type constraints_addition =
  | Now of bool * Univ.ContextSet.t
  | Later of Univ.ContextSet.t Future.computation

let add_constraints cst senv =
  match cst with
  | Later fc -&gt;
    {senv with future_cst = fc :: senv.future_cst}
  | Now (poly,cst) -&gt;
  { senv with
    env = Environ.push_context_set ~strict:(not poly) cst senv.env;
    univ = Univ.ContextSet.union cst senv.univ }

let add_constraints_list cst senv =
  List.fold_left (fun acc c -&gt; add_constraints c acc) senv cst

let push_context_set poly ctx = add_constraints (Now (poly,ctx))

let is_curmod_library senv =
  match senv.modvariant with LIBRARY -&gt; true | _ -&gt; false

let join_safe_environment ?(except=Future.UUIDSet.empty) e =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Modops.join_structure except (Environ.opaque_tables e.env) e.revstruct;
  List.fold_left
    (fun e fc -&gt;
       if Future.UUIDSet.mem (Future.uuid fc) except then e
       else add_constraints (Now (false, Future.join fc)) e)
    {e with future_cst = []} e.future_cst</abbr>

let is_joined_environment e = List.is_empty e.future_cst

(** {6 Various checks } *)

let exists_modlabel l senv = Label.Set.mem l senv.modlabels
let exists_objlabel l senv = Label.Set.mem l senv.objlabels

let check_modlabel l senv =
  if exists_modlabel l senv then Modops.error_existing_label l

let check_objlabel l senv =
  if exists_objlabel l senv then Modops.error_existing_label l

let check_objlabels ls senv =
  Label.Set.iter (fun l -&gt; check_objlabel l senv) ls

(** Are we closing the right module / modtype ?
    No user error here, since the opening/ending coherence
    is now verified in [vernac_end_segment] *)

let check_current_label lab = function
  | MPdot (_,l) -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert (Label.equal lab l)</abbr>
  | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let check_struct = function
  | STRUCT (params,oldsenv) -&gt; params, oldsenv
  | NONE | LIBRARY | SIG _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let check_sig = function
  | SIG (params,oldsenv) -&gt; params, oldsenv
  | NONE | LIBRARY | STRUCT _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let check_current_library dir senv = match senv.modvariant with
  | LIBRARY -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert (ModPath.equal senv.modpath (MPfile dir))</abbr>
  | NONE | STRUCT _ | SIG _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* cf Lib.end_compilation *)

(** When operating on modules, we're normally outside sections *)

let check_empty_context senv =
  <abbr class="mark-warning" title="Assert instruction is not handled.">assert (Environ.empty_context senv.env)</abbr>

(** When adding a parameter to the current module/modtype,
    it must have been freshly started *)

let check_empty_struct senv =
  <abbr class="mark-warning" title="Assert instruction is not handled.">assert (List.is_empty senv.revstruct
          &amp;&amp; List.is_empty senv.loads)</abbr>

(** When starting a library, the current environment should be initial
    i.e. only composed of Require's *)

let check_initial senv = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (is_initial senv)</abbr>

(** When loading a library, its dependencies should be already there,
    with the correct digests. *)

let check_required current_libs needed =
  let check (id,required) =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
      let actual = DPMap.find id current_libs in
      if not(digest_match ~actual ~required) then
        CErrors.user_err Pp.(pr_sequence str
          [&quot;Inconsistent assumptions over module&quot;; DirPath.to_string id; &quot;.&quot;])
    with Not_found -&gt;
      CErrors.user_err Pp.(pr_sequence str [&quot;Reference to unknown module&quot;; DirPath.to_string id; &quot;.&quot;])</abbr>
  in
  Array.iter check needed


(** {6 Insertion of section variables} *)

(** They are now typed before being added to the environment.
    Same as push_named, but check that the variable is not already
    there. Should *not* be done in Environ because tactics add temporary
    hypothesis many many times, and the check performed here would
    cost too much. *)

let safe_push_named d env =
  let id = NamedDecl.get_id d in
  let _ =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
      let _ = Environ.lookup_named id env in
      CErrors.user_err Pp.(pr_sequence str [&quot;Identifier&quot;; Id.to_string id; &quot;already defined.&quot;])
    with Not_found -&gt; ()</abbr> in
  Environ.push_named d env


let push_named_def (id,de) senv =
  let c, r, typ = Term_typing.translate_local_def senv.env id de in
  let x = Context.make_annot id r in
  let env'' = safe_push_named (LocalDef (x, c, typ)) senv.env in
  { senv with env = env'' }

let push_named_assum ((id,t,poly),ctx) senv =
  let senv' = push_context_set poly ctx senv in
  let t, r = Term_typing.translate_local_assum senv'.env t in
  let x = Context.make_annot id r in
  let env'' = safe_push_named (LocalAssum (x,t)) senv'.env in
    {senv' with env=env''}


(** {6 Insertion of new declarations to current environment } *)

let labels_of_mib mib =
  let add,get =
    let labels = ref Label.Set.empty in
    (fun id -&gt; labels := Label.Set.add (Label.of_id id) !labels),
    (fun () -&gt; !labels)
  in
  let visit_mip mip =
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">add mip.mind_typename;
    Array.iter add mip.mind_consnames</abbr>
  in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.iter visit_mip mib.mind_packets;
  get ()</abbr>

let globalize_constant_universes env cb =
  match cb.const_universes with
  | Monomorphic cstrs -&gt;
    Now (false, cstrs) ::
    (match cb.const_body with
     | (Undef _ | Def _ | Primitive _) -&gt; []
     | OpaqueDef lc -&gt;
       match Opaqueproof.get_constraints (Environ.opaque_tables env) lc with
       | None -&gt; []
       | Some fc -&gt;
            match Future.peek_val fc with
             | None -&gt; [Later fc]
             | Some c -&gt; [Now (false, c)])
  | Polymorphic _ -&gt;
    [Now (true, Univ.ContextSet.empty)]

let globalize_mind_universes mb =
  match mb.mind_universes with
  | Monomorphic ctx -&gt;
    [Now (false, ctx)]
  | Polymorphic _ -&gt; [Now (true, Univ.ContextSet.empty)]

let constraints_of_sfb env sfb =
  match sfb with
  | SFBconst cb -&gt; globalize_constant_universes env cb
  | SFBmind mib -&gt; globalize_mind_universes mib
  | SFBmodtype mtb -&gt; [Now (false, mtb.mod_constraints)]
  | SFBmodule mb -&gt; [Now (false, mb.mod_constraints)]

let add_retroknowledge pttc senv =
  { senv with
    env = Primred.add_retroknowledge senv.env pttc;
    local_retroknowledge = pttc::senv.local_retroknowledge }

(** A generic function for adding a new field in a same environment.
    It also performs the corresponding [add_constraints]. *)

type generic_name =
  | C of Constant.t
  | I of MutInd.t
  | M (** name already known, cf the mod_mp field *)
  | MT (** name already known, cf the mod_mp field *)

let add_field ?(is_include=false) ((l,sfb) as field) gn senv =
  let mlabs,olabs = match sfb with
    | SFBmind mib -&gt;
      let l = labels_of_mib mib in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_objlabels l senv; (Label.Set.empty,l)</abbr>
    | SFBconst _ -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_objlabel l senv; (Label.Set.empty, Label.Set.singleton l)</abbr>
    | SFBmodule _ | SFBmodtype _ -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_modlabel l senv; (Label.Set.singleton l, Label.Set.empty)</abbr>
  in
  let senv =
    if is_include then
      (* Universes and constraints were added when the included module
         was defined eg in [Include F X.] (one of the trickier
         versions of Include) the constraints on the fields are
         exactly those of the fields of F which was defined
         separately. *)
      senv
    else
      let cst = constraints_of_sfb senv.env sfb in
      add_constraints_list cst senv
  in
  let env' = match sfb, gn with
    | SFBconst cb, C con -&gt; Environ.add_constant con cb senv.env
    | SFBmind mib, I mind -&gt; Environ.add_mind mind mib senv.env
    | SFBmodtype mtb, MT -&gt; Environ.add_modtype mtb senv.env
    | SFBmodule mb, M -&gt; Modops.add_module mb senv.env
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in
  { senv with
    env = env';
    revstruct = field :: senv.revstruct;
    modlabels = Label.Set.union mlabs senv.modlabels;
    objlabels = Label.Set.union olabs senv.objlabels }

(** Applying a certain function to the resolver of a safe environment *)

let update_resolver f senv = { senv with modresolver = f senv.modresolver }

(** Insertion of constants and parameters in environment *)
type 'a effect_entry =
| EffectEntry : private_constants effect_entry
| PureEntry : unit effect_entry

type global_declaration =
  | ConstantEntry : 'a effect_entry * 'a Entries.constant_entry -&gt; global_declaration
  | GlobalRecipe of Cooking.recipe

type exported_private_constant =
  Constant.t * Entries.side_effect_role

let add_constant_aux ~in_section senv (kn, cb) =
  let l = Constant.label kn in
  (* This is the only place where we hashcons the contents of a constant body *)
  let cb = if in_section then cb else Declareops.hcons_const_body cb in
  let cb, otab = match cb.const_body with
    | OpaqueDef lc when not in_section -&gt;
      (* In coqc, opaque constants outside sections will be stored
         indirectly in a specific table *)
      let od, otab =
        Opaqueproof.turn_indirect
          (library_dp_of_senv senv) lc (Environ.opaque_tables senv.env) in
      { cb with const_body = OpaqueDef od }, otab
    | _ -&gt; cb, (Environ.opaque_tables senv.env)
  in
  let senv = { senv with env = Environ.set_opaque_tables senv.env otab } in
  let senv' = add_field (l,SFBconst cb) (C kn) senv in
  let senv'' = match cb.const_body with
    | Undef (Some lev) -&gt;
      update_resolver
        (Mod_subst.add_inline_delta_resolver (Constant.user kn) (lev,None)) senv'
    | _ -&gt; senv'
  in
  senv''

let mk_pure_proof c = (c, Univ.ContextSet.empty), SideEffects.empty

let inline_side_effects env body side_eff =
  let open Entries in
  let open Constr in
  (** First step: remove the constants that are still in the environment *)
  let filter { eff = se; from_env = mb } =
    let map e = (e.seff_constant, e.seff_body, e.seff_env) in
    let cbl = List.map map se in
    let not_exists (c,_,_) =
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">ignore(Environ.lookup_constant c env); false</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
      with Not_found -&gt; true</abbr> in
    let cbl = List.filter not_exists cbl in
    (cbl, mb)
  in
  (* CAVEAT: we assure that most recent effects come first *)
  let side_eff = List.map filter (SideEffects.repr side_eff) in
  let sigs = List.rev_map (fun (cbl, mb) -&gt; mb, List.length cbl) side_eff in
  let side_eff = List.fold_left (fun accu (cbl, _) -&gt; cbl @ accu) [] side_eff in
  let side_eff = List.rev side_eff in
  (** Most recent side-effects first in side_eff *)
  if List.is_empty side_eff then (body, Univ.ContextSet.empty, sigs)
  else
    (** Second step: compute the lifts and substitutions to apply *)
    let cname c r = Context.make_annot (Name (Label.to_id (Constant.label c))) r in
    let <abbr class="mark-warning" title="Polymorphic variant types are not handled">fold</abbr> (subst, var, ctx, args) (c, cb, b) =
      let (b, opaque) = match cb.const_body, b with
      | Def b, _ -&gt; (Mod_subst.force_constr b, false)
      | OpaqueDef _, <abbr class="mark-warning" title="Patterns on variants are not supported">`Opaque (b,_)</abbr> -&gt; (b, true)
      | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
      in
      match cb.const_universes with
      | Monomorphic univs -&gt;
        (** Abstract over the term at the top of the proof *)
        let ty = cb.const_type in
        let subst = Cmap_env.add c (Inr var) subst in
        let ctx = Univ.ContextSet.union ctx univs in
        (subst, var + 1, ctx, (cname c cb.const_relevance, b, ty, opaque) :: args)
      | Polymorphic _ -&gt;
        (** Inline the term to emulate universe polymorphism *)
        let subst = Cmap_env.add c (Inl b) subst in
        (subst, var, ctx, args)
    in
    let (subst, len, ctx, args) = List.fold_left fold (Cmap_env.empty, 1, Univ.ContextSet.empty, []) side_eff in
    (** Third step: inline the definitions *)
    let rec subst_const i k t = match Constr.kind t with
    | Const (c, u) -&gt;
      let data = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (Cmap_env.find c subst) with Not_found -&gt; None</abbr> in
      begin match data with
      | None -&gt; t
      | Some (Inl b) -&gt;
        (** [b] is closed but may refer to other constants *)
        subst_const i k (Vars.subst_instance_constr u b)
      | Some (Inr n) -&gt;
        mkRel (k + n - i)
      end
    | Rel n -&gt;
      (** Lift free rel variables *)
      if n &lt;= k then t
      else mkRel (n + len - i - 1)
    | _ -&gt; Constr.map_with_binders ((+) 1) (fun k t -&gt; subst_const i k t) k t
    in
    let map_args i (na, b, ty, opaque) =
      (** Both the type and the body may mention other constants *)
      let ty = subst_const (len - i - 1) 0 ty in
      let b = subst_const (len - i - 1) 0 b in
      (na, b, ty, opaque)
    in
    let args = List.mapi map_args args in
    let body = subst_const 0 0 body in
    let fold_arg (na, b, ty, opaque) accu =
      if opaque then mkApp (mkLambda (na, ty, accu), <abbr class="mark-warning" title="Arrays not handled.">[|b|]</abbr>)
      else mkLetIn (na, b, ty, accu)
    in
    let body = List.fold_right fold_arg args body in
    (body, ctx, sigs)

let inline_private_constants_in_definition_entry env ce =
  let open Entries in
  { ce with
  const_entry_body = Future.chain
    ce.const_entry_body (fun ((body, ctx), side_eff) -&gt;
      let body, ctx',_ = inline_side_effects env body side_eff in
      let ctx' = Univ.ContextSet.union ctx ctx' in
      (body, ctx'), ());
  }

let inline_private_constants_in_constr env body side_eff =
  pi1 (inline_side_effects env body side_eff)

let rec is_nth_suffix n l suf =
  if Int.equal n 0 then l == suf
  else match l with
  | [] -&gt; false
  | _ :: l -&gt; is_nth_suffix (pred n) l suf

(* Given the list of signatures of side effects, checks if they match.
 * I.e. if they are ordered descendants of the current revstruct.
   Returns the number of effects that can be trusted. *)
let check_signatures curmb sl =
  let is_direct_ancestor accu (mb, how_many) =
    match accu with
    | None -&gt; None
    | Some (n, curmb) -&gt;
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
          let mb = CEphemeron.get mb in
          if is_nth_suffix how_many mb curmb
          then Some (n + how_many, mb)
          else None
        with CEphemeron.InvalidKey -&gt; None</abbr> in
  let sl = List.fold_left is_direct_ancestor (Some (0, curmb)) sl in
  match sl with
  | None -&gt; 0
  | Some (n, _) -&gt; n


let <abbr class="mark-warning" title="Polymorphic variant types are not handled">constant_entry_of_side_effect</abbr> cb u =
  let open Entries in
  let univs =
    match cb.const_universes with
    | Monomorphic uctx -&gt;
      Monomorphic_entry uctx
    | Polymorphic auctx -&gt;
      Polymorphic_entry (Univ.AUContext.names auctx, Univ.AUContext.repr auctx)
  in
  let pt =
    match cb.const_body, u with
    | OpaqueDef _, <abbr class="mark-warning" title="Patterns on variants are not supported">`Opaque (b, c)</abbr> -&gt; b, c
    | Def b, <abbr class="mark-warning" title="Patterns on variants are not supported">`Nothing</abbr> -&gt; Mod_subst.force_constr b, Univ.ContextSet.empty
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> in
  DefinitionEntry {
    const_entry_body = Future.from_val (pt, ());
    const_entry_secctx = None;
    const_entry_feedback = None;
    const_entry_type = Some cb.const_type;
    const_entry_universes = univs;
    const_entry_opaque = Declareops.is_opaque cb;
    const_entry_inline_code = cb.const_inline_code }

let turn_direct orig =
  let open Entries in
  let cb = orig.seff_body in
  if Declareops.is_opaque cb then
    let p = match orig.seff_env with
    | <abbr class="mark-warning" title="Patterns on variants are not supported">`Opaque (b, c)</abbr> -&gt; (b, c)
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    in
    let const_body = OpaqueDef (Opaqueproof.create (Future.from_val p)) in
    let cb = { cb with const_body } in
    { orig with seff_body = cb }
  else orig

let export_eff eff =
  let open Entries in
  (eff.seff_constant, eff.seff_body, eff.seff_role)

let export_side_effects mb env c =
  let open Entries in
      let body = c.const_entry_body in
      let _, eff = Future.force body in
      let ce = { c with
        Entries.const_entry_body = Future.chain body
          (fun (b_ctx, _) -&gt; b_ctx, ()) } in
      let not_exists e =
        <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">ignore(Environ.lookup_constant e.seff_constant env); false</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
        with Not_found -&gt; true</abbr> in
      let aux (acc,sl) { eff = se; from_env = mb } =
        let cbl = List.filter not_exists se in
        if List.is_empty cbl then acc, sl
        else cbl :: acc, (mb,List.length cbl) :: sl in
      let seff, signatures = List.fold_left aux ([],[]) (SideEffects.repr eff) in
      let trusted = check_signatures mb signatures in
      let push_seff env eff =
        let { seff_constant = kn; seff_body = cb ; _ } = eff in
        let env = Environ.add_constant kn cb env in
        match cb.const_universes with
        | Polymorphic _ -&gt; env
        | Monomorphic ctx -&gt;
          let ctx = match eff.seff_env with
          | <abbr class="mark-warning" title="Patterns on variants are not supported">`Nothing</abbr> -&gt; ctx
          | <abbr class="mark-warning" title="Patterns on variants are not supported">`Opaque(_, ctx')</abbr> -&gt; Univ.ContextSet.union ctx' ctx
          in
          Environ.push_context_set ~strict:true ctx env
      in
      let rec translate_seff sl seff acc env =
        match seff with
        | [] -&gt; List.rev acc, ce
        | cbs :: rest -&gt;
          if Int.equal sl 0 then
           let env, cbs =
             List.fold_left (fun (env,cbs) eff -&gt;
              let { seff_constant = kn; seff_body = ocb; seff_env = u ; _ } = eff in
               let ce = constant_entry_of_side_effect ocb u in
               let cb = Term_typing.translate_constant Term_typing.Pure env kn ce in
               let eff = { eff with
                seff_body = cb;
                seff_env = <abbr class="mark-warning" title="Variants not supported">`Nothing</abbr>;
               } in
               (push_seff env eff, export_eff eff :: cbs))
             (env,[]) cbs in
           translate_seff 0 rest (cbs @ acc) env
          else
           let cbs_len = List.length cbs in
           let cbs = List.map turn_direct cbs in
           let env = List.fold_left push_seff env cbs in
           let ecbs = List.map export_eff cbs in
           translate_seff (sl - cbs_len) rest (ecbs @ acc) env
     in
       translate_seff trusted seff [] env

let export_private_constants ~in_section ce senv =
  let exported, ce = export_side_effects senv.revstruct senv.env ce in
  let bodies = List.map (fun (kn, cb, _) -&gt; (kn, cb)) exported in
  let exported = List.map (fun (kn, _, r) -&gt; (kn, r)) exported in
  let senv = List.fold_left (add_constant_aux ~in_section) senv bodies in
  (ce, exported), senv

let add_constant ~in_section l decl senv =
  let kn = Constant.make2 senv.modpath l in
  let senv =
    let cb =
      match decl with
      | ConstantEntry (EffectEntry, ce) -&gt;
        let handle env body eff =
          let body, uctx, signatures = inline_side_effects env body eff in
          let trusted = check_signatures senv.revstruct signatures in
          body, uctx, trusted
        in
        Term_typing.translate_constant (Term_typing.SideEffects handle) senv.env kn ce
      | ConstantEntry (PureEntry, ce) -&gt;
        Term_typing.translate_constant Term_typing.Pure senv.env kn ce
      | GlobalRecipe r -&gt;
        Term_typing.translate_recipe senv.env kn r in
    add_constant_aux ~in_section senv (kn, cb) in
  let senv =
    match decl with
    | ConstantEntry (_,(Entries.PrimitiveEntry { Entries.prim_entry_content = CPrimitives.OT_type t; _ })) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if in_section then CErrors.anomaly (Pp.str &quot;Primitive type not allowed in sections&quot;);
      add_retroknowledge (Retroknowledge.Register_type(t,kn)) senv</abbr>
    | _ -&gt; senv
  in
  kn, senv

(** Insertion of inductive types *)

let check_mind mie lab =
  let open Entries in
  match mie.mind_entry_inds with
  | [] -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* empty inductive entry *)
  | oie::_ -&gt;
    (* The label and the first inductive type name should match *)
    <abbr class="mark-warning" title="Assert instruction is not handled.">assert (Id.equal (Label.to_id lab) oie.mind_entry_typename)</abbr>

let add_mind l mie senv =
  let () = check_mind mie l in
  let kn = MutInd.make2 senv.modpath l in
  let mib = Indtypes.check_inductive senv.env kn mie in
  let mib =
    match mib.mind_hyps with [] -&gt; Declareops.hcons_mind mib | _ -&gt; mib
  in
  kn, add_field (l,SFBmind mib) (I kn) senv

(** Insertion of module types *)

let add_modtype l params_mte inl senv =
  let mp = MPdot(senv.modpath, l) in
  let mtb = Mod_typing.translate_modtype senv.env mp inl params_mte  in
  let mtb = Declareops.hcons_module_type mtb in
  let senv' = add_field (l,SFBmodtype mtb) MT senv in
  mp, senv'

(** full_add_module adds module with universes and constraints *)

let full_add_module mb senv =
  let senv = add_constraints (Now (false, mb.mod_constraints)) senv in
  let dp = ModPath.dp mb.mod_mp in
  let linkinfo = Nativecode.link_info_of_dirpath dp in
  { senv with env = Modops.add_linked_module mb linkinfo senv.env }

let full_add_module_type mp mt senv =
  let senv = add_constraints (Now (false, mt.mod_constraints)) senv in
  { senv with env = Modops.add_module_type mp mt senv.env }

(** Insertion of modules *)

let add_module l me inl senv =
  let mp = MPdot(senv.modpath, l) in
  let mb = Mod_typing.translate_module senv.env mp inl me in
  let mb = Declareops.hcons_module_body mb in
  let senv' = add_field (l,SFBmodule mb) M senv in
  let senv'' =
    if Modops.is_functor mb.mod_type then senv'
    else update_resolver (Mod_subst.add_delta_resolver mb.mod_delta) senv'
  in
  (mp,mb.mod_delta),senv''


(** {6 Starting / ending interactive modules and module types } *)

let start_module l senv =
  let () = check_modlabel l senv in
  let () = check_empty_context senv in
  let mp = MPdot(senv.modpath, l) in
  mp,
  { empty_environment with
    env = senv.env;
    modpath = mp;
    modvariant = STRUCT ([],senv);
    required = senv.required }

let start_modtype l senv =
  let () = check_modlabel l senv in
  let () = check_empty_context senv in
  let mp = MPdot(senv.modpath, l) in
  mp,
  { empty_environment with
    env = senv.env;
    modpath = mp;
    modvariant = SIG ([], senv);
    required = senv.required }

(** Adding parameters to the current module or module type.
    This module should have been freshly started. *)

let add_module_parameter mbid mte inl senv =
  let () = check_empty_struct senv in
  let mp = MPbound mbid in
  let mtb = Mod_typing.translate_modtype senv.env mp inl ([],mte) in
  let senv = full_add_module_type mp mtb senv in
  let new_variant = match senv.modvariant with
    | STRUCT (params,oldenv) -&gt; STRUCT ((mbid,mtb) :: params, oldenv)
    | SIG (params,oldenv) -&gt; SIG ((mbid,mtb) :: params, oldenv)
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in
  let new_paramresolver =
    if Modops.is_functor mtb.mod_type then senv.paramresolver
    else Mod_subst.add_delta_resolver mtb.mod_delta senv.paramresolver
  in
  mtb.mod_delta,
  { senv with
    modvariant = new_variant;
    paramresolver = new_paramresolver }

let functorize params init =
  List.fold_left (fun e (mbid,mt) -&gt; MoreFunctor(mbid,mt,e)) init params

let propagate_loads senv =
  List.fold_left
    (fun env (_,mb) -&gt; full_add_module mb env)
    senv
    (List.rev senv.loads)

(** Build the module body of the current module, taking in account
    a possible return type (_:T) *)

let functorize_module params mb =
  let f x = functorize params x in
  { mb with
    mod_expr = Modops.implem_smartmap f f mb.mod_expr;
    mod_type = f mb.mod_type;
    mod_type_alg = Option.map f mb.mod_type_alg }

let build_module_body params restype senv =
  let struc = NoFunctor (List.rev senv.revstruct) in
  let restype' = Option.map (fun (ty,inl) -&gt; (([],ty),inl)) restype in
  let mb =
    Mod_typing.finalize_module senv.env senv.modpath
      (struc,None,senv.modresolver,senv.univ) restype'
  in
  let mb' = functorize_module params mb in
  { mb' with mod_retroknowledge = ModBodyRK senv.local_retroknowledge }

(** Returning back to the old pre-interactive-module environment,
    with one extra component and some updated fields
    (constraints, required, etc) *)

let allow_delayed_constants = ref false

let propagate_senv newdef newenv newresolver senv oldsenv =
  let now_cst, later_cst = List.partition Future.is_val senv.future_cst in
  (* This asserts that after Paral-ITP, standard vo compilation is behaving
   * exctly as before: the same universe constraints are added to modules *)
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not !allow_delayed_constants &amp;&amp; later_cst &lt;&gt; [] then
    CErrors.anomaly ~label:&quot;safe_typing&quot;
      Pp.(str &quot;True Future.t were created for opaque constants even if -async-proofs is off&quot;);
  { oldsenv with
    env = newenv;
    modresolver = newresolver;
    revstruct = newdef::oldsenv.revstruct;
    modlabels = Label.Set.add (fst newdef) oldsenv.modlabels;
    univ =
      List.fold_left (fun acc cst -&gt;
        Univ.ContextSet.union acc (Future.force cst))
      (Univ.ContextSet.union senv.univ oldsenv.univ)
      now_cst;
    future_cst = later_cst @ oldsenv.future_cst;
    (* engagement is propagated to the upper level *)
    engagement = senv.engagement;
    required = senv.required;
    loads = senv.loads@oldsenv.loads;
    local_retroknowledge =
            senv.local_retroknowledge@oldsenv.local_retroknowledge;
    native_symbols = senv.native_symbols}</abbr>

let end_module l restype senv =
  let mp = senv.modpath in
  let params, oldsenv = check_struct senv.modvariant in
  let () = check_current_label l mp in
  let () = check_empty_context senv in
  let mbids = List.rev_map fst params in
  let mb = build_module_body params restype senv in
  let newenv = Environ.set_opaque_tables oldsenv.env (Environ.opaque_tables senv.env) in
  let newenv = set_engagement_opt newenv senv.engagement in
  let senv'=
    propagate_loads { senv with
      env = newenv;
      univ = Univ.ContextSet.union senv.univ mb.mod_constraints} in
  let newenv = Environ.push_context_set ~strict:true mb.mod_constraints senv'.env in
  let newenv = Modops.add_module mb newenv in
  let newresolver =
    if Modops.is_functor mb.mod_type then oldsenv.modresolver
    else Mod_subst.add_delta_resolver mb.mod_delta oldsenv.modresolver
  in
  (mp,mbids,mb.mod_delta),
  propagate_senv (l,SFBmodule mb) newenv newresolver senv' oldsenv

let build_mtb mp sign cst delta =
  { mod_mp = mp;
    mod_expr = ();
    mod_type = sign;
    mod_type_alg = None;
    mod_constraints = cst;
    mod_delta = delta;
    mod_retroknowledge = ModTypeRK }

let end_modtype l senv =
  let mp = senv.modpath in
  let params, oldsenv = check_sig senv.modvariant in
  let () = check_current_label l mp in
  let () = check_empty_context senv in
  let mbids = List.rev_map fst params in
  let newenv = Environ.set_opaque_tables oldsenv.env (Environ.opaque_tables senv.env) in
  let newenv = Environ.push_context_set ~strict:true senv.univ newenv in
  let newenv = set_engagement_opt newenv senv.engagement in
  let senv' = propagate_loads {senv with env=newenv} in
  let auto_tb = functorize params (NoFunctor (List.rev senv.revstruct)) in
  let mtb = build_mtb mp auto_tb senv'.univ senv.modresolver in
  let newenv = Environ.add_modtype mtb senv'.env in
  let newresolver = oldsenv.modresolver in
  (mp,mbids),
  propagate_senv (l,SFBmodtype mtb) newenv newresolver senv' oldsenv

(** {6 Inclusion of module or module type } *)

let add_include me is_module inl senv =
  let open Mod_typing in
  let mp_sup = senv.modpath in
  let sign,(),resolver,cst =
    translate_mse_incl is_module senv.env mp_sup inl me
  in
  let senv = add_constraints (Now (false, cst)) senv in
  (* Include Self support  *)
  let rec compute_sign sign mb resolver senv =
    match sign with
    | MoreFunctor(mbid,mtb,str) -&gt;
      let cst_sub = Subtyping.check_subtypes senv.env mb mtb in
      let senv =
        add_constraints
          (Now (false, Univ.ContextSet.add_constraints cst_sub Univ.ContextSet.empty))
          senv in
      let mpsup_delta =
        Modops.inline_delta_resolver senv.env inl mp_sup mbid mtb mb.mod_delta
      in
      let subst = Mod_subst.map_mbid mbid mp_sup mpsup_delta in
      let resolver = Mod_subst.subst_codom_delta_resolver subst resolver in
      compute_sign (Modops.subst_signature subst str) mb resolver senv
    | NoFunctor str -&gt; resolver,str,senv
  in
  let resolver,str,senv =
    let struc = NoFunctor (List.rev senv.revstruct) in
    let mtb = build_mtb mp_sup struc Univ.ContextSet.empty senv.modresolver in
    compute_sign sign mtb resolver senv
  in
  let senv = update_resolver (Mod_subst.add_delta_resolver resolver) senv
  in
  let add senv ((l,elem) as field) =
    let new_name = match elem with
      | SFBconst _ -&gt;
        C (Mod_subst.constant_of_delta_kn resolver (KerName.make mp_sup l))
      | SFBmind _ -&gt;
        I (Mod_subst.mind_of_delta_kn resolver (KerName.make mp_sup l))
      | SFBmodule _ -&gt; M
      | SFBmodtype _ -&gt; MT
    in
    add_field ~is_include:true field new_name senv
  in
  resolver, List.fold_left add senv str

(** {6 Libraries, i.e. compiled modules } *)

type compiled_library = {
  comp_name : DirPath.t;
  comp_mod : module_body;
  comp_deps : library_info array;
  comp_enga : engagement;
  comp_natsymbs : Nativecode.symbols
}

let module_of_library lib = lib.comp_mod

type native_library = Nativecode.global list

let get_library_native_symbols senv dir =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try DPMap.find dir senv.native_symbols
  with Not_found -&gt; CErrors.user_err ~hdr:&quot;get_library_native_symbols&quot;
                      Pp.((str &quot;Linker error in the native compiler. Are you using Require inside a nested Module declaration?&quot;) ++ fnl () ++
                          (str &quot;This use case is not supported, but disabling the native compiler may help.&quot;))</abbr>

(** FIXME: MS: remove?*)
let current_modpath senv = senv.modpath
let current_dirpath senv = Names.ModPath.dp (current_modpath senv)

let start_library dir senv =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_initial senv;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (not (DirPath.is_empty dir));
  let mp = MPfile dir in
  mp,
  { empty_environment with
    env = senv.env;
    modpath = mp;
    modvariant = LIBRARY;
    required = senv.required }</abbr>

let export ?except ~output_native_objects senv dir =
  let senv =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try join_safe_environment ?except senv
    with e -&gt;
      let e = CErrors.push e in
      CErrors.user_err ~hdr:&quot;export&quot; (CErrors.iprint e)</abbr>
  in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert(senv.future_cst = []);
  let () = check_current_library dir senv in
  let mp = senv.modpath in
  let str = NoFunctor (List.rev senv.revstruct) in
  let mb =
    { mod_mp = mp;
      mod_expr = FullStruct;
      mod_type = str;
      mod_type_alg = None;
      mod_constraints = senv.univ;
      mod_delta = senv.modresolver;
      mod_retroknowledge = ModBodyRK senv.local_retroknowledge
    }
  in
  let ast, symbols =
    if output_native_objects then
      Nativelibrary.dump_library mp dir senv.env str
    else [], Nativecode.empty_symbols
  in
  let lib = {
    comp_name = dir;
    comp_mod = mb;
    comp_deps = Array.of_list (DPMap.bindings senv.required);
    comp_enga = Environ.engagement senv.env;
    comp_natsymbs = symbols }
  in
  mp, lib, ast</abbr>

(* cst are the constraints that were computed by the vi2vo step and hence are
 * not part of the mb.mod_constraints field (but morally should be) *)
let import lib cst vodigest senv =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_required senv.required lib.comp_deps;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_engagement senv.env lib.comp_enga;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if DirPath.equal (ModPath.dp senv.modpath) lib.comp_name then
    CErrors.user_err ~hdr:&quot;Safe_typing.import&quot;
     (Pp.strbrk &quot;Cannot load a library with the same name as the current one.&quot;);
  let mp = MPfile lib.comp_name in
  let mb = lib.comp_mod in
  let env = Environ.push_context_set ~strict:true
                                     (Univ.ContextSet.union mb.mod_constraints cst)
                                     senv.env
  in
  mp,
  { senv with
    env =
      (let linkinfo =
         Nativecode.link_info_of_dirpath lib.comp_name
       in
       Modops.add_linked_module mb linkinfo env);
    modresolver = Mod_subst.add_delta_resolver mb.mod_delta senv.modresolver;
    required = DPMap.add lib.comp_name vodigest senv.required;
    loads = (mp,mb)::senv.loads;
    native_symbols = DPMap.add lib.comp_name lib.comp_natsymbs senv.native_symbols }</abbr>

(** {6 Safe typing } *)

type judgment = Environ.unsafe_judgment

let j_val j = j.Environ.uj_val
let j_type j = j.Environ.uj_type

let typing senv = Typeops.infer (env_of_senv senv)

(** {6 Retroknowledge / native compiler } *)

let register_inline kn senv =
  let open Environ in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if not (evaluable_constant kn senv.env) then
    CErrors.user_err Pp.(str &quot;Register inline: an evaluable constant is expected&quot;);
  let env = senv.env in
  let cb = lookup_constant kn env in
  let cb = {cb with const_inline_code = true} in
  let env = add_constant kn cb env in { senv with env}</abbr>

let check_register_ind ind r env =
  let (mb,ob as spec) = Inductive.lookup_mind_specif env ind in
  let check_if b msg =
    if not b then
      CErrors.user_err ~hdr:&quot;check_register_ind&quot; msg in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (Int.equal (Array.length mb.mind_packets) 1) Pp.(str &quot;A non mutual inductive is expected&quot;);
  let is_monomorphic = function Monomorphic _ -&gt; true | Polymorphic _ -&gt; false in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (is_monomorphic mb.mind_universes) Pp.(str &quot;A universe monomorphic inductive type is expected&quot;);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (not @@ Inductive.is_private spec) Pp.(str &quot;A non-private inductive type is expected&quot;);
  let check_nparams n =
    check_if (Int.equal mb.mind_nparams n) Pp.(str &quot;An inductive type with &quot; ++ int n ++ str &quot; parameters is expected&quot;)
  in
  let check_nconstr n =
    check_if (Int.equal (Array.length ob.mind_consnames) n)
      Pp.(str &quot;an inductive type with &quot; ++ int n ++ str &quot; constructors is expected&quot;)
  in
  let check_name pos s =
    check_if (Id.equal ob.mind_consnames.(pos) (Id.of_string s))
      Pp.(str&quot;the &quot; ++ int (pos + 1) ++ str
       &quot;th constructor does not have the expected name: &quot; ++ str s) in
  let check_type pos t =
    check_if (Constr.equal t ob.mind_user_lc.(pos))
      Pp.(str&quot;the &quot; ++ int (pos + 1) ++ str
       &quot;th constructor does not have the expected type&quot;) in
  let check_type_cte pos = check_type pos (Constr.mkRel 1) in
  match r with
  | CPrimitives.PIT_bool -&gt;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nparams 0;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nconstr 2;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 0 &quot;true&quot;;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_type_cte 0;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 1 &quot;false&quot;;
    check_type_cte 1</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  | CPrimitives.PIT_carry -&gt;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nparams 1;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nconstr 2;
    let test_type pos =
      let c = ob.mind_user_lc.(pos) in
      let s = Pp.(str&quot;the &quot; ++ int (pos + 1) ++ str
              &quot;th constructor does not have the expected type&quot;) in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (Constr.isProd c) s;
      let (_,d,cd) = Constr.destProd c in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (Constr.is_Type d) s;
      check_if
        (Constr.equal
                (mkProd (Context.anonR,mkRel 1, mkApp (mkRel 3,</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|mkRel 2|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">)))
                cd)
        s</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 0 &quot;C0&quot;;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">test_type 0;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 1 &quot;C1&quot;;
    test_type 1;</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  | CPrimitives.PIT_pair -&gt;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nparams 2;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nconstr 1;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 0 &quot;pair&quot;;
    let c = ob.mind_user_lc.(0) in
    let s =  Pp.str &quot;the constructor does not have the expected type&quot; in
    begin match Term.decompose_prod c with
      | ([_,b;_,a;_,_B;_,_A], codom) -&gt;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (is_Type _A) s;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (is_Type _B) s;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (Constr.equal a (mkRel 2)) s;
        </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_if (Constr.equal b (mkRel 2)) s;
        check_if (Constr.equal codom (mkApp (mkRel 5,</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|mkRel 4; mkRel 3|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">))) s</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
      | _ -&gt; check_if false s
    end</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  | CPrimitives.PIT_cmp -&gt;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nparams 0;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_nconstr 3;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 0 &quot;Eq&quot;;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_type_cte 0;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 1 &quot;Lt&quot;;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_type_cte 1;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_name 2 &quot;Gt&quot;;
    check_type_cte 2</abbr>

let register_inductive ind prim senv =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_register_ind ind prim senv.env;
  let action = Retroknowledge.Register_ind(prim,ind) in
  add_retroknowledge action senv</abbr>

let add_constraints c =
  add_constraints
    (Now (false, Univ.ContextSet.add_constraints c Univ.ContextSet.empty))


(* NB: The next old comment probably refers to [propagate_loads] above.
   When a Require is done inside a module, we'll redo this require
   at the upper level after the module is ended, and so on.
   This is probably not a big deal anyway, since these Require's
   inside modules should be pretty rare. Maybe someday we could
   brutally forbid this tricky &quot;feature&quot;... *)

(* we have an inefficiency: Since loaded files are added to the
environment every time a module is closed, their components are
calculated many times. This could be avoided in several ways:

1 - for each file create a dummy environment containing only this
file's components, merge this environment with the global
environment, and store for the future (instead of just its type)

2 - create &quot;persistent modules&quot; environment table in Environ add put
loaded by side-effect once and for all (like it is done in OCaml).
Would this be correct with respect to undo's and stuff ?
*)

let set_strategy k l e = { e with env =
   (Environ.set_oracle e.env
      (Conv_oracle.set_strategy (Environ.oracle e.env) k l)) }
</pre>
  </div>
  <div class="col-md-6">
    <a href="#safe_typing.ml"><code>Safe_typing.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Declarations.

Import Constr.

Import Context.Named.Declaration.

Module NamedDecl := Context.Named.Declaration.

Inductive vodigest : Set :=
| Dvo_or_vi : Stdlib.Digest.t -&gt; vodigest
| Dvivo : Stdlib.Digest.t -&gt; Stdlib.Digest.t -&gt; vodigest.

Definition digest_match (actual : vodigest) (required : vodigest) : bool :=
  match (actual, required) with
  | (Dvo_or_vi d1, Dvo_or_vi d2) | (Dvivo d1 _, Dvo_or_vi d2) =&gt;
    (|Util.String|).(CString.ExtS.equal) d1 d2
  | (Dvivo d1 e1, Dvivo d2 e2) =&gt;
    andb ((|Util.String|).(CString.ExtS.equal) d1 d2)
      ((|Util.String|).(CString.ExtS.equal) e1 e2)
  | (Dvo_or_vi _, Dvivo _ _) =&gt; false
  end.

Definition library_info := Names.DirPath.t * vodigest.

Definition module_parameters :=
  list (Names.MBId.t * Declarations.module_type_body).

Definition DPMap :=
  Map.Make
    (existT _ _
      {|
        Stdlib__map.OrderedType.compare := Names.DirPath.compare
      |}).

Reserved Notation &quot;'safe_environment&quot;.

Module safe_environment.
  Record record {env modpath modvariant modresolver paramresolver revstruct
    modlabels objlabels univ future_cst engagement required loads
    local_retroknowledge native_symbols : Set} := {
    env : env;
    modpath : modpath;
    modvariant : modvariant;
    modresolver : modresolver;
    paramresolver : paramresolver;
    revstruct : revstruct;
    modlabels : modlabels;
    objlabels : objlabels;
    univ : univ;
    future_cst : future_cst;
    engagement : engagement;
    required : required;
    loads : loads;
    local_retroknowledge : local_retroknowledge;
    native_symbols : native_symbols }.
  Arguments record : clear implicits.
  Definition with_env
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) env
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_modpath
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) modpath
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_modvariant
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) modvariant
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_modresolver
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) modresolver
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_paramresolver
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) paramresolver
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_revstruct
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) revstruct
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_modlabels
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) modlabels
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_objlabels
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) objlabels
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_univ
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) univ
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_future_cst
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) future_cst
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_engagement
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) engagement
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_required
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) required
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_loads
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) loads
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols r |}.
  Definition with_local_retroknowledge
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) local_retroknowledge
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge;
      native_symbols := native_symbols r |}.
  Definition with_native_symbols
    {env_type modpath_type modvariant_type modresolver_type paramresolver_type
      revstruct_type modlabels_type objlabels_type univ_type future_cst_type
      engagement_type required_type loads_type local_retroknowledge_type
      native_symbols_type : Set}
    (r :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type) native_symbols
    :
      record env_type modpath_type modvariant_type modresolver_type
        paramresolver_type revstruct_type modlabels_type objlabels_type
        univ_type future_cst_type engagement_type required_type loads_type
        local_retroknowledge_type native_symbols_type :=
    {| env := env r; modpath := modpath r; modvariant := modvariant r;
      modresolver := modresolver r; paramresolver := paramresolver r;
      revstruct := revstruct r; modlabels := modlabels r;
      objlabels := objlabels r; univ := univ r; future_cst := future_cst r;
      engagement := engagement r; required := required r; loads := loads r;
      local_retroknowledge := local_retroknowledge r;
      native_symbols := native_symbols |}.
End safe_environment.
Definition safe_environment_skeleton := safe_environment.record.

Inductive modvariant : Set :=
| NONE : modvariant
| LIBRARY : modvariant
| SIG : module_parameters -&gt; 'safe_environment -&gt; modvariant
| STRUCT : module_parameters -&gt; 'safe_environment -&gt; modvariant

where &quot;'safe_environment&quot; :=
  (safe_environment_skeleton Environ.env Names.ModPath.t modvariant
    Mod_subst.delta_resolver Mod_subst.delta_resolver
    Declarations.structure_body Names.Label.__Set.t Names.Label.__Set.t
    Univ.ContextSet.t (list (Future.computation Univ.ContextSet.t))
    (option Declarations.engagement) (DPMap.t vodigest)
    (list (Names.ModPath.t * Declarations.module_body))
    (list Retroknowledge.action) (DPMap.t Nativecode.symbols)).

Definition safe_environment := 'safe_environment.

Fixpoint library_dp_of_senv (senv : safe_environment) {struct senv}
  : Names.DirPath.t :=
  match safe_environment.modvariant senv with
  | NONE | LIBRARY =&gt; ModPath.dp (safe_environment.modpath senv)
  | SIG _ senv =&gt; library_dp_of_senv senv
  | STRUCT _ senv =&gt; library_dp_of_senv senv
  end.

Definition empty_environment : safe_environment :=
  {| safe_environment.env := Environ.empty_env;
    safe_environment.modpath := ModPath.initial;
    safe_environment.modvariant := NONE;
    safe_environment.modresolver := Mod_subst.empty_delta_resolver;
    safe_environment.paramresolver := Mod_subst.empty_delta_resolver;
    safe_environment.revstruct := [];
    safe_environment.modlabels := Label.__Set.empty;
    safe_environment.objlabels := Label.__Set.empty;
    safe_environment.univ := Univ.ContextSet.empty;
    safe_environment.future_cst := []; safe_environment.engagement := None;
    safe_environment.required := DPMap.empty; safe_environment.loads := [];
    safe_environment.local_retroknowledge := [];
    safe_environment.native_symbols := DPMap.empty |}.

Definition is_initial (senv : safe_environment) : bool :=
  match ((safe_environment.revstruct senv), (safe_environment.modvariant senv))
    with
  | ([], NONE) =&gt; ModPath.equal (safe_environment.modpath senv) ModPath.initial
  | _ =&gt; false
  end.

Definition delta_of_senv (senv : safe_environment)
  : Mod_subst.delta_resolver * Mod_subst.delta_resolver :=
  ((safe_environment.modresolver senv), (safe_environment.paramresolver senv)).

Definition constant_of_delta_kn_senv
  (senv : safe_environment) (kn : Names.KerName.t) : Names.Constant.t :=
  Mod_subst.constant_of_deltas_kn (safe_environment.paramresolver senv)
    (safe_environment.modresolver senv) kn.

Definition mind_of_delta_kn_senv
  (senv : safe_environment) (kn : Names.KerName.t) : Names.MutInd.t :=
  Mod_subst.mind_of_deltas_kn (safe_environment.paramresolver senv)
    (safe_environment.modresolver senv) kn.

Definition safe_transformer0 := safe_environment -&gt; safe_environment.

Definition safe_transformer (a : Set) :=
  safe_environment -&gt; a * safe_environment.

Definition set_engagement_opt
  (env : Environ.env) (function_parameter : option Declarations.engagement)
  : Environ.env :=
  match function_parameter with
  | Some c =&gt; Environ.set_engagement c env
  | None =&gt; env
  end.

Definition set_engagement
  (c : Declarations.engagement) (senv : safe_environment) : safe_environment :=
  safe_environment.with_engagement
    (safe_environment.with_env senv
      (Environ.set_engagement c (safe_environment.env senv))) (Some c).

Definition set_typing_flags
  (c : Declarations.typing_flags) (senv : safe_environment)
  : safe_environment :=
  let env := Environ.set_typing_flags c (safe_environment.env senv) in
  if Stdlib.op_eqeq env (safe_environment.env senv) then
    senv
  else
    safe_environment.with_env senv env.

Definition set_indices_matter (indices_matter : bool) (senv : safe_environment)
  : safe_environment :=
  set_typing_flags
    (Declarations.typing_flags.with_indices_matter
      (Environ.typing_flags (safe_environment.env senv)) indices_matter) senv.

Definition set_share_reduction (b : bool) (senv : safe_environment)
  : safe_environment :=
  let flags := Environ.typing_flags (safe_environment.env senv) in
  set_typing_flags (Declarations.typing_flags.with_share_reduction flags b) senv.

Definition set_VM (b : bool) (senv : safe_environment) : safe_environment :=
  let flags := Environ.typing_flags (safe_environment.env senv) in
  set_typing_flags (Declarations.typing_flags.with_enable_VM flags b) senv.

Definition set_native_compiler (b : bool) (senv : safe_environment)
  : safe_environment :=
  let flags := Environ.typing_flags (safe_environment.env senv) in
  set_typing_flags
    (Declarations.typing_flags.with_enable_native_compiler flags b) senv.

Definition make_sprop_cumulative (senv : safe_environment) : safe_environment :=
  safe_environment.with_env senv
    (Environ.make_sprop_cumulative (safe_environment.env senv)).

Definition set_allow_sprop (b : bool) (senv : safe_environment)
  : safe_environment :=
  safe_environment.with_env senv
    (Environ.set_allow_sprop b (safe_environment.env senv)).

Definition check_engagement
  (env : Environ.env)
  (expected_impredicative_set : Declarations.set_predicativity) : unit :=
  let impredicative_set := Environ.engagement env in
  match (impredicative_set, expected_impredicative_set) with
  | (Declarations.PredicativeSet, Declarations.ImpredicativeSet) =&gt;
    CErrors.user_err None None (str &quot;Needs option -impredicative-set.&quot;)
  | _ =&gt; tt
  end.

Definition get_opaque_body
  (env : Environ.env) (cbo : Declarations.constant_body)
  : (* `Nothing *) unit :=
  match Declarations.constant_body.const_body cbo with
  | Declarations.Undef _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Declarations.Primitive _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Declarations.Def _ =&gt;
    (* ❌ Variants not supported *)
    (* ❌ `Nothing *)
    Nothing
  | Declarations.OpaqueDef opaque =&gt;
    (* ❌ Variants not supported *)
    (* ❌ `Opaque *)
    Opaque
      ((Opaqueproof.force_proof (Environ.opaque_tables env) opaque),
        (Opaqueproof.force_constraints (Environ.opaque_tables env) opaque))
  end.

Module side_effect.
  Record record := {
    from_env : CEphemeron.key Declarations.structure_body;
    eff : list Entries.side_eff }.
  Definition with_from_env (r : record) from_env : record :=
    {| from_env := from_env; eff := eff r |}.
  Definition with_eff (r : record) eff : record :=
    {| from_env := from_env r; eff := eff |}.
End side_effect.
Definition side_effect := side_effect.record.

Module SideEffects.
  Definition SeffOrd :=
    (* ❌ open *)
    let t := side_effect in
    let compare (e1 : side_effect) (e2 : side_effect) : Z :=
      let cmp (e1 : Entries.side_eff) (e2 : Entries.side_eff) : Z :=
        Constant.CanOrd.compare (Entries.side_eff.seff_constant e1)
          (Entries.side_eff.seff_constant e2) in
      (|Util.List|).(CList.ExtS.compare) cmp (side_effect.eff e1)
        (side_effect.eff e2) in
    existT (fun _ =&gt; _) tt
      {|
        Stdlib__map.OrderedType.compare := compare
      |}.
  
  Definition SeffSet :=
    __Set.Make
      (existT _ _
        {|
          Stdlib__map.OrderedType.compare :=
            (|SeffOrd|).(Stdlib__map.OrderedType.compare)
        |}).
  
  Module t.
    Record record := {
      seff : list side_effect;
      elts : SeffSet.t }.
    Definition with_seff (r : record) seff : record :=
      {| seff := seff; elts := elts r |}.
    Definition with_elts (r : record) elts : record :=
      {| seff := seff r; elts := elts |}.
  End t.
  Definition t := t.record.
  
  Definition repr (eff : t) : list side_effect := t.seff eff.
  
  Definition empty : t := {| t.seff := []; t.elts := SeffSet.empty |}.
  
  Definition add (x : SeffSet.elt) (es : t) : t :=
    if SeffSet.mem x (t.elts es) then
      es
    else
      {| t.seff := cons x (t.seff es); t.elts := SeffSet.add x (t.elts es) |}.
  
  Definition concat (xes : t) (yes : t) : t :=
    (|Util.List|).(CList.ExtS.fold_right) add (t.seff xes) yes.
End SideEffects.

Definition private_constants := SideEffects.t.

Definition side_effects_of_private_constants (l : SideEffects.t)
  : list Entries.side_eff :=
  let ans := (|Util.List|).(CList.ExtS.rev) (SideEffects.repr l) in
  (|Util.List|).(CList.ExtS.map_append)
    (fun function_parameter =&gt;
      let '{| side_effect.eff := eff |} := function_parameter in
      eff) ans.

Definition empty_private_constants : SideEffects.t := SideEffects.empty.

Definition add_private
  (mb : Declarations.structure_body) (eff : list Entries.side_eff)
  (effs : SideEffects.t) : SideEffects.t :=
  let from_env := CEphemeron.create mb in
  SideEffects.add {| side_effect.from_env := from_env; side_effect.eff := eff |}
    effs.

Definition concat_private : SideEffects.t -&gt; SideEffects.t -&gt; SideEffects.t :=
  SideEffects.concat.

Definition make_eff
  (env : safe_environment) (cst : Names.Constant.t)
  (r : Entries.side_effect_role) : Entries.side_eff :=
  let cbo := Environ.lookup_constant cst (safe_environment.env env) in
  {| Entries.side_eff.seff_constant := cst; Entries.side_eff.seff_body := cbo;
    Entries.side_eff.seff_env := get_opaque_body (safe_environment.env env) cbo;
    Entries.side_eff.seff_role := r |}.

Definition private_con_of_con (env : safe_environment) (c : Names.Constant.t)
  : SideEffects.t :=
  let eff := [ make_eff env c Entries.Subproof ] in
  add_private (safe_environment.revstruct env) eff empty_private_constants.

Definition private_con_of_scheme
  (kind : string) (env : safe_environment)
  (cl : list (Names.inductive * Names.Constant.t)) : SideEffects.t :=
  let eff :=
    (|Util.List|).(CList.ExtS.map)
      (fun function_parameter =&gt;
        let '(i, c) := function_parameter in
        make_eff env c (Entries.Schema i kind)) cl in
  add_private (safe_environment.revstruct env) eff empty_private_constants.

Definition universes_of_private (eff : SideEffects.t)
  : list Univ.ContextSet.t :=
  let fold (acc : list Univ.ContextSet.t) (eff : Entries.side_eff)
    : list Univ.ContextSet.t :=
    let acc :=
      match Entries.side_eff.seff_env eff with
      | Nothing =&gt; acc
      | Opaque (_, ctx) =&gt; cons ctx acc
      end in
    match
      Declarations.constant_body.const_universes
        (Entries.side_eff.seff_body eff) with
    | Declarations.Monomorphic ctx =&gt; cons ctx acc
    | Declarations.Polymorphic _ =&gt; acc
    end in
  (|Util.List|).(CList.ExtS.fold_left) fold []
    (side_effects_of_private_constants eff).

Definition env_of_safe_env (senv : safe_environment) : Environ.env :=
  safe_environment.env senv.

Definition env_of_senv : safe_environment -&gt; Environ.env := env_of_safe_env.

Inductive constraints_addition : Set :=
| Now : bool -&gt; Univ.ContextSet.t -&gt; constraints_addition
| Later : Future.computation Univ.ContextSet.t -&gt; constraints_addition.

Definition add_constraints
  (cst : constraints_addition) (senv : safe_environment) : safe_environment :=
  match cst with
  | Later fc =&gt;
    safe_environment.with_future_cst senv
      (cons fc (safe_environment.future_cst senv))
  | Now poly cst =&gt;
    safe_environment.with_univ
      (safe_environment.with_env senv
        (Environ.push_context_set (Some (negb poly)) cst
          (safe_environment.env senv)))
      (Univ.ContextSet.union cst (safe_environment.univ senv))
  end.

Definition add_constraints_list
  (cst : list constraints_addition) (senv : safe_environment)
  : safe_environment :=
  (|Util.List|).(CList.ExtS.fold_left)
    (fun acc =&gt; fun c =&gt; add_constraints c acc) senv cst.

Definition push_context_set (poly : bool) (ctx : Univ.ContextSet.t)
  : safe_environment -&gt; safe_environment := add_constraints (Now poly ctx).

Definition is_curmod_library (senv : safe_environment) : bool :=
  match safe_environment.modvariant senv with
  | LIBRARY =&gt; true
  | _ =&gt; false
  end.

Definition join_safe_environment (op_staroptstar : option Future.UUIDSet.t)
  : safe_environment -&gt; safe_environment :=
  let except :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; Future.UUIDSet.empty
    end in
  fun e =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Util.List|).(CList.ExtS.fold_left)
      (fun e =&gt;
        fun fc =&gt;
          if Future.UUIDSet.mem (Future.uuid fc) except then
            e
          else
            add_constraints (Now false (Future.join fc)) e)
      (safe_environment.with_future_cst e []) (safe_environment.future_cst e).

Definition is_joined_environment (e : safe_environment) : bool :=
  (|Util.List|).(CList.ExtS.is_empty) (safe_environment.future_cst e).

Definition exists_modlabel (l : Names.Label.__Set.elt) (senv : safe_environment)
  : bool := Label.__Set.mem l (safe_environment.modlabels senv).

Definition exists_objlabel (l : Names.Label.__Set.elt) (senv : safe_environment)
  : bool := Label.__Set.mem l (safe_environment.objlabels senv).

Definition check_modlabel (l : Names.Label.__Set.elt) (senv : safe_environment)
  : unit :=
  if exists_modlabel l senv then
    Modops.error_existing_label l
  else
    tt.

Definition check_objlabel (l : Names.Label.__Set.elt) (senv : safe_environment)
  : unit :=
  if exists_objlabel l senv then
    Modops.error_existing_label l
  else
    tt.

Definition check_objlabels (ls : Names.Label.__Set.t) (senv : safe_environment)
  : unit := Label.__Set.iter (fun l =&gt; check_objlabel l senv) ls.

Definition check_current_label
  (lab : Names.Label.t) (function_parameter : Names.module_path) : unit :=
  match function_parameter with
  | Names.MPdot _ l =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert (Label.equal lab l)
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition check_struct (function_parameter : modvariant)
  : module_parameters * safe_environment :=
  match function_parameter with
  | STRUCT params oldsenv =&gt; (params, oldsenv)
  | NONE | LIBRARY | SIG _ _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition check_sig (function_parameter : modvariant)
  : module_parameters * safe_environment :=
  match function_parameter with
  | SIG params oldsenv =&gt; (params, oldsenv)
  | NONE | LIBRARY | STRUCT _ _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition check_current_library
  (dir : Names.DirPath.t) (senv : safe_environment) : unit :=
  match safe_environment.modvariant senv with
  | LIBRARY =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert (ModPath.equal (safe_environment.modpath senv) (Names.MPfile dir))
  | NONE | STRUCT _ _ | SIG _ _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition check_empty_context (senv : safe_environment) : unit :=
  (* ❌ Assert instruction is not handled. *)
  assert (Environ.empty_context (safe_environment.env senv)).

Definition check_empty_struct (senv : safe_environment) : unit :=
  (* ❌ Assert instruction is not handled. *)
  assert
    (andb
      ((|Util.List|).(CList.ExtS.is_empty) (safe_environment.revstruct senv))
      ((|Util.List|).(CList.ExtS.is_empty) (safe_environment.loads senv))).

Definition check_initial (senv : safe_environment) : unit :=
  (* ❌ Assert instruction is not handled. *)
  assert (is_initial senv).

Definition check_required
  (current_libs : DPMap.t vodigest) (needed : array (DPMap.key * vodigest))
  : unit :=
  let check (function_parameter : DPMap.key * vodigest) : unit :=
    let '(id, required) := function_parameter in
    (* ❌ Try-with are not handled *)
    try
      (let actual := DPMap.find id current_libs in
      if negb (digest_match actual required) then
        CErrors.user_err None None
          (pr_sequence str
            [ &quot;Inconsistent assumptions over module&quot;; DirPath.to_string id; &quot;.&quot; ])
      else
        tt) in
  (|Util.Array|).(CArray.ExtS.iter) check needed.

Definition safe_push_named
  (d : NamedDecl.pt Constr.constr Constr.types) (env : Environ.env)
  : Environ.env :=
  let id := NamedDecl.get_id d in
  let '_ :=
    (* ❌ Try-with are not handled *)
    try
      (let '_ := Environ.lookup_named id env in
      CErrors.user_err None None
        (pr_sequence str [ &quot;Identifier&quot;; Id.to_string id; &quot;already defined.&quot; ]))
    in
  Environ.push_named d env.

Definition push_named_def
  (function_parameter : Names.Id.t * Entries.section_def_entry)
  : safe_environment -&gt; safe_environment :=
  let '(id, de) := function_parameter in
  fun senv =&gt;
    let '(c, r, typ) :=
      Term_typing.translate_local_def (safe_environment.env senv) id de in
    let x := Context.make_annot id r in
    let env'' :=
      safe_push_named (Context.Named.Declaration.LocalDef x c typ)
        (safe_environment.env senv) in
    safe_environment.with_env senv env''.

Definition push_named_assum
  (function_parameter : (Names.Id.t * Constr.types * bool) * Univ.ContextSet.t)
  : safe_environment -&gt; safe_environment :=
  let '((id, t, poly), ctx) := function_parameter in
  fun senv =&gt;
    let senv' := push_context_set poly ctx senv in
    let '(t, r) :=
      Term_typing.translate_local_assum (safe_environment.env senv') t in
    let x := Context.make_annot id r in
    let env'' :=
      safe_push_named (Context.Named.Declaration.LocalAssum x t)
        (safe_environment.env senv') in
    safe_environment.with_env senv' env''.

Definition labels_of_mib (mib : Declarations.mutual_inductive_body)
  : Names.Label.__Set.t :=
  let '(add, get) :=
    let labels := Stdlib.__ref_value Label.__Set.empty in
    ((fun id =&gt;
      Stdlib.op_coloneq labels
        (Label.__Set.add (Label.of_id id) (Stdlib.op_exclamation labels))),
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Stdlib.op_exclamation labels)) in
  let visit_mip (mip : Declarations.one_inductive_body) : unit :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Util.Array|).(CArray.ExtS.iter) add
      (Declarations.one_inductive_body.mind_consnames mip) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  get tt.

Definition globalize_constant_universes
  (env : Environ.env) (cb : Declarations.constant_body)
  : list constraints_addition :=
  match Declarations.constant_body.const_universes cb with
  | Declarations.Monomorphic cstrs =&gt;
    cons (Now false cstrs)
      match Declarations.constant_body.const_body cb with
      | Declarations.Undef _ | Declarations.Def _ | Declarations.Primitive _ =&gt;
        []
      | Declarations.OpaqueDef lc =&gt;
        match Opaqueproof.get_constraints (Environ.opaque_tables env) lc with
        | None =&gt; []
        | Some fc =&gt;
          match Future.peek_val fc with
          | None =&gt; [ Later fc ]
          | Some c =&gt; [ Now false c ]
          end
        end
      end
  | Declarations.Polymorphic _ =&gt; [ Now true Univ.ContextSet.empty ]
  end.

Definition globalize_mind_universes (mb : Declarations.mutual_inductive_body)
  : list constraints_addition :=
  match Declarations.mutual_inductive_body.mind_universes mb with
  | Declarations.Monomorphic ctx =&gt; [ Now false ctx ]
  | Declarations.Polymorphic _ =&gt; [ Now true Univ.ContextSet.empty ]
  end.

Definition constraints_of_sfb
  (env : Environ.env) (sfb : Declarations.structure_field_body)
  : list constraints_addition :=
  match sfb with
  | Declarations.SFBconst cb =&gt; globalize_constant_universes env cb
  | Declarations.SFBmind mib =&gt; globalize_mind_universes mib
  | Declarations.SFBmodtype mtb =&gt;
    [ Now false (Declarations.generic_module_body.mod_constraints mtb) ]
  | Declarations.SFBmodule mb =&gt;
    [ Now false (Declarations.generic_module_body.mod_constraints mb) ]
  end.

Definition add_retroknowledge
  (pttc : Retroknowledge.action) (senv : safe_environment) : safe_environment :=
  safe_environment.with_local_retroknowledge
    (safe_environment.with_env senv
      (Primred.add_retroknowledge (safe_environment.env senv) pttc))
    (cons pttc (safe_environment.local_retroknowledge senv)).

Inductive generic_name : Set :=
| C : Names.Constant.t -&gt; generic_name
| I : Names.MutInd.t -&gt; generic_name
| M : generic_name
| MT : generic_name.

Definition add_field (op_staroptstar : option bool)
  : Names.Label.__Set.elt * Declarations.structure_field_body -&gt; generic_name -&gt;
  safe_environment -&gt; safe_environment :=
  let is_include :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun function_parameter =&gt;
    let '(l, sfb) as field := function_parameter in
    fun gn =&gt;
      fun senv =&gt;
        let '(mlabs, olabs) :=
          match sfb with
          | Declarations.SFBmind mib =&gt;
            let l := labels_of_mib mib in
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            (Label.__Set.empty, l)
          | Declarations.SFBconst _ =&gt;
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            (Label.__Set.empty, (Label.__Set.singleton l))
          | Declarations.SFBmodule _ | Declarations.SFBmodtype _ =&gt;
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            ((Label.__Set.singleton l), Label.__Set.empty)
          end in
        let senv :=
          if is_include then
            senv
          else
            let cst := constraints_of_sfb (safe_environment.env senv) sfb in
            add_constraints_list cst senv in
        let env' :=
          match (sfb, gn) with
          | (Declarations.SFBconst cb, C con) =&gt;
            Environ.add_constant con cb (safe_environment.env senv)
          | (Declarations.SFBmind mib, I mind) =&gt;
            Environ.add_mind mind mib (safe_environment.env senv)
          | (Declarations.SFBmodtype mtb, MT) =&gt;
            Environ.add_modtype mtb (safe_environment.env senv)
          | (Declarations.SFBmodule mb, M) =&gt;
            Modops.add_module mb (safe_environment.env senv)
          | _ =&gt;
            (* ❌ Assert instruction is not handled. *)
            assert false
          end in
        safe_environment.with_objlabels
          (safe_environment.with_modlabels
            (safe_environment.with_revstruct
              (safe_environment.with_env senv env')
              (cons field (safe_environment.revstruct senv)))
            (Label.__Set.union mlabs (safe_environment.modlabels senv)))
          (Label.__Set.union olabs (safe_environment.objlabels senv)).

Definition update_resolver
  (f : Mod_subst.delta_resolver -&gt; Mod_subst.delta_resolver)
  (senv : safe_environment) : safe_environment :=
  safe_environment.with_modresolver senv (f (safe_environment.modresolver senv)).

Reserved Notation &quot;'effect_entry&quot;.

Inductive effect_entry_gadt : Set :=
| EffectEntry : effect_entry_gadt
| PureEntry : effect_entry_gadt

where &quot;'effect_entry&quot; := (fun (a : Set) =&gt; effect_entry_gadt).

Definition effect_entry := 'effect_entry.

Reserved Notation &quot;'global_declaration&quot;.

Inductive global_declaration_gadt : Set :=
| ConstantEntry : forall {a : Set},
  effect_entry a -&gt; Entries.constant_entry a -&gt; global_declaration_gadt
| GlobalRecipe : Cooking.recipe -&gt; global_declaration_gadt

where &quot;'global_declaration&quot; := (global_declaration_gadt).

Definition global_declaration := 'global_declaration.

Definition exported_private_constant :=
  Names.Constant.t * Entries.side_effect_role.

Definition add_constant_aux
  (in_section : bool) (senv : safe_environment)
  (function_parameter : Names.Constant.t * Declarations.constant_body)
  : safe_environment :=
  let '(kn, cb) := function_parameter in
  let l := Constant.label kn in
  let cb :=
    if in_section then
      cb
    else
      Declareops.hcons_const_body cb in
  let '(cb, otab) :=
    match
      ((Declarations.constant_body.const_body cb),
        match Declarations.constant_body.const_body cb with
        | Declarations.OpaqueDef lc =&gt; negb in_section
        | _ =&gt; false
        end) with
    | (Declarations.OpaqueDef lc, true) =&gt;
      let '(od, otab) :=
        Opaqueproof.turn_indirect (library_dp_of_senv senv) lc
          (Environ.opaque_tables (safe_environment.env senv)) in
      ((Declarations.constant_body.with_const_body cb
        (Declarations.OpaqueDef od)), otab)
    | (_, _) =&gt; (cb, (Environ.opaque_tables (safe_environment.env senv)))
    end in
  let senv :=
    safe_environment.with_env senv
      (Environ.set_opaque_tables (safe_environment.env senv) otab) in
  let senv' := add_field None (l, (Declarations.SFBconst cb)) (C kn) senv in
  let senv'' :=
    match Declarations.constant_body.const_body cb with
    | Declarations.Undef (Some lev) =&gt;
      update_resolver
        (Mod_subst.add_inline_delta_resolver (Constant.user kn) (lev, None))
        senv'
    | _ =&gt; senv'
    end in
  senv''.

Definition mk_pure_proof {A : Set} (c : A)
  : (A * Univ.ContextSet.t) * SideEffects.t :=
  ((c, Univ.ContextSet.empty), SideEffects.empty).

Definition inline_side_effects
  (env : Environ.env) (body : Constr.constr) (side_eff : SideEffects.t)
  : Constr.constr * Univ.ContextSet.t *
    list (CEphemeron.key Declarations.structure_body * Z) :=
  let filter (function_parameter : side_effect)
    : list (Names.Constant.t * Declarations.constant_body * Entries.seff_env) *
      CEphemeron.key Declarations.structure_body :=
    let '{| side_effect.from_env := mb; side_effect.eff := se |} :=
      function_parameter in
    let map (e : Entries.side_eff)
      : Names.Constant.t * Declarations.constant_body * Entries.seff_env :=
      ((Entries.side_eff.seff_constant e), (Entries.side_eff.seff_body e),
        (Entries.side_eff.seff_env e)) in
    let cbl := (|Util.List|).(CList.ExtS.map) map se in
    let not_exists {A B : Set} (function_parameter : Names.Constant.t * A * B)
      : bool :=
      let '(c, _, _) := function_parameter in
      (* ❌ Try-with are not handled *)
      try
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        false in
    let cbl := (|Util.List|).(CList.ExtS.filter) not_exists cbl in
    (cbl, mb) in
  let side_eff :=
    (|Util.List|).(CList.ExtS.map) filter (SideEffects.repr side_eff) in
  let sigs :=
    (|Util.List|).(CList.ExtS.rev_map)
      (fun function_parameter =&gt;
        let '(cbl, mb) := function_parameter in
        (mb, ((|Util.List|).(CList.ExtS.length) cbl))) side_eff in
  let side_eff :=
    (|Util.List|).(CList.ExtS.fold_left)
      (fun accu =&gt;
        fun function_parameter =&gt;
          let '(cbl, _) := function_parameter in
          op_at cbl accu) [] side_eff in
  let side_eff := (|Util.List|).(CList.ExtS.rev) side_eff in
  if (|Util.List|).(CList.ExtS.is_empty) side_eff then
    (body, Univ.ContextSet.empty, sigs)
  else
    let cname (c : Names.Constant.t) (r : Sorts.relevance)
      : Context.binder_annot Names.name :=
      Context.make_annot (Names.Name (Label.to_id (Constant.label c))) r in
    let fold {A : Set}
      (function_parameter :
        Names.Cmap_env.t (Util.union Constr.constr Z) * Z * Univ.ContextSet.t *
          list
            (Context.binder_annot Names.name * Constr.constr * Constr.types *
              bool))
      : Names.Cmap_env.key * Declarations.constant_body *
        (* `Opaque *) (Constr.constr * A) -&gt;
      Names.Cmap_env.t (Util.union Constr.constr Z) * Z * Univ.ContextSet.t *
        list
          (Context.binder_annot Names.name * Constr.constr * Constr.types * bool) :=
      let '(subst, var, ctx, args) := function_parameter in
      fun function_parameter =&gt;
        let '(c, cb, b) := function_parameter in
        let '(b, opaque) :=
          match ((Declarations.constant_body.const_body cb), b) with
          | (Declarations.Def b, _) =&gt; ((Mod_subst.force_constr b), false)
          | (Declarations.OpaqueDef _, Opaque (b, _)) =&gt; (b, true)
          | _ =&gt;
            (* ❌ Assert instruction is not handled. *)
            assert false
          end in
        match Declarations.constant_body.const_universes cb with
        | Declarations.Monomorphic univs =&gt;
          let ty := Declarations.constant_body.const_type cb in
          let subst := Cmap_env.add c (Util.Inr var) subst in
          let ctx := Univ.ContextSet.union ctx univs in
          (subst, (Z.add var 1), ctx,
            (cons
              ((cname c (Declarations.constant_body.const_relevance cb)), b, ty,
                opaque) args))
        | Declarations.Polymorphic _ =&gt;
          let subst := Cmap_env.add c (Util.Inl b) subst in
          (subst, var, ctx, args)
        end in
    let '(subst, len, ctx, args) :=
      (|Util.List|).(CList.ExtS.fold_left) fold
        (Cmap_env.empty, 1, Univ.ContextSet.empty, []) side_eff in
    let fix subst_const (i : Z) (k : Z) (t : Constr.constr) {struct i}
      : Constr.constr :=
      match Constr.kind t with
      | Constr.Const (c, u) =&gt;
        let data :=
          (* ❌ Try-with are not handled *)
          try (Some (Cmap_env.find c subst)) in
        match data with
        | None =&gt; t
        | Some (Util.Inl b) =&gt; subst_const i k (Vars.subst_instance_constr u b)
        | Some (Util.Inr n) =&gt; mkRel (Z.sub (Z.add k n) i)
        end
      | Constr.Rel n =&gt;
        if OCaml.Stdlib.le n k then
          t
        else
          mkRel (Z.sub (Z.sub (Z.add n len) i) 1)
      | _ =&gt;
        Constr.map_with_binders (Z.add 1) (fun k =&gt; fun t =&gt; subst_const i k t)
          k t
      end in
    let map_args {A B : Set}
      (i : Z) (function_parameter : A * Constr.constr * Constr.constr * B)
      : A * Constr.constr * Constr.constr * B :=
      let '(na, b, ty, opaque) := function_parameter in
      let ty := subst_const (Z.sub (Z.sub len i) 1) 0 ty in
      let b := subst_const (Z.sub (Z.sub len i) 1) 0 b in
      (na, b, ty, opaque) in
    let args := (|Util.List|).(CList.ExtS.mapi) map_args args in
    let body := subst_const 0 0 body in
    let fold_arg
      (function_parameter :
        Context.binder_annot Names.Name.t * Constr.constr * Constr.types * bool)
      : Constr.constr -&gt; Constr.constr :=
      let '(na, b, ty, opaque) := function_parameter in
      fun accu =&gt;
        if opaque then
          mkApp
            ((mkLambda (na, ty, accu)),
              (* ❌ Arrays not handled. *)
              [ b ])
        else
          mkLetIn (na, b, ty, accu) in
    let body := (|Util.List|).(CList.ExtS.fold_right) fold_arg args body in
    (body, ctx, sigs).

Definition inline_private_constants_in_definition_entry
  (env : Environ.env) (ce : Entries.definition_entry SideEffects.t)
  : Entries.definition_entry unit :=
  Entries.definition_entry.with_const_entry_body ce
    (Future.chain (Entries.definition_entry.const_entry_body ce)
      (fun function_parameter =&gt;
        let '((body, ctx), side_eff) := function_parameter in
        let '(body, ctx', _) := inline_side_effects env body side_eff in
        let ctx' := Univ.ContextSet.union ctx ctx' in
        ((body, ctx'), tt))).

Definition inline_private_constants_in_constr
  (env : Environ.env) (body : Constr.constr) (side_eff : SideEffects.t)
  : Constr.constr := pi1 (inline_side_effects env body side_eff).

Fixpoint is_nth_suffix {A : Set} (n : Int.t) (l : list A) (suf : list A)
  {struct n} : bool :=
  if Int.equal n 0 then
    Stdlib.op_eqeq l suf
  else
    match l with
    | [] =&gt; false
    | cons _ l =&gt; is_nth_suffix (Z.pred n) l suf
    end.

Definition check_signatures {A : Set}
  (curmb : list A) (sl : list (CEphemeron.key (list A) * Int.t)) : Z :=
  let is_direct_ancestor {B : Set}
    (accu : option (Z * list B))
    (function_parameter : CEphemeron.key (list B) * Int.t)
    : option (Z * list B) :=
    let '(mb, how_many) := function_parameter in
    match accu with
    | None =&gt; None
    | Some (n, curmb) =&gt;
      (* ❌ Try-with are not handled *)
      try
        (let mb := CEphemeron.get mb in
        if is_nth_suffix how_many mb curmb then
          Some ((Z.add n how_many), mb)
        else
          None)
    end in
  let sl :=
    (|Util.List|).(CList.ExtS.fold_left) is_direct_ancestor (Some (0, curmb)) sl
    in
  match sl with
  | None =&gt; 0
  | Some (n, _) =&gt; n
  end.

Definition constant_entry_of_side_effect
  (cb : Declarations.constant_body)
  (u : (* `Opaque *) Constr.constr * Univ.ContextSet.t)
  : Entries.constant_entry unit :=
  let univs :=
    match Declarations.constant_body.const_universes cb with
    | Declarations.Monomorphic uctx =&gt; Entries.Monomorphic_entry uctx
    | Declarations.Polymorphic auctx =&gt;
      Entries.Polymorphic_entry (Univ.AUContext.names auctx)
        (Univ.AUContext.repr auctx)
    end in
  let pt :=
    match ((Declarations.constant_body.const_body cb), u) with
    | (Declarations.OpaqueDef _, Opaque (b, c)) =&gt; (b, c)
    | (Declarations.Def b, Nothing) =&gt;
      ((Mod_subst.force_constr b), Univ.ContextSet.empty)
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  Entries.DefinitionEntry
    {|
      Entries.definition_entry.const_entry_body := Future.from_val None (pt, tt);
      Entries.definition_entry.const_entry_secctx := None;
      Entries.definition_entry.const_entry_feedback := None;
      Entries.definition_entry.const_entry_type :=
        Some (Declarations.constant_body.const_type cb);
      Entries.definition_entry.const_entry_universes := univs;
      Entries.definition_entry.const_entry_opaque := Declareops.is_opaque cb;
      Entries.definition_entry.const_entry_inline_code :=
        Declarations.constant_body.const_inline_code cb |}.

Definition turn_direct (orig : Entries.side_eff) : Entries.side_eff :=
  let cb := Entries.side_eff.seff_body orig in
  if Declareops.is_opaque cb then
    let p :=
      match Entries.side_eff.seff_env orig with
      | Opaque (b, c) =&gt; (b, c)
      | _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end in
    let const_body :=
      Declarations.OpaqueDef (Opaqueproof.create (Future.from_val None p)) in
    let cb := Declarations.constant_body.with_const_body cb const_body in
    Entries.side_eff.with_seff_body orig cb
  else
    orig.

Definition export_eff (eff : Entries.side_eff)
  : Names.Constant.t * Declarations.constant_body * Entries.side_effect_role :=
  ((Entries.side_eff.seff_constant eff), (Entries.side_eff.seff_body eff),
    (Entries.side_eff.seff_role eff)).

Definition export_side_effects
  (mb : Declarations.structure_body) (env : Environ.env)
  (c : Entries.definition_entry SideEffects.t)
  : list
    (Names.Constant.t * Declarations.constant_body * Entries.side_effect_role) *
    Entries.definition_entry unit :=
  let body := Entries.definition_entry.const_entry_body c in
  let '(_, eff) := Future.force body in
  let ce :=
    Entries.definition_entry.with_const_entry_body c
      (Future.chain body
        (fun function_parameter =&gt;
          let '(b_ctx, _) := function_parameter in
          (b_ctx, tt))) in
  let not_exists (e : Entries.side_eff) : bool :=
    (* ❌ Try-with are not handled *)
    try
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      false in
  let aux
    (function_parameter :
      list (list Entries.side_eff) *
        list (CEphemeron.key Declarations.structure_body * Z))
    : side_effect -&gt;
    list (list Entries.side_eff) *
      list (CEphemeron.key Declarations.structure_body * Z) :=
    let '(acc, sl) := function_parameter in
    fun function_parameter =&gt;
      let '{| side_effect.from_env := mb; side_effect.eff := se |} :=
        function_parameter in
      let cbl := (|Util.List|).(CList.ExtS.filter) not_exists se in
      if (|Util.List|).(CList.ExtS.is_empty) cbl then
        (acc, sl)
      else
        ((cons cbl acc), (cons (mb, ((|Util.List|).(CList.ExtS.length) cbl)) sl))
    in
  let '(seff, signatures) :=
    (|Util.List|).(CList.ExtS.fold_left) aux ([], []) (SideEffects.repr eff) in
  let trusted := check_signatures mb signatures in
  let push_seff (env : Environ.env) (eff : Entries.side_eff) : Environ.env :=
    let '{|
      Entries.side_eff.seff_constant := kn;
        Entries.side_eff.seff_body := cb
        |} := eff in
    let env := Environ.add_constant kn cb env in
    match Declarations.constant_body.const_universes cb with
    | Declarations.Polymorphic _ =&gt; env
    | Declarations.Monomorphic ctx =&gt;
      let ctx :=
        match Entries.side_eff.seff_env eff with
        | Nothing =&gt; ctx
        | Opaque (_, ctx') =&gt; Univ.ContextSet.union ctx' ctx
        end in
      Environ.push_context_set (Some true) ctx env
    end in
  let fix translate_seff
    (sl : Int.t) (seff : list (list Entries.side_eff))
    (acc :
      list
        (Names.Constant.t * Declarations.constant_body *
          Entries.side_effect_role)) (env : Environ.env) {struct sl}
    : list
      (Names.Constant.t * Declarations.constant_body * Entries.side_effect_role)
      * Entries.definition_entry unit :=
    match seff with
    | [] =&gt; (((|Util.List|).(CList.ExtS.rev) acc), ce)
    | cons cbs rest =&gt;
      if Int.equal sl 0 then
        let '(env, cbs) :=
          (|Util.List|).(CList.ExtS.fold_left)
            (fun function_parameter =&gt;
              let '(env, cbs) := function_parameter in
              fun eff =&gt;
                let '{|
                  Entries.side_eff.seff_constant := kn;
                    Entries.side_eff.seff_body := ocb;
                    Entries.side_eff.seff_env := u
                    |} := eff in
                let ce := constant_entry_of_side_effect ocb u in
                let cb :=
                  Term_typing.translate_constant Term_typing.Pure env kn ce in
                let eff :=
                  Entries.side_eff.with_seff_env
                    (Entries.side_eff.with_seff_body eff cb)
                    (* ❌ Variants not supported *)
                    (* ❌ `Nothing *)
                    Nothing in
                ((push_seff env eff), (cons (export_eff eff) cbs))) (env, [])
            cbs in
        translate_seff 0 rest (op_at cbs acc) env
      else
        let cbs_len := (|Util.List|).(CList.ExtS.length) cbs in
        let cbs := (|Util.List|).(CList.ExtS.map) turn_direct cbs in
        let env := (|Util.List|).(CList.ExtS.fold_left) push_seff env cbs in
        let ecbs := (|Util.List|).(CList.ExtS.map) export_eff cbs in
        translate_seff (Z.sub sl cbs_len) rest (op_at ecbs acc) env
    end in
  translate_seff trusted seff [] env.

Definition export_private_constants
  (in_section : bool) (ce : Entries.definition_entry SideEffects.t)
  (senv : safe_environment)
  : (Entries.definition_entry unit *
    list (Names.Constant.t * Entries.side_effect_role)) * safe_environment :=
  let '(exported, ce) :=
    export_side_effects (safe_environment.revstruct senv)
      (safe_environment.env senv) ce in
  let bodies :=
    (|Util.List|).(CList.ExtS.map)
      (fun function_parameter =&gt;
        let '(kn, cb, _) := function_parameter in
        (kn, cb)) exported in
  let exported :=
    (|Util.List|).(CList.ExtS.map)
      (fun function_parameter =&gt;
        let '(kn, _, r) := function_parameter in
        (kn, r)) exported in
  let senv :=
    (|Util.List|).(CList.ExtS.fold_left) (add_constant_aux in_section) senv
      bodies in
  ((ce, exported), senv).

Definition add_constant
  (in_section : bool) (l : Names.Label.t) (decl : global_declaration)
  (senv : safe_environment) : Names.Constant.t * safe_environment :=
  let kn := Constant.make2 (safe_environment.modpath senv) l in
  let senv :=
    let cb :=
      match decl with
      | ConstantEntry EffectEntry ce =&gt;
        let handle
          (env : Environ.env) (body : Constr.constr) (eff : SideEffects.t)
          : Constr.constr * Univ.ContextSet.t * Z :=
          let '(body, uctx, signatures) := inline_side_effects env body eff in
          let trusted :=
            check_signatures (safe_environment.revstruct senv) signatures in
          (body, uctx, trusted) in
        Term_typing.translate_constant (Term_typing.SideEffects handle)
          (safe_environment.env senv) kn ce
      | ConstantEntry PureEntry ce =&gt;
        Term_typing.translate_constant Term_typing.Pure
          (safe_environment.env senv) kn ce
      | GlobalRecipe r =&gt;
        Term_typing.translate_recipe (safe_environment.env senv) kn r
      end in
    add_constant_aux in_section senv (kn, cb) in
  let senv :=
    match decl with
    |
      ConstantEntry _
        (Entries.PrimitiveEntry {|
          Entries.primitive_entry.prim_entry_content := CPrimitives.OT_type t
            |}) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      add_retroknowledge (Retroknowledge.Register_type t kn) senv
    | _ =&gt; senv
    end in
  (kn, senv).

Definition check_mind
  (mie : Entries.mutual_inductive_entry) (lab : Names.Label.t) : unit :=
  match Entries.mutual_inductive_entry.mind_entry_inds mie with
  | [] =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | cons oie _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert
      (Id.equal (Label.to_id lab)
        (Entries.one_inductive_entry.mind_entry_typename oie))
  end.

Definition add_mind
  (l : Names.Label.t) (mie : Entries.mutual_inductive_entry)
  (senv : safe_environment) : Names.MutInd.t * safe_environment :=
  let '_ := check_mind mie l in
  let kn := MutInd.make2 (safe_environment.modpath senv) l in
  let mib := Indtypes.check_inductive (safe_environment.env senv) kn mie in
  let mib :=
    match Declarations.mutual_inductive_body.mind_hyps mib with
    | [] =&gt; Declareops.hcons_mind mib
    | _ =&gt; mib
    end in
  (kn, (add_field None (l, (Declarations.SFBmind mib)) (I kn) senv)).

Definition add_modtype
  (l : Names.Label.__Set.elt) (params_mte : Entries.module_type_entry)
  (inl : Entries.inline) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  let mp := Names.MPdot (safe_environment.modpath senv) l in
  let mtb :=
    Mod_typing.translate_modtype (safe_environment.env senv) mp inl params_mte
    in
  let mtb := Declareops.hcons_module_type mtb in
  let senv' := add_field None (l, (Declarations.SFBmodtype mtb)) MT senv in
  (mp, senv').

Definition full_add_module
  (mb : Declarations.module_body) (senv : safe_environment)
  : safe_environment :=
  let senv :=
    add_constraints
      (Now false (Declarations.generic_module_body.mod_constraints mb)) senv in
  let dp := ModPath.dp (Declarations.generic_module_body.mod_mp mb) in
  let linkinfo := Nativecode.link_info_of_dirpath dp in
  safe_environment.with_env senv
    (Modops.add_linked_module mb linkinfo (safe_environment.env senv)).

Definition full_add_module_type
  (mp : Names.ModPath.t) (mt : Declarations.module_type_body)
  (senv : safe_environment) : safe_environment :=
  let senv :=
    add_constraints
      (Now false (Declarations.generic_module_body.mod_constraints mt)) senv in
  safe_environment.with_env senv
    (Modops.add_module_type mp mt (safe_environment.env senv)).

Definition add_module
  (l : Names.Label.__Set.elt) (me : Entries.module_entry) (inl : Entries.inline)
  (senv : safe_environment)
  : (Names.module_path * Mod_subst.delta_resolver) * safe_environment :=
  let mp := Names.MPdot (safe_environment.modpath senv) l in
  let mb := Mod_typing.translate_module (safe_environment.env senv) mp inl me in
  let mb := Declareops.hcons_module_body mb in
  let senv' := add_field None (l, (Declarations.SFBmodule mb)) M senv in
  let senv'' :=
    if Modops.is_functor (Declarations.generic_module_body.mod_type mb) then
      senv'
    else
      update_resolver
        (Mod_subst.add_delta_resolver
          (Declarations.generic_module_body.mod_delta mb)) senv' in
  ((mp, (Declarations.generic_module_body.mod_delta mb)), senv'').

Definition start_module (l : Names.Label.__Set.elt) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  let '_ := check_modlabel l senv in
  let '_ := check_empty_context senv in
  let mp := Names.MPdot (safe_environment.modpath senv) l in
  (mp,
    (safe_environment.with_required
      (safe_environment.with_modvariant
        (safe_environment.with_modpath
          (safe_environment.with_env empty_environment
            (safe_environment.env senv)) mp) (STRUCT [] senv))
      (safe_environment.required senv))).

Definition start_modtype (l : Names.Label.__Set.elt) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  let '_ := check_modlabel l senv in
  let '_ := check_empty_context senv in
  let mp := Names.MPdot (safe_environment.modpath senv) l in
  (mp,
    (safe_environment.with_required
      (safe_environment.with_modvariant
        (safe_environment.with_modpath
          (safe_environment.with_env empty_environment
            (safe_environment.env senv)) mp) (SIG [] senv))
      (safe_environment.required senv))).

Definition add_module_parameter
  (mbid : Names.MBId.t) (mte : Entries.module_struct_entry)
  (inl : Entries.inline) (senv : safe_environment)
  : Mod_subst.delta_resolver * safe_environment :=
  let '_ := check_empty_struct senv in
  let mp := Names.MPbound mbid in
  let mtb :=
    Mod_typing.translate_modtype (safe_environment.env senv) mp inl ([], mte) in
  let senv := full_add_module_type mp mtb senv in
  let new_variant :=
    match safe_environment.modvariant senv with
    | STRUCT params oldenv =&gt; STRUCT (cons (mbid, mtb) params) oldenv
    | SIG params oldenv =&gt; SIG (cons (mbid, mtb) params) oldenv
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  let new_paramresolver :=
    if Modops.is_functor (Declarations.generic_module_body.mod_type mtb) then
      safe_environment.paramresolver senv
    else
      Mod_subst.add_delta_resolver
        (Declarations.generic_module_body.mod_delta mtb)
        (safe_environment.paramresolver senv) in
  ((Declarations.generic_module_body.mod_delta mtb),
    (safe_environment.with_paramresolver
      (safe_environment.with_modvariant senv new_variant) new_paramresolver)).

Definition functorize {A B : Set}
  (params : list (Names.MBId.t * A)) (init : Declarations.functorize A B)
  : Declarations.functorize A B :=
  (|Util.List|).(CList.ExtS.fold_left)
    (fun e =&gt;
      fun function_parameter =&gt;
        let '(mbid, mt) := function_parameter in
        Declarations.MoreFunctor mbid mt e) init params.

Definition propagate_loads (senv : safe_environment) : safe_environment :=
  (|Util.List|).(CList.ExtS.fold_left)
    (fun env =&gt;
      fun function_parameter =&gt;
        let '(_, mb) := function_parameter in
        full_add_module mb env) senv
    ((|Util.List|).(CList.ExtS.rev) (safe_environment.loads senv)).

Definition functorize_module
  (params : list (Names.MBId.t * Declarations.module_type_body))
  (mb : Declarations.generic_module_body Declarations.module_implementation)
  : Declarations.generic_module_body Declarations.module_implementation :=
  let f {A : Set} (x : Declarations.functorize Declarations.module_type_body A)
    : Declarations.functorize Declarations.module_type_body A :=
    functorize params x in
  Declarations.generic_module_body.with_mod_type_alg
    (Declarations.generic_module_body.with_mod_type
      (Declarations.generic_module_body.with_mod_expr mb
        (Modops.implem_smartmap f f
          (Declarations.generic_module_body.mod_expr mb)))
      (f (Declarations.generic_module_body.mod_type mb)))
    (Option.map f (Declarations.generic_module_body.mod_type_alg mb)).

Definition build_module_body
  (params : list (Names.MBId.t * Declarations.module_type_body))
  (restype : option (Entries.module_struct_entry * Entries.inline))
  (senv : safe_environment)
  : Declarations.generic_module_body Declarations.module_implementation :=
  let struc :=
    Declarations.NoFunctor
      ((|Util.List|).(CList.ExtS.rev) (safe_environment.revstruct senv)) in
  let restype' :=
    Option.map
      (fun function_parameter =&gt;
        let '(ty, inl) := function_parameter in
        (([], ty), inl)) restype in
  let mb :=
    Mod_typing.finalize_module (safe_environment.env senv)
      (safe_environment.modpath senv)
      (struc, None, (safe_environment.modresolver senv),
        (safe_environment.univ senv)) restype' in
  let mb' := functorize_module params mb in
  Declarations.generic_module_body.with_mod_retroknowledge mb'
    (Declarations.ModBodyRK (safe_environment.local_retroknowledge senv)).

Definition allow_delayed_constants : Stdlib.ref bool := Stdlib.__ref_value false.

Definition propagate_senv
  (newdef : Names.Label.__Set.elt * Declarations.structure_field_body)
  (newenv : Environ.env) (newresolver : Mod_subst.delta_resolver)
  (senv : safe_environment) (oldsenv : safe_environment) : safe_environment :=
  let '(now_cst, later_cst) :=
    (|Util.List|).(CList.ExtS.partition) Future.is_val
      (safe_environment.future_cst senv) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  safe_environment.with_native_symbols
    (safe_environment.with_local_retroknowledge
      (safe_environment.with_loads
        (safe_environment.with_required
          (safe_environment.with_engagement
            (safe_environment.with_future_cst
              (safe_environment.with_univ
                (safe_environment.with_modlabels
                  (safe_environment.with_revstruct
                    (safe_environment.with_modresolver
                      (safe_environment.with_env oldsenv newenv) newresolver)
                    (cons newdef (safe_environment.revstruct oldsenv)))
                  (Label.__Set.add (fst newdef)
                    (safe_environment.modlabels oldsenv)))
                ((|Util.List|).(CList.ExtS.fold_left)
                  (fun acc =&gt;
                    fun cst =&gt; Univ.ContextSet.union acc (Future.force cst))
                  (Univ.ContextSet.union (safe_environment.univ senv)
                    (safe_environment.univ oldsenv)) now_cst))
              (op_at later_cst (safe_environment.future_cst oldsenv)))
            (safe_environment.engagement senv)) (safe_environment.required senv))
        (op_at (safe_environment.loads senv) (safe_environment.loads oldsenv)))
      (op_at (safe_environment.local_retroknowledge senv)
        (safe_environment.local_retroknowledge oldsenv)))
    (safe_environment.native_symbols senv).

Definition end_module
  (l : Names.Label.t)
  (restype : option (Entries.module_struct_entry * Entries.inline))
  (senv : safe_environment)
  : (Names.ModPath.t * list Names.MBId.t * Mod_subst.delta_resolver) *
    safe_environment :=
  let mp := safe_environment.modpath senv in
  let '(params, oldsenv) := check_struct (safe_environment.modvariant senv) in
  let '_ := check_current_label l mp in
  let '_ := check_empty_context senv in
  let mbids := (|Util.List|).(CList.ExtS.rev_map) fst params in
  let mb := build_module_body params restype senv in
  let newenv :=
    Environ.set_opaque_tables (safe_environment.env oldsenv)
      (Environ.opaque_tables (safe_environment.env senv)) in
  let newenv := set_engagement_opt newenv (safe_environment.engagement senv) in
  let senv' :=
    propagate_loads
      (safe_environment.with_univ (safe_environment.with_env senv newenv)
        (Univ.ContextSet.union (safe_environment.univ senv)
          (Declarations.generic_module_body.mod_constraints mb))) in
  let newenv :=
    Environ.push_context_set (Some true)
      (Declarations.generic_module_body.mod_constraints mb)
      (safe_environment.env senv') in
  let newenv := Modops.add_module mb newenv in
  let newresolver :=
    if Modops.is_functor (Declarations.generic_module_body.mod_type mb) then
      safe_environment.modresolver oldsenv
    else
      Mod_subst.add_delta_resolver
        (Declarations.generic_module_body.mod_delta mb)
        (safe_environment.modresolver oldsenv) in
  ((mp, mbids, (Declarations.generic_module_body.mod_delta mb)),
    (propagate_senv (l, (Declarations.SFBmodule mb)) newenv newresolver senv'
      oldsenv)).

Definition build_mtb
  (mp : Names.ModPath.t) (sign : Declarations.module_signature)
  (cst : Univ.ContextSet.t) (delta : Mod_subst.delta_resolver)
  : Declarations.generic_module_body unit :=
  {| Declarations.generic_module_body.mod_mp := mp;
    Declarations.generic_module_body.mod_expr := tt;
    Declarations.generic_module_body.mod_type := sign;
    Declarations.generic_module_body.mod_type_alg := None;
    Declarations.generic_module_body.mod_constraints := cst;
    Declarations.generic_module_body.mod_delta := delta;
    Declarations.generic_module_body.mod_retroknowledge :=
      Declarations.ModTypeRK |}.

Definition end_modtype (l : Names.Label.t) (senv : safe_environment)
  : (Names.ModPath.t * list Names.MBId.t) * safe_environment :=
  let mp := safe_environment.modpath senv in
  let '(params, oldsenv) := check_sig (safe_environment.modvariant senv) in
  let '_ := check_current_label l mp in
  let '_ := check_empty_context senv in
  let mbids := (|Util.List|).(CList.ExtS.rev_map) fst params in
  let newenv :=
    Environ.set_opaque_tables (safe_environment.env oldsenv)
      (Environ.opaque_tables (safe_environment.env senv)) in
  let newenv :=
    Environ.push_context_set (Some true) (safe_environment.univ senv) newenv in
  let newenv := set_engagement_opt newenv (safe_environment.engagement senv) in
  let senv' := propagate_loads (safe_environment.with_env senv newenv) in
  let auto_tb :=
    functorize params
      (Declarations.NoFunctor
        ((|Util.List|).(CList.ExtS.rev) (safe_environment.revstruct senv))) in
  let mtb :=
    build_mtb mp auto_tb (safe_environment.univ senv')
      (safe_environment.modresolver senv) in
  let newenv := Environ.add_modtype mtb (safe_environment.env senv') in
  let newresolver := safe_environment.modresolver oldsenv in
  ((mp, mbids),
    (propagate_senv (l, (Declarations.SFBmodtype mtb)) newenv newresolver senv'
      oldsenv)).

Definition add_include
  (me : Entries.module_struct_entry) (is_module : bool) (inl : Entries.inline)
  (senv : safe_environment) : Mod_subst.delta_resolver * safe_environment :=
  let mp_sup := safe_environment.modpath senv in
  let '(sign, _, resolver, cst) :=
    translate_mse_incl is_module (safe_environment.env senv) mp_sup inl me in
  let senv := add_constraints (Now false cst) senv in
  let fix compute_sign
    (sign : Declarations.module_signature) (mb : Declarations.module_type_body)
    (resolver : Mod_subst.delta_resolver) (senv : safe_environment)
    {struct sign}
    : Mod_subst.delta_resolver * Declarations.structure_body * safe_environment :=
    match sign with
    | Declarations.MoreFunctor mbid mtb str =&gt;
      let cst_sub := Subtyping.check_subtypes (safe_environment.env senv) mb mtb
        in
      let senv :=
        add_constraints
          (Now false
            (Univ.ContextSet.add_constraints cst_sub Univ.ContextSet.empty))
          senv in
      let mpsup_delta :=
        Modops.inline_delta_resolver (safe_environment.env senv) inl mp_sup mbid
          mtb (Declarations.generic_module_body.mod_delta mb) in
      let subst := Mod_subst.map_mbid mbid mp_sup mpsup_delta in
      let resolver := Mod_subst.subst_codom_delta_resolver subst resolver in
      compute_sign (Modops.subst_signature subst str) mb resolver senv
    | Declarations.NoFunctor str =&gt; (resolver, str, senv)
    end in
  let '(resolver, str, senv) :=
    let struc :=
      Declarations.NoFunctor
        ((|Util.List|).(CList.ExtS.rev) (safe_environment.revstruct senv)) in
    let mtb :=
      build_mtb mp_sup struc Univ.ContextSet.empty
        (safe_environment.modresolver senv) in
    compute_sign sign mtb resolver senv in
  let senv := update_resolver (Mod_subst.add_delta_resolver resolver) senv in
  let add
    (senv : safe_environment)
    (function_parameter :
      Names.Label.__Set.elt * Declarations.structure_field_body)
    : safe_environment :=
    let '(l, elem) as field := function_parameter in
    let new_name :=
      match elem with
      | Declarations.SFBconst _ =&gt;
        C (Mod_subst.constant_of_delta_kn resolver (KerName.make mp_sup l))
      | Declarations.SFBmind _ =&gt;
        I (Mod_subst.mind_of_delta_kn resolver (KerName.make mp_sup l))
      | Declarations.SFBmodule _ =&gt; M
      | Declarations.SFBmodtype _ =&gt; MT
      end in
    add_field (Some true) field new_name senv in
  (resolver, ((|Util.List|).(CList.ExtS.fold_left) add senv str)).

Module compiled_library.
  Record record := {
    comp_name : Names.DirPath.t;
    comp_mod : Declarations.module_body;
    comp_deps : array library_info;
    comp_enga : Declarations.engagement;
    comp_natsymbs : Nativecode.symbols }.
  Definition with_comp_name (r : record) comp_name : record :=
    {| comp_name := comp_name; comp_mod := comp_mod r; comp_deps := comp_deps r;
      comp_enga := comp_enga r; comp_natsymbs := comp_natsymbs r |}.
  Definition with_comp_mod (r : record) comp_mod : record :=
    {| comp_name := comp_name r; comp_mod := comp_mod; comp_deps := comp_deps r;
      comp_enga := comp_enga r; comp_natsymbs := comp_natsymbs r |}.
  Definition with_comp_deps (r : record) comp_deps : record :=
    {| comp_name := comp_name r; comp_mod := comp_mod r; comp_deps := comp_deps;
      comp_enga := comp_enga r; comp_natsymbs := comp_natsymbs r |}.
  Definition with_comp_enga (r : record) comp_enga : record :=
    {| comp_name := comp_name r; comp_mod := comp_mod r;
      comp_deps := comp_deps r; comp_enga := comp_enga;
      comp_natsymbs := comp_natsymbs r |}.
  Definition with_comp_natsymbs (r : record) comp_natsymbs : record :=
    {| comp_name := comp_name r; comp_mod := comp_mod r;
      comp_deps := comp_deps r; comp_enga := comp_enga r;
      comp_natsymbs := comp_natsymbs |}.
End compiled_library.
Definition compiled_library := compiled_library.record.

Definition module_of_library (lib : compiled_library)
  : Declarations.module_body := compiled_library.comp_mod lib.

Definition native_library := list Nativecode.global.

Definition get_library_native_symbols
  (senv : safe_environment) (dir : DPMap.key) : Nativecode.symbols :=
  (* ❌ Try-with are not handled *)
  try (DPMap.find dir (safe_environment.native_symbols senv)).

Definition current_modpath (senv : safe_environment) : Names.ModPath.t :=
  safe_environment.modpath senv.

Definition current_dirpath (senv : safe_environment) : Names.DirPath.t :=
  Names.ModPath.dp (current_modpath senv).

Definition start_library (dir : Names.DirPath.t) (senv : safe_environment)
  : Names.module_path * safe_environment :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let mp := Names.MPfile dir in
  (mp,
    (safe_environment.with_required
      (safe_environment.with_modvariant
        (safe_environment.with_modpath
          (safe_environment.with_env empty_environment
            (safe_environment.env senv)) mp) LIBRARY)
      (safe_environment.required senv))).

Definition export
  (except : option Future.UUIDSet.t) (output_native_objects : bool)
  (senv : safe_environment) (dir : Names.DirPath.t)
  : Names.ModPath.t * compiled_library * list Nativecode.global :=
  let senv :=
    (* ❌ Try-with are not handled *)
    try (join_safe_environment except senv) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let '_ := check_current_library dir senv in
  let mp := safe_environment.modpath senv in
  let str :=
    Declarations.NoFunctor
      ((|Util.List|).(CList.ExtS.rev) (safe_environment.revstruct senv)) in
  let mb :=
    {| Declarations.generic_module_body.mod_mp := mp;
      Declarations.generic_module_body.mod_expr := Declarations.FullStruct;
      Declarations.generic_module_body.mod_type := str;
      Declarations.generic_module_body.mod_type_alg := None;
      Declarations.generic_module_body.mod_constraints :=
        safe_environment.univ senv;
      Declarations.generic_module_body.mod_delta :=
        safe_environment.modresolver senv;
      Declarations.generic_module_body.mod_retroknowledge :=
        Declarations.ModBodyRK (safe_environment.local_retroknowledge senv) |}
    in
  let '(ast, symbols) :=
    if output_native_objects then
      Nativelibrary.dump_library mp dir (safe_environment.env senv) str
    else
      ([], Nativecode.empty_symbols) in
  let lib :=
    {| compiled_library.comp_name := dir; compiled_library.comp_mod := mb;
      compiled_library.comp_deps :=
        (|Util.Array|).(CArray.ExtS.of_list)
          (DPMap.bindings (safe_environment.required senv));
      compiled_library.comp_enga :=
        Environ.engagement (safe_environment.env senv);
      compiled_library.comp_natsymbs := symbols |} in
  (mp, lib, ast).

Definition import
  (lib : compiled_library) (cst : Univ.ContextSet.t) (vodigest : vodigest)
  (senv : safe_environment) : Names.module_path * safe_environment :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let mp := Names.MPfile (compiled_library.comp_name lib) in
  let mb := compiled_library.comp_mod lib in
  let env :=
    Environ.push_context_set (Some true)
      (Univ.ContextSet.union
        (Declarations.generic_module_body.mod_constraints mb) cst)
      (safe_environment.env senv) in
  (mp,
    (safe_environment.with_native_symbols
      (safe_environment.with_loads
        (safe_environment.with_required
          (safe_environment.with_modresolver
            (safe_environment.with_env senv
              (let linkinfo :=
                Nativecode.link_info_of_dirpath (compiled_library.comp_name lib)
                in
              Modops.add_linked_module mb linkinfo env))
            (Mod_subst.add_delta_resolver
              (Declarations.generic_module_body.mod_delta mb)
              (safe_environment.modresolver senv)))
          (DPMap.add (compiled_library.comp_name lib) vodigest
            (safe_environment.required senv)))
        (cons (mp, mb) (safe_environment.loads senv)))
      (DPMap.add (compiled_library.comp_name lib)
        (compiled_library.comp_natsymbs lib)
        (safe_environment.native_symbols senv)))).

Definition judgment := Environ.unsafe_judgment.

Definition j_val {A B : Set} (j : Environ.punsafe_judgment A B) : A :=
  Environ.punsafe_judgment.uj_val j.

Definition j_type {A B : Set} (j : Environ.punsafe_judgment A B) : B :=
  Environ.punsafe_judgment.uj_type j.

Definition typing (senv : safe_environment)
  : Constr.constr -&gt; Environ.unsafe_judgment := Typeops.infer (env_of_senv senv).

Definition register_inline (kn : Names.Constant.t) (senv : safe_environment)
  : safe_environment :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let env := safe_environment.env senv in
  let cb := lookup_constant kn env in
  let cb := Declarations.constant_body.with_const_inline_code cb true in
  let env := add_constant kn cb env in
  safe_environment.with_env senv env.

Definition check_register_ind
  (ind : Names.inductive) (r : CPrimitives.prim_ind) (env : Environ.env)
  : unit :=
  let '(mb, ob) as spec := Inductive.lookup_mind_specif env ind in
  let check_if (b : bool) (msg : Pp.t) : unit :=
    if negb b then
      CErrors.user_err None (Some &quot;check_register_ind&quot;) msg
    else
      tt in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let is_monomorphic (function_parameter : Declarations.universes) : bool :=
    match function_parameter with
    | Declarations.Monomorphic _ =&gt; true
    | Declarations.Polymorphic _ =&gt; false
    end in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let check_nparams (n : Int.t) : unit :=
    check_if (Int.equal (Declarations.mutual_inductive_body.mind_nparams mb) n)
      (op_plusplus (op_plusplus (str &quot;An inductive type with &quot;) (int n))
        (str &quot; parameters is expected&quot;)) in
  let check_nconstr (n : Int.t) : unit :=
    check_if
      (Int.equal
        ((|Util.Array|).(CArray.ExtS.length)
          (Declarations.one_inductive_body.mind_consnames ob)) n)
      (op_plusplus (op_plusplus (str &quot;an inductive type with &quot;) (int n))
        (str &quot; constructors is expected&quot;)) in
  let check_name (pos : Z) (s : string) : unit :=
    check_if
      (Id.equal
        ((|Util.Array|).(CArray.ExtS.get)
          (Declarations.one_inductive_body.mind_consnames ob) pos)
        (Id.of_string s))
      (op_plusplus
        (op_plusplus (op_plusplus (str &quot;the &quot;) (int (Z.add pos 1)))
          (str &quot;th constructor does not have the expected name: &quot;)) (str s)) in
  let check_type (pos : Z) (t : Constr.constr) : unit :=
    check_if
      (Constr.equal t
        ((|Util.Array|).(CArray.ExtS.get)
          (Declarations.one_inductive_body.mind_user_lc ob) pos))
      (op_plusplus (op_plusplus (str &quot;the &quot;) (int (Z.add pos 1)))
        (str &quot;th constructor does not have the expected type&quot;)) in
  let check_type_cte (pos : Z) : unit :=
    check_type pos (Constr.mkRel 1) in
  match r with
  | CPrimitives.PIT_bool =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    check_type_cte 1
  | CPrimitives.PIT_carry =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let test_type (pos : Z) : unit :=
      let c :=
        (|Util.Array|).(CArray.ExtS.get)
          (Declarations.one_inductive_body.mind_user_lc ob) pos in
      let s :=
        op_plusplus (op_plusplus (str &quot;the &quot;) (int (Z.add pos 1)))
          (str &quot;th constructor does not have the expected type&quot;) in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      let '(_, d, cd) := Constr.destProd c in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      check_if
        (Constr.equal
          (mkProd
            (Context.anonR, (mkRel 1),
              (mkApp
                ((mkRel 3),
                  (* ❌ Arrays not handled. *)
                  [ mkRel 2 ])))) cd) s in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    test_type 1
  | CPrimitives.PIT_pair =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let c :=
      (|Util.Array|).(CArray.ExtS.get)
        (Declarations.one_inductive_body.mind_user_lc ob) 0 in
    let s := Pp.str &quot;the constructor does not have the expected type&quot; in
    match Term.decompose_prod c with
    | (cons (_, b) (cons (_, a) (cons (_, _B) (cons (_, _A) []))), codom) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      check_if
        (Constr.equal codom
          (mkApp
            ((mkRel 5),
              (* ❌ Arrays not handled. *)
              [ mkRel 4; mkRel 3 ]))) s
    | _ =&gt; check_if false s
    end
  | CPrimitives.PIT_cmp =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    check_type_cte 2
  end.

Definition register_inductive
  (ind : Names.inductive) (prim : CPrimitives.prim_ind)
  (senv : safe_environment) : safe_environment :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let action := Retroknowledge.Register_ind prim ind in
  add_retroknowledge action senv.

Definition add_constraints (c : Univ.Constraint.t)
  : safe_environment -&gt; safe_environment :=
  add_constraints
    (Now false (Univ.ContextSet.add_constraints c Univ.ContextSet.empty)).

Definition set_strategy
  (k : Names.tableKey Names.Constant.t) (l : Conv_oracle.level)
  (e : safe_environment) : safe_environment :=
  safe_environment.with_env e
    (Environ.set_oracle (safe_environment.env e)
      (Conv_oracle.set_strategy (Environ.oracle (safe_environment.env e)) k l)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="safe_typing.mli">
  <div style="margin: 20px;">
    <h3>Safe_typing_mli</h3>
    <ul>
      <li>OCaml size: 226 lines</li>
      <li>Coq size: 212 lines (-7% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#safe_typing.mli"><code>safe_typing.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

type vodigest =
  | Dvo_or_vi of Digest.t        (* The digest of the seg_lib part *)
  | Dvivo of Digest.t * Digest.t (* The digest of the seg_lib + seg_univ part *)

val digest_match : actual:vodigest -&gt; required:vodigest -&gt; bool

(** {6 Safe environments } *)

(** Since we are now able to type terms, we can define an abstract type
    of safe environments, where objects are typed before being added.

    We also provide functionality for modules : [start_module], [end_module],
    etc.
*)

type safe_environment

val empty_environment : safe_environment

val is_initial : safe_environment -&gt; bool

val env_of_safe_env : safe_environment -&gt; Environ.env

(** The safe_environment state monad *)

type safe_transformer0 = safe_environment -&gt; safe_environment
type 'a safe_transformer = safe_environment -&gt; 'a * safe_environment


(** {6 Stm machinery } *)

type private_constants

val side_effects_of_private_constants :
  private_constants -&gt; Entries.side_eff list
(** Return the list of individual side-effects in the order of their
    creation. *)

val empty_private_constants : private_constants
val concat_private : private_constants -&gt; private_constants -&gt; private_constants
(** [concat_private e1 e2] adds the constants of [e1] to [e2], i.e. constants in
    [e1] must be more recent than those of [e2]. *)

val private_con_of_con : safe_environment -&gt; Constant.t -&gt; private_constants
val private_con_of_scheme : kind:string -&gt; safe_environment -&gt; (inductive * Constant.t) list -&gt; private_constants

val mk_pure_proof : Constr.constr -&gt; private_constants Entries.proof_output
val inline_private_constants_in_constr :
  Environ.env -&gt; Constr.constr -&gt; private_constants -&gt; Constr.constr
val inline_private_constants_in_definition_entry :
  Environ.env -&gt; private_constants Entries.definition_entry -&gt; unit Entries.definition_entry

val universes_of_private : private_constants -&gt; Univ.ContextSet.t list

val is_curmod_library : safe_environment -&gt; bool

(* safe_environment has functional data affected by lazy computations,
 * thus this function returns a new safe_environment *)
val join_safe_environment :
  ?except:Future.UUIDSet.t -&gt; safe_environment -&gt; safe_environment

val is_joined_environment : safe_environment -&gt; bool
(** {6 Enriching a safe environment } *)

(** Insertion of local declarations (Local or Variables) *)

val push_named_assum :
  (Id.t * Constr.types * bool (* polymorphic *))
    Univ.in_universe_context_set -&gt; safe_transformer0

(** Returns the full universe context necessary to typecheck the definition
  (futures are forced) *)
val push_named_def :
  Id.t * Entries.section_def_entry -&gt; safe_transformer0

(** Insertion of global axioms or definitions *)

type 'a effect_entry =
| EffectEntry : private_constants effect_entry
| PureEntry : unit effect_entry

type global_declaration =
  | ConstantEntry : 'a effect_entry * 'a Entries.constant_entry -&gt; global_declaration
  | GlobalRecipe of Cooking.recipe

type exported_private_constant =
  Constant.t * Entries.side_effect_role

val export_private_constants : in_section:bool -&gt;
  private_constants Entries.definition_entry -&gt;
  (unit Entries.definition_entry * exported_private_constant list) safe_transformer

(** returns the main constant plus a list of auxiliary constants (empty
    unless one requires the side effects to be exported) *)
val add_constant :
  in_section:bool -&gt; Label.t -&gt; global_declaration -&gt;
    Constant.t safe_transformer

(** Adding an inductive type *)

val add_mind :
  Label.t -&gt; Entries.mutual_inductive_entry -&gt;
    MutInd.t safe_transformer

(** Adding a module or a module type *)

val add_module :
  Label.t -&gt; Entries.module_entry -&gt; Declarations.inline -&gt;
    (ModPath.t * Mod_subst.delta_resolver) safe_transformer
val add_modtype :
  Label.t -&gt; Entries.module_type_entry -&gt; Declarations.inline -&gt;
    ModPath.t safe_transformer

(** Adding universe constraints *)

val push_context_set :
  bool -&gt; Univ.ContextSet.t -&gt; safe_transformer0

val add_constraints :
  Univ.Constraint.t -&gt; safe_transformer0

(* (\** Generator of universes *\) *)
(* val next_universe : int safe_transformer *)

(** Setting the type theory flavor *)
val set_engagement : Declarations.engagement -&gt; safe_transformer0
val set_indices_matter : bool -&gt; safe_transformer0
val set_typing_flags : Declarations.typing_flags -&gt; safe_transformer0
val set_share_reduction : bool -&gt; safe_transformer0
val set_VM : bool -&gt; safe_transformer0
val set_native_compiler : bool -&gt; safe_transformer0
val make_sprop_cumulative : safe_transformer0
val set_allow_sprop : bool -&gt; safe_transformer0

val check_engagement : Environ.env -&gt; Declarations.set_predicativity -&gt; unit

(** {6 Interactive module functions } *)

val start_module : Label.t -&gt; ModPath.t safe_transformer

val start_modtype : Label.t -&gt; ModPath.t safe_transformer

val add_module_parameter :
  MBId.t -&gt; Entries.module_struct_entry -&gt; Declarations.inline -&gt;
    Mod_subst.delta_resolver safe_transformer

(** Traditional mode: check at end of module that no future was
    created. *)
val allow_delayed_constants : bool ref

(** The optional result type is given without its functorial part *)

val end_module :
  Label.t -&gt; (Entries.module_struct_entry * Declarations.inline) option -&gt;
    (ModPath.t * MBId.t list * Mod_subst.delta_resolver) safe_transformer

val end_modtype : Label.t -&gt; (ModPath.t * MBId.t list) safe_transformer

val add_include :
  Entries.module_struct_entry -&gt; bool -&gt; Declarations.inline -&gt;
   Mod_subst.delta_resolver safe_transformer

val current_modpath : safe_environment -&gt; ModPath.t

val current_dirpath : safe_environment -&gt; DirPath.t

(** {6 Libraries : loading and saving compilation units } *)

type compiled_library

type native_library = Nativecode.global list

val module_of_library : compiled_library -&gt; Declarations.module_body

val get_library_native_symbols : safe_environment -&gt; DirPath.t -&gt; Nativecode.symbols

val start_library : DirPath.t -&gt; ModPath.t safe_transformer

val export :
  ?except:Future.UUIDSet.t -&gt; output_native_objects:bool -&gt;
  safe_environment -&gt; DirPath.t -&gt;
    ModPath.t * compiled_library * native_library

(* Constraints are non empty iff the file is a vi2vo *)
val import : compiled_library -&gt; Univ.ContextSet.t -&gt; vodigest -&gt;
  ModPath.t safe_transformer

(** {6 Safe typing judgments } *)

type judgment

val j_val : judgment -&gt; Constr.constr
val j_type : judgment -&gt; Constr.constr

(** The safe typing of a term returns a typing judgment. *)
val typing : safe_environment -&gt; Constr.constr -&gt; judgment

(** {6 Queries } *)

val exists_objlabel : Label.t -&gt; safe_environment -&gt; bool

val delta_of_senv :
  safe_environment -&gt; Mod_subst.delta_resolver * Mod_subst.delta_resolver

val constant_of_delta_kn_senv : safe_environment -&gt; KerName.t -&gt; Constant.t
val mind_of_delta_kn_senv : safe_environment -&gt; KerName.t -&gt; MutInd.t

(** {6 Retroknowledge / Native compiler } *)

val register_inline : Constant.t -&gt; safe_transformer0
val register_inductive : inductive -&gt; CPrimitives.prim_ind -&gt; safe_transformer0

val set_strategy :
  Names.Constant.t Names.tableKey -&gt; Conv_oracle.level -&gt; safe_transformer0
</pre>
  </div>
  <div class="col-md-6">
    <a href="#safe_typing.mli"><code>Safe_typing_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Inductive vodigest : Set :=
| Dvo_or_vi : Stdlib.Digest.t -&gt; vodigest
| Dvivo : Stdlib.Digest.t -&gt; Stdlib.Digest.t -&gt; vodigest.

Parameter digest_match : vodigest -&gt; vodigest -&gt; bool.

Parameter safe_environment : Set.

Parameter empty_environment : safe_environment.

Parameter is_initial : safe_environment -&gt; bool.

Parameter env_of_safe_env : safe_environment -&gt; Environ.env.

Definition safe_transformer0 := safe_environment -&gt; safe_environment.

Definition safe_transformer (a : Set) :=
  safe_environment -&gt; a * safe_environment.

Parameter private_constants : Set.

Parameter side_effects_of_private_constants :
  private_constants -&gt; list Entries.side_eff.

Parameter empty_private_constants : private_constants.

Parameter concat_private :
  private_constants -&gt; private_constants -&gt; private_constants.

Parameter private_con_of_con :
  safe_environment -&gt; Names.Constant.t -&gt; private_constants.

Parameter private_con_of_scheme :
  string -&gt; safe_environment -&gt; list (Names.inductive * Names.Constant.t) -&gt;
  private_constants.

Parameter mk_pure_proof :
  Constr.constr -&gt; Entries.proof_output private_constants.

Parameter inline_private_constants_in_constr :
  Environ.env -&gt; Constr.constr -&gt; private_constants -&gt; Constr.constr.

Parameter inline_private_constants_in_definition_entry :
  Environ.env -&gt; Entries.definition_entry private_constants -&gt;
  Entries.definition_entry unit.

Parameter universes_of_private : private_constants -&gt; list Univ.ContextSet.t.

Parameter is_curmod_library : safe_environment -&gt; bool.

Parameter join_safe_environment :
  option Future.UUIDSet.t -&gt; safe_environment -&gt; safe_environment.

Parameter is_joined_environment : safe_environment -&gt; bool.

Parameter push_named_assum :
  Univ.in_universe_context_set (Names.Id.t * Constr.types * bool) -&gt;
  safe_transformer0.

Parameter push_named_def :
  Names.Id.t * Entries.section_def_entry -&gt; safe_transformer0.

Reserved Notation &quot;'effect_entry&quot;.

Inductive effect_entry_gadt : Set :=
| EffectEntry : effect_entry_gadt
| PureEntry : effect_entry_gadt

where &quot;'effect_entry&quot; := (fun (a : Set) =&gt; effect_entry_gadt).

Definition effect_entry := 'effect_entry.

Reserved Notation &quot;'global_declaration&quot;.

Inductive global_declaration_gadt : Set :=
| ConstantEntry : forall {a : Set},
  effect_entry a -&gt; Entries.constant_entry a -&gt; global_declaration_gadt
| GlobalRecipe : Cooking.recipe -&gt; global_declaration_gadt

where &quot;'global_declaration&quot; := (global_declaration_gadt).

Definition global_declaration := 'global_declaration.

Definition exported_private_constant :=
  Names.Constant.t * Entries.side_effect_role.

Parameter export_private_constants :
  bool -&gt; Entries.definition_entry private_constants -&gt;
  safe_transformer
    (Entries.definition_entry unit * list exported_private_constant).

Parameter add_constant :
  bool -&gt; Names.Label.t -&gt; global_declaration -&gt;
  safe_transformer Names.Constant.t.

Parameter add_mind :
  Names.Label.t -&gt; Entries.mutual_inductive_entry -&gt;
  safe_transformer Names.MutInd.t.

Parameter add_module :
  Names.Label.t -&gt; Entries.module_entry -&gt; Declarations.inline -&gt;
  safe_transformer (Names.ModPath.t * Mod_subst.delta_resolver).

Parameter add_modtype :
  Names.Label.t -&gt; Entries.module_type_entry -&gt; Declarations.inline -&gt;
  safe_transformer Names.ModPath.t.

Parameter push_context_set : bool -&gt; Univ.ContextSet.t -&gt; safe_transformer0.

Parameter add_constraints : Univ.Constraint.t -&gt; safe_transformer0.

Parameter set_engagement : Declarations.engagement -&gt; safe_transformer0.

Parameter set_indices_matter : bool -&gt; safe_transformer0.

Parameter set_typing_flags : Declarations.typing_flags -&gt; safe_transformer0.

Parameter set_share_reduction : bool -&gt; safe_transformer0.

Parameter set_VM : bool -&gt; safe_transformer0.

Parameter set_native_compiler : bool -&gt; safe_transformer0.

Parameter make_sprop_cumulative : safe_transformer0.

Parameter set_allow_sprop : bool -&gt; safe_transformer0.

Parameter check_engagement :
  Environ.env -&gt; Declarations.set_predicativity -&gt; unit.

Parameter start_module : Names.Label.t -&gt; safe_transformer Names.ModPath.t.

Parameter start_modtype : Names.Label.t -&gt; safe_transformer Names.ModPath.t.

Parameter add_module_parameter :
  Names.MBId.t -&gt; Entries.module_struct_entry -&gt; Declarations.inline -&gt;
  safe_transformer Mod_subst.delta_resolver.

Parameter allow_delayed_constants : Stdlib.ref bool.

Parameter end_module :
  Names.Label.t -&gt; option (Entries.module_struct_entry * Declarations.inline) -&gt;
  safe_transformer
    (Names.ModPath.t * list Names.MBId.t * Mod_subst.delta_resolver).

Parameter end_modtype :
  Names.Label.t -&gt; safe_transformer (Names.ModPath.t * list Names.MBId.t).

Parameter add_include :
  Entries.module_struct_entry -&gt; bool -&gt; Declarations.inline -&gt;
  safe_transformer Mod_subst.delta_resolver.

Parameter current_modpath : safe_environment -&gt; Names.ModPath.t.

Parameter current_dirpath : safe_environment -&gt; Names.DirPath.t.

Parameter compiled_library : Set.

Definition native_library := list Nativecode.global.

Parameter module_of_library : compiled_library -&gt; Declarations.module_body.

Parameter get_library_native_symbols :
  safe_environment -&gt; Names.DirPath.t -&gt; Nativecode.symbols.

Parameter start_library : Names.DirPath.t -&gt; safe_transformer Names.ModPath.t.

Parameter export :
  option Future.UUIDSet.t -&gt; bool -&gt; safe_environment -&gt; Names.DirPath.t -&gt;
  Names.ModPath.t * compiled_library * native_library.

Parameter import :
  compiled_library -&gt; Univ.ContextSet.t -&gt; vodigest -&gt;
  safe_transformer Names.ModPath.t.

Parameter judgment : Set.

Parameter j_val : judgment -&gt; Constr.constr.

Parameter j_type : judgment -&gt; Constr.constr.

Parameter typing : safe_environment -&gt; Constr.constr -&gt; judgment.

Parameter exists_objlabel : Names.Label.t -&gt; safe_environment -&gt; bool.

Parameter delta_of_senv :
  safe_environment -&gt; Mod_subst.delta_resolver * Mod_subst.delta_resolver.

Parameter constant_of_delta_kn_senv :
  safe_environment -&gt; Names.KerName.t -&gt; Names.Constant.t.

Parameter mind_of_delta_kn_senv :
  safe_environment -&gt; Names.KerName.t -&gt; Names.MutInd.t.

Parameter register_inline : Names.Constant.t -&gt; safe_transformer0.

Parameter register_inductive :
  Names.inductive -&gt; CPrimitives.prim_ind -&gt; safe_transformer0.

Parameter set_strategy :
  Names.tableKey Names.Constant.t -&gt; Conv_oracle.level -&gt; safe_transformer0.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="sorts.ml">
  <div style="margin: 20px;">
    <h3>Sorts</h3>
    <ul>
      <li>OCaml size: 160 lines</li>
      <li>Coq size: 223 lines (+39% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#sorts.ml"><code>sorts.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Univ

type family = InSProp | InProp | InSet | InType

type t =
  | SProp
  | Prop
  | Set
  | Type of Universe.t

let sprop = SProp
let prop = Prop
let set = Set
let type1 = Type type1_univ

let univ_of_sort = function
  | Type u -&gt; u
  | Set -&gt; Universe.type0
  | Prop -&gt; Universe.type0m
  | SProp -&gt; Universe.sprop

let sort_of_univ u =
  if Universe.is_sprop u then sprop
  else if is_type0m_univ u then prop
  else if is_type0_univ u then set
  else Type u

let compare s1 s2 =
  if s1 == s2 then 0 else
    match s1, s2 with
    | SProp, SProp -&gt; 0
    | SProp, _ -&gt; -1
    | _, SProp -&gt; 1
    | Prop, Prop -&gt; 0
    | Prop, _ -&gt; -1
    | Set, Prop -&gt; 1
    | Set, Set -&gt; 0
    | Set, _ -&gt; -1
    | Type u1, Type u2 -&gt; Universe.compare u1 u2
    | Type _, _ -&gt; -1

let equal s1 s2 = Int.equal (compare s1 s2) 0

let super = function
  | SProp | Prop | Set -&gt; Type (Universe.type1)
  | Type u -&gt; Type (Universe.super u)

let is_sprop = function
  | SProp -&gt; true
  | Prop | Set | Type _ -&gt; false

let is_prop = function
  | Prop -&gt; true
  | SProp | Set | Type _ -&gt; false

let is_set = function
  | Set -&gt; true
  | SProp | Prop | Type _ -&gt; false

let is_small = function
  | SProp | Prop | Set -&gt; true
  | Type _ -&gt; false

let family = function
  | SProp -&gt; InSProp
  | Prop -&gt; InProp
  | Set -&gt; InSet
  | Type _ -&gt; InType

let family_compare a b = match a,b with
  | InSProp, InSProp -&gt; 0
  | InSProp, _ -&gt; -1
  | _, InSProp -&gt; 1
  | InProp, InProp -&gt; 0
  | InProp, _ -&gt; -1
  | _, InProp -&gt; 1
  | InSet, InSet -&gt; 0
  | InSet, _ -&gt; -1
  | _, InSet -&gt; 1
  | InType, InType -&gt; 0

let family_equal = (==)

open Hashset.Combine

let hash = function
  | SProp -&gt; combinesmall 1 0
  | Prop -&gt; combinesmall 1 1
  | Set -&gt; combinesmall 1 2
  | Type u -&gt;
    let h = Univ.Universe.hash u in
    combinesmall 2 h

module List = struct
  let mem = List.memq
  let intersect l l' = CList.intersect family_equal l l'
end

module Hsorts =
  Hashcons.Make(
    struct
      type _t = t
      type t = _t
      type u = Universe.t -&gt; Universe.t

      let hashcons huniv = function
        | Type u as c -&gt;
          let u' = huniv u in
            if u' == u then c else Type u'
        | s -&gt; s
      let eq s1 s2 = match (s1,s2) with
        | Prop, Prop | Set, Set -&gt; true
        | (Type u1, Type u2) -&gt; u1 == u2
        |_ -&gt; false

      let hash = hash
    end)

let hcons = Hashcons.simple_hcons Hsorts.generate Hsorts.hcons hcons_univ

(** On binders: is this variable proof relevant *)
type relevance = Relevant | Irrelevant

let relevance_equal r1 r2 = match r1,r2 with
  | Relevant, Relevant | Irrelevant, Irrelevant -&gt; true
  | (Relevant | Irrelevant), _ -&gt; false

let relevance_of_sort_family = function
  | InSProp -&gt; Irrelevant
  | _ -&gt; Relevant

let relevance_hash = function
  | Relevant -&gt; 0
  | Irrelevant -&gt; 1

let relevance_of_sort = function
  | SProp -&gt; Irrelevant
  | _ -&gt; Relevant

let debug_print = function
  | SProp -&gt; Pp.(str &quot;SProp&quot;)
  | Prop -&gt; Pp.(str &quot;Prop&quot;)
  | Set -&gt; Pp.(str &quot;Set&quot;)
  | Type u -&gt; Pp.(str &quot;Type(&quot; ++ Univ.Universe.pr u ++ str &quot;)&quot;)

let pr_sort_family = function
  | InSProp -&gt; Pp.(str &quot;SProp&quot;)
  | InProp -&gt; Pp.(str &quot;Prop&quot;)
  | InSet -&gt; Pp.(str &quot;Set&quot;)
  | InType -&gt; Pp.(str &quot;Type&quot;)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#sorts.ml"><code>Sorts.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Univ.

Inductive family : Set :=
| InSProp : family
| InProp : family
| InSet : family
| InType : family.

Inductive t : Set :=
| SProp : t
| Prop : t
| __Set : t
| Type : Univ.Universe.t -&gt; t.

Definition sprop : t := SProp.

Definition prop : t := Prop.

Definition set : t := __Set.

Definition type1 : t := Type type1_univ.

Definition univ_of_sort (function_parameter : t) : Univ.Universe.t :=
  match function_parameter with
  | Type u =&gt; u
  | __Set =&gt; Universe.type0
  | Prop =&gt; Universe.type0m
  | SProp =&gt; Universe.sprop
  end.

Definition sort_of_univ (u : Univ.Universe.t) : t :=
  if Universe.is_sprop u then
    sprop
  else
    if is_type0m_univ u then
      prop
    else
      if is_type0_univ u then
        set
      else
        Type u.

Definition compare (s1 : t) (s2 : t) : Z :=
  if Stdlib.op_eqeq s1 s2 then
    0
  else
    match (s1, s2) with
    | (SProp, SProp) =&gt; 0
    | (SProp, _) =&gt; (-1)
    | (_, SProp) =&gt; 1
    | (Prop, Prop) =&gt; 0
    | (Prop, _) =&gt; (-1)
    | (__Set, Prop) =&gt; 1
    | (__Set, __Set) =&gt; 0
    | (__Set, _) =&gt; (-1)
    | (Type u1, Type u2) =&gt; Universe.compare u1 u2
    | (Type _, _) =&gt; (-1)
    end.

Definition equal (s1 : t) (s2 : t) : bool := Int.equal (compare s1 s2) 0.

Definition super (function_parameter : t) : t :=
  match function_parameter with
  | SProp | Prop | __Set =&gt; Type Universe.type1
  | Type u =&gt; Type (Universe.super u)
  end.

Definition is_sprop (function_parameter : t) : bool :=
  match function_parameter with
  | SProp =&gt; true
  | Prop | __Set | Type _ =&gt; false
  end.

Definition is_prop (function_parameter : t) : bool :=
  match function_parameter with
  | Prop =&gt; true
  | SProp | __Set | Type _ =&gt; false
  end.

Definition is_set (function_parameter : t) : bool :=
  match function_parameter with
  | __Set =&gt; true
  | SProp | Prop | Type _ =&gt; false
  end.

Definition is_small (function_parameter : t) : bool :=
  match function_parameter with
  | SProp | Prop | __Set =&gt; true
  | Type _ =&gt; false
  end.

Definition family (function_parameter : t) : family :=
  match function_parameter with
  | SProp =&gt; InSProp
  | Prop =&gt; InProp
  | __Set =&gt; InSet
  | Type _ =&gt; InType
  end.

Definition family_compare (a : family) (b : family) : Z :=
  match (a, b) with
  | (InSProp, InSProp) =&gt; 0
  | (InSProp, _) =&gt; (-1)
  | (_, InSProp) =&gt; 1
  | (InProp, InProp) =&gt; 0
  | (InProp, _) =&gt; (-1)
  | (_, InProp) =&gt; 1
  | (InSet, InSet) =&gt; 0
  | (InSet, _) =&gt; (-1)
  | (_, InSet) =&gt; 1
  | (InType, InType) =&gt; 0
  end.

Definition family_equal {A : Set} : A -&gt; A -&gt; bool := Stdlib.op_eqeq.

Import Hashset.Combine.

Definition hash (function_parameter : t) : Z :=
  match function_parameter with
  | SProp =&gt; combinesmall 1 0
  | Prop =&gt; combinesmall 1 1
  | __Set =&gt; combinesmall 1 2
  | Type u =&gt;
    let h := Univ.Universe.hash u in
    combinesmall 2 h
  end.

Module List.
  Definition mem {A : Set} : A -&gt; list A -&gt; bool := Stdlib.List.memq.
  
  Definition intersect {A : Set} (l : list A) (l' : list A) : list A :=
    (|CList|).(CList.ExtS.intersect) family_equal l l'.
End List.

Definition Hsorts :=
  Hashcons.Make
    (let _t := t in
    let t := _t in
    let u := Univ.Universe.t -&gt; Univ.Universe.t in
    let hashcons
      (huniv : Univ.Universe.t -&gt; Univ.Universe.t) (function_parameter : t)
      : t :=
      match function_parameter with
      | (Type u) as c =&gt;
        let u' := huniv u in
        if Stdlib.op_eqeq u' u then
          c
        else
          Type u'
      | s =&gt; s
      end in
    let eq (s1 : t) (s2 : t) : bool :=
      match (s1, s2) with
      | (Prop, Prop) | (__Set, __Set) =&gt; true
      | (Type u1, Type u2) =&gt; Stdlib.op_eqeq u1 u2
      | _ =&gt; false
      end in
    existT _ [_, _]
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}).

Definition hcons : (|Hsorts|).(Hashcons.S.t) -&gt; (|Hsorts|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|Hsorts|).(Hashcons.S.generate)
    (|Hsorts|).(Hashcons.S.hcons) hcons_univ.

Inductive relevance : Set :=
| Relevant : relevance
| Irrelevant : relevance.

Definition relevance_equal (r1 : relevance) (r2 : relevance) : bool :=
  match (r1, r2) with
  | (Relevant, Relevant) | (Irrelevant, Irrelevant) =&gt; true
  | (Relevant | Irrelevant, _) =&gt; false
  end.

Definition relevance_of_sort_family (function_parameter : family) : relevance :=
  match function_parameter with
  | InSProp =&gt; Irrelevant
  | _ =&gt; Relevant
  end.

Definition relevance_hash (function_parameter : relevance) : Z :=
  match function_parameter with
  | Relevant =&gt; 0
  | Irrelevant =&gt; 1
  end.

Definition relevance_of_sort (function_parameter : t) : relevance :=
  match function_parameter with
  | SProp =&gt; Irrelevant
  | _ =&gt; Relevant
  end.

Definition debug_print (function_parameter : t) : Pp.t :=
  match function_parameter with
  | SProp =&gt; str &quot;SProp&quot;
  | Prop =&gt; str &quot;Prop&quot;
  | __Set =&gt; str &quot;Set&quot;
  | Type u =&gt;
    op_plusplus (op_plusplus (str &quot;Type(&quot;) (Univ.Universe.pr u)) (str &quot;)&quot;)
  end.

Definition pr_sort_family (function_parameter : family) : Pp.t :=
  match function_parameter with
  | InSProp =&gt; str &quot;SProp&quot;
  | InProp =&gt; str &quot;Prop&quot;
  | InSet =&gt; str &quot;Set&quot;
  | InType =&gt; str &quot;Type&quot;
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="sorts.mli">
  <div style="margin: 20px;">
    <h3>Sorts_mli</h3>
    <ul>
      <li>OCaml size: 63 lines</li>
      <li>Coq size: 80 lines (+26% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#sorts.mli"><code>sorts.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** {6 The sorts of CCI. } *)

type family = InSProp | InProp | InSet | InType

type t = private
  | SProp
  | Prop
  | Set
  | Type of Univ.Universe.t

val sprop : t
val set  : t
val prop : t
val type1  : t

val equal : t -&gt; t -&gt; bool
val compare : t -&gt; t -&gt; int
val hash : t -&gt; int

val is_sprop : t -&gt; bool
val is_set : t -&gt; bool
val is_prop : t -&gt; bool
val is_small : t -&gt; bool
val family : t -&gt; family

val hcons : t -&gt; t

val family_compare : family -&gt; family -&gt; int
val family_equal : family -&gt; family -&gt; bool

module List : sig
  val mem : family -&gt; family list -&gt; bool
  val intersect : family list -&gt; family list -&gt; family list
end

val univ_of_sort : t -&gt; Univ.Universe.t
val sort_of_univ : Univ.Universe.t -&gt; t

val super : t -&gt; t

(** On binders: is this variable proof relevant *)
type relevance = Relevant | Irrelevant

val relevance_hash : relevance -&gt; int

val relevance_equal : relevance -&gt; relevance -&gt; bool

val relevance_of_sort : t -&gt; relevance
val relevance_of_sort_family : family -&gt; relevance

val debug_print : t -&gt; Pp.t

val pr_sort_family : family -&gt; Pp.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#sorts.mli"><code>Sorts_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Inductive family : Set :=
| InSProp : family
| InProp : family
| InSet : family
| InType : family.

Inductive t : Set :=
| SProp : t
| Prop : t
| __Set : t
| Type : Univ.Universe.t -&gt; t.

Parameter sprop : t.

Parameter set : t.

Parameter prop : t.

Parameter type1 : t.

Parameter equal : t -&gt; t -&gt; bool.

Parameter compare : t -&gt; t -&gt; Z.

Parameter hash : t -&gt; Z.

Parameter is_sprop : t -&gt; bool.

Parameter is_set : t -&gt; bool.

Parameter is_prop : t -&gt; bool.

Parameter is_small : t -&gt; bool.

Parameter family : t -&gt; family.

Parameter hcons : t -&gt; t.

Parameter family_compare : family -&gt; family -&gt; Z.

Parameter family_equal : family -&gt; family -&gt; bool.

Module List.
  Parameter mem : family -&gt; list family -&gt; bool.
  
  Parameter intersect : list family -&gt; list family -&gt; list family.
End List.

Parameter univ_of_sort : t -&gt; Univ.Universe.t.

Parameter sort_of_univ : Univ.Universe.t -&gt; t.

Parameter super : t -&gt; t.

Inductive relevance : Set :=
| Relevant : relevance
| Irrelevant : relevance.

Parameter relevance_hash : relevance -&gt; Z.

Parameter relevance_equal : relevance -&gt; relevance -&gt; bool.

Parameter relevance_of_sort : t -&gt; relevance.

Parameter relevance_of_sort_family : family -&gt; relevance.

Parameter debug_print : t -&gt; Pp.t.

Parameter pr_sort_family : family -&gt; Pp.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="subtyping.ml">
  <div style="margin: 20px;">
    <h3>Subtyping</h3>
    <ul>
      <li>OCaml size: 353 lines</li>
      <li>Coq size: 503 lines (+42% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#subtyping.ml"><code>subtyping.ml</code></a>&nbsp;<span class="label label-warning">15 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)

(* This module checks subtyping of module types *)

(*i*)
open Names
open Univ
open Util
open Constr
open Declarations
open Declareops
open Reduction
open Inductive
open Modops
open Context
open Mod_subst
(*i*)

(* This local type is used to subtype a constant with a constructor or
   an inductive type. It can also be useful to allow reorderings in
   inductive types *)
type namedobject =
  | Constant of constant_body
  | IndType of inductive * mutual_inductive_body
  | IndConstr of constructor * mutual_inductive_body

type namedmodule =
  | Module of module_body
  | Modtype of module_type_body

(* adds above information about one mutual inductive: all types and
   constructors *)

let add_mib_nameobjects mp l mib map =
  let ind = MutInd.make2 mp l in
  let add_mip_nameobjects j oib map =
    let ip = (ind,j) in
    let map =
      Array.fold_right_i
      (fun i id map -&gt;
        Label.Map.add (Label.of_id id) (IndConstr((ip,i+1), mib)) map)
      oib.mind_consnames
      map
    in
      Label.Map.add (Label.of_id oib.mind_typename) (IndType (ip, mib)) map
  in
  Array.fold_right_i add_mip_nameobjects mib.mind_packets map


(* creates (namedobject/namedmodule) map for the whole signature *)

type labmap = { objs : namedobject Label.Map.t; mods : namedmodule Label.Map.t }

let empty_labmap = { objs = Label.Map.empty; mods = Label.Map.empty }

let get_obj mp map l =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Label.Map.find l map.objs
  with Not_found -&gt; error_no_such_label_sub l (ModPath.to_string mp)</abbr>

let get_mod mp map l =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Label.Map.find l map.mods
  with Not_found -&gt; error_no_such_label_sub l (ModPath.to_string mp)</abbr>

let make_labmap mp list =
  let add_one (l,e) map =
   match e with
    | SFBconst cb -&gt; { map with objs = Label.Map.add l (Constant cb) map.objs }
    | SFBmind mib -&gt; { map with objs = add_mib_nameobjects mp l mib map.objs }
    | SFBmodule mb -&gt; { map with mods = Label.Map.add l (Module mb) map.mods }
    | SFBmodtype mtb -&gt; { map with mods = Label.Map.add l (Modtype mtb) map.mods }
  in
  CList.fold_right add_one list empty_labmap


let check_conv_error error why cst poly f env a1 a2 =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let cst' = f env (Environ.universes env) a1 a2 in
      if poly then
        if Constraint.is_empty cst' then cst
        else error (IncompatiblePolymorphism (env, a1, a2))
      else Constraint.union cst cst'
  with NotConvertible -&gt; error why
     | Univ.UniverseInconsistency e -&gt; error (IncompatibleUniverses e)</abbr>

let check_universes error env u1 u2 =
  match u1, u2 with
  | Monomorphic _, Monomorphic _ -&gt; env
  | Polymorphic auctx1, Polymorphic auctx2 -&gt;
    let lbound = Environ.universes_lbound env in
    if not (UGraph.check_subtype ~lbound (Environ.universes env) auctx2 auctx1) then
      error (IncompatibleConstraints { got = auctx1; expect = auctx2; } )
    else
      Environ.push_context ~strict:false (Univ.AUContext.repr auctx2) env
  | Monomorphic _, Polymorphic _ -&gt; error (PolymorphicStatusExpected true)
  | Polymorphic _, Monomorphic _ -&gt; error (PolymorphicStatusExpected false)

let check_variance error v1 v2 =
  match v1, v2 with
  | None, None -&gt; ()
  | Some v1, Some v2 -&gt;
    if not (Array.for_all2 Variance.check_subtype v2 v1) then
      error IncompatibleVariance
  | None, Some _ -&gt; error (CumulativeStatusExpected true)
  | Some _, None -&gt; error (CumulativeStatusExpected false)

(* for now we do not allow reorderings *)

let check_inductive cst env mp1 l info1 mp2 mib2 spec2 subst1 subst2 reso1 reso2=
  let kn1 = KerName.make mp1 l in
  let kn2 = KerName.make mp2 l in
  let error why = error_signature_mismatch l spec2 why in
  let check_conv why cst poly f = check_conv_error error why cst poly f in
  let mib1 =
    match info1 with
      | IndType ((_,0), mib) -&gt; Declareops.subst_mind_body subst1 mib
      | _ -&gt; error (InductiveFieldExpected mib2)
  in
  let env = check_universes error env mib1.mind_universes mib2.mind_universes in
  let () = check_variance error mib1.mind_variance mib2.mind_variance in
  let inst = make_abstract_instance (Declareops.inductive_polymorphic_context mib1) in
  let mib2 =  Declareops.subst_mind_body subst2 mib2 in
  let check_inductive_type cst name t1 t2 =
    check_conv (NotConvertibleInductiveField name)
      cst (inductive_is_polymorphic mib1) (infer_conv_leq ?l2r:None ?evars:None ?ts:None) env t1 t2
  in

  let check_packet cst p1 p2 =
    let check f test why = if not (test (f p1) (f p2)) then error why in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (fun p -&gt; p.mind_consnames) (Array.equal Id.equal) NotSameConstructorNamesField;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (fun p -&gt; p.mind_typename) Id.equal NotSameInductiveNameInBlockField;
      (* nf_lc later *)
      (* nf_arity later *)
      (* user_lc ignored *)
      (* user_arity ignored *)
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (fun p -&gt; p.mind_nrealargs) Int.equal (NotConvertibleInductiveField p2.mind_typename); (* How can it fail since the type of inductive are checked below? [HH] *)
      (* kelim ignored *)
      (* listrec ignored *)
      (* finite done *)
      (* nparams done *)
      (* params_ctxt done because part of the inductive types *)
      (* Don't check the sort of the type if polymorphic *)
      let ty1 = type_of_inductive env ((mib1, p1), inst) in
      let ty2 = type_of_inductive env ((mib2, p2), inst) in
      let cst = check_inductive_type cst p2.mind_typename ty1 ty2 in
        cst</abbr>
  in
  let mind = MutInd.make1 kn1 in
  let check_cons_types _i cst p1 p2 =
    Array.fold_left3
      (fun cst id t1 t2 -&gt; check_conv (NotConvertibleConstructorField id) cst
        (inductive_is_polymorphic mib1) (infer_conv ?l2r:None ?evars:None ?ts:None) env t1 t2)
      cst
      p2.mind_consnames
      (arities_of_specif (mind, inst) (mib1, p1))
      (arities_of_specif (mind, inst) (mib2, p2))
  in
  let check f test why = if not (test (f mib1) (f mib2)) then error (why (f mib2)) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (fun mib -&gt; mib.mind_finite&lt;&gt;CoFinite) (==) (fun x -&gt; FiniteInductiveFieldExpected x);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (fun mib -&gt; mib.mind_ntypes) Int.equal (fun x -&gt; InductiveNumbersFieldExpected x);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (List.is_empty mib1.mind_hyps &amp;&amp; List.is_empty mib2.mind_hyps);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Array.length mib1.mind_packets &gt;= 1
            &amp;&amp; Array.length mib2.mind_packets &gt;= 1);

  (* Check that the expected numbers of uniform parameters are the same *)
  (* No need to check the contexts of parameters: it is checked *)
  (* at the time of checking the inductive arities in check_packet. *)
  (* Notice that we don't expect the local definitions to match: only *)
  (* the inductive types and constructors types have to be convertible *)
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (fun mib -&gt; mib.mind_nparams) Int.equal (fun x -&gt; InductiveParamsNumberField x);

  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
    let kn2' = kn_of_delta reso2 kn2 in
    if KerName.equal kn2 kn2' ||
       MutInd.equal (mind_of_delta_kn reso1 kn1)
                    (subst_mind subst2 (MutInd.make kn2 kn2'))
    then ()
    else error NotEqualInductiveAliases
  end;
  (* we check that records and their field names are preserved. *)
  (** FIXME: this check looks nonsense *)
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check (fun mib -&gt; mib.mind_record &lt;&gt; NotRecord) (==) (fun x -&gt; RecordFieldExpected x);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if mib1.mind_record &lt;&gt; NotRecord then begin
    let rec names_prod_letin t = match kind t with
      | Prod(n,_,t) -&gt; n.binder_name::(names_prod_letin t)
      | LetIn(n,_,_,t) -&gt; n.binder_name::(names_prod_letin t)
      | Cast(t,_,_) -&gt; names_prod_letin t
      | _ -&gt; []
    in
    assert (Int.equal (Array.length mib1.mind_packets) 1);
    assert (Int.equal (Array.length mib2.mind_packets) 1);
    assert (Int.equal (Array.length mib1.mind_packets.(0).mind_user_lc) 1);
    assert (Int.equal (Array.length mib2.mind_packets.(0).mind_user_lc) 1);
    check (fun mib -&gt;
      let nparamdecls = List.length mib.mind_params_ctxt in
      let names = names_prod_letin (mib.mind_packets.(0).mind_user_lc.(0)) in
      snd (List.chop nparamdecls names)) (List.equal Name.equal)
      (fun x -&gt; RecordProjectionsExpected x);
  end;
  (* we first check simple things *)
  let cst =
    Array.fold_left2 check_packet cst mib1.mind_packets mib2.mind_packets
  in
  (* and constructor types in the end *)
  let cst =
    Array.fold_left2_i check_cons_types cst mib1.mind_packets mib2.mind_packets
  in
    cst</abbr>


let check_constant cst env l info1 cb2 spec2 subst1 subst2 =
  let error why = error_signature_mismatch l spec2 why in
  let check_conv cst poly f = check_conv_error error cst poly f in
  let check_type poly cst env t1 t2 =
    let err = NotConvertibleTypeField (env, t1, t2) in
    check_conv err cst poly (infer_conv_leq ?l2r:None ?evars:None ?ts:None) env t1 t2
  in
  match info1 with
    | Constant cb1 -&gt;
      let () = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (List.is_empty cb1.const_hyps &amp;&amp; List.is_empty cb2.const_hyps)</abbr> in
      let cb1 = Declareops.subst_const_body subst1 cb1 in
      let cb2 = Declareops.subst_const_body subst2 cb2 in
      (* Start by checking universes *)
      let env = check_universes error env cb1.const_universes cb2.const_universes in
      let poly = Declareops.constant_is_polymorphic cb1 in
      (* Now check types *)
      let typ1 = cb1.const_type in
      let typ2 = cb2.const_type in
      let cst = check_type poly cst env typ1 typ2 in
      (* Now we check the bodies:
         - A transparent constant can only be implemented by a compatible
           transparent constant.
         - In the signature, an opaque is handled just as a parameter:
           anything of the right type can implement it, even if bodies differ.
      *)
      (match cb2.const_body with
        | Primitive _ | Undef _ | OpaqueDef _ -&gt; cst
        | Def lc2 -&gt;
          (match cb1.const_body with
            | Primitive _ | Undef _ | OpaqueDef _ -&gt; error NotConvertibleBodyField
            | Def lc1 -&gt;
              (* NB: cb1 might have been strengthened and appear as transparent.
                 Anyway [check_conv] will handle that afterwards. *)
              let c1 = Mod_subst.force_constr lc1 in
              let c2 = Mod_subst.force_constr lc2 in
              check_conv NotConvertibleBodyField cst poly (infer_conv ?l2r:None ?evars:None ?ts:None) env c1 c2))
   | IndType ((_kn,_i),_mind1) -&gt;
       CErrors.user_err Pp.(str @@
       &quot;The kernel does not recognize yet that a parameter can be &quot; ^
       &quot;instantiated by an inductive type. Hint: you can rename the &quot; ^
       &quot;inductive type and give a definition to map the old name to the new &quot; ^
       &quot;name.&quot;)
   | IndConstr (((_kn,_i),_j),_mind1) -&gt;
      CErrors.user_err Pp.(str @@
       &quot;The kernel does not recognize yet that a parameter can be &quot; ^
       &quot;instantiated by a constructor. Hint: you can rename the &quot; ^
       &quot;constructor and give a definition to map the old name to the new &quot; ^
       &quot;name.&quot;)

let rec check_modules cst env msb1 msb2 subst1 subst2 =
  let mty1 = module_type_of_module msb1 in
  let mty2 =  module_type_of_module msb2 in
  check_modtypes cst env mty1 mty2 subst1 subst2 false

and check_signatures cst env mp1 sig1 mp2 sig2 subst1 subst2 reso1 reso2=
  let map1 = make_labmap mp1 sig1 in
  let check_one_body cst (l,spec2) =
    match spec2 with
        | SFBconst cb2 -&gt;
            check_constant cst env l (get_obj mp1 map1 l)
              cb2 spec2 subst1 subst2
        | SFBmind mib2 -&gt;
            check_inductive cst env mp1 l (get_obj mp1 map1 l)
              mp2 mib2 spec2 subst1 subst2 reso1 reso2
        | SFBmodule msb2 -&gt;
            begin match get_mod mp1 map1 l with
              | Module msb -&gt; check_modules cst env msb msb2 subst1 subst2
              | _ -&gt; error_signature_mismatch l spec2 ModuleFieldExpected
            end
        | SFBmodtype mtb2 -&gt;
            let mtb1 = match get_mod mp1 map1 l with
              | Modtype mtb -&gt; mtb
              | _ -&gt; error_signature_mismatch l spec2 ModuleTypeFieldExpected
            in
            let env =
              add_module_type mtb2.mod_mp mtb2
                (add_module_type mtb1.mod_mp mtb1 env)
            in
            check_modtypes cst env mtb1 mtb2 subst1 subst2 true
  in
    List.fold_left check_one_body cst sig2

and check_modtypes cst env mtb1 mtb2 subst1 subst2 equiv =
  if mtb1==mtb2 || mtb1.mod_type == mtb2.mod_type then cst
  else
    let rec check_structure cst env str1 str2 equiv subst1 subst2 =
      match str1,str2 with
      |NoFunctor list1,
       NoFunctor list2 -&gt;
        if equiv then
          let subst2 = add_mp mtb2.mod_mp mtb1.mod_mp mtb1.mod_delta subst2 in
          let cst1 = check_signatures cst env
            mtb1.mod_mp list1 mtb2.mod_mp list2 subst1 subst2
            mtb1.mod_delta mtb2.mod_delta
          in
          let cst2 = check_signatures cst env
            mtb2.mod_mp list2 mtb1.mod_mp list1 subst2 subst1
            mtb2.mod_delta  mtb1.mod_delta
          in
          Univ.Constraint.union cst1 cst2
        else
          check_signatures cst env
            mtb1.mod_mp list1 mtb2.mod_mp list2 subst1 subst2
            mtb1.mod_delta  mtb2.mod_delta
      |MoreFunctor (arg_id1,arg_t1,body_t1),
       MoreFunctor (arg_id2,arg_t2,body_t2) -&gt;
        let mp2 = MPbound arg_id2 in
        let subst1 = join (map_mbid arg_id1 mp2 arg_t2.mod_delta) subst1 in
        let cst = check_modtypes cst env arg_t2 arg_t1 subst2 subst1 equiv in
        (* contravariant *)
        let env = add_module_type mp2 arg_t2 env in
        let env =
          if Modops.is_functor body_t1 then env
          else add_module
            {mod_mp = mtb1.mod_mp;
             mod_expr = Abstract;
             mod_type = subst_signature subst1 body_t1;
             mod_type_alg = None;
             mod_constraints = mtb1.mod_constraints;
             mod_retroknowledge = ModBodyRK [];
             mod_delta = mtb1.mod_delta} env
        in
        check_structure cst env body_t1 body_t2 equiv subst1 subst2
      | _ , _ -&gt; error_incompatible_modtypes mtb1 mtb2
    in
    check_structure cst env mtb1.mod_type mtb2.mod_type equiv subst1 subst2

let check_subtypes env sup super =
  let env = add_module_type sup.mod_mp sup env in
  let env = Environ.push_context_set ~strict:true super.mod_constraints env in
  check_modtypes Univ.Constraint.empty env
    (strengthen sup sup.mod_mp) super empty_subst
    (map_mp super.mod_mp sup.mod_mp sup.mod_delta) false

</pre>
  </div>
  <div class="col-md-6">
    <a href="#subtyping.ml"><code>Subtyping.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Univ.

Import Util.

Import Constr.

Import Declarations.

Import Declareops.

Import Reduction.

Import Inductive.

Import Modops.

Import Context.

Import Mod_subst.

Inductive namedobject : Set :=
| Constant : Declarations.constant_body -&gt; namedobject
| IndType : Names.inductive -&gt; Declarations.mutual_inductive_body -&gt; namedobject
| IndConstr :
  Names.constructor -&gt; Declarations.mutual_inductive_body -&gt; namedobject.

Inductive namedmodule : Set :=
| Module : Declarations.module_body -&gt; namedmodule
| Modtype : Declarations.module_type_body -&gt; namedmodule.

Definition add_mib_nameobjects
  (mp : Names.ModPath.t) (l : Names.Label.t)
  (mib : Declarations.mutual_inductive_body)
  (map : Names.Label.Map.t namedobject) : Names.Label.Map.t namedobject :=
  let ind := MutInd.make2 mp l in
  let add_mip_nameobjects
    (j : Z) (oib : Declarations.one_inductive_body)
    (map : Names.Label.Map.t namedobject) : Names.Label.Map.t namedobject :=
    let ip := (ind, j) in
    let map :=
      (|Util.Array|).(CArray.ExtS.fold_right_i)
        (fun i =&gt;
          fun id =&gt;
            fun map =&gt;
              Label.Map.add (Label.of_id id) (IndConstr (ip, (Z.add i 1)) mib)
                map) (Declarations.one_inductive_body.mind_consnames oib) map in
    Label.Map.add
      (Label.of_id (Declarations.one_inductive_body.mind_typename oib))
      (IndType ip mib) map in
  (|Util.Array|).(CArray.ExtS.fold_right_i) add_mip_nameobjects
    (Declarations.mutual_inductive_body.mind_packets mib) map.

Module labmap.
  Record record := {
    objs : Names.Label.Map.t namedobject;
    mods : Names.Label.Map.t namedmodule }.
  Definition with_objs (r : record) objs : record :=
    {| objs := objs; mods := mods r |}.
  Definition with_mods (r : record) mods : record :=
    {| objs := objs r; mods := mods |}.
End labmap.
Definition labmap := labmap.record.

Definition empty_labmap : labmap :=
  {| labmap.objs := Label.Map.empty; labmap.mods := Label.Map.empty |}.

Definition get_obj
  (mp : Names.ModPath.t) (map : labmap) (l : Names.Label.Map.key)
  : namedobject :=
  (* ❌ Try-with are not handled *)
  try (Label.Map.find l (labmap.objs map)).

Definition get_mod
  (mp : Names.ModPath.t) (map : labmap) (l : Names.Label.Map.key)
  : namedmodule :=
  (* ❌ Try-with are not handled *)
  try (Label.Map.find l (labmap.mods map)).

Definition make_labmap
  (mp : Names.ModPath.t)
  (__list_value : list (Names.Label.Map.key * Declarations.structure_field_body))
  : labmap :=
  let add_one
    (function_parameter :
      Names.Label.Map.key * Declarations.structure_field_body)
    : labmap -&gt; labmap :=
    let '(l, e) := function_parameter in
    fun map =&gt;
      match e with
      | Declarations.SFBconst cb =&gt;
        labmap.with_objs map (Label.Map.add l (Constant cb) (labmap.objs map))
      | Declarations.SFBmind mib =&gt;
        labmap.with_objs map (add_mib_nameobjects mp l mib (labmap.objs map))
      | Declarations.SFBmodule mb =&gt;
        labmap.with_mods map (Label.Map.add l (Module mb) (labmap.mods map))
      | Declarations.SFBmodtype mtb =&gt;
        labmap.with_mods map (Label.Map.add l (Modtype mtb) (labmap.mods map))
      end in
  (|CList|).(CList.ExtS.fold_right) add_one __list_value empty_labmap.

Definition check_conv_error
  (__error : Modops.signature_mismatch_error -&gt; Univ.Constraint.t)
  (why : Modops.signature_mismatch_error) (cst : Univ.Constraint.t)
  (poly : bool)
  (f :
    Environ.env -&gt; UGraph.t -&gt; Constr.types -&gt; Constr.types -&gt; Univ.Constraint.t)
  (env : Environ.env) (a1 : Constr.types) (a2 : Constr.types)
  : Univ.Constraint.t :=
  (* ❌ Try-with are not handled *)
  try
    (let cst' := f env (Environ.universes env) a1 a2 in
    if poly then
      if Constraint.is_empty cst' then
        cst
      else
        __error (Modops.IncompatiblePolymorphism env a1 a2)
    else
      Constraint.union cst cst').

Definition check_universes
  (__error : Modops.signature_mismatch_error -&gt; Environ.env) (env : Environ.env)
  (u1 : Declarations.universes) (u2 : Declarations.universes) : Environ.env :=
  match (u1, u2) with
  | (Declarations.Monomorphic _, Declarations.Monomorphic _) =&gt; env
  | (Declarations.Polymorphic auctx1, Declarations.Polymorphic auctx2) =&gt;
    let lbound := Environ.universes_lbound env in
    if negb (UGraph.check_subtype lbound (Environ.universes env) auctx2 auctx1)
      then
      __error
        (Modops.IncompatibleConstraints
          {|
            Modops.signature_mismatch_error.IncompatibleConstraints.got :=
              auctx1;
            Modops.signature_mismatch_error.IncompatibleConstraints.expect :=
              auctx2 |})
    else
      Environ.push_context (Some false) (Univ.AUContext.repr auctx2) env
  | (Declarations.Monomorphic _, Declarations.Polymorphic _) =&gt;
    __error (Modops.PolymorphicStatusExpected true)
  | (Declarations.Polymorphic _, Declarations.Monomorphic _) =&gt;
    __error (Modops.PolymorphicStatusExpected false)
  end.

Definition check_variance
  (__error : Modops.signature_mismatch_error -&gt; unit)
  (v1 : option (array Univ.Variance.t)) (v2 : option (array Univ.Variance.t))
  : unit :=
  match (v1, v2) with
  | (None, None) =&gt; tt
  | (Some v1, Some v2) =&gt;
    if negb ((|Util.Array|).(CArray.ExtS.for_all2) Variance.check_subtype v2 v1)
      then
      __error Modops.IncompatibleVariance
    else
      tt
  | (None, Some _) =&gt; __error (Modops.CumulativeStatusExpected true)
  | (Some _, None) =&gt; __error (Modops.CumulativeStatusExpected false)
  end.

Definition check_inductive
  (cst : Univ.Constraint.t) (env : Environ.env) (mp1 : Names.ModPath.t)
  (l : Names.Label.t) (info1 : namedobject) (mp2 : Names.ModPath.t)
  (mib2 : Declarations.mutual_inductive_body)
  (spec2 : Declarations.structure_field_body) (subst1 : Mod_subst.substitution)
  (subst2 : Mod_subst.substitution) (reso1 : Mod_subst.delta_resolver)
  (reso2 : Mod_subst.delta_resolver) : Univ.Constraint.t :=
  let kn1 := KerName.make mp1 l in
  let kn2 := KerName.make mp2 l in
  let __error {A : Set} (why : Modops.signature_mismatch_error) : A :=
    error_signature_mismatch l spec2 why in
  let check_conv
    (why : Modops.signature_mismatch_error) (cst : Univ.Constraint.t)
    (poly : bool)
    (f :
      Environ.env -&gt; UGraph.t -&gt; Constr.types -&gt; Constr.types -&gt;
      Univ.Constraint.t)
    : Environ.env -&gt; Constr.types -&gt; Constr.types -&gt; Univ.Constraint.t :=
    check_conv_error __error why cst poly f in
  let mib1 :=
    match info1 with
    | IndType (_, 0) mib =&gt; Declareops.subst_mind_body subst1 mib
    | _ =&gt; __error (Modops.InductiveFieldExpected mib2)
    end in
  let env :=
    check_universes __error env
      (Declarations.mutual_inductive_body.mind_universes mib1)
      (Declarations.mutual_inductive_body.mind_universes mib2) in
  let '_ :=
    check_variance __error
      (Declarations.mutual_inductive_body.mind_variance mib1)
      (Declarations.mutual_inductive_body.mind_variance mib2) in
  let inst :=
    make_abstract_instance (Declareops.inductive_polymorphic_context mib1) in
  let mib2 := Declareops.subst_mind_body subst2 mib2 in
  let check_inductive_type
    (cst : Univ.Constraint.t) (name : Names.Id.t) (t1 : Constr.types)
    (t2 : Constr.types) : Univ.Constraint.t :=
    check_conv (Modops.NotConvertibleInductiveField name) cst
      (inductive_is_polymorphic mib1) (infer_conv_leq None None None) env t1 t2
    in
  let check_packet
    (cst : Univ.Constraint.t) (p1 : Declarations.one_inductive_body)
    (p2 : Declarations.one_inductive_body) : Univ.Constraint.t :=
    let check {A : Set}
      (f : Declarations.one_inductive_body -&gt; A) (test : A -&gt; A -&gt; bool)
      (why : Modops.signature_mismatch_error) : unit :=
      if negb (test (f p1) (f p2)) then
        __error why
      else
        tt in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let ty1 := type_of_inductive env ((mib1, p1), inst) in
    let ty2 := type_of_inductive env ((mib2, p2), inst) in
    let cst :=
      check_inductive_type cst
        (Declarations.one_inductive_body.mind_typename p2) ty1 ty2 in
    cst in
  let mind := MutInd.make1 kn1 in
  let check_cons_types {A : Set}
    (_i : A) (cst : Univ.Constraint.t) (p1 : Declarations.one_inductive_body)
    (p2 : Declarations.one_inductive_body) : Univ.Constraint.t :=
    (|Util.Array|).(CArray.ExtS.fold_left3)
      (fun cst =&gt;
        fun id =&gt;
          fun t1 =&gt;
            fun t2 =&gt;
              check_conv (Modops.NotConvertibleConstructorField id) cst
                (inductive_is_polymorphic mib1) (infer_conv None None None) env
                t1 t2) cst (Declarations.one_inductive_body.mind_consnames p2)
      (arities_of_specif (mind, inst) (mib1, p1))
      (arities_of_specif (mind, inst) (mib2, p2)) in
  let check {A : Set}
    (f : Declarations.mutual_inductive_body -&gt; A) (test : A -&gt; A -&gt; bool)
    (why : A -&gt; Modops.signature_mismatch_error) : unit :=
    if negb (test (f mib1) (f mib2)) then
      __error (why (f mib2))
    else
      tt in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let cst :=
    (|Util.Array|).(CArray.ExtS.fold_left2) check_packet cst
      (Declarations.mutual_inductive_body.mind_packets mib1)
      (Declarations.mutual_inductive_body.mind_packets mib2) in
  let cst :=
    (|Util.Array|).(CArray.ExtS.fold_left2_i) check_cons_types cst
      (Declarations.mutual_inductive_body.mind_packets mib1)
      (Declarations.mutual_inductive_body.mind_packets mib2) in
  cst.

Definition check_constant
  (cst : Univ.Constraint.t) (env : Environ.env) (l : Names.Label.t)
  (info1 : namedobject) (cb2 : Declarations.constant_body)
  (spec2 : Declarations.structure_field_body) (subst1 : Mod_subst.substitution)
  (subst2 : Mod_subst.substitution) : Univ.Constraint.t :=
  let __error {A : Set} (why : Modops.signature_mismatch_error) : A :=
    error_signature_mismatch l spec2 why in
  let check_conv
    (cst : Modops.signature_mismatch_error) (poly : Univ.Constraint.t)
    (f : bool)
    : (Environ.env -&gt; UGraph.t -&gt; Constr.types -&gt; Constr.types -&gt;
    Univ.Constraint.t) -&gt; Environ.env -&gt; Constr.types -&gt; Constr.types -&gt;
    Univ.Constraint.t :=
    check_conv_error __error cst poly f in
  let check_type
    (poly : bool) (cst : Univ.Constraint.t) (env : Environ.env)
    (t1 : Constr.types) (t2 : Constr.types) : Univ.Constraint.t :=
    let err := Modops.NotConvertibleTypeField env t1 t2 in
    check_conv err cst poly (infer_conv_leq None None None) env t1 t2 in
  match info1 with
  | Constant cb1 =&gt;
    let '_ :=
      (* ❌ Assert instruction is not handled. *)
      assert
        (andb
          ((|Util.List|).(CList.ExtS.is_empty)
            (Declarations.constant_body.const_hyps cb1))
          ((|Util.List|).(CList.ExtS.is_empty)
            (Declarations.constant_body.const_hyps cb2))) in
    let cb1 := Declareops.subst_const_body subst1 cb1 in
    let cb2 := Declareops.subst_const_body subst2 cb2 in
    let env :=
      check_universes __error env
        (Declarations.constant_body.const_universes cb1)
        (Declarations.constant_body.const_universes cb2) in
    let poly := Declareops.constant_is_polymorphic cb1 in
    let typ1 := Declarations.constant_body.const_type cb1 in
    let typ2 := Declarations.constant_body.const_type cb2 in
    let cst := check_type poly cst env typ1 typ2 in
    match Declarations.constant_body.const_body cb2 with
    | Declarations.Primitive _ | Declarations.Undef _ | Declarations.OpaqueDef _
      =&gt; cst
    | Declarations.Def lc2 =&gt;
      match Declarations.constant_body.const_body cb1 with
      |
        Declarations.Primitive _ | Declarations.Undef _ |
        Declarations.OpaqueDef _ =&gt; __error Modops.NotConvertibleBodyField
      | Declarations.Def lc1 =&gt;
        let c1 := Mod_subst.force_constr lc1 in
        let c2 := Mod_subst.force_constr lc2 in
        check_conv Modops.NotConvertibleBodyField cst poly
          (infer_conv None None None) env c1 c2
      end
    end
  | IndType (_kn, _i) _mind1 =&gt;
    CErrors.user_err None None
      (apply str
        (String.append
          &quot;The kernel does not recognize yet that a parameter can be &quot;
          (String.append
            &quot;instantiated by an inductive type. Hint: you can rename the &quot;
            (String.append
              &quot;inductive type and give a definition to map the old name to the new &quot;
              &quot;name.&quot;))))
  | IndConstr ((_kn, _i), _j) _mind1 =&gt;
    CErrors.user_err None None
      (apply str
        (String.append
          &quot;The kernel does not recognize yet that a parameter can be &quot;
          (String.append
            &quot;instantiated by a constructor. Hint: you can rename the &quot;
            (String.append
              &quot;constructor and give a definition to map the old name to the new &quot;
              &quot;name.&quot;))))
  end.

Fixpoint check_modules
  (cst : Univ.Constraint.t) (env : Environ.env)
  (msb1 : Declarations.module_body) (msb2 : Declarations.module_body)
  (subst1 : Mod_subst.substitution) (subst2 : Mod_subst.substitution)
  {struct cst} : Univ.Constraint.t :=
  let mty1 := module_type_of_module msb1 in
  let mty2 := module_type_of_module msb2 in
  check_modtypes cst env mty1 mty2 subst1 subst2 false

with check_signatures
  (cst : Univ.Constraint.t) (env : Environ.env) (mp1 : Names.ModPath.t)
  (sig1 : list (Names.Label.Map.key * Declarations.structure_field_body))
  (mp2 : Names.ModPath.t)
  (sig2 : list (Names.Label.Map.key * Declarations.structure_field_body))
  (subst1 : Mod_subst.substitution) (subst2 : Mod_subst.substitution)
  (reso1 : Mod_subst.delta_resolver) (reso2 : Mod_subst.delta_resolver)
  {struct cst} : Univ.Constraint.t :=
  let map1 := make_labmap mp1 sig1 in
  let check_one_body
    (cst : Univ.Constraint.t)
    (function_parameter :
      Names.Label.Map.key * Declarations.structure_field_body)
    : Univ.Constraint.t :=
    let '(l, spec2) := function_parameter in
    match spec2 with
    | Declarations.SFBconst cb2 =&gt;
      check_constant cst env l (get_obj mp1 map1 l) cb2 spec2 subst1 subst2
    | Declarations.SFBmind mib2 =&gt;
      check_inductive cst env mp1 l (get_obj mp1 map1 l) mp2 mib2 spec2 subst1
        subst2 reso1 reso2
    | Declarations.SFBmodule msb2 =&gt;
      match get_mod mp1 map1 l with
      | Module msb =&gt; check_modules cst env msb msb2 subst1 subst2
      | _ =&gt; error_signature_mismatch l spec2 Modops.ModuleFieldExpected
      end
    | Declarations.SFBmodtype mtb2 =&gt;
      let mtb1 :=
        match get_mod mp1 map1 l with
        | Modtype mtb =&gt; mtb
        | _ =&gt; error_signature_mismatch l spec2 Modops.ModuleTypeFieldExpected
        end in
      let env :=
        add_module_type (Declarations.generic_module_body.mod_mp mtb2) mtb2
          (add_module_type (Declarations.generic_module_body.mod_mp mtb1) mtb1
            env) in
      check_modtypes cst env mtb1 mtb2 subst1 subst2 true
    end in
  (|Util.List|).(CList.ExtS.fold_left) check_one_body cst sig2

with check_modtypes
  (cst : Univ.Constraint.t) (env : Environ.env)
  (mtb1 : Declarations.module_type_body) (mtb2 : Declarations.module_type_body)
  (subst1 : Mod_subst.substitution) (subst2 : Mod_subst.substitution)
  (equiv : bool) {struct cst} : Univ.Constraint.t :=
  if
    orb (Stdlib.op_eqeq mtb1 mtb2)
      (Stdlib.op_eqeq (Declarations.generic_module_body.mod_type mtb1)
        (Declarations.generic_module_body.mod_type mtb2)) then
    cst
  else
    let fix check_structure
      (cst : Univ.Constraint.t) (env : Environ.env)
      (str1 :
        Declarations.functorize Declarations.module_type_body
          Declarations.structure_body)
      (str2 :
        Declarations.functorize Declarations.module_type_body
          (list (Names.Label.Map.key * Declarations.structure_field_body)))
      (equiv : bool) (subst1 : Mod_subst.substitution)
      (subst2 : Mod_subst.substitution) {struct cst} : Univ.Constraint.t :=
      match (str1, str2) with
      | (Declarations.NoFunctor list1, Declarations.NoFunctor list2) =&gt;
        if equiv then
          let subst2 :=
            add_mp (Declarations.generic_module_body.mod_mp mtb2)
              (Declarations.generic_module_body.mod_mp mtb1)
              (Declarations.generic_module_body.mod_delta mtb1) subst2 in
          let cst1 :=
            check_signatures cst env
              (Declarations.generic_module_body.mod_mp mtb1) list1
              (Declarations.generic_module_body.mod_mp mtb2) list2 subst1 subst2
              (Declarations.generic_module_body.mod_delta mtb1)
              (Declarations.generic_module_body.mod_delta mtb2) in
          let cst2 :=
            check_signatures cst env
              (Declarations.generic_module_body.mod_mp mtb2) list2
              (Declarations.generic_module_body.mod_mp mtb1) list1 subst2 subst1
              (Declarations.generic_module_body.mod_delta mtb2)
              (Declarations.generic_module_body.mod_delta mtb1) in
          Univ.Constraint.union cst1 cst2
        else
          check_signatures cst env
            (Declarations.generic_module_body.mod_mp mtb1) list1
            (Declarations.generic_module_body.mod_mp mtb2) list2 subst1 subst2
            (Declarations.generic_module_body.mod_delta mtb1)
            (Declarations.generic_module_body.mod_delta mtb2)
      |
        (Declarations.MoreFunctor arg_id1 arg_t1 body_t1,
          Declarations.MoreFunctor arg_id2 arg_t2 body_t2) =&gt;
        let mp2 := Names.MPbound arg_id2 in
        let subst1 :=
          join
            (map_mbid arg_id1 mp2
              (Declarations.generic_module_body.mod_delta arg_t2)) subst1 in
        let cst := check_modtypes cst env arg_t2 arg_t1 subst2 subst1 equiv in
        let env := add_module_type mp2 arg_t2 env in
        let env :=
          if Modops.is_functor body_t1 then
            env
          else
            add_module
              {|
                Declarations.generic_module_body.mod_mp :=
                  Declarations.generic_module_body.mod_mp mtb1;
                Declarations.generic_module_body.mod_expr :=
                  Declarations.Abstract;
                Declarations.generic_module_body.mod_type :=
                  subst_signature subst1 body_t1;
                Declarations.generic_module_body.mod_type_alg := None;
                Declarations.generic_module_body.mod_constraints :=
                  Declarations.generic_module_body.mod_constraints mtb1;
                Declarations.generic_module_body.mod_delta :=
                  Declarations.generic_module_body.mod_delta mtb1;
                Declarations.generic_module_body.mod_retroknowledge :=
                  Declarations.ModBodyRK [] |} env in
        check_structure cst env body_t1 body_t2 equiv subst1 subst2
      | (_, _) =&gt; error_incompatible_modtypes mtb1 mtb2
      end in
    check_structure cst env (Declarations.generic_module_body.mod_type mtb1)
      (Declarations.generic_module_body.mod_type mtb2) equiv subst1 subst2.

Definition check_subtypes
  (env : Environ.env) (sup : Declarations.module_type_body)
  (super : Declarations.module_type_body) : Univ.Constraint.t :=
  let env :=
    add_module_type (Declarations.generic_module_body.mod_mp sup) sup env in
  let env :=
    Environ.push_context_set (Some true)
      (Declarations.generic_module_body.mod_constraints super) env in
  check_modtypes Univ.Constraint.empty env
    (strengthen sup (Declarations.generic_module_body.mod_mp sup)) super
    empty_subst
    (map_mp (Declarations.generic_module_body.mod_mp super)
      (Declarations.generic_module_body.mod_mp sup)
      (Declarations.generic_module_body.mod_delta sup)) false.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="subtyping.mli">
  <div style="margin: 20px;">
    <h3>Subtyping_mli</h3>
    <ul>
      <li>OCaml size: 15 lines</li>
      <li>Coq size: 14 lines (-7% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#subtyping.mli"><code>subtyping.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Univ
open Declarations
open Environ

val check_subtypes : env -&gt; module_type_body -&gt; module_type_body -&gt; Constraint.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#subtyping.mli"><code>Subtyping_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter check_subtypes :
  Environ.env -&gt; Declarations.module_type_body -&gt;
  Declarations.module_type_body -&gt; Univ.Constraint.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="term.ml">
  <div style="margin: 20px;">
    <h3>Term</h3>
    <ul>
      <li>OCaml size: 386 lines</li>
      <li>Coq size: 552 lines (+43% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#term.ml"><code>term.ml</code></a>&nbsp;<span class="label label-warning">8 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Util
open Pp
open CErrors
open Names
open Vars
open Constr
open Context

(* Deprecated *)
type sorts_family = Sorts.family = InSProp | InProp | InSet | InType
[@@ocaml.deprecated &quot;Alias for Sorts.family&quot;]

type sorts = Sorts.t = private
  | SProp | Prop | Set
  | Type of Univ.Universe.t  (** Type *)
[@@ocaml.deprecated &quot;Alias for Sorts.t&quot;]

(****************************************************************************)
(*              Functions for dealing with constr terms                     *)
(****************************************************************************)

(***************************)
(* Other term constructors *)
(***************************)

let name_annot = map_annot Name.mk_name

let mkNamedProd id typ c = mkProd (name_annot id, typ, subst_var id.binder_name c)
let mkNamedLambda id typ c = mkLambda (name_annot id, typ, subst_var id.binder_name c)
let mkNamedLetIn id c1 t c2 = mkLetIn (name_annot id, c1, t, subst_var id.binder_name c2)

(* Constructs either [(x:t)c] or [[x=b:t]c] *)
let mkProd_or_LetIn decl c =
  let open Context.Rel.Declaration in
  match decl with
  | LocalAssum (na,t) -&gt; mkProd (na, t, c)
  | LocalDef (na,b,t) -&gt; mkLetIn (na, b, t, c)

let mkNamedProd_or_LetIn decl c =
  let open Context.Named.Declaration in
  match decl with
    | LocalAssum (id,t) -&gt; mkNamedProd id t c
    | LocalDef (id,b,t) -&gt; mkNamedLetIn id b t c

(* Constructs either [(x:t)c] or [c] where [x] is replaced by [b] *)
let mkProd_wo_LetIn decl c =
  let open Context.Rel.Declaration in
  match decl with
  | LocalAssum (na,t) -&gt; mkProd (na, t, c)
  | LocalDef (_na,b,_t) -&gt; subst1 b c

let mkNamedProd_wo_LetIn decl c =
  let open Context.Named.Declaration in
  match decl with
    | LocalAssum (id,t) -&gt; mkNamedProd id t c
    | LocalDef (id,b,_) -&gt; subst1 b (subst_var id.binder_name c)

(* non-dependent product t1 -&gt; t2 *)
let mkArrow t1 r t2 = mkProd (make_annot Anonymous r, t1, t2)
let mkArrowR t1 t2 = mkArrow t1 Sorts.Relevant t2

(* Constructs either [[x:t]c] or [[x=b:t]c] *)
let mkLambda_or_LetIn decl c =
  let open Context.Rel.Declaration in
  match decl with
    | LocalAssum (na,t) -&gt; mkLambda (na, t, c)
    | LocalDef (na,b,t) -&gt; mkLetIn (na, b, t, c)

let mkNamedLambda_or_LetIn decl c =
  let open Context.Named.Declaration in
  match decl with
    | LocalAssum (id,t) -&gt; mkNamedLambda id t c
    | LocalDef (id,b,t) -&gt; mkNamedLetIn id b t c

(* prodn n [xn:Tn;..;x1:T1;Gamma] b = (x1:T1)..(xn:Tn)b *)
let prodn n env b =
  let rec prodrec = function
    | (0, _env, b)        -&gt; b
    | (n, ((v,t)::l), b) -&gt; prodrec (n-1,  l, mkProd (v,t,b))
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in
  prodrec (n,env,b)

(* compose_prod [xn:Tn;..;x1:T1] b = (x1:T1)..(xn:Tn)b *)
let compose_prod l b = prodn (List.length l) l b

(* lamn n [xn:Tn;..;x1:T1;Gamma] b = [x1:T1]..[xn:Tn]b *)
let lamn n env b =
  let rec lamrec = function
    | (0, _env, b)        -&gt; b
    | (n, ((v,t)::l), b) -&gt; lamrec (n-1,  l, mkLambda (v,t,b))
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in
  lamrec (n,env,b)

(* compose_lam [xn:Tn;..;x1:T1] b = [x1:T1]..[xn:Tn]b *)
let compose_lam l b = lamn (List.length l) l b

let applist (f,l) = mkApp (f, Array.of_list l)

let applistc f l = mkApp (f, Array.of_list l)

let appvect = mkApp

let appvectc f l = mkApp (f,l)

(* to_lambda n (x1:T1)...(xn:Tn)T =
 * [x1:T1]...[xn:Tn]T *)
let rec to_lambda n prod =
  if Int.equal n 0 then
    prod
  else
    match kind prod with
      | Prod (na,ty,bd) -&gt; mkLambda (na,ty,to_lambda (n-1) bd)
      | Cast (c,_,_) -&gt; to_lambda n c
      | _   -&gt; user_err ~hdr:&quot;to_lambda&quot; (mt ())

let rec to_prod n lam =
  if Int.equal n 0 then
    lam
  else
    match kind lam with
      | Lambda (na,ty,bd) -&gt; mkProd (na,ty,to_prod (n-1) bd)
      | Cast (c,_,_) -&gt; to_prod n c
      | _   -&gt; user_err ~hdr:&quot;to_prod&quot; (mt ())

let it_mkProd_or_LetIn   = List.fold_left (fun c d -&gt; mkProd_or_LetIn d c)
let it_mkLambda_or_LetIn = List.fold_left (fun c d -&gt; mkLambda_or_LetIn d c)

(* Application with expected on-the-fly reduction *)

let lambda_applist c l =
  let rec app subst c l =
    match kind c, l with
    | Lambda(_,_,c), arg::l -&gt; app (arg::subst) c l
    | _, [] -&gt; substl subst c
    | _ -&gt; anomaly (Pp.str &quot;Not enough lambda's.&quot;) in
  app [] c l

let lambda_appvect c v = lambda_applist c (Array.to_list v)

let lambda_applist_assum n c l =
  let rec app n subst t l =
    if Int.equal n 0 then
      if l == [] then substl subst t
      else anomaly (Pp.str &quot;Too many arguments.&quot;)
    else match kind t, l with
    | Lambda(_,_,c), arg::l -&gt; app (n-1) (arg::subst) c l
    | LetIn(_,b,_,c), _ -&gt; app (n-1) (substl subst b::subst) c l
    | _, [] -&gt; anomaly (Pp.str &quot;Not enough arguments.&quot;)
    | _ -&gt; anomaly (Pp.str &quot;Not enough lambda/let's.&quot;) in
  app n [] c l

let lambda_appvect_assum n c v = lambda_applist_assum n c (Array.to_list v)

(* prod_applist T [ a1 ; ... ; an ] -&gt; (T a1 ... an) *)
let prod_applist c l =
  let rec app subst c l =
    match kind c, l with
    | Prod(_,_,c), arg::l -&gt; app (arg::subst) c l
    | _, [] -&gt; substl subst c
    | _ -&gt; anomaly (Pp.str &quot;Not enough prod's.&quot;) in
  app [] c l

(* prod_appvect T [| a1 ; ... ; an |] -&gt; (T a1 ... an) *)
let prod_appvect c v = prod_applist c (Array.to_list v)

let prod_applist_assum n c l =
  let rec app n subst t l =
    if Int.equal n 0 then
      if l == [] then substl subst t
      else anomaly (Pp.str &quot;Too many arguments.&quot;)
    else match kind t, l with
    | Prod(_,_,c), arg::l -&gt; app (n-1) (arg::subst) c l
    | LetIn(_,b,_,c), _ -&gt; app (n-1) (substl subst b::subst) c l
    | _, [] -&gt; anomaly (Pp.str &quot;Not enough arguments.&quot;)
    | _ -&gt; anomaly (Pp.str &quot;Not enough prod/let's.&quot;) in
  app n [] c l

let prod_appvect_assum n c v = prod_applist_assum n c (Array.to_list v)

(*********************************)
(* Other term destructors        *)
(*********************************)

(* Transforms a product term (x1:T1)..(xn:Tn)T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a product *)
let decompose_prod =
  let rec prodec_rec l c = match kind c with
    | Prod (x,t,c) -&gt; prodec_rec ((x,t)::l) c
    | Cast (c,_,_)   -&gt; prodec_rec l c
    | _              -&gt; l,c
  in
  prodec_rec []

(* Transforms a lambda term [x1:T1]..[xn:Tn]T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a lambda *)
let decompose_lam =
  let rec lamdec_rec l c = match kind c with
    | Lambda (x,t,c) -&gt; lamdec_rec ((x,t)::l) c
    | Cast (c,_,_)     -&gt; lamdec_rec l c
    | _                -&gt; l,c
  in
  lamdec_rec []

(* Given a positive integer n, transforms a product term (x1:T1)..(xn:Tn)T
   into the pair ([(xn,Tn);...;(x1,T1)],T) *)
let decompose_prod_n n =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if n &lt; 0 then user_err (str &quot;decompose_prod_n: integer parameter must be positive&quot;);
  let rec prodec_rec l n c =
    if Int.equal n 0 then l,c
    else match kind c with
      | Prod (x,t,c) -&gt; prodec_rec ((x,t)::l) (n-1) c
      | Cast (c,_,_)   -&gt; prodec_rec l n c
      | _ -&gt; user_err (str &quot;decompose_prod_n: not enough products&quot;)
  in
  prodec_rec [] n</abbr>

(* Given a positive integer n, transforms a lambda term [x1:T1]..[xn:Tn]T
   into the pair ([(xn,Tn);...;(x1,T1)],T) *)
let decompose_lam_n n =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if n &lt; 0 then user_err (str &quot;decompose_lam_n: integer parameter must be positive&quot;);
  let rec lamdec_rec l n c =
    if Int.equal n 0 then l,c
    else match kind c with
      | Lambda (x,t,c) -&gt; lamdec_rec ((x,t)::l) (n-1) c
      | Cast (c,_,_)     -&gt; lamdec_rec l n c
      | _ -&gt; user_err (str &quot;decompose_lam_n: not enough abstractions&quot;)
  in
  lamdec_rec [] n</abbr>

(* Transforms a product term (x1:T1)..(xn:Tn)T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a product *)
let decompose_prod_assum =
  let open Context.Rel.Declaration in
  let rec prodec_rec l c =
    match kind c with
    | Prod (x,t,c)    -&gt; prodec_rec (Context.Rel.add (LocalAssum (x,t)) l) c
    | LetIn (x,b,t,c) -&gt; prodec_rec (Context.Rel.add (LocalDef (x,b,t)) l) c
    | Cast (c,_,_)      -&gt; prodec_rec l c
    | _               -&gt; l,c
  in
  prodec_rec Context.Rel.empty

(* Transforms a lambda term [x1:T1]..[xn:Tn]T into the pair
   ([(xn,Tn);...;(x1,T1)],T), where T is not a lambda *)
let decompose_lam_assum =
  let rec lamdec_rec l c =
    let open Context.Rel.Declaration in
    match kind c with
    | Lambda (x,t,c)  -&gt; lamdec_rec (Context.Rel.add (LocalAssum (x,t)) l) c
    | LetIn (x,b,t,c) -&gt; lamdec_rec (Context.Rel.add (LocalDef (x,b,t)) l) c
    | Cast (c,_,_)      -&gt; lamdec_rec l c
    | _               -&gt; l,c
  in
  lamdec_rec Context.Rel.empty

(* Given a positive integer n, decompose a product or let-in term
   of the form [forall (x1:T1)..(xi:=ci:Ti)..(xn:Tn), T] into the pair
   of the quantifying context [(xn,None,Tn);..;(xi,Some
   ci,Ti);..;(x1,None,T1)] and of the inner type [T]) *)
let decompose_prod_n_assum n =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if n &lt; 0 then
    user_err (str &quot;decompose_prod_n_assum: integer parameter must be positive&quot;);
  let rec prodec_rec l n c =
    if Int.equal n 0 then l,c
    else
      let open Context.Rel.Declaration in
      match kind c with
      | Prod (x,t,c)    -&gt; prodec_rec (Context.Rel.add (LocalAssum (x,t)) l) (n-1) c
      | LetIn (x,b,t,c) -&gt; prodec_rec (Context.Rel.add (LocalDef (x,b,t)) l) (n-1) c
      | Cast (c,_,_)      -&gt; prodec_rec l n c
      | _ -&gt; user_err (str  &quot;decompose_prod_n_assum: not enough assumptions&quot;)
  in
  prodec_rec Context.Rel.empty n</abbr>

(* Given a positive integer n, decompose a lambda or let-in term [fun
   (x1:T1)..(xi:=ci:Ti)..(xn:Tn) =&gt; T] into the pair of the abstracted
   context [(xn,None,Tn);...;(xi,Some ci,Ti);...;(x1,None,T1)] and of
   the inner body [T].
   Lets in between are not expanded but turn into local definitions,
   but n is the actual number of destructurated lambdas. *)
let decompose_lam_n_assum n =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if n &lt; 0 then
    user_err (str  &quot;decompose_lam_n_assum: integer parameter must be positive&quot;);
  let rec lamdec_rec l n c =
    if Int.equal n 0 then l,c
    else
      let open Context.Rel.Declaration in
      match kind c with
      | Lambda (x,t,c)  -&gt; lamdec_rec (Context.Rel.add (LocalAssum (x,t)) l) (n-1) c
      | LetIn (x,b,t,c) -&gt; lamdec_rec (Context.Rel.add (LocalDef (x,b,t)) l) n c
      | Cast (c,_,_)      -&gt; lamdec_rec l n c
      | _c -&gt; user_err (str &quot;decompose_lam_n_assum: not enough abstractions&quot;)
  in
  lamdec_rec Context.Rel.empty n</abbr>

(* Same, counting let-in *)
let decompose_lam_n_decls n =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if n &lt; 0 then
    user_err (str &quot;decompose_lam_n_decls: integer parameter must be positive&quot;);
  let rec lamdec_rec l n c =
    if Int.equal n 0 then l,c
    else
      let open Context.Rel.Declaration in
      match kind c with
      | Lambda (x,t,c)  -&gt; lamdec_rec (Context.Rel.add (LocalAssum (x,t)) l) (n-1) c
      | LetIn (x,b,t,c) -&gt; lamdec_rec (Context.Rel.add (LocalDef (x,b,t)) l) (n-1) c
      | Cast (c,_,_)      -&gt; lamdec_rec l n c
      | _ -&gt; user_err (str &quot;decompose_lam_n_decls: not enough abstractions&quot;)
  in
  lamdec_rec Context.Rel.empty n</abbr>

let prod_assum t = fst (decompose_prod_assum t)
let prod_n_assum n t = fst (decompose_prod_n_assum n t)
let strip_prod_assum t = snd (decompose_prod_assum t)
let strip_prod t = snd (decompose_prod t)
let strip_prod_n n t = snd (decompose_prod_n n t)
let lam_assum t = fst (decompose_lam_assum t)
let lam_n_assum n t = fst (decompose_lam_n_assum n t)
let strip_lam_assum t = snd (decompose_lam_assum t)
let strip_lam t = snd (decompose_lam t)
let strip_lam_n n t = snd (decompose_lam_n n t)

(***************************)
(* Arities                 *)
(***************************)

(* An &quot;arity&quot; is a term of the form [[x1:T1]...[xn:Tn]s] with [s] a sort.
   Such a term can canonically be seen as the pair of a context of types
   and of a sort *)

type arity = Constr.rel_context * Sorts.t

let destArity =
  let open Context.Rel.Declaration in
  let rec prodec_rec l c =
    match kind c with
    | Prod (x,t,c)    -&gt; prodec_rec (LocalAssum (x,t) :: l) c
    | LetIn (x,b,t,c) -&gt; prodec_rec (LocalDef (x,b,t) :: l) c
    | Cast (c,_,_)      -&gt; prodec_rec l c
    | Sort s          -&gt; l,s
    | _               -&gt; anomaly ~label:&quot;destArity&quot; (Pp.str &quot;not an arity.&quot;)
  in
  prodec_rec []

let mkArity (sign,s) = it_mkProd_or_LetIn (mkSort s) sign

let rec isArity c =
  match kind c with
  | Prod (_,_,c)    -&gt; isArity c
  | LetIn (_,b,_,c) -&gt; isArity (subst1 b c)
  | Cast (c,_,_)      -&gt; isArity c
  | Sort _          -&gt; true
  | _               -&gt; false

(** Kind of type *)

(* Experimental, used in Presburger contrib *)
type ('constr, 'types) kind_of_type =
  | SortType   of Sorts.t
  | CastType   of 'types * 'types
  | ProdType   of Name.t Context.binder_annot * 'types * 'types
  | LetInType  of Name.t Context.binder_annot * 'constr * 'types * 'types
  | AtomicType of 'constr * 'constr array

let kind_of_type t = match kind t with
  | Sort s -&gt; SortType s
  | Cast (c,_,t) -&gt; CastType (c, t)
  | Prod (na,t,c) -&gt; ProdType (na, t, c)
  | LetIn (na,b,t,c) -&gt; LetInType (na, b, t, c)
  | App (c,l) -&gt; AtomicType (c, l)
  | (Rel _ | Meta _ | Var _ | Evar _ | Const _
  | Proj _ | Case _ | Fix _ | CoFix _ | Ind _)
    -&gt; AtomicType (t,<abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>)
  | (Lambda _ | Construct _ | Int _) -&gt; failwith &quot;Not a type&quot;
</pre>
  </div>
  <div class="col-md-6">
    <a href="#term.ml"><code>Term.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Pp.

Import CErrors.

Import Names.

Import Vars.

Import Constr.

Import Context.

Inductive sorts_family : Set :=
| InSProp : sorts_family
| InProp : sorts_family
| InSet : sorts_family
| InType : sorts_family.

Inductive sorts : Set :=
| SProp : sorts
| Prop : sorts
| __Set : sorts
| Type : Univ.Universe.t -&gt; sorts.

Definition name_annot
  : Context.binder_annot Names.Id.t -&gt; Context.binder_annot Names.Name.t :=
  map_annot Name.mk_name.

Definition mkNamedProd
  (id : Context.binder_annot Names.Id.t) (typ : Constr.types)
  (c : Constr.constr) : Constr.types :=
  mkProd
    ((name_annot id), typ, (subst_var (Context.binder_annot.binder_name id) c)).

Definition mkNamedLambda
  (id : Context.binder_annot Names.Id.t) (typ : Constr.types)
  (c : Constr.constr) : Constr.constr :=
  mkLambda
    ((name_annot id), typ, (subst_var (Context.binder_annot.binder_name id) c)).

Definition mkNamedLetIn
  (id : Context.binder_annot Names.Id.t) (c1 : Constr.constr) (t : Constr.types)
  (c2 : Constr.constr) : Constr.constr :=
  mkLetIn
    ((name_annot id), c1, t,
      (subst_var (Context.binder_annot.binder_name id) c2)).

Definition mkProd_or_LetIn
  (decl : Context.Rel.Declaration.pt Constr.constr Constr.types)
  (c : Constr.types) : Constr.types :=
  match decl with
  | Context.Rel.Declaration.LocalAssum na t =&gt; mkProd (na, t, c)
  | Context.Rel.Declaration.LocalDef na b t =&gt; mkLetIn (na, b, t, c)
  end.

Definition mkNamedProd_or_LetIn
  (decl : Context.Named.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.types :=
  match decl with
  | Context.Named.Declaration.LocalAssum id t =&gt; mkNamedProd id t c
  | Context.Named.Declaration.LocalDef id b t =&gt; mkNamedLetIn id b t c
  end.

Definition mkProd_wo_LetIn
  (decl : Context.Rel.Declaration.pt Constr.constr Constr.types)
  (c : Constr.types) : Constr.types :=
  match decl with
  | Context.Rel.Declaration.LocalAssum na t =&gt; mkProd (na, t, c)
  | Context.Rel.Declaration.LocalDef _na b _t =&gt; subst1 b c
  end.

Definition mkNamedProd_wo_LetIn
  (decl : Context.Named.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.types :=
  match decl with
  | Context.Named.Declaration.LocalAssum id t =&gt; mkNamedProd id t c
  | Context.Named.Declaration.LocalDef id b _ =&gt;
    subst1 b (subst_var (Context.binder_annot.binder_name id) c)
  end.

Definition mkArrow (t1 : Constr.types) (r : Sorts.relevance) (t2 : Constr.types)
  : Constr.types := mkProd ((make_annot Names.Anonymous r), t1, t2).

Definition mkArrowR (t1 : Constr.types) (t2 : Constr.types) : Constr.types :=
  mkArrow t1 Sorts.Relevant t2.

Definition mkLambda_or_LetIn
  (decl : Context.Rel.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.constr :=
  match decl with
  | Context.Rel.Declaration.LocalAssum na t =&gt; mkLambda (na, t, c)
  | Context.Rel.Declaration.LocalDef na b t =&gt; mkLetIn (na, b, t, c)
  end.

Definition mkNamedLambda_or_LetIn
  (decl : Context.Named.Declaration.pt Constr.constr Constr.types)
  (c : Constr.constr) : Constr.constr :=
  match decl with
  | Context.Named.Declaration.LocalAssum id t =&gt; mkNamedLambda id t c
  | Context.Named.Declaration.LocalDef id b t =&gt; mkNamedLetIn id b t c
  end.

Definition prodn
  (n : Z) (env : list (Context.binder_annot Names.Name.t * Constr.types))
  (b : Constr.types) : Constr.types :=
  let fix prodrec
    (function_parameter :
      Z * list (Context.binder_annot Names.Name.t * Constr.types) * Constr.types)
    {struct function_parameter} : Constr.types :=
    match function_parameter with
    | (0, _env, b) =&gt; b
    | (n, cons (v, t) l, b) =&gt; prodrec ((Z.sub n 1), l, (mkProd (v, t, b)))
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  prodrec (n, env, b).

Definition compose_prod
  (l : list (Context.binder_annot Names.Name.t * Constr.types))
  (b : Constr.types) : Constr.types :=
  prodn ((|Util.List|).(CList.ExtS.length) l) l b.

Definition lamn
  (n : Z) (env : list (Context.binder_annot Names.Name.t * Constr.types))
  (b : Constr.constr) : Constr.constr :=
  let fix lamrec
    (function_parameter :
      Z * list (Context.binder_annot Names.Name.t * Constr.types) *
        Constr.constr) {struct function_parameter} : Constr.constr :=
    match function_parameter with
    | (0, _env, b) =&gt; b
    | (n, cons (v, t) l, b) =&gt; lamrec ((Z.sub n 1), l, (mkLambda (v, t, b)))
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  lamrec (n, env, b).

Definition compose_lam
  (l : list (Context.binder_annot Names.Name.t * Constr.types))
  (b : Constr.constr) : Constr.constr :=
  lamn ((|Util.List|).(CList.ExtS.length) l) l b.

Definition applist (function_parameter : Constr.constr * list Constr.constr)
  : Constr.constr :=
  let '(f, l) := function_parameter in
  mkApp (f, ((|Util.Array|).(CArray.ExtS.of_list) l)).

Definition applistc (f : Constr.constr) (l : list Constr.constr)
  : Constr.constr := mkApp (f, ((|Util.Array|).(CArray.ExtS.of_list) l)).

Definition appvect : Constr.constr * array Constr.constr -&gt; Constr.constr :=
  mkApp.

Definition appvectc (f : Constr.constr) (l : array Constr.constr)
  : Constr.constr := mkApp (f, l).

Fixpoint to_lambda (n : Int.t) (prod : Constr.constr) {struct n}
  : Constr.constr :=
  if Int.equal n 0 then
    prod
  else
    match kind prod with
    | Constr.Prod na ty bd =&gt; mkLambda (na, ty, (to_lambda (Z.sub n 1) bd))
    | Constr.Cast c _ _ =&gt; to_lambda n c
    | _ =&gt; user_err None (Some &quot;to_lambda&quot;) (mt tt)
    end.

Fixpoint to_prod (n : Int.t) (lam : Constr.constr) {struct n} : Constr.constr :=
  if Int.equal n 0 then
    lam
  else
    match kind lam with
    | Constr.Lambda na ty bd =&gt; mkProd (na, ty, (to_prod (Z.sub n 1) bd))
    | Constr.Cast c _ _ =&gt; to_prod n c
    | _ =&gt; user_err None (Some &quot;to_prod&quot;) (mt tt)
    end.

Definition it_mkProd_or_LetIn
  : Constr.types -&gt;
  list (Context.Rel.Declaration.pt Constr.constr Constr.types) -&gt; Constr.types :=
  (|Util.List|).(CList.ExtS.fold_left) (fun c =&gt; fun d =&gt; mkProd_or_LetIn d c).

Definition it_mkLambda_or_LetIn
  : Constr.constr -&gt;
  list (Context.Rel.Declaration.pt Constr.constr Constr.types) -&gt; Constr.constr :=
  (|Util.List|).(CList.ExtS.fold_left) (fun c =&gt; fun d =&gt; mkLambda_or_LetIn d c).

Definition lambda_applist (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app (subst : Vars.substl) (c : Constr.constr) (l : list Constr.constr)
    {struct subst} : Constr.constr :=
    match ((kind c), l) with
    | (Constr.Lambda _ _ c, cons arg l) =&gt; app (cons arg subst) c l
    | (_, []) =&gt; substl subst c
    | _ =&gt; anomaly None None (Pp.str &quot;Not enough lambda's.&quot;)
    end in
  app [] c l.

Definition lambda_appvect (c : Constr.constr) (v : array Constr.constr)
  : Constr.constr := lambda_applist c ((|Util.Array|).(CArray.ExtS.to_list) v).

Definition lambda_applist_assum
  (n : Int.t) (c : Constr.constr) (l : list Constr.constr) : Constr.constr :=
  let fix app
    (n : Int.t) (subst : Vars.substl) (t : Constr.constr)
    (l : list Constr.constr) {struct n} : Constr.constr :=
    if Int.equal n 0 then
      if Stdlib.op_eqeq l [] then
        substl subst t
      else
        anomaly None None (Pp.str &quot;Too many arguments.&quot;)
    else
      match ((kind t), l) with
      | (Constr.Lambda _ _ c, cons arg l) =&gt;
        app (Z.sub n 1) (cons arg subst) c l
      | (Constr.LetIn _ b _ c, _) =&gt;
        app (Z.sub n 1) (cons (substl subst b) subst) c l
      | (_, []) =&gt; anomaly None None (Pp.str &quot;Not enough arguments.&quot;)
      | _ =&gt; anomaly None None (Pp.str &quot;Not enough lambda/let's.&quot;)
      end in
  app n [] c l.

Definition lambda_appvect_assum
  (n : Int.t) (c : Constr.constr) (v : array Constr.constr) : Constr.constr :=
  lambda_applist_assum n c ((|Util.Array|).(CArray.ExtS.to_list) v).

Definition prod_applist (c : Constr.constr) (l : list Constr.constr)
  : Constr.constr :=
  let fix app (subst : Vars.substl) (c : Constr.constr) (l : list Constr.constr)
    {struct subst} : Constr.constr :=
    match ((kind c), l) with
    | (Constr.Prod _ _ c, cons arg l) =&gt; app (cons arg subst) c l
    | (_, []) =&gt; substl subst c
    | _ =&gt; anomaly None None (Pp.str &quot;Not enough prod's.&quot;)
    end in
  app [] c l.

Definition prod_appvect (c : Constr.constr) (v : array Constr.constr)
  : Constr.constr := prod_applist c ((|Util.Array|).(CArray.ExtS.to_list) v).

Definition prod_applist_assum
  (n : Int.t) (c : Constr.constr) (l : list Constr.constr) : Constr.constr :=
  let fix app
    (n : Int.t) (subst : Vars.substl) (t : Constr.constr)
    (l : list Constr.constr) {struct n} : Constr.constr :=
    if Int.equal n 0 then
      if Stdlib.op_eqeq l [] then
        substl subst t
      else
        anomaly None None (Pp.str &quot;Too many arguments.&quot;)
    else
      match ((kind t), l) with
      | (Constr.Prod _ _ c, cons arg l) =&gt; app (Z.sub n 1) (cons arg subst) c l
      | (Constr.LetIn _ b _ c, _) =&gt;
        app (Z.sub n 1) (cons (substl subst b) subst) c l
      | (_, []) =&gt; anomaly None None (Pp.str &quot;Not enough arguments.&quot;)
      | _ =&gt; anomaly None None (Pp.str &quot;Not enough prod/let's.&quot;)
      end in
  app n [] c l.

Definition prod_appvect_assum
  (n : Int.t) (c : Constr.constr) (v : array Constr.constr) : Constr.constr :=
  prod_applist_assum n c ((|Util.Array|).(CArray.ExtS.to_list) v).

Definition decompose_prod
  : Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
  let fix prodec_rec
    (l : list (Context.binder_annot Names.Name.t * Constr.types))
    (c : Constr.constr) {struct l}
    : list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
    match kind c with
    | Constr.Prod x t c =&gt; prodec_rec (cons (x, t) l) c
    | Constr.Cast c _ _ =&gt; prodec_rec l c
    | _ =&gt; (l, c)
    end in
  prodec_rec [].

Definition decompose_lam
  : Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
  let fix lamdec_rec
    (l : list (Context.binder_annot Names.Name.t * Constr.types))
    (c : Constr.constr) {struct l}
    : list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
    match kind c with
    | Constr.Lambda x t c =&gt; lamdec_rec (cons (x, t) l) c
    | Constr.Cast c _ _ =&gt; lamdec_rec l c
    | _ =&gt; (l, c)
    end in
  lamdec_rec [].

Definition decompose_prod_n (n : Int.t)
  : Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fix prodec_rec
    (l : list (Context.binder_annot Names.Name.t * Constr.types)) (n : Int.t)
    (c : Constr.constr) {struct l}
    : list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match kind c with
      | Constr.Prod x t c =&gt; prodec_rec (cons (x, t) l) (Z.sub n 1) c
      | Constr.Cast c _ _ =&gt; prodec_rec l n c
      | _ =&gt; user_err None None (str &quot;decompose_prod_n: not enough products&quot;)
      end in
  prodec_rec [] n.

Definition decompose_lam_n (n : Int.t)
  : Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fix lamdec_rec
    (l : list (Context.binder_annot Names.Name.t * Constr.types)) (n : Int.t)
    (c : Constr.constr) {struct l}
    : list (Context.binder_annot Names.Name.t * Constr.types) * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match kind c with
      | Constr.Lambda x t c =&gt; lamdec_rec (cons (x, t) l) (Z.sub n 1) c
      | Constr.Cast c _ _ =&gt; lamdec_rec l n c
      | _ =&gt; user_err None None (str &quot;decompose_lam_n: not enough abstractions&quot;)
      end in
  lamdec_rec [] n.

Definition decompose_prod_assum
  : Constr.constr -&gt; Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
  let fix prodec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (c : Constr.constr)
    {struct l} : Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
    match kind c with
    | Constr.Prod x t c =&gt;
      prodec_rec (Context.Rel.add (Context.Rel.Declaration.LocalAssum x t) l) c
    | Constr.LetIn x b t c =&gt;
      prodec_rec (Context.Rel.add (Context.Rel.Declaration.LocalDef x b t) l) c
    | Constr.Cast c _ _ =&gt; prodec_rec l c
    | _ =&gt; (l, c)
    end in
  prodec_rec Context.Rel.empty.

Definition decompose_lam_assum
  : Constr.constr -&gt; Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
  let fix lamdec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (c : Constr.constr)
    {struct l} : Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
    match kind c with
    | Constr.Lambda x t c =&gt;
      lamdec_rec (Context.Rel.add (Context.Rel.Declaration.LocalAssum x t) l) c
    | Constr.LetIn x b t c =&gt;
      lamdec_rec (Context.Rel.add (Context.Rel.Declaration.LocalDef x b t) l) c
    | Constr.Cast c _ _ =&gt; lamdec_rec l c
    | _ =&gt; (l, c)
    end in
  lamdec_rec Context.Rel.empty.

Definition decompose_prod_n_assum (n : Int.t)
  : Constr.constr -&gt; Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fix prodec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (n : Int.t)
    (c : Constr.constr) {struct l}
    : Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match kind c with
      | Constr.Prod x t c =&gt;
        prodec_rec (Context.Rel.add (Context.Rel.Declaration.LocalAssum x t) l)
          (Z.sub n 1) c
      | Constr.LetIn x b t c =&gt;
        prodec_rec (Context.Rel.add (Context.Rel.Declaration.LocalDef x b t) l)
          (Z.sub n 1) c
      | Constr.Cast c _ _ =&gt; prodec_rec l n c
      | _ =&gt;
        user_err None None
          (str &quot;decompose_prod_n_assum: not enough assumptions&quot;)
      end in
  prodec_rec Context.Rel.empty n.

Definition decompose_lam_n_assum (n : Int.t)
  : Constr.constr -&gt; Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fix lamdec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (n : Int.t)
    (c : Constr.constr) {struct l}
    : Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match kind c with
      | Constr.Lambda x t c =&gt;
        lamdec_rec (Context.Rel.add (Context.Rel.Declaration.LocalAssum x t) l)
          (Z.sub n 1) c
      | Constr.LetIn x b t c =&gt;
        lamdec_rec (Context.Rel.add (Context.Rel.Declaration.LocalDef x b t) l)
          n c
      | Constr.Cast c _ _ =&gt; lamdec_rec l n c
      | _c =&gt;
        user_err None None
          (str &quot;decompose_lam_n_assum: not enough abstractions&quot;)
      end in
  lamdec_rec Context.Rel.empty n.

Definition decompose_lam_n_decls (n : Int.t)
  : Constr.constr -&gt; Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fix lamdec_rec
    (l : Context.Rel.pt Constr.constr Constr.types) (n : Int.t)
    (c : Constr.constr) {struct l}
    : Context.Rel.pt Constr.constr Constr.types * Constr.constr :=
    if Int.equal n 0 then
      (l, c)
    else
      match kind c with
      | Constr.Lambda x t c =&gt;
        lamdec_rec (Context.Rel.add (Context.Rel.Declaration.LocalAssum x t) l)
          (Z.sub n 1) c
      | Constr.LetIn x b t c =&gt;
        lamdec_rec (Context.Rel.add (Context.Rel.Declaration.LocalDef x b t) l)
          (Z.sub n 1) c
      | Constr.Cast c _ _ =&gt; lamdec_rec l n c
      | _ =&gt;
        user_err None None
          (str &quot;decompose_lam_n_decls: not enough abstractions&quot;)
      end in
  lamdec_rec Context.Rel.empty n.

Definition prod_assum (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types := fst (decompose_prod_assum t).

Definition prod_n_assum (n : Int.t) (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types :=
  fst (decompose_prod_n_assum n t).

Definition strip_prod_assum (t : Constr.constr) : Constr.constr :=
  snd (decompose_prod_assum t).

Definition strip_prod (t : Constr.constr) : Constr.constr :=
  snd (decompose_prod t).

Definition strip_prod_n (n : Int.t) (t : Constr.constr) : Constr.constr :=
  snd (decompose_prod_n n t).

Definition lam_assum (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types := fst (decompose_lam_assum t).

Definition lam_n_assum (n : Int.t) (t : Constr.constr)
  : Context.Rel.pt Constr.constr Constr.types := fst (decompose_lam_n_assum n t).

Definition strip_lam_assum (t : Constr.constr) : Constr.constr :=
  snd (decompose_lam_assum t).

Definition strip_lam (t : Constr.constr) : Constr.constr :=
  snd (decompose_lam t).

Definition strip_lam_n (n : Int.t) (t : Constr.constr) : Constr.constr :=
  snd (decompose_lam_n n t).

Definition arity := Constr.rel_context * Sorts.t.

Definition destArity
  : Constr.constr -&gt;
  list (Context.Rel.Declaration.pt Constr.constr Constr.types) * Sorts.t :=
  let fix prodec_rec
    (l : list (Context.Rel.Declaration.pt Constr.constr Constr.types))
    (c : Constr.constr) {struct l}
    : list (Context.Rel.Declaration.pt Constr.constr Constr.types) * Sorts.t :=
    match kind c with
    | Constr.Prod x t c =&gt;
      prodec_rec (cons (Context.Rel.Declaration.LocalAssum x t) l) c
    | Constr.LetIn x b t c =&gt;
      prodec_rec (cons (Context.Rel.Declaration.LocalDef x b t) l) c
    | Constr.Cast c _ _ =&gt; prodec_rec l c
    | Constr.Sort s =&gt; (l, s)
    | _ =&gt; anomaly None (Some &quot;destArity&quot;) (Pp.str &quot;not an arity.&quot;)
    end in
  prodec_rec [].

Definition mkArity
  (function_parameter :
    list (Context.Rel.Declaration.pt Constr.constr Constr.types) * Sorts.t)
  : Constr.types :=
  let '(sign, s) := function_parameter in
  it_mkProd_or_LetIn (mkSort s) sign.

Fixpoint isArity (c : Constr.constr) {struct c} : bool :=
  match kind c with
  | Constr.Prod _ _ c =&gt; isArity c
  | Constr.LetIn _ b _ c =&gt; isArity (subst1 b c)
  | Constr.Cast c _ _ =&gt; isArity c
  | Constr.Sort _ =&gt; true
  | _ =&gt; false
  end.

Inductive kind_of_type (constr types : Set) : Set :=
| SortType : Sorts.t -&gt; kind_of_type constr types
| CastType : types -&gt; types -&gt; kind_of_type constr types
| ProdType :
  Context.binder_annot Names.Name.t -&gt; types -&gt; types -&gt;
  kind_of_type constr types
| LetInType :
  Context.binder_annot Names.Name.t -&gt; constr -&gt; types -&gt; types -&gt;
  kind_of_type constr types
| AtomicType : constr -&gt; array constr -&gt; kind_of_type constr types.

Arguments SortType {_ _}.
Arguments CastType {_ _}.
Arguments ProdType {_ _}.
Arguments LetInType {_ _}.
Arguments AtomicType {_ _}.

Definition kind_of_type (t : Constr.constr)
  : kind_of_type Constr.constr Constr.constr :=
  match kind t with
  | Constr.Sort s =&gt; SortType s
  | Constr.Cast c _ t =&gt; CastType c t
  | Constr.Prod na t c =&gt; ProdType na t c
  | Constr.LetIn na b t c =&gt; LetInType na b t c
  | Constr.App c l =&gt; AtomicType c l
  |
    Constr.Rel _ | Constr.Meta _ | Constr.Var _ | Constr.Evar _ | Constr.Const _
    | Constr.Proj _ _ | Constr.Case _ _ _ _ | Constr.Fix _ | Constr.CoFix _ |
    Constr.Ind _ =&gt;
    AtomicType t
      (* ❌ Arrays not handled. *)
      [ ]
  | Constr.Lambda _ _ _ | Constr.Construct _ | Constr.Int _ =&gt;
    OCaml.Stdlib.failwith &quot;Not a type&quot;
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="term.mli">
  <div style="margin: 20px;">
    <h3>Term_mli</h3>
    <ul>
      <li>OCaml size: 202 lines</li>
      <li>Coq size: 191 lines (-6% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#term.mli"><code>term.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr

(** {5 Derived constructors} *)

(** non-dependent product [t1 -&gt; t2], an alias for
   [forall (_:t1), t2]. Beware [t_2] is NOT lifted.
   Eg: in context [A:Prop], [A-&gt;A] is built by [(mkArrow (mkRel 1) (mkRel 2))]
*)
val mkArrow : types -&gt; Sorts.relevance -&gt; types -&gt; constr

val mkArrowR : types -&gt; types -&gt; constr
(** For an always-relevant domain *)

(** Named version of the functions from [Term]. *)
val mkNamedLambda : Id.t Context.binder_annot -&gt; types -&gt; constr -&gt; constr
val mkNamedLetIn : Id.t Context.binder_annot -&gt; constr -&gt; types -&gt; constr -&gt; constr
val mkNamedProd : Id.t Context.binder_annot -&gt; types -&gt; types -&gt; types

(** Constructs either [(x:t)c] or [[x=b:t]c] *)
val mkProd_or_LetIn : Constr.rel_declaration -&gt; types -&gt; types
val mkProd_wo_LetIn : Constr.rel_declaration -&gt; types -&gt; types
val mkNamedProd_or_LetIn : Constr.named_declaration -&gt; types -&gt; types
val mkNamedProd_wo_LetIn : Constr.named_declaration -&gt; types -&gt; types

(** Constructs either [[x:t]c] or [[x=b:t]c] *)
val mkLambda_or_LetIn : Constr.rel_declaration -&gt; constr -&gt; constr
val mkNamedLambda_or_LetIn : Constr.named_declaration -&gt; constr -&gt; constr

(** {5 Other term constructors. } *)

(** [applist (f,args)] and its variants work as [mkApp] *)

val applist : constr * constr list -&gt; constr
val applistc : constr -&gt; constr list -&gt; constr
val appvect : constr * constr array -&gt; constr
val appvectc : constr -&gt; constr array -&gt; constr

(** [prodn n l b] = [forall (x_1:T_1)...(x_n:T_n), b]
   where [l] is [(x_n,T_n)...(x_1,T_1)...]. *)
val prodn : int -&gt; (Name.t Context.binder_annot * constr) list -&gt; constr -&gt; constr

(** [compose_prod l b]
   @return [forall (x_1:T_1)...(x_n:T_n), b]
   where [l] is [(x_n,T_n)...(x_1,T_1)].
   Inverse of [decompose_prod]. *)
val compose_prod : (Name.t Context.binder_annot * constr) list -&gt; constr -&gt; constr

(** [lamn n l b]
    @return [fun (x_1:T_1)...(x_n:T_n) =&gt; b]
   where [l] is [(x_n,T_n)...(x_1,T_1)...]. *)
val lamn : int -&gt; (Name.t Context.binder_annot * constr) list -&gt; constr -&gt; constr

(** [compose_lam l b]
   @return [fun (x_1:T_1)...(x_n:T_n) =&gt; b]
   where [l] is [(x_n,T_n)...(x_1,T_1)].
   Inverse of [it_destLam] *)
val compose_lam : (Name.t Context.binder_annot * constr) list -&gt; constr -&gt; constr

(** [to_lambda n l]
   @return [fun (x_1:T_1)...(x_n:T_n) =&gt; T]
   where [l] is [forall (x_1:T_1)...(x_n:T_n), T] *)
val to_lambda : int -&gt; constr -&gt; constr

(** [to_prod n l]
   @return [forall (x_1:T_1)...(x_n:T_n), T]
   where [l] is [fun (x_1:T_1)...(x_n:T_n) =&gt; T] *)
val to_prod : int -&gt; constr -&gt; constr

val it_mkLambda_or_LetIn : constr -&gt; Constr.rel_context -&gt; constr
val it_mkProd_or_LetIn : types -&gt; Constr.rel_context -&gt; types

(** In [lambda_applist c args], [c] is supposed to have the form
    [Î»Î.c] with [Î] without let-in; it returns [c] with the variables
    of [Î] instantiated by [args]. *)
val lambda_applist : constr -&gt; constr list -&gt; constr
val lambda_appvect : constr -&gt; constr array -&gt; constr

(** In [lambda_applist_assum n c args], [c] is supposed to have the
    form [Î»Î.c] with [Î] of length [n] and possibly with let-ins; it
    returns [c] with the assumptions of [Î] instantiated by [args] and
    the local definitions of [Î] expanded. *)
val lambda_applist_assum : int -&gt; constr -&gt; constr list -&gt; constr
val lambda_appvect_assum : int -&gt; constr -&gt; constr array -&gt; constr

(** pseudo-reduction rule *)

(** [prod_appvect] [forall (x1:B1;...;xn:Bn), B] [a1...an] @return [B[a1...an]] *)
val prod_appvect : types -&gt; constr array -&gt; types
val prod_applist : types -&gt; constr list -&gt; types

(** In [prod_appvect_assum n c args], [c] is supposed to have the
    form [âÎ.c] with [Î] of length [n] and possibly with let-ins; it
    returns [c] with the assumptions of [Î] instantiated by [args] and
    the local definitions of [Î] expanded. *)
val prod_appvect_assum : int -&gt; types -&gt; constr array -&gt; types
val prod_applist_assum : int -&gt; types -&gt; constr list -&gt; types

(** {5 Other term destructors. } *)

(** Transforms a product term {% $ %}(x_1:T_1)..(x_n:T_n)T{% $ %} into the pair
   {% $ %}([(x_n,T_n);...;(x_1,T_1)],T){% $ %}, where {% $ %}T{% $ %} is not a product. *)
val decompose_prod : constr -&gt; (Name.t Context.binder_annot * constr) list * constr

(** Transforms a lambda term {% $ %}[x_1:T_1]..[x_n:T_n]T{% $ %} into the pair
   {% $ %}([(x_n,T_n);...;(x_1,T_1)],T){% $ %}, where {% $ %}T{% $ %} is not a lambda. *)
val decompose_lam : constr -&gt; (Name.t Context.binder_annot * constr) list * constr

(** Given a positive integer n, decompose a product term
   {% $ %}(x_1:T_1)..(x_n:T_n)T{% $ %}
   into the pair {% $ %}([(xn,Tn);...;(x1,T1)],T){% $ %}.
   Raise a user error if not enough products. *)
val decompose_prod_n : int -&gt; constr -&gt; (Name.t Context.binder_annot * constr) list * constr

(** Given a positive integer {% $ %}n{% $ %}, decompose a lambda term
   {% $ %}[x_1:T_1]..[x_n:T_n]T{% $ %} into the pair {% $ %}([(x_n,T_n);...;(x_1,T_1)],T){% $ %}.
   Raise a user error if not enough lambdas. *)
val decompose_lam_n : int -&gt; constr -&gt; (Name.t Context.binder_annot * constr) list * constr

(** Extract the premisses and the conclusion of a term of the form
   &quot;(xi:Ti) ... (xj:=cj:Tj) ..., T&quot; where T is not a product nor a let *)
val decompose_prod_assum : types -&gt; Constr.rel_context * types

(** Idem with lambda's and let's *)
val decompose_lam_assum : constr -&gt; Constr.rel_context * constr

(** Idem but extract the first [n] premisses, counting let-ins. *)
val decompose_prod_n_assum : int -&gt; types -&gt; Constr.rel_context * types

(** Idem for lambdas, _not_ counting let-ins *)
val decompose_lam_n_assum : int -&gt; constr -&gt; Constr.rel_context * constr

(** Idem, counting let-ins *)
val decompose_lam_n_decls : int -&gt; constr -&gt; Constr.rel_context * constr

(** Return the premisses/parameters of a type/term (let-in included) *)
val prod_assum : types -&gt; Constr.rel_context
val lam_assum : constr -&gt; Constr.rel_context

(** Return the first n-th premisses/parameters of a type (let included and counted) *)
val prod_n_assum : int -&gt; types -&gt; Constr.rel_context

(** Return the first n-th premisses/parameters of a term (let included but not counted) *)
val lam_n_assum : int -&gt; constr -&gt; Constr.rel_context

(** Remove the premisses/parameters of a type/term *)
val strip_prod : types -&gt; types
val strip_lam : constr -&gt; constr

(** Remove the first n-th premisses/parameters of a type/term *)
val strip_prod_n : int -&gt; types -&gt; types
val strip_lam_n : int -&gt; constr -&gt; constr

(** Remove the premisses/parameters of a type/term (including let-in) *)
val strip_prod_assum : types -&gt; types
val strip_lam_assum : constr -&gt; constr

(** {5 ... } *)
(** An &quot;arity&quot; is a term of the form [[x1:T1]...[xn:Tn]s] with [s] a sort.
    Such a term can canonically be seen as the pair of a context of types
    and of a sort *)

type arity = Constr.rel_context * Sorts.t

(** Build an &quot;arity&quot; from its canonical form *)
val mkArity : arity -&gt; types

(** Destruct an &quot;arity&quot; into its canonical form *)
val destArity : types -&gt; arity

(** Tell if a term has the form of an arity *)
val isArity : types -&gt; bool

(** {5 Kind of type} *)

type ('constr, 'types) kind_of_type =
  | SortType   of Sorts.t
  | CastType   of 'types * 'types
  | ProdType   of Name.t Context.binder_annot * 'types * 'types
  | LetInType  of Name.t Context.binder_annot * 'constr * 'types * 'types
  | AtomicType of 'constr * 'constr array

val kind_of_type : types -&gt; (constr, types) kind_of_type

(* Deprecated *)
type sorts_family = Sorts.family = InSProp | InProp | InSet | InType
[@@ocaml.deprecated &quot;Alias for Sorts.family&quot;]

type sorts = Sorts.t = private
  | SProp | Prop | Set
  | Type of Univ.Universe.t  (** Type *)
[@@ocaml.deprecated &quot;Alias for Sorts.t&quot;]
</pre>
  </div>
  <div class="col-md-6">
    <a href="#term.mli"><code>Term_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter mkArrow :
  Constr.types -&gt; Sorts.relevance -&gt; Constr.types -&gt; Constr.constr.

Parameter mkArrowR : Constr.types -&gt; Constr.types -&gt; Constr.constr.

Parameter mkNamedLambda :
  Context.binder_annot Names.Id.t -&gt; Constr.types -&gt; Constr.constr -&gt;
  Constr.constr.

Parameter mkNamedLetIn :
  Context.binder_annot Names.Id.t -&gt; Constr.constr -&gt; Constr.types -&gt;
  Constr.constr -&gt; Constr.constr.

Parameter mkNamedProd :
  Context.binder_annot Names.Id.t -&gt; Constr.types -&gt; Constr.types -&gt;
  Constr.types.

Parameter mkProd_or_LetIn :
  Constr.rel_declaration -&gt; Constr.types -&gt; Constr.types.

Parameter mkProd_wo_LetIn :
  Constr.rel_declaration -&gt; Constr.types -&gt; Constr.types.

Parameter mkNamedProd_or_LetIn :
  Constr.named_declaration -&gt; Constr.types -&gt; Constr.types.

Parameter mkNamedProd_wo_LetIn :
  Constr.named_declaration -&gt; Constr.types -&gt; Constr.types.

Parameter mkLambda_or_LetIn :
  Constr.rel_declaration -&gt; Constr.constr -&gt; Constr.constr.

Parameter mkNamedLambda_or_LetIn :
  Constr.named_declaration -&gt; Constr.constr -&gt; Constr.constr.

Parameter applist : Constr.constr * list Constr.constr -&gt; Constr.constr.

Parameter applistc : Constr.constr -&gt; list Constr.constr -&gt; Constr.constr.

Parameter appvect : Constr.constr * array Constr.constr -&gt; Constr.constr.

Parameter appvectc : Constr.constr -&gt; array Constr.constr -&gt; Constr.constr.

Parameter prodn :
  Z -&gt; list (Context.binder_annot Names.Name.t * Constr.constr) -&gt;
  Constr.constr -&gt; Constr.constr.

Parameter compose_prod :
  list (Context.binder_annot Names.Name.t * Constr.constr) -&gt; Constr.constr -&gt;
  Constr.constr.

Parameter lamn :
  Z -&gt; list (Context.binder_annot Names.Name.t * Constr.constr) -&gt;
  Constr.constr -&gt; Constr.constr.

Parameter compose_lam :
  list (Context.binder_annot Names.Name.t * Constr.constr) -&gt; Constr.constr -&gt;
  Constr.constr.

Parameter to_lambda : Z -&gt; Constr.constr -&gt; Constr.constr.

Parameter to_prod : Z -&gt; Constr.constr -&gt; Constr.constr.

Parameter it_mkLambda_or_LetIn :
  Constr.constr -&gt; Constr.rel_context -&gt; Constr.constr.

Parameter it_mkProd_or_LetIn :
  Constr.types -&gt; Constr.rel_context -&gt; Constr.types.

Parameter lambda_applist : Constr.constr -&gt; list Constr.constr -&gt; Constr.constr.

Parameter lambda_appvect :
  Constr.constr -&gt; array Constr.constr -&gt; Constr.constr.

Parameter lambda_applist_assum :
  Z -&gt; Constr.constr -&gt; list Constr.constr -&gt; Constr.constr.

Parameter lambda_appvect_assum :
  Z -&gt; Constr.constr -&gt; array Constr.constr -&gt; Constr.constr.

Parameter prod_appvect : Constr.types -&gt; array Constr.constr -&gt; Constr.types.

Parameter prod_applist : Constr.types -&gt; list Constr.constr -&gt; Constr.types.

Parameter prod_appvect_assum :
  Z -&gt; Constr.types -&gt; array Constr.constr -&gt; Constr.types.

Parameter prod_applist_assum :
  Z -&gt; Constr.types -&gt; list Constr.constr -&gt; Constr.types.

Parameter decompose_prod :
  Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.constr) * Constr.constr.

Parameter decompose_lam :
  Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.constr) * Constr.constr.

Parameter decompose_prod_n :
  Z -&gt; Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.constr) * Constr.constr.

Parameter decompose_lam_n :
  Z -&gt; Constr.constr -&gt;
  list (Context.binder_annot Names.Name.t * Constr.constr) * Constr.constr.

Parameter decompose_prod_assum :
  Constr.types -&gt; Constr.rel_context * Constr.types.

Parameter decompose_lam_assum :
  Constr.constr -&gt; Constr.rel_context * Constr.constr.

Parameter decompose_prod_n_assum :
  Z -&gt; Constr.types -&gt; Constr.rel_context * Constr.types.

Parameter decompose_lam_n_assum :
  Z -&gt; Constr.constr -&gt; Constr.rel_context * Constr.constr.

Parameter decompose_lam_n_decls :
  Z -&gt; Constr.constr -&gt; Constr.rel_context * Constr.constr.

Parameter prod_assum : Constr.types -&gt; Constr.rel_context.

Parameter lam_assum : Constr.constr -&gt; Constr.rel_context.

Parameter prod_n_assum : Z -&gt; Constr.types -&gt; Constr.rel_context.

Parameter lam_n_assum : Z -&gt; Constr.constr -&gt; Constr.rel_context.

Parameter strip_prod : Constr.types -&gt; Constr.types.

Parameter strip_lam : Constr.constr -&gt; Constr.constr.

Parameter strip_prod_n : Z -&gt; Constr.types -&gt; Constr.types.

Parameter strip_lam_n : Z -&gt; Constr.constr -&gt; Constr.constr.

Parameter strip_prod_assum : Constr.types -&gt; Constr.types.

Parameter strip_lam_assum : Constr.constr -&gt; Constr.constr.

Definition arity := Constr.rel_context * Sorts.t.

Parameter mkArity : arity -&gt; Constr.types.

Parameter destArity : Constr.types -&gt; arity.

Parameter isArity : Constr.types -&gt; bool.

Inductive kind_of_type (constr types : Set) : Set :=
| SortType : Sorts.t -&gt; kind_of_type constr types
| CastType : types -&gt; types -&gt; kind_of_type constr types
| ProdType :
  Context.binder_annot Names.Name.t -&gt; types -&gt; types -&gt;
  kind_of_type constr types
| LetInType :
  Context.binder_annot Names.Name.t -&gt; constr -&gt; types -&gt; types -&gt;
  kind_of_type constr types
| AtomicType : constr -&gt; array constr -&gt; kind_of_type constr types.

Arguments SortType {_ _}.
Arguments CastType {_ _}.
Arguments ProdType {_ _}.
Arguments LetInType {_ _}.
Arguments AtomicType {_ _}.

Parameter kind_of_type :
  Constr.types -&gt; kind_of_type Constr.constr Constr.types.

Inductive sorts_family : Set :=
| InSProp : sorts_family
| InProp : sorts_family
| InSet : sorts_family
| InType : sorts_family.

Inductive sorts : Set :=
| SProp : sorts
| Prop : sorts
| __Set : sorts
| Type : Univ.Universe.t -&gt; sorts.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="term_typing.ml">
  <div style="margin: 20px;">
    <h3>Term_typing</h3>
    <ul>
      <li>OCaml size: 402 lines</li>
      <li>Coq size: 551 lines (+37% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#term_typing.ml"><code>term_typing.ml</code></a>&nbsp;<span class="label label-warning">25 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created by Jacek Chrzaszcz, Aug 2002 as part of the implementation of
   the Coq module system *)

(* This module provides the main entry points for type-checking basic
   declarations *)

open CErrors
open Util
open Names
open Constr
open Declarations
open Environ
open Entries

module NamedDecl = Context.Named.Declaration

(* Insertion of constants and parameters in environment. *)

type 'a effect_handler =
  env -&gt; Constr.t -&gt; 'a -&gt; (Constr.t * Univ.ContextSet.t * int)

type _ trust =
| Pure : unit trust
| SideEffects : 'a effect_handler -&gt; 'a trust

let <abbr class="mark-warning" title="Polymorphic variant types are not handled">skip_trusted_seff</abbr> sl b e =
  let rec <abbr class="mark-warning" title="Polymorphic variant types are not handled

——————————

Polymorphic variant types are not handled">aux</abbr> sl b e acc =
    let open Context.Rel.Declaration in
    if Int.equal sl 0 then b, e, acc
    else match kind b with
    | LetIn (n,c,ty,bo) -&gt;
       aux (sl - 1) bo
         (Environ.push_rel (LocalDef (n,c,ty)) e) (<abbr class="mark-warning" title="Variants not supported">`Let(n,c,ty)</abbr>::acc)
    | App(hd,arg) -&gt;
       begin match kind hd with
       | Lambda (n,ty,bo) -&gt;
           aux (sl - 1) bo
             (Environ.push_rel (LocalAssum (n,ty)) e) (<abbr class="mark-warning" title="Variants not supported">`Cut(n,ty,arg)</abbr>::acc)
       | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
       end
    | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
    in
  aux sl b e []

let rec <abbr class="mark-warning" title="Polymorphic variant types are not handled">unzip</abbr> ctx j =
  match ctx with
  | [] -&gt; j
  | <abbr class="mark-warning" title="Patterns on variants are not supported">`Let (n,c,ty)</abbr> :: ctx -&gt;
      unzip ctx { j with uj_val = mkLetIn (n,c,ty,j.uj_val) }
  | <abbr class="mark-warning" title="Patterns on variants are not supported">`Cut (n,ty,arg)</abbr> :: ctx -&gt;
      unzip ctx { j with uj_val = mkApp (mkLambda (n,ty,j.uj_val),arg) }

let feedback_completion_typecheck =
  Option.iter (fun state_id -&gt;
      Feedback.feedback ~id:state_id Feedback.Complete)

let infer_declaration (type a) ~(trust : a trust) env (dcl : a constant_entry) =
  match dcl with
    | ParameterEntry (ctx,(t,uctx),nl) -&gt;
      let env = match uctx with
        | Monomorphic_entry uctx -&gt; push_context_set ~strict:true uctx env
        | Polymorphic_entry (_, uctx) -&gt; push_context ~strict:false uctx env
      in
      let j = Typeops.infer env t in
      let usubst, univs = Declareops.abstract_universes uctx in
      let r = Typeops.assumption_of_judgment env j in
      let t = Vars.subst_univs_level_constr usubst j.uj_val in
      {
        Cooking.cook_body = Undef nl;
        cook_type = t;
        cook_universes = univs;
        cook_private_univs = None;
        cook_relevance = r;
        cook_inline = false;
        cook_context = ctx;
      }

    (** Primitives cannot be universe polymorphic *)
    | PrimitiveEntry ({ prim_entry_type = otyp;
                        prim_entry_univs = uctxt;
                        prim_entry_content = op_t;
                      }) -&gt;
      let env = push_context_set ~strict:true uctxt env in
      let ty = match otyp with
      | Some typ -&gt;
        let typ = Typeops.infer_type env typ in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Typeops.check_primitive_type env op_t typ.utj_val;
        typ.utj_val</abbr>
      | None -&gt;
        match op_t with
        | CPrimitives.OT_op op -&gt; Typeops.type_of_prim env op
        | CPrimitives.OT_type _ -&gt; mkSet
      in
      let cd =
        match op_t with
        | CPrimitives.OT_op op -&gt; Declarations.Primitive op
        | CPrimitives.OT_type _ -&gt; Undef None in
      { Cooking.cook_body = cd;
        cook_type = ty;
        cook_universes = Monomorphic uctxt;
        cook_private_univs = None;
        cook_inline = false;
        cook_context = None;
        cook_relevance = Sorts.Relevant;
      }

  (** Definition [c] is opaque (Qed), non polymorphic and with a specified type,
      so we delay the typing and hash consing of its body. *)

  | DefinitionEntry ({ const_entry_type = Some typ;
                       const_entry_opaque = true;
                       const_entry_universes = Monomorphic_entry univs; _ } as c) -&gt;
      let env = push_context_set ~strict:true univs env in
      let { const_entry_body = body; const_entry_feedback = feedback_id; _ } = c in
      let tyj = Typeops.infer_type env typ in
      let proofterm =
        Future.chain body (fun ((body,uctx),side_eff) -&gt;
          (* don't redeclare universes which are declared for the type *)
          let uctx = Univ.ContextSet.diff uctx univs in
          let j, uctx = match trust with
          | Pure -&gt;
            let env = push_context_set uctx env in
            let j = Typeops.infer env body in
            let _ = Typeops.judge_of_cast env j DEFAULTcast tyj in
            j, uctx
          | SideEffects handle -&gt;
            let (body, uctx', valid_signatures) = handle env body side_eff in
            let uctx = Univ.ContextSet.union uctx uctx' in
            let env = push_context_set uctx env in
            let body,env,ectx = skip_trusted_seff valid_signatures body env in
            let j = Typeops.infer env body in
            let j = unzip ectx j in
            let _ = Typeops.judge_of_cast env j DEFAULTcast tyj in
            j, uctx
          in
          let c = j.uj_val in
          <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">feedback_completion_typecheck feedback_id;
          c, uctx</abbr>) in
      let def = OpaqueDef (Opaqueproof.create proofterm) in
      {
        Cooking.cook_body = def;
        cook_type = tyj.utj_val;
        cook_universes = Monomorphic univs;
        cook_private_univs = None;
        cook_relevance = Sorts.relevance_of_sort tyj.utj_type;
        cook_inline = c.const_entry_inline_code;
        cook_context = c.const_entry_secctx;
      }

  (** Similar case for polymorphic entries. TODO: also delay type-checking of
      the body. *)

  | DefinitionEntry ({ const_entry_type = Some typ;
                       const_entry_opaque = true;
                       const_entry_universes = Polymorphic_entry (nas, uctx); _ } as c) -&gt;
      let { const_entry_body = body; const_entry_feedback = feedback_id; _ } = c in
      let env = push_context ~strict:false uctx env in
      let tj = Typeops.infer_type env typ in
      let sbst, auctx = Univ.abstract_universes nas uctx in
      let usubst = Univ.make_instance_subst sbst in
      let (def, private_univs) =
        let (body, ctx), side_eff = Future.join body in
        let body, ctx = match trust with
        | Pure -&gt; body, ctx
        | SideEffects handle -&gt;
          let body, ctx', _ = handle env body side_eff in
          body, Univ.ContextSet.union ctx ctx'
        in
        (** [ctx] must contain local universes, such that it has no impact
            on the rest of the graph (up to transitivity). *)
        let env = push_subgraph ctx env in
        let private_univs = on_snd (Univ.subst_univs_level_constraints usubst) ctx in
        let j = Typeops.infer env body in
        let _ = Typeops.judge_of_cast env j DEFAULTcast tj in
        let def = Constr.hcons (Vars.subst_univs_level_constr usubst j.uj_val) in
        def, private_univs
      in
      let def = OpaqueDef (Opaqueproof.create (Future.from_val (def, Univ.ContextSet.empty))) in
      let typ = Vars.subst_univs_level_constr usubst tj.utj_val in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">feedback_completion_typecheck feedback_id;
      {
        Cooking.cook_body = def;
        cook_type = typ;
        cook_universes = Polymorphic auctx;
        cook_private_univs = Some private_univs;
        cook_relevance = Sorts.relevance_of_sort tj.utj_type;
        cook_inline = c.const_entry_inline_code;
        cook_context = c.const_entry_secctx;
      }</abbr>

  (** Other definitions have to be processed immediately. *)
  | DefinitionEntry c -&gt;
      let { const_entry_type = typ; _ } = c in
      let { const_entry_body = body; const_entry_feedback = feedback_id; _ } = c in
      (* Opaque constants must be provided with a non-empty const_entry_type,
         and thus should have been treated above. *)
      let () = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (not c.const_entry_opaque)</abbr> in
      let body, ctx = match trust with
      | Pure -&gt;
        let (body, ctx), () = Future.join body in
        body, ctx
      | SideEffects _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
      in
      let env, usubst, univs, private_univs = match c.const_entry_universes with
      | Monomorphic_entry univs -&gt;
        let ctx = Univ.ContextSet.union univs ctx in
        let env = push_context_set ~strict:true ctx env in
        env, Univ.empty_level_subst, Monomorphic ctx, None
      | Polymorphic_entry (nas, uctx) -&gt;
        (** [ctx] must contain local universes, such that it has no impact
            on the rest of the graph (up to transitivity). *)
        let env = push_context ~strict:false uctx env in
        let sbst, auctx = Univ.abstract_universes nas uctx in
        let sbst = Univ.make_instance_subst sbst in
        let env, local =
          if Univ.ContextSet.is_empty ctx then env, None
          else CErrors.anomaly Pp.(str &quot;Local universes in non-opaque polymorphic definition.&quot;)
        in
        env, sbst, Polymorphic auctx, local
      in
      let j = Typeops.infer env body in
      let typ = match typ with
        | None -&gt;
          Vars.subst_univs_level_constr usubst j.uj_type
        | Some t -&gt;
           let tj = Typeops.infer_type env t in
           let _ = Typeops.judge_of_cast env j DEFAULTcast tj in
           Vars.subst_univs_level_constr usubst tj.utj_val
      in
      let def = Vars.subst_univs_level_constr usubst j.uj_val in
      let def = Def (Mod_subst.from_val def) in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">feedback_completion_typecheck feedback_id;
      {
        Cooking.cook_body = def;
        cook_type = typ;
        cook_universes = univs;
        cook_private_univs = private_univs;
        cook_relevance = Retypeops.relevance_of_term env j.uj_val;
        cook_inline = c.const_entry_inline_code;
        cook_context = c.const_entry_secctx;
      }</abbr>

let record_aux env s_ty s_bo =
  let in_ty = keep_hyps env s_ty in
  let v =
    String.concat &quot; &quot;
      (CList.map_filter (fun decl -&gt;
          let id = NamedDecl.get_id decl in
          if List.exists (NamedDecl.get_id %&gt; Id.equal id) in_ty then None
          else Some (Id.to_string id))
        (keep_hyps env s_bo)) in
  Aux_file.record_in_aux &quot;context_used&quot; v

let build_constant_declaration _kn env result =
  let open Cooking in
  let typ = result.cook_type in
  let check declared inferred =
    let mk_set l = List.fold_right Id.Set.add (List.map NamedDecl.get_id l) Id.Set.empty in
    let inferred_set, declared_set = mk_set inferred, mk_set declared in
    if not (Id.Set.subset inferred_set declared_set) then
      let l = Id.Set.elements (Id.Set.diff inferred_set declared_set) in
      let n = List.length l in
      let declared_vars = Pp.pr_sequence Id.print (Id.Set.elements declared_set) in
      let inferred_vars = Pp.pr_sequence Id.print (Id.Set.elements inferred_set) in
      let missing_vars  = Pp.pr_sequence Id.print (List.rev l) in
      user_err Pp.(prlist str
         [&quot;The following section &quot;; (String.plural n &quot;variable&quot;); &quot; &quot;;
          (String.conjugate_verb_to_be n); &quot; used but not declared:&quot;] ++ fnl () ++
         missing_vars ++ str &quot;.&quot; ++ fnl () ++ fnl () ++
         str &quot;You can either update your proof to not depend on &quot; ++ missing_vars ++
         str &quot;, or you can update your Proof line from&quot; ++ fnl () ++
         str &quot;Proof using &quot; ++ declared_vars ++ fnl () ++
         str &quot;to&quot; ++ fnl () ++
         str &quot;Proof using &quot; ++ inferred_vars) in
  let sort l =
    List.filter (fun decl -&gt;
      let id = NamedDecl.get_id decl in
      List.exists (NamedDecl.get_id %&gt; Names.Id.equal id) l)
    (named_context env) in
  (* We try to postpone the computation of used section variables *)
  let hyps, def =
    let context_ids = List.map NamedDecl.get_id (named_context env) in
    let def = result.cook_body in
    match result.cook_context with
    | None when not (List.is_empty context_ids) -&gt;
        (* No declared section vars, and non-empty section context:
           we must look at the body NOW, if any *)
        let ids_typ = global_vars_set env typ in
        let ids_def = match def with
        | Undef _ | Primitive _ -&gt; Id.Set.empty
        | Def cs -&gt; global_vars_set env (Mod_subst.force_constr cs)
        | OpaqueDef lc -&gt;
            let vars =
              global_vars_set env
                (Opaqueproof.force_proof (opaque_tables env) lc) in
            (* we force so that cst are added to the env immediately after *)
            <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">ignore(Opaqueproof.force_constraints (opaque_tables env) lc);
            </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Aux_file.recording () then record_aux env ids_typ vars;
            vars</abbr>
        in
        keep_hyps env (Id.Set.union ids_typ ids_def), def
    | None -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Aux_file.recording () then
          record_aux env Id.Set.empty Id.Set.empty;
        [], def</abbr> (* Empty section context: no need to check *)
    | Some declared -&gt;
        (* We use the declared set and chain a check of correctness *)
        sort declared,
        match def with
        | Undef _ | Primitive _ as x -&gt; x (* nothing to check *)
        | Def cs as x -&gt;
            let ids_typ = global_vars_set env typ in
            let ids_def = global_vars_set env (Mod_subst.force_constr cs) in
            let inferred = keep_hyps env (Id.Set.union ids_typ ids_def) in
            <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check declared inferred;
            x</abbr>
        | OpaqueDef lc -&gt; (* In this case we can postpone the check *)
            OpaqueDef (Opaqueproof.iter_direct_opaque (fun c -&gt;
              let ids_typ = global_vars_set env typ in
              let ids_def = global_vars_set env c in
              let inferred = keep_hyps env (Id.Set.union ids_typ ids_def) in
              check declared inferred) lc) in
  let univs = result.cook_universes in
  let tps =
    let res = Cbytegen.compile_constant_body ~fail_on_error:false env univs def in
    Option.map Cemitcodes.from_val res
  in
  { const_hyps = hyps;
    const_body = def;
    const_type = typ;
    const_body_code = tps;
    const_universes = univs;
    const_private_poly_univs = result.cook_private_univs;
    const_relevance = result.cook_relevance;
    const_inline_code = result.cook_inline;
    const_typing_flags = Environ.typing_flags env }

(*s Global and local constant declaration. *)

let translate_constant mb env kn ce =
  build_constant_declaration kn env
    (infer_declaration ~trust:mb env ce)

let translate_local_assum env t =
  let j = Typeops.infer env t in
  let t = Typeops.assumption_of_judgment env j in
    j.uj_val, t

let translate_recipe env kn r =
  build_constant_declaration kn env (Cooking.cook_constant r)

let translate_local_def env _id centry =
  let open Cooking in
  let body = Future.from_val ((centry.secdef_body, Univ.ContextSet.empty), ()) in
  let centry = {
    const_entry_body = body;
    const_entry_secctx = centry.secdef_secctx;
    const_entry_feedback = centry.secdef_feedback;
    const_entry_type = centry.secdef_type;
    const_entry_universes = Monomorphic_entry Univ.ContextSet.empty;
    const_entry_opaque = false;
    const_entry_inline_code = false;
  } in
  let decl = infer_declaration ~trust:Pure env (DefinitionEntry centry) in
  let typ = decl.cook_type in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Option.is_empty decl.cook_context &amp;&amp; Aux_file.recording () then begin
    match decl.cook_body with
    | Undef _ -&gt; ()
    | Primitive _ -&gt; ()
    | Def _ -&gt; ()
    | OpaqueDef lc -&gt;
       let ids_typ = global_vars_set env typ in
       let ids_def = global_vars_set env
         (Opaqueproof.force_proof (opaque_tables env) lc) in
       record_aux env ids_typ ids_def
  end;
  let () = match decl.cook_universes with
  | Monomorphic ctx -&gt; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert (Univ.ContextSet.is_empty ctx)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  | Polymorphic _ -&gt; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert false</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  in
  let c = match decl.cook_body with
  | Def c -&gt; Mod_subst.force_constr c
  | OpaqueDef o -&gt;
    let p = Opaqueproof.force_proof (Environ.opaque_tables env) o in
    let cst = Opaqueproof.force_constraints (Environ.opaque_tables env) o in
    (** Let definitions are ensured to have no extra constraints coming from
        the body by virtue of the typing of [Entries.section_def_entry]. *)
    let () = </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert (Univ.ContextSet.is_empty cst)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> in
    p
  | Undef _ | Primitive _ -&gt; </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Assert instruction is not handled.">assert false</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
  in
  c, decl.cook_relevance, typ</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#term_typing.ml"><code>Term_typing.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Util.

Import Names.

Import Constr.

Import Declarations.

Import Environ.

Import Entries.

Module NamedDecl := Context.Named.Declaration.

Definition effect_handler (a : Set) :=
  Environ.env -&gt; Constr.t -&gt; a -&gt; Constr.t * Univ.ContextSet.t * Z.

Reserved Notation &quot;'trust&quot;.

Inductive trust_gadt : Set :=
| Pure : trust_gadt
| SideEffects : forall {a : Set}, effect_handler a -&gt; trust_gadt

where &quot;'trust&quot; := (fun (_ : Set) =&gt; trust_gadt).

Definition trust := 'trust.

Definition skip_trusted_seff (sl : Int.t) (b : Constr.constr) (e : Environ.env)
  : Constr.constr * Environ.env *
    list
      ((* `Let *)
      Context.binder_annot Names.Name.t * Constr.constr * Constr.types +
        (* `Cut *)
        Context.binder_annot Names.Name.t * Constr.types * array Constr.constr) :=
  let fix aux
    (sl : Int.t) (b : Constr.constr) (e : Environ.env)
    (acc :
      list
        (* `Let *)
        (Context.binder_annot Names.Name.t * Constr.constr * Constr.types))
    {struct sl}
    : Constr.constr * Environ.env *
      list
        (* `Let *)
        (Context.binder_annot Names.Name.t * Constr.constr * Constr.types) :=
    if Int.equal sl 0 then
      (b, e, acc)
    else
      match kind b with
      | Constr.LetIn n c ty bo =&gt;
        aux (Z.sub sl 1) bo
          (Environ.push_rel (Context.Rel.Declaration.LocalDef n c ty) e)
          (cons
            (* ❌ Variants not supported *)
            (* ❌ `Let *)
            (Let (n, c, ty)) acc)
      | Constr.App hd arg =&gt;
        match kind hd with
        | Constr.Lambda n ty bo =&gt;
          aux (Z.sub sl 1) bo
            (Environ.push_rel (Context.Rel.Declaration.LocalAssum n ty) e)
            (cons
              (* ❌ Variants not supported *)
              (* ❌ `Cut *)
              (Cut (n, ty, arg)) acc)
        | _ =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        end
      | _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end in
  aux sl b e [].

Fixpoint unzip {A : Set}
  (ctx :
    list
      (* `Let *)
      (Context.binder_annot Names.Name.t * Constr.constr * Constr.types))
  (j : Environ.punsafe_judgment Constr.constr A) {struct ctx}
  : Environ.punsafe_judgment Constr.constr A :=
  match ctx with
  | [] =&gt; j
  | cons (Let (n, c, ty)) ctx =&gt;
    unzip ctx
      (Environ.punsafe_judgment.with_uj_val j
        (mkLetIn (n, c, ty, (Environ.punsafe_judgment.uj_val j))))
  | cons (Cut (n, ty, arg)) ctx =&gt;
    unzip ctx
      (Environ.punsafe_judgment.with_uj_val j
        (mkApp ((mkLambda (n, ty, (Environ.punsafe_judgment.uj_val j))), arg)))
  end.

Definition feedback_completion_typecheck : option Stateid.t -&gt; unit :=
  Option.iter
    (fun state_id =&gt;
      Feedback.feedback None (Some state_id) None Feedback.Complete).

Definition infer_declaration {A : Set}
  (trust : trust A) (env : Environ.env) (dcl : Entries.constant_entry A)
  : Cooking.result :=
  match dcl with
  | Entries.ParameterEntry (ctx, (t, uctx), nl) =&gt;
    let env :=
      match uctx with
      | Entries.Monomorphic_entry uctx =&gt; push_context_set (Some true) uctx env
      | Entries.Polymorphic_entry _ uctx =&gt; push_context (Some false) uctx env
      end in
    let j := Typeops.infer env t in
    let '(usubst, univs) := Declareops.abstract_universes uctx in
    let r := Typeops.assumption_of_judgment env j in
    let t :=
      Vars.subst_univs_level_constr usubst (Environ.punsafe_judgment.uj_val j)
      in
    {| Cooking.result.cook_body := Declarations.Undef nl;
      Cooking.result.cook_type := t; Cooking.result.cook_universes := univs;
      Cooking.result.cook_private_univs := None;
      Cooking.result.cook_relevance := r; Cooking.result.cook_inline := false;
      Cooking.result.cook_context := ctx |}
  |
    Entries.PrimitiveEntry {|
      Entries.primitive_entry.prim_entry_type := otyp;
        Entries.primitive_entry.prim_entry_univs := uctxt;
        Entries.primitive_entry.prim_entry_content := op_t
        |} =&gt;
    let env := push_context_set (Some true) uctxt env in
    let ty :=
      match otyp with
      | Some typ =&gt;
        let typ := Typeops.infer_type env typ in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        Environ.punsafe_type_judgment.utj_val typ
      | None =&gt;
        match op_t with
        | CPrimitives.OT_op op =&gt; Typeops.type_of_prim env op
        | CPrimitives.OT_type _ =&gt; mkSet
        end
      end in
    let cd :=
      match op_t with
      | CPrimitives.OT_op op =&gt; Declarations.Primitive op
      | CPrimitives.OT_type _ =&gt; Declarations.Undef None
      end in
    {| Cooking.result.cook_body := cd; Cooking.result.cook_type := ty;
      Cooking.result.cook_universes := Declarations.Monomorphic uctxt;
      Cooking.result.cook_private_univs := None;
      Cooking.result.cook_relevance := Sorts.Relevant;
      Cooking.result.cook_inline := false; Cooking.result.cook_context := None
      |}
  |
    Entries.DefinitionEntry
      ({|
        Entries.definition_entry.const_entry_type := Some typ;
          Entries.definition_entry.const_entry_universes :=
            Entries.Monomorphic_entry univs;
          Entries.definition_entry.const_entry_opaque := true
          |} as c) =&gt;
    let env := push_context_set (Some true) univs env in
    let '{|
      Entries.definition_entry.const_entry_body := body;
        Entries.definition_entry.const_entry_feedback := feedback_id
        |} := c in
    let tyj := Typeops.infer_type env typ in
    let proofterm :=
      Future.chain body
        (fun function_parameter =&gt;
          let '((body, uctx), side_eff) := function_parameter in
          let uctx := Univ.ContextSet.diff uctx univs in
          let '(j, uctx) :=
            match trust with
            | Pure =&gt;
              let env := push_context_set None uctx env in
              let j := Typeops.infer env body in
              let '_ := Typeops.judge_of_cast env j Constr.DEFAULTcast tyj in
              (j, uctx)
            | SideEffects handle =&gt;
              let '(body, uctx', valid_signatures) := handle env body side_eff
                in
              let uctx := Univ.ContextSet.union uctx uctx' in
              let env := push_context_set None uctx env in
              let '(body, env, ectx) :=
                skip_trusted_seff valid_signatures body env in
              let j := Typeops.infer env body in
              let j := unzip ectx j in
              let '_ := Typeops.judge_of_cast env j Constr.DEFAULTcast tyj in
              (j, uctx)
            end in
          let c := Environ.punsafe_judgment.uj_val j in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (c, uctx)) in
    let def := Declarations.OpaqueDef (Opaqueproof.create proofterm) in
    {| Cooking.result.cook_body := def;
      Cooking.result.cook_type := Environ.punsafe_type_judgment.utj_val tyj;
      Cooking.result.cook_universes := Declarations.Monomorphic univs;
      Cooking.result.cook_private_univs := None;
      Cooking.result.cook_relevance :=
        Sorts.relevance_of_sort (Environ.punsafe_type_judgment.utj_type tyj);
      Cooking.result.cook_inline :=
        Entries.definition_entry.const_entry_inline_code c;
      Cooking.result.cook_context :=
        Entries.definition_entry.const_entry_secctx c |}
  |
    Entries.DefinitionEntry
      ({|
        Entries.definition_entry.const_entry_type := Some typ;
          Entries.definition_entry.const_entry_universes :=
            Entries.Polymorphic_entry nas uctx;
          Entries.definition_entry.const_entry_opaque := true
          |} as c) =&gt;
    let '{|
      Entries.definition_entry.const_entry_body := body;
        Entries.definition_entry.const_entry_feedback := feedback_id
        |} := c in
    let env := push_context (Some false) uctx env in
    let tj := Typeops.infer_type env typ in
    let '(sbst, auctx) := Univ.abstract_universes nas uctx in
    let usubst := Univ.make_instance_subst sbst in
    let '(def, private_univs) :=
      let '((body, ctx), side_eff) := Future.join body in
      let '(body, ctx) :=
        match trust with
        | Pure =&gt; (body, ctx)
        | SideEffects handle =&gt;
          let '(body, ctx', _) := handle env body side_eff in
          (body, (Univ.ContextSet.union ctx ctx'))
        end in
      let env := push_subgraph ctx env in
      let private_univs :=
        on_snd (Univ.subst_univs_level_constraints usubst) ctx in
      let j := Typeops.infer env body in
      let '_ := Typeops.judge_of_cast env j Constr.DEFAULTcast tj in
      let def :=
        Constr.hcons
          (Vars.subst_univs_level_constr usubst
            (Environ.punsafe_judgment.uj_val j)) in
      (def, private_univs) in
    let def :=
      Declarations.OpaqueDef
        (Opaqueproof.create (Future.from_val None (def, Univ.ContextSet.empty)))
      in
    let typ :=
      Vars.subst_univs_level_constr usubst
        (Environ.punsafe_type_judgment.utj_val tj) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    {| Cooking.result.cook_body := def; Cooking.result.cook_type := typ;
      Cooking.result.cook_universes := Declarations.Polymorphic auctx;
      Cooking.result.cook_private_univs := Some private_univs;
      Cooking.result.cook_relevance :=
        Sorts.relevance_of_sort (Environ.punsafe_type_judgment.utj_type tj);
      Cooking.result.cook_inline :=
        Entries.definition_entry.const_entry_inline_code c;
      Cooking.result.cook_context :=
        Entries.definition_entry.const_entry_secctx c |}
  | Entries.DefinitionEntry c =&gt;
    let '{| Entries.definition_entry.const_entry_type := typ |} := c in
    let '{|
      Entries.definition_entry.const_entry_body := body;
        Entries.definition_entry.const_entry_feedback := feedback_id
        |} := c in
    let '_ :=
      (* ❌ Assert instruction is not handled. *)
      assert (negb (Entries.definition_entry.const_entry_opaque c)) in
    let '(body, ctx) :=
      match trust with
      | Pure =&gt;
        let '((body, ctx), _) := Future.join body in
        (body, ctx)
      | SideEffects _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end in
    let '(env, usubst, univs, private_univs) :=
      match Entries.definition_entry.const_entry_universes c with
      | Entries.Monomorphic_entry univs =&gt;
        let ctx := Univ.ContextSet.union univs ctx in
        let env := push_context_set (Some true) ctx env in
        (env, Univ.empty_level_subst, (Declarations.Monomorphic ctx), None)
      | Entries.Polymorphic_entry nas uctx =&gt;
        let env := push_context (Some false) uctx env in
        let '(sbst, auctx) := Univ.abstract_universes nas uctx in
        let sbst := Univ.make_instance_subst sbst in
        let '(env, local) :=
          if Univ.ContextSet.is_empty ctx then
            (env, None)
          else
            CErrors.anomaly None None
              (str &quot;Local universes in non-opaque polymorphic definition.&quot;) in
        (env, sbst, (Declarations.Polymorphic auctx), local)
      end in
    let j := Typeops.infer env body in
    let typ :=
      match typ with
      | None =&gt;
        Vars.subst_univs_level_constr usubst
          (Environ.punsafe_judgment.uj_type j)
      | Some t =&gt;
        let tj := Typeops.infer_type env t in
        let '_ := Typeops.judge_of_cast env j Constr.DEFAULTcast tj in
        Vars.subst_univs_level_constr usubst
          (Environ.punsafe_type_judgment.utj_val tj)
      end in
    let def :=
      Vars.subst_univs_level_constr usubst (Environ.punsafe_judgment.uj_val j)
      in
    let def := Declarations.Def (Mod_subst.from_val def) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    {| Cooking.result.cook_body := def; Cooking.result.cook_type := typ;
      Cooking.result.cook_universes := univs;
      Cooking.result.cook_private_univs := private_univs;
      Cooking.result.cook_relevance :=
        Retypeops.relevance_of_term env (Environ.punsafe_judgment.uj_val j);
      Cooking.result.cook_inline :=
        Entries.definition_entry.const_entry_inline_code c;
      Cooking.result.cook_context :=
        Entries.definition_entry.const_entry_secctx c |}
  end.

Definition record_aux
  (env : Environ.env) (s_ty : Names.Id.__Set.t) (s_bo : Names.Id.__Set.t)
  : unit :=
  let in_ty := keep_hyps env s_ty in
  let v :=
    (|Util.String|).(CString.ExtS.concat) &quot; &quot;
      ((|CList|).(CList.ExtS.map_filter)
        (fun decl =&gt;
          let id := NamedDecl.get_id decl in
          if
            (|Util.List|).(CList.ExtS.__exists)
              (op_percentgt NamedDecl.get_id (Id.equal id)) in_ty then
            None
          else
            Some (Id.to_string id)) (keep_hyps env s_bo)) in
  Aux_file.record_in_aux &quot;context_used&quot; v.

Definition build_constant_declaration {A : Set}
  (_kn : A) (env : Environ.env) (__result_value : Cooking.result)
  : Declarations.constant_body :=
  let typ := Cooking.result.cook_type __result_value in
  let check {B C D E : Set}
    (declared : list (NamedDecl.pt B C)) (inferred : list (NamedDecl.pt D E))
    : unit :=
    let mk_set {F G : Set} (l : list (NamedDecl.pt F G)) : Names.Id.__Set.t :=
      (|Util.List|).(CList.ExtS.fold_right) Id.__Set.add
        ((|Util.List|).(CList.ExtS.map) NamedDecl.get_id l) Id.__Set.empty in
    let '(inferred_set, declared_set) := ((mk_set inferred), (mk_set declared))
      in
    if negb (Id.__Set.subset inferred_set declared_set) then
      let l := Id.__Set.elements (Id.__Set.diff inferred_set declared_set) in
      let n := (|Util.List|).(CList.ExtS.length) l in
      let declared_vars :=
        Pp.pr_sequence Id.print (Id.__Set.elements declared_set) in
      let inferred_vars :=
        Pp.pr_sequence Id.print (Id.__Set.elements inferred_set) in
      let missing_vars :=
        Pp.pr_sequence Id.print ((|Util.List|).(CList.ExtS.rev) l) in
      user_err None None
        (op_plusplus
          (op_plusplus
            (op_plusplus
              (op_plusplus
                (op_plusplus
                  (op_plusplus
                    (op_plusplus
                      (op_plusplus
                        (op_plusplus
                          (op_plusplus
                            (op_plusplus
                              (op_plusplus
                                (op_plusplus
                                  (op_plusplus
                                    (op_plusplus
                                      (op_plusplus
                                        (prlist str
                                          [
                                            &quot;The following section &quot;;
                                            (|Util.String|).(CString.ExtS.plural)
                                              n
                                              &quot;variable&quot;;
                                            &quot; &quot;;
                                            (|Util.String|).(CString.ExtS.conjugate_verb_to_be)
                                              n;
                                            &quot; used but not declared:&quot;
                                          ]) (fnl tt)) missing_vars) (str &quot;.&quot;))
                                  (fnl tt)) (fnl tt))
                              (str
                                &quot;You can either update your proof to not depend on &quot;))
                            missing_vars)
                          (str &quot;, or you can update your Proof line from&quot;))
                        (fnl tt)) (str &quot;Proof using &quot;)) declared_vars) (fnl tt))
                (str &quot;to&quot;)) (fnl tt)) (str &quot;Proof using &quot;)) inferred_vars)
    else
      tt in
  let sort {B C : Set} (l : list (NamedDecl.pt B C))
    : list (NamedDecl.pt Constr.constr Constr.types) :=
    (|Util.List|).(CList.ExtS.filter)
      (fun decl =&gt;
        let id := NamedDecl.get_id decl in
        (|Util.List|).(CList.ExtS.__exists)
          (op_percentgt NamedDecl.get_id (Names.Id.equal id)) l)
      (named_context env) in
  let '(hyps, def) :=
    let context_ids :=
      (|Util.List|).(CList.ExtS.map) NamedDecl.get_id (named_context env) in
    let def := Cooking.result.cook_body __result_value in
    match
      ((Cooking.result.cook_context __result_value),
        match Cooking.result.cook_context __result_value with
        | None =&gt; negb ((|Util.List|).(CList.ExtS.is_empty) context_ids)
        | _ =&gt; false
        end) with
    | (None, true) =&gt;
      let ids_typ := global_vars_set env typ in
      let ids_def :=
        match def with
        | Declarations.Undef _ | Declarations.Primitive _ =&gt; Id.__Set.empty
        | Declarations.Def cs =&gt; global_vars_set env (Mod_subst.force_constr cs)
        | Declarations.OpaqueDef lc =&gt;
          let vars :=
            global_vars_set env (Opaqueproof.force_proof (opaque_tables env) lc)
            in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          vars
        end in
      ((keep_hyps env (Id.__Set.union ids_typ ids_def)), def)
    | (None, _) =&gt;
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      ([], def)
    | (Some declared, _) =&gt;
      ((sort declared),
        match def with
        | (Declarations.Undef _ | Declarations.Primitive _) as x =&gt; x
        | (Declarations.Def cs) as x =&gt;
          let ids_typ := global_vars_set env typ in
          let ids_def := global_vars_set env (Mod_subst.force_constr cs) in
          let inferred := keep_hyps env (Id.__Set.union ids_typ ids_def) in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          x
        | Declarations.OpaqueDef lc =&gt;
          Declarations.OpaqueDef
            (Opaqueproof.iter_direct_opaque
              (fun c =&gt;
                let ids_typ := global_vars_set env typ in
                let ids_def := global_vars_set env c in
                let inferred := keep_hyps env (Id.__Set.union ids_typ ids_def)
                  in
                check declared inferred) lc)
        end)
    end in
  let univs := Cooking.result.cook_universes __result_value in
  let tps :=
    let res := Cbytegen.compile_constant_body false env univs def in
    Option.map Cemitcodes.from_val res in
  {| Declarations.constant_body.const_hyps := hyps;
    Declarations.constant_body.const_body := def;
    Declarations.constant_body.const_type := typ;
    Declarations.constant_body.const_relevance :=
      Cooking.result.cook_relevance __result_value;
    Declarations.constant_body.const_body_code := tps;
    Declarations.constant_body.const_universes := univs;
    Declarations.constant_body.const_private_poly_univs :=
      Cooking.result.cook_private_univs __result_value;
    Declarations.constant_body.const_inline_code :=
      Cooking.result.cook_inline __result_value;
    Declarations.constant_body.const_typing_flags := Environ.typing_flags env |}.

Definition translate_constant {A B : Set}
  (mb : trust A) (env : Environ.env) (kn : B) (ce : Entries.constant_entry A)
  : Declarations.constant_body :=
  build_constant_declaration kn env (infer_declaration mb env ce).

Definition translate_local_assum (env : Environ.env) (t : Constr.constr)
  : Constr.constr * Sorts.relevance :=
  let j := Typeops.infer env t in
  let t := Typeops.assumption_of_judgment env j in
  ((Environ.punsafe_judgment.uj_val j), t).

Definition translate_recipe {A : Set}
  (env : Environ.env) (kn : A) (r : Cooking.recipe)
  : Declarations.constant_body :=
  build_constant_declaration kn env (Cooking.cook_constant r).

Definition translate_local_def {A : Set}
  (env : Environ.env) (_id : A) (centry : Entries.section_def_entry)
  : Constr.constr * Sorts.relevance * Constr.types :=
  let body :=
    Future.from_val None
      (((Entries.section_def_entry.secdef_body centry), Univ.ContextSet.empty),
        tt) in
  let centry :=
    {| Entries.definition_entry.const_entry_body := body;
      Entries.definition_entry.const_entry_secctx :=
        Entries.section_def_entry.secdef_secctx centry;
      Entries.definition_entry.const_entry_feedback :=
        Entries.section_def_entry.secdef_feedback centry;
      Entries.definition_entry.const_entry_type :=
        Entries.section_def_entry.secdef_type centry;
      Entries.definition_entry.const_entry_universes :=
        Entries.Monomorphic_entry Univ.ContextSet.empty;
      Entries.definition_entry.const_entry_opaque := false;
      Entries.definition_entry.const_entry_inline_code := false |} in
  let decl := infer_declaration Pure env (Entries.DefinitionEntry centry) in
  let typ := Cooking.result.cook_type decl in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let '_ :=
    match Cooking.result.cook_universes decl with
    | Declarations.Monomorphic ctx =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert (Univ.ContextSet.is_empty ctx)
    | Declarations.Polymorphic _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  let c :=
    match Cooking.result.cook_body decl with
    | Declarations.Def c =&gt; Mod_subst.force_constr c
    | Declarations.OpaqueDef o =&gt;
      let p := Opaqueproof.force_proof (Environ.opaque_tables env) o in
      let cst := Opaqueproof.force_constraints (Environ.opaque_tables env) o in
      let '_ :=
        (* ❌ Assert instruction is not handled. *)
        assert (Univ.ContextSet.is_empty cst) in
      p
    | Declarations.Undef _ | Declarations.Primitive _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end in
  (c, (Cooking.result.cook_relevance decl), typ).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="term_typing.mli">
  <div style="margin: 20px;">
    <h3>Term_typing_mli</h3>
    <ul>
      <li>OCaml size: 46 lines</li>
      <li>Coq size: 45 lines (-3% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#term_typing.mli"><code>term_typing.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Environ
open Declarations
open Entries

(** Handlers are used to manage side-effects. The ['a] type stands for the type
    of side-effects, and it is parametric because they are only defined later
    on. Handlers inline the provided side-effects into the term, and return
    the set of additional global constraints that need to be added for the term
    to be well typed. *)
type 'a effect_handler =
  env -&gt; Constr.t -&gt; 'a -&gt; (Constr.t * Univ.ContextSet.t * int)

type _ trust =
| Pure : unit trust
| SideEffects : 'a effect_handler -&gt; 'a trust

val translate_local_def : env -&gt; Id.t -&gt; section_def_entry -&gt;
  constr * Sorts.relevance * types

val translate_local_assum : env -&gt; types -&gt; types * Sorts.relevance

val translate_constant :
  'a trust -&gt; env -&gt; Constant.t -&gt; 'a constant_entry -&gt;
    constant_body

val translate_recipe : env -&gt; Constant.t -&gt; Cooking.recipe -&gt; constant_body

(** Internal functions, mentioned here for debug purpose only *)

val infer_declaration : trust:'a trust -&gt; env -&gt;
  'a constant_entry -&gt; Cooking.result

val build_constant_declaration :
  Constant.t -&gt; env -&gt; Cooking.result -&gt; constant_body
</pre>
  </div>
  <div class="col-md-6">
    <a href="#term_typing.mli"><code>Term_typing_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition effect_handler (a : Set) :=
  Environ.env -&gt; Constr.t -&gt; a -&gt; Constr.t * Univ.ContextSet.t * Z.

Reserved Notation &quot;'trust&quot;.

Inductive trust_gadt : Set :=
| Pure : trust_gadt
| SideEffects : forall {a : Set}, effect_handler a -&gt; trust_gadt

where &quot;'trust&quot; := (fun (_ : Set) =&gt; trust_gadt).

Definition trust := 'trust.

Parameter translate_local_def :
  Environ.env -&gt; Names.Id.t -&gt; Entries.section_def_entry -&gt;
  Constr.constr * Sorts.relevance * Constr.types.

Parameter translate_local_assum :
  Environ.env -&gt; Constr.types -&gt; Constr.types * Sorts.relevance.

Parameter translate_constant : forall {a : Set},
  trust a -&gt; Environ.env -&gt; Names.Constant.t -&gt; Entries.constant_entry a -&gt;
  Declarations.constant_body.

Parameter translate_recipe :
  Environ.env -&gt; Names.Constant.t -&gt; Cooking.recipe -&gt;
  Declarations.constant_body.

Parameter infer_declaration : forall {a : Set},
  trust a -&gt; Environ.env -&gt; Entries.constant_entry a -&gt; Cooking.result.

Parameter build_constant_declaration :
  Names.Constant.t -&gt; Environ.env -&gt; Cooking.result -&gt;
  Declarations.constant_body.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="transparentState.ml">
  <div style="margin: 20px;">
    <h3>TransparentState</h3>
    <ul>
      <li>OCaml size: 45 lines</li>
      <li>Coq size: 42 lines (-7% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#transparentState.ml"><code>transparentState.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

type t = {
  tr_var : Id.Pred.t;
  tr_cst : Cpred.t;
}

let empty = {
  tr_var = Id.Pred.empty;
  tr_cst = Cpred.empty;
}

let full = {
  tr_var = Id.Pred.full;
  tr_cst = Cpred.full;
}

let var_full = {
  tr_var = Id.Pred.full;
  tr_cst = Cpred.empty;
}

let cst_full = {
  tr_var = Id.Pred.empty;
  tr_cst = Cpred.full;
}

let is_empty ts =
  Id.Pred.is_empty ts.tr_var &amp;&amp; Cpred.is_empty ts.tr_cst

let is_transparent_variable ts id =
  Id.Pred.mem id ts.tr_var

let is_transparent_constant ts cst =
  Cpred.mem cst ts.tr_cst
</pre>
  </div>
  <div class="col-md-6">
    <a href="#transparentState.ml"><code>TransparentState.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Module t.
  Record record := {
    tr_var : Names.Id.Pred.t;
    tr_cst : Names.Cpred.t }.
  Definition with_tr_var (r : record) tr_var : record :=
    {| tr_var := tr_var; tr_cst := tr_cst r |}.
  Definition with_tr_cst (r : record) tr_cst : record :=
    {| tr_var := tr_var r; tr_cst := tr_cst |}.
End t.
Definition t := t.record.

Definition empty : t := {| t.tr_var := Id.Pred.empty; t.tr_cst := Cpred.empty |}.

Definition full : t := {| t.tr_var := Id.Pred.full; t.tr_cst := Cpred.full |}.

Definition var_full : t :=
  {| t.tr_var := Id.Pred.full; t.tr_cst := Cpred.empty |}.

Definition cst_full : t :=
  {| t.tr_var := Id.Pred.empty; t.tr_cst := Cpred.full |}.

Definition is_empty (ts : t) : bool :=
  andb (Id.Pred.is_empty (t.tr_var ts)) (Cpred.is_empty (t.tr_cst ts)).

Definition is_transparent_variable (ts : t) (id : Names.Id.Pred.elt) : bool :=
  Id.Pred.mem id (t.tr_var ts).

Definition is_transparent_constant (ts : t) (cst : Names.Cpred.elt) : bool :=
  Cpred.mem cst (t.tr_cst ts).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="transparentState.mli">
  <div style="margin: 20px;">
    <h3>TransparentState_mli</h3>
    <ul>
      <li>OCaml size: 34 lines</li>
      <li>Coq size: 35 lines (+2% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#transparentState.mli"><code>transparentState.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

(** Sets of names *)
type t = {
  tr_var : Id.Pred.t;
  tr_cst : Cpred.t;
}

val empty : t
(** Everything opaque *)

val full : t
(** Everything transparent *)

val var_full : t
(** All variables transparent *)

val cst_full : t
(** All constant transparent *)

val is_empty : t -&gt; bool

val is_transparent_variable : t -&gt; Id.t -&gt; bool
val is_transparent_constant : t -&gt; Constant.t -&gt; bool
</pre>
  </div>
  <div class="col-md-6">
    <a href="#transparentState.mli"><code>TransparentState_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Module t.
  Record record := {
    tr_var : Names.Id.Pred.t;
    tr_cst : Names.Cpred.t }.
  Definition with_tr_var (r : record) tr_var : record :=
    {| tr_var := tr_var; tr_cst := tr_cst r |}.
  Definition with_tr_cst (r : record) tr_cst : record :=
    {| tr_var := tr_var r; tr_cst := tr_cst |}.
End t.
Definition t := t.record.

Parameter empty : t.

Parameter full : t.

Parameter var_full : t.

Parameter cst_full : t.

Parameter is_empty : t -&gt; bool.

Parameter is_transparent_variable : t -&gt; Names.Id.t -&gt; bool.

Parameter is_transparent_constant : t -&gt; Names.Constant.t -&gt; bool.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="type_errors.ml">
  <div style="margin: 20px;">
    <h3>Type_errors</h3>
    <ul>
      <li>OCaml size: 203 lines</li>
      <li>Coq size: 322 lines (+58% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#type_errors.ml"><code>type_errors.ml</code></a>&nbsp;<span class="label label-warning">22 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Environ
open Reduction

(* Type errors. *)

type 'constr pguard_error =
  (* Fixpoints *)
  | NotEnoughAbstractionInFixBody
  | RecursionNotOnInductiveType of 'constr
  | RecursionOnIllegalTerm of int * (env * 'constr) * int list * int list
  | NotEnoughArgumentsForFixCall of int
  (* CoFixpoints *)
  | CodomainNotInductiveType of 'constr
  | NestedRecursiveOccurrences
  | UnguardedRecursiveCall of 'constr
  | RecCallInTypeOfAbstraction of 'constr
  | RecCallInNonRecArgOfConstructor of 'constr
  | RecCallInTypeOfDef of 'constr
  | RecCallInCaseFun of 'constr
  | RecCallInCaseArg of 'constr
  | RecCallInCasePred of 'constr
  | NotGuardedForm of 'constr
  | ReturnPredicateNotCoInductive of 'constr
  | FixpointOnIrrelevantInductive

type guard_error = constr pguard_error

type arity_error =
  | NonInformativeToInformative
  | StrongEliminationOnNonSmallType
  | WrongArity

type ('constr, 'types) ptype_error =
  | UnboundRel of int
  | UnboundVar of variable
  | NotAType of ('constr, 'types) punsafe_judgment
  | BadAssumption of ('constr, 'types) punsafe_judgment
  | ReferenceVariables of Id.t * 'constr
  | ElimArity of pinductive * 'constr * ('constr, 'types) punsafe_judgment
      * (Sorts.family list * Sorts.family * Sorts.family * arity_error) option
  | CaseNotInductive of ('constr, 'types) punsafe_judgment
  | WrongCaseInfo of pinductive * case_info
  | NumberBranches of ('constr, 'types) punsafe_judgment * int
  | IllFormedBranch of 'constr * pconstructor * 'constr * 'constr
  | Generalization of (Name.t * 'types) * ('constr, 'types) punsafe_judgment
  | ActualType of ('constr, 'types) punsafe_judgment * 'types
  | IncorrectPrimitive of (CPrimitives.op_or_type,'types) punsafe_judgment * 'types
  | CantApplyBadType of
      (int * 'constr * 'constr) * ('constr, 'types) punsafe_judgment * ('constr, 'types) punsafe_judgment array
  | CantApplyNonFunctional of ('constr, 'types) punsafe_judgment * ('constr, 'types) punsafe_judgment array
  | IllFormedRecBody of 'constr pguard_error * Name.t Context.binder_annot array * int * env * ('constr, 'types) punsafe_judgment array
  | IllTypedRecBody of
      int * Name.t Context.binder_annot array * ('constr, 'types) punsafe_judgment array * 'types array
  | UnsatisfiedConstraints of Univ.Constraint.t
  | UndeclaredUniverse of Univ.Level.t
  | DisallowedSProp
  | BadRelevance

type type_error = (constr, types) ptype_error

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception TypeError of env * type_error</abbr>

type inductive_error =
  | NonPos of env * constr * constr
  | NotEnoughArgs of env * constr * constr
  | NotConstructor of env * Id.t * constr * constr * int * int
  | NonPar of env * constr * int * constr * constr
  | SameNamesTypes of Id.t
  | SameNamesConstructors of Id.t
  | SameNamesOverlap of Id.t list
  | NotAnArity of env * constr
  | BadEntry
  | LargeNonPropInductiveNotInType
  | BadUnivs

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception InductiveError of inductive_error</abbr>

let nfj env {uj_val=c;uj_type=ct} =
  {uj_val=c;uj_type=nf_betaiota env ct}

let error_unbound_rel env n =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, UnboundRel n))</abbr>

let error_unbound_var env v =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, UnboundVar v))</abbr>

let error_not_type env j =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, NotAType j))</abbr>

let error_assumption env j =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, BadAssumption j))</abbr>

let error_reference_variables env id c =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, ReferenceVariables (id,c)))</abbr>

let error_elim_arity env ind c pj okinds =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, ElimArity (ind,c,pj,okinds)))</abbr>

let error_case_not_inductive env j =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, CaseNotInductive j))</abbr>

let error_number_branches env cj expn =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, NumberBranches (nfj env cj,expn)))</abbr>

let error_ill_formed_branch env c i actty expty =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env,
    IllFormedBranch (c,i,nf_betaiota env actty, nf_betaiota env expty)))</abbr>

let error_generalization env nvar c =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, Generalization (nvar,c)))</abbr>

let error_actual_type env j expty =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, ActualType (j,expty)))</abbr>

let error_incorrect_primitive env p t =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, IncorrectPrimitive (p, t)))</abbr>

let error_cant_apply_not_functional env rator randl =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, CantApplyNonFunctional (rator,randl)))</abbr>

let error_cant_apply_bad_type env t rator randl =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, CantApplyBadType (t,rator,randl)))</abbr>

let error_ill_formed_rec_body env why lna i fixenv vdefj =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, IllFormedRecBody (why,lna,i,fixenv,vdefj)))</abbr>

let error_ill_typed_rec_body env i lna vdefj vargs =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, IllTypedRecBody (i,lna,vdefj,vargs)))</abbr>

let error_elim_explain kp ki =
  let open Sorts in
  match kp,ki with
  | (InType | InSet), InProp -&gt; NonInformativeToInformative
  | InType, InSet -&gt; StrongEliminationOnNonSmallType (* if Set impredicative *)
  | _ -&gt; WrongArity

let error_unsatisfied_constraints env c =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, UnsatisfiedConstraints c))</abbr>

let error_undeclared_universe env l =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, UndeclaredUniverse l))</abbr>

let error_disallowed_sprop env =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, DisallowedSProp))</abbr>

let error_bad_relevance env =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(TypeError (env, BadRelevance))</abbr>

let map_pguard_error f = function
| NotEnoughAbstractionInFixBody -&gt; NotEnoughAbstractionInFixBody
| RecursionNotOnInductiveType c -&gt; RecursionNotOnInductiveType (f c)
| RecursionOnIllegalTerm (n, (env, c), l1, l2) -&gt; RecursionOnIllegalTerm (n, (env, f c), l1, l2)
| NotEnoughArgumentsForFixCall n -&gt; NotEnoughArgumentsForFixCall n
| CodomainNotInductiveType c -&gt; CodomainNotInductiveType (f c)
| NestedRecursiveOccurrences -&gt; NestedRecursiveOccurrences
| UnguardedRecursiveCall c -&gt; UnguardedRecursiveCall (f c)
| RecCallInTypeOfAbstraction c -&gt; RecCallInTypeOfAbstraction (f c)
| RecCallInNonRecArgOfConstructor c -&gt; RecCallInNonRecArgOfConstructor (f c)
| RecCallInTypeOfDef c -&gt; RecCallInTypeOfDef (f c)
| RecCallInCaseFun c -&gt; RecCallInCaseFun (f c)
| RecCallInCaseArg c -&gt; RecCallInCaseArg (f c)
| RecCallInCasePred c -&gt; RecCallInCasePred (f c)
| NotGuardedForm c -&gt; NotGuardedForm (f c)
| ReturnPredicateNotCoInductive c -&gt; ReturnPredicateNotCoInductive (f c)
| FixpointOnIrrelevantInductive -&gt; FixpointOnIrrelevantInductive

let map_ptype_error f = function
| UnboundRel n -&gt; UnboundRel n
| UnboundVar id -&gt; UnboundVar id
| NotAType j -&gt; NotAType (on_judgment f j)
| BadAssumption j -&gt; BadAssumption (on_judgment f j)
| ReferenceVariables (id, c) -&gt; ReferenceVariables (id, f c)
| ElimArity (pi, c, j, ar) -&gt; ElimArity (pi, f c, on_judgment f j, ar)
| CaseNotInductive j -&gt; CaseNotInductive (on_judgment f j)
| WrongCaseInfo (pi, ci) -&gt; WrongCaseInfo (pi, ci)
| NumberBranches (j, n) -&gt; NumberBranches (on_judgment f j, n)
| IllFormedBranch (c, pc, t1, t2) -&gt; IllFormedBranch (f c, pc, f t1, f t2)
| Generalization ((na, t), j) -&gt; Generalization ((na, f t), on_judgment f j)
| ActualType (j, t) -&gt; ActualType (on_judgment f j, f t)
| IncorrectPrimitive (p, t) -&gt; IncorrectPrimitive ({p with uj_type=f p.uj_type}, f t)
| CantApplyBadType ((n, c1, c2), j, vj) -&gt;
  CantApplyBadType ((n, f c1, f c2), on_judgment f j, Array.map (on_judgment f) vj)
| CantApplyNonFunctional (j, jv) -&gt; CantApplyNonFunctional (on_judgment f j, Array.map (on_judgment f) jv)
| IllFormedRecBody (ge, na, n, env, jv) -&gt;
  IllFormedRecBody (map_pguard_error f ge, na, n, env, Array.map (on_judgment f) jv)
| IllTypedRecBody (n, na, jv, t) -&gt;
  IllTypedRecBody (n, na, Array.map (on_judgment f) jv, Array.map f t)
| UnsatisfiedConstraints g -&gt; UnsatisfiedConstraints g
| UndeclaredUniverse l -&gt; UndeclaredUniverse l
| DisallowedSProp -&gt; DisallowedSProp
| BadRelevance -&gt; BadRelevance
</pre>
  </div>
  <div class="col-md-6">
    <a href="#type_errors.ml"><code>Type_errors.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Constr.

Import Environ.

Import Reduction.

Inductive pguard_error (constr : Set) : Set :=
| NotEnoughAbstractionInFixBody : pguard_error constr
| RecursionNotOnInductiveType : constr -&gt; pguard_error constr
| RecursionOnIllegalTerm :
  Z -&gt; Environ.env * constr -&gt; list Z -&gt; list Z -&gt; pguard_error constr
| NotEnoughArgumentsForFixCall : Z -&gt; pguard_error constr
| CodomainNotInductiveType : constr -&gt; pguard_error constr
| NestedRecursiveOccurrences : pguard_error constr
| UnguardedRecursiveCall : constr -&gt; pguard_error constr
| RecCallInTypeOfAbstraction : constr -&gt; pguard_error constr
| RecCallInNonRecArgOfConstructor : constr -&gt; pguard_error constr
| RecCallInTypeOfDef : constr -&gt; pguard_error constr
| RecCallInCaseFun : constr -&gt; pguard_error constr
| RecCallInCaseArg : constr -&gt; pguard_error constr
| RecCallInCasePred : constr -&gt; pguard_error constr
| NotGuardedForm : constr -&gt; pguard_error constr
| ReturnPredicateNotCoInductive : constr -&gt; pguard_error constr
| FixpointOnIrrelevantInductive : pguard_error constr.

Arguments NotEnoughAbstractionInFixBody {_}.
Arguments RecursionNotOnInductiveType {_}.
Arguments RecursionOnIllegalTerm {_}.
Arguments NotEnoughArgumentsForFixCall {_}.
Arguments CodomainNotInductiveType {_}.
Arguments NestedRecursiveOccurrences {_}.
Arguments UnguardedRecursiveCall {_}.
Arguments RecCallInTypeOfAbstraction {_}.
Arguments RecCallInNonRecArgOfConstructor {_}.
Arguments RecCallInTypeOfDef {_}.
Arguments RecCallInCaseFun {_}.
Arguments RecCallInCaseArg {_}.
Arguments RecCallInCasePred {_}.
Arguments NotGuardedForm {_}.
Arguments ReturnPredicateNotCoInductive {_}.
Arguments FixpointOnIrrelevantInductive {_}.

Definition guard_error := pguard_error Constr.constr.

Inductive arity_error : Set :=
| NonInformativeToInformative : arity_error
| StrongEliminationOnNonSmallType : arity_error
| WrongArity : arity_error.

Inductive ptype_error (constr types : Set) : Set :=
| UnboundRel : Z -&gt; ptype_error constr types
| UnboundVar : Names.variable -&gt; ptype_error constr types
| NotAType : Environ.punsafe_judgment constr types -&gt; ptype_error constr types
| BadAssumption :
  Environ.punsafe_judgment constr types -&gt; ptype_error constr types
| ReferenceVariables : Names.Id.t -&gt; constr -&gt; ptype_error constr types
| ElimArity :
  Constr.pinductive -&gt; constr -&gt; Environ.punsafe_judgment constr types -&gt;
  option (list Sorts.family * Sorts.family * Sorts.family * arity_error) -&gt;
  ptype_error constr types
| CaseNotInductive :
  Environ.punsafe_judgment constr types -&gt; ptype_error constr types
| WrongCaseInfo :
  Constr.pinductive -&gt; Constr.case_info -&gt; ptype_error constr types
| NumberBranches :
  Environ.punsafe_judgment constr types -&gt; Z -&gt; ptype_error constr types
| IllFormedBranch :
  constr -&gt; Constr.pconstructor -&gt; constr -&gt; constr -&gt; ptype_error constr types
| Generalization :
  Names.Name.t * types -&gt; Environ.punsafe_judgment constr types -&gt;
  ptype_error constr types
| ActualType :
  Environ.punsafe_judgment constr types -&gt; types -&gt; ptype_error constr types
| IncorrectPrimitive :
  Environ.punsafe_judgment CPrimitives.op_or_type types -&gt; types -&gt;
  ptype_error constr types
| CantApplyBadType :
  Z * constr * constr -&gt; Environ.punsafe_judgment constr types -&gt;
  array (Environ.punsafe_judgment constr types) -&gt; ptype_error constr types
| CantApplyNonFunctional :
  Environ.punsafe_judgment constr types -&gt;
  array (Environ.punsafe_judgment constr types) -&gt; ptype_error constr types
| IllFormedRecBody :
  pguard_error constr -&gt; array (Context.binder_annot Names.Name.t) -&gt; Z -&gt;
  Environ.env -&gt; array (Environ.punsafe_judgment constr types) -&gt;
  ptype_error constr types
| IllTypedRecBody :
  Z -&gt; array (Context.binder_annot Names.Name.t) -&gt;
  array (Environ.punsafe_judgment constr types) -&gt; array types -&gt;
  ptype_error constr types
| UnsatisfiedConstraints : Univ.Constraint.t -&gt; ptype_error constr types
| UndeclaredUniverse : Univ.Level.t -&gt; ptype_error constr types
| DisallowedSProp : ptype_error constr types
| BadRelevance : ptype_error constr types.

Arguments UnboundRel {_ _}.
Arguments UnboundVar {_ _}.
Arguments NotAType {_ _}.
Arguments BadAssumption {_ _}.
Arguments ReferenceVariables {_ _}.
Arguments ElimArity {_ _}.
Arguments CaseNotInductive {_ _}.
Arguments WrongCaseInfo {_ _}.
Arguments NumberBranches {_ _}.
Arguments IllFormedBranch {_ _}.
Arguments Generalization {_ _}.
Arguments ActualType {_ _}.
Arguments IncorrectPrimitive {_ _}.
Arguments CantApplyBadType {_ _}.
Arguments CantApplyNonFunctional {_ _}.
Arguments IllFormedRecBody {_ _}.
Arguments IllTypedRecBody {_ _}.
Arguments UnsatisfiedConstraints {_ _}.
Arguments UndeclaredUniverse {_ _}.
Arguments DisallowedSProp {_ _}.
Arguments BadRelevance {_ _}.

Definition type_error := ptype_error Constr.constr Constr.types.

(* ❌ The definition of exceptions is not handled. *)
(* exception TypeError *)

Inductive inductive_error : Set :=
| NonPos : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotEnoughArgs :
  Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotConstructor :
  Environ.env -&gt; Names.Id.t -&gt; Constr.constr -&gt; Constr.constr -&gt; Z -&gt; Z -&gt;
  inductive_error
| NonPar :
  Environ.env -&gt; Constr.constr -&gt; Z -&gt; Constr.constr -&gt; Constr.constr -&gt;
  inductive_error
| SameNamesTypes : Names.Id.t -&gt; inductive_error
| SameNamesConstructors : Names.Id.t -&gt; inductive_error
| SameNamesOverlap : list Names.Id.t -&gt; inductive_error
| NotAnArity : Environ.env -&gt; Constr.constr -&gt; inductive_error
| BadEntry : inductive_error
| LargeNonPropInductiveNotInType : inductive_error
| BadUnivs : inductive_error.

(* ❌ The definition of exceptions is not handled. *)
(* exception InductiveError *)

Definition nfj {A : Set}
  (env : Environ.env)
  (function_parameter : Environ.punsafe_judgment A Constr.constr)
  : Environ.punsafe_judgment A Constr.constr :=
  let '{|
    Environ.punsafe_judgment.uj_val := c;
      Environ.punsafe_judgment.uj_type := ct
      |} := function_parameter in
  {| Environ.punsafe_judgment.uj_val := c;
    Environ.punsafe_judgment.uj_type := nf_betaiota env ct |}.

Definition error_unbound_rel {A : Set} (env : Environ.env) (n : Z) : A :=
  Stdlib.raise extensible_type_value.

Definition error_unbound_var {A : Set} (env : Environ.env) (v : Names.variable)
  : A := Stdlib.raise extensible_type_value.

Definition error_not_type {A : Set}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  : A := Stdlib.raise extensible_type_value.

Definition error_assumption {A : Set}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  : A := Stdlib.raise extensible_type_value.

Definition error_reference_variables {A : Set}
  (env : Environ.env) (id : Names.Id.t) (c : Constr.constr) : A :=
  Stdlib.raise extensible_type_value.

Definition error_elim_arity {A : Set}
  (env : Environ.env) (ind : Constr.pinductive) (c : Constr.constr)
  (pj : Environ.punsafe_judgment Constr.constr Constr.types)
  (okinds :
    option (list Sorts.family * Sorts.family * Sorts.family * arity_error))
  : A := Stdlib.raise extensible_type_value.

Definition error_case_not_inductive {A : Set}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  : A := Stdlib.raise extensible_type_value.

Definition error_number_branches {A : Set}
  (env : Environ.env)
  (cj : Environ.punsafe_judgment Constr.constr Constr.constr) (expn : Z) : A :=
  Stdlib.raise extensible_type_value.

Definition error_ill_formed_branch {A : Set}
  (env : Environ.env) (c : Constr.constr) (i : Constr.pconstructor)
  (actty : Constr.constr) (expty : Constr.constr) : A :=
  Stdlib.raise extensible_type_value.

Definition error_generalization {A : Set}
  (env : Environ.env) (nvar : Names.Name.t * Constr.types)
  (c : Environ.punsafe_judgment Constr.constr Constr.types) : A :=
  Stdlib.raise extensible_type_value.

Definition error_actual_type {A : Set}
  (env : Environ.env) (j : Environ.punsafe_judgment Constr.constr Constr.types)
  (expty : Constr.types) : A := Stdlib.raise extensible_type_value.

Definition error_incorrect_primitive {A : Set}
  (env : Environ.env)
  (p : Environ.punsafe_judgment CPrimitives.op_or_type Constr.types)
  (t : Constr.types) : A := Stdlib.raise extensible_type_value.

Definition error_cant_apply_not_functional {A : Set}
  (env : Environ.env)
  (rator : Environ.punsafe_judgment Constr.constr Constr.types)
  (randl : array (Environ.punsafe_judgment Constr.constr Constr.types)) : A :=
  Stdlib.raise extensible_type_value.

Definition error_cant_apply_bad_type {A : Set}
  (env : Environ.env) (t : Z * Constr.constr * Constr.constr)
  (rator : Environ.punsafe_judgment Constr.constr Constr.types)
  (randl : array (Environ.punsafe_judgment Constr.constr Constr.types)) : A :=
  Stdlib.raise extensible_type_value.

Definition error_ill_formed_rec_body {A : Set}
  (env : Environ.env) (why : pguard_error Constr.constr)
  (lna : array (Context.binder_annot Names.Name.t)) (i : Z)
  (fixenv : Environ.env)
  (vdefj : array (Environ.punsafe_judgment Constr.constr Constr.types)) : A :=
  Stdlib.raise extensible_type_value.

Definition error_ill_typed_rec_body {A : Set}
  (env : Environ.env) (i : Z) (lna : array (Context.binder_annot Names.Name.t))
  (vdefj : array (Environ.punsafe_judgment Constr.constr Constr.types))
  (vargs : array Constr.types) : A := Stdlib.raise extensible_type_value.

Definition error_elim_explain (kp : Sorts.family) (ki : Sorts.family)
  : arity_error :=
  match (kp, ki) with
  | (Sorts.InType | Sorts.InSet, Sorts.InProp) =&gt; NonInformativeToInformative
  | (Sorts.InType, Sorts.InSet) =&gt; StrongEliminationOnNonSmallType
  | _ =&gt; WrongArity
  end.

Definition error_unsatisfied_constraints {A : Set}
  (env : Environ.env) (c : Univ.Constraint.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_undeclared_universe {A : Set}
  (env : Environ.env) (l : Univ.Level.t) : A :=
  Stdlib.raise extensible_type_value.

Definition error_disallowed_sprop {A : Set} (env : Environ.env) : A :=
  Stdlib.raise extensible_type_value.

Definition error_bad_relevance {A : Set} (env : Environ.env) : A :=
  Stdlib.raise extensible_type_value.

Definition map_pguard_error {A B : Set}
  (f : A -&gt; B) (function_parameter : pguard_error A) : pguard_error B :=
  match function_parameter with
  | NotEnoughAbstractionInFixBody =&gt; NotEnoughAbstractionInFixBody
  | RecursionNotOnInductiveType c =&gt; RecursionNotOnInductiveType (f c)
  | RecursionOnIllegalTerm n (env, c) l1 l2 =&gt;
    RecursionOnIllegalTerm n (env, (f c)) l1 l2
  | NotEnoughArgumentsForFixCall n =&gt; NotEnoughArgumentsForFixCall n
  | CodomainNotInductiveType c =&gt; CodomainNotInductiveType (f c)
  | NestedRecursiveOccurrences =&gt; NestedRecursiveOccurrences
  | UnguardedRecursiveCall c =&gt; UnguardedRecursiveCall (f c)
  | RecCallInTypeOfAbstraction c =&gt; RecCallInTypeOfAbstraction (f c)
  | RecCallInNonRecArgOfConstructor c =&gt; RecCallInNonRecArgOfConstructor (f c)
  | RecCallInTypeOfDef c =&gt; RecCallInTypeOfDef (f c)
  | RecCallInCaseFun c =&gt; RecCallInCaseFun (f c)
  | RecCallInCaseArg c =&gt; RecCallInCaseArg (f c)
  | RecCallInCasePred c =&gt; RecCallInCasePred (f c)
  | NotGuardedForm c =&gt; NotGuardedForm (f c)
  | ReturnPredicateNotCoInductive c =&gt; ReturnPredicateNotCoInductive (f c)
  | FixpointOnIrrelevantInductive =&gt; FixpointOnIrrelevantInductive
  end.

Definition map_ptype_error {A B : Set}
  (f : A -&gt; B) (function_parameter : ptype_error A A) : ptype_error B B :=
  match function_parameter with
  | UnboundRel n =&gt; UnboundRel n
  | UnboundVar id =&gt; UnboundVar id
  | NotAType j =&gt; NotAType (on_judgment f j)
  | BadAssumption j =&gt; BadAssumption (on_judgment f j)
  | ReferenceVariables id c =&gt; ReferenceVariables id (f c)
  | ElimArity pi c j ar =&gt; ElimArity pi (f c) (on_judgment f j) ar
  | CaseNotInductive j =&gt; CaseNotInductive (on_judgment f j)
  | WrongCaseInfo pi ci =&gt; WrongCaseInfo pi ci
  | NumberBranches j n =&gt; NumberBranches (on_judgment f j) n
  | IllFormedBranch c pc t1 t2 =&gt; IllFormedBranch (f c) pc (f t1) (f t2)
  | Generalization (na, t) j =&gt; Generalization (na, (f t)) (on_judgment f j)
  | ActualType j t =&gt; ActualType (on_judgment f j) (f t)
  | IncorrectPrimitive p t =&gt;
    IncorrectPrimitive
      (Environ.punsafe_judgment.with_uj_type p
        (f (Environ.punsafe_judgment.uj_type p))) (f t)
  | CantApplyBadType (n, c1, c2) j vj =&gt;
    CantApplyBadType (n, (f c1), (f c2)) (on_judgment f j)
      (Array.map (on_judgment f) vj)
  | CantApplyNonFunctional j jv =&gt;
    CantApplyNonFunctional (on_judgment f j) (Array.map (on_judgment f) jv)
  | IllFormedRecBody ge na n env jv =&gt;
    IllFormedRecBody (map_pguard_error f ge) na n env
      (Array.map (on_judgment f) jv)
  | IllTypedRecBody n na jv t =&gt;
    IllTypedRecBody n na (Array.map (on_judgment f) jv) (Array.map f t)
  | UnsatisfiedConstraints g =&gt; UnsatisfiedConstraints g
  | UndeclaredUniverse l =&gt; UndeclaredUniverse l
  | DisallowedSProp =&gt; DisallowedSProp
  | BadRelevance =&gt; BadRelevance
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="type_errors.mli">
  <div style="margin: 20px;">
    <h3>Type_errors_mli</h3>
    <ul>
      <li>OCaml size: 145 lines</li>
      <li>Coq size: 217 lines (+49% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#type_errors.mli"><code>type_errors.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Environ

(** Type errors. {% \label{typeerrors} %} *)

(*i Rem: NotEnoughAbstractionInFixBody should only occur with &quot;/i&quot; Fix
    notation i*)
type 'constr pguard_error =
  (** Fixpoints *)
  | NotEnoughAbstractionInFixBody
  | RecursionNotOnInductiveType of 'constr
  | RecursionOnIllegalTerm of int * (env * 'constr) * int list * int list
  | NotEnoughArgumentsForFixCall of int
  (** CoFixpoints *)
  | CodomainNotInductiveType of 'constr
  | NestedRecursiveOccurrences
  | UnguardedRecursiveCall of 'constr
  | RecCallInTypeOfAbstraction of 'constr
  | RecCallInNonRecArgOfConstructor of 'constr
  | RecCallInTypeOfDef of 'constr
  | RecCallInCaseFun of 'constr
  | RecCallInCaseArg of 'constr
  | RecCallInCasePred of 'constr
  | NotGuardedForm of 'constr
  | ReturnPredicateNotCoInductive of 'constr
  | FixpointOnIrrelevantInductive

type guard_error = constr pguard_error

type arity_error =
  | NonInformativeToInformative
  | StrongEliminationOnNonSmallType
  | WrongArity

type ('constr, 'types) ptype_error =
  | UnboundRel of int
  | UnboundVar of variable
  | NotAType of ('constr, 'types) punsafe_judgment
  | BadAssumption of ('constr, 'types) punsafe_judgment
  | ReferenceVariables of Id.t * 'constr
  | ElimArity of pinductive * 'constr * ('constr, 'types) punsafe_judgment
      * (Sorts.family list * Sorts.family * Sorts.family * arity_error) option
  | CaseNotInductive of ('constr, 'types) punsafe_judgment
  | WrongCaseInfo of pinductive * case_info
  | NumberBranches of ('constr, 'types) punsafe_judgment * int
  | IllFormedBranch of 'constr * pconstructor * 'constr * 'constr
  | Generalization of (Name.t * 'types) * ('constr, 'types) punsafe_judgment
  | ActualType of ('constr, 'types) punsafe_judgment * 'types
  | IncorrectPrimitive of (CPrimitives.op_or_type,'types) punsafe_judgment * 'types
  | CantApplyBadType of
      (int * 'constr * 'constr) * ('constr, 'types) punsafe_judgment * ('constr, 'types) punsafe_judgment array
  | CantApplyNonFunctional of ('constr, 'types) punsafe_judgment * ('constr, 'types) punsafe_judgment array
  | IllFormedRecBody of 'constr pguard_error * Name.t Context.binder_annot array * int * env * ('constr, 'types) punsafe_judgment array
  | IllTypedRecBody of
      int * Name.t Context.binder_annot array * ('constr, 'types) punsafe_judgment array * 'types array
  | UnsatisfiedConstraints of Univ.Constraint.t
  | UndeclaredUniverse of Univ.Level.t
  | DisallowedSProp
  | BadRelevance

type type_error = (constr, types) ptype_error

<abbr class="mark-warning" title="Signature item `exception` not handled">exception TypeError of env * type_error</abbr>

(** The different kinds of errors that may result of a malformed inductive
    definition. *)
type inductive_error =
  | NonPos of env * constr * constr
  | NotEnoughArgs of env * constr * constr
  | NotConstructor of env * Id.t * constr * constr * int * int
  | NonPar of env * constr * int * constr * constr
  | SameNamesTypes of Id.t
  | SameNamesConstructors of Id.t
  | SameNamesOverlap of Id.t list
  | NotAnArity of env * constr
  | BadEntry
  | LargeNonPropInductiveNotInType
  | BadUnivs

<abbr class="mark-warning" title="Signature item `exception` not handled">exception InductiveError of inductive_error</abbr>

(** Raising functions *)

val error_unbound_rel : env -&gt; int -&gt; 'a

val error_unbound_var : env -&gt; variable -&gt; 'a

val error_not_type : env -&gt; unsafe_judgment -&gt; 'a

val error_assumption : env -&gt; unsafe_judgment -&gt; 'a

val error_reference_variables : env -&gt; Id.t -&gt; constr -&gt; 'a

val error_elim_arity :
  env -&gt; pinductive -&gt; constr -&gt; unsafe_judgment -&gt;
      (Sorts.family list * Sorts.family * Sorts.family * arity_error) option -&gt; 'a

val error_case_not_inductive : env -&gt; unsafe_judgment -&gt; 'a

val error_number_branches : env -&gt; unsafe_judgment -&gt; int -&gt; 'a

val error_ill_formed_branch : env -&gt; constr -&gt; pconstructor -&gt; constr -&gt; constr -&gt; 'a

val error_generalization : env -&gt; Name.t * types -&gt; unsafe_judgment -&gt; 'a

val error_actual_type : env -&gt; unsafe_judgment -&gt; types -&gt; 'a

val error_incorrect_primitive : env -&gt; (CPrimitives.op_or_type,types) punsafe_judgment -&gt; types -&gt; 'a

val error_cant_apply_not_functional :
  env -&gt; unsafe_judgment -&gt; unsafe_judgment array -&gt; 'a

val error_cant_apply_bad_type :
  env -&gt; int * constr * constr -&gt;
      unsafe_judgment -&gt; unsafe_judgment array -&gt; 'a

val error_ill_formed_rec_body :
  env -&gt; guard_error -&gt; Name.t Context.binder_annot array -&gt; int -&gt; env -&gt; unsafe_judgment array -&gt; 'a

val error_ill_typed_rec_body  :
  env -&gt; int -&gt; Name.t Context.binder_annot array -&gt; unsafe_judgment array -&gt; types array -&gt; 'a

val error_elim_explain : Sorts.family -&gt; Sorts.family -&gt; arity_error

val error_unsatisfied_constraints : env -&gt; Univ.Constraint.t -&gt; 'a

val error_undeclared_universe : env -&gt; Univ.Level.t -&gt; 'a

val error_disallowed_sprop : env -&gt; 'a

val error_bad_relevance : env -&gt; 'a

val map_pguard_error : ('c -&gt; 'd) -&gt; 'c pguard_error -&gt; 'd pguard_error
val map_ptype_error : ('c -&gt; 'd) -&gt; ('c, 'c) ptype_error -&gt; ('d, 'd) ptype_error
</pre>
  </div>
  <div class="col-md-6">
    <a href="#type_errors.mli"><code>Type_errors_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Inductive pguard_error (constr : Set) : Set :=
| NotEnoughAbstractionInFixBody : pguard_error constr
| RecursionNotOnInductiveType : constr -&gt; pguard_error constr
| RecursionOnIllegalTerm :
  Z -&gt; Environ.env * constr -&gt; list Z -&gt; list Z -&gt; pguard_error constr
| NotEnoughArgumentsForFixCall : Z -&gt; pguard_error constr
| CodomainNotInductiveType : constr -&gt; pguard_error constr
| NestedRecursiveOccurrences : pguard_error constr
| UnguardedRecursiveCall : constr -&gt; pguard_error constr
| RecCallInTypeOfAbstraction : constr -&gt; pguard_error constr
| RecCallInNonRecArgOfConstructor : constr -&gt; pguard_error constr
| RecCallInTypeOfDef : constr -&gt; pguard_error constr
| RecCallInCaseFun : constr -&gt; pguard_error constr
| RecCallInCaseArg : constr -&gt; pguard_error constr
| RecCallInCasePred : constr -&gt; pguard_error constr
| NotGuardedForm : constr -&gt; pguard_error constr
| ReturnPredicateNotCoInductive : constr -&gt; pguard_error constr
| FixpointOnIrrelevantInductive : pguard_error constr.

Arguments NotEnoughAbstractionInFixBody {_}.
Arguments RecursionNotOnInductiveType {_}.
Arguments RecursionOnIllegalTerm {_}.
Arguments NotEnoughArgumentsForFixCall {_}.
Arguments CodomainNotInductiveType {_}.
Arguments NestedRecursiveOccurrences {_}.
Arguments UnguardedRecursiveCall {_}.
Arguments RecCallInTypeOfAbstraction {_}.
Arguments RecCallInNonRecArgOfConstructor {_}.
Arguments RecCallInTypeOfDef {_}.
Arguments RecCallInCaseFun {_}.
Arguments RecCallInCaseArg {_}.
Arguments RecCallInCasePred {_}.
Arguments NotGuardedForm {_}.
Arguments ReturnPredicateNotCoInductive {_}.
Arguments FixpointOnIrrelevantInductive {_}.

Definition guard_error := pguard_error Constr.constr.

Inductive arity_error : Set :=
| NonInformativeToInformative : arity_error
| StrongEliminationOnNonSmallType : arity_error
| WrongArity : arity_error.

Inductive ptype_error (constr types : Set) : Set :=
| UnboundRel : Z -&gt; ptype_error constr types
| UnboundVar : Names.variable -&gt; ptype_error constr types
| NotAType : Environ.punsafe_judgment constr types -&gt; ptype_error constr types
| BadAssumption :
  Environ.punsafe_judgment constr types -&gt; ptype_error constr types
| ReferenceVariables : Names.Id.t -&gt; constr -&gt; ptype_error constr types
| ElimArity :
  Constr.pinductive -&gt; constr -&gt; Environ.punsafe_judgment constr types -&gt;
  option (list Sorts.family * Sorts.family * Sorts.family * arity_error) -&gt;
  ptype_error constr types
| CaseNotInductive :
  Environ.punsafe_judgment constr types -&gt; ptype_error constr types
| WrongCaseInfo :
  Constr.pinductive -&gt; Constr.case_info -&gt; ptype_error constr types
| NumberBranches :
  Environ.punsafe_judgment constr types -&gt; Z -&gt; ptype_error constr types
| IllFormedBranch :
  constr -&gt; Constr.pconstructor -&gt; constr -&gt; constr -&gt; ptype_error constr types
| Generalization :
  Names.Name.t * types -&gt; Environ.punsafe_judgment constr types -&gt;
  ptype_error constr types
| ActualType :
  Environ.punsafe_judgment constr types -&gt; types -&gt; ptype_error constr types
| IncorrectPrimitive :
  Environ.punsafe_judgment CPrimitives.op_or_type types -&gt; types -&gt;
  ptype_error constr types
| CantApplyBadType :
  Z * constr * constr -&gt; Environ.punsafe_judgment constr types -&gt;
  array (Environ.punsafe_judgment constr types) -&gt; ptype_error constr types
| CantApplyNonFunctional :
  Environ.punsafe_judgment constr types -&gt;
  array (Environ.punsafe_judgment constr types) -&gt; ptype_error constr types
| IllFormedRecBody :
  pguard_error constr -&gt; array (Context.binder_annot Names.Name.t) -&gt; Z -&gt;
  Environ.env -&gt; array (Environ.punsafe_judgment constr types) -&gt;
  ptype_error constr types
| IllTypedRecBody :
  Z -&gt; array (Context.binder_annot Names.Name.t) -&gt;
  array (Environ.punsafe_judgment constr types) -&gt; array types -&gt;
  ptype_error constr types
| UnsatisfiedConstraints : Univ.Constraint.t -&gt; ptype_error constr types
| UndeclaredUniverse : Univ.Level.t -&gt; ptype_error constr types
| DisallowedSProp : ptype_error constr types
| BadRelevance : ptype_error constr types.

Arguments UnboundRel {_ _}.
Arguments UnboundVar {_ _}.
Arguments NotAType {_ _}.
Arguments BadAssumption {_ _}.
Arguments ReferenceVariables {_ _}.
Arguments ElimArity {_ _}.
Arguments CaseNotInductive {_ _}.
Arguments WrongCaseInfo {_ _}.
Arguments NumberBranches {_ _}.
Arguments IllFormedBranch {_ _}.
Arguments Generalization {_ _}.
Arguments ActualType {_ _}.
Arguments IncorrectPrimitive {_ _}.
Arguments CantApplyBadType {_ _}.
Arguments CantApplyNonFunctional {_ _}.
Arguments IllFormedRecBody {_ _}.
Arguments IllTypedRecBody {_ _}.
Arguments UnsatisfiedConstraints {_ _}.
Arguments UndeclaredUniverse {_ _}.
Arguments DisallowedSProp {_ _}.
Arguments BadRelevance {_ _}.

Definition type_error := ptype_error Constr.constr Constr.types.

(* exception TypeError *)

Inductive inductive_error : Set :=
| NonPos : Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotEnoughArgs :
  Environ.env -&gt; Constr.constr -&gt; Constr.constr -&gt; inductive_error
| NotConstructor :
  Environ.env -&gt; Names.Id.t -&gt; Constr.constr -&gt; Constr.constr -&gt; Z -&gt; Z -&gt;
  inductive_error
| NonPar :
  Environ.env -&gt; Constr.constr -&gt; Z -&gt; Constr.constr -&gt; Constr.constr -&gt;
  inductive_error
| SameNamesTypes : Names.Id.t -&gt; inductive_error
| SameNamesConstructors : Names.Id.t -&gt; inductive_error
| SameNamesOverlap : list Names.Id.t -&gt; inductive_error
| NotAnArity : Environ.env -&gt; Constr.constr -&gt; inductive_error
| BadEntry : inductive_error
| LargeNonPropInductiveNotInType : inductive_error
| BadUnivs : inductive_error.

(* exception InductiveError *)

Parameter error_unbound_rel : forall {a : Set}, Environ.env -&gt; Z -&gt; a.

Parameter error_unbound_var : forall {a : Set},
  Environ.env -&gt; Names.variable -&gt; a.

Parameter error_not_type : forall {a : Set},
  Environ.env -&gt; Environ.unsafe_judgment -&gt; a.

Parameter error_assumption : forall {a : Set},
  Environ.env -&gt; Environ.unsafe_judgment -&gt; a.

Parameter error_reference_variables : forall {a : Set},
  Environ.env -&gt; Names.Id.t -&gt; Constr.constr -&gt; a.

Parameter error_elim_arity : forall {a : Set},
  Environ.env -&gt; Constr.pinductive -&gt; Constr.constr -&gt;
  Environ.unsafe_judgment -&gt;
  option (list Sorts.family * Sorts.family * Sorts.family * arity_error) -&gt; a.

Parameter error_case_not_inductive : forall {a : Set},
  Environ.env -&gt; Environ.unsafe_judgment -&gt; a.

Parameter error_number_branches : forall {a : Set},
  Environ.env -&gt; Environ.unsafe_judgment -&gt; Z -&gt; a.

Parameter error_ill_formed_branch : forall {a : Set},
  Environ.env -&gt; Constr.constr -&gt; Constr.pconstructor -&gt; Constr.constr -&gt;
  Constr.constr -&gt; a.

Parameter error_generalization : forall {a : Set},
  Environ.env -&gt; Names.Name.t * Constr.types -&gt; Environ.unsafe_judgment -&gt; a.

Parameter error_actual_type : forall {a : Set},
  Environ.env -&gt; Environ.unsafe_judgment -&gt; Constr.types -&gt; a.

Parameter error_incorrect_primitive : forall {a : Set},
  Environ.env -&gt; Environ.punsafe_judgment CPrimitives.op_or_type Constr.types -&gt;
  Constr.types -&gt; a.

Parameter error_cant_apply_not_functional : forall {a : Set},
  Environ.env -&gt; Environ.unsafe_judgment -&gt; array Environ.unsafe_judgment -&gt; a.

Parameter error_cant_apply_bad_type : forall {a : Set},
  Environ.env -&gt; Z * Constr.constr * Constr.constr -&gt; Environ.unsafe_judgment -&gt;
  array Environ.unsafe_judgment -&gt; a.

Parameter error_ill_formed_rec_body : forall {a : Set},
  Environ.env -&gt; guard_error -&gt; array (Context.binder_annot Names.Name.t) -&gt;
  Z -&gt; Environ.env -&gt; array Environ.unsafe_judgment -&gt; a.

Parameter error_ill_typed_rec_body : forall {a : Set},
  Environ.env -&gt; Z -&gt; array (Context.binder_annot Names.Name.t) -&gt;
  array Environ.unsafe_judgment -&gt; array Constr.types -&gt; a.

Parameter error_elim_explain : Sorts.family -&gt; Sorts.family -&gt; arity_error.

Parameter error_unsatisfied_constraints : forall {a : Set},
  Environ.env -&gt; Univ.Constraint.t -&gt; a.

Parameter error_undeclared_universe : forall {a : Set},
  Environ.env -&gt; Univ.Level.t -&gt; a.

Parameter error_disallowed_sprop : forall {a : Set}, Environ.env -&gt; a.

Parameter error_bad_relevance : forall {a : Set}, Environ.env -&gt; a.

Parameter map_pguard_error : forall {c d : Set},
  (c -&gt; d) -&gt; pguard_error c -&gt; pguard_error d.

Parameter map_ptype_error : forall {c d : Set},
  (c -&gt; d) -&gt; ptype_error c c -&gt; ptype_error d d.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="typeops.ml">
  <div style="margin: 20px;">
    <h3>Typeops</h3>
    <ul>
      <li>OCaml size: 715 lines</li>
      <li>Coq size: 895 lines (+25% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#typeops.ml"><code>typeops.ml</code></a>&nbsp;<span class="label label-warning">36 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open CErrors
open Util
open Names
open Univ
open Sorts
open Term
open Constr
open Context
open Vars
open Declarations
open Environ
open Reduction
open Inductive
open Type_errors

module RelDecl = Context.Rel.Declaration
module NamedDecl = Context.Named.Declaration

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception NotConvertibleVect of int</abbr>

let conv_leq l2r env x y = default_conv CUMUL ~l2r env x y

let conv_leq_vecti env v1 v2 =
  Array.fold_left2_i
    (fun i _ t1 t2 -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try conv_leq false env t1 t2
      with NotConvertible -&gt; raise (NotConvertibleVect i)</abbr>)
    ()
    v1
    v2

let check_constraints cst env =
  if Environ.check_constraints cst env then ()
  else error_unsatisfied_constraints env cst

(* This should be a type (a priori without intention to be an assumption) *)
let check_type env c t =
  match kind(whd_all env t) with
  | Sort s -&gt; s
  | _ -&gt; error_not_type env (make_judge c t)

(* This should be a type intended to be assumed. The error message is
   not as useful as for [type_judgment]. *)
let infer_assumption env t ty =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let s = check_type env t ty in
    (match s with Sorts.SProp -&gt; Irrelevant | _ -&gt; Relevant)
  with TypeError _ -&gt;
    error_assumption env (make_judge t ty)</abbr>

let warn_bad_relevance_name = &quot;bad-relevance&quot;
let warn_bad_relevance =
  CWarnings.create ~name:warn_bad_relevance_name ~category:&quot;debug&quot; ~default:CWarnings.Disabled
    Pp.(function
        | None -&gt;  str &quot;Bad relevance in case annotation.&quot;
        | Some x -&gt; str &quot;Bad relevance for binder &quot; ++ Name.print x.binder_name ++ str &quot;.&quot;)

let warn_bad_relevance_ci ?loc () = warn_bad_relevance ?loc None
let warn_bad_relevance ?loc x = warn_bad_relevance ?loc (Some x)

let check_assumption env x t ty =
  let r = x.binder_relevance in
  let r' = infer_assumption env t ty in
  let x = if Sorts.relevance_equal r r'
    then x
    else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(warn_bad_relevance x; {x with binder_relevance = r'})</abbr>
  in
  x

(************************************************)
(* Incremental typing rules: builds a typing judgment given the *)
(* judgments for the subterms. *)

(*s Type of sorts *)

(* Prop and Set *)

let type1 = mkSort Sorts.type1

(* Type of Type(i). *)

let type_of_type u =
  let uu = Universe.super u in
    mkType uu

let type_of_sort = function
  | SProp | Prop | Set -&gt; type1
  | Type u -&gt; type_of_type u

(*s Type of a de Bruijn index. *)

let type_of_relative env n =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    env |&gt; lookup_rel n |&gt; RelDecl.get_type |&gt; lift n
  with Not_found -&gt;
    error_unbound_rel env n</abbr>

(* Type of variables *)
let type_of_variable env id =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try named_type id env
  with Not_found -&gt;
    error_unbound_var env id</abbr>

(* Management of context of variables. *)

(* Checks if a context of variables can be instantiated by the
   variables of the current env.
   Order does not have to be checked assuming that all names are distinct *)
let check_hyps_inclusion env ?evars f c sign =
  let conv env a b = conv env ?evars a b in
  Context.Named.fold_outside
    (fun d1 () -&gt;
      let open Context.Named.Declaration in
      let id = NamedDecl.get_id d1 in
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
        let d2 = lookup_named id env in
        </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">conv env (get_type d2) (get_type d1);
        (match d2,d1 with
        | LocalAssum _, LocalAssum _ -&gt; ()
        | LocalAssum _, LocalDef _ -&gt;
            (* This is wrong, because we don't know if the body is
               needed or not for typechecking: *) ()
        | LocalDef _, LocalAssum _ -&gt; raise </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Values of extensible types are not handled">NotConvertible</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
        | LocalDef (_,b2,_), LocalDef (_,b1,_) -&gt; conv env b2 b1);</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
      with Not_found | NotConvertible | Option.Heterogeneous -&gt;
        error_reference_variables env id (f c)</abbr>)
    sign
    ~init:()

(* Instantiation of terms on real arguments. *)

(* Make a type polymorphic if an arity *)

(* Type of constants *)


let type_of_constant env (kn,_u as cst) =
  let cb = lookup_constant kn env in
  let () = check_hyps_inclusion env mkConstU cst cb.const_hyps in
  let ty, cu = constant_type env cst in
  let () = check_constraints cu env in
    ty

let type_of_constant_in env (kn,_u as cst) =
  let cb = lookup_constant kn env in
  let () = check_hyps_inclusion env mkConstU cst cb.const_hyps in
  constant_type_in env cst

(* Type of a lambda-abstraction. *)

(* [judge_of_abstraction env name var j] implements the rule

 env, name:typ |- j.uj_val:j.uj_type     env, |- (name:typ)j.uj_type : s
 -----------------------------------------------------------------------
          env |- [name:typ]j.uj_val : (name:typ)j.uj_type

  Since all products are defined in the Calculus of Inductive Constructions
  and no upper constraint exists on the sort $s$, we don't need to compute $s$
*)

let type_of_abstraction _env name var ty =
  mkProd (name, var, ty)

(* Type of an application. *)

let make_judgev c t =
  Array.map2 make_judge c t

let rec check_empty_stack = function
| [] -&gt; true
| CClosure.Zupdate _ :: s -&gt; check_empty_stack s
| _ -&gt; false

let type_of_apply env func funt argsv argstv =
  let open CClosure in
  let len = Array.length argsv in
  let infos = create_clos_infos all env in
  let tab = create_tab () in
  let rec apply_rec i typ =
    if Int.equal i len then term_of_fconstr typ
    else
      let typ, stk = whd_stack infos tab typ [] in
      (** The return stack is known to be empty *)
      let () = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (check_empty_stack stk)</abbr> in
      match fterm_of typ with
      | FProd (_, c1, c2, e) -&gt;
        let arg = argsv.(i) in
        let argt = argstv.(i) in
        let c1 = term_of_fconstr c1 in
        begin match conv_leq false env argt c1 with
        | () -&gt; apply_rec (i+1) (mk_clos (Esubst.subs_cons (<abbr class="mark-warning" title="Arrays not handled.">[| inject arg |]</abbr>, e)) c2)
        | exception <abbr class="mark-warning" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">NotConvertible</abbr> -&gt;
          error_cant_apply_bad_type env
            (i+1,c1,argt)
            (make_judge func funt)
            (make_judgev argsv argstv)
        end
      | _ -&gt;
        error_cant_apply_not_functional env
          (make_judge func funt)
          (make_judgev argsv argstv)
  in
  apply_rec 0 (inject funt)

(* Type of primitive constructs *)
let type_of_prim_type _env = function
  | CPrimitives.PT_int63 -&gt; Constr.mkSet

let type_of_int env =
  match env.retroknowledge.Retroknowledge.retro_int63 with
  | Some c -&gt; mkConst c
  | None -&gt; CErrors.user_err Pp.(str&quot;The type int must be registered before this construction can be typechecked.&quot;)

let type_of_prim env t =
  let int_ty = type_of_int env in
  let bool_ty () =
    match env.retroknowledge.Retroknowledge.retro_bool with
    | Some ((ind,_),_) -&gt; Constr.mkInd ind
    | None -&gt; CErrors.user_err Pp.(str&quot;The type bool must be registered before this primitive.&quot;)
  in
  let compare_ty () =
    match env.retroknowledge.Retroknowledge.retro_cmp with
    | Some ((ind,_),_,_) -&gt; Constr.mkInd ind
    | None -&gt; CErrors.user_err Pp.(str&quot;The type compare must be registered before this primitive.&quot;)
  in
  let pair_ty fst_ty snd_ty =
    match env.retroknowledge.Retroknowledge.retro_pair with
    | Some (ind,_) -&gt; Constr.mkApp(Constr.mkInd ind, <abbr class="mark-warning" title="Arrays not handled.">[|fst_ty;snd_ty|]</abbr>)
    | None -&gt; CErrors.user_err Pp.(str&quot;The type pair must be registered before this primitive.&quot;)
  in
  let carry_ty int_ty =
    match env.retroknowledge.Retroknowledge.retro_carry with
    | Some ((ind,_),_) -&gt; Constr.mkApp(Constr.mkInd ind, <abbr class="mark-warning" title="Arrays not handled.">[|int_ty|]</abbr>)
    | None -&gt; CErrors.user_err Pp.(str&quot;The type carry must be registered before this primitive.&quot;)
  in
  let rec nary_int63_op arity ty =
    if Int.equal arity 0 then ty
      else Constr.mkProd(Context.nameR (Id.of_string &quot;x&quot;), int_ty, nary_int63_op (arity-1) ty)
  in
  let return_ty =
    let open CPrimitives in
    match t with
    | Int63head0
    | Int63tail0
    | Int63add
    | Int63sub
    | Int63mul
    | Int63div
    | Int63mod
    | Int63lsr
    | Int63lsl
    | Int63land
    | Int63lor
    | Int63lxor
    | Int63addMulDiv -&gt; int_ty
    | Int63eq
    | Int63lt
    | Int63le -&gt; bool_ty ()
    | Int63mulc
    | Int63div21
    | Int63diveucl -&gt; pair_ty int_ty int_ty
    | Int63addc
    | Int63subc
    | Int63addCarryC
    | Int63subCarryC -&gt; carry_ty int_ty
    | Int63compare -&gt; compare_ty ()
  in
  nary_int63_op (CPrimitives.arity t) return_ty

let type_of_prim_or_type env = let open CPrimitives in
  function
  | OT_type t -&gt; type_of_prim_type env t
  | OT_op op -&gt; type_of_prim env op

let judge_of_int env i =
  make_judge (Constr.mkInt i) (type_of_int env)

(* Type of product *)

let sort_of_product env domsort rangsort =
  match (domsort, rangsort) with
    | (_, SProp) | (SProp, _) -&gt; rangsort
    (* Product rule (s,Prop,Prop) *)
    | (_,       Prop)  -&gt; rangsort
    (* Product rule (Prop/Set,Set,Set) *)
    | ((Prop | Set),  Set) -&gt; rangsort
    (* Product rule (Type,Set,?) *)
    | (Type u1, Set) -&gt;
        if is_impredicative_set env then
          (* Rule is (Type,Set,Set) in the Set-impredicative calculus *)
          rangsort
        else
          (* Rule is (Type_i,Set,Type_i) in the Set-predicative calculus *)
          Sorts.sort_of_univ (Universe.sup Universe.type0 u1)
    (* Product rule (Prop,Type_i,Type_i) *)
    | (Set,  Type u2)  -&gt; Sorts.sort_of_univ (Universe.sup Universe.type0 u2)
    (* Product rule (Prop,Type_i,Type_i) *)
    | (Prop, Type _)  -&gt; rangsort
    (* Product rule (Type_i,Type_i,Type_i) *)
    | (Type u1, Type u2) -&gt; Sorts.sort_of_univ (Universe.sup u1 u2)

(* [judge_of_product env name (typ1,s1) (typ2,s2)] implements the rule

    env |- typ1:s1       env, name:typ1 |- typ2 : s2
    -------------------------------------------------------------------------
         s' &gt;= (s1,s2), env |- (name:typ)j.uj_val : s'

  where j.uj_type is convertible to a sort s2
*)
let type_of_product env _name s1 s2 =
  let s = sort_of_product env s1 s2 in
    mkSort s

(* Type of a type cast *)

(* [judge_of_cast env (c,typ1) (typ2,s)] implements the rule

    env |- c:typ1    env |- typ2:s    env |- typ1 &lt;= typ2
    ---------------------------------------------------------------------
         env |- c:typ2
*)

let check_cast env c ct k expected_type =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    match k with
    | VMcast -&gt;
      Vconv.vm_conv CUMUL env ct expected_type
    | DEFAULTcast -&gt;
      default_conv ~l2r:false CUMUL env ct expected_type
    | REVERTcast -&gt;
      default_conv ~l2r:true CUMUL env ct expected_type
    | NATIVEcast -&gt;
      let sigma = Nativelambda.empty_evars in
      Nativeconv.native_conv CUMUL sigma env ct expected_type
  with NotConvertible -&gt;
    error_actual_type env (make_judge c ct) expected_type</abbr>

(* Inductive types. *)

(* The type is parametric over the uniform parameters whose conclusion
   is in Type; to enforce the internal constraints between the
   parameters and the instances of Type occurring in the type of the
   constructors, we use the level variables _statically_ assigned to
   the conclusions of the parameters as mediators: e.g. if a parameter
   has conclusion Type(alpha), static constraints of the form alpha&lt;=v
   exist between alpha and the Type's occurring in the constructor
   types; when the parameters is finally instantiated by a term of
   conclusion Type(u), then the constraints u&lt;=alpha is computed in
   the App case of execute; from this constraints, the expected
   dynamic constraints of the form u&lt;=v are enforced *)

let type_of_inductive_knowing_parameters env (ind,u as indu) args =
  let (mib,_mip) as spec = lookup_mind_specif env ind in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_hyps_inclusion env mkIndU indu mib.mind_hyps;
  let t,cst = Inductive.constrained_type_of_inductive_knowing_parameters
    env (spec,u) args
  in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_constraints cst env;
  t</abbr>

let type_of_inductive env (ind,u as indu) =
  let (mib,mip) = lookup_mind_specif env ind in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_hyps_inclusion env mkIndU indu mib.mind_hyps;
  let t,cst = Inductive.constrained_type_of_inductive env ((mib,mip),u) in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_constraints cst env;
  t</abbr>

(* Constructors. *)

let type_of_constructor env (c,_u as cu) =
  let () =
    let ((kn,_),_) = c in
    let mib = lookup_mind kn env in
    check_hyps_inclusion env mkConstructU cu mib.mind_hyps
  in
  let specif = lookup_mind_specif env (inductive_of_constructor c) in
  let t,cst = constrained_type_of_constructor cu specif in
  let () = check_constraints cst env in
  t

(* Case. *)

let check_branch_types env (ind,u) c ct lft explft =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try conv_leq_vecti env lft explft
  with
      NotConvertibleVect i -&gt;
        error_ill_formed_branch env c ((ind,i+1),u) lft.(i) explft.(i)
    | Invalid_argument _ -&gt;
        error_number_branches env (make_judge c ct) (Array.length explft)</abbr>

let type_of_case env ci p pt c ct _lf lft =
  let (pind, _ as indspec) =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try find_rectype env ct
    with Not_found -&gt; error_case_not_inductive env (make_judge c ct)</abbr> in
  let _, sp = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try dest_arity env pt
    with NotArity -&gt; error_elim_arity env pind c (make_judge p pt) None</abbr> in
  let rp = Sorts.relevance_of_sort sp in
  let ci = if ci.ci_relevance == rp then ci
    else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(warn_bad_relevance_ci (); {ci with ci_relevance=rp})</abbr>
  in
  let () = check_case_info env pind rp ci in
  let (bty,rslty) =
    type_case_branches env indspec (make_judge p pt) c in
  let () = check_branch_types env pind c ct lft bty in
  ci, rslty

let type_of_projection env p c ct =
  let pty = lookup_projection p env in
  let (ind,u), args =
    <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try find_rectype env ct
    with Not_found -&gt; error_case_not_inductive env (make_judge c ct)</abbr>
  in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert(eq_ind (Projection.inductive p) ind);
  let ty = Vars.subst_instance_constr u pty in
  substl (c :: CList.rev args) ty</abbr>


(* Fixpoints. *)

(* Checks the type of a general (co)fixpoint, i.e. without checking *)
(* the specific guard condition. *)

let check_fixpoint env lna lar vdef vdeft =
  let lt = Array.length vdeft in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Int.equal (Array.length lar) lt);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    conv_leq_vecti env vdeft (Array.map (fun ty -&gt; lift lt ty) lar)
  with NotConvertibleVect i -&gt;
    error_ill_typed_rec_body env i lna (make_judgev vdef vdeft) lar</abbr>

(* Global references *)

let type_of_global_in_context env r =
  let open Names.GlobRef in
  match r with
  | VarRef id -&gt; Environ.named_type id env, Univ.AUContext.empty
  | ConstRef c -&gt;
    let cb = Environ.lookup_constant c env in
    let univs = Declareops.constant_polymorphic_context cb in
    cb.Declarations.const_type, univs
  | IndRef ind -&gt;
    let (mib,_ as specif) = Inductive.lookup_mind_specif env ind in
    let univs = Declareops.inductive_polymorphic_context mib in
    let inst = Univ.make_abstract_instance univs in
    let env = Environ.push_context ~strict:false (Univ.AUContext.repr univs) env in
    Inductive.type_of_inductive env (specif, inst), univs
  | ConstructRef cstr -&gt;
    let (mib,_ as specif) =
      Inductive.lookup_mind_specif env (inductive_of_constructor cstr)
    in
    let univs = Declareops.inductive_polymorphic_context mib in
    let inst = Univ.make_abstract_instance univs in
    Inductive.type_of_constructor (cstr,inst) specif, univs

(************************************************************************)
(************************************************************************)

let check_binder_annot s x =
  let r = x.binder_relevance in
  let r' = Sorts.relevance_of_sort s in
  if r' == r
  then x
  else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(warn_bad_relevance x; {x with binder_relevance = r'})</abbr>

(* The typing machine. *)
    (* ATTENTION : faudra faire le typage du contexte des Const,
    Ind et Constructsi un jour cela devient des constructions
    arbitraires et non plus des variables *)
let rec execute env cstr =
  let open Context.Rel.Declaration in
  match kind cstr with
    (* Atomic terms *)
    | Sort s -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(match s with
       | SProp -&gt; if not (Environ.sprop_allowed env) then error_disallowed_sprop env
       | _ -&gt; ());
      cstr, type_of_sort s</abbr>

    | Rel n -&gt;
      cstr, type_of_relative env n

    | Var id -&gt;
      cstr, type_of_variable env id

    | Const c -&gt;
      cstr, type_of_constant env c

    | Proj (p, c) -&gt;
      let c', ct = execute env c in
      let cstr = if c == c' then cstr else mkProj (p,c') in
      cstr, type_of_projection env p c' ct

    (* Lambda calculus operators *)
    | App (f,args) -&gt;
      let args', argst = execute_array env args in
        let f', ft =
          match kind f with
          | Ind ind when Environ.template_polymorphic_pind ind env -&gt;
            let args = Array.map (fun t -&gt; <abbr class="mark-warning" title="Lazy expressions are not handled">lazy t</abbr>) argst in
              f, type_of_inductive_knowing_parameters env ind args
          | _ -&gt;
            (* No template polymorphism *)
            execute env f
        in
        let cstr = if f == f' &amp;&amp; args == args' then cstr else mkApp (f',args') in
        cstr, type_of_apply env f' ft args' argst

    | Lambda (name,c1,c2) -&gt;
      let c1', s = execute_is_type env c1 in
      let name' = check_binder_annot s name in
      let env1 = push_rel (LocalAssum (name',c1')) env in
      let c2', c2t = execute env1 c2 in
      let cstr = if name == name' &amp;&amp; c1 == c1' &amp;&amp; c2 == c2' then cstr else mkLambda(name',c1',c2') in
      cstr, type_of_abstraction env name' c1 c2t

    | Prod (name,c1,c2) -&gt;
      let c1', vars = execute_is_type env c1 in
      let name' = check_binder_annot vars name in
      let env1 = push_rel (LocalAssum (name',c1')) env in
      let c2', vars' = execute_is_type env1 c2 in
      let cstr = if name == name' &amp;&amp; c1 == c1' &amp;&amp; c2 == c2' then cstr else mkProd(name',c1',c2') in
      cstr, type_of_product env name' vars vars'

    | LetIn (name,c1,c2,c3) -&gt;
      let c1', c1t = execute env c1 in
      let c2', c2s = execute_is_type env c2 in
      let name' = check_binder_annot c2s name in
      let () = check_cast env c1' c1t DEFAULTcast c2' in
      let env1 = push_rel (LocalDef (name',c1',c2')) env in
      let c3', c3t = execute env1 c3 in
      let cstr = if name == name' &amp;&amp; c1 == c1' &amp;&amp; c2 == c2' &amp;&amp; c3 == c3' then cstr
        else mkLetIn(name',c1',c2',c3')
      in
      cstr, subst1 c1 c3t

    | Cast (c,k,t) -&gt;
      let c', ct = execute env c in
      let t', _ts = execute_is_type env t in
      let () = check_cast env c' ct k t' in
      let cstr = if c == c' &amp;&amp; t == t' then cstr else mkCast(c',k,t') in
      cstr, t'

    (* Inductive types *)
    | Ind ind -&gt;
      cstr, type_of_inductive env ind

    | Construct c -&gt;
      cstr, type_of_constructor env c

    | Case (ci,p,c,lf) -&gt;
        let c', ct = execute env c in
        let p', pt = execute env p in
        let lf', lft = execute_array env lf in
        let ci', t = type_of_case env ci p' pt c' ct lf' lft in
        let cstr = if ci == ci' &amp;&amp; c == c' &amp;&amp; p == p' &amp;&amp; lf == lf' then cstr
          else mkCase(ci',p',c',lf')
        in
        cstr, t

    | Fix ((_vn,i as vni),recdef as fix) -&gt;
      let (fix_ty,recdef') = execute_recdef env recdef i in
      let cstr, fix = if recdef == recdef' then cstr, fix else
          let fix = (vni,recdef') in mkFix fix, fix
      in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_fix env fix; cstr, fix_ty</abbr>

    | CoFix (i,recdef as cofix) -&gt;
      let (fix_ty,recdef') = execute_recdef env recdef i in
      let cstr, cofix = if recdef == recdef' then cstr, cofix else
          let cofix = (i,recdef') in mkCoFix cofix, cofix
      in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">check_cofix env cofix; cstr, fix_ty</abbr>

    (* Primitive types *)
    | Int _ -&gt; cstr, type_of_int env

    (* Partial proofs: unsupported by the kernel *)
    | Meta _ -&gt;
        anomaly (Pp.str &quot;the kernel does not support metavariables.&quot;)

    | Evar _ -&gt;
        anomaly (Pp.str &quot;the kernel does not support existential variables.&quot;)

and execute_is_type env constr =
  let c, t = execute env constr in
    c, check_type env constr t

and execute_recdef env (names,lar,vdef as recdef) i =
  let lar', lart = execute_array env lar in
  let names' = Array.Smart.map_i (fun i na -&gt; check_assumption env na lar'.(i) lart.(i)) names in
  let env1 = push_rec_types (names',lar',vdef) env in (* vdef is ignored *)
  let vdef', vdeft = execute_array env1 vdef in
  let () = check_fixpoint env1 names' lar' vdef' vdeft in
  let recdef = if names == names' &amp;&amp; lar == lar' &amp;&amp; vdef == vdef' then recdef else (names',lar',vdef') in
    (lar'.(i),recdef)

and execute_array env cs =
  let tys = Array.make (Array.length cs) mkProp in
  let cs = Array.Smart.map_i (fun i c -&gt; let c, ty = execute env c in <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">tys.(i) &lt;- ty; c</abbr>) cs in
  cs, tys

(* Derived functions *)

let check_wellformed_universes env c =
  let univs = universes_of_constr c in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try UGraph.check_declared_universes (universes env) univs
  with UGraph.UndeclaredLevel u -&gt;
    error_undeclared_universe env u</abbr>

let infer env constr =
  let () = check_wellformed_universes env constr in
  let constr, t = execute env constr in
  make_judge constr t

let infer =
  if Flags.profile then
    let infer_key = CProfile.declare_profile &quot;Fast_infer&quot; in
      CProfile.profile2 infer_key (fun b c -&gt; infer b c)
  else (fun b c -&gt; infer b c)

let assumption_of_judgment env {uj_val=c; uj_type=t} =
  infer_assumption env c t

let type_judgment env {uj_val=c; uj_type=t} =
  let s = check_type env c t in
  {utj_val = c; utj_type = s }

let infer_type env constr =
  let () = check_wellformed_universes env constr in
  let constr, t = execute env constr in
  let s = check_type env constr t in
  {utj_val = constr; utj_type = s}

(* Typing of several terms. *)

let check_context env rels =
  let open Context.Rel.Declaration in
  Context.Rel.fold_outside (fun d (env,rels) -&gt;
    match d with
      | LocalAssum (x,ty) -&gt;
        let jty = infer_type env ty in
        let x = check_binder_annot jty.utj_type x in
        push_rel d env, LocalAssum (x,jty.utj_val) :: rels
      | LocalDef (x,bd,ty) -&gt;
        let j1 = infer env bd in
        let jty = infer_type env ty in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">conv_leq false env j1.uj_type ty;
        let x = check_binder_annot jty.utj_type x in
        push_rel d env, LocalDef (x,j1.uj_val,jty.utj_val) :: rels</abbr>)
    rels ~init:(env,[])

let judge_of_prop = make_judge mkProp type1
let judge_of_set = make_judge mkSet type1
let judge_of_type u = make_judge (mkType u) (type_of_type u)

let judge_of_relative env k = make_judge (mkRel k) (type_of_relative env k)

let judge_of_variable env x = make_judge (mkVar x) (type_of_variable env x)

let judge_of_constant env cst = make_judge (mkConstU cst) (type_of_constant env cst)

let judge_of_projection env p cj =
  make_judge (mkProj (p,cj.uj_val)) (type_of_projection env p cj.uj_val cj.uj_type)

let dest_judgev v =
  Array.map j_val v, Array.map j_type v

let judge_of_apply env funj argjv =
  let args, argtys = dest_judgev argjv in
  make_judge (mkApp (funj.uj_val, args)) (type_of_apply env funj.uj_val funj.uj_type args argtys)

(* let judge_of_abstraction env x varj bodyj = *)
(*   make_judge (mkLambda (x, varj.utj_val, bodyj.uj_val)) *)
(*              (type_of_abstraction env x varj.utj_val bodyj.uj_type) *)

(* let judge_of_product env x varj outj = *)
(*   make_judge (mkProd (x, varj.utj_val, outj.utj_val)) *)
(*              (mkSort (sort_of_product env varj.utj_type outj.utj_type)) *)

(* let judge_of_letin env name defj typj j = *)
(*   make_judge (mkLetIn (name, defj.uj_val, typj.utj_val, j.uj_val)) *)
(*              (subst1 defj.uj_val j.uj_type) *)

let judge_of_cast env cj k tj =
  let () = check_cast env cj.uj_val cj.uj_type k tj.utj_val in
  let c = match k with | REVERTcast -&gt; cj.uj_val | _ -&gt; mkCast (cj.uj_val, k, tj.utj_val) in
  make_judge c tj.utj_val

let judge_of_inductive env indu =
  make_judge (mkIndU indu) (type_of_inductive env indu)

let judge_of_constructor env cu =
  make_judge (mkConstructU cu) (type_of_constructor env cu)

let judge_of_case env ci pj cj lfj =
  let lf, lft = dest_judgev lfj in
  let ci, t = type_of_case env ci pj.uj_val pj.uj_type cj.uj_val cj.uj_type lf lft in
  make_judge (mkCase (ci, (*nf_betaiota*) pj.uj_val, cj.uj_val, lft)) t

(* Building type of primitive operators and type *)

let check_primitive_type env op_t t =
  let inft = type_of_prim_or_type env op_t in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try default_conv ~l2r:false CUMUL env inft t
  with NotConvertible -&gt; error_incorrect_primitive env (make_judge op_t inft) t</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#typeops.ml"><code>Typeops.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import CErrors.

Import Util.

Import Names.

Import Univ.

Import Sorts.

Import Term.

Import Constr.

Import Context.

Import Vars.

Import Declarations.

Import Environ.

Import Reduction.

Import Inductive.

Import Type_errors.

Module RelDecl := Context.Rel.Declaration.

Module NamedDecl := Context.Named.Declaration.

(* ❌ The definition of exceptions is not handled. *)
(* exception NotConvertibleVect *)

Definition conv_leq
  (l2r : bool) (env : Environ.env) (x : Constr.types) (y : Constr.types)
  : unit := default_conv Reduction.CUMUL (Some l2r) env x y.

Definition conv_leq_vecti
  (env : Environ.env) (v1 : array Constr.types) (v2 : array Constr.types)
  : unit :=
  (|Util.Array|).(CArray.ExtS.fold_left2_i)
    (fun i =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        fun t1 =&gt;
          fun t2 =&gt;
            (* ❌ Try-with are not handled *)
            try (conv_leq false env t1 t2)) tt v1 v2.

Definition check_constraints (cst : Univ.Constraint.t) (env : Environ.env)
  : unit :=
  if Environ.check_constraints cst env then
    tt
  else
    error_unsatisfied_constraints env cst.

Definition check_type
  (env : Environ.env) (c : Constr.constr) (t : Constr.constr) : Sorts.t :=
  match kind (whd_all env t) with
  | Constr.Sort s =&gt; s
  | _ =&gt; error_not_type env (make_judge c t)
  end.

Definition infer_assumption
  (env : Environ.env) (t : Constr.constr) (ty : Constr.constr)
  : Sorts.relevance :=
  (* ❌ Try-with are not handled *)
  try
    (let s := check_type env t ty in
    match s with
    | Sorts.SProp =&gt; Sorts.Irrelevant
    | _ =&gt; Sorts.Relevant
    end).

Definition warn_bad_relevance_name : string := &quot;bad-relevance&quot;.

Definition warn_bad_relevance
  : option Loc.t -&gt; option (Context.binder_annot Names.Name.t) -&gt; unit :=
  CWarnings.create warn_bad_relevance_name &quot;debug&quot; (Some CWarnings.Disabled)
    (fun function_parameter =&gt;
      match function_parameter with
      | None =&gt; str &quot;Bad relevance in case annotation.&quot;
      | Some x =&gt;
        op_plusplus
          (op_plusplus (str &quot;Bad relevance for binder &quot;)
            (Name.print (Context.binder_annot.binder_name x))) (str &quot;.&quot;)
      end).

Definition warn_bad_relevance_ci
  (loc : option Loc.t) (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  warn_bad_relevance loc None.

Definition warn_bad_relevance
  (loc : option Loc.t) (x : Context.binder_annot Names.Name.t) : unit :=
  warn_bad_relevance loc (Some x).

Definition check_assumption
  (env : Environ.env) (x : Context.binder_annot Names.Name.t)
  (t : Constr.constr) (ty : Constr.constr)
  : Context.binder_annot Names.Name.t :=
  let r := Context.binder_annot.binder_relevance x in
  let r' := infer_assumption env t ty in
  let x :=
    if Sorts.relevance_equal r r' then
      x
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Context.binder_annot.with_binder_relevance x r' in
  x.

Definition type1 : Constr.types := mkSort Sorts.type1.

Definition type_of_type (u : Univ.Universe.t) : Constr.types :=
  let uu := Universe.super u in
  mkType uu.

Definition type_of_sort (function_parameter : Term.sorts) : Constr.types :=
  match function_parameter with
  | Term.SProp | Term.Prop | Term.__Set =&gt; type1
  | Term.Type u =&gt; type_of_type u
  end.

Definition type_of_relative (env : Environ.env) (n : Z) : Constr.constr :=
  (* ❌ Try-with are not handled *)
  try
    (OCaml.Stdlib.reverse_apply
      (OCaml.Stdlib.reverse_apply
        (OCaml.Stdlib.reverse_apply env (lookup_rel n)) RelDecl.get_type)
      (lift n)).

Definition type_of_variable (env : Environ.env) (id : Names.variable)
  : Constr.types :=
  (* ❌ Try-with are not handled *)
  try (named_type id env).

Definition check_hyps_inclusion {A : Set}
  (env : Environ.env)
  (evars : option ((Constr.existential -&gt; option Constr.constr) * UGraph.t))
  (f : A -&gt; Constr.constr) (c : A)
  (sign : Context.Named.pt Constr.constr Constr.constr) : unit :=
  let conv (env : Environ.env) (a : Constr.constr) (b : Constr.constr) : unit :=
    conv None None env evars a b in
  Context.Named.fold_outside
    (fun d1 =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        let id := NamedDecl.get_id d1 in
        (* ❌ Try-with are not handled *)
        try
          (let d2 := lookup_named id env in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          match (d2, d1) with
          |
            (Context.Named.Declaration.LocalAssum _ _,
              Context.Named.Declaration.LocalAssum _ _) =&gt; tt
          |
            (Context.Named.Declaration.LocalAssum _ _,
              Context.Named.Declaration.LocalDef _ _ _) =&gt; tt
          |
            (Context.Named.Declaration.LocalDef _ _ _,
              Context.Named.Declaration.LocalAssum _ _) =&gt;
            Stdlib.raise extensible_type_value
          |
            (Context.Named.Declaration.LocalDef _ b2 _,
              Context.Named.Declaration.LocalDef _ b1 _) =&gt; conv env b2 b1
          end)) sign tt.

Definition type_of_constant
  (env : Environ.env) (function_parameter : Names.Constant.t * Univ.Instance.t)
  : Constr.types :=
  let '(kn, _u) as cst := function_parameter in
  let cb := lookup_constant kn env in
  let '_ :=
    check_hyps_inclusion env None mkConstU cst
      (Declarations.constant_body.const_hyps cb) in
  let '(ty, cu) := constant_type env cst in
  let '_ := check_constraints cu env in
  ty.

Definition type_of_constant_in
  (env : Environ.env) (function_parameter : Names.Constant.t * Univ.Instance.t)
  : Constr.types :=
  let '(kn, _u) as cst := function_parameter in
  let cb := lookup_constant kn env in
  let '_ :=
    check_hyps_inclusion env None mkConstU cst
      (Declarations.constant_body.const_hyps cb) in
  constant_type_in env cst.

Definition type_of_abstraction {A : Set}
  (_env : A) (name : Context.binder_annot Names.Name.t) (var : Constr.types)
  (ty : Constr.types) : Constr.types := mkProd (name, var, ty).

Definition make_judgev {A B : Set} (c : array A) (t : array B)
  : array (Environ.punsafe_judgment A B) :=
  (|Util.Array|).(CArray.ExtS.map2) make_judge c t.

Fixpoint check_empty_stack (function_parameter : list CClosure.stack_member)
  {struct function_parameter} : bool :=
  match function_parameter with
  | [] =&gt; true
  | cons (CClosure.Zupdate _) s =&gt; check_empty_stack s
  | _ =&gt; false
  end.

Definition type_of_apply
  (env : Environ.env) (func : Constr.constr) (funt : Constr.types)
  (argsv : array Constr.constr) (argstv : array Constr.types) : Constr.constr :=
  let len := (|Util.Array|).(CArray.ExtS.length) argsv in
  let infos := create_clos_infos None all env in
  let tab := create_tab tt in
  let fix apply_rec (i : Int.t) (typ : CClosure.fconstr) {struct i}
    : Constr.constr :=
    if Int.equal i len then
      term_of_fconstr typ
    else
      let '(typ, stk) := whd_stack infos tab typ [] in
      let '_ :=
        (* ❌ Assert instruction is not handled. *)
        assert (check_empty_stack stk) in
      match fterm_of typ with
      | CClosure.FProd _ c1 c2 e =&gt;
        let arg := (|Util.Array|).(CArray.ExtS.get) argsv i in
        let argt := (|Util.Array|).(CArray.ExtS.get) argstv i in
        let c1 := term_of_fconstr c1 in
        let '_ := conv_leq false env argt c1 in
        apply_rec (Z.add i 1)
          (mk_clos
            (Esubst.subs_cons
              ((* ❌ Arrays not handled. *)
              [ inject arg ], e)) c2)
      | _ =&gt;
        error_cant_apply_not_functional env (make_judge func funt)
          (make_judgev argsv argstv)
      end in
  apply_rec 0 (inject funt).

Definition type_of_prim_type {A : Set}
  (_env : A) (function_parameter : CPrimitives.prim_type) : Constr.types :=
  let 'CPrimitives.PT_int63 := function_parameter in
  Constr.mkSet.

Definition type_of_int (env : Environ.env) : Constr.constr :=
  match
    Retroknowledge.retroknowledge.retro_int63 (Environ.env.retroknowledge env)
    with
  | Some c =&gt; mkConst c
  | None =&gt;
    CErrors.user_err None None
      (str
        &quot;The type int must be registered before this construction can be typechecked.&quot;)
  end.

Definition type_of_prim (env : Environ.env) (t : CPrimitives.t)
  : Constr.types :=
  let int_ty := type_of_int env in
  let bool_ty (function_parameter : unit) : Constr.constr :=
    let '_ := function_parameter in
    match
      Retroknowledge.retroknowledge.retro_bool (Environ.env.retroknowledge env)
      with
    | Some ((ind, _), _) =&gt; Constr.mkInd ind
    | None =&gt;
      CErrors.user_err None None
        (str &quot;The type bool must be registered before this primitive.&quot;)
    end in
  let compare_ty (function_parameter : unit) : Constr.constr :=
    let '_ := function_parameter in
    match
      Retroknowledge.retroknowledge.retro_cmp (Environ.env.retroknowledge env)
      with
    | Some ((ind, _), _, _) =&gt; Constr.mkInd ind
    | None =&gt;
      CErrors.user_err None None
        (str &quot;The type compare must be registered before this primitive.&quot;)
    end in
  let pair_ty (fst_ty : Constr.constr) (snd_ty : Constr.constr)
    : Constr.constr :=
    match
      Retroknowledge.retroknowledge.retro_pair (Environ.env.retroknowledge env)
      with
    | Some (ind, _) =&gt;
      Constr.mkApp
        ((Constr.mkInd ind),
          (* ❌ Arrays not handled. *)
          [ fst_ty; snd_ty ])
    | None =&gt;
      CErrors.user_err None None
        (str &quot;The type pair must be registered before this primitive.&quot;)
    end in
  let carry_ty (int_ty : Constr.constr) : Constr.constr :=
    match
      Retroknowledge.retroknowledge.retro_carry (Environ.env.retroknowledge env)
      with
    | Some ((ind, _), _) =&gt;
      Constr.mkApp
        ((Constr.mkInd ind),
          (* ❌ Arrays not handled. *)
          [ int_ty ])
    | None =&gt;
      CErrors.user_err None None
        (str &quot;The type carry must be registered before this primitive.&quot;)
    end in
  let fix nary_int63_op (arity : Int.t) (ty : Constr.types) {struct arity}
    : Constr.types :=
    if Int.equal arity 0 then
      ty
    else
      Constr.mkProd
        ((Context.nameR (Id.of_string &quot;x&quot;)), int_ty,
          (nary_int63_op (Z.sub arity 1) ty)) in
  let return_ty :=
    match t with
    |
      CPrimitives.Int63head0 | CPrimitives.Int63tail0 | CPrimitives.Int63add |
      CPrimitives.Int63sub | CPrimitives.Int63mul | CPrimitives.Int63div |
      CPrimitives.Int63mod | CPrimitives.Int63lsr | CPrimitives.Int63lsl |
      CPrimitives.Int63land | CPrimitives.Int63lor | CPrimitives.Int63lxor |
      CPrimitives.Int63addMulDiv =&gt; int_ty
    | CPrimitives.Int63eq | CPrimitives.Int63lt | CPrimitives.Int63le =&gt;
      bool_ty tt
    | CPrimitives.Int63mulc | CPrimitives.Int63div21 | CPrimitives.Int63diveucl
      =&gt; pair_ty int_ty int_ty
    |
      CPrimitives.Int63addc | CPrimitives.Int63subc | CPrimitives.Int63addCarryC
      | CPrimitives.Int63subCarryC =&gt; carry_ty int_ty
    | CPrimitives.Int63compare =&gt; compare_ty tt
    end in
  nary_int63_op (CPrimitives.arity t) return_ty.

Definition type_of_prim_or_type
  (env : Environ.env) (function_parameter : CPrimitives.op_or_type)
  : Constr.types :=
  match function_parameter with
  | CPrimitives.OT_type t =&gt; type_of_prim_type env t
  | CPrimitives.OT_op op =&gt; type_of_prim env op
  end.

Definition judge_of_int (env : Environ.env) (i : Uint63.t)
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  make_judge (Constr.mkInt i) (type_of_int env).

Definition sort_of_product
  (env : Environ.env) (domsort : Term.sorts) (rangsort : Term.sorts)
  : Term.sorts :=
  match (domsort, rangsort) with
  | (_, Term.SProp) | (Term.SProp, _) =&gt; rangsort
  | (_, Term.Prop) =&gt; rangsort
  | (Term.Prop | Term.__Set, Term.__Set) =&gt; rangsort
  | (Term.Type u1, Term.__Set) =&gt;
    if is_impredicative_set env then
      rangsort
    else
      Sorts.sort_of_univ (Universe.sup Universe.type0 u1)
  | (Term.__Set, Term.Type u2) =&gt;
    Sorts.sort_of_univ (Universe.sup Universe.type0 u2)
  | (Term.Prop, Term.Type _) =&gt; rangsort
  | (Term.Type u1, Term.Type u2) =&gt; Sorts.sort_of_univ (Universe.sup u1 u2)
  end.

Definition type_of_product {A : Set}
  (env : Environ.env) (_name : A) (s1 : Term.sorts) (s2 : Term.sorts)
  : Constr.types :=
  let s := sort_of_product env s1 s2 in
  mkSort s.

Definition check_cast
  (env : Environ.env) (c : Constr.constr) (ct : Constr.types)
  (k : Constr.cast_kind) (expected_type : Constr.types) : unit :=
  (* ❌ Try-with are not handled *)
  try
    match k with
    | Constr.VMcast =&gt; Vconv.vm_conv Reduction.CUMUL env ct expected_type
    | Constr.DEFAULTcast =&gt;
      default_conv Reduction.CUMUL (Some false) env ct expected_type
    | Constr.REVERTcast =&gt;
      default_conv Reduction.CUMUL (Some true) env ct expected_type
    | Constr.NATIVEcast =&gt;
      let sigma := Nativelambda.empty_evars in
      Nativeconv.native_conv Reduction.CUMUL sigma env ct expected_type
    end.

Definition type_of_inductive_knowing_parameters
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : array (Stdlib.Lazy.t Constr.types) -&gt; Constr.types :=
  let '(ind, u) as indu := function_parameter in
  fun args =&gt;
    let '(mib, _mip) as spec := lookup_mind_specif env ind in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let '(t, cst) :=
      Inductive.constrained_type_of_inductive_knowing_parameters env (spec, u)
        args in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    t.

Definition type_of_inductive
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : Constr.types :=
  let '(ind, u) as indu := function_parameter in
  let '(mib, mip) := lookup_mind_specif env ind in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let '(t, cst) := Inductive.constrained_type_of_inductive env ((mib, mip), u)
    in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  t.

Definition type_of_constructor
  (env : Environ.env) (function_parameter : Names.constructor * Univ.Instance.t)
  : Constr.types :=
  let '(c, _u) as cu := function_parameter in
  let '_ :=
    let '((kn, _), _) := c in
    let mib := lookup_mind kn env in
    check_hyps_inclusion env None mkConstructU cu
      (Declarations.mutual_inductive_body.mind_hyps mib) in
  let specif := lookup_mind_specif env (inductive_of_constructor c) in
  let '(t, cst) := constrained_type_of_constructor cu specif in
  let '_ := check_constraints cst env in
  t.

Definition check_branch_types
  (env : Environ.env) (function_parameter : Names.inductive * Univ.Instance.t)
  : Constr.constr -&gt; Constr.types -&gt; array Constr.types -&gt; array Constr.types -&gt;
  unit :=
  let '(ind, u) := function_parameter in
  fun c =&gt;
    fun ct =&gt;
      fun lft =&gt;
        fun explft =&gt;
          (* ❌ Try-with are not handled *)
          try (conv_leq_vecti env lft explft).

Definition type_of_case {A : Set}
  (env : Environ.env) (ci : Constr.case_info) (p : Constr.constr)
  (pt : Constr.types) (c : Constr.constr) (ct : Constr.types) (_lf : A)
  (lft : array Constr.types) : Constr.case_info * Constr.types :=
  let '(pind, _) as indspec :=
    (* ❌ Try-with are not handled *)
    try (find_rectype env ct) in
  let '(_, sp) :=
    (* ❌ Try-with are not handled *)
    try (dest_arity env pt) in
  let rp := Sorts.relevance_of_sort sp in
  let ci :=
    if Stdlib.op_eqeq (Constr.case_info.ci_relevance ci) rp then
      ci
    else
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Constr.case_info.with_ci_relevance ci rp in
  let '_ := check_case_info env pind rp ci in
  let '(bty, rslty) := type_case_branches env indspec (make_judge p pt) c in
  let '_ := check_branch_types env pind c ct lft bty in
  (ci, rslty).

Definition type_of_projection
  (env : Environ.env) (p : Names.Projection.t) (c : Constr.constr)
  (ct : Constr.types) : Constr.constr :=
  let pty := lookup_projection p env in
  let '((ind, u), args) :=
    (* ❌ Try-with are not handled *)
    try (find_rectype env ct) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let ty := Vars.subst_instance_constr u pty in
  substl (cons c ((|CList|).(CList.ExtS.rev) args)) ty.

Definition check_fixpoint
  (env : Environ.env) (lna : array (Context.binder_annot Names.Name.t))
  (lar : array Constr.constr) (vdef : array Constr.constr)
  (vdeft : array Constr.types) : unit :=
  let lt := (|Util.Array|).(CArray.ExtS.length) vdeft in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Try-with are not handled *)
  try
    (conv_leq_vecti env vdeft
      ((|Util.Array|).(CArray.ExtS.map) (fun ty =&gt; lift lt ty) lar)).

Definition type_of_global_in_context (env : Environ.env) (r : Names.GlobRef.t)
  : Constr.types * Univ.AUContext.t :=
  match r with
  | Names.GlobRef.VarRef id =&gt;
    ((Environ.named_type id env), Univ.AUContext.empty)
  | Names.GlobRef.ConstRef c =&gt;
    let cb := Environ.lookup_constant c env in
    let univs := Declareops.constant_polymorphic_context cb in
    ((Declarations.constant_body.const_type cb), univs)
  | Names.GlobRef.IndRef ind =&gt;
    let '(mib, _) as specif := Inductive.lookup_mind_specif env ind in
    let univs := Declareops.inductive_polymorphic_context mib in
    let inst := Univ.make_abstract_instance univs in
    let env := Environ.push_context (Some false) (Univ.AUContext.repr univs) env
      in
    ((Inductive.type_of_inductive env (specif, inst)), univs)
  | Names.GlobRef.ConstructRef cstr =&gt;
    let '(mib, _) as specif :=
      Inductive.lookup_mind_specif env (inductive_of_constructor cstr) in
    let univs := Declareops.inductive_polymorphic_context mib in
    let inst := Univ.make_abstract_instance univs in
    ((Inductive.type_of_constructor (cstr, inst) specif), univs)
  end.

Definition check_binder_annot
  (s : Sorts.t) (x : Context.binder_annot Names.Name.t)
  : Context.binder_annot Names.Name.t :=
  let r := Context.binder_annot.binder_relevance x in
  let r' := Sorts.relevance_of_sort s in
  if Stdlib.op_eqeq r' r then
    x
  else
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Context.binder_annot.with_binder_relevance x r'.

Fixpoint execute (env : Environ.env) (cstr : Constr.constr) {struct env}
  : Constr.constr * Constr.types :=
  match kind cstr with
  | Constr.Sort s =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (cstr, (type_of_sort s))
  | Constr.Rel n =&gt; (cstr, (type_of_relative env n))
  | Constr.Var id =&gt; (cstr, (type_of_variable env id))
  | Constr.Const c =&gt; (cstr, (type_of_constant env c))
  | Constr.Proj p c =&gt;
    let '(c', ct) := execute env c in
    let cstr :=
      if Stdlib.op_eqeq c c' then
        cstr
      else
        mkProj (p, c') in
    (cstr, (type_of_projection env p c' ct))
  | Constr.App f args =&gt;
    let '(args', argst) := execute_array env args in
    let '(f', ft) :=
      match
        ((kind f),
          match kind f with
          | Constr.Ind ind =&gt; Environ.template_polymorphic_pind ind env
          | _ =&gt; false
          end) with
      | (Constr.Ind ind, true) =&gt;
        let args :=
          (|Util.Array|).(CArray.ExtS.map)
            (fun t =&gt;
              (* ❌ Lazy expressions are not handled *)
              lazy t) argst in
        (f, (type_of_inductive_knowing_parameters env ind args))
      | (_, _) =&gt; execute env f
      end in
    let cstr :=
      if andb (Stdlib.op_eqeq f f') (Stdlib.op_eqeq args args') then
        cstr
      else
        mkApp (f', args') in
    (cstr, (type_of_apply env f' ft args' argst))
  | Constr.Lambda name c1 c2 =&gt;
    let '(c1', s) := execute_is_type env c1 in
    let name' := check_binder_annot s name in
    let env1 := push_rel (Context.Rel.Declaration.LocalAssum name' c1') env in
    let '(c2', c2t) := execute env1 c2 in
    let cstr :=
      if
        andb (Stdlib.op_eqeq name name')
          (andb (Stdlib.op_eqeq c1 c1') (Stdlib.op_eqeq c2 c2')) then
        cstr
      else
        mkLambda (name', c1', c2') in
    (cstr, (type_of_abstraction env name' c1 c2t))
  | Constr.Prod name c1 c2 =&gt;
    let '(c1', vars) := execute_is_type env c1 in
    let name' := check_binder_annot vars name in
    let env1 := push_rel (Context.Rel.Declaration.LocalAssum name' c1') env in
    let '(c2', vars') := execute_is_type env1 c2 in
    let cstr :=
      if
        andb (Stdlib.op_eqeq name name')
          (andb (Stdlib.op_eqeq c1 c1') (Stdlib.op_eqeq c2 c2')) then
        cstr
      else
        mkProd (name', c1', c2') in
    (cstr, (type_of_product env name' vars vars'))
  | Constr.LetIn name c1 c2 c3 =&gt;
    let '(c1', c1t) := execute env c1 in
    let '(c2', c2s) := execute_is_type env c2 in
    let name' := check_binder_annot c2s name in
    let '_ := check_cast env c1' c1t Constr.DEFAULTcast c2' in
    let env1 := push_rel (Context.Rel.Declaration.LocalDef name' c1' c2') env in
    let '(c3', c3t) := execute env1 c3 in
    let cstr :=
      if
        andb (Stdlib.op_eqeq name name')
          (andb (Stdlib.op_eqeq c1 c1')
            (andb (Stdlib.op_eqeq c2 c2') (Stdlib.op_eqeq c3 c3'))) then
        cstr
      else
        mkLetIn (name', c1', c2', c3') in
    (cstr, (subst1 c1 c3t))
  | Constr.Cast c k t =&gt;
    let '(c', ct) := execute env c in
    let '(t', _ts) := execute_is_type env t in
    let '_ := check_cast env c' ct k t' in
    let cstr :=
      if andb (Stdlib.op_eqeq c c') (Stdlib.op_eqeq t t') then
        cstr
      else
        mkCast (c', k, t') in
    (cstr, t')
  | Constr.Ind ind =&gt; (cstr, (type_of_inductive env ind))
  | Constr.Construct c =&gt; (cstr, (type_of_constructor env c))
  | Constr.Case ci p c lf =&gt;
    let '(c', ct) := execute env c in
    let '(p', pt) := execute env p in
    let '(lf', lft) := execute_array env lf in
    let '(ci', t) := type_of_case env ci p' pt c' ct lf' lft in
    let cstr :=
      if
        andb (Stdlib.op_eqeq ci ci')
          (andb (Stdlib.op_eqeq c c')
            (andb (Stdlib.op_eqeq p p') (Stdlib.op_eqeq lf lf'))) then
        cstr
      else
        mkCase (ci', p', c', lf') in
    (cstr, t)
  | Constr.Fix (((_vn, i) as vni, recdef) as fix) =&gt;
    let '(fix_ty, recdef') := execute_recdef env recdef i in
    let '(cstr, fix) :=
      if Stdlib.op_eqeq recdef recdef' then
        (cstr, fix)
      else
        let fix := (vni, recdef') in
        ((mkFix fix), fix) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (cstr, fix_ty)
  | Constr.CoFix ((i, recdef) as cofix) =&gt;
    let '(fix_ty, recdef') := execute_recdef env recdef i in
    let '(cstr, cofix) :=
      if Stdlib.op_eqeq recdef recdef' then
        (cstr, cofix)
      else
        let cofix := (i, recdef') in
        ((mkCoFix cofix), cofix) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (cstr, fix_ty)
  | Constr.Int _ =&gt; (cstr, (type_of_int env))
  | Constr.Meta _ =&gt;
    anomaly None None (Pp.str &quot;the kernel does not support metavariables.&quot;)
  | Constr.Evar _ =&gt;
    anomaly None None
      (Pp.str &quot;the kernel does not support existential variables.&quot;)
  end

with execute_is_type (env : Environ.env) (constr : Constr.types) {struct env}
  : Constr.types * Term.sorts :=
  let '(c, t) := execute env constr in
  (c, (check_type env constr t))

with execute_recdef
  (env : Environ.env)
  (function_parameter : Constr.prec_declaration Constr.constr Constr.types)
  {struct env}
  : Z -&gt; Constr.types * Constr.prec_declaration Constr.constr Constr.types :=
  let '(names, lar, vdef) as recdef := function_parameter in
  fun i =&gt;
    let '(lar', lart) := execute_array env lar in
    let names' :=
      Array.Smart.map_i
        (fun i =&gt;
          fun na =&gt;
            check_assumption env na ((|Util.Array|).(CArray.ExtS.get) lar' i)
              ((|Util.Array|).(CArray.ExtS.get) lart i)) names in
    let env1 := push_rec_types (names', lar', vdef) env in
    let '(vdef', vdeft) := execute_array env1 vdef in
    let '_ := check_fixpoint env1 names' lar' vdef' vdeft in
    let recdef :=
      if
        andb (Stdlib.op_eqeq names names')
          (andb (Stdlib.op_eqeq lar lar') (Stdlib.op_eqeq vdef vdef')) then
        recdef
      else
        (names', lar', vdef') in
    (((|Util.Array|).(CArray.ExtS.get) lar' i), recdef)

with execute_array (env : Environ.env) (cs : array Constr.constr) {struct env}
  : array Constr.constr * array Constr.types :=
  let tys :=
    (|Util.Array|).(CArray.ExtS.make) ((|Util.Array|).(CArray.ExtS.length) cs)
      mkProp in
  let cs :=
    Array.Smart.map_i
      (fun i =&gt;
        fun c =&gt;
          let '(c, ty) := execute env c in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          c) cs in
  (cs, tys).

Definition check_wellformed_universes (env : Environ.env) (c : Constr.constr)
  : unit :=
  let univs := universes_of_constr c in
  (* ❌ Try-with are not handled *)
  try (UGraph.check_declared_universes (universes env) univs).

Definition infer (env : Environ.env) (constr : Constr.constr)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  let '_ := check_wellformed_universes env constr in
  let '(constr, t) := execute env constr in
  make_judge constr t.

Definition infer
  : Environ.env -&gt; Constr.constr -&gt;
  Environ.punsafe_judgment Constr.constr Constr.types :=
  if Flags.profile then
    let infer_key := CProfile.declare_profile &quot;Fast_infer&quot; in
    CProfile.profile2 infer_key (fun b =&gt; fun c =&gt; infer b c)
  else
    fun b =&gt; fun c =&gt; infer b c.

Definition assumption_of_judgment
  (env : Environ.env)
  (function_parameter : Environ.punsafe_judgment Constr.constr Constr.constr)
  : Sorts.relevance :=
  let '{|
    Environ.punsafe_judgment.uj_val := c;
      Environ.punsafe_judgment.uj_type := t
      |} := function_parameter in
  infer_assumption env c t.

Definition type_judgment
  (env : Environ.env)
  (function_parameter : Environ.punsafe_judgment Constr.constr Constr.constr)
  : Environ.punsafe_type_judgment Constr.constr :=
  let '{|
    Environ.punsafe_judgment.uj_val := c;
      Environ.punsafe_judgment.uj_type := t
      |} := function_parameter in
  let s := check_type env c t in
  {| Environ.punsafe_type_judgment.utj_val := c;
    Environ.punsafe_type_judgment.utj_type := s |}.

Definition infer_type (env : Environ.env) (constr : Constr.constr)
  : Environ.punsafe_type_judgment Constr.constr :=
  let '_ := check_wellformed_universes env constr in
  let '(constr, t) := execute env constr in
  let s := check_type env constr t in
  {| Environ.punsafe_type_judgment.utj_val := constr;
    Environ.punsafe_type_judgment.utj_type := s |}.

Definition check_context
  (env : Environ.env) (rels : Context.Rel.pt Constr.constr Constr.constr)
  : Environ.env * list (Context.Rel.Declaration.pt Constr.constr Constr.constr) :=
  Context.Rel.fold_outside
    (fun d =&gt;
      fun function_parameter =&gt;
        let '(env, rels) := function_parameter in
        match d with
        | Context.Rel.Declaration.LocalAssum x ty =&gt;
          let jty := infer_type env ty in
          let x :=
            check_binder_annot (Environ.punsafe_type_judgment.utj_type jty) x in
          ((push_rel d env),
            (cons
              (Context.Rel.Declaration.LocalAssum x
                (Environ.punsafe_type_judgment.utj_val jty)) rels))
        | Context.Rel.Declaration.LocalDef x bd ty =&gt;
          let j1 := infer env bd in
          let jty := infer_type env ty in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          let x :=
            check_binder_annot (Environ.punsafe_type_judgment.utj_type jty) x in
          ((push_rel d env),
            (cons
              (Context.Rel.Declaration.LocalDef x
                (Environ.punsafe_judgment.uj_val j1)
                (Environ.punsafe_type_judgment.utj_val jty)) rels))
        end) rels (env, []).

Definition judge_of_prop : Environ.punsafe_judgment Constr.types Constr.types :=
  make_judge mkProp type1.

Definition judge_of_set : Environ.punsafe_judgment Constr.types Constr.types :=
  make_judge mkSet type1.

Definition judge_of_type (u : Univ.Universe.t)
  : Environ.punsafe_judgment Constr.types Constr.types :=
  make_judge (mkType u) (type_of_type u).

Definition judge_of_relative (env : Environ.env) (k : Z)
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  make_judge (mkRel k) (type_of_relative env k).

Definition judge_of_variable (env : Environ.env) (x : Names.variable)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  make_judge (mkVar x) (type_of_variable env x).

Definition judge_of_constant (env : Environ.env) (cst : Constr.pconstant)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  make_judge (mkConstU cst) (type_of_constant env cst).

Definition judge_of_projection
  (env : Environ.env) (p : Names.Projection.t)
  (cj : Environ.punsafe_judgment Constr.constr Constr.types)
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  make_judge (mkProj (p, (Environ.punsafe_judgment.uj_val cj)))
    (type_of_projection env p (Environ.punsafe_judgment.uj_val cj)
      (Environ.punsafe_judgment.uj_type cj)).

Definition dest_judgev {A B : Set} (v : array (Environ.punsafe_judgment A B))
  : array A * array B :=
  (((|Util.Array|).(CArray.ExtS.map) j_val v),
    ((|Util.Array|).(CArray.ExtS.map) j_type v)).

Definition judge_of_apply
  (env : Environ.env)
  (funj : Environ.punsafe_judgment Constr.constr Constr.types)
  (argjv : array (Environ.punsafe_judgment Constr.constr Constr.types))
  : Environ.punsafe_judgment Constr.constr Constr.constr :=
  let '(args, argtys) := dest_judgev argjv in
  make_judge (mkApp ((Environ.punsafe_judgment.uj_val funj), args))
    (type_of_apply env (Environ.punsafe_judgment.uj_val funj)
      (Environ.punsafe_judgment.uj_type funj) args argtys).

Definition judge_of_cast
  (env : Environ.env) (cj : Environ.punsafe_judgment Constr.constr Constr.types)
  (k : Constr.cast_kind) (tj : Environ.punsafe_type_judgment Constr.types)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  let '_ :=
    check_cast env (Environ.punsafe_judgment.uj_val cj)
      (Environ.punsafe_judgment.uj_type cj) k
      (Environ.punsafe_type_judgment.utj_val tj) in
  let c :=
    match k with
    | Constr.REVERTcast =&gt; Environ.punsafe_judgment.uj_val cj
    | _ =&gt;
      mkCast
        ((Environ.punsafe_judgment.uj_val cj), k,
          (Environ.punsafe_type_judgment.utj_val tj))
    end in
  make_judge c (Environ.punsafe_type_judgment.utj_val tj).

Definition judge_of_inductive (env : Environ.env) (indu : Constr.pinductive)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  make_judge (mkIndU indu) (type_of_inductive env indu).

Definition judge_of_constructor (env : Environ.env) (cu : Constr.pconstructor)
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  make_judge (mkConstructU cu) (type_of_constructor env cu).

Definition judge_of_case {A : Set}
  (env : Environ.env) (ci : Constr.case_info)
  (pj : Environ.punsafe_judgment Constr.constr Constr.types)
  (cj : Environ.punsafe_judgment Constr.constr Constr.types)
  (lfj : array (Environ.punsafe_judgment A Constr.types))
  : Environ.punsafe_judgment Constr.constr Constr.types :=
  let '(lf, lft) := dest_judgev lfj in
  let '(ci, t) :=
    type_of_case env ci (Environ.punsafe_judgment.uj_val pj)
      (Environ.punsafe_judgment.uj_type pj) (Environ.punsafe_judgment.uj_val cj)
      (Environ.punsafe_judgment.uj_type cj) lf lft in
  make_judge
    (mkCase
      (ci, (Environ.punsafe_judgment.uj_val pj),
        (Environ.punsafe_judgment.uj_val cj), lft)) t.

Definition check_primitive_type
  (env : Environ.env) (op_t : CPrimitives.op_or_type) (t : Constr.types)
  : unit :=
  let inft := type_of_prim_or_type env op_t in
  (* ❌ Try-with are not handled *)
  try (default_conv Reduction.CUMUL (Some false) env inft t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="typeops.mli">
  <div style="margin: 20px;">
    <h3>Typeops_mli</h3>
    <ul>
      <li>OCaml size: 127 lines</li>
      <li>Coq size: 103 lines (-19% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#typeops.mli"><code>typeops.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr
open Univ
open Environ

(** {6 Typing functions (not yet tagged as safe) }

    They return unsafe judgments that are &quot;in context&quot; of a set of
   (local) universe variables (the ones that appear in the term) and
   associated constraints. In case of polymorphic definitions, these
   variables and constraints will be generalized.

    When typechecking a term it may be updated to fix relevance marks.
   Do not discard the result. *)

val infer      : env -&gt; constr       -&gt; unsafe_judgment
val infer_type : env -&gt; types        -&gt; unsafe_type_judgment

val check_context :
  env -&gt; Constr.rel_context -&gt; env * Constr.rel_context

(** {6 Basic operations of the typing machine. } *)

(** If [j] is the judgement {% $ %}c:t{% $ %}, then [assumption_of_judgement env j]
   returns the type {% $ %}c{% $ %}, checking that {% $ %}t{% $ %} is a sort. *)

val assumption_of_judgment :  env -&gt; unsafe_judgment -&gt; Sorts.relevance
val type_judgment          :  env -&gt; unsafe_judgment -&gt; unsafe_type_judgment

val check_binder_annot : Sorts.t -&gt; Name.t Context.binder_annot -&gt; Name.t Context.binder_annot

(** {6 Type of sorts. } *)
val type1 : types
val type_of_sort : Sorts.t -&gt; types
val judge_of_prop : unsafe_judgment
val judge_of_set  : unsafe_judgment
val judge_of_type           : Universe.t -&gt; unsafe_judgment

(** {6 Type of a bound variable. } *)
val type_of_relative : env -&gt; int -&gt; types
val judge_of_relative : env -&gt; int -&gt; unsafe_judgment

(** {6 Type of variables } *)
val type_of_variable : env -&gt; variable -&gt; types
val judge_of_variable : env -&gt; variable -&gt; unsafe_judgment

(** {6 type of a constant } *)
val type_of_constant_in : env -&gt; pconstant -&gt; types
val judge_of_constant : env -&gt; pconstant -&gt; unsafe_judgment

(** {6 type of an applied projection } *)
val judge_of_projection : env -&gt; Projection.t -&gt; unsafe_judgment -&gt; unsafe_judgment

(** {6 Type of application. } *)
val judge_of_apply :
  env -&gt; unsafe_judgment -&gt; unsafe_judgment array
    -&gt; unsafe_judgment

(** {6 Type of an abstraction. } *)
(* val judge_of_abstraction : *)
(*   env -&gt; Name.t -&gt; unsafe_type_judgment -&gt; unsafe_judgment *)
(*     -&gt; unsafe_judgment *)

(** {6 Type of a product. } *)
val sort_of_product : env -&gt; Sorts.t -&gt; Sorts.t -&gt; Sorts.t
val type_of_product : env -&gt; Name.t Context.binder_annot -&gt; Sorts.t -&gt; Sorts.t -&gt; types
(* val judge_of_product : *)
(*   env -&gt; Name.t -&gt; unsafe_type_judgment -&gt; unsafe_type_judgment *)
(*     -&gt; unsafe_judgment *)

(** s Type of a let in. *)
(* val judge_of_letin : *)
(*   env -&gt; Name.t -&gt; unsafe_judgment -&gt; unsafe_type_judgment -&gt; unsafe_judgment *)
(*     -&gt; unsafe_judgment *)

(** {6 Type of a cast. } *)
val judge_of_cast :
  env -&gt; unsafe_judgment -&gt; cast_kind -&gt; unsafe_type_judgment -&gt;
  unsafe_judgment

(** {6 Inductive types. } *)
val judge_of_inductive : env -&gt; inductive puniverses -&gt; unsafe_judgment
val judge_of_constructor : env -&gt; constructor puniverses -&gt; unsafe_judgment

(** {6 Type of Cases. } *)
val judge_of_case : env -&gt; case_info
  -&gt; unsafe_judgment -&gt; unsafe_judgment -&gt; unsafe_judgment array
    -&gt; unsafe_judgment

(** {6 Type of global references. } *)

val type_of_global_in_context : env -&gt; GlobRef.t -&gt; types * Univ.AUContext.t
(** Returns the type of the global reference, by creating a fresh
    instance of polymorphic references and computing their
    instantiated universe context. The type should not be used
    without pushing it's universe context in the environmnent of
    usage. For non-universe-polymorphic constants, it does not
    matter. *)

(** {6 Miscellaneous. } *)

(** Check that hyps are included in env and fails with error otherwise *)
val check_hyps_inclusion : env -&gt; ?evars:((existential-&gt;constr option) * UGraph.t) -&gt;
  ('a -&gt; constr) -&gt; 'a -&gt; Constr.named_context -&gt; unit

val check_primitive_type : env -&gt; CPrimitives.op_or_type -&gt; types -&gt; unit

(** Types for primitives *)

val type_of_int : env -&gt; types
val judge_of_int : env -&gt; Uint63.t -&gt; unsafe_judgment

val type_of_prim_type : env -&gt; CPrimitives.prim_type -&gt; types
val type_of_prim : env -&gt; CPrimitives.t -&gt; types

val warn_bad_relevance_name : string
(** Allow the checker to make this warning into an error. *)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#typeops.mli"><code>Typeops_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter infer : Environ.env -&gt; Constr.constr -&gt; Environ.unsafe_judgment.

Parameter infer_type :
  Environ.env -&gt; Constr.types -&gt; Environ.unsafe_type_judgment.

Parameter check_context :
  Environ.env -&gt; Constr.rel_context -&gt; Environ.env * Constr.rel_context.

Parameter assumption_of_judgment :
  Environ.env -&gt; Environ.unsafe_judgment -&gt; Sorts.relevance.

Parameter type_judgment :
  Environ.env -&gt; Environ.unsafe_judgment -&gt; Environ.unsafe_type_judgment.

Parameter check_binder_annot :
  Sorts.t -&gt; Context.binder_annot Names.Name.t -&gt;
  Context.binder_annot Names.Name.t.

Parameter type1 : Constr.types.

Parameter type_of_sort : Sorts.t -&gt; Constr.types.

Parameter judge_of_prop : Environ.unsafe_judgment.

Parameter judge_of_set : Environ.unsafe_judgment.

Parameter judge_of_type : Univ.Universe.t -&gt; Environ.unsafe_judgment.

Parameter type_of_relative : Environ.env -&gt; Z -&gt; Constr.types.

Parameter judge_of_relative : Environ.env -&gt; Z -&gt; Environ.unsafe_judgment.

Parameter type_of_variable : Environ.env -&gt; Names.variable -&gt; Constr.types.

Parameter judge_of_variable :
  Environ.env -&gt; Names.variable -&gt; Environ.unsafe_judgment.

Parameter type_of_constant_in : Environ.env -&gt; Constr.pconstant -&gt; Constr.types.

Parameter judge_of_constant :
  Environ.env -&gt; Constr.pconstant -&gt; Environ.unsafe_judgment.

Parameter judge_of_projection :
  Environ.env -&gt; Names.Projection.t -&gt; Environ.unsafe_judgment -&gt;
  Environ.unsafe_judgment.

Parameter judge_of_apply :
  Environ.env -&gt; Environ.unsafe_judgment -&gt; array Environ.unsafe_judgment -&gt;
  Environ.unsafe_judgment.

Parameter sort_of_product : Environ.env -&gt; Sorts.t -&gt; Sorts.t -&gt; Sorts.t.

Parameter type_of_product :
  Environ.env -&gt; Context.binder_annot Names.Name.t -&gt; Sorts.t -&gt; Sorts.t -&gt;
  Constr.types.

Parameter judge_of_cast :
  Environ.env -&gt; Environ.unsafe_judgment -&gt; Constr.cast_kind -&gt;
  Environ.unsafe_type_judgment -&gt; Environ.unsafe_judgment.

Parameter judge_of_inductive :
  Environ.env -&gt; Univ.puniverses Names.inductive -&gt; Environ.unsafe_judgment.

Parameter judge_of_constructor :
  Environ.env -&gt; Univ.puniverses Names.constructor -&gt; Environ.unsafe_judgment.

Parameter judge_of_case :
  Environ.env -&gt; Constr.case_info -&gt; Environ.unsafe_judgment -&gt;
  Environ.unsafe_judgment -&gt; array Environ.unsafe_judgment -&gt;
  Environ.unsafe_judgment.

Parameter type_of_global_in_context :
  Environ.env -&gt; Names.GlobRef.t -&gt; Constr.types * Univ.AUContext.t.

Parameter check_hyps_inclusion : forall {a : Set},
  Environ.env -&gt;
  option ((Constr.existential -&gt; option Constr.constr) * UGraph.t) -&gt;
  (a -&gt; Constr.constr) -&gt; a -&gt; Constr.named_context -&gt; unit.

Parameter check_primitive_type :
  Environ.env -&gt; CPrimitives.op_or_type -&gt; Constr.types -&gt; unit.

Parameter type_of_int : Environ.env -&gt; Constr.types.

Parameter judge_of_int : Environ.env -&gt; Uint63.t -&gt; Environ.unsafe_judgment.

Parameter type_of_prim_type :
  Environ.env -&gt; CPrimitives.prim_type -&gt; Constr.types.

Parameter type_of_prim : Environ.env -&gt; CPrimitives.t -&gt; Constr.types.

Parameter warn_bad_relevance_name : string.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="uGraph.ml">
  <div style="margin: 20px;">
    <h3>UGraph</h3>
    <ul>
      <li>OCaml size: 226 lines</li>
      <li>Coq size: 338 lines (+49% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#uGraph.ml"><code>uGraph.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Univ

module G = AcyclicGraph.Make(struct
    type t = Level.t
    module Set = LSet
    module Map = LMap
    module Constraint = Constraint

    let equal = Level.equal
    let compare = Level.compare

    type explanation = Univ.explanation
    let error_inconsistency d u v p =
      raise <abbr class="mark-warning" title="Values of extensible types are not handled">(UniverseInconsistency (d,Universe.make u, Universe.make v, p))</abbr>

    let pr = Level.pr
  end) [@@inlined] (* without inline, +1% ish on HoTT, compcert. See jenkins 594 vs 596 *)
(* Do not include G to make it easier to control universe specific
   code (eg add_universe with a constraint vs G.add with no
   constraint) *)

type t = { graph: G.t; sprop_cumulative : bool }
type 'a check_function = t -&gt; 'a -&gt; 'a -&gt; bool

let g_map f g =
  let g' = f g.graph in
  if g.graph == g' then g
  else {g with graph=g'}

let make_sprop_cumulative g = {g with sprop_cumulative=true}

let check_smaller_expr g (u,n) (v,m) =
  let diff = n - m in
    match diff with
    | 0 -&gt; G.check_leq g.graph u v
    | 1 -&gt; G.check_lt g.graph u v
    | x when x &lt; 0 -&gt; G.check_leq g.graph u v
    | _ -&gt; false

let exists_bigger g ul l =
  Universe.exists (fun ul' -&gt;
    check_smaller_expr g ul ul') l

let real_check_leq g u v =
  Universe.for_all (fun ul -&gt; exists_bigger g ul v) u

let check_leq g u v =
  Universe.equal u v || (g.sprop_cumulative &amp;&amp; Universe.is_sprop u) ||
  (not (Universe.is_sprop u) &amp;&amp; not (Universe.is_sprop v) &amp;&amp;
    (is_type0m_univ u ||
     real_check_leq g u v))

let check_eq g u v =
  Universe.equal u v ||
  (not (Universe.is_sprop u || Universe.is_sprop v) &amp;&amp;
   (real_check_leq g u v &amp;&amp; real_check_leq g v u))

let check_eq_level g u v =
  u == v ||
  (not (Level.is_sprop u || Level.is_sprop v) &amp;&amp; G.check_eq g.graph u v)

let empty_universes = {graph=G.empty; sprop_cumulative=false}

let initial_universes =
  let big_rank = 1000000 in
  let g = G.empty in
  let g = G.add ~rank:big_rank Level.prop g in
  let g = G.add ~rank:big_rank Level.set g in
  {graph=G.enforce_lt Level.prop Level.set g; sprop_cumulative=false}

let enforce_constraint (u,d,v) g =
  match d with
  | Le -&gt; G.enforce_leq u v g
  | Lt -&gt; G.enforce_lt u v g
  | Eq -&gt; G.enforce_eq u v g

let enforce_constraint (u,d,v as cst) g =
  match Level.is_sprop u, d, Level.is_sprop v with
  | false, _, false -&gt; g_map (enforce_constraint cst) g
  | true, (Eq|Le), true -&gt; g
  | true, Le, false when g.sprop_cumulative -&gt; g
  | _ -&gt;  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(UniverseInconsistency (d,Universe.make u, Universe.make v, None))</abbr>

let merge_constraints csts g = Constraint.fold enforce_constraint csts g

let check_constraint g (u,d,v) =
  match d with
  | Le -&gt; G.check_leq g u v
  | Lt -&gt; G.check_lt g u v
  | Eq -&gt; G.check_eq g u v

let check_constraint g (u,d,v as cst) =
  match Level.is_sprop u, d, Level.is_sprop v with
  | false, _, false -&gt; check_constraint g.graph cst
  | true, (Eq|Le), true -&gt; true
  | true, Le, false -&gt; g.sprop_cumulative
  | _ -&gt; false

let check_constraints csts g = Constraint.for_all (check_constraint g) csts

let leq_expr (u,m) (v,n) =
  let d = match m - n with
    | 1 -&gt; Lt
    | diff -&gt; <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (diff &lt;= 0); Le</abbr>
  in
  (u,d,v)

let enforce_leq_alg u v g =
  let open Util in
  let enforce_one (u,v) = function
    | Inr _ as orig -&gt; orig
    | Inl (cstrs,g) as orig -&gt;
      if check_smaller_expr g u v then orig
      else
        (let c = leq_expr u v in
         match enforce_constraint c g with
         | g -&gt; Inl (Constraint.add c cstrs,g)
         | exception <abbr class="mark-warning" title="Pattern-matching on exceptions not supported

Only the special case `| exception _ when false -&gt; ...` is supported for default value of GADT pattern-matching">(UniverseInconsistency _ as e)</abbr> -&gt; Inr e)
  in
  (* max(us) &lt;= max(vs) &lt;-&gt; forall u in us, exists v in vs, u &lt;= v *)
  let c = Universe.map (fun u -&gt; Universe.map (fun v -&gt; (u,v)) v) u in
  let c = List.cartesians enforce_one (Inl (Constraint.empty,g)) c in
  (* We pick a best constraint: smallest number of constraints, not an error if possible. *)
  let order x y = match x, y with
    | Inr _, Inr _ -&gt; 0
    | Inl _, Inr _ -&gt; -1
    | Inr _, Inl _ -&gt; 1
    | Inl (c,_), Inl (c',_) -&gt;
      Int.compare (Constraint.cardinal c) (Constraint.cardinal c')
  in
  match List.min order c with
  | Inl x -&gt; x
  | Inr e -&gt; raise e

(* sanity check wrapper *)
let enforce_leq_alg u v g =
  let _,g as cg = enforce_leq_alg u v g in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (check_leq g u v);
  cg</abbr>

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception AlreadyDeclared = G.AlreadyDeclared</abbr>
let add_universe u ~lbound ~strict g =
  let graph = G.add u g.graph in
  let d = if strict then Lt else Le in
  enforce_constraint (lbound,d,u) {g with graph}

let add_universe_unconstrained u g = {g with graph=G.add u g.graph}

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception UndeclaredLevel = G.Undeclared</abbr>
let check_declared_universes g l = G.check_declared g.graph (LSet.remove Level.sprop l)

let constraints_of_universes g = G.constraints_of g.graph
let constraints_for ~kept g = G.constraints_for ~kept:(LSet.remove Level.sprop kept) g.graph

(** Subtyping of polymorphic contexts *)

let check_subtype ~lbound univs ctxT ctx =
  if AUContext.size ctxT == AUContext.size ctx then
    let (inst, cst) = UContext.dest (AUContext.repr ctx) in
    let cstT = UContext.constraints (AUContext.repr ctxT) in
    let push accu v = add_universe v ~lbound ~strict:false accu in
    let univs = Array.fold_left push univs (Instance.to_array inst) in
    let univs = merge_constraints cstT univs in
    check_constraints cst univs
  else false

(** Instances *)

let check_eq_instances g t1 t2 =
  let t1 = Instance.to_array t1 in
  let t2 = Instance.to_array t2 in
  t1 == t2 ||
    (Int.equal (Array.length t1) (Array.length t2) &amp;&amp;
        let rec aux i =
          (Int.equal i (Array.length t1)) || (check_eq_level g t1.(i) t2.(i) &amp;&amp; aux (i + 1))
        in aux 0)

let domain g = LSet.add Level.sprop (G.domain g.graph)
let choose p g u = if Level.is_sprop u
  then if p u then Some u else None
  else G.choose p g.graph u

let dump_universes f g = G.dump f g.graph

let check_universes_invariants g = G.check_invariants ~required_canonical:Level.is_small g.graph

let pr_universes prl g = G.pr prl g.graph

let dummy_mp = Names.DirPath.make [Names.Id.of_string &quot;Type&quot;]
let make_dummy i = Level.(make (UGlobal.make dummy_mp i))
let sort_universes g = g_map (G.sort make_dummy [Level.prop;Level.set]) g

(** Profiling *)

let merge_constraints =
  if Flags.profile then
    let key = CProfile.declare_profile &quot;merge_constraints&quot; in
      CProfile.profile2 key merge_constraints
  else merge_constraints
let check_constraints =
  if Flags.profile then
    let key = CProfile.declare_profile &quot;check_constraints&quot; in
      CProfile.profile2 key check_constraints
  else check_constraints

let check_eq =
  if Flags.profile then
    let check_eq_key = CProfile.declare_profile &quot;check_eq&quot; in
      CProfile.profile3 check_eq_key check_eq
  else check_eq

let check_leq =
  if Flags.profile then
    let check_leq_key = CProfile.declare_profile &quot;check_leq&quot; in
      CProfile.profile3 check_leq_key check_leq
  else check_leq
</pre>
  </div>
  <div class="col-md-6">
    <a href="#uGraph.ml"><code>UGraph.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Univ.

Definition G :=
  AcyclicGraph.Make
    (let t := Univ.Level.t in
    let __Set := LSet in
    let Map := LMap in
    let equal := Level.equal in
    let compare := Level.compare in
    let explanation := Univ.explanation in
    let error_inconsistency {A : Set}
      (d : Univ.constraint_type) (u : Univ.Level.t) (v : Univ.Level.t)
      (p : option (Stdlib.Lazy.t Univ.explanation)) : A :=
      Stdlib.raise extensible_type_value in
    let pr := Level.pr in
    existT _ [_, _, _, _]
      {|
        AcyclicGraph.Point.equal := equal;
        AcyclicGraph.Point.compare := compare;
        AcyclicGraph.Point.error_inconsistency {_} := error_inconsistency;
        AcyclicGraph.Point.pr := pr
      |}).

Module t.
  Record record := {
    graph : G.t;
    sprop_cumulative : bool }.
  Definition with_graph (r : record) graph : record :=
    {| graph := graph; sprop_cumulative := sprop_cumulative r |}.
  Definition with_sprop_cumulative (r : record) sprop_cumulative : record :=
    {| graph := graph r; sprop_cumulative := sprop_cumulative |}.
End t.
Definition t := t.record.

Definition check_function (a : Set) := t -&gt; a -&gt; a -&gt; bool.

Definition g_map (f : G.t -&gt; G.t) (g : t) : t :=
  let g' := f (t.graph g) in
  if Stdlib.op_eqeq (t.graph g) g' then
    g
  else
    t.with_graph g g'.

Definition make_sprop_cumulative (g : t) : t := t.with_sprop_cumulative g true.

Definition check_smaller_expr (g : t) (function_parameter : Univ.Level.t * Z)
  : Univ.Level.t * Z -&gt; bool :=
  let '(u, n) := function_parameter in
  fun function_parameter =&gt;
    let '(v, m) := function_parameter in
    let diff := Z.sub n m in
    match
      (diff,
        match diff with
        | x =&gt; OCaml.Stdlib.lt x 0
        | _ =&gt; false
        end) with
    | (0, _) =&gt; G.check_leq (t.graph g) u v
    | (1, _) =&gt; G.check_lt (t.graph g) u v
    | (x, true) =&gt; G.check_leq (t.graph g) u v
    | (_, _) =&gt; false
    end.

Definition exists_bigger (g : t) (ul : Univ.Level.t * Z) (l : Univ.Universe.t)
  : bool := Universe.__exists (fun ul' =&gt; check_smaller_expr g ul ul') l.

Definition real_check_leq (g : t) (u : Univ.Universe.t) (v : Univ.Universe.t)
  : bool := Universe.for_all (fun ul =&gt; exists_bigger g ul v) u.

Definition check_leq (g : t) (u : Univ.Universe.t) (v : Univ.Universe.t)
  : bool :=
  orb (Universe.equal u v)
    (orb (andb (t.sprop_cumulative g) (Universe.is_sprop u))
      (andb (negb (Universe.is_sprop u))
        (andb (negb (Universe.is_sprop v))
          (orb (is_type0m_univ u) (real_check_leq g u v))))).

Definition check_eq (g : t) (u : Univ.Universe.t) (v : Univ.Universe.t)
  : bool :=
  orb (Universe.equal u v)
    (andb (negb (orb (Universe.is_sprop u) (Universe.is_sprop v)))
      (andb (real_check_leq g u v) (real_check_leq g v u))).

Definition check_eq_level (g : t) (u : Univ.Level.t) (v : Univ.Level.t)
  : bool :=
  orb (Stdlib.op_eqeq u v)
    (andb (negb (orb (Level.is_sprop u) (Level.is_sprop v)))
      (G.check_eq (t.graph g) u v)).

Definition empty_universes : t :=
  {| t.graph := G.empty; t.sprop_cumulative := false |}.

Definition initial_universes : t :=
  let big_rank := 1000000 in
  let g := G.empty in
  let g := G.add (Some big_rank) Level.prop g in
  let g := G.add (Some big_rank) Level.set g in
  {| t.graph := G.enforce_lt Level.prop Level.set g; t.sprop_cumulative := false
    |}.

Definition enforce_constraint
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : G.t -&gt; G.t :=
  let '(u, d, v) := function_parameter in
  fun g =&gt;
    match d with
    | Univ.Le =&gt; G.enforce_leq u v g
    | Univ.Lt =&gt; G.enforce_lt u v g
    | Univ.Eq =&gt; G.enforce_eq u v g
    end.

Definition enforce_constraint
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : t -&gt; t :=
  let '(u, d, v) as cst := function_parameter in
  fun g =&gt;
    match
      (((Level.is_sprop u), d, (Level.is_sprop v)),
        match ((Level.is_sprop u), d, (Level.is_sprop v)) with
        | (true, Univ.Le, false) =&gt; t.sprop_cumulative g
        | _ =&gt; false
        end) with
    | ((false, _, false), _) =&gt; g_map (enforce_constraint cst) g
    | ((true, Univ.Eq | Univ.Le, true), _) =&gt; g
    | ((true, Univ.Le, false), true) =&gt; g
    | (_, _) =&gt; Stdlib.raise extensible_type_value
    end.

Definition merge_constraints (csts : Univ.Constraint.t) (g : t) : t :=
  Constraint.fold enforce_constraint csts g.

Definition check_constraint
  (g : G.t)
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : bool :=
  let '(u, d, v) := function_parameter in
  match d with
  | Univ.Le =&gt; G.check_leq g u v
  | Univ.Lt =&gt; G.check_lt g u v
  | Univ.Eq =&gt; G.check_eq g u v
  end.

Definition check_constraint
  (g : t)
  (function_parameter : Univ.Level.t * Univ.constraint_type * Univ.Level.t)
  : bool :=
  let '(u, d, v) as cst := function_parameter in
  match ((Level.is_sprop u), d, (Level.is_sprop v)) with
  | (false, _, false) =&gt; check_constraint (t.graph g) cst
  | (true, Univ.Eq | Univ.Le, true) =&gt; true
  | (true, Univ.Le, false) =&gt; t.sprop_cumulative g
  | _ =&gt; false
  end.

Definition check_constraints (csts : Univ.Constraint.t) (g : t) : bool :=
  Constraint.for_all (check_constraint g) csts.

Definition leq_expr {A B : Set} (function_parameter : A * Z)
  : B * Z -&gt; A * Univ.constraint_type * B :=
  let '(u, m) := function_parameter in
  fun function_parameter =&gt;
    let '(v, n) := function_parameter in
    let d :=
      match Z.sub m n with
      | 1 =&gt; Univ.Lt
      | diff =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        Univ.Le
      end in
    (u, d, v).

Definition enforce_leq_alg (u : Univ.Universe.t) (v : Univ.Universe.t) (g : t)
  : Univ.Constraint.t * t :=
  let enforce_one (function_parameter : (Univ.Level.t * Z) * (Univ.Level.t * Z))
    : Util.union (Univ.Constraint.t * t) exn -&gt;
    Util.union (Univ.Constraint.t * t) exn :=
    let '(u, v) := function_parameter in
    fun function_parameter =&gt;
      match function_parameter with
      | (Util.Inr _) as orig =&gt; orig
      | (Util.Inl (cstrs, g)) as orig =&gt;
        if check_smaller_expr g u v then
          orig
        else
          let c := leq_expr u v in
          let 'g := enforce_constraint c g in
          Util.Inl ((Constraint.add c cstrs), g)
      end in
  let c := Universe.map (fun u =&gt; Universe.map (fun v =&gt; (u, v)) v) u in
  let c :=
    (|Util.List|).(CList.ExtS.cartesians) enforce_one
      (Util.Inl (Constraint.empty, g)) c in
  let order {A B C D : Set}
    (x : Util.union (Univ.Constraint.t * A) B)
    (y : Util.union (Univ.Constraint.t * C) D) : Z :=
    match (x, y) with
    | (Util.Inr _, Util.Inr _) =&gt; 0
    | (Util.Inl _, Util.Inr _) =&gt; (-1)
    | (Util.Inr _, Util.Inl _) =&gt; 1
    | (Util.Inl (c, _), Util.Inl (c', _)) =&gt;
      Int.compare (Constraint.cardinal c) (Constraint.cardinal c')
    end in
  match (|Util.List|).(CList.ExtS.min) order c with
  | Util.Inl x =&gt; x
  | Util.Inr e =&gt; Stdlib.raise e
  end.

Definition enforce_leq_alg (u : Univ.Universe.t) (v : Univ.Universe.t) (g : t)
  : Univ.Constraint.t * t :=
  let '(_, g) as cg := enforce_leq_alg u v g in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  cg.

(* ❌ The definition of exceptions is not handled. *)
(* exception AlreadyDeclared *)

Definition add_universe
  (u : Univ.Level.t) (lbound : Univ.Level.t) (strict : bool) (g : t) : t :=
  let graph := G.add None u (t.graph g) in
  let d :=
    if strict then
      Univ.Lt
    else
      Univ.Le in
  enforce_constraint (lbound, d, u) (t.with_graph g graph).

Definition add_universe_unconstrained (u : Univ.Level.t) (g : t) : t :=
  t.with_graph g (G.add None u (t.graph g)).

(* ❌ The definition of exceptions is not handled. *)
(* exception UndeclaredLevel *)

Definition check_declared_universes (g : t) (l : Univ.LSet.t) : unit :=
  G.check_declared (t.graph g) (LSet.remove Level.sprop l).

Definition constraints_of_universes (g : t)
  : Univ.Constraint.t * list Univ.LSet.t := G.constraints_of (t.graph g).

Definition constraints_for (kept : Univ.LSet.t) (g : t) : Univ.Constraint.t :=
  G.constraints_for (LSet.remove Level.sprop kept) (t.graph g).

Definition check_subtype
  (lbound : Univ.Level.t) (univs : t) (ctxT : Univ.AUContext.t)
  (ctx : Univ.AUContext.t) : bool :=
  if Stdlib.op_eqeq (AUContext.size ctxT) (AUContext.size ctx) then
    let '(inst, cst) := UContext.dest (AUContext.repr ctx) in
    let cstT := UContext.constraints (AUContext.repr ctxT) in
    let push (accu : t) (v : Univ.Level.t) : t :=
      add_universe v lbound false accu in
    let univs := Array.fold_left push univs (Instance.to_array inst) in
    let univs := merge_constraints cstT univs in
    check_constraints cst univs
  else
    false.

Definition check_eq_instances
  (g : t) (t1 : Univ.Instance.t) (t2 : Univ.Instance.t) : bool :=
  let t1 := Instance.to_array t1 in
  let t2 := Instance.to_array t2 in
  orb (Stdlib.op_eqeq t1 t2)
    (andb (Int.equal (Array.length t1) (Array.length t2))
      (let fix aux (i : Int.t) {struct i} : bool :=
        orb (Int.equal i (Array.length t1))
          (andb (check_eq_level g (Array.get t1 i) (Array.get t2 i))
            (aux (Z.add i 1))) in
      aux 0)).

Definition domain (g : t) : Univ.LSet.t :=
  LSet.add Level.sprop (G.domain (t.graph g)).

Definition choose (p : Univ.Level.t -&gt; bool) (g : t) (u : Univ.Level.t)
  : option Univ.Level.t :=
  if Level.is_sprop u then
    if p u then
      Some u
    else
      None
  else
    G.choose p (t.graph g) u.

Definition dump_universes
  (f : AcyclicGraph.constraint_type -&gt; Univ.Level.t -&gt; Univ.Level.t -&gt; unit)
  (g : t) : unit := G.dump f (t.graph g).

Definition check_universes_invariants (g : t) : unit :=
  G.check_invariants Level.is_small (t.graph g).

Definition pr_universes (prl : Univ.Level.t -&gt; Pp.t) (g : t) : Pp.t :=
  G.pr prl (t.graph g).

Definition dummy_mp : Names.DirPath.t :=
  Names.DirPath.make [ Names.Id.of_string &quot;Type&quot; ].

Definition make_dummy (i : Z) : Univ.Level.t := make (UGlobal.make dummy_mp i).

Definition sort_universes (g : t) : t :=
  g_map (G.sort make_dummy [ Level.prop; Level.set ]) g.

Definition merge_constraints : Univ.Constraint.t -&gt; t -&gt; t :=
  if Flags.profile then
    let key := CProfile.declare_profile &quot;merge_constraints&quot; in
    CProfile.profile2 key merge_constraints
  else
    merge_constraints.

Definition check_constraints : Univ.Constraint.t -&gt; t -&gt; bool :=
  if Flags.profile then
    let key := CProfile.declare_profile &quot;check_constraints&quot; in
    CProfile.profile2 key check_constraints
  else
    check_constraints.

Definition check_eq : t -&gt; Univ.Universe.t -&gt; Univ.Universe.t -&gt; bool :=
  if Flags.profile then
    let check_eq_key := CProfile.declare_profile &quot;check_eq&quot; in
    CProfile.profile3 check_eq_key check_eq
  else
    check_eq.

Definition check_leq : t -&gt; Univ.Universe.t -&gt; Univ.Universe.t -&gt; bool :=
  if Flags.profile then
    let check_leq_key := CProfile.declare_profile &quot;check_leq&quot; in
    CProfile.profile3 check_leq_key check_leq
  else
    check_leq.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="uGraph.mli">
  <div style="margin: 20px;">
    <h3>UGraph_mli</h3>
    <ul>
      <li>OCaml size: 99 lines</li>
      <li>Coq size: 69 lines (-31% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#uGraph.mli"><code>uGraph.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Univ

(** {6 Graphs of universes. } *)
type t

val make_sprop_cumulative : t -&gt; t
(** Don't use this in the kernel, it makes the system incomplete. *)

type 'a check_function = t -&gt; 'a -&gt; 'a -&gt; bool

val check_leq : Universe.t check_function
val check_eq : Universe.t check_function
val check_eq_level : Level.t check_function

(** The initial graph of universes: Prop &lt; Set *)
val initial_universes : t

(** Check equality of instances w.r.t. a universe graph *)
val check_eq_instances : Instance.t check_function

(** {6 ... } *)
(** Merge of constraints in a universes graph.
  The function [merge_constraints] merges a set of constraints in a given
  universes graph. It raises the exception [UniverseInconsistency] if the
  constraints are not satisfiable. *)

val enforce_constraint : univ_constraint -&gt; t -&gt; t
val merge_constraints : Constraint.t -&gt; t -&gt; t

val check_constraint  : t -&gt; univ_constraint -&gt; bool
val check_constraints : Constraint.t -&gt; t -&gt; bool

(** Picks an arbitrary set of constraints sufficient to ensure [u &lt;= v]. *)
val enforce_leq_alg : Universe.t -&gt; Universe.t -&gt; t -&gt; Constraint.t * t

(** Adds a universe to the graph, ensuring it is &gt;= or &gt; Set.
   @raise AlreadyDeclared if the level is already declared in the graph. *)

<abbr class="mark-warning" title="Signature item `exception` not handled">exception AlreadyDeclared</abbr>

val add_universe : Level.t -&gt; lbound:Level.t -&gt; strict:bool -&gt; t -&gt; t

(** Add a universe without (Prop,Set) &lt;= u *)
val add_universe_unconstrained : Level.t -&gt; t -&gt; t

(** Check that the universe levels are declared. Otherwise
    @raise UndeclaredLevel l for the first undeclared level found. *)
<abbr class="mark-warning" title="Signature item `exception` not handled">exception UndeclaredLevel of Univ.Level.t</abbr>

val check_declared_universes : t -&gt; Univ.LSet.t -&gt; unit

(** {6 Pretty-printing of universes. } *)

val pr_universes : (Level.t -&gt; Pp.t) -&gt; t -&gt; Pp.t

(** The empty graph of universes *)
val empty_universes : t

val sort_universes : t -&gt; t

(** [constraints_of_universes g] returns [csts] and [partition] where
   [csts] are the non-Eq constraints and [partition] is the partition
   of the universes into equivalence classes. *)
val constraints_of_universes : t -&gt; Constraint.t * LSet.t list

val choose : (Level.t -&gt; bool) -&gt; t -&gt; Level.t -&gt; Level.t option
(** [choose p g u] picks a universe verifying [p] and equal
   to [u] in [g]. *)

(** [constraints_for ~kept g] returns the constraints about the
   universes [kept] in [g] up to transitivity.

    eg if [g] is [a &lt;= b &lt;= c] then [constraints_for ~kept:{a, c} g] is [a &lt;= c]. *)
val constraints_for : kept:LSet.t -&gt; t -&gt; Constraint.t

val domain : t -&gt; LSet.t
(** Known universes *)

val check_subtype : lbound:Level.t -&gt; AUContext.t check_function
(** [check_subtype univ ctx1 ctx2] checks whether [ctx2] is an instance of
    [ctx1]. *)

(** {6 Dumping to a file } *)

val dump_universes :
  (constraint_type -&gt; Level.t -&gt; Level.t -&gt; unit) -&gt; t -&gt; unit

(** {6 Debugging} *)
val check_universes_invariants : t -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#uGraph.mli"><code>UGraph_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter t : Set.

Parameter make_sprop_cumulative : t -&gt; t.

Definition check_function (a : Set) := t -&gt; a -&gt; a -&gt; bool.

Parameter check_leq : check_function Univ.Universe.t.

Parameter check_eq : check_function Univ.Universe.t.

Parameter check_eq_level : check_function Univ.Level.t.

Parameter initial_universes : t.

Parameter check_eq_instances : check_function Univ.Instance.t.

Parameter enforce_constraint : Univ.univ_constraint -&gt; t -&gt; t.

Parameter merge_constraints : Univ.Constraint.t -&gt; t -&gt; t.

Parameter check_constraint : t -&gt; Univ.univ_constraint -&gt; bool.

Parameter check_constraints : Univ.Constraint.t -&gt; t -&gt; bool.

Parameter enforce_leq_alg :
  Univ.Universe.t -&gt; Univ.Universe.t -&gt; t -&gt; Univ.Constraint.t * t.

(* exception AlreadyDeclared *)

Parameter add_universe : Univ.Level.t -&gt; Univ.Level.t -&gt; bool -&gt; t -&gt; t.

Parameter add_universe_unconstrained : Univ.Level.t -&gt; t -&gt; t.

(* exception UndeclaredLevel *)

Parameter check_declared_universes : t -&gt; Univ.LSet.t -&gt; unit.

Parameter pr_universes : (Univ.Level.t -&gt; Pp.t) -&gt; t -&gt; Pp.t.

Parameter empty_universes : t.

Parameter sort_universes : t -&gt; t.

Parameter constraints_of_universes : t -&gt; Univ.Constraint.t * list Univ.LSet.t.

Parameter choose :
  (Univ.Level.t -&gt; bool) -&gt; t -&gt; Univ.Level.t -&gt; option Univ.Level.t.

Parameter constraints_for : Univ.LSet.t -&gt; t -&gt; Univ.Constraint.t.

Parameter domain : t -&gt; Univ.LSet.t.

Parameter check_subtype : Univ.Level.t -&gt; check_function Univ.AUContext.t.

Parameter dump_universes :
  (Univ.constraint_type -&gt; Univ.Level.t -&gt; Univ.Level.t -&gt; unit) -&gt; t -&gt; unit.

Parameter check_universes_invariants : t -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="uint63.ml">
  <div style="margin: 20px;">
    <h3>Uint63</h3>
    <ul>
      <li>OCaml size: 229 lines</li>
      <li>Coq size: 249 lines (+8% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#uint63.ml"><code>uint63.ml</code></a>&nbsp;<span class="label label-warning">16 warnings</span>
    
    <pre>(* DO NOT EDIT THIS FILE: automatically generated by ./write_uint63.ml *)
(* see uint63_amd64.ml and uint63_x86.ml *)
(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t = int

let _ = assert (Sys.word_size = 64)

let uint_size = 63

let maxuint63 = Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;
let maxuint31 = 0x7FFFFFFF

    (* conversion from an int *)
let to_uint64 i = Int64.logand (Int64.of_int i) maxuint63

let of_int i = i
[@@ocaml.inline always]

let to_int2 i = (0,i)

let of_int64 _i = <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let hash i = i
[@@ocaml.inline always]

    (* conversion of an uint63 to a string *)
let to_string i = Int64.to_string (to_uint64 i)

let of_string s =
  let i64 = Int64.of_string s in
  if Int64.compare Int64.zero i64 &lt;= 0
      &amp;&amp; Int64.compare i64 maxuint63 &lt;= 0
  then Int64.to_int i64
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">(Failure &quot;Int64.of_string&quot;)</abbr>

(* Compiles an unsigned int to OCaml code *)
let compile i = Printf.sprintf &quot;Uint63.of_int (%i)&quot; i

let zero = 0
let one = 1

    (* logical shift *)
let l_sl x y =
  if 0 &lt;= y &amp;&amp; y &lt; 63 then x lsl y else 0

let l_sr x y =
  if 0 &lt;= y &amp;&amp; y &lt; 63 then x lsr y else 0

let l_and x y = x land y
[@@ocaml.inline always]

let l_or x y = x lor y
[@@ocaml.inline always]

let l_xor x y = x lxor y
[@@ocaml.inline always]

    (* addition of int63 *)
let add x y = x + y
[@@ocaml.inline always]

    (* subtraction *)
let sub x y = x - y
[@@ocaml.inline always]

    (* multiplication *)
let mul x y = x * y
[@@ocaml.inline always]

    (* division *)
let div (x : int) (y : int) =
  if y = 0 then 0 else Int64.to_int (Int64.div (to_uint64 x) (to_uint64 y))

    (* modulo *)
let rem (x : int) (y : int) =
  if y = 0 then 0 else Int64.to_int (Int64.rem (to_uint64 x) (to_uint64 y))

let diveucl x y = (div x y, rem x y)

let addmuldiv p x y =
  l_or (l_sl x p) (l_sr y (uint_size - p))

    (* comparison *)
let lt (x : int) (y : int) =
  (x lxor 0x4000000000000000) &lt; (y lxor 0x4000000000000000)
[@@ocaml.inline always]

let le (x : int) (y : int) =
  (x lxor 0x4000000000000000) &lt;= (y lxor 0x4000000000000000)
[@@ocaml.inline always]

    (* division of two numbers by one *)
(* precondition: xh &lt; y *)
(* outputs: q, r s.t. x = q * y + r, r &lt; y *)
let div21 xh xl y =
  (* nh might temporarily grow as large as 2*y - 1 in the loop body,
     so we store it as a 64-bit unsigned integer *)
  let nh = ref xh in
  let nl = ref xl in
  let q = ref 0 in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for _i = 0 to 62 do
    (* invariants: 0 &lt;= nh &lt; y, nl = (xl*2^i) % 2^63,
       (q*y + nh) * 2^(63-i) + (xl % 2^(63-i)) = (xh%y) * 2^63 + xl *)
    nh := Int64.logor (Int64.shift_left !nh 1) (Int64.of_int (!nl lsr 62));
    nl := !nl lsl 1;
    q := !q lsl 1;
    (* TODO: use &quot;Int64.unsigned_compare !nh y &gt;= 0&quot;,
       once OCaml 4.08 becomes the minimal required version *)
    if Int64.compare !nh 0L &lt; 0 || Int64.compare !nh y &gt;= 0 then
      begin q := !q lor 1; nh := Int64.sub !nh y; end
  done;
  !q, Int64.to_int !nh</abbr>

let div21 xh xl y =
  let xh = to_uint64 xh in
  let y = to_uint64 y in
  if Int64.compare y xh &lt;= 0 then 0, 0 else div21 xh xl y

     (* exact multiplication *)
(* TODO: check that none of these additions could be a logical or *)


(* size = 32 + 31
   (hx &lt;&lt; 31 + lx) * (hy &lt;&lt; 31 + ly) =
   hxhy &lt;&lt; 62 + (hxly + lxhy) &lt;&lt; 31 + lxly
*)

(* precondition : (x lsr 62 = 0 || y lsr 62 = 0) *)
let mulc_aux x y =
  let lx = x land maxuint31 in
  let ly = y land maxuint31 in
  let hx = x lsr 31  in
  let hy = y lsr 31 in
    (* hx and hy are 32 bits value but at most one is 32 *)
  let hxy  = hx * hy in (* 63 bits *)
  let hxly = hx * ly in (* 63 bits *)
  let lxhy = lx * hy in (* 63 bits *)
  let lxy  = lx * ly in (* 62 bits *)
  let l  = lxy lor (hxy lsl 62) (* 63 bits *) in
  let h  = hxy lsr 1 in (* 62 bits *)
  let hl = hxly + lxhy in (* We can have a carry *)
  let h  = if lt hl hxly then h + (1 lsl 31) else h in
  let hl'= hl lsl 31 in
  let l  = l + hl' in
  let h  = if lt l hl' then h + 1 else h in
  let h  = h + (hl lsr 32) in
  (h,l)

let mulc x y =
  if (x lsr 62 = 0 || y lsr 62 = 0) then mulc_aux x y
  else
    let yl = y lxor (1 lsl 62) in
    let (h,l) = mulc_aux x yl in
    (* h &lt;&lt; 63 + l = x * yl
       x * y = x * (1 &lt;&lt; 62 + yl)  =
       x &lt;&lt; 62 + x*yl = x &lt;&lt; 62 + h &lt;&lt; 63 + l *)
    let l' = l + (x lsl 62) in
    let h = if lt l' l then h + 1 else h in
    (h + (x lsr 1), l')

let equal (x : int) (y : int) = x = y
[@@ocaml.inline always]

let compare (x:int) (y:int) =
  let x = x lxor 0x4000000000000000 in
  let y = y lxor 0x4000000000000000 in
  if x &gt; y then 1
  else if y &gt; x then -1
  else 0

    (* head tail *)

let head0 x =
  let r = ref 0 in
  let x = ref x in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x7FFFFFFF00000000 = 0 then r := !r + 31
  else x := !x lsr 31;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFFFF0000 = 0 then (x := !x lsl 16; r := !r + 16);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFF000000 = 0 then (x := !x lsl 8; r := !r + 8);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xF0000000 = 0 then (x := !x lsl 4; r := !r + 4);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xC0000000 = 0 then (x := !x lsl 2; r := !r + 2);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x80000000 = 0 then (x := !x lsl 1; r := !r + 1);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x80000000 = 0 then (               r := !r + 1);
  !r</abbr>;;

let tail0 x =
  let r = ref 0 in
  let x = ref x in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFFFFFFFF = 0 then (x := !x lsr 32; r := !r + 32);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFFFF = 0 then (x := !x lsr 16; r := !r + 16);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFF = 0   then (x := !x lsr 8;  r := !r + 8);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xF = 0    then (x := !x lsr 4;  r := !r + 4);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x3 = 0    then (x := !x lsr 2;  r := !r + 2);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x1 = 0    then (                r := !r + 1);
  !r</abbr>

let is_uint63 t =
  Obj.is_int t
[@@ocaml.inline always]

(* Arithmetic with explicit carries *)

(* Analog of Numbers.Abstract.Cyclic.carry *)
type 'a carry = C0 of 'a | C1 of 'a

let addc x y =
  let r = x + y in
  if lt r x then C1 r else C0 r

let addcarryc x y =
  let r = x + y + 1 in
  if le r x then C1 r else C0 r

let subc x y =
  let r = x - y in
  if le y x then C0 r else C1 r

let subcarryc x y =
  let r = x - y - 1 in
  if lt y x then C0 r else C1 r
</pre>
  </div>
  <div class="col-md-6">
    <a href="#uint63.ml"><code>Uint63.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition t := Z.



Definition uint_size : Z := 63.

Definition maxuint63 : int64 := Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;.

Definition maxuint31 : Z := 2147483647.

Definition to_uint64 (i : Z) : int64 := Int64.logand (Int64.of_int i) maxuint63.

Definition of_int {A : Set} (i : A) : A := i.

Definition to_int2 {A : Set} (i : A) : Z * A := (0, i).

Definition of_int64 {A B : Set} (_i : A) : B :=
  (* ❌ Assert instruction is not handled. *)
  assert false.

Definition hash {A : Set} (i : A) : A := i.

Definition to_string (i : Z) : string := Int64.to_string (to_uint64 i).

Definition of_string (s : string) : Z :=
  let i64 := Int64.of_string s in
  if
    andb (OCaml.Stdlib.le (Int64.compare Int64.zero i64) 0)
      (OCaml.Stdlib.le (Int64.compare i64 maxuint63) 0) then
    Int64.to_int i64
  else
    Stdlib.raise extensible_type_value.

Definition compile (i : Z) : string :=
  Printf.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;Uint63.of_int (&quot;
        (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
            CamlinternalFormatBasics.End_of_format))) &quot;Uint63.of_int (%i)&quot;) i.

Definition zero : Z := 0.

Definition one : Z := 1.

Definition l_sl (x : Z) (y : Z) : Z :=
  if andb (OCaml.Stdlib.le 0 y) (OCaml.Stdlib.lt y 63) then
    Z.shiftl x y
  else
    0.

Definition l_sr (x : Z) (y : Z) : Z :=
  if andb (OCaml.Stdlib.le 0 y) (OCaml.Stdlib.lt y 63) then
    Z.shiftr x y
  else
    0.

Definition l_and (x : Z) (y : Z) : Z := Z.land x y.

Definition l_or (x : Z) (y : Z) : Z := Z.lor x y.

Definition l_xor (x : Z) (y : Z) : Z := Z.lxor x y.

Definition add (x : Z) (y : Z) : Z := Z.add x y.

Definition sub (x : Z) (y : Z) : Z := Z.sub x y.

Definition mul (x : Z) (y : Z) : Z := Z.mul x y.

Definition div (x : Z) (y : Z) : Z :=
  if equiv_decb y 0 then
    0
  else
    Int64.to_int (Int64.div (to_uint64 x) (to_uint64 y)).

Definition rem (x : Z) (y : Z) : Z :=
  if equiv_decb y 0 then
    0
  else
    Int64.to_int (Int64.rem (to_uint64 x) (to_uint64 y)).

Definition diveucl (x : Z) (y : Z) : Z * Z := ((div x y), (rem x y)).

Definition addmuldiv (p : Z) (x : Z) (y : Z) : Z :=
  l_or (l_sl x p) (l_sr y (Z.sub uint_size p)).

Definition lt (x : Z) (y : Z) : bool :=
  OCaml.Stdlib.lt (Z.lxor x (-4611686018427387904))
    (Z.lxor y (-4611686018427387904)).

Definition le (x : Z) (y : Z) : bool :=
  OCaml.Stdlib.le (Z.lxor x (-4611686018427387904))
    (Z.lxor y (-4611686018427387904)).

Definition div21 (xh : Stdlib.Int64.t) (xl : Z) (y : Stdlib.Int64.t) : Z * Z :=
  let nh := Stdlib.__ref_value xh in
  let nl := Stdlib.__ref_value xl in
  let q := Stdlib.__ref_value 0 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  ((Stdlib.op_exclamation q), (Int64.to_int (Stdlib.op_exclamation nh))).

Definition div21 (xh : Z) (xl : Z) (y : Z) : Z * Z :=
  let xh := to_uint64 xh in
  let y := to_uint64 y in
  if OCaml.Stdlib.le (Int64.compare y xh) 0 then
    (0, 0)
  else
    div21 xh xl y.

Definition mulc_aux (x : Z) (y : Z) : Z * Z :=
  let lx := Z.land x maxuint31 in
  let ly := Z.land y maxuint31 in
  let hx := Z.shiftr x 31 in
  let hy := Z.shiftr y 31 in
  let hxy := Z.mul hx hy in
  let hxly := Z.mul hx ly in
  let lxhy := Z.mul lx hy in
  let lxy := Z.mul lx ly in
  let l := Z.lor lxy (Z.shiftl hxy 62) in
  let h := Z.shiftr hxy 1 in
  let hl := Z.add hxly lxhy in
  let h :=
    if lt hl hxly then
      Z.add h (Z.shiftl 1 31)
    else
      h in
  let hl' := Z.shiftl hl 31 in
  let l := Z.add l hl' in
  let h :=
    if lt l hl' then
      Z.add h 1
    else
      h in
  let h := Z.add h (Z.shiftr hl 32) in
  (h, l).

Definition mulc (x : Z) (y : Z) : Z * Z :=
  if orb (equiv_decb (Z.shiftr x 62) 0) (equiv_decb (Z.shiftr y 62) 0) then
    mulc_aux x y
  else
    let yl := Z.lxor y (Z.shiftl 1 62) in
    let '(h, l) := mulc_aux x yl in
    let l' := Z.add l (Z.shiftl x 62) in
    let h :=
      if lt l' l then
        Z.add h 1
      else
        h in
    ((Z.add h (Z.shiftr x 1)), l').

Definition equal (x : Z) (y : Z) : bool := equiv_decb x y.

Definition compare (x : Z) (y : Z) : Z :=
  let x := Z.lxor x (-4611686018427387904) in
  let y := Z.lxor y (-4611686018427387904) in
  if OCaml.Stdlib.gt x y then
    1
  else
    if OCaml.Stdlib.gt y x then
      (-1)
    else
      0.

Definition head0 (x : Z) : Z :=
  let r := Stdlib.__ref_value 0 in
  let x := Stdlib.__ref_value x in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.op_exclamation r.

Definition tail0 (x : Z) : Z :=
  let r := Stdlib.__ref_value 0 in
  let x := Stdlib.__ref_value x in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.op_exclamation r.

Definition is_uint63 (t : Stdlib.Obj.t) : bool := Obj.is_int t.

Inductive carry (a : Set) : Set :=
| C0 : a -&gt; carry a
| C1 : a -&gt; carry a.

Arguments C0 {_}.
Arguments C1 {_}.

Definition addc (x : Z) (y : Z) : carry Z :=
  let r := Z.add x y in
  if lt r x then
    C1 r
  else
    C0 r.

Definition addcarryc (x : Z) (y : Z) : carry Z :=
  let r := Z.add (Z.add x y) 1 in
  if le r x then
    C1 r
  else
    C0 r.

Definition subc (x : Z) (y : Z) : carry Z :=
  let r := Z.sub x y in
  if le y x then
    C0 r
  else
    C1 r.

Definition subcarryc (x : Z) (y : Z) : carry Z :=
  let r := Z.sub (Z.sub x y) 1 in
  if lt y x then
    C0 r
  else
    C1 r.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="uint63.mli">
  <div style="margin: 20px;">
    <h3>Uint63_mli</h3>
    <ul>
      <li>OCaml size: 71 lines</li>
      <li>Coq size: 91 lines (+28% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#uint63.mli"><code>uint63.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>type t

val uint_size : int
val maxuint31 : t

      (* conversion to int *)
val of_int : int -&gt; t
val to_int2 : t -&gt; int * int (* msb, lsb *)
val of_int64 : Int64.t -&gt; t
(*
val of_uint : int -&gt; t
*)

val hash : t -&gt; int

     (* conversion to a string *)
val to_string : t -&gt; string
val of_string : string -&gt; t

val compile : t -&gt; string

(* constants *)
val zero    : t
val one : t

      (* logical operations *)
val l_sl    : t -&gt; t -&gt; t
val l_sr    : t -&gt; t -&gt; t
val l_and   : t -&gt; t -&gt; t
val l_xor   : t -&gt; t -&gt; t
val l_or    : t -&gt; t -&gt; t

      (* Arithmetic operations *)
val add     : t -&gt; t -&gt; t
val sub     : t -&gt; t -&gt; t
val mul     : t -&gt; t -&gt; t
val div     : t -&gt; t -&gt; t
val rem     : t -&gt; t -&gt; t

val diveucl : t -&gt; t -&gt; t * t

      (* Specific arithmetic operations *)
val mulc    : t -&gt; t -&gt; t * t
val addmuldiv : t -&gt; t -&gt; t -&gt; t

(** [div21 xh xl y] returns [q % 2^63, r]
    s.t. [xh * 2^63 + xl = q * y + r] and [r &lt; y].
    When [y] is [0], returns [0, 0]. *)
val div21   : t -&gt; t -&gt; t -&gt; t * t

      (* comparison *)
val lt      : t -&gt; t -&gt; bool
val equal      : t -&gt; t -&gt; bool
val le      : t -&gt; t -&gt; bool
val compare : t -&gt; t -&gt; int

      (* head and tail *)
val head0   : t -&gt; t
val tail0   : t -&gt; t

val is_uint63 : Obj.t -&gt; bool

(* Arithmetic with explicit carries *)

(* Analog of Numbers.Abstract.Cyclic.carry *)
type 'a carry = C0 of 'a | C1 of 'a

val addc : t -&gt; t -&gt; t carry
val addcarryc : t -&gt; t -&gt; t carry
val subc : t -&gt; t -&gt; t carry
val subcarryc : t -&gt; t -&gt; t carry
</pre>
  </div>
  <div class="col-md-6">
    <a href="#uint63.mli"><code>Uint63_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter t : Set.

Parameter uint_size : Z.

Parameter maxuint31 : t.

Parameter of_int : Z -&gt; t.

Parameter to_int2 : t -&gt; Z * Z.

Parameter of_int64 : Stdlib.Int64.t -&gt; t.

Parameter hash : t -&gt; Z.

Parameter to_string : t -&gt; string.

Parameter of_string : string -&gt; t.

Parameter compile : t -&gt; string.

Parameter zero : t.

Parameter one : t.

Parameter l_sl : t -&gt; t -&gt; t.

Parameter l_sr : t -&gt; t -&gt; t.

Parameter l_and : t -&gt; t -&gt; t.

Parameter l_xor : t -&gt; t -&gt; t.

Parameter l_or : t -&gt; t -&gt; t.

Parameter add : t -&gt; t -&gt; t.

Parameter sub : t -&gt; t -&gt; t.

Parameter mul : t -&gt; t -&gt; t.

Parameter div : t -&gt; t -&gt; t.

Parameter rem : t -&gt; t -&gt; t.

Parameter diveucl : t -&gt; t -&gt; t * t.

Parameter mulc : t -&gt; t -&gt; t * t.

Parameter addmuldiv : t -&gt; t -&gt; t -&gt; t.

Parameter div21 : t -&gt; t -&gt; t -&gt; t * t.

Parameter lt : t -&gt; t -&gt; bool.

Parameter equal : t -&gt; t -&gt; bool.

Parameter le : t -&gt; t -&gt; bool.

Parameter compare : t -&gt; t -&gt; Z.

Parameter head0 : t -&gt; t.

Parameter tail0 : t -&gt; t.

Parameter is_uint63 : Stdlib.Obj.t -&gt; bool.

Inductive carry (a : Set) : Set :=
| C0 : a -&gt; carry a
| C1 : a -&gt; carry a.

Arguments C0 {_}.
Arguments C1 {_}.

Parameter addc : t -&gt; t -&gt; carry t.

Parameter addcarryc : t -&gt; t -&gt; carry t.

Parameter subc : t -&gt; t -&gt; carry t.

Parameter subcarryc : t -&gt; t -&gt; carry t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="uint63_amd64.ml">
  <div style="margin: 20px;">
    <h3>Uint63_amd64</h3>
    <ul>
      <li>OCaml size: 227 lines</li>
      <li>Coq size: 249 lines (+9% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#uint63_amd64.ml"><code>uint63_amd64.ml</code></a>&nbsp;<span class="label label-warning">16 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

type t = int

let _ = assert (Sys.word_size = 64)

let uint_size = 63

let maxuint63 = Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;
let maxuint31 = 0x7FFFFFFF

    (* conversion from an int *)
let to_uint64 i = Int64.logand (Int64.of_int i) maxuint63

let of_int i = i
[@@ocaml.inline always]

let to_int2 i = (0,i)

let of_int64 _i = <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let hash i = i
[@@ocaml.inline always]

    (* conversion of an uint63 to a string *)
let to_string i = Int64.to_string (to_uint64 i)

let of_string s =
  let i64 = Int64.of_string s in
  if Int64.compare Int64.zero i64 &lt;= 0
      &amp;&amp; Int64.compare i64 maxuint63 &lt;= 0
  then Int64.to_int i64
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">(Failure &quot;Int64.of_string&quot;)</abbr>

(* Compiles an unsigned int to OCaml code *)
let compile i = Printf.sprintf &quot;Uint63.of_int (%i)&quot; i

let zero = 0
let one = 1

    (* logical shift *)
let l_sl x y =
  if 0 &lt;= y &amp;&amp; y &lt; 63 then x lsl y else 0

let l_sr x y =
  if 0 &lt;= y &amp;&amp; y &lt; 63 then x lsr y else 0

let l_and x y = x land y
[@@ocaml.inline always]

let l_or x y = x lor y
[@@ocaml.inline always]

let l_xor x y = x lxor y
[@@ocaml.inline always]

    (* addition of int63 *)
let add x y = x + y
[@@ocaml.inline always]

    (* subtraction *)
let sub x y = x - y
[@@ocaml.inline always]

    (* multiplication *)
let mul x y = x * y
[@@ocaml.inline always]

    (* division *)
let div (x : int) (y : int) =
  if y = 0 then 0 else Int64.to_int (Int64.div (to_uint64 x) (to_uint64 y))

    (* modulo *)
let rem (x : int) (y : int) =
  if y = 0 then 0 else Int64.to_int (Int64.rem (to_uint64 x) (to_uint64 y))

let diveucl x y = (div x y, rem x y)

let addmuldiv p x y =
  l_or (l_sl x p) (l_sr y (uint_size - p))

    (* comparison *)
let lt (x : int) (y : int) =
  (x lxor 0x4000000000000000) &lt; (y lxor 0x4000000000000000)
[@@ocaml.inline always]

let le (x : int) (y : int) =
  (x lxor 0x4000000000000000) &lt;= (y lxor 0x4000000000000000)
[@@ocaml.inline always]

    (* division of two numbers by one *)
(* precondition: xh &lt; y *)
(* outputs: q, r s.t. x = q * y + r, r &lt; y *)
let div21 xh xl y =
  (* nh might temporarily grow as large as 2*y - 1 in the loop body,
     so we store it as a 64-bit unsigned integer *)
  let nh = ref xh in
  let nl = ref xl in
  let q = ref 0 in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for _i = 0 to 62 do
    (* invariants: 0 &lt;= nh &lt; y, nl = (xl*2^i) % 2^63,
       (q*y + nh) * 2^(63-i) + (xl % 2^(63-i)) = (xh%y) * 2^63 + xl *)
    nh := Int64.logor (Int64.shift_left !nh 1) (Int64.of_int (!nl lsr 62));
    nl := !nl lsl 1;
    q := !q lsl 1;
    (* TODO: use &quot;Int64.unsigned_compare !nh y &gt;= 0&quot;,
       once OCaml 4.08 becomes the minimal required version *)
    if Int64.compare !nh 0L &lt; 0 || Int64.compare !nh y &gt;= 0 then
      begin q := !q lor 1; nh := Int64.sub !nh y; end
  done;
  !q, Int64.to_int !nh</abbr>

let div21 xh xl y =
  let xh = to_uint64 xh in
  let y = to_uint64 y in
  if Int64.compare y xh &lt;= 0 then 0, 0 else div21 xh xl y

     (* exact multiplication *)
(* TODO: check that none of these additions could be a logical or *)


(* size = 32 + 31
   (hx &lt;&lt; 31 + lx) * (hy &lt;&lt; 31 + ly) =
   hxhy &lt;&lt; 62 + (hxly + lxhy) &lt;&lt; 31 + lxly
*)

(* precondition : (x lsr 62 = 0 || y lsr 62 = 0) *)
let mulc_aux x y =
  let lx = x land maxuint31 in
  let ly = y land maxuint31 in
  let hx = x lsr 31  in
  let hy = y lsr 31 in
    (* hx and hy are 32 bits value but at most one is 32 *)
  let hxy  = hx * hy in (* 63 bits *)
  let hxly = hx * ly in (* 63 bits *)
  let lxhy = lx * hy in (* 63 bits *)
  let lxy  = lx * ly in (* 62 bits *)
  let l  = lxy lor (hxy lsl 62) (* 63 bits *) in
  let h  = hxy lsr 1 in (* 62 bits *)
  let hl = hxly + lxhy in (* We can have a carry *)
  let h  = if lt hl hxly then h + (1 lsl 31) else h in
  let hl'= hl lsl 31 in
  let l  = l + hl' in
  let h  = if lt l hl' then h + 1 else h in
  let h  = h + (hl lsr 32) in
  (h,l)

let mulc x y =
  if (x lsr 62 = 0 || y lsr 62 = 0) then mulc_aux x y
  else
    let yl = y lxor (1 lsl 62) in
    let (h,l) = mulc_aux x yl in
    (* h &lt;&lt; 63 + l = x * yl
       x * y = x * (1 &lt;&lt; 62 + yl)  =
       x &lt;&lt; 62 + x*yl = x &lt;&lt; 62 + h &lt;&lt; 63 + l *)
    let l' = l + (x lsl 62) in
    let h = if lt l' l then h + 1 else h in
    (h + (x lsr 1), l')

let equal (x : int) (y : int) = x = y
[@@ocaml.inline always]

let compare (x:int) (y:int) =
  let x = x lxor 0x4000000000000000 in
  let y = y lxor 0x4000000000000000 in
  if x &gt; y then 1
  else if y &gt; x then -1
  else 0

    (* head tail *)

let head0 x =
  let r = ref 0 in
  let x = ref x in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x7FFFFFFF00000000 = 0 then r := !r + 31
  else x := !x lsr 31;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFFFF0000 = 0 then (x := !x lsl 16; r := !r + 16);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFF000000 = 0 then (x := !x lsl 8; r := !r + 8);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xF0000000 = 0 then (x := !x lsl 4; r := !r + 4);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xC0000000 = 0 then (x := !x lsl 2; r := !r + 2);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x80000000 = 0 then (x := !x lsl 1; r := !r + 1);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x80000000 = 0 then (               r := !r + 1);
  !r</abbr>;;

let tail0 x =
  let r = ref 0 in
  let x = ref x in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFFFFFFFF = 0 then (x := !x lsr 32; r := !r + 32);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFFFF = 0 then (x := !x lsr 16; r := !r + 16);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xFF = 0   then (x := !x lsr 8;  r := !r + 8);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0xF = 0    then (x := !x lsr 4;  r := !r + 4);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x3 = 0    then (x := !x lsr 2;  r := !r + 2);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if !x land 0x1 = 0    then (                r := !r + 1);
  !r</abbr>

let is_uint63 t =
  Obj.is_int t
[@@ocaml.inline always]

(* Arithmetic with explicit carries *)

(* Analog of Numbers.Abstract.Cyclic.carry *)
type 'a carry = C0 of 'a | C1 of 'a

let addc x y =
  let r = x + y in
  if lt r x then C1 r else C0 r

let addcarryc x y =
  let r = x + y + 1 in
  if le r x then C1 r else C0 r

let subc x y =
  let r = x - y in
  if le y x then C0 r else C1 r

let subcarryc x y =
  let r = x - y - 1 in
  if lt y x then C0 r else C1 r
</pre>
  </div>
  <div class="col-md-6">
    <a href="#uint63_amd64.ml"><code>Uint63_amd64.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition t := Z.



Definition uint_size : Z := 63.

Definition maxuint63 : int64 := Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;.

Definition maxuint31 : Z := 2147483647.

Definition to_uint64 (i : Z) : int64 := Int64.logand (Int64.of_int i) maxuint63.

Definition of_int {A : Set} (i : A) : A := i.

Definition to_int2 {A : Set} (i : A) : Z * A := (0, i).

Definition of_int64 {A B : Set} (_i : A) : B :=
  (* ❌ Assert instruction is not handled. *)
  assert false.

Definition hash {A : Set} (i : A) : A := i.

Definition to_string (i : Z) : string := Int64.to_string (to_uint64 i).

Definition of_string (s : string) : Z :=
  let i64 := Int64.of_string s in
  if
    andb (OCaml.Stdlib.le (Int64.compare Int64.zero i64) 0)
      (OCaml.Stdlib.le (Int64.compare i64 maxuint63) 0) then
    Int64.to_int i64
  else
    Stdlib.raise extensible_type_value.

Definition compile (i : Z) : string :=
  Printf.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;Uint63.of_int (&quot;
        (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
            CamlinternalFormatBasics.End_of_format))) &quot;Uint63.of_int (%i)&quot;) i.

Definition zero : Z := 0.

Definition one : Z := 1.

Definition l_sl (x : Z) (y : Z) : Z :=
  if andb (OCaml.Stdlib.le 0 y) (OCaml.Stdlib.lt y 63) then
    Z.shiftl x y
  else
    0.

Definition l_sr (x : Z) (y : Z) : Z :=
  if andb (OCaml.Stdlib.le 0 y) (OCaml.Stdlib.lt y 63) then
    Z.shiftr x y
  else
    0.

Definition l_and (x : Z) (y : Z) : Z := Z.land x y.

Definition l_or (x : Z) (y : Z) : Z := Z.lor x y.

Definition l_xor (x : Z) (y : Z) : Z := Z.lxor x y.

Definition add (x : Z) (y : Z) : Z := Z.add x y.

Definition sub (x : Z) (y : Z) : Z := Z.sub x y.

Definition mul (x : Z) (y : Z) : Z := Z.mul x y.

Definition div (x : Z) (y : Z) : Z :=
  if equiv_decb y 0 then
    0
  else
    Int64.to_int (Int64.div (to_uint64 x) (to_uint64 y)).

Definition rem (x : Z) (y : Z) : Z :=
  if equiv_decb y 0 then
    0
  else
    Int64.to_int (Int64.rem (to_uint64 x) (to_uint64 y)).

Definition diveucl (x : Z) (y : Z) : Z * Z := ((div x y), (rem x y)).

Definition addmuldiv (p : Z) (x : Z) (y : Z) : Z :=
  l_or (l_sl x p) (l_sr y (Z.sub uint_size p)).

Definition lt (x : Z) (y : Z) : bool :=
  OCaml.Stdlib.lt (Z.lxor x (-4611686018427387904))
    (Z.lxor y (-4611686018427387904)).

Definition le (x : Z) (y : Z) : bool :=
  OCaml.Stdlib.le (Z.lxor x (-4611686018427387904))
    (Z.lxor y (-4611686018427387904)).

Definition div21 (xh : Stdlib.Int64.t) (xl : Z) (y : Stdlib.Int64.t) : Z * Z :=
  let nh := Stdlib.__ref_value xh in
  let nl := Stdlib.__ref_value xl in
  let q := Stdlib.__ref_value 0 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  ((Stdlib.op_exclamation q), (Int64.to_int (Stdlib.op_exclamation nh))).

Definition div21 (xh : Z) (xl : Z) (y : Z) : Z * Z :=
  let xh := to_uint64 xh in
  let y := to_uint64 y in
  if OCaml.Stdlib.le (Int64.compare y xh) 0 then
    (0, 0)
  else
    div21 xh xl y.

Definition mulc_aux (x : Z) (y : Z) : Z * Z :=
  let lx := Z.land x maxuint31 in
  let ly := Z.land y maxuint31 in
  let hx := Z.shiftr x 31 in
  let hy := Z.shiftr y 31 in
  let hxy := Z.mul hx hy in
  let hxly := Z.mul hx ly in
  let lxhy := Z.mul lx hy in
  let lxy := Z.mul lx ly in
  let l := Z.lor lxy (Z.shiftl hxy 62) in
  let h := Z.shiftr hxy 1 in
  let hl := Z.add hxly lxhy in
  let h :=
    if lt hl hxly then
      Z.add h (Z.shiftl 1 31)
    else
      h in
  let hl' := Z.shiftl hl 31 in
  let l := Z.add l hl' in
  let h :=
    if lt l hl' then
      Z.add h 1
    else
      h in
  let h := Z.add h (Z.shiftr hl 32) in
  (h, l).

Definition mulc (x : Z) (y : Z) : Z * Z :=
  if orb (equiv_decb (Z.shiftr x 62) 0) (equiv_decb (Z.shiftr y 62) 0) then
    mulc_aux x y
  else
    let yl := Z.lxor y (Z.shiftl 1 62) in
    let '(h, l) := mulc_aux x yl in
    let l' := Z.add l (Z.shiftl x 62) in
    let h :=
      if lt l' l then
        Z.add h 1
      else
        h in
    ((Z.add h (Z.shiftr x 1)), l').

Definition equal (x : Z) (y : Z) : bool := equiv_decb x y.

Definition compare (x : Z) (y : Z) : Z :=
  let x := Z.lxor x (-4611686018427387904) in
  let y := Z.lxor y (-4611686018427387904) in
  if OCaml.Stdlib.gt x y then
    1
  else
    if OCaml.Stdlib.gt y x then
      (-1)
    else
      0.

Definition head0 (x : Z) : Z :=
  let r := Stdlib.__ref_value 0 in
  let x := Stdlib.__ref_value x in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.op_exclamation r.

Definition tail0 (x : Z) : Z :=
  let r := Stdlib.__ref_value 0 in
  let x := Stdlib.__ref_value x in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Stdlib.op_exclamation r.

Definition is_uint63 (t : Stdlib.Obj.t) : bool := Obj.is_int t.

Inductive carry (a : Set) : Set :=
| C0 : a -&gt; carry a
| C1 : a -&gt; carry a.

Arguments C0 {_}.
Arguments C1 {_}.

Definition addc (x : Z) (y : Z) : carry Z :=
  let r := Z.add x y in
  if lt r x then
    C1 r
  else
    C0 r.

Definition addcarryc (x : Z) (y : Z) : carry Z :=
  let r := Z.add (Z.add x y) 1 in
  if le r x then
    C1 r
  else
    C0 r.

Definition subc (x : Z) (y : Z) : carry Z :=
  let r := Z.sub x y in
  if le y x then
    C0 r
  else
    C1 r.

Definition subcarryc (x : Z) (y : Z) : carry Z :=
  let r := Z.sub (Z.sub x y) 1 in
  if lt y x then
    C0 r
  else
    C1 r.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="uint63_x86.ml">
  <div style="margin: 20px;">
    <h3>Uint63_x86</h3>
    <ul>
      <li>OCaml size: 216 lines</li>
      <li>Coq size: 273 lines (+26% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#uint63_x86.ml"><code>uint63_x86.ml</code></a>&nbsp;<span class="label label-warning">24 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Invariant: the msb should be 0 *)
type t = Int64.t

let _ = assert (Sys.word_size = 32)

let uint_size = 63

let maxuint63 = Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;
let maxuint31 = Int64.of_string &quot;0x7FFFFFFF&quot;

let zero = Int64.zero
let one = Int64.one

    (* conversion from an int *)
let mask63 i = Int64.logand i maxuint63
let of_int i = Int64.of_int i
let to_int2 i = (Int64.to_int (Int64.shift_right_logical i 31), Int64.to_int i)
let of_int64 i = i
let hash i =
  let (h,l) = to_int2 i in
  (*Hashset.combine h l*)
  h * 65599 + l

    (* conversion of an uint63 to a string *)
let to_string i = Int64.to_string i

let of_string s =
  let i64 = Int64.of_string s in
  if Int64.compare Int64.zero i64 &lt;= 0
      &amp;&amp; Int64.compare i64 maxuint63 &lt;= 0
  then i64
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">(Failure &quot;Int63.of_string&quot;)</abbr>

(* Compiles an unsigned int to OCaml code *)
let compile i = Printf.sprintf &quot;Uint63.of_int64 (%LiL)&quot; i

    (* comparison *)
let lt x y =
  Int64.compare x y &lt; 0

let le x y =
  Int64.compare x y &lt;= 0

    (* logical shift *)
let l_sl x y =
  if le 0L y &amp;&amp; lt y 63L then mask63 (Int64.shift_left x (Int64.to_int y)) else 0L

let l_sr x y =
  if le 0L y &amp;&amp; lt y 63L then Int64.shift_right x (Int64.to_int y) else 0L

let l_and x y = Int64.logand x y
let l_or x y = Int64.logor x y
let l_xor x y = Int64.logxor x y

    (* addition of int63 *)
let add x y = mask63 (Int64.add x y)

let addcarry x y = add (add x y) Int64.one

    (* subtraction *)
let sub x y = mask63 (Int64.sub x y)

let subcarry x y = sub (sub x y) Int64.one

    (* multiplication *)
let mul x y = mask63 (Int64.mul x y)

    (* division *)
let div x y =
  if y = 0L then 0L else Int64.div x y

    (* modulo *)
let rem x y =
  if y = 0L then 0L else Int64.rem x y

let diveucl x y = (div x y, rem x y)

let addmuldiv p x y =
  l_or (l_sl x p) (l_sr y Int64.(sub (of_int uint_size) p))

    (* division of two numbers by one *)
(* precondition: xh &lt; y *)
(* outputs: q, r s.t. x = q * y + r, r &lt; y *)
let div21 xh xl y =
  let nh = ref xh in
  let nl = ref xl in
  let q = ref 0L in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for _i = 0 to 62 do
    (* invariants: 0 &lt;= nh &lt; y, nl = (xl*2^i) % 2^64,
       (q*y + nh) * 2^(63-i) + (xl % 2^(63-i)) = (xh%y) * 2^63 + xl *)
    nl := Int64.shift_left !nl 1;
    nh := Int64.logor (Int64.shift_left !nh 1) (Int64.shift_right_logical !nl 63);
    q := Int64.shift_left !q 1;
    (* TODO: use &quot;Int64.unsigned_compare !nh y &gt;= 0&quot;,
       once OCaml 4.08 becomes the minimal required version *)
    if Int64.compare !nh 0L &lt; 0 || Int64.compare !nh y &gt;= 0 then
      begin q := Int64.logor !q 1L; nh := Int64.sub !nh y; end
  done;
  !q, !nh</abbr>

let div21 xh xl y =
  if Int64.compare y xh &lt;= 0 then zero, zero else div21 xh xl y

     (* exact multiplication *)
let mulc x y =
  let lx = ref (Int64.logand x maxuint31) in
  let ly = ref (Int64.logand y maxuint31) in
  let hx = Int64.shift_right x 31 in
  let hy = Int64.shift_right y 31 in
  let hr = ref (Int64.mul hx hy) in
  let lr = ref (Int64.logor (Int64.mul !lx !ly) (Int64.shift_left !hr 62)) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">hr := (Int64.shift_right_logical !hr 1);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">lx := Int64.mul !lx hy;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">ly := Int64.mul hx !ly;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">hr := Int64.logor !hr (Int64.add (Int64.shift_right !lx 32) (Int64.shift_right !ly 32));
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">lr := Int64.add !lr (Int64.shift_left !lx 31);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">hr := Int64.add !hr (Int64.shift_right_logical !lr 63);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">lr := Int64.add (Int64.shift_left !ly 31) (mask63 !lr);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">hr := Int64.add !hr (Int64.shift_right_logical !lr 63);
  if Int64.logand !lr Int64.min_int &lt;&gt; 0L
  then Int64.(sub !hr one, mask63 !lr)
  else (!hr, !lr)</abbr>

let equal x y = mask63 x = mask63 y

let compare x y = Int64.compare x y

(* Number of leading zeroes *)
let head0 x =
  let r = ref 0 in
  let x = ref x in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0x7FFFFFFF00000000L = 0L then r := !r + 31
  else x := Int64.shift_right !x 31;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xFFFF0000L = 0L then (x := Int64.shift_left !x 16; r := !r + 16);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xFF000000L = 0L then (x := Int64.shift_left !x 8; r := !r + 8);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xF0000000L = 0L then (x := Int64.shift_left !x 4; r := !r + 4);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xC0000000L = 0L then (x := Int64.shift_left !x 2; r := !r + 2);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0x80000000L = 0L then (x := Int64.shift_left !x 1; r := !r + 1);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0x80000000L = 0L then (r := !r + 1);
  Int64.of_int !r</abbr>

(* Number of trailing zeroes *)
let tail0 x =
  let r = ref 0 in
  let x = ref x in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xFFFFFFFFL = 0L then (x := Int64.shift_right !x 32; r := !r + 32);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xFFFFL = 0L then (x := Int64.shift_right !x 16; r := !r + 16);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xFFL = 0L then (x := Int64.shift_right !x 8; r := !r + 8);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0xFL = 0L then (x := Int64.shift_right !x 4; r := !r + 4);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0x3L = 0L then (x := Int64.shift_right !x 2; r := !r + 2);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Int64.logand !x 0x1L = 0L then (r := !r + 1);
  Int64.of_int !r</abbr>

(* May an object be safely cast into an Uint63.t ? *)
let is_uint63 t =
  Obj.is_block t &amp;&amp; Int.equal (Obj.tag t) Obj.custom_tag
  &amp;&amp; le (Obj.magic t) maxuint63

(* Arithmetic with explicit carries *)

(* Analog of Numbers.Abstract.Cyclic.carry *)
type 'a carry = C0 of 'a | C1 of 'a

let addc x y =
  let r = add x y in
  if lt r x then C1 r else C0 r

let addcarryc x y =
  let r = addcarry x y in
  if le r x then C1 r else C0 r

let subc x y =
  let r = sub x y in
  if le y x then C0 r else C1 r

let subcarryc x y =
  let r = subcarry x y in
  if lt y x then C0 r else C1 r

(* Register all exported functions so that they can be called from C code *)

<abbr class="mark-warning" title="Top-level evaluations are not handled">let () =
  Callback.register &quot;uint63 add&quot; add;
  Callback.register &quot;uint63 addcarry&quot; addcarry;
  Callback.register &quot;uint63 addmuldiv&quot; addmuldiv;
  Callback.register &quot;uint63 div&quot; div;
  Callback.register &quot;uint63 div21_ml&quot; div21;
  Callback.register &quot;uint63 eq&quot; equal;
  Callback.register &quot;uint63 eq0&quot; (equal Int64.zero);
  Callback.register &quot;uint63 head0&quot; head0;
  Callback.register &quot;uint63 land&quot; l_and;
  Callback.register &quot;uint63 leq&quot; le;
  Callback.register &quot;uint63 lor&quot; l_or;
  Callback.register &quot;uint63 lsl&quot; l_sl;
  Callback.register &quot;uint63 lsl1&quot; (fun x -&gt; l_sl x Int64.one);
  Callback.register &quot;uint63 lsr&quot; l_sr;
  Callback.register &quot;uint63 lsr1&quot; (fun x -&gt; l_sr x Int64.one);
  Callback.register &quot;uint63 lt&quot; lt;
  Callback.register &quot;uint63 lxor&quot; l_xor;
  Callback.register &quot;uint63 mod&quot; rem;
  Callback.register &quot;uint63 mul&quot; mul;
  Callback.register &quot;uint63 mulc_ml&quot; mulc;
  Callback.register &quot;uint63 one&quot; one;
  Callback.register &quot;uint63 sub&quot; sub;
  Callback.register &quot;uint63 subcarry&quot; subcarry;
  Callback.register &quot;uint63 tail0&quot; tail0</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#uint63_x86.ml"><code>Uint63_x86.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition t := Stdlib.Int64.t.



Definition uint_size : Z := 63.

Definition maxuint63 : int64 := Int64.of_string &quot;0x7FFFFFFFFFFFFFFF&quot;.

Definition maxuint31 : int64 := Int64.of_string &quot;0x7FFFFFFF&quot;.

Definition zero : int64 := Int64.zero.

Definition one : int64 := Int64.one.

Definition mask63 (i : int64) : int64 := Int64.logand i maxuint63.

Definition of_int (i : Z) : int64 := Int64.of_int i.

Definition to_int2 (i : int64) : Z * Z :=
  ((Int64.to_int (Int64.shift_right_logical i 31)), (Int64.to_int i)).

Definition of_int64 {A : Set} (i : A) : A := i.

Definition hash (i : int64) : Z :=
  let '(h, l) := to_int2 i in
  Z.add (Z.mul h 65599) l.

Definition to_string (i : int64) : string := Int64.to_string i.

Definition of_string (s : string) : int64 :=
  let i64 := Int64.of_string s in
  if
    andb (OCaml.Stdlib.le (Int64.compare Int64.zero i64) 0)
      (OCaml.Stdlib.le (Int64.compare i64 maxuint63) 0) then
    i64
  else
    Stdlib.raise extensible_type_value.

Definition compile (i : int64) : string :=
  Printf.sprintf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;Uint63.of_int64 (&quot;
        (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_i
          CamlinternalFormatBasics.No_padding
          CamlinternalFormatBasics.No_precision
          (CamlinternalFormatBasics.String_literal &quot;L)&quot;
            CamlinternalFormatBasics.End_of_format))) &quot;Uint63.of_int64 (%LiL)&quot;)
    i.

Definition lt (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : bool :=
  OCaml.Stdlib.lt (Int64.compare x y) 0.

Definition le (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : bool :=
  OCaml.Stdlib.le (Int64.compare x y) 0.

Definition l_sl (x : int64) (y : Stdlib.Int64.t) : int64 :=
  if
    andb
      (le
        (* ❌ Constant of type int64 is converted to int *)
        0 y)
      (lt y
        (* ❌ Constant of type int64 is converted to int *)
        63) then
    mask63 (Int64.shift_left x (Int64.to_int y))
  else
    (* ❌ Constant of type int64 is converted to int *)
    0.

Definition l_sr (x : int64) (y : Stdlib.Int64.t) : int64 :=
  if
    andb
      (le
        (* ❌ Constant of type int64 is converted to int *)
        0 y)
      (lt y
        (* ❌ Constant of type int64 is converted to int *)
        63) then
    Int64.shift_right x (Int64.to_int y)
  else
    (* ❌ Constant of type int64 is converted to int *)
    0.

Definition l_and (x : int64) (y : int64) : int64 := Int64.logand x y.

Definition l_or (x : int64) (y : int64) : int64 := Int64.logor x y.

Definition l_xor (x : int64) (y : int64) : int64 := Int64.logxor x y.

Definition add (x : int64) (y : int64) : int64 := mask63 (Int64.add x y).

Definition addcarry (x : int64) (y : int64) : int64 := add (add x y) Int64.one.

Definition sub (x : int64) (y : int64) : int64 := mask63 (Int64.sub x y).

Definition subcarry (x : int64) (y : int64) : int64 := sub (sub x y) Int64.one.

Definition mul (x : int64) (y : int64) : int64 := mask63 (Int64.mul x y).

Definition div (x : int64) (y : int64) : int64 :=
  if
    equiv_decb y
      (* ❌ Constant of type int64 is converted to int *)
      0 then
    (* ❌ Constant of type int64 is converted to int *)
    0
  else
    Int64.div x y.

Definition rem (x : int64) (y : int64) : int64 :=
  if
    equiv_decb y
      (* ❌ Constant of type int64 is converted to int *)
      0 then
    (* ❌ Constant of type int64 is converted to int *)
    0
  else
    Int64.rem x y.

Definition diveucl (x : int64) (y : int64) : int64 * int64 :=
  ((div x y), (rem x y)).

Definition addmuldiv (p : Stdlib.Int64.t) (x : int64) (y : int64) : int64 :=
  l_or (l_sl x p) (l_sr y (sub (of_int uint_size) p)).

Definition div21 (xh : Stdlib.Int64.t) (xl : int64) (y : Stdlib.Int64.t)
  : int64 * Stdlib.Int64.t :=
  let nh := Stdlib.__ref_value xh in
  let nl := Stdlib.__ref_value xl in
  let q :=
    Stdlib.__ref_value
      (* ❌ Constant of type int64 is converted to int *)
      0 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  ((Stdlib.op_exclamation q), (Stdlib.op_exclamation nh)).

Definition div21 (xh : Stdlib.Int64.t) (xl : int64) (y : Stdlib.Int64.t)
  : int64 * Stdlib.Int64.t :=
  if OCaml.Stdlib.le (Int64.compare y xh) 0 then
    (zero, zero)
  else
    div21 xh xl y.

Definition mulc (x : int64) (y : int64) : int64 * int64 :=
  let lx := Stdlib.__ref_value (Int64.logand x maxuint31) in
  let ly := Stdlib.__ref_value (Int64.logand y maxuint31) in
  let hx := Int64.shift_right x 31 in
  let hy := Int64.shift_right y 31 in
  let hr := Stdlib.__ref_value (Int64.mul hx hy) in
  let lr :=
    Stdlib.__ref_value
      (Int64.logor
        (Int64.mul (Stdlib.op_exclamation lx) (Stdlib.op_exclamation ly))
        (Int64.shift_left (Stdlib.op_exclamation hr) 62)) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  if
    nequiv_decb (Int64.logand (Stdlib.op_exclamation lr) Int64.min_int)
      (* ❌ Constant of type int64 is converted to int *)
      0 then
    ((sub (Stdlib.op_exclamation hr) one), (mask63 (Stdlib.op_exclamation lr)))
  else
    ((Stdlib.op_exclamation hr), (Stdlib.op_exclamation lr)).

Definition equal (x : int64) (y : int64) : bool :=
  equiv_decb (mask63 x) (mask63 y).

Definition compare (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : Z :=
  Int64.compare x y.

Definition head0 (x : int64) : int64 :=
  let r := Stdlib.__ref_value 0 in
  let x := Stdlib.__ref_value x in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Int64.of_int (Stdlib.op_exclamation r).

Definition tail0 (x : int64) : int64 :=
  let r := Stdlib.__ref_value 0 in
  let x := Stdlib.__ref_value x in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Int64.of_int (Stdlib.op_exclamation r).

Definition is_uint63 (t : Stdlib.Obj.t) : bool :=
  andb (Obj.is_block t)
    (andb (Int.equal (Obj.tag t) Obj.custom_tag) (le (Obj.magic t) maxuint63)).

Inductive carry (a : Set) : Set :=
| C0 : a -&gt; carry a
| C1 : a -&gt; carry a.

Arguments C0 {_}.
Arguments C1 {_}.

Definition addc (x : Stdlib.Int64.t) (y : int64) : carry int64 :=
  let r := add x y in
  if lt r x then
    C1 r
  else
    C0 r.

Definition addcarryc (x : Stdlib.Int64.t) (y : int64) : carry int64 :=
  let r := addcarry x y in
  if le r x then
    C1 r
  else
    C0 r.

Definition subc (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : carry int64 :=
  let r := sub x y in
  if le y x then
    C0 r
  else
    C1 r.

Definition subcarryc (x : Stdlib.Int64.t) (y : Stdlib.Int64.t) : carry int64 :=
  let r := subcarry x y in
  if lt y x then
    C0 r
  else
    C1 r.

(* ❌ Top-level evaluations are not handled *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="univ.ml">
  <div style="margin: 20px;">
    <h3>Univ</h3>
    <ul>
      <li>OCaml size: 1247 lines</li>
      <li>Coq size: 1745 lines (+39% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#univ.ml"><code>univ.ml</code></a>&nbsp;<span class="label label-warning">22 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(* Created in Caml by GÃ©rard Huet for CoC 4.8 [Dec 1988] *)
(* Functional code by Jean-Christophe FilliÃ¢tre for Coq V7.0 [1999] *)
(* Extension with algebraic universes by HH for Coq V7.0 [Sep 2001] *)
(* Additional support for sort-polymorphic inductive types by HH [Mar 2006] *)
(* Support for universe polymorphism by MS [2014] *)

(* Revisions by Bruno Barras, Hugo Herbelin, Pierre Letouzey, Matthieu
   Sozeau, Pierre-Marie PÃ©drot *)

open Pp
open CErrors
open Util

(* Universes are stratified by a partial ordering $\le$.
   Let $\~{}$ be the associated equivalence. We also have a strict ordering
   $&lt;$ between equivalence classes, and we maintain that $&lt;$ is acyclic,
   and contained in $\le$ in the sense that $[U]&lt;[V]$ implies $U\le V$.

   At every moment, we have a finite number of universes, and we
   maintain the ordering in the presence of assertions $U&lt;V$ and $U\le V$.

   The equivalence $\~{}$ is represented by a tree structure, as in the
   union-find algorithm. The assertions $&lt;$ and $\le$ are represented by
   adjacency lists *)

module RawLevel =
struct
  open Names

  module UGlobal = struct
    type t = DirPath.t * int

    let make dp i = (DirPath.hcons dp,i)

    let equal (d, i) (d', i') = DirPath.equal d d' &amp;&amp; Int.equal i i'

    let hash (d,i) = Hashset.Combine.combine i (DirPath.hash d)

    let compare (d, i) (d', i') =
      let c = Int.compare i i' in
      if Int.equal c 0 then DirPath.compare d d'
      else c
  end

  type t =
    | SProp
    | Prop
    | Set
    | Level of UGlobal.t
    | Var of int

  (* Hash-consing *)

  let equal x y =
    x == y ||
      match x, y with
      | SProp, SProp -&gt; true
      | Prop, Prop -&gt; true
      | Set, Set -&gt; true
      | Level l, Level l' -&gt; UGlobal.equal l l'
      | Var n, Var n' -&gt; Int.equal n n'
      | _ -&gt; false

  let compare u v =
    match u, v with
    | SProp, SProp -&gt; 0
    | SProp, _ -&gt; -1
    | _, SProp -&gt; 1
    | Prop,Prop -&gt; 0
    | Prop, _ -&gt; -1
    | _, Prop -&gt; 1
    | Set, Set -&gt; 0
    | Set, _ -&gt; -1
    | _, Set -&gt; 1
    | Level (dp1, i1), Level (dp2, i2) -&gt;
      if i1 &lt; i2 then -1
      else if i1 &gt; i2 then 1
      else DirPath.compare dp1 dp2
    | Level _, _ -&gt; -1
    | _, Level _ -&gt; 1
    | Var n, Var m -&gt; Int.compare n m

  let hequal x y =
    x == y ||
      match x, y with
      | SProp, SProp -&gt; true
      | Prop, Prop -&gt; true
      | Set, Set -&gt; true
      | Level (n,d), Level (n',d') -&gt;
        n == n' &amp;&amp; d == d'
      | Var n, Var n' -&gt; n == n'
      | _ -&gt; false

  let hcons = function
    | SProp as x -&gt; x
    | Prop as x -&gt; x
    | Set as x -&gt; x
    | Level (d,n) as x -&gt;
      let d' = Names.DirPath.hcons d in
        if d' == d then x else Level (d',n)
    | Var _n as x -&gt; x

  open Hashset.Combine

  let hash = function
    | SProp -&gt; combinesmall 1 0
    | Prop -&gt; combinesmall 1 1
    | Set -&gt; combinesmall 1 2
    | Var n -&gt; combinesmall 2 n
    | Level (d, n) -&gt; combinesmall 3 (combine n (Names.DirPath.hash d))

end

module Level = struct

  module UGlobal = RawLevel.UGlobal

  type raw_level = RawLevel.t =
  | SProp
  | Prop
  | Set
  | Level of UGlobal.t
  | Var of int

  (** Embed levels with their hash value *)
  type t = {
    hash : int;
    data : RawLevel.t }

  let equal x y =
    x == y || Int.equal x.hash y.hash &amp;&amp; RawLevel.equal x.data y.data

  let hash x = x.hash

  let data x = x.data

  (** Hashcons on levels + their hash *)

  module Self = struct
    type nonrec t = t
    type u = unit
    let eq x y = x.hash == y.hash &amp;&amp; RawLevel.hequal x.data y.data
    let hash x = x.hash
    let hashcons () x =
      let data' = RawLevel.hcons x.data in
      if x.data == data' then x else { x with data = data' }
  end

  let hcons =
    let module H = Hashcons.Make(Self) in
    Hashcons.simple_hcons H.generate H.hcons ()

  let make l = hcons { hash = RawLevel.hash l; data = l }

  let set = make Set
  let prop = make Prop
  let sprop = make SProp

  let is_small x =
    match data x with
    | Level _ -&gt; false
    | Var _ -&gt; false
    | SProp -&gt; true
    | Prop -&gt; true
    | Set -&gt; true

  let is_prop x =
    match data x with
    | Prop -&gt; true
    | _ -&gt; false

  let is_set x =
    match data x with
    | Set -&gt; true
    | _ -&gt; false

  let is_sprop x =
    match data x with
    | SProp -&gt; true
    | _ -&gt; false

  let compare u v =
    if u == v then 0
    else RawLevel.compare (data u) (data v)

  let to_string x =
    match data x with
    | SProp -&gt; &quot;SProp&quot;
    | Prop -&gt; &quot;Prop&quot;
    | Set -&gt; &quot;Set&quot;
    | Level (d,n) -&gt; Names.DirPath.to_string d^&quot;.&quot;^string_of_int n
    | Var n -&gt; &quot;Var(&quot; ^ string_of_int n ^ &quot;)&quot;

  let pr u = str (to_string u)

  let apart u v =
    match data u, data v with
    | SProp, _ | _, SProp
    | Prop, Set | Set, Prop -&gt; true
    | _ -&gt; false

  let vars = Array.init 20 (fun i -&gt; make (Var i))

  let var n =
    if n &lt; 20 then vars.(n) else make (Var n)

  let var_index u =
    match data u with
    | Var n -&gt; Some n | _ -&gt; None

  let make qid = make (Level qid)

  let name u =
    match data u with
    | Level (d, n) -&gt; Some (d, n)
    | _ -&gt; None
end

(** Level maps *)
module LMap = struct
  module M = HMap.Make (Level)
  include M

  let lunion l r =
    union (fun _k l _r -&gt; Some l) l r

  let subst_union l r =
    union (fun _k l r -&gt;
      match l, r with
      | Some _, _ -&gt; Some l
      | None, None -&gt; Some l
      | _, _ -&gt; Some r) l r

  let diff ext orig =
    fold (fun u v acc -&gt;
      if mem u orig then acc
      else add u v acc)
      ext empty

  let pr f m =
    h 0 (prlist_with_sep fnl (fun (u, v) -&gt;
      Level.pr u ++ f v) (bindings m))
end

module LSet = struct
  include LMap.Set

  let pr prl s =
    str&quot;{&quot; ++ prlist_with_sep spc prl (elements s) ++ str&quot;}&quot;

  let of_array l =
    Array.fold_left (fun acc x -&gt; add x acc) empty l

end


type 'a universe_map = 'a LMap.t

type universe_level = Level.t

type universe_level_subst_fn = universe_level -&gt; universe_level

type universe_set = LSet.t

(* An algebraic universe [universe] is either a universe variable
   [Level.t] or a formal universe known to be greater than some
   universe variables and strictly greater than some (other) universe
   variables

   Universes variables denote universes initially present in the term
   to type-check and non variable algebraic universes denote the
   universes inferred while type-checking: it is either the successor
   of a universe present in the initial term to type-check or the
   maximum of two algebraic universes
*)

module Universe =
struct
  (* Invariants: non empty, sorted and without duplicates *)

  module Expr =
  struct
    type t = Level.t * int

    (* Hashing of expressions *)
    module ExprHash =
    struct
      type t = Level.t * int
      type u = Level.t -&gt; Level.t
      let hashcons hdir (b,n as x) =
        let b' = hdir b in
          if b' == b then x else (b',n)
      let eq l1 l2 =
        l1 == l2 ||
        match l1,l2 with
        | (b,n), (b',n') -&gt; b == b' &amp;&amp; n == n'

      let hash (x, n) = n + Level.hash x

    end

    module H = Hashcons.Make(ExprHash)

    let hcons =
      Hashcons.simple_hcons H.generate H.hcons Level.hcons

    let make l = (l, 0)

    let compare u v =
      if u == v then 0
      else
        let <abbr class="mark-warning" title="A variable name instead of a pattern was expected.">(x, n)</abbr> = u and <abbr class="mark-warning" title="A variable name instead of a pattern was expected.">(x', n')</abbr> = v in
          if Int.equal n n' then Level.compare x x'
          else n - n'

    let sprop = hcons (Level.sprop, 0)
    let prop = hcons (Level.prop, 0)
    let set = hcons (Level.set, 0)
    let type1 = hcons (Level.set, 1)

    let is_small = function
      | (l,0) -&gt; Level.is_small l
      | _ -&gt; false

    let equal x y = x == y ||
      (let <abbr class="mark-warning" title="A variable name instead of a pattern was expected.">(u,n)</abbr> = x and <abbr class="mark-warning" title="A variable name instead of a pattern was expected.">(v,n')</abbr> = y in
         Int.equal n n' &amp;&amp; Level.equal u v)

    let hash = ExprHash.hash

    let leq (u,n) (v,n') =
      let cmp = Level.compare u v in
        if Int.equal cmp 0 then n &lt;= n'
        else if n &lt;= n' then
          (Level.is_prop u &amp;&amp; not (Level.is_sprop v))
        else false

    let successor (u,n) =
      if Level.is_small u then type1
      else (u, n + 1)

    let addn k (u,n as x) =
      if k = 0 then x
      else if Level.is_small u then
        (Level.set,n+k)
      else (u,n+k)

    type super_result =
        SuperSame of bool
        (* The level expressions are in cumulativity relation. boolean
           indicates if left is smaller than right?  *)
      | SuperDiff of int
        (* The level expressions are unrelated, the comparison result
           is canonical *)

    (** [super u v] compares two level expressions,
       returning [SuperSame] if they refer to the same level at potentially different
       increments or [SuperDiff] if they are different. The booleans indicate if the
       left expression is &quot;smaller&quot; than the right one in both cases. *)
    let super (u,n) (v,n') =
      let cmp = Level.compare u v in
        if Int.equal cmp 0 then SuperSame (n &lt; n')
        else
          let open RawLevel in
          match Level.data u, n, Level.data v, n' with
          | SProp, _, SProp, _ | Prop, _, Prop, _ -&gt; SuperSame (n &lt; n')
          | SProp, 0, Prop, 0 -&gt; SuperSame true
          | Prop, 0, SProp, 0 -&gt; SuperSame false
          | (SProp | Prop), 0, _, _ -&gt; SuperSame true
          | _, _, (SProp | Prop), 0 -&gt; SuperSame false

          | _, _, _, _ -&gt; SuperDiff cmp

    let to_string (v, n) =
      if Int.equal n 0 then Level.to_string v
      else Level.to_string v ^ &quot;+&quot; ^ string_of_int n

    let pr x = str(to_string x)

    let pr_with f (v, n) =
      if Int.equal n 0 then f v
      else f v ++ str&quot;+&quot; ++ int n

    let is_level = function
      | (_v, 0) -&gt; true
      | _ -&gt; false

    let level = function
      | (v,0) -&gt; Some v
      | _ -&gt; None

    let get_level (v,_n) = v

    let map f (v, n as x) =
      let v' = f v in
        if v' == v then x
        else if Level.is_prop v' &amp;&amp; n != 0 then
          (Level.set, n)
        else (v', n)

  end

  type t = Expr.t list

  let tip l = [l]
  let cons x l = x :: l

  let rec hash = function
  | [] -&gt; 0
  | e :: l -&gt; Hashset.Combine.combinesmall (Expr.ExprHash.hash e) (hash l)

  let equal x y = x == y || List.equal Expr.equal x y

  let compare x y = if x == y then 0 else List.compare Expr.compare x y

  module Huniv = Hashcons.Hlist(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Hashcons.HashedType, Util.Set.HashedType

We were looking for a module signature name for the following shape:
[ hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">Expr</abbr>)

  let hcons = Hashcons.recursive_hcons Huniv.generate Huniv.hcons Expr.hcons

  let make l = tip (Expr.make l)
  let tip x = tip x

  let pr l = match l with
    | [u] -&gt; Expr.pr u
    | _ -&gt;
      str &quot;max(&quot; ++ hov 0
        (prlist_with_sep pr_comma Expr.pr l) ++
        str &quot;)&quot;

  let pr_with f l = match l with
    | [u] -&gt; Expr.pr_with f u
    | _ -&gt;
      str &quot;max(&quot; ++ hov 0
        (prlist_with_sep pr_comma (Expr.pr_with f) l) ++
        str &quot;)&quot;

  let is_level l = match l with
    | [l] -&gt; Expr.is_level l
    | _ -&gt; false

  let rec is_levels l = match l with
    | l :: r -&gt; Expr.is_level l &amp;&amp; is_levels r
    | [] -&gt; true

  let level l = match l with
    | [l] -&gt; Expr.level l
    | _ -&gt; None

  let levels l =
    List.fold_left (fun acc x -&gt; LSet.add (Expr.get_level x) acc) LSet.empty l

  let is_small u =
    match u with
    | [l] -&gt; Expr.is_small l
    | _ -&gt; false

  let sprop = tip Expr.sprop

  (* The lower predicative level of the hierarchy that contains (impredicative)
     Prop and singleton inductive types *)
  let type0m = tip Expr.prop

  (* The level of sets *)
  let type0 = tip Expr.set

  (* When typing [Prop] and [Set], there is no constraint on the level,
     hence the definition of [type1_univ], the type of [Prop] *)
  let type1 = tip Expr.type1

  let is_sprop x = equal sprop x
  let is_type0m x = equal type0m x
  let is_type0 x = equal type0 x

  (* Returns the formal universe that lies just above the universe variable u.
     Used to type the sort u. *)
  let super l =
    if is_small l then type1
    else
      List.Smart.map (fun x -&gt; Expr.successor x) l

  let addn n l =
    List.Smart.map (fun x -&gt; Expr.addn n x) l

  let rec merge_univs l1 l2 =
    match l1, l2 with
    | [], _ -&gt; l2
    | _, [] -&gt; l1
    | h1 :: t1, h2 :: t2 -&gt;
       let open Expr in
       (match super h1 h2 with
        | SuperSame true (* h1 &lt; h2 *) -&gt; merge_univs t1 l2
        | SuperSame false -&gt; merge_univs l1 t2
        | SuperDiff c -&gt;
           if c &lt;= 0 (* h1 &lt; h2 is name order *)
           then cons h1 (merge_univs t1 l2)
           else cons h2 (merge_univs l1 t2))

  let sort u =
    let rec aux a l =
      match l with
      | b :: l' -&gt;
        let open Expr in
        (match super a b with
         | SuperSame false -&gt; aux a l'
         | SuperSame true -&gt; l
         | SuperDiff c -&gt;
            if c &lt;= 0 then cons a l
            else cons b (aux a l'))
      | [] -&gt; cons a l
    in
      List.fold_right (fun a acc -&gt; aux a acc) u []

  (* Returns the formal universe that is greater than the universes u and v.
     Used to type the products. *)
  let sup x y = merge_univs x y

  let empty = []

  let exists = List.exists

  let for_all = List.for_all

  let smart_map = List.Smart.map

  let map = List.map
end

type universe = Universe.t

(* The level of predicative Set *)
let type0m_univ = Universe.type0m
let type0_univ = Universe.type0
let type1_univ = Universe.type1
let is_type0m_univ = Universe.is_type0m
let is_type0_univ = Universe.is_type0
let is_univ_variable l = Universe.level l != None
let is_small_univ = Universe.is_small
let pr_uni = Universe.pr

let sup = Universe.sup
let super = Universe.super

open Universe

let universe_level = Universe.level


type constraint_type = AcyclicGraph.constraint_type = Lt | Le | Eq

type explanation = (constraint_type * Level.t) list

let constraint_type_ord c1 c2 = match c1, c2 with
| Lt, Lt -&gt; 0
| Lt, _ -&gt; -1
| Le, Lt -&gt; 1
| Le, Le -&gt; 0
| Le, Eq -&gt; -1
| Eq, Eq -&gt; 0
| Eq, _ -&gt; 1

(* Universe inconsistency: error raised when trying to enforce a relation
   that would create a cycle in the graph of universes. *)

type univ_inconsistency = constraint_type * universe * universe * explanation Lazy.t option

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception UniverseInconsistency of univ_inconsistency</abbr>

let error_inconsistency o u v p =
  raise <abbr class="mark-warning" title="Values of extensible types are not handled">(UniverseInconsistency (o,make u,make v,p))</abbr>

(* Constraints and sets of constraints. *)

type univ_constraint = Level.t * constraint_type * Level.t

let pr_constraint_type op =
  let op_str = match op with
    | Lt -&gt; &quot; &lt; &quot;
    | Le -&gt; &quot; &lt;= &quot;
    | Eq -&gt; &quot; = &quot;
  in str op_str

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module UConstraintOrd =
struct
  type t = univ_constraint
  let compare (u,c,v) (u',c',v') =
    let i = constraint_type_ord c c' in
    if not (Int.equal i 0) then i
    else
      let i' = Level.compare u u' in
      if not (Int.equal i' 0) then i'
      else Level.compare v v'
end</abbr>

module Constraint =
struct
  module S = Set.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Util.Set.OrderedType, Util.Map.OrderedType

We were looking for a module signature name for the following shape:
[ compare ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">UConstraintOrd</abbr>)
  include S

  let pr prl c =
    v 0 (prlist_with_sep spc (fun (u1,op,u2) -&gt;
      hov 0 (prl u1 ++ pr_constraint_type op ++ prl u2))
       (elements c))

end

let empty_constraint = Constraint.empty
let union_constraint = Constraint.union
let eq_constraint = Constraint.equal

type constraints = Constraint.t

module Hconstraint =
  Hashcons.Make(
    struct
      type t = univ_constraint
      type u = universe_level -&gt; universe_level
      let hashcons hul (l1,k,l2) = (hul l1, k, hul l2)
      let eq (l1,k,l2) (l1',k',l2') =
        l1 == l1' &amp;&amp; k == k' &amp;&amp; l2 == l2'
      let hash = Hashtbl.hash
    end)

module Hconstraints =
  Hashcons.Make(
    struct
      type t = constraints
      type u = univ_constraint -&gt; univ_constraint
      let hashcons huc s =
        Constraint.fold (fun x -&gt; Constraint.add (huc x)) s Constraint.empty
      let eq s s' =
        List.for_all2eq (==)
          (Constraint.elements s)
          (Constraint.elements s')
      let hash = Hashtbl.hash
    end)

let hcons_constraint = Hashcons.simple_hcons Hconstraint.generate Hconstraint.hcons Level.hcons
let hcons_constraints = Hashcons.simple_hcons Hconstraints.generate Hconstraints.hcons hcons_constraint


(** A value with universe constraints. *)
type 'a constrained = 'a * constraints

let constraints_of (_, cst) = cst

(** Constraint functions. *)

type 'a constraint_function = 'a -&gt; 'a -&gt; constraints -&gt; constraints

let enforce_eq_level u v c =
  (* We discard trivial constraints like u=u *)
  if Level.equal u v then c
  else if Level.apart u v then
    error_inconsistency Eq u v None
  else Constraint.add (u,Eq,v) c

let enforce_eq u v c =
  match Universe.level u, Universe.level v with
    | Some u, Some v -&gt; enforce_eq_level u v c
    | _ -&gt; anomaly (Pp.str &quot;A universe comparison can only happen between variables.&quot;)

let check_univ_eq u v = Universe.equal u v

let enforce_eq u v c =
  if check_univ_eq u v then c
  else enforce_eq u v c

let constraint_add_leq v u c =
  (* We just discard trivial constraints like u&lt;=u *)
  if Expr.equal v u then c
  else
    match v, u with
    | (x,n), (y,m) -&gt;
    let j = m - n in
      if j = -1 (* n = m+1, v+1 &lt;= u &lt;-&gt; v &lt; u *) then
        Constraint.add (x,Lt,y) c
      else if j &lt;= -1 (* n = m+k, v+k &lt;= u &lt;-&gt; v+(k-1) &lt; u *) then
        if Level.equal x y then (* u+(k+1) &lt;= u *)
          raise <abbr class="mark-warning" title="Values of extensible types are not handled">(UniverseInconsistency (Le, Universe.tip v, Universe.tip u, None))</abbr>
        else anomaly (Pp.str&quot;Unable to handle arbitrary u+k &lt;= v constraints.&quot;)
      else if j = 0 then
        Constraint.add (x,Le,y) c
      else (* j &gt;= 1 *) (* m = n + k, u &lt;= v+k *)
        if Level.equal x y then c (* u &lt;= u+k, trivial *)
        else if Level.is_small x then c (* Prop,Set &lt;= u+S k, trivial *)
        else Constraint.add (x,Le,y) c (* u &lt;= v implies u &lt;= v+k *)

let check_univ_leq_one u v = Universe.exists (Expr.leq u) v

let check_univ_leq u v =
  Universe.for_all (fun u -&gt; check_univ_leq_one u v) u

let enforce_leq u v c =
  match is_sprop u, is_sprop v with
  | true, true -&gt; c
  | true, false | false, true -&gt;
    raise <abbr class="mark-warning" title="Values of extensible types are not handled">(UniverseInconsistency (Le, u, v, None))</abbr>
  | false, false -&gt;
    List.fold_left (fun c v -&gt; (List.fold_left (fun c u -&gt; constraint_add_leq u v c) c u)) c v

let enforce_leq u v c =
  if check_univ_leq u v then c
  else enforce_leq u v c

let enforce_leq_level u v c =
  if Level.equal u v then c else Constraint.add (u,Le,v) c

(* Miscellaneous functions to remove or test local univ assumed to
   occur in a universe *)

let univ_level_mem u v =
  List.exists (fun (l, n) -&gt; Int.equal n 0 &amp;&amp; Level.equal u l) v

let univ_level_rem u v min =
  match Universe.level v with
  | Some u' -&gt; if Level.equal u u' then min else v
  | None -&gt; List.filter (fun (l, n) -&gt; not (Int.equal n 0 &amp;&amp; Level.equal u l)) v

(* Is u mentioned in v (or equals to v) ? *)


(**********************************************************************)
(** Universe polymorphism                                             *)
(**********************************************************************)

(** A universe level substitution, note that no algebraic universes are
    involved *)

type universe_level_subst = universe_level universe_map

(** A full substitution might involve algebraic universes *)
type universe_subst = universe universe_map

module Variance =
struct
  (** A universe position in the instance given to a cumulative
     inductive can be the following. Note there is no Contravariant
     case because [forall x : A, B &lt;= forall x : A', B'] requires [A =
     A'] as opposed to [A' &lt;= A]. *)
  type t = Irrelevant | Covariant | Invariant

  let sup x y =
    match x, y with
    | Irrelevant, s | s, Irrelevant -&gt; s
    | Invariant, _ | _, Invariant -&gt; Invariant
    | Covariant, Covariant -&gt; Covariant

  let check_subtype x y = match x, y with
  | (Irrelevant | Covariant | Invariant), Irrelevant -&gt; true
  | Irrelevant, Covariant -&gt; false
  | (Covariant | Invariant), Covariant -&gt; true
  | (Irrelevant | Covariant), Invariant -&gt; false
  | Invariant, Invariant -&gt; true

  let pr = function
    | Irrelevant -&gt; str &quot;*&quot;
    | Covariant -&gt; str &quot;+&quot;
    | Invariant -&gt; str &quot;=&quot;

  let leq_constraint csts variance u u' =
    match variance with
    | Irrelevant -&gt; csts
    | Covariant -&gt; enforce_leq_level u u' csts
    | Invariant -&gt; enforce_eq_level u u' csts

  let eq_constraint csts variance u u' =
    match variance with
    | Irrelevant -&gt; csts
    | Covariant | Invariant -&gt; enforce_eq_level u u' csts

  let leq_constraints variance u u' csts =
    let len = Array.length u in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (len = Array.length u' &amp;&amp; len = Array.length variance);
    Array.fold_left3 leq_constraint csts variance u u'</abbr>

  let eq_constraints variance u u' csts =
    let len = Array.length u in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (len = Array.length u' &amp;&amp; len = Array.length variance);
    Array.fold_left3 eq_constraint csts variance u u'</abbr>
end

<abbr class="mark-warning" title="This kind of module is not handled.">module Instance : sig
    type t = Level.t array

    val empty : t
    val is_empty : t -&gt; bool

    val of_array : Level.t array -&gt; t
    val to_array : t -&gt; Level.t array

    val append : t -&gt; t -&gt; t
    val equal : t -&gt; t -&gt; bool
    val length : t -&gt; int

    val hcons : t -&gt; t
    val hash : t -&gt; int

    val share : t -&gt; t * int

    val subst_fn : universe_level_subst_fn -&gt; t -&gt; t

    val pr : (Level.t -&gt; Pp.t) -&gt; ?variance:Variance.t array -&gt; t -&gt; Pp.t
    val levels : t -&gt; LSet.t
end =
struct
  type t = Level.t array

  let empty : t = [||]

  module HInstancestruct =
  struct
    type nonrec t = t
    type u = Level.t -&gt; Level.t

    let hashcons huniv a =
      let len = Array.length a in
        if Int.equal len 0 then empty
        else begin
          for i = 0 to len - 1 do
            let x = Array.unsafe_get a i in
            let x' = huniv x in
              if x == x' then ()
              else Array.unsafe_set a i x'
          done;
          a
        end

    let eq t1 t2 =
      t1 == t2 ||
        (Int.equal (Array.length t1) (Array.length t2) &amp;&amp;
           let rec aux i =
             (Int.equal i (Array.length t1)) || (t1.(i) == t2.(i) &amp;&amp; aux (i + 1))
           in aux 0)

    let hash a =
      let accu = ref 0 in
        for i = 0 to Array.length a - 1 do
          let l = Array.unsafe_get a i in
          let h = Level.hash l in
            accu := Hashset.Combine.combine !accu h;
        done;
        (* [h] must be positive. *)
        let h = !accu land 0x3FFFFFFF in
          h
  end

  module HInstance = Hashcons.Make(HInstancestruct)

  let hcons = Hashcons.simple_hcons HInstance.generate HInstance.hcons Level.hcons

  let hash = HInstancestruct.hash

  let share a = (hcons a, hash a)

  let empty = hcons [||]

  let is_empty x = Int.equal (Array.length x) 0

  let append x y =
    if Array.length x = 0 then y
    else if Array.length y = 0 then x
    else Array.append x y

  let of_array a =
    assert(Array.for_all (fun x -&gt; not (Level.is_prop x || Level.is_sprop x)) a);
    a

  let to_array a = a

  let length a = Array.length a

  let subst_fn fn t =
    let t' = CArray.Smart.map fn t in
      if t' == t then t else of_array t'

  let levels x = LSet.of_array x

  let pr prl ?variance =
    let ppu i u =
      let v = Option.map (fun v -&gt; v.(i)) variance in
      pr_opt_no_spc Variance.pr v ++ prl u
    in
    prvecti_with_sep spc ppu

  let equal t u =
    t == u ||
      (Array.is_empty t &amp;&amp; Array.is_empty u) ||
      (CArray.for_all2 Level.equal t u
         (* Necessary as universe instances might come from different modules and
            unmarshalling doesn't preserve sharing *))

end</abbr>

let enforce_eq_instances x y =
  let ax = Instance.to_array x and ay = Instance.to_array y in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Array.length ax != Array.length ay then
      anomaly (Pp.(++) (Pp.str &quot;Invalid argument: enforce_eq_instances called with&quot;)
                 (Pp.str &quot; instances of different lengths.&quot;));
    CArray.fold_right2 enforce_eq_level ax ay</abbr>

let enforce_eq_variance_instances = Variance.eq_constraints
let enforce_leq_variance_instances = Variance.leq_constraints

let subst_instance_level s l =
  match l.Level.data with
  | Level.Var n -&gt; s.(n)
  | _ -&gt; l

let subst_instance_instance s i =
  Array.Smart.map (fun l -&gt; subst_instance_level s l) i

let subst_instance_universe s u =
  let f x = Universe.Expr.map (fun u -&gt; subst_instance_level s u) x in
  let u' = Universe.smart_map f u in
    if u == u' then u
    else Universe.sort u'

let subst_instance_constraint s (u,d,v as c) =
  let u' = subst_instance_level s u in
  let v' = subst_instance_level s v in
    if u' == u &amp;&amp; v' == v then c
    else (u',d,v')

let subst_instance_constraints s csts =
  Constraint.fold
    (fun c csts -&gt; Constraint.add (subst_instance_constraint s c) csts)
    csts Constraint.empty

type 'a puniverses = 'a * Instance.t
let out_punivs (x, _y) = x
let in_punivs x = (x, Instance.empty)
let eq_puniverses f (x, u) (y, u') =
  f x y &amp;&amp; Instance.equal u u'

(** A context of universe levels with universe constraints,
    representing local universe variables and constraints *)

module UContext =
struct
  type t = Instance.t constrained

  let make x = x

  (** Universe contexts (variables as a list) *)
  let empty = (Instance.empty, Constraint.empty)
  let is_empty (univs, cst) = Instance.is_empty univs &amp;&amp; Constraint.is_empty cst

  let pr prl ?variance (univs, cst as ctx) =
    if is_empty ctx then mt() else
      h 0 (Instance.pr prl ?variance univs ++ str &quot; |= &quot;) ++ h 0 (v 0 (Constraint.pr prl cst))

  let hcons (univs, cst) =
    (Instance.hcons univs, hcons_constraints cst)

  let instance (univs, _cst) = univs
  let constraints (_univs, cst) = cst

  let union (univs, cst) (univs', cst') =
    Instance.append univs univs', Constraint.union cst cst'

  let dest x = x

  let size (x,_) = Instance.length x

end

type universe_context = UContext.t
let hcons_universe_context = UContext.hcons

module AUContext =
struct
  type t = Names.Name.t array constrained

  let repr (inst, cst) =
    (Array.init (Array.length inst) (fun i -&gt; Level.var i), cst)

  let pr f ?variance ctx = UContext.pr f ?variance (repr ctx)

  let instantiate inst (u, cst) =
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Array.length u = Array.length inst);
    subst_instance_constraints inst cst</abbr>

  let names (nas, _) = nas

  let hcons (univs, cst) =
    (Array.map Names.Name.hcons univs, hcons_constraints cst)

  let empty = (<abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>, Constraint.empty)

  let is_empty (nas, cst) = Array.is_empty nas &amp;&amp; Constraint.is_empty cst

  let union (nas, cst) (nas', cst') = (Array.append nas nas', Constraint.union cst cst')

  let size (nas, _) = Array.length nas

end

type 'a univ_abstracted = {
  univ_abstracted_value : 'a;
  univ_abstracted_binder : AUContext.t;
}

let map_univ_abstracted f {univ_abstracted_value;univ_abstracted_binder} =
  let univ_abstracted_value = f univ_abstracted_value in
  {univ_abstracted_value;univ_abstracted_binder}

let hcons_abstract_universe_context = AUContext.hcons

(** A set of universes with universe constraints.
    We linearize the set to a list after typechecking.
    Beware, representation could change.
*)

module ContextSet =
struct
  type t = universe_set constrained

  let empty = (LSet.empty, Constraint.empty)
  let is_empty (univs, cst) = LSet.is_empty univs &amp;&amp; Constraint.is_empty cst

  let equal (univs, cst as x) (univs', cst' as y) =
    x == y || (LSet.equal univs univs' &amp;&amp; Constraint.equal cst cst')

  let of_set s = (s, Constraint.empty)
  let singleton l = of_set (LSet.singleton l)
  let of_instance i = of_set (Instance.levels i)

  let union (univs, cst as x) (univs', cst' as y) =
    if x == y then x
    else LSet.union univs univs', Constraint.union cst cst'

  let append (univs, cst) (univs', cst') =
    let univs = LSet.fold LSet.add univs univs' in
    let cst = Constraint.fold Constraint.add cst cst' in
    (univs, cst)

  let diff (univs, cst) (univs', cst') =
    LSet.diff univs univs', Constraint.diff cst cst'

  let add_universe u (univs, cst) =
    LSet.add u univs, cst

  let add_constraints cst' (univs, cst) =
    univs, Constraint.union cst cst'

  let add_instance inst (univs, cst) =
    let v = Instance.to_array inst in
    let fold accu u = LSet.add u accu in
    let univs = Array.fold_left fold univs v in
    (univs, cst)

  let sort_levels a =
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Array.sort Level.compare a; a</abbr>

  let to_context (ctx, cst) =
    (Instance.of_array (sort_levels (Array.of_list (LSet.elements ctx))), cst)

  let of_context (ctx, cst) =
    (Instance.levels ctx, cst)

  let pr prl (univs, cst as ctx) =
    if is_empty ctx then mt() else
      h 0 (LSet.pr prl univs ++ str &quot; |= &quot;) ++ h 0 (v 0 (Constraint.pr prl cst))

  let constraints (_univs, cst) = cst
  let levels (univs, _cst) = univs

  let size (univs,_) = LSet.cardinal univs
end

type universe_context_set = ContextSet.t

(** A value in a universe context (resp. context set). *)
type 'a in_universe_context = 'a * universe_context
type 'a in_universe_context_set = 'a * universe_context_set

let extend_in_context_set (a, ctx) ctx' =
  (a, ContextSet.union ctx ctx')

(** Substitutions. *)

let empty_subst = LMap.empty
let is_empty_subst = LMap.is_empty

let empty_level_subst = LMap.empty
let is_empty_level_subst = LMap.is_empty

(** Substitution functions *)

(** With level to level substitutions. *)
let subst_univs_level_level subst l =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try LMap.find l subst
  with Not_found -&gt; l</abbr>

let subst_univs_level_universe subst u =
  let f x = Universe.Expr.map (fun u -&gt; subst_univs_level_level subst u) x in
  let u' = Universe.smart_map f u in
    if u == u' then u
    else Universe.sort u'

let subst_univs_level_instance subst i =
  let i' = Instance.subst_fn (subst_univs_level_level subst) i in
    if i == i' then i
    else i'

let subst_univs_level_constraint subst (u,d,v) =
  let u' = subst_univs_level_level subst u
  and v' = subst_univs_level_level subst v in
    if d != Lt &amp;&amp; Level.equal u' v' then None
    else Some (u',d,v')

let subst_univs_level_constraints subst csts =
  Constraint.fold
    (fun c -&gt; Option.fold_right Constraint.add (subst_univs_level_constraint subst c))
    csts Constraint.empty

let subst_univs_level_abstract_universe_context subst (inst, csts) =
  inst, subst_univs_level_constraints subst csts

(** With level to universe substitutions. *)
type universe_subst_fn = universe_level -&gt; universe

let make_subst subst = fun l -&gt; LMap.find l subst

let subst_univs_expr_opt fn (l,n) =
  Universe.addn n (fn l)

let subst_univs_universe fn ul =
  let subst, nosubst =
    List.fold_right (fun u (subst,nosubst) -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try let a' = subst_univs_expr_opt fn u in
            (a' :: subst, nosubst)
      with Not_found -&gt; (subst, u :: nosubst)</abbr>)
      ul ([], [])
  in
    if CList.is_empty subst then ul
    else
      let substs =
        List.fold_left Universe.merge_univs Universe.empty subst
      in
        List.fold_left (fun acc u -&gt; Universe.merge_univs acc (Universe.tip u))
          substs nosubst

let make_instance_subst i =
  let arr = Instance.to_array i in
    Array.fold_left_i (fun i acc l -&gt;
      LMap.add l (Level.var i) acc)
      LMap.empty arr

let make_inverse_instance_subst i =
  let arr = Instance.to_array i in
    Array.fold_left_i (fun i acc l -&gt;
      LMap.add (Level.var i) l acc)
      LMap.empty arr

let make_abstract_instance (ctx, _) =
  Array.init (Array.length ctx) (fun i -&gt; Level.var i)

let abstract_universes nas ctx =
  let instance = UContext.instance ctx in
  let () = <abbr class="mark-warning" title="Assert instruction is not handled.">assert (Int.equal (Array.length nas) (Instance.length instance))</abbr> in
  let subst = make_instance_subst instance in
  let cstrs = subst_univs_level_constraints subst
      (UContext.constraints ctx)
  in
  let ctx = (nas, cstrs) in
  instance, ctx

let rec compact_univ s vars i u =
  match u with
  | [] -&gt; (s, List.rev vars)
  | (lvl, _) :: u -&gt;
    match Level.var_index lvl with
    | Some k when not (LMap.mem lvl s) -&gt;
      let lvl' = Level.var i in
      compact_univ (LMap.add lvl lvl' s) (k :: vars) (i+1) u
    | _ -&gt; compact_univ s vars i u

let compact_univ u =
  let (s, s') = compact_univ LMap.empty [] 0 u in
  (subst_univs_level_universe s u, s')

(** Pretty-printing *)

let pr_constraints prl = Constraint.pr prl

let pr_universe_context = UContext.pr

let pr_abstract_universe_context = AUContext.pr

let pr_universe_context_set = ContextSet.pr

let pr_universe_subst =
  LMap.pr (fun u -&gt; str&quot; := &quot; ++ Universe.pr u ++ spc ())

let pr_universe_level_subst =
  LMap.pr (fun u -&gt; str&quot; := &quot; ++ Level.pr u ++ spc ())

module Huniverse_set =
  Hashcons.Make(
    struct
      type t = universe_set
      type u = universe_level -&gt; universe_level
      let hashcons huc s =
        LSet.fold (fun x -&gt; LSet.add (huc x)) s LSet.empty
      let eq s s' =
        LSet.equal s s'
      let hash = Hashtbl.hash
    end)

let hcons_universe_set =
  Hashcons.simple_hcons Huniverse_set.generate Huniverse_set.hcons Level.hcons

let hcons_universe_context_set (v, c) =
  (hcons_universe_set v, hcons_constraints c)

let hcons_univ x = Universe.hcons x

let explain_universe_inconsistency prl (o,u,v,p : univ_inconsistency) =
  let pr_uni = Universe.pr_with prl in
  let pr_rel = function
    | Eq -&gt; str&quot;=&quot; | Lt -&gt; str&quot;&lt;&quot; | Le -&gt; str&quot;&lt;=&quot;
  in
  let reason = match p with
    | None -&gt; mt()
    | Some p -&gt;
      let p = Lazy.force p in
      if p = [] then mt ()
      else
        str &quot; because&quot; ++ spc() ++ pr_uni v ++
        prlist (fun (r,v) -&gt; spc() ++ pr_rel r ++ str&quot; &quot; ++ prl v)
          p ++
        (if Universe.equal (Universe.make (snd (List.last p))) u then mt() else
           (spc() ++ str &quot;= &quot; ++ pr_uni u))
  in
    str &quot;Cannot enforce&quot; ++ spc() ++ pr_uni u ++ spc() ++
      pr_rel o ++ spc() ++ pr_uni v ++ reason
</pre>
  </div>
  <div class="col-md-6">
    <a href="#univ.ml"><code>Univ.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Pp.

Import CErrors.

Import Util.

Module RawLevel.
  Import Names.
  
  Module UGlobal.
    Definition t := Names.DirPath.t * Z.
    
    Definition make {A : Set} (dp : Names.DirPath.t) (i : A)
      : Names.DirPath.t * A := ((DirPath.hcons dp), i).
    
    Definition equal (function_parameter : Names.DirPath.t * Int.t)
      : Names.DirPath.t * Int.t -&gt; bool :=
      let '(d, i) := function_parameter in
      fun function_parameter =&gt;
        let '(d', i') := function_parameter in
        andb (DirPath.equal d d') (Int.equal i i').
    
    Definition hash (function_parameter : Names.DirPath.t * Z) : Z :=
      let '(d, i) := function_parameter in
      Hashset.Combine.combine i (DirPath.hash d).
    
    Definition compare (function_parameter : Names.DirPath.t * Int.t)
      : Names.DirPath.t * Int.t -&gt; Z :=
      let '(d, i) := function_parameter in
      fun function_parameter =&gt;
        let '(d', i') := function_parameter in
        let c := Int.compare i i' in
        if Int.equal c 0 then
          DirPath.compare d d'
        else
          c.
  End UGlobal.
  
  Inductive t : Set :=
  | SProp : t
  | Prop : t
  | __Set : t
  | Level : UGlobal.t -&gt; t
  | Var : Z -&gt; t.
  
  Definition equal (x : t) (y : t) : bool :=
    orb (Stdlib.op_eqeq x y)
      match (x, y) with
      | (SProp, SProp) =&gt; true
      | (Prop, Prop) =&gt; true
      | (__Set, __Set) =&gt; true
      | (Level l, Level l') =&gt; UGlobal.equal l l'
      | (Var n, Var n') =&gt; Int.equal n n'
      | _ =&gt; false
      end.
  
  Definition compare (u : t) (v : t) : Z :=
    match (u, v) with
    | (SProp, SProp) =&gt; 0
    | (SProp, _) =&gt; (-1)
    | (_, SProp) =&gt; 1
    | (Prop, Prop) =&gt; 0
    | (Prop, _) =&gt; (-1)
    | (_, Prop) =&gt; 1
    | (__Set, __Set) =&gt; 0
    | (__Set, _) =&gt; (-1)
    | (_, __Set) =&gt; 1
    | (Level (dp1, i1), Level (dp2, i2)) =&gt;
      if OCaml.Stdlib.lt i1 i2 then
        (-1)
      else
        if OCaml.Stdlib.gt i1 i2 then
          1
        else
          DirPath.compare dp1 dp2
    | (Level _, _) =&gt; (-1)
    | (_, Level _) =&gt; 1
    | (Var n, Var m) =&gt; Int.compare n m
    end.
  
  Definition hequal (x : t) (y : t) : bool :=
    orb (Stdlib.op_eqeq x y)
      match (x, y) with
      | (SProp, SProp) =&gt; true
      | (Prop, Prop) =&gt; true
      | (__Set, __Set) =&gt; true
      | (Level (n, d), Level (n', d')) =&gt;
        andb (Stdlib.op_eqeq n n') (Stdlib.op_eqeq d d')
      | (Var n, Var n') =&gt; Stdlib.op_eqeq n n'
      | _ =&gt; false
      end.
  
  Definition hcons (function_parameter : t) : t :=
    match function_parameter with
    | SProp as x =&gt; x
    | Prop as x =&gt; x
    | __Set as x =&gt; x
    | (Level (d, n)) as x =&gt;
      let d' := Names.DirPath.hcons d in
      if Stdlib.op_eqeq d' d then
        x
      else
        Level (d', n)
    | (Var _n) as x =&gt; x
    end.
  
  Import Hashset.Combine.
  
  Definition hash (function_parameter : t) : Z :=
    match function_parameter with
    | SProp =&gt; combinesmall 1 0
    | Prop =&gt; combinesmall 1 1
    | __Set =&gt; combinesmall 1 2
    | Var n =&gt; combinesmall 2 n
    | Level (d, n) =&gt; combinesmall 3 (combine n (Names.DirPath.hash d))
    end.
End RawLevel.

Module Level.
  Module UGlobal := RawLevel.UGlobal.
  
  Inductive raw_level : Set :=
  | SProp : raw_level
  | Prop : raw_level
  | __Set : raw_level
  | Level : UGlobal.t -&gt; raw_level
  | Var : Z -&gt; raw_level.
  
  Module t.
    Record record := {
      hash : Z;
      data : RawLevel.t }.
    Definition with_hash (r : record) hash : record :=
      {| hash := hash; data := data r |}.
    Definition with_data (r : record) data : record :=
      {| hash := hash r; data := data |}.
  End t.
  Definition t := t.record.
  
  Definition equal (x : t) (y : t) : bool :=
    orb (Stdlib.op_eqeq x y)
      (andb (Int.equal (t.hash x) (t.hash y))
        (RawLevel.equal (t.data x) (t.data y))).
  
  Definition hash (x : t) : Z := t.hash x.
  
  Definition data (x : t) : RawLevel.t := t.data x.
  
  Module Self.
    Definition t := t.
    
    Definition u := unit.
    
    Definition eq (x : t) (y : t) : bool :=
      andb (Stdlib.op_eqeq (t.hash x) (t.hash y))
        (RawLevel.hequal (t.data x) (t.data y)).
    
    Definition hash (x : t) : Z := t.hash x.
    
    Definition hashcons (function_parameter : unit) : t -&gt; t :=
      let '_ := function_parameter in
      fun x =&gt;
        let data' := RawLevel.hcons (t.data x) in
        if Stdlib.op_eqeq (t.data x) data' then
          x
        else
          t.with_data x data'.
  End Self.
  
  Definition hcons : Self.t -&gt; Self.t :=
    let H :=
      Hashcons.Make
        (existT _ [_, _]
          {|
            Hashcons.HashconsedType.hashcons :=
              (|Self|).(Hashcons.HashconsedType.hashcons);
            Hashcons.HashconsedType.eq := (|Self|).(Hashcons.HashconsedType.eq);
            Hashcons.HashconsedType.hash :=
              (|Self|).(Hashcons.HashconsedType.hash)
          |}) in
    Hashcons.simple_hcons (|H|).(Hashcons.S.generate) (|H|).(Hashcons.S.hcons)
      tt.
  
  Definition make (l : RawLevel.t) : (|Self|).(Hashcons.HashconsedType.t) :=
    hcons {| t.hash := RawLevel.hash l; t.data := l |}.
  
  Definition set : (|Self|).(Hashcons.HashconsedType.t) := make __Set.
  
  Definition prop : (|Self|).(Hashcons.HashconsedType.t) := make Prop.
  
  Definition sprop : (|Self|).(Hashcons.HashconsedType.t) := make SProp.
  
  Definition is_small (x : t) : bool :=
    match data x with
    | Level _ =&gt; false
    | Var _ =&gt; false
    | SProp =&gt; true
    | Prop =&gt; true
    | __Set =&gt; true
    end.
  
  Definition is_prop (x : t) : bool :=
    match data x with
    | Prop =&gt; true
    | _ =&gt; false
    end.
  
  Definition is_set (x : t) : bool :=
    match data x with
    | __Set =&gt; true
    | _ =&gt; false
    end.
  
  Definition is_sprop (x : t) : bool :=
    match data x with
    | SProp =&gt; true
    | _ =&gt; false
    end.
  
  Definition compare (u : t) (v : t) : Z :=
    if Stdlib.op_eqeq u v then
      0
    else
      RawLevel.compare (data u) (data v).
  
  Definition to_string (x : t) : string :=
    match data x with
    | SProp =&gt; &quot;SProp&quot;
    | Prop =&gt; &quot;Prop&quot;
    | __Set =&gt; &quot;Set&quot;
    | Level (d, n) =&gt;
      String.append (Names.DirPath.to_string d)
        (String.append &quot;.&quot; (OCaml.Stdlib.string_of_int n))
    | Var n =&gt;
      String.append &quot;Var(&quot; (String.append (OCaml.Stdlib.string_of_int n) &quot;)&quot;)
    end.
  
  Definition pr (u : t) : Pp.t := str (to_string u).
  
  Definition apart (u : t) (v : t) : bool :=
    match ((data u), (data v)) with
    | (SProp, _) | (_, SProp) | (Prop, __Set) | (__Set, Prop) =&gt; true
    | _ =&gt; false
    end.
  
  Definition vars : array (|Self|).(Hashcons.HashconsedType.t) :=
    (|Util.Array|).(CArray.ExtS.init) 20 (fun i =&gt; make (Var i)).
  
  Definition var (n : Z) : (|Self|).(Hashcons.HashconsedType.t) :=
    if OCaml.Stdlib.lt n 20 then
      (|Util.Array|).(CArray.ExtS.get) vars n
    else
      make (Var n).
  
  Definition var_index (u : t) : option Z :=
    match data u with
    | Var n =&gt; Some n
    | _ =&gt; None
    end.
  
  Definition make (qid : UGlobal.t) : (|Self|).(Hashcons.HashconsedType.t) :=
    make (Level qid).
  
  Definition name (u : t) : option (Names.DirPath.t * Z) :=
    match data u with
    | Level (d, n) =&gt; Some (d, n)
    | _ =&gt; None
    end.
End Level.

Module LMap.
  Definition M :=
    HMap.Make
      (existT _ _
        {|
          HMap.HashedType.compare := Level.compare;
          HMap.HashedType.hash := Level.hash
        |}).
  
  Definition key := (|M|).(Util.Map.ExtS.key).
  
  Definition t := (|M|).(Util.Map.ExtS.t).
  
  Definition empty := (|M|).(Util.Map.ExtS.empty).
  
  Definition is_empty := (|M|).(Util.Map.ExtS.is_empty).
  
  Definition mem := (|M|).(Util.Map.ExtS.mem).
  
  Definition add := (|M|).(Util.Map.ExtS.add).
  
  Definition singleton := (|M|).(Util.Map.ExtS.singleton).
  
  Definition remove := (|M|).(Util.Map.ExtS.remove).
  
  Definition merge := (|M|).(Util.Map.ExtS.merge).
  
  Definition union := (|M|).(Util.Map.ExtS.union).
  
  Definition compare := (|M|).(Util.Map.ExtS.compare).
  
  Definition equal := (|M|).(Util.Map.ExtS.equal).
  
  Definition iter := (|M|).(Util.Map.ExtS.iter).
  
  Definition fold := (|M|).(Util.Map.ExtS.fold).
  
  Definition for_all := (|M|).(Util.Map.ExtS.for_all).
  
  Definition __exists := (|M|).(Util.Map.ExtS.__exists).
  
  Definition filter := (|M|).(Util.Map.ExtS.filter).
  
  Definition partition := (|M|).(Util.Map.ExtS.partition).
  
  Definition cardinal := (|M|).(Util.Map.ExtS.cardinal).
  
  Definition bindings := (|M|).(Util.Map.ExtS.bindings).
  
  Definition min_binding := (|M|).(Util.Map.ExtS.min_binding).
  
  Definition max_binding := (|M|).(Util.Map.ExtS.max_binding).
  
  Definition choose := (|M|).(Util.Map.ExtS.choose).
  
  Definition split := (|M|).(Util.Map.ExtS.split).
  
  Definition find := (|M|).(Util.Map.ExtS.find).
  
  Definition find_opt := (|M|).(Util.Map.ExtS.find_opt).
  
  Definition map := (|M|).(Util.Map.ExtS.map).
  
  Definition mapi := (|M|).(Util.Map.ExtS.mapi).
  
  Definition get := (|M|).(Util.Map.ExtS.get).
  
  Definition set := (|M|).(Util.Map.ExtS.set).
  
  Definition modify := (|M|).(Util.Map.ExtS.modify).
  
  Definition domain := (|M|).(Util.Map.ExtS.domain).
  
  Definition bind := (|M|).(Util.Map.ExtS.bind).
  
  Definition fold_left := (|M|).(Util.Map.ExtS.fold_left).
  
  Definition fold_right := (|M|).(Util.Map.ExtS.fold_right).
  
  Definition height := (|M|).(Util.Map.ExtS.height).
  
  Definition filter_range := (|M|).(Util.Map.ExtS.filter_range).
  
  Definition update := (|M|).(Util.Map.ExtS.update).
  
  Definition lunion {A : Set} (l : t A) (r : t A) : t A :=
    union (fun _k =&gt; fun l =&gt; fun _r =&gt; Some l) l r.
  
  Definition subst_union {A : Set} (l : t (option A)) (r : t (option A))
    : t (option A) :=
    union
      (fun _k =&gt;
        fun l =&gt;
          fun r =&gt;
            match (l, r) with
            | (Some _, _) =&gt; Some l
            | (None, None) =&gt; Some l
            | (_, _) =&gt; Some r
            end) l r.
  
  Definition diff {A B : Set} (ext : t A) (orig : t B) : t A :=
    fold
      (fun u =&gt;
        fun v =&gt;
          fun acc =&gt;
            if mem u orig then
              acc
            else
              add u v acc) ext empty.
  
  Definition pr {A : Set} (f : A -&gt; Pp.t) (m : t A) : Pp.t :=
    h 0
      (prlist_with_sep fnl
        (fun function_parameter =&gt;
          let '(u, v) := function_parameter in
          op_plusplus (Level.pr u) (f v)) (bindings m)).
End LMap.

Module LSet.
  Include LMap.__Set.
  
  Definition pr (prl : elt -&gt; Pp.t) (s : t) : Pp.t :=
    op_plusplus (op_plusplus (str &quot;{&quot;) (prlist_with_sep spc prl (elements s)))
      (str &quot;}&quot;).
  
  Definition of_array (l : array elt) : t :=
    (|Util.Array|).(CArray.ExtS.fold_left) (fun acc =&gt; fun x =&gt; add x acc) empty
      l.
End LSet.

Definition universe_map (a : Set) := LMap.t a.

Definition universe_level := Level.t.

Definition universe_level_subst_fn := universe_level -&gt; universe_level.

Definition universe_set := LSet.t.

Module Universe.
  Module Expr.
    Definition t := Level.t * Z.
    
    Definition ExprHash :=
      let t := Level.t * Z in
      let u := Level.t -&gt; Level.t in
      let hashcons {A B : Set} (hdir : A -&gt; A) (function_parameter : A * B)
        : A * B :=
        let '(b, n) as x := function_parameter in
        let b' := hdir b in
        if Stdlib.op_eqeq b' b then
          x
        else
          (b', n) in
      let eq {A B : Set} (l1 : A * B) (l2 : A * B) : bool :=
        orb (Stdlib.op_eqeq l1 l2)
          (let '((b, n), (b', n')) := (l1, l2) in
          andb (Stdlib.op_eqeq b b') (Stdlib.op_eqeq n n')) in
      let hash (function_parameter : Level.t * Z) : Z :=
        let '(x, n) := function_parameter in
        Z.add n (Level.hash x) in
      existT (fun _ =&gt; _) tt
        {|
          Hashcons.HashconsedType.hashcons {_ _} := hashcons;
          Hashcons.HashconsedType.eq {_ _} := eq;
          Hashcons.HashconsedType.hash := hash
        |}.
    
    Definition H :=
      Hashcons.Make
        (existT _ [_, _]
          {|
            Hashcons.HashconsedType.hashcons :=
              (|ExprHash|).(Hashcons.HashconsedType.hashcons);
            Hashcons.HashconsedType.eq :=
              (|ExprHash|).(Hashcons.HashconsedType.eq);
            Hashcons.HashconsedType.hash :=
              (|ExprHash|).(Hashcons.HashconsedType.hash)
          |}).
    
    Definition hcons : (|H|).(Hashcons.S.t) -&gt; (|H|).(Hashcons.S.t) :=
      Hashcons.simple_hcons (|H|).(Hashcons.S.generate) (|H|).(Hashcons.S.hcons)
        Level.hcons.
    
    Definition make {A : Set} (l : A) : A * Z := (l, 0).
    
    Definition compare (u : Level.t * Int.t) (v : Level.t * Int.t) : Z :=
      if Stdlib.op_eqeq u v then
        0
      else
        in
        if Int.equal n n' then
          Level.compare x x'
        else
          Z.sub n n'.
    
    Definition sprop : (|H|).(Hashcons.S.t) := hcons (Level.sprop, 0).
    
    Definition prop : (|H|).(Hashcons.S.t) := hcons (Level.prop, 0).
    
    Definition set : (|H|).(Hashcons.S.t) := hcons (Level.set, 0).
    
    Definition type1 : (|H|).(Hashcons.S.t) := hcons (Level.set, 1).
    
    Definition is_small (function_parameter : Level.t * Z) : bool :=
      match function_parameter with
      | (l, 0) =&gt; Level.is_small l
      | _ =&gt; false
      end.
    
    Definition equal (x : Level.t * Int.t) (y : Level.t * Int.t) : bool :=
      orb (Stdlib.op_eqeq x y)
        ( in
        andb (Int.equal n n') (Level.equal u v)).
    
    Definition hash : Level.t * Z -&gt; Z :=
      (|ExprHash|).(Hashcons.HashconsedType.hash).
    
    Definition leq {A : Set} (function_parameter : Level.t * A)
      : Level.t * A -&gt; bool :=
      let '(u, n) := function_parameter in
      fun function_parameter =&gt;
        let '(v, n') := function_parameter in
        let cmp := Level.compare u v in
        if Int.equal cmp 0 then
          OCaml.Stdlib.le n n'
        else
          if OCaml.Stdlib.le n n' then
            andb (Level.is_prop u) (negb (Level.is_sprop v))
          else
            false.
    
    Definition successor (function_parameter : Level.t * Z)
      : (|H|).(Hashcons.S.t) :=
      let '(u, n) := function_parameter in
      if Level.is_small u then
        type1
      else
        (u, (Z.add n 1)).
    
    Definition addn
      (k : Z)
      (function_parameter : (|Level.Self|).(Hashcons.HashconsedType.t) * Z)
      : (|Level.Self|).(Hashcons.HashconsedType.t) * Z :=
      let '(u, n) as x := function_parameter in
      if equiv_decb k 0 then
        x
      else
        if Level.is_small u then
          (Level.set, (Z.add n k))
        else
          (u, (Z.add n k)).
    
    Inductive super_result : Set :=
    | SuperSame : bool -&gt; super_result
    | SuperDiff : Z -&gt; super_result.
    
    Definition super (function_parameter : Level.t * Z)
      : Level.t * Z -&gt; super_result :=
      let '(u, n) := function_parameter in
      fun function_parameter =&gt;
        let '(v, n') := function_parameter in
        let cmp := Level.compare u v in
        if Int.equal cmp 0 then
          SuperSame (OCaml.Stdlib.lt n n')
        else
          match ((Level.data u), n, (Level.data v), n') with
          |
            (RawLevel.SProp, _, RawLevel.SProp, _) |
            (RawLevel.Prop, _, RawLevel.Prop, _) =&gt;
            SuperSame (OCaml.Stdlib.lt n n')
          | (RawLevel.SProp, 0, RawLevel.Prop, 0) =&gt; SuperSame true
          | (RawLevel.Prop, 0, RawLevel.SProp, 0) =&gt; SuperSame false
          | (RawLevel.SProp | RawLevel.Prop, 0, _, _) =&gt; SuperSame true
          | (_, _, RawLevel.SProp | RawLevel.Prop, 0) =&gt; SuperSame false
          | (_, _, _, _) =&gt; SuperDiff cmp
          end.
    
    Definition to_string (function_parameter : Level.t * Int.t) : string :=
      let '(v, n) := function_parameter in
      if Int.equal n 0 then
        Level.to_string v
      else
        String.append (Level.to_string v)
          (String.append &quot;+&quot; (OCaml.Stdlib.string_of_int n)).
    
    Definition pr (x : Level.t * Int.t) : Pp.t := str (to_string x).
    
    Definition pr_with {A : Set}
      (f : A -&gt; Pp.t) (function_parameter : A * Int.t) : Pp.t :=
      let '(v, n) := function_parameter in
      if Int.equal n 0 then
        f v
      else
        op_plusplus (op_plusplus (f v) (str &quot;+&quot;)) (int n).
    
    Definition is_level {A : Set} (function_parameter : A * Z) : bool :=
      match function_parameter with
      | (_v, 0) =&gt; true
      | _ =&gt; false
      end.
    
    Definition level {A : Set} (function_parameter : A * Z) : option A :=
      match function_parameter with
      | (v, 0) =&gt; Some v
      | _ =&gt; None
      end.
    
    Definition get_level {A B : Set} (function_parameter : A * B) : A :=
      let '(v, _n) := function_parameter in
      v.
    
    Definition map
      (f :
        (|Level.Self|).(Hashcons.HashconsedType.t) -&gt;
        (|Level.Self|).(Hashcons.HashconsedType.t))
      (function_parameter : (|Level.Self|).(Hashcons.HashconsedType.t) * Z)
      : (|Level.Self|).(Hashcons.HashconsedType.t) * Z :=
      let '(v, n) as x := function_parameter in
      let v' := f v in
      if Stdlib.op_eqeq v' v then
        x
      else
        if andb (Level.is_prop v') (Stdlib.op_exclamationeq n 0) then
          (Level.set, n)
        else
          (v', n).
  End Expr.
  
  Definition t := list Expr.t.
  
  Definition tip {A : Set} (l : A) : list A := [ l ].
  
  Definition cons {A : Set} (x : A) (l : list A) : list A := cons x l.
  
  Fixpoint hash (function_parameter : list (Level.t * Z))
    {struct function_parameter} : Z :=
    match function_parameter with
    | [] =&gt; 0
    | cons e l =&gt;
      Hashset.Combine.combinesmall
        ((|Expr.ExprHash|).(Hashcons.HashconsedType.hash) e) (hash l)
    end.
  
  Definition equal (x : list (Level.t * Int.t)) (y : list (Level.t * Int.t))
    : bool :=
    orb (Stdlib.op_eqeq x y) ((|Util.List|).(CList.ExtS.equal) Expr.equal x y).
  
  Definition compare (x : list (Level.t * Int.t)) (y : list (Level.t * Int.t))
    : Z :=
    if Stdlib.op_eqeq x y then
      0
    else
      (|Util.List|).(CList.ExtS.compare) Expr.compare x y.
  
  Definition Huniv :=
    Hashcons.Hlist
      (existT _ _
        {|
          Hashcons.HashedType.hash := Expr.hash
        |}).
  
  Definition hcons : (|Huniv|).(Hashcons.S.t) -&gt; (|Huniv|).(Hashcons.S.t) :=
    Hashcons.recursive_hcons (|Huniv|).(Hashcons.S.generate)
      (|Huniv|).(Hashcons.S.hcons) Expr.hcons.
  
  Definition make {A : Set} (l : A) : list (A * Z) := tip (Expr.make l).
  
  Definition tip {A : Set} (x : A) : list A := tip x.
  
  Definition pr (l : list (Level.t * Int.t)) : Pp.t :=
    match l with
    | cons u [] =&gt; Expr.pr u
    | _ =&gt;
      op_plusplus
        (op_plusplus (str &quot;max(&quot;) (hov 0 (prlist_with_sep pr_comma Expr.pr l)))
        (str &quot;)&quot;)
    end.
  
  Definition pr_with {A : Set} (f : A -&gt; Pp.t) (l : list (A * Int.t)) : Pp.t :=
    match l with
    | cons u [] =&gt; Expr.pr_with f u
    | _ =&gt;
      op_plusplus
        (op_plusplus (str &quot;max(&quot;)
          (hov 0 (prlist_with_sep pr_comma (Expr.pr_with f) l))) (str &quot;)&quot;)
    end.
  
  Definition is_level {A : Set} (l : list (A * Z)) : bool :=
    match l with
    | cons l [] =&gt; Expr.is_level l
    | _ =&gt; false
    end.
  
  Fixpoint is_levels {A : Set} (l : list (A * Z)) {struct l} : bool :=
    match l with
    | cons l r =&gt; andb (Expr.is_level l) (is_levels r)
    | [] =&gt; true
    end.
  
  Definition level {A : Set} (l : list (A * Z)) : option A :=
    match l with
    | cons l [] =&gt; Expr.level l
    | _ =&gt; None
    end.
  
  Definition levels {A : Set} (l : list (LSet.elt * A)) : LSet.t :=
    (|Util.List|).(CList.ExtS.fold_left)
      (fun acc =&gt; fun x =&gt; LSet.add (Expr.get_level x) acc) LSet.empty l.
  
  Definition is_small (u : list (Level.t * Z)) : bool :=
    match u with
    | cons l [] =&gt; Expr.is_small l
    | _ =&gt; false
    end.
  
  Definition sprop : list (|Expr.H|).(Hashcons.S.t) := tip Expr.sprop.
  
  Definition type0m : list (|Expr.H|).(Hashcons.S.t) := tip Expr.prop.
  
  Definition type0 : list (|Expr.H|).(Hashcons.S.t) := tip Expr.set.
  
  Definition type1 : list (|Expr.H|).(Hashcons.S.t) := tip Expr.type1.
  
  Definition is_sprop (x : list (|Expr.H|).(Hashcons.S.t)) : bool :=
    equal sprop x.
  
  Definition is_type0m (x : list (|Expr.H|).(Hashcons.S.t)) : bool :=
    equal type0m x.
  
  Definition is_type0 (x : list (|Expr.H|).(Hashcons.S.t)) : bool :=
    equal type0 x.
  
  Definition super (l : list (|Expr.H|).(Hashcons.S.t))
    : list (|Expr.H|).(Hashcons.S.t) :=
    if is_small l then
      type1
    else
      List.Smart.map (fun x =&gt; Expr.successor x) l.
  
  Definition addn
    (n : Z) (l : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z))
    : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z) :=
    List.Smart.map (fun x =&gt; Expr.addn n x) l.
  
  Fixpoint merge_univs (l1 : list (Level.t * Z)) (l2 : list (Level.t * Z))
    {struct l1} : list (Level.t * Z) :=
    match (l1, l2) with
    | ([], _) =&gt; l2
    | (_, []) =&gt; l1
    | (cons h1 t1, cons h2 t2) =&gt;
      match super h1 h2 with
      | Expr.SuperSame true =&gt; merge_univs t1 l2
      | Expr.SuperSame false =&gt; merge_univs l1 t2
      | Expr.SuperDiff c =&gt;
        if OCaml.Stdlib.le c 0 then
          cons h1 (merge_univs t1 l2)
        else
          cons h2 (merge_univs l1 t2)
      end
    end.
  
  Definition sort (u : list (Level.t * Z)) : list (Level.t * Z) :=
    let fix aux (a : Level.t * Z) (l : list (Level.t * Z)) {struct a}
      : list (Level.t * Z) :=
      match l with
      | cons b l' =&gt;
        match super a b with
        | Expr.SuperSame false =&gt; aux a l'
        | Expr.SuperSame true =&gt; l
        | Expr.SuperDiff c =&gt;
          if OCaml.Stdlib.le c 0 then
            cons a l
          else
            cons b (aux a l')
        end
      | [] =&gt; cons a l
      end in
    (|Util.List|).(CList.ExtS.fold_right) (fun a =&gt; fun acc =&gt; aux a acc) u [].
  
  Definition sup (x : list (Level.t * Z)) (y : list (Level.t * Z))
    : list (Level.t * Z) := merge_univs x y.
  
  Definition empty {A : Set} : list A := [].
  
  Definition __exists {A : Set} : (A -&gt; bool) -&gt; list A -&gt; bool :=
    (|Util.List|).(CList.ExtS.__exists).
  
  Definition for_all {A : Set} : (A -&gt; bool) -&gt; list A -&gt; bool :=
    (|Util.List|).(CList.ExtS.for_all).
  
  Definition smart_map {A : Set} : (A -&gt; A) -&gt; list A -&gt; list A :=
    List.Smart.map.
  
  Definition map {A B : Set} : (A -&gt; B) -&gt; list A -&gt; list B :=
    (|Util.List|).(CList.ExtS.map).
End Universe.

Definition universe := Universe.t.

Definition type0m_univ : list (|Universe.Expr.H|).(Hashcons.S.t) :=
  Universe.type0m.

Definition type0_univ : list (|Universe.Expr.H|).(Hashcons.S.t) :=
  Universe.type0.

Definition type1_univ : list (|Universe.Expr.H|).(Hashcons.S.t) :=
  Universe.type1.

Definition is_type0m_univ : list (|Universe.Expr.H|).(Hashcons.S.t) -&gt; bool :=
  Universe.is_type0m.

Definition is_type0_univ : list (|Universe.Expr.H|).(Hashcons.S.t) -&gt; bool :=
  Universe.is_type0.

Definition is_univ_variable {A : Set} (l : list (A * Z)) : bool :=
  Stdlib.op_exclamationeq (Universe.level l) None.

Definition is_small_univ : list (Level.t * Z) -&gt; bool := Universe.is_small.

Definition pr_uni : list (Level.t * Int.t) -&gt; Pp.t := Universe.pr.

Definition sup
  : list (Level.t * Z) -&gt; list (Level.t * Z) -&gt; list (Level.t * Z) :=
  Universe.sup.

Definition super
  : list (|Universe.Expr.H|).(Hashcons.S.t) -&gt;
  list (|Universe.Expr.H|).(Hashcons.S.t) := Universe.super.

Import Universe.

Definition universe_level {A : Set} : list (A * Z) -&gt; option A := Universe.level.

Inductive constraint_type : Set :=
| Lt : constraint_type
| Le : constraint_type
| Eq : constraint_type.

Definition explanation := list (constraint_type * Level.t).

Definition constraint_type_ord (c1 : constraint_type) (c2 : constraint_type)
  : Z :=
  match (c1, c2) with
  | (Lt, Lt) =&gt; 0
  | (Lt, _) =&gt; (-1)
  | (Le, Lt) =&gt; 1
  | (Le, Le) =&gt; 0
  | (Le, Eq) =&gt; (-1)
  | (Eq, Eq) =&gt; 0
  | (Eq, _) =&gt; 1
  end.

Definition univ_inconsistency :=
  constraint_type * universe * universe * option (Stdlib.Lazy.t explanation).

(* ❌ The definition of exceptions is not handled. *)
(* exception UniverseInconsistency *)

Definition error_inconsistency {A : Set}
  (o : constraint_type) (u : Level.t) (v : Level.t)
  (p : option (Stdlib.Lazy.t explanation)) : A :=
  Stdlib.raise extensible_type_value.

Definition univ_constraint := Level.t * constraint_type * Level.t.

Definition pr_constraint_type (op : constraint_type) : Pp.t :=
  let op_str :=
    match op with
    | Lt =&gt; &quot; &lt; &quot;
    | Le =&gt; &quot; &lt;= &quot;
    | Eq =&gt; &quot; = &quot;
    end in
  str op_str.

Definition UConstraintOrd :=
  let t := univ_constraint in
  let compare (function_parameter : Level.t * constraint_type * Level.t)
    : Level.t * constraint_type * Level.t -&gt; Z :=
    let '(u, c, v) := function_parameter in
    fun function_parameter =&gt;
      let '(u', c', v') := function_parameter in
      let i := constraint_type_ord c c' in
      if negb (Int.equal i 0) then
        i
      else
        let i' := Level.compare u u' in
        if negb (Int.equal i' 0) then
          i'
        else
          Level.compare v v' in
  existT (fun _ =&gt; _) tt
    {|
      Util.__Set.OrderedType.compare := compare
    |}.

Module Constraint.
  Definition S :=
    __Set.Make
      (existT _ _
        {|
          Util.__Set.OrderedType.compare :=
            (|UConstraintOrd|).(Util.__Set.OrderedType.compare)
        |}).
  
  Include S.
  
  Definition pr (prl : Level.t -&gt; Pp.t) (c : t) : Pp.t :=
    v 0
      (prlist_with_sep spc
        (fun function_parameter =&gt;
          let '(u1, op, u2) := function_parameter in
          hov 0
            (op_plusplus (op_plusplus (prl u1) (pr_constraint_type op)) (prl u2)))
        (elements c)).
End Constraint.

Definition empty_constraint : Constraint.t := Constraint.empty.

Definition union_constraint : Constraint.t -&gt; Constraint.t -&gt; Constraint.t :=
  Constraint.union.

Definition eq_constraint : Constraint.t -&gt; Constraint.t -&gt; bool :=
  Constraint.equal.

Definition constraints := Constraint.t.

Definition Hconstraint :=
  Hashcons.Make
    (let t := univ_constraint in
    let u := universe_level -&gt; universe_level in
    let hashcons {A B C : Set} (hul : A -&gt; B) (function_parameter : A * C * A)
      : B * C * B :=
      let '(l1, k, l2) := function_parameter in
      ((hul l1), k, (hul l2)) in
    let eq {A B C : Set} (function_parameter : A * B * C) : A * B * C -&gt; bool :=
      let '(l1, k, l2) := function_parameter in
      fun function_parameter =&gt;
        let '(l1', k', l2') := function_parameter in
        andb (Stdlib.op_eqeq l1 l1')
          (andb (Stdlib.op_eqeq k k') (Stdlib.op_eqeq l2 l2')) in
    let hash := Hashtbl.hash in
    existT _ [_, _]
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}).

Definition Hconstraints :=
  Hashcons.Make
    (let t := constraints in
    let u := univ_constraint -&gt; univ_constraint in
    let hashcons (huc : Constraint.elt -&gt; Constraint.elt) (s : Constraint.t)
      : Constraint.t :=
      Constraint.fold (fun x =&gt; Constraint.add (huc x)) s Constraint.empty in
    let eq (s : Constraint.t) (s' : Constraint.t) : bool :=
      (|Util.List|).(CList.ExtS.for_all2eq) Stdlib.op_eqeq
        (Constraint.elements s) (Constraint.elements s') in
    let hash := Hashtbl.hash in
    existT _ [_, _]
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}).

Definition hcons_constraint
  : (|Hconstraint|).(Hashcons.S.t) -&gt; (|Hconstraint|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|Hconstraint|).(Hashcons.S.generate)
    (|Hconstraint|).(Hashcons.S.hcons) Level.hcons.

Definition hcons_constraints
  : (|Hconstraints|).(Hashcons.S.t) -&gt; (|Hconstraints|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|Hconstraints|).(Hashcons.S.generate)
    (|Hconstraints|).(Hashcons.S.hcons) hcons_constraint.

Definition constrained (a : Set) := a * constraints.

Definition constraints_of {A B : Set} (function_parameter : A * B) : B :=
  let '(_, cst) := function_parameter in
  cst.

Definition constraint_function (a : Set) :=
  a -&gt; a -&gt; constraints -&gt; constraints.

Definition enforce_eq_level (u : Level.t) (v : Level.t) (c : Constraint.t)
  : Constraint.t :=
  if Level.equal u v then
    c
  else
    if Level.apart u v then
      error_inconsistency Eq u v None
    else
      Constraint.add (u, Eq, v) c.

Definition enforce_eq
  (u : list (Level.t * Z)) (v : list (Level.t * Z)) (c : Constraint.t)
  : Constraint.t :=
  match ((Universe.level u), (Universe.level v)) with
  | (Some u, Some v) =&gt; enforce_eq_level u v c
  | _ =&gt;
    anomaly None None
      (Pp.str &quot;A universe comparison can only happen between variables.&quot;)
  end.

Definition check_univ_eq
  (u : list (Level.t * Int.t)) (v : list (Level.t * Int.t)) : bool :=
  Universe.equal u v.

Definition enforce_eq
  (u : list (Level.t * Int.t)) (v : list (Level.t * Int.t)) (c : Constraint.t)
  : Constraint.t :=
  if check_univ_eq u v then
    c
  else
    enforce_eq u v c.

Definition constraint_add_leq
  (v : Universe.Expr.t) (u : Universe.Expr.t) (c : Constraint.t)
  : Constraint.t :=
  if Expr.equal v u then
    c
  else
    let '((x, n), (y, m)) := (v, u) in
    let j := Z.sub m n in
    if equiv_decb j (-1) then
      Constraint.add (x, Lt, y) c
    else
      if OCaml.Stdlib.le j (-1) then
        if Level.equal x y then
          Stdlib.raise extensible_type_value
        else
          anomaly None None
            (Pp.str &quot;Unable to handle arbitrary u+k &lt;= v constraints.&quot;)
      else
        if equiv_decb j 0 then
          Constraint.add (x, Le, y) c
        else
          if Level.equal x y then
            c
          else
            if Level.is_small x then
              c
            else
              Constraint.add (x, Le, y) c.

Definition check_univ_leq_one {A : Set}
  (u : Level.t * A) (v : list (Level.t * A)) : bool :=
  Universe.__exists (Expr.leq u) v.

Definition check_univ_leq {A : Set}
  (u : list (Level.t * A)) (v : list (Level.t * A)) : bool :=
  Universe.for_all (fun u =&gt; check_univ_leq_one u v) u.

Definition enforce_leq
  (u : list (|Universe.Expr.H|).(Hashcons.S.t))
  (v : list (|Universe.Expr.H|).(Hashcons.S.t)) (c : Constraint.t)
  : Constraint.t :=
  match ((is_sprop u), (is_sprop v)) with
  | (true, true) =&gt; c
  | (true, false) | (false, true) =&gt; Stdlib.raise extensible_type_value
  | (false, false) =&gt;
    (|Util.List|).(CList.ExtS.fold_left)
      (fun c =&gt;
        fun v =&gt;
          (|Util.List|).(CList.ExtS.fold_left)
            (fun c =&gt; fun u =&gt; constraint_add_leq u v c) c u) c v
  end.

Definition enforce_leq
  (u : list (|Universe.Expr.H|).(Hashcons.S.t))
  (v : list (|Universe.Expr.H|).(Hashcons.S.t)) (c : Constraint.t)
  : Constraint.t :=
  if check_univ_leq u v then
    c
  else
    enforce_leq u v c.

Definition enforce_leq_level (u : Level.t) (v : Level.t) (c : Constraint.t)
  : Constraint.t :=
  if Level.equal u v then
    c
  else
    Constraint.add (u, Le, v) c.

Definition univ_level_mem (u : Level.t) (v : list (Level.t * Int.t)) : bool :=
  (|Util.List|).(CList.ExtS.__exists)
    (fun function_parameter =&gt;
      let '(l, n) := function_parameter in
      andb (Int.equal n 0) (Level.equal u l)) v.

Definition univ_level_rem
  (u : Level.t) (v : list (Level.t * Z)) (min : list (Level.t * Int.t))
  : list (Level.t * Int.t) :=
  match Universe.level v with
  | Some u' =&gt;
    if Level.equal u u' then
      min
    else
      v
  | None =&gt;
    (|Util.List|).(CList.ExtS.filter)
      (fun function_parameter =&gt;
        let '(l, n) := function_parameter in
        negb (andb (Int.equal n 0) (Level.equal u l))) v
  end.

Definition universe_level_subst := universe_map universe_level.

Definition universe_subst := universe_map universe.

Module Variance.
  Inductive t : Set :=
  | Irrelevant : t
  | Covariant : t
  | Invariant : t.
  
  Definition sup (x : t) (y : t) : t :=
    match (x, y) with
    | (Irrelevant, s) | (s, Irrelevant) =&gt; s
    | (Invariant, _) | (_, Invariant) =&gt; Invariant
    | (Covariant, Covariant) =&gt; Covariant
    end.
  
  Definition check_subtype (x : t) (y : t) : bool :=
    match (x, y) with
    | (Irrelevant | Covariant | Invariant, Irrelevant) =&gt; true
    | (Irrelevant, Covariant) =&gt; false
    | (Covariant | Invariant, Covariant) =&gt; true
    | (Irrelevant | Covariant, Invariant) =&gt; false
    | (Invariant, Invariant) =&gt; true
    end.
  
  Definition pr (function_parameter : t) : Pp.t :=
    match function_parameter with
    | Irrelevant =&gt; str &quot;*&quot;
    | Covariant =&gt; str &quot;+&quot;
    | Invariant =&gt; str &quot;=&quot;
    end.
  
  Definition leq_constraint
    (csts : Constraint.t) (variance : t) (u : Level.t) (u' : Level.t)
    : Constraint.t :=
    match variance with
    | Irrelevant =&gt; csts
    | Covariant =&gt; enforce_leq_level u u' csts
    | Invariant =&gt; enforce_eq_level u u' csts
    end.
  
  Definition eq_constraint
    (csts : Constraint.t) (variance : t) (u : Level.t) (u' : Level.t)
    : Constraint.t :=
    match variance with
    | Irrelevant =&gt; csts
    | Covariant | Invariant =&gt; enforce_eq_level u u' csts
    end.
  
  Definition leq_constraints
    (variance : array t) (u : array Level.t) (u' : array Level.t)
    (csts : Constraint.t) : Constraint.t :=
    let len := (|Util.Array|).(CArray.ExtS.length) u in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Util.Array|).(CArray.ExtS.fold_left3) leq_constraint csts variance u u'.
  
  Definition eq_constraints
    (variance : array t) (u : array Level.t) (u' : array Level.t)
    (csts : Constraint.t) : Constraint.t :=
    let len := (|Util.Array|).(CArray.ExtS.length) u in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Util.Array|).(CArray.ExtS.fold_left3) eq_constraint csts variance u u'.
End Variance.

(* ❌ This kind of module is not handled. *)
(* unhandled_module *)

Definition enforce_eq_instances (x : Instance.t) (y : Instance.t)
  : Constraint.t -&gt; Constraint.t :=
  let ax : array Level.t :=
    Instance.to_array x
  with ay : array Level.t :=
    Instance.to_array y in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (|CArray|).(CArray.ExtS.fold_right2) enforce_eq_level ax ay.

Definition enforce_eq_variance_instances
  : array Variance.t -&gt; array Level.t -&gt; array Level.t -&gt; Constraint.t -&gt;
  Constraint.t := Variance.eq_constraints.

Definition enforce_leq_variance_instances
  : array Variance.t -&gt; array Level.t -&gt; array Level.t -&gt; Constraint.t -&gt;
  Constraint.t := Variance.leq_constraints.

Definition subst_instance_level (s : array Level.t) (l : Level.t) : Level.t :=
  match Level.t.data l with
  | Level.Var n =&gt; (|Util.Array|).(CArray.ExtS.get) s n
  | _ =&gt; l
  end.

Definition subst_instance_instance (s : array Level.t) (i : array Level.t)
  : array Level.t := Array.Smart.map (fun l =&gt; subst_instance_level s l) i.

Definition subst_instance_universe
  (s : array (|Level.Self|).(Hashcons.HashconsedType.t))
  (u : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z))
  : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z) :=
  let f (x : (|Level.Self|).(Hashcons.HashconsedType.t) * Z)
    : (|Level.Self|).(Hashcons.HashconsedType.t) * Z :=
    Universe.Expr.map (fun u =&gt; subst_instance_level s u) x in
  let u' := Universe.smart_map f u in
  if Stdlib.op_eqeq u u' then
    u
  else
    Universe.sort u'.

Definition subst_instance_constraint {A : Set}
  (s : array Level.t) (function_parameter : Level.t * A * Level.t)
  : Level.t * A * Level.t :=
  let '(u, d, v) as c := function_parameter in
  let u' := subst_instance_level s u in
  let v' := subst_instance_level s v in
  if andb (Stdlib.op_eqeq u' u) (Stdlib.op_eqeq v' v) then
    c
  else
    (u', d, v').

Definition subst_instance_constraints (s : array Level.t) (csts : Constraint.t)
  : Constraint.t :=
  Constraint.fold
    (fun c =&gt; fun csts =&gt; Constraint.add (subst_instance_constraint s c) csts)
    csts Constraint.empty.

Definition puniverses (a : Set) := a * Instance.t.

Definition out_punivs {A B : Set} (function_parameter : A * B) : A :=
  let '(x, _y) := function_parameter in
  x.

Definition in_punivs {A : Set} (x : A) : A * Instance.t := (x, Instance.empty).

Definition eq_puniverses {A B : Set}
  (f : A -&gt; B -&gt; bool) (function_parameter : A * Instance.t)
  : B * Instance.t -&gt; bool :=
  let '(x, u) := function_parameter in
  fun function_parameter =&gt;
    let '(y, u') := function_parameter in
    andb (f x y) (Instance.equal u u').

Module UContext.
  Definition t := constrained Instance.t.
  
  Definition make {A : Set} (x : A) : A := x.
  
  Definition empty : Instance.t * Constraint.t :=
    (Instance.empty, Constraint.empty).
  
  Definition is_empty (function_parameter : Instance.t * Constraint.t) : bool :=
    let '(univs, cst) := function_parameter in
    andb (Instance.is_empty univs) (Constraint.is_empty cst).
  
  Definition pr
    (prl : Level.t -&gt; Pp.t) (variance : option (array Variance.t))
    (function_parameter : Instance.t * Constraint.t) : Pp.t :=
    let '(univs, cst) as ctx := function_parameter in
    if is_empty ctx then
      mt tt
    else
      op_plusplus
        (h 0 (op_plusplus (Instance.pr prl variance univs) (str &quot; |= &quot;)))
        (h 0 (v 0 (Constraint.pr prl cst))).
  
  Definition hcons
    (function_parameter : Instance.t * (|Hconstraints|).(Hashcons.S.t))
    : Instance.t * (|Hconstraints|).(Hashcons.S.t) :=
    let '(univs, cst) := function_parameter in
    ((Instance.hcons univs), (hcons_constraints cst)).
  
  Definition instance {A B : Set} (function_parameter : A * B) : A :=
    let '(univs, _cst) := function_parameter in
    univs.
  
  Definition constraints {A B : Set} (function_parameter : A * B) : B :=
    let '(_univs, cst) := function_parameter in
    cst.
  
  Definition union (function_parameter : Instance.t * Constraint.t)
    : Instance.t * Constraint.t -&gt; Instance.t * Constraint.t :=
    let '(univs, cst) := function_parameter in
    fun function_parameter =&gt;
      let '(univs', cst') := function_parameter in
      ((Instance.append univs univs'), (Constraint.union cst cst')).
  
  Definition dest {A : Set} (x : A) : A := x.
  
  Definition size {A : Set} (function_parameter : Instance.t * A) : Z :=
    let '(x, _) := function_parameter in
    Instance.length x.
End UContext.

Definition universe_context := UContext.t.

Definition hcons_universe_context
  : Instance.t * (|Hconstraints|).(Hashcons.S.t) -&gt;
  Instance.t * (|Hconstraints|).(Hashcons.S.t) := UContext.hcons.

Module AUContext.
  Definition t := constrained (array Names.Name.t).
  
  Definition repr {A B : Set} (function_parameter : array A * B)
    : array (|Level.Self|).(Hashcons.HashconsedType.t) * B :=
    let '(inst, cst) := function_parameter in
    (((|Util.Array|).(CArray.ExtS.init)
      ((|Util.Array|).(CArray.ExtS.length) inst) (fun i =&gt; Level.var i)), cst).
  
  Definition pr {A : Set}
    (f : Level.t -&gt; Pp.t) (variance : option (array Variance.t))
    (ctx : array A * Constraint.t) : Pp.t := UContext.pr f variance (repr ctx).
  
  Definition instantiate {A : Set}
    (inst : array Level.t) (function_parameter : array A * Constraint.t)
    : Constraint.t :=
    let '(u, cst) := function_parameter in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    subst_instance_constraints inst cst.
  
  Definition names {A B : Set} (function_parameter : A * B) : A :=
    let '(nas, _) := function_parameter in
    nas.
  
  Definition hcons
    (function_parameter : array Names.Name.t * (|Hconstraints|).(Hashcons.S.t))
    : array Names.Name.t * (|Hconstraints|).(Hashcons.S.t) :=
    let '(univs, cst) := function_parameter in
    (((|Util.Array|).(CArray.ExtS.map) Names.Name.hcons univs),
      (hcons_constraints cst)).
  
  Definition empty {A : Set} : array A * Constraint.t :=
    ((* ❌ Arrays not handled. *)
    [ ], Constraint.empty).
  
  Definition is_empty {A : Set} (function_parameter : array A * Constraint.t)
    : bool :=
    let '(nas, cst) := function_parameter in
    andb ((|Util.Array|).(CArray.ExtS.is_empty) nas) (Constraint.is_empty cst).
  
  Definition union {A : Set} (function_parameter : array A * Constraint.t)
    : array A * Constraint.t -&gt; array A * Constraint.t :=
    let '(nas, cst) := function_parameter in
    fun function_parameter =&gt;
      let '(nas', cst') := function_parameter in
      (((|Util.Array|).(CArray.ExtS.append) nas nas'),
        (Constraint.union cst cst')).
  
  Definition size {A B : Set} (function_parameter : array A * B) : Z :=
    let '(nas, _) := function_parameter in
    (|Util.Array|).(CArray.ExtS.length) nas.
End AUContext.

Module univ_abstracted.
  Record record {a : Set} := {
    univ_abstracted_value : a;
    univ_abstracted_binder : AUContext.t }.
  Arguments record : clear implicits.
  Definition with_univ_abstracted_value {a_type : Set} (r : record a_type)
    univ_abstracted_value : record a_type :=
    {| univ_abstracted_value := univ_abstracted_value;
      univ_abstracted_binder := univ_abstracted_binder r |}.
  Definition with_univ_abstracted_binder {a_type : Set} (r : record a_type)
    univ_abstracted_binder : record a_type :=
    {| univ_abstracted_value := univ_abstracted_value r;
      univ_abstracted_binder := univ_abstracted_binder |}.
End univ_abstracted.
Definition univ_abstracted := univ_abstracted.record.

Definition map_univ_abstracted {A B : Set}
  (f : A -&gt; B) (function_parameter : univ_abstracted A) : univ_abstracted B :=
  let '{|
    univ_abstracted.univ_abstracted_value := univ_abstracted_value;
      univ_abstracted.univ_abstracted_binder := univ_abstracted_binder
      |} := function_parameter in
  let univ_abstracted_value := f univ_abstracted_value in
  {| univ_abstracted.univ_abstracted_value := univ_abstracted_value;
    univ_abstracted.univ_abstracted_binder := univ_abstracted_binder |}.

Definition hcons_abstract_universe_context
  : array Names.Name.t * (|Hconstraints|).(Hashcons.S.t) -&gt;
  array Names.Name.t * (|Hconstraints|).(Hashcons.S.t) := AUContext.hcons.

Module ContextSet.
  Definition t := constrained universe_set.
  
  Definition empty : LSet.t * Constraint.t := (LSet.empty, Constraint.empty).
  
  Definition is_empty (function_parameter : LSet.t * Constraint.t) : bool :=
    let '(univs, cst) := function_parameter in
    andb (LSet.is_empty univs) (Constraint.is_empty cst).
  
  Definition equal (function_parameter : LSet.t * Constraint.t)
    : LSet.t * Constraint.t -&gt; bool :=
    let '(univs, cst) as x := function_parameter in
    fun function_parameter =&gt;
      let '(univs', cst') as y := function_parameter in
      orb (Stdlib.op_eqeq x y)
        (andb (LSet.equal univs univs') (Constraint.equal cst cst')).
  
  Definition of_set {A : Set} (s : A) : A * Constraint.t :=
    (s, Constraint.empty).
  
  Definition singleton (l : LSet.elt) : LSet.t * Constraint.t :=
    of_set (LSet.singleton l).
  
  Definition of_instance (i : Instance.t) : LSet.t * Constraint.t :=
    of_set (Instance.levels i).
  
  Definition union (function_parameter : LSet.t * Constraint.t)
    : LSet.t * Constraint.t -&gt; LSet.t * Constraint.t :=
    let '(univs, cst) as x := function_parameter in
    fun function_parameter =&gt;
      let '(univs', cst') as y := function_parameter in
      if Stdlib.op_eqeq x y then
        x
      else
        ((LSet.union univs univs'), (Constraint.union cst cst')).
  
  Definition append (function_parameter : LSet.t * Constraint.t)
    : LSet.t * Constraint.t -&gt; LSet.t * Constraint.t :=
    let '(univs, cst) := function_parameter in
    fun function_parameter =&gt;
      let '(univs', cst') := function_parameter in
      let univs := LSet.fold LSet.add univs univs' in
      let cst := Constraint.fold Constraint.add cst cst' in
      (univs, cst).
  
  Definition diff (function_parameter : LSet.t * Constraint.t)
    : LSet.t * Constraint.t -&gt; LSet.t * Constraint.t :=
    let '(univs, cst) := function_parameter in
    fun function_parameter =&gt;
      let '(univs', cst') := function_parameter in
      ((LSet.diff univs univs'), (Constraint.diff cst cst')).
  
  Definition add_universe {A : Set}
    (u : LSet.elt) (function_parameter : LSet.t * A) : LSet.t * A :=
    let '(univs, cst) := function_parameter in
    ((LSet.add u univs), cst).
  
  Definition add_constraints {A : Set}
    (cst' : Constraint.t) (function_parameter : A * Constraint.t)
    : A * Constraint.t :=
    let '(univs, cst) := function_parameter in
    (univs, (Constraint.union cst cst')).
  
  Definition add_instance {A : Set}
    (inst : Instance.t) (function_parameter : LSet.t * A) : LSet.t * A :=
    let '(univs, cst) := function_parameter in
    let v := Instance.to_array inst in
    let fold (accu : LSet.t) (u : LSet.elt) : LSet.t :=
      LSet.add u accu in
    let univs := (|Util.Array|).(CArray.ExtS.fold_left) fold univs v in
    (univs, cst).
  
  Definition sort_levels (a : array Level.t) : array Level.t :=
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    a.
  
  Definition to_context {A : Set} (function_parameter : LSet.t * A)
    : Instance.t * A :=
    let '(ctx, cst) := function_parameter in
    ((Instance.of_array
      (sort_levels ((|Util.Array|).(CArray.ExtS.of_list) (LSet.elements ctx)))),
      cst).
  
  Definition of_context {A : Set} (function_parameter : Instance.t * A)
    : LSet.t * A :=
    let '(ctx, cst) := function_parameter in
    ((Instance.levels ctx), cst).
  
  Definition pr
    (prl : LSet.elt -&gt; Pp.t) (function_parameter : LSet.t * Constraint.t)
    : Pp.t :=
    let '(univs, cst) as ctx := function_parameter in
    if is_empty ctx then
      mt tt
    else
      op_plusplus (h 0 (op_plusplus (LSet.pr prl univs) (str &quot; |= &quot;)))
        (h 0 (v 0 (Constraint.pr prl cst))).
  
  Definition constraints {A B : Set} (function_parameter : A * B) : B :=
    let '(_univs, cst) := function_parameter in
    cst.
  
  Definition levels {A B : Set} (function_parameter : A * B) : A :=
    let '(univs, _cst) := function_parameter in
    univs.
  
  Definition size {A : Set} (function_parameter : LSet.t * A) : Z :=
    let '(univs, _) := function_parameter in
    LSet.cardinal univs.
End ContextSet.

Definition universe_context_set := ContextSet.t.

Definition in_universe_context (a : Set) := a * universe_context.

Definition in_universe_context_set (a : Set) := a * universe_context_set.

Definition extend_in_context_set {A : Set}
  (function_parameter : A * (LSet.t * Constraint.t))
  : LSet.t * Constraint.t -&gt; A * (LSet.t * Constraint.t) :=
  let '(a, ctx) := function_parameter in
  fun ctx' =&gt; (a, (ContextSet.union ctx ctx')).

Definition empty_subst {A : Set} : LMap.t A := LMap.empty.

Definition is_empty_subst {A : Set} : LMap.t A -&gt; bool := LMap.is_empty.

Definition empty_level_subst {A : Set} : LMap.t A := LMap.empty.

Definition is_empty_level_subst {A : Set} : LMap.t A -&gt; bool := LMap.is_empty.

Definition subst_univs_level_level (subst : LMap.t LMap.key) (l : LMap.key)
  : LMap.key :=
  (* ❌ Try-with are not handled *)
  try (LMap.find l subst).

Definition subst_univs_level_universe
  (subst : LMap.t LMap.key)
  (u : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z))
  : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z) :=
  let f (x : (|Level.Self|).(Hashcons.HashconsedType.t) * Z)
    : (|Level.Self|).(Hashcons.HashconsedType.t) * Z :=
    Universe.Expr.map (fun u =&gt; subst_univs_level_level subst u) x in
  let u' := Universe.smart_map f u in
  if Stdlib.op_eqeq u u' then
    u
  else
    Universe.sort u'.

Definition subst_univs_level_instance (subst : LMap.t LMap.key) (i : Instance.t)
  : Instance.t :=
  let i' := Instance.subst_fn (subst_univs_level_level subst) i in
  if Stdlib.op_eqeq i i' then
    i
  else
    i'.

Definition subst_univs_level_constraint
  (subst : LMap.t LMap.key)
  (function_parameter : LMap.key * constraint_type * LMap.key)
  : option (LMap.key * constraint_type * LMap.key) :=
  let '(u, d, v) := function_parameter in
  let u' : LMap.key :=
    subst_univs_level_level subst u
  with v' : LMap.key :=
    subst_univs_level_level subst v in
  if andb (Stdlib.op_exclamationeq d Lt) (Level.equal u' v') then
    None
  else
    Some (u', d, v').

Definition subst_univs_level_constraints
  (subst : LMap.t LMap.key) (csts : Constraint.t) : Constraint.t :=
  Constraint.fold
    (fun c =&gt;
      Option.fold_right Constraint.add (subst_univs_level_constraint subst c))
    csts Constraint.empty.

Definition subst_univs_level_abstract_universe_context {A : Set}
  (subst : LMap.t LMap.key) (function_parameter : A * Constraint.t)
  : A * Constraint.t :=
  let '(inst, csts) := function_parameter in
  (inst, (subst_univs_level_constraints subst csts)).

Definition universe_subst_fn := universe_level -&gt; universe.

Definition make_subst {A : Set} (subst : LMap.t A) (l : LMap.key) : A :=
  LMap.find l subst.

Definition subst_univs_expr_opt {A : Set}
  (fn : A -&gt; list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z))
  (function_parameter : A * Z)
  : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z) :=
  let '(l, n) := function_parameter in
  Universe.addn n (fn l).

Definition subst_univs_universe
  (fn :
    (|Level.Self|).(Hashcons.HashconsedType.t) -&gt;
    list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z))
  (ul : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z))
  : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z) :=
  let '(subst, nosubst) :=
    (|Util.List|).(CList.ExtS.fold_right)
      (fun u =&gt;
        fun function_parameter =&gt;
          let '(subst, nosubst) := function_parameter in
          (* ❌ Try-with are not handled *)
          try
            (let a' := subst_univs_expr_opt fn u in
            ((cons a' subst), nosubst))) ul ([], []) in
  if (|CList|).(CList.ExtS.is_empty) subst then
    ul
  else
    let substs :=
      (|Util.List|).(CList.ExtS.fold_left) Universe.merge_univs Universe.empty
        subst in
    (|Util.List|).(CList.ExtS.fold_left)
      (fun acc =&gt; fun u =&gt; Universe.merge_univs acc (Universe.tip u)) substs
      nosubst.

Definition make_instance_subst (i : Instance.t)
  : LMap.t (|Level.Self|).(Hashcons.HashconsedType.t) :=
  let arr := Instance.to_array i in
  (|Util.Array|).(CArray.ExtS.fold_left_i)
    (fun i =&gt; fun acc =&gt; fun l =&gt; LMap.add l (Level.var i) acc) LMap.empty arr.

Definition make_inverse_instance_subst (i : Instance.t) : LMap.t Level.t :=
  let arr := Instance.to_array i in
  (|Util.Array|).(CArray.ExtS.fold_left_i)
    (fun i =&gt; fun acc =&gt; fun l =&gt; LMap.add (Level.var i) l acc) LMap.empty arr.

Definition make_abstract_instance {A B : Set} (function_parameter : array A * B)
  : array (|Level.Self|).(Hashcons.HashconsedType.t) :=
  let '(ctx, _) := function_parameter in
  (|Util.Array|).(CArray.ExtS.init) ((|Util.Array|).(CArray.ExtS.length) ctx)
    (fun i =&gt; Level.var i).

Definition abstract_universes {A : Set}
  (nas : array A) (ctx : Instance.t * Constraint.t)
  : Instance.t * (array A * Constraint.t) :=
  let instance := UContext.instance ctx in
  let '_ :=
    (* ❌ Assert instruction is not handled. *)
    assert
      (Int.equal ((|Util.Array|).(CArray.ExtS.length) nas)
        (Instance.length instance)) in
  let subst := make_instance_subst instance in
  let cstrs := subst_univs_level_constraints subst (UContext.constraints ctx) in
  let ctx := (nas, cstrs) in
  (instance, ctx).

Fixpoint compact_univ {A : Set}
  (s : LMap.t (|Level.Self|).(Hashcons.HashconsedType.t)) (vars : list Z)
  (i : Z) (u : list (Level.t * A)) {struct s}
  : LMap.t (|Level.Self|).(Hashcons.HashconsedType.t) * list Z :=
  match u with
  | [] =&gt; (s, ((|Util.List|).(CList.ExtS.rev) vars))
  | cons (lvl, _) u =&gt;
    match
      ((Level.var_index lvl),
        match Level.var_index lvl with
        | Some k =&gt; negb (LMap.mem lvl s)
        | _ =&gt; false
        end) with
    | (Some k, true) =&gt;
      let lvl' := Level.var i in
      compact_univ (LMap.add lvl lvl' s) (cons k vars) (Z.add i 1) u
    | (_, _) =&gt; compact_univ s vars i u
    end
  end.

Definition compact_univ
  (u : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z))
  : list ((|Level.Self|).(Hashcons.HashconsedType.t) * Z) * list Z :=
  let '(s, s') := compact_univ LMap.empty [] 0 u in
  ((subst_univs_level_universe s u), s').

Definition pr_constraints (prl : Level.t -&gt; Pp.t) : Constraint.t -&gt; Pp.t :=
  Constraint.pr prl.

Definition pr_universe_context
  : (Level.t -&gt; Pp.t) -&gt; option (array Variance.t) -&gt;
  Instance.t * Constraint.t -&gt; Pp.t := UContext.pr.

Definition pr_abstract_universe_context {A : Set}
  : (Level.t -&gt; Pp.t) -&gt; option (array Variance.t) -&gt; array A * Constraint.t -&gt;
  Pp.t := AUContext.pr.

Definition pr_universe_context_set
  : (LSet.elt -&gt; Pp.t) -&gt; LSet.t * Constraint.t -&gt; Pp.t := ContextSet.pr.

Definition pr_universe_subst : LMap.t (list (Level.t * Int.t)) -&gt; Pp.t :=
  LMap.pr
    (fun u =&gt; op_plusplus (op_plusplus (str &quot; := &quot;) (Universe.pr u)) (spc tt)).

Definition pr_universe_level_subst : LMap.t Level.t -&gt; Pp.t :=
  LMap.pr
    (fun u =&gt; op_plusplus (op_plusplus (str &quot; := &quot;) (Level.pr u)) (spc tt)).

Definition Huniverse_set :=
  Hashcons.Make
    (let t := universe_set in
    let u := universe_level -&gt; universe_level in
    let hashcons (huc : LSet.elt -&gt; LSet.elt) (s : LSet.t) : LSet.t :=
      LSet.fold (fun x =&gt; LSet.add (huc x)) s LSet.empty in
    let eq (s : LSet.t) (s' : LSet.t) : bool :=
      LSet.equal s s' in
    let hash := Hashtbl.hash in
    existT _ [_, _]
      {|
        Hashcons.HashconsedType.hashcons := hashcons;
        Hashcons.HashconsedType.eq := eq;
        Hashcons.HashconsedType.hash := hash
      |}).

Definition hcons_universe_set
  : (|Huniverse_set|).(Hashcons.S.t) -&gt; (|Huniverse_set|).(Hashcons.S.t) :=
  Hashcons.simple_hcons (|Huniverse_set|).(Hashcons.S.generate)
    (|Huniverse_set|).(Hashcons.S.hcons) Level.hcons.

Definition hcons_universe_context_set
  (function_parameter :
    (|Huniverse_set|).(Hashcons.S.t) * (|Hconstraints|).(Hashcons.S.t))
  : (|Huniverse_set|).(Hashcons.S.t) * (|Hconstraints|).(Hashcons.S.t) :=
  let '(v, c) := function_parameter in
  ((hcons_universe_set v), (hcons_constraints c)).

Definition hcons_univ (x : (|Universe.Huniv|).(Hashcons.S.t))
  : (|Universe.Huniv|).(Hashcons.S.t) := Universe.hcons x.

Definition explain_universe_inconsistency
  (prl : Level.t -&gt; Pp.t) (function_parameter : univ_inconsistency) : Pp.t :=
  let '(o, u, v, p) := function_parameter in
  let pr_uni := Universe.pr_with prl in
  let pr_rel (function_parameter : constraint_type) : Pp.t :=
    match function_parameter with
    | Eq =&gt; str &quot;=&quot;
    | Lt =&gt; str &quot;&lt;&quot;
    | Le =&gt; str &quot;&lt;=&quot;
    end in
  let reason :=
    match p with
    | None =&gt; mt tt
    | Some p =&gt;
      let p := Lazy.force p in
      if equiv_decb p [] then
        mt tt
      else
        op_plusplus
          (op_plusplus
            (op_plusplus (op_plusplus (str &quot; because&quot;) (spc tt)) (pr_uni v))
            (prlist
              (fun function_parameter =&gt;
                let '(r, v) := function_parameter in
                op_plusplus
                  (op_plusplus (op_plusplus (spc tt) (pr_rel r)) (str &quot; &quot;))
                  (prl v)) p))
          (if
            Universe.equal
              (Universe.make (snd ((|Util.List|).(CList.ExtS.last) p))) u then
            mt tt
          else
            op_plusplus (op_plusplus (spc tt) (str &quot;= &quot;)) (pr_uni u))
    end in
  op_plusplus
    (op_plusplus
      (op_plusplus
        (op_plusplus
          (op_plusplus
            (op_plusplus (op_plusplus (str &quot;Cannot enforce&quot;) (spc tt))
              (pr_uni u)) (spc tt)) (pr_rel o)) (spc tt)) (pr_uni v)) reason.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="univ.mli">
  <div style="margin: 20px;">
    <h3>Univ_mli</h3>
    <ul>
      <li>OCaml size: 492 lines</li>
      <li>Coq size: 570 lines (+15% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#univ.mli"><code>univ.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** Universes. *)
module Level :
sig

  module UGlobal : sig
    type t

    val make : Names.DirPath.t -&gt; int -&gt; t
    val equal : t -&gt; t -&gt; bool
    val hash : t -&gt; int
    val compare : t -&gt; t -&gt; int

  end
  (** Qualified global universe level *)

  type t
  (** Type of universe levels. A universe level is essentially a unique name
      that will be associated to constraints later on. A level can be local to a
      definition or global. *)

  val set : t
  val prop : t
  val sprop : t
  (** The set and prop universe levels. *)

  val is_small : t -&gt; bool
  (** Is the universe set or prop? *)

  val is_sprop : t -&gt; bool
  val is_prop : t -&gt; bool
  val is_set : t -&gt; bool
  (** Is it specifically Prop or Set *)

  val compare : t -&gt; t -&gt; int
  (** Comparison function *)

  val equal : t -&gt; t -&gt; bool
  (** Equality function *)

  val hash : t -&gt; int

  val make : UGlobal.t -&gt; t

  val pr : t -&gt; Pp.t
  (** Pretty-printing *)

  val to_string : t -&gt; string
  (** Debug printing *)

  val var : int -&gt; t

  val var_index : t -&gt; int option

  val name : t -&gt; UGlobal.t option
end

(** Sets of universe levels *)
module LSet :
sig
  include CSig.SetS with type elt = Level.t

  val pr : (Level.t -&gt; Pp.t) -&gt; t -&gt; Pp.t
  (** Pretty-printing *)
end

module Universe :
sig
  type t
  (** Type of universes. A universe is defined as a set of level expressions.
      A level expression is built from levels and successors of level expressions, i.e.:
      le ::= l + n, n \in N.

      A universe is said atomic if it consists of a single level expression with
      no increment, and algebraic otherwise (think the least upper bound of a set of
      level expressions).
  *)

  val compare : t -&gt; t -&gt; int
  (** Comparison function *)

  val equal : t -&gt; t -&gt; bool
  (** Equality function on formal universes *)

  val hash : t -&gt; int
  (** Hash function *)

  val make : Level.t -&gt; t
  (** Create a universe representing the given level. *)

  val pr : t -&gt; Pp.t
  (** Pretty-printing *)

  val pr_with : (Level.t -&gt; Pp.t) -&gt; t -&gt; Pp.t

  val is_level : t -&gt; bool
  (** Test if the universe is a level or an algebraic universe. *)

  val is_levels : t -&gt; bool
  (** Test if the universe is a lub of levels or contains +n's. *)

  val level : t -&gt; Level.t option
  (** Try to get a level out of a universe, returns [None] if it
      is an algebraic universe. *)

  val levels : t -&gt; LSet.t
  (** Get the levels inside the universe, forgetting about increments *)

  val super : t -&gt; t
  (** The universe strictly above *)

  val sup   : t -&gt; t -&gt; t
  (** The l.u.b. of 2 universes *)

  val sprop : t

  val type0m : t
  (** image of Prop in the universes hierarchy *)

  val type0 : t
  (** image of Set in the universes hierarchy *)

  val type1 : t
  (** the universe of the type of Prop/Set *)

  val is_sprop : t -&gt; bool
  val is_type0m : t -&gt; bool
  val is_type0 : t -&gt; bool

  val exists : (Level.t * int -&gt; bool) -&gt; t -&gt; bool
  val for_all : (Level.t * int -&gt; bool) -&gt; t -&gt; bool

  val map : (Level.t * int -&gt; 'a) -&gt; t -&gt; 'a list

end

(** Alias name. *)

val pr_uni : Universe.t -&gt; Pp.t

(** The universes hierarchy: Type 0- = Prop &lt;= Type 0 = Set &lt;= Type 1 &lt;= ...
   Typing of universes: Type 0-, Type 0 : Type 1; Type i : Type (i+1) if i&gt;0 *)
val type0m_univ : Universe.t
val type0_univ : Universe.t
val type1_univ : Universe.t

val is_type0_univ : Universe.t -&gt; bool
val is_type0m_univ : Universe.t -&gt; bool
val is_univ_variable : Universe.t -&gt; bool
val is_small_univ : Universe.t -&gt; bool

val sup : Universe.t -&gt; Universe.t -&gt; Universe.t
val super : Universe.t -&gt; Universe.t

val universe_level : Universe.t -&gt; Level.t option

(** [univ_level_mem l u] Is l is mentioned in u ? *)

val univ_level_mem : Level.t -&gt; Universe.t -&gt; bool

(** [univ_level_rem u v min] removes [u] from [v], resulting in [min]
    if [v] was exactly [u]. *)

val univ_level_rem : Level.t -&gt; Universe.t -&gt; Universe.t -&gt; Universe.t

(** {6 Constraints. } *)

type constraint_type = AcyclicGraph.constraint_type = Lt | Le | Eq
type univ_constraint = Level.t * constraint_type * Level.t

module Constraint : sig
 include Set.S with type elt = univ_constraint
end

val empty_constraint : Constraint.t
val union_constraint : Constraint.t -&gt; Constraint.t -&gt; Constraint.t
val eq_constraint : Constraint.t -&gt; Constraint.t -&gt; bool

(** A value with universe Constraint.t. *)
type 'a constrained = 'a * Constraint.t

(** Constrained *)
val constraints_of : 'a constrained -&gt; Constraint.t

(** Enforcing Constraint.t. *)
type 'a constraint_function = 'a -&gt; 'a -&gt; Constraint.t -&gt; Constraint.t

val enforce_eq : Universe.t constraint_function
val enforce_leq : Universe.t constraint_function
val enforce_eq_level : Level.t constraint_function
val enforce_leq_level : Level.t constraint_function

(** Type explanation is used to decorate error messages to provide
  useful explanation why a given constraint is rejected. It is composed
  of a path of universes and relation kinds [(r1,u1);..;(rn,un)] means
   .. &lt;(r1) u1 &lt;(r2) ... &lt;(rn) un (where &lt;(ri) is the relation symbol
  denoted by ri, currently only &lt; and &lt;=). The lowest end of the chain
  is supposed known (see UniverseInconsistency exn). The upper end may
  differ from the second univ of UniverseInconsistency because all
  universes in the path are canonical. Note that each step does not
  necessarily correspond to an actual constraint, but reflect how the
  system stores the graph and may result from combination of several
  Constraint.t...
*)
type explanation = (constraint_type * Level.t) list
type univ_inconsistency = constraint_type * Universe.t * Universe.t * explanation Lazy.t option

<abbr class="mark-warning" title="Signature item `exception` not handled">exception UniverseInconsistency of univ_inconsistency</abbr>

(** {6 Support for universe polymorphism } *)

(** Polymorphic maps from universe levels to 'a *)
module LMap :
sig
  include <abbr class="mark-warning" title="Can only do `with` on types in module types">CMap.ExtS with type key = Level.t and module Set := LSet</abbr>

  val lunion : 'a t -&gt; 'a t -&gt; 'a t
  (** [lunion x y] favors the bindings in the first map. *)

  val diff : 'a t -&gt; 'a t -&gt; 'a t
  (** [diff x y] removes bindings from x that appear in y (whatever the value). *)

  val subst_union : 'a option t -&gt; 'a option t -&gt; 'a option t
  (** [subst_union x y] favors the bindings of the first map that are [Some],
      otherwise takes y's bindings. *)

  val pr : ('a -&gt; Pp.t) -&gt; 'a t -&gt; Pp.t
  (** Pretty-printing *)
end

type 'a universe_map = 'a LMap.t

(** {6 Substitution} *)

type universe_subst_fn = Level.t -&gt; Universe.t
type universe_level_subst_fn = Level.t -&gt; Level.t

(** A full substitution, might involve algebraic universes *)
type universe_subst = Universe.t universe_map
type universe_level_subst = Level.t universe_map

module Variance :
sig
  (** A universe position in the instance given to a cumulative
     inductive can be the following. Note there is no Contravariant
     case because [forall x : A, B &lt;= forall x : A', B'] requires [A =
     A'] as opposed to [A' &lt;= A]. *)
  type t = Irrelevant | Covariant | Invariant

  (** [check_subtype x y] holds if variance [y] is also an instance of [x] *)
  val check_subtype : t -&gt; t -&gt; bool

  val sup : t -&gt; t -&gt; t

  val pr : t -&gt; Pp.t

end

(** {6 Universe instances} *)

module Instance :
sig
  type t
  (** A universe instance represents a vector of argument universes
      to a polymorphic definition (constant, inductive or constructor). *)

  val empty : t
  val is_empty : t -&gt; bool

  val of_array : Level.t array -&gt; t
  val to_array : t -&gt; Level.t array

  val append : t -&gt; t -&gt; t
  (** To concatenate two instances, used for discharge *)

  val equal : t -&gt; t -&gt; bool
  (** Equality *)

  val length : t -&gt; int
  (** Instance length *)

  val hcons : t -&gt; t
  (** Hash-consing. *)

  val hash : t -&gt; int
  (** Hash value *)

  val share : t -&gt; t * int
  (** Simultaneous hash-consing and hash-value computation *)

  val subst_fn : universe_level_subst_fn -&gt; t -&gt; t
  (** Substitution by a level-to-level function. *)

  val pr : (Level.t -&gt; Pp.t) -&gt; ?variance:Variance.t array -&gt; t -&gt; Pp.t
  (** Pretty-printing, no comments *)

  val levels : t -&gt; LSet.t
  (** The set of levels in the instance *)

end

val enforce_eq_instances : Instance.t constraint_function

val enforce_eq_variance_instances : Variance.t array -&gt; Instance.t constraint_function
val enforce_leq_variance_instances : Variance.t array -&gt; Instance.t constraint_function

type 'a puniverses = 'a * Instance.t
val out_punivs : 'a puniverses -&gt; 'a
val in_punivs : 'a -&gt; 'a puniverses

val eq_puniverses : ('a -&gt; 'a -&gt; bool) -&gt; 'a puniverses -&gt; 'a puniverses -&gt; bool

(** A vector of universe levels with universe Constraint.t,
    representiong local universe variables and associated Constraint.t *)

module UContext :
sig
  type t

  val make : Instance.t constrained -&gt; t

  val empty : t
  val is_empty : t -&gt; bool

  val instance : t -&gt; Instance.t
  val constraints : t -&gt; Constraint.t

  val dest : t -&gt; Instance.t * Constraint.t

  (** Keeps the order of the instances *)
  val union : t -&gt; t -&gt; t

  (** the number of universes in the context *)
  val size : t -&gt; int

end

module AUContext :
sig
  type t

  val repr : t -&gt; UContext.t
  (** [repr ctx] is [(Var(0), ... Var(n-1) |= cstr] where [n] is the length of
      the context and [cstr] the abstracted Constraint.t. *)

  val empty : t
  val is_empty : t -&gt; bool

  val size : t -&gt; int

  (** Keeps the order of the instances *)
  val union : t -&gt; t -&gt; t

  val instantiate : Instance.t -&gt; t -&gt; Constraint.t
  (** Generate the set of instantiated Constraint.t **)

  val names : t -&gt; Names.Name.t array
  (** Return the names of the bound universe variables *)

end

type 'a univ_abstracted = {
  univ_abstracted_value : 'a;
  univ_abstracted_binder : AUContext.t;
}
(** A value with bound universe levels. *)

val map_univ_abstracted : ('a -&gt; 'b) -&gt; 'a univ_abstracted -&gt; 'b univ_abstracted

(** Universe contexts (as sets) *)

(** A set of universes with universe Constraint.t.
    We linearize the set to a list after typechecking.
    Beware, representation could change.
*)

module ContextSet :
sig
  type t = LSet.t constrained

  val empty : t
  val is_empty : t -&gt; bool

  val singleton : Level.t -&gt; t
  val of_instance : Instance.t -&gt; t
  val of_set : LSet.t -&gt; t

  val equal : t -&gt; t -&gt; bool
  val union : t -&gt; t -&gt; t

  val append : t -&gt; t -&gt; t
  (** Variant of {!union} which is more efficient when the left argument is
      much smaller than the right one. *)

  val diff : t -&gt; t -&gt; t
  val add_universe : Level.t -&gt; t -&gt; t
  val add_constraints : Constraint.t -&gt; t -&gt; t
  val add_instance : Instance.t -&gt; t -&gt; t

  (** Arbitrary choice of linear order of the variables *)
  val sort_levels : Level.t array -&gt; Level.t array
  val to_context : t -&gt; UContext.t
  val of_context : UContext.t -&gt; t

  val constraints : t -&gt; Constraint.t
  val levels : t -&gt; LSet.t

  (** the number of universes in the context *)
  val size : t -&gt; int
end

(** A value in a universe context (resp. context set). *)
type 'a in_universe_context = 'a * UContext.t
type 'a in_universe_context_set = 'a * ContextSet.t

val extend_in_context_set : 'a in_universe_context_set -&gt; ContextSet.t -&gt;
  'a in_universe_context_set

val empty_level_subst : universe_level_subst
val is_empty_level_subst : universe_level_subst -&gt; bool

(** Substitution of universes. *)
val subst_univs_level_level : universe_level_subst -&gt; Level.t -&gt; Level.t
val subst_univs_level_universe : universe_level_subst -&gt; Universe.t -&gt; Universe.t
val subst_univs_level_constraints : universe_level_subst -&gt; Constraint.t -&gt; Constraint.t
val subst_univs_level_abstract_universe_context :
  universe_level_subst -&gt; AUContext.t -&gt; AUContext.t
val subst_univs_level_instance : universe_level_subst -&gt; Instance.t -&gt; Instance.t

(** Level to universe substitutions. *)

val empty_subst : universe_subst
val is_empty_subst : universe_subst -&gt; bool
val make_subst : universe_subst -&gt; universe_subst_fn

val subst_univs_universe : universe_subst_fn -&gt; Universe.t -&gt; Universe.t
(** Only user in the kernel is template polymorphism. Ideally we get rid of
    this code if it goes away. *)

(** Substitution of instances *)
val subst_instance_instance : Instance.t -&gt; Instance.t -&gt; Instance.t
val subst_instance_universe : Instance.t -&gt; Universe.t -&gt; Universe.t

val make_instance_subst : Instance.t -&gt; universe_level_subst
(** Creates [u(0) â¦ 0; ...; u(n-1) â¦ n - 1] out of [u(0); ...; u(n - 1)] *)

val make_inverse_instance_subst : Instance.t -&gt; universe_level_subst

val abstract_universes : Names.Name.t array -&gt; UContext.t -&gt; Instance.t * AUContext.t
(** TODO: move universe abstraction out of the kernel *)

val make_abstract_instance : AUContext.t -&gt; Instance.t

(** [compact_univ u] remaps local variables in [u] such that their indices become
     consecutive. It returns the new universe and the mapping.
     Example: compact_univ [(Var 0, i); (Prop, 0); (Var 2; j))] =
       [(Var 0,i); (Prop, 0); (Var 1; j)], [0; 2]
*)
val compact_univ : Universe.t -&gt; Universe.t * int list

(** {6 Pretty-printing of universes. } *)

val pr_constraint_type : constraint_type -&gt; Pp.t
val pr_constraints : (Level.t -&gt; Pp.t) -&gt; Constraint.t -&gt; Pp.t
val pr_universe_context : (Level.t -&gt; Pp.t) -&gt; ?variance:Variance.t array -&gt;
  UContext.t -&gt; Pp.t
val pr_abstract_universe_context : (Level.t -&gt; Pp.t) -&gt; ?variance:Variance.t array -&gt;
  AUContext.t -&gt; Pp.t
val pr_universe_context_set : (Level.t -&gt; Pp.t) -&gt; ContextSet.t -&gt; Pp.t
val explain_universe_inconsistency : (Level.t -&gt; Pp.t) -&gt;
  univ_inconsistency -&gt; Pp.t

val pr_universe_level_subst : universe_level_subst -&gt; Pp.t
val pr_universe_subst : universe_subst -&gt; Pp.t

(** {6 Hash-consing } *)

val hcons_univ : Universe.t -&gt; Universe.t
val hcons_constraints : Constraint.t -&gt; Constraint.t
val hcons_universe_set : LSet.t -&gt; LSet.t
val hcons_universe_context : UContext.t -&gt; UContext.t
val hcons_abstract_universe_context : AUContext.t -&gt; AUContext.t
val hcons_universe_context_set : ContextSet.t -&gt; ContextSet.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#univ.mli"><code>Univ_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Module Level.
  Module UGlobal.
    Parameter t : Set.
    
    Parameter make : Names.DirPath.t -&gt; Z -&gt; t.
    
    Parameter equal : t -&gt; t -&gt; bool.
    
    Parameter hash : t -&gt; Z.
    
    Parameter compare : t -&gt; t -&gt; Z.
  End UGlobal.
  
  Parameter t : Set.
  
  Parameter set : t.
  
  Parameter prop : t.
  
  Parameter sprop : t.
  
  Parameter is_small : t -&gt; bool.
  
  Parameter is_sprop : t -&gt; bool.
  
  Parameter is_prop : t -&gt; bool.
  
  Parameter is_set : t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
  
  Parameter make : UGlobal.t -&gt; t.
  
  Parameter pr : t -&gt; Pp.t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter var : Z -&gt; t.
  
  Parameter var_index : t -&gt; option Z.
  
  Parameter name : t -&gt; option UGlobal.t.
End Level.

Module LSet.
  Parameter Included_SetS : {t : _ &amp; CSig.SetS.signature Level.t t}.
  
  Definition elt := (|Included_SetS|).(CSig.SetS.elt).
  
  Definition t := (|Included_SetS|).(CSig.SetS.t).
  
  Definition empty := (|Included_SetS|).(CSig.SetS.empty).
  
  Definition is_empty := (|Included_SetS|).(CSig.SetS.is_empty).
  
  Definition mem := (|Included_SetS|).(CSig.SetS.mem).
  
  Definition add := (|Included_SetS|).(CSig.SetS.add).
  
  Definition singleton := (|Included_SetS|).(CSig.SetS.singleton).
  
  Definition remove := (|Included_SetS|).(CSig.SetS.remove).
  
  Definition union := (|Included_SetS|).(CSig.SetS.union).
  
  Definition inter := (|Included_SetS|).(CSig.SetS.inter).
  
  Definition diff := (|Included_SetS|).(CSig.SetS.diff).
  
  Definition compare := (|Included_SetS|).(CSig.SetS.compare).
  
  Definition equal := (|Included_SetS|).(CSig.SetS.equal).
  
  Definition subset := (|Included_SetS|).(CSig.SetS.subset).
  
  Definition iter := (|Included_SetS|).(CSig.SetS.iter).
  
  Definition fold := (|Included_SetS|).(CSig.SetS.fold).
  
  Definition for_all := (|Included_SetS|).(CSig.SetS.for_all).
  
  Definition __exists := (|Included_SetS|).(CSig.SetS.__exists).
  
  Definition filter := (|Included_SetS|).(CSig.SetS.filter).
  
  Definition partition := (|Included_SetS|).(CSig.SetS.partition).
  
  Definition cardinal := (|Included_SetS|).(CSig.SetS.cardinal).
  
  Definition elements := (|Included_SetS|).(CSig.SetS.elements).
  
  Definition min_elt := (|Included_SetS|).(CSig.SetS.min_elt).
  
  Definition max_elt := (|Included_SetS|).(CSig.SetS.max_elt).
  
  Definition choose := (|Included_SetS|).(CSig.SetS.choose).
  
  Definition split := (|Included_SetS|).(CSig.SetS.split).
  
  Parameter pr : (Level.t -&gt; Pp.t) -&gt; t -&gt; Pp.t.
End LSet.

Module Universe.
  Parameter t : Set.
  
  Parameter compare : t -&gt; t -&gt; Z.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter hash : t -&gt; Z.
  
  Parameter make : Level.t -&gt; t.
  
  Parameter pr : t -&gt; Pp.t.
  
  Parameter pr_with : (Level.t -&gt; Pp.t) -&gt; t -&gt; Pp.t.
  
  Parameter is_level : t -&gt; bool.
  
  Parameter is_levels : t -&gt; bool.
  
  Parameter level : t -&gt; option Level.t.
  
  Parameter levels : t -&gt; LSet.t.
  
  Parameter super : t -&gt; t.
  
  Parameter sup : t -&gt; t -&gt; t.
  
  Parameter sprop : t.
  
  Parameter type0m : t.
  
  Parameter type0 : t.
  
  Parameter type1 : t.
  
  Parameter is_sprop : t -&gt; bool.
  
  Parameter is_type0m : t -&gt; bool.
  
  Parameter is_type0 : t -&gt; bool.
  
  Parameter __exists : (Level.t * Z -&gt; bool) -&gt; t -&gt; bool.
  
  Parameter for_all : (Level.t * Z -&gt; bool) -&gt; t -&gt; bool.
  
  Parameter map : forall {a : Set}, (Level.t * Z -&gt; a) -&gt; t -&gt; list a.
End Universe.

Parameter pr_uni : Universe.t -&gt; Pp.t.

Parameter type0m_univ : Universe.t.

Parameter type0_univ : Universe.t.

Parameter type1_univ : Universe.t.

Parameter is_type0_univ : Universe.t -&gt; bool.

Parameter is_type0m_univ : Universe.t -&gt; bool.

Parameter is_univ_variable : Universe.t -&gt; bool.

Parameter is_small_univ : Universe.t -&gt; bool.

Parameter sup : Universe.t -&gt; Universe.t -&gt; Universe.t.

Parameter super : Universe.t -&gt; Universe.t.

Parameter universe_level : Universe.t -&gt; option Level.t.

Parameter univ_level_mem : Level.t -&gt; Universe.t -&gt; bool.

Parameter univ_level_rem : Level.t -&gt; Universe.t -&gt; Universe.t -&gt; Universe.t.

Inductive constraint_type : Set :=
| Lt : constraint_type
| Le : constraint_type
| Eq : constraint_type.

Definition univ_constraint := Level.t * constraint_type * Level.t.

Parameter Constraint : {t : _ &amp; __Set.S.signature univ_constraint t}.

Parameter empty_constraint : Constraint.t.

Parameter union_constraint : Constraint.t -&gt; Constraint.t -&gt; Constraint.t.

Parameter eq_constraint : Constraint.t -&gt; Constraint.t -&gt; bool.

Definition constrained (a : Set) := a * Constraint.t.

Parameter constraints_of : forall {a : Set}, constrained a -&gt; Constraint.t.

Definition constraint_function (a : Set) :=
  a -&gt; a -&gt; Constraint.t -&gt; Constraint.t.

Parameter enforce_eq : constraint_function Universe.t.

Parameter enforce_leq : constraint_function Universe.t.

Parameter enforce_eq_level : constraint_function Level.t.

Parameter enforce_leq_level : constraint_function Level.t.

Definition explanation := list (constraint_type * Level.t).

Definition univ_inconsistency :=
  constraint_type * Universe.t * Universe.t * option (Stdlib.Lazy.t explanation).

(* exception UniverseInconsistency *)

Module LMap.
  Parameter Included_ExtS :
    {'[t, __Set_t] : _ &amp; CMap.ExtS.signature Level.t t __Set_t}.
  
  Definition key := (|Included_ExtS|).(CMap.ExtS.key).
  
  Definition t := (|Included_ExtS|).(CMap.ExtS.t).
  
  Definition empty := (|Included_ExtS|).(CMap.ExtS.empty).
  
  Definition is_empty := (|Included_ExtS|).(CMap.ExtS.is_empty).
  
  Definition mem := (|Included_ExtS|).(CMap.ExtS.mem).
  
  Definition add := (|Included_ExtS|).(CMap.ExtS.add).
  
  Definition singleton := (|Included_ExtS|).(CMap.ExtS.singleton).
  
  Definition remove := (|Included_ExtS|).(CMap.ExtS.remove).
  
  Definition merge := (|Included_ExtS|).(CMap.ExtS.merge).
  
  Definition union := (|Included_ExtS|).(CMap.ExtS.union).
  
  Definition compare := (|Included_ExtS|).(CMap.ExtS.compare).
  
  Definition equal := (|Included_ExtS|).(CMap.ExtS.equal).
  
  Definition iter := (|Included_ExtS|).(CMap.ExtS.iter).
  
  Definition fold := (|Included_ExtS|).(CMap.ExtS.fold).
  
  Definition for_all := (|Included_ExtS|).(CMap.ExtS.for_all).
  
  Definition __exists := (|Included_ExtS|).(CMap.ExtS.__exists).
  
  Definition filter := (|Included_ExtS|).(CMap.ExtS.filter).
  
  Definition partition := (|Included_ExtS|).(CMap.ExtS.partition).
  
  Definition cardinal := (|Included_ExtS|).(CMap.ExtS.cardinal).
  
  Definition bindings := (|Included_ExtS|).(CMap.ExtS.bindings).
  
  Definition min_binding := (|Included_ExtS|).(CMap.ExtS.min_binding).
  
  Definition max_binding := (|Included_ExtS|).(CMap.ExtS.max_binding).
  
  Definition choose := (|Included_ExtS|).(CMap.ExtS.choose).
  
  Definition split := (|Included_ExtS|).(CMap.ExtS.split).
  
  Definition find := (|Included_ExtS|).(CMap.ExtS.find).
  
  Definition find_opt := (|Included_ExtS|).(CMap.ExtS.find_opt).
  
  Definition map := (|Included_ExtS|).(CMap.ExtS.map).
  
  Definition mapi := (|Included_ExtS|).(CMap.ExtS.mapi).
  
  Definition get := (|Included_ExtS|).(CMap.ExtS.get).
  
  Definition set := (|Included_ExtS|).(CMap.ExtS.set).
  
  Definition modify := (|Included_ExtS|).(CMap.ExtS.modify).
  
  Definition domain := (|Included_ExtS|).(CMap.ExtS.domain).
  
  Definition bind := (|Included_ExtS|).(CMap.ExtS.bind).
  
  Definition fold_left := (|Included_ExtS|).(CMap.ExtS.fold_left).
  
  Definition fold_right := (|Included_ExtS|).(CMap.ExtS.fold_right).
  
  Definition height := (|Included_ExtS|).(CMap.ExtS.height).
  
  Definition filter_range := (|Included_ExtS|).(CMap.ExtS.filter_range).
  
  Definition update := (|Included_ExtS|).(CMap.ExtS.update).
  
  Definition Smart := existT (fun _ =&gt; _) tt (|Included_ExtS|).(CMap.ExtS.Smart).
  
  Definition Unsafe := existT (fun _ =&gt; _) tt
    (|Included_ExtS|).(CMap.ExtS.Unsafe).
  
  Definition Monad := existT (fun _ =&gt; _) tt (|Included_ExtS|).(CMap.ExtS.Monad).
  
  Parameter lunion : forall {a : Set}, t a -&gt; t a -&gt; t a.
  
  Parameter diff : forall {a : Set}, t a -&gt; t a -&gt; t a.
  
  Parameter subst_union : forall {a : Set},
    t (option a) -&gt; t (option a) -&gt; t (option a).
  
  Parameter pr : forall {a : Set}, (a -&gt; Pp.t) -&gt; t a -&gt; Pp.t.
End LMap.

Definition universe_map (a : Set) := LMap.t a.

Definition universe_subst_fn := Level.t -&gt; Universe.t.

Definition universe_level_subst_fn := Level.t -&gt; Level.t.

Definition universe_subst := universe_map Universe.t.

Definition universe_level_subst := universe_map Level.t.

Module Variance.
  Inductive t : Set :=
  | Irrelevant : t
  | Covariant : t
  | Invariant : t.
  
  Parameter check_subtype : t -&gt; t -&gt; bool.
  
  Parameter sup : t -&gt; t -&gt; t.
  
  Parameter pr : t -&gt; Pp.t.
End Variance.

Module Instance.
  Parameter t : Set.
  
  Parameter empty : t.
  
  Parameter is_empty : t -&gt; bool.
  
  Parameter of_array : array Level.t -&gt; t.
  
  Parameter to_array : t -&gt; array Level.t.
  
  Parameter append : t -&gt; t -&gt; t.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter length : t -&gt; Z.
  
  Parameter hcons : t -&gt; t.
  
  Parameter hash : t -&gt; Z.
  
  Parameter share : t -&gt; t * Z.
  
  Parameter subst_fn : universe_level_subst_fn -&gt; t -&gt; t.
  
  Parameter pr : (Level.t -&gt; Pp.t) -&gt; option (array Variance.t) -&gt; t -&gt; Pp.t.
  
  Parameter levels : t -&gt; LSet.t.
End Instance.

Parameter enforce_eq_instances : constraint_function Instance.t.

Parameter enforce_eq_variance_instances :
  array Variance.t -&gt; constraint_function Instance.t.

Parameter enforce_leq_variance_instances :
  array Variance.t -&gt; constraint_function Instance.t.

Definition puniverses (a : Set) := a * Instance.t.

Parameter out_punivs : forall {a : Set}, puniverses a -&gt; a.

Parameter in_punivs : forall {a : Set}, a -&gt; puniverses a.

Parameter eq_puniverses : forall {a : Set},
  (a -&gt; a -&gt; bool) -&gt; puniverses a -&gt; puniverses a -&gt; bool.

Module UContext.
  Parameter t : Set.
  
  Parameter make : constrained Instance.t -&gt; t.
  
  Parameter empty : t.
  
  Parameter is_empty : t -&gt; bool.
  
  Parameter instance : t -&gt; Instance.t.
  
  Parameter constraints : t -&gt; Constraint.t.
  
  Parameter dest : t -&gt; Instance.t * Constraint.t.
  
  Parameter union : t -&gt; t -&gt; t.
  
  Parameter size : t -&gt; Z.
End UContext.

Module AUContext.
  Parameter t : Set.
  
  Parameter repr : t -&gt; UContext.t.
  
  Parameter empty : t.
  
  Parameter is_empty : t -&gt; bool.
  
  Parameter size : t -&gt; Z.
  
  Parameter union : t -&gt; t -&gt; t.
  
  Parameter instantiate : Instance.t -&gt; t -&gt; Constraint.t.
  
  Parameter names : t -&gt; array Names.Name.t.
End AUContext.

Module univ_abstracted.
  Record record {a : Set} := {
    univ_abstracted_value : a;
    univ_abstracted_binder : AUContext.t }.
  Arguments record : clear implicits.
  Definition with_univ_abstracted_value {a_type : Set} (r : record a_type)
    univ_abstracted_value : record a_type :=
    {| univ_abstracted_value := univ_abstracted_value;
      univ_abstracted_binder := univ_abstracted_binder r |}.
  Definition with_univ_abstracted_binder {a_type : Set} (r : record a_type)
    univ_abstracted_binder : record a_type :=
    {| univ_abstracted_value := univ_abstracted_value r;
      univ_abstracted_binder := univ_abstracted_binder |}.
End univ_abstracted.
Definition univ_abstracted := univ_abstracted.record.

Parameter map_univ_abstracted : forall {a b : Set},
  (a -&gt; b) -&gt; univ_abstracted a -&gt; univ_abstracted b.

Module ContextSet.
  Definition t := constrained LSet.t.
  
  Parameter empty : t.
  
  Parameter is_empty : t -&gt; bool.
  
  Parameter singleton : Level.t -&gt; t.
  
  Parameter of_instance : Instance.t -&gt; t.
  
  Parameter of_set : LSet.t -&gt; t.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter union : t -&gt; t -&gt; t.
  
  Parameter append : t -&gt; t -&gt; t.
  
  Parameter diff : t -&gt; t -&gt; t.
  
  Parameter add_universe : Level.t -&gt; t -&gt; t.
  
  Parameter add_constraints : Constraint.t -&gt; t -&gt; t.
  
  Parameter add_instance : Instance.t -&gt; t -&gt; t.
  
  Parameter sort_levels : array Level.t -&gt; array Level.t.
  
  Parameter to_context : t -&gt; UContext.t.
  
  Parameter of_context : UContext.t -&gt; t.
  
  Parameter constraints : t -&gt; Constraint.t.
  
  Parameter levels : t -&gt; LSet.t.
  
  Parameter size : t -&gt; Z.
End ContextSet.

Definition in_universe_context (a : Set) := a * UContext.t.

Definition in_universe_context_set (a : Set) := a * ContextSet.t.

Parameter extend_in_context_set : forall {a : Set},
  in_universe_context_set a -&gt; ContextSet.t -&gt; in_universe_context_set a.

Parameter empty_level_subst : universe_level_subst.

Parameter is_empty_level_subst : universe_level_subst -&gt; bool.

Parameter subst_univs_level_level : universe_level_subst -&gt; Level.t -&gt; Level.t.

Parameter subst_univs_level_universe :
  universe_level_subst -&gt; Universe.t -&gt; Universe.t.

Parameter subst_univs_level_constraints :
  universe_level_subst -&gt; Constraint.t -&gt; Constraint.t.

Parameter subst_univs_level_abstract_universe_context :
  universe_level_subst -&gt; AUContext.t -&gt; AUContext.t.

Parameter subst_univs_level_instance :
  universe_level_subst -&gt; Instance.t -&gt; Instance.t.

Parameter empty_subst : universe_subst.

Parameter is_empty_subst : universe_subst -&gt; bool.

Parameter make_subst : universe_subst -&gt; universe_subst_fn.

Parameter subst_univs_universe : universe_subst_fn -&gt; Universe.t -&gt; Universe.t.

Parameter subst_instance_instance : Instance.t -&gt; Instance.t -&gt; Instance.t.

Parameter subst_instance_universe : Instance.t -&gt; Universe.t -&gt; Universe.t.

Parameter make_instance_subst : Instance.t -&gt; universe_level_subst.

Parameter make_inverse_instance_subst : Instance.t -&gt; universe_level_subst.

Parameter abstract_universes :
  array Names.Name.t -&gt; UContext.t -&gt; Instance.t * AUContext.t.

Parameter make_abstract_instance : AUContext.t -&gt; Instance.t.

Parameter compact_univ : Universe.t -&gt; Universe.t * list Z.

Parameter pr_constraint_type : constraint_type -&gt; Pp.t.

Parameter pr_constraints : (Level.t -&gt; Pp.t) -&gt; Constraint.t -&gt; Pp.t.

Parameter pr_universe_context :
  (Level.t -&gt; Pp.t) -&gt; option (array Variance.t) -&gt; UContext.t -&gt; Pp.t.

Parameter pr_abstract_universe_context :
  (Level.t -&gt; Pp.t) -&gt; option (array Variance.t) -&gt; AUContext.t -&gt; Pp.t.

Parameter pr_universe_context_set : (Level.t -&gt; Pp.t) -&gt; ContextSet.t -&gt; Pp.t.

Parameter explain_universe_inconsistency :
  (Level.t -&gt; Pp.t) -&gt; univ_inconsistency -&gt; Pp.t.

Parameter pr_universe_level_subst : universe_level_subst -&gt; Pp.t.

Parameter pr_universe_subst : universe_subst -&gt; Pp.t.

Parameter hcons_univ : Universe.t -&gt; Universe.t.

Parameter hcons_constraints : Constraint.t -&gt; Constraint.t.

Parameter hcons_universe_set : LSet.t -&gt; LSet.t.

Parameter hcons_universe_context : UContext.t -&gt; UContext.t.

Parameter hcons_abstract_universe_context : AUContext.t -&gt; AUContext.t.

Parameter hcons_universe_context_set : ContextSet.t -&gt; ContextSet.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vars.ml">
  <div style="margin: 20px;">
    <h3>Vars</h3>
    <ul>
      <li>OCaml size: 322 lines</li>
      <li>Coq size: 459 lines (+42% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vars.ml"><code>vars.ml</code></a>&nbsp;<span class="label label-warning">25 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names

module RelDecl = Context.Rel.Declaration

(*********************)
(*     Occurring     *)
(*********************)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception LocalOccur</abbr>

(* (closedn n M) raises FreeVar if a variable of height greater than n
   occurs in M, returns () otherwise *)

let closedn n c =
  let rec closed_rec n c = match Constr.kind c with
    | Constr.Rel m -&gt; if m&gt;n then raise <abbr class="mark-warning" title="Values of extensible types are not handled">LocalOccur</abbr>
    | _ -&gt; Constr.iter_with_binders succ closed_rec n c
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">closed_rec n c; true</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> with LocalOccur -&gt; false</abbr>

(* [closed0 M] is true iff [M] is a (de Bruijn) closed term *)

let closed0 c = closedn 0 c

(* (noccurn n M) returns true iff (Rel n) does NOT occur in term M  *)

let noccurn n term =
  let rec occur_rec n c = match Constr.kind c with
    | Constr.Rel m -&gt; if Int.equal m n then raise <abbr class="mark-warning" title="Values of extensible types are not handled">LocalOccur</abbr>
    | _ -&gt; Constr.iter_with_binders succ occur_rec n c
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">occur_rec n term; true</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> with LocalOccur -&gt; false</abbr>

(* (noccur_between n m M) returns true iff (Rel p) does NOT occur in term M
  for n &lt;= p &lt; n+m *)

let noccur_between n m term =
  let rec occur_rec n c = match Constr.kind c with
    | Constr.Rel p -&gt; if n&lt;=p &amp;&amp; p&lt;n+m then raise <abbr class="mark-warning" title="Values of extensible types are not handled">LocalOccur</abbr>
    | _        -&gt; Constr.iter_with_binders succ occur_rec n c
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">occur_rec n term; true</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> with LocalOccur -&gt; false</abbr>

(* Checking function for terms containing existential variables.
 The function [noccur_with_meta] considers the fact that
 each existential variable (as well as each isevar)
 in the term appears applied to its local context,
 which may contain the CoFix variables. These occurrences of CoFix variables
 are not considered *)

let isMeta c = match Constr.kind c with
| Constr.Meta _ -&gt; true
| _ -&gt; false

let noccur_with_meta n m term =
  let rec occur_rec n c = match Constr.kind c with
    | Constr.Rel p -&gt; if n&lt;=p &amp;&amp; p&lt;n+m then raise <abbr class="mark-warning" title="Values of extensible types are not handled">LocalOccur</abbr>
    | Constr.App(f,_cl) -&gt;
        (match Constr.kind f with
           | Constr.Cast (c,_,_) when isMeta c -&gt; ()
           | Constr.Meta _ -&gt; ()
           | _ -&gt; Constr.iter_with_binders succ occur_rec n c)
    | Constr.Evar (_, _) -&gt; ()
    | _ -&gt; Constr.iter_with_binders succ occur_rec n c
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(occur_rec n term; true)</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> with LocalOccur -&gt; false</abbr>

(*********************)
(*      Lifting      *)
(*********************)

let exliftn = Constr.exliftn
let liftn = Constr.liftn
let lift = Constr.lift

(*********************)
(*   Substituting    *)
(*********************)

(* (subst1 M c) substitutes M for Rel(1) in c
   we generalise it to (substl [M1,...,Mn] c) which substitutes in parallel
   M1,...,Mn for respectively Rel(1),...,Rel(n) in c *)

(* 1st : general case *)

type info = Closed | Open | Unknown
type 'a substituend = { mutable sinfo: info; sit: 'a }

let lift_substituend depth s =
  match s.sinfo with
    | Closed -&gt; s.sit
    | Open -&gt; lift depth s.sit
    | Unknown -&gt;
      let sit = s.sit in
      if closed0 sit then
        let () = <abbr class="mark-warning" title="Set record field not handled.">s.sinfo &lt;- Closed</abbr> in
        sit
      else
        let () = <abbr class="mark-warning" title="Set record field not handled.">s.sinfo &lt;- Open</abbr> in
        lift depth sit

let make_substituend c = { sinfo=Unknown; sit=c }

let substn_many lamv n c =
  let lv = Array.length lamv in
  if Int.equal lv 0 then c
  else
    let rec substrec depth c = match Constr.kind c with
      | Constr.Rel k     -&gt;
          if k&lt;=depth then c
          else if k-depth &lt;= lv then lift_substituend depth (Array.unsafe_get lamv (k-depth-1))
          else Constr.mkRel (k-lv)
      | _ -&gt; Constr.map_with_binders succ substrec depth c in
    substrec n c

(*
let substkey = CProfile.declare_profile &quot;substn_many&quot;;;
let substn_many lamv n c = CProfile.profile3 substkey substn_many lamv n c;;
*)

let make_subst = function
| [] -&gt; <abbr class="mark-warning" title="Arrays not handled.">[||]</abbr>
| hd :: tl -&gt;
  let len = List.length tl in
  let subst = Array.make (1 + len) (make_substituend hd) in
  let s = ref tl in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 1 to len do
    match !s with
    | [] -&gt; assert false
    | x :: tl -&gt;
      Array.unsafe_set subst i (make_substituend x);
      s := tl
  done;
  subst</abbr>

(* The type of substitutions, with term substituting most recent
    binder at the head *)

type substl = Constr.t list

let substnl laml n c = substn_many (make_subst laml) n c
let substl laml c = substn_many (make_subst laml) 0 c
let subst1 lam c = substn_many <abbr class="mark-warning" title="Arrays not handled.">[|make_substituend lam|]</abbr> 0 c

let substnl_decl laml k r = RelDecl.map_constr (fun c -&gt; substnl laml k c) r
let substl_decl laml r = RelDecl.map_constr (fun c -&gt; substnl laml 0 c) r
let subst1_decl lam r = RelDecl.map_constr (fun c -&gt; subst1 lam c) r

(* Build a substitution from an instance, inserting missing let-ins *)

let subst_of_rel_context_instance sign l =
  let rec aux subst sign l =
    let open RelDecl in
    match sign, l with
    | LocalAssum _ :: sign', a::args' -&gt; aux (a::subst) sign' args'
    | LocalDef (_,c,_)::sign', args' -&gt;
        aux (substl subst c :: subst) sign' args'
    | [], [] -&gt; subst
    | _ -&gt; CErrors.anomaly (Pp.str &quot;Instance and signature do not match.&quot;)
  in aux [] (List.rev sign) l

let adjust_subst_to_rel_context sign l =
  List.rev (subst_of_rel_context_instance sign l)

let adjust_rel_to_rel_context sign n =
  let rec aux sign =
    let open RelDecl in
    match sign with
    | LocalAssum _ :: sign' -&gt; let (n',p) = aux sign' in (n'+1,p)
    | LocalDef (_,_c,_)::sign' -&gt; let (n',p) = aux sign' in (n'+1,if n'&lt;n then p+1 else p)
    | [] -&gt; (0,n)
  in snd (aux sign)

(* (thin_val sigma) removes identity substitutions from sigma *)

let rec thin_val = function
  | [] -&gt; []
  | (id, c) :: tl -&gt;
    match Constr.kind c with
    | Constr.Var v -&gt;
      if Id.equal id v then thin_val tl
      else (id, make_substituend c) :: (thin_val tl)
    | _ -&gt; (id, make_substituend c) :: (thin_val tl)

let rec find_var id = function
| [] -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr>
| (idc, c) :: subst -&gt;
  if Id.equal id idc then c
  else find_var id subst

(* (replace_vars sigma M) applies substitution sigma to term M *)
let replace_vars var_alist x =
  let var_alist = thin_val var_alist in
  match var_alist with
  | [] -&gt; x
  | _ -&gt;
    let rec substrec n c = match Constr.kind c with
    | Constr.Var x -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(try lift_substituend n (find_var x var_alist)
      with Not_found -&gt; c)</abbr>
    | _ -&gt; Constr.map_with_binders succ substrec n c
    in
    substrec 0 x

(* (subst_var str t) substitute (Var str) by (Rel 1) in t *)
let subst_var str t = replace_vars [(str, Constr.mkRel 1)] t

(* (subst_vars [id1;...;idn] t) substitute (Var idj) by (Rel j) in t *)
let substn_vars p vars c =
  let _,subst =
    List.fold_left (fun (n,l) var -&gt; ((n+1),(var,Constr.mkRel n)::l)) (p,[]) vars
  in replace_vars (List.rev subst) c

let subst_vars subst c = substn_vars 1 subst c

(** Universe substitutions *)
open Constr

let subst_univs_level_constr subst c =
  if Univ.is_empty_level_subst subst then c
  else
    let f = Univ.Instance.subst_fn (Univ.subst_univs_level_level subst) in
    let changed = ref false in
    let rec aux t =
      match kind t with
      | Const (c, u) -&gt;
        if Univ.Instance.is_empty u then t
        else
          let u' = f u in
            if u' == u then t
            else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(changed := true; mkConstU (c, u'))</abbr>
      | Ind (i, u) -&gt;
        if Univ.Instance.is_empty u then t
        else
          let u' = f u in
            if u' == u then t
            else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(changed := true; mkIndU (i, u'))</abbr>
      | Construct (c, u) -&gt;
        if Univ.Instance.is_empty u then t
        else
          let u' = f u in
            if u' == u then t
            else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(changed := true; mkConstructU (c, u'))</abbr>
      | Sort (Sorts.Type u) -&gt;
         let u' = Univ.subst_univs_level_universe subst u in
           if u' == u then t else
             <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">(changed := true; mkSort (Sorts.sort_of_univ u'))</abbr>
      | _ -&gt; Constr.map aux t
    in
    let c' = aux c in
      if !changed then c' else c

let subst_univs_level_context s =
  Context.Rel.map (subst_univs_level_constr s)

let subst_instance_constr subst c =
  if Univ.Instance.is_empty subst then c
  else
    let f u = Univ.subst_instance_instance subst u in
    let rec aux t =
      match kind t with
      | Const (c, u) -&gt;
       if Univ.Instance.is_empty u then t
       else
          let u' = f u in
           if u' == u then t
           else (mkConstU (c, u'))
      | Ind (i, u) -&gt;
       if Univ.Instance.is_empty u then t
       else
         let u' = f u in
           if u' == u then t
           else (mkIndU (i, u'))
      | Construct (c, u) -&gt;
       if Univ.Instance.is_empty u then t
       else
          let u' = f u in
           if u' == u then t
           else (mkConstructU (c, u'))
      | Sort (Sorts.Type u) -&gt;
         let u' = Univ.subst_instance_universe subst u in
          if u' == u then t else
            (mkSort (Sorts.sort_of_univ u'))
      | _ -&gt; Constr.map aux t
    in
    aux c

let univ_instantiate_constr u c =
  let open Univ in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Int.equal (Instance.length u) (AUContext.size c.univ_abstracted_binder));
  subst_instance_constr u c.univ_abstracted_value</abbr>

(* let substkey = CProfile.declare_profile &quot;subst_instance_constr&quot;;; *)
(* let subst_instance_constr inst c = CProfile.profile2 substkey subst_instance_constr inst c;; *)

let subst_instance_context s ctx =
  if Univ.Instance.is_empty s then ctx
  else Context.Rel.map (fun x -&gt; subst_instance_constr s x) ctx

let universes_of_constr c =
  let open Univ in
  let rec aux s c =
    match kind c with
    | Const (_c, u) -&gt;
       LSet.fold LSet.add (Instance.levels u) s
    | Ind ((_mind,_), u) | Construct (((_mind,_),_), u) -&gt;
       LSet.fold LSet.add (Instance.levels u) s
    | Sort u when not (Sorts.is_small u) -&gt;
      let u = Sorts.univ_of_sort u in
      LSet.fold LSet.add (Universe.levels u) s
    | _ -&gt; Constr.fold aux s c
  in aux LSet.empty c
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vars.ml"><code>Vars.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Module RelDecl := Context.Rel.Declaration.

(* ❌ The definition of exceptions is not handled. *)
(* exception LocalOccur *)

Definition closedn (n : Z) (c : Constr.constr) : bool :=
  let fix closed_rec (n : Z) (c : Constr.constr) {struct n} : unit :=
    match Constr.kind c with
    | Constr.Rel m =&gt;
      if OCaml.Stdlib.gt m n then
        Stdlib.raise extensible_type_value
      else
        tt
    | _ =&gt; Constr.iter_with_binders Z.succ closed_rec n c
    end in
  (* ❌ Try-with are not handled *)
  try
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    true.

Definition closed0 (c : Constr.constr) : bool := closedn 0 c.

Definition noccurn (n : Int.t) (term : Constr.constr) : bool :=
  let fix occur_rec (n : Int.t) (c : Constr.constr) {struct n} : unit :=
    match Constr.kind c with
    | Constr.Rel m =&gt;
      if Int.equal m n then
        Stdlib.raise extensible_type_value
      else
        tt
    | _ =&gt; Constr.iter_with_binders Z.succ occur_rec n c
    end in
  (* ❌ Try-with are not handled *)
  try
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    true.

Definition noccur_between (n : Z) (m : Z) (term : Constr.constr) : bool :=
  let fix occur_rec (n : Z) (c : Constr.constr) {struct n} : unit :=
    match Constr.kind c with
    | Constr.Rel p =&gt;
      if andb (OCaml.Stdlib.le n p) (OCaml.Stdlib.lt p (Z.add n m)) then
        Stdlib.raise extensible_type_value
      else
        tt
    | _ =&gt; Constr.iter_with_binders Z.succ occur_rec n c
    end in
  (* ❌ Try-with are not handled *)
  try
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    true.

Definition isMeta (c : Constr.constr) : bool :=
  match Constr.kind c with
  | Constr.Meta _ =&gt; true
  | _ =&gt; false
  end.

Definition noccur_with_meta (n : Z) (m : Z) (term : Constr.constr) : bool :=
  let fix occur_rec (n : Z) (c : Constr.constr) {struct n} : unit :=
    match Constr.kind c with
    | Constr.Rel p =&gt;
      if andb (OCaml.Stdlib.le n p) (OCaml.Stdlib.lt p (Z.add n m)) then
        Stdlib.raise extensible_type_value
      else
        tt
    | Constr.App f _cl =&gt;
      match
        ((Constr.kind f),
          match Constr.kind f with
          | Constr.Cast c _ _ =&gt; isMeta c
          | _ =&gt; false
          end) with
      | (Constr.Cast c _ _, true) =&gt; tt
      | (Constr.Meta _, _) =&gt; tt
      | (_, _) =&gt; Constr.iter_with_binders Z.succ occur_rec n c
      end
    | Constr.Evar (_, _) =&gt; tt
    | _ =&gt; Constr.iter_with_binders Z.succ occur_rec n c
    end in
  (* ❌ Try-with are not handled *)
  try
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    true.

Definition exliftn : Esubst.lift -&gt; Constr.constr -&gt; Constr.constr :=
  Constr.exliftn.

Definition liftn : Z -&gt; Z -&gt; Constr.constr -&gt; Constr.constr := Constr.liftn.

Definition lift : Z -&gt; Constr.constr -&gt; Constr.constr := Constr.lift.

Inductive info : Set :=
| Closed : info
| Open : info
| Unknown : info.

Module substituend.
  Record record {a : Set} := {
    sinfo : info;
    sit : a }.
  Arguments record : clear implicits.
  Definition with_sinfo {a_type : Set} (r : record a_type) sinfo
    : record a_type :=
    {| sinfo := sinfo; sit := sit r |}.
  Definition with_sit {a_type : Set} (r : record a_type) sit : record a_type :=
    {| sinfo := sinfo r; sit := sit |}.
End substituend.
Definition substituend := substituend.record.

Definition lift_substituend (depth : Z) (s : substituend Constr.constr)
  : Constr.constr :=
  match substituend.sinfo s with
  | Closed =&gt; substituend.sit s
  | Open =&gt; lift depth (substituend.sit s)
  | Unknown =&gt;
    let sit := substituend.sit s in
    if closed0 sit then
      let '_ :=
        (* ❌ Set record field not handled. *)
        set_record_field s &quot;sinfo&quot; Closed in
      sit
    else
      let '_ :=
        (* ❌ Set record field not handled. *)
        set_record_field s &quot;sinfo&quot; Open in
      lift depth sit
  end.

Definition make_substituend {A : Set} (c : A) : substituend A :=
  {| substituend.sinfo := Unknown; substituend.sit := c |}.

Definition substn_many
  (lamv : array (substituend Constr.constr)) (n : Z) (c : Constr.constr)
  : Constr.constr :=
  let lv := Array.length lamv in
  if Int.equal lv 0 then
    c
  else
    let fix substrec (depth : Z) (c : Constr.constr) {struct depth}
      : Constr.constr :=
      match Constr.kind c with
      | Constr.Rel k =&gt;
        if OCaml.Stdlib.le k depth then
          c
        else
          if OCaml.Stdlib.le (Z.sub k depth) lv then
            lift_substituend depth
              (Array.unsafe_get lamv (Z.sub (Z.sub k depth) 1))
          else
            Constr.mkRel (Z.sub k lv)
      | _ =&gt; Constr.map_with_binders Z.succ substrec depth c
      end in
    substrec n c.

Definition make_subst {A : Set} (function_parameter : list A)
  : array (substituend A) :=
  match function_parameter with
  | [] =&gt;
    (* ❌ Arrays not handled. *)
    [ ]
  | cons hd tl =&gt;
    let len := OCaml.List.length tl in
    let subst := Array.make (Z.add 1 len) (make_substituend hd) in
    let s := Stdlib.__ref_value tl in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    subst
  end.

Definition substl := list Constr.t.

Definition substnl (laml : list Constr.constr) (n : Z) (c : Constr.constr)
  : Constr.constr := substn_many (make_subst laml) n c.

Definition substl (laml : list Constr.constr) (c : Constr.constr)
  : Constr.constr := substn_many (make_subst laml) 0 c.

Definition subst1 (lam : Constr.constr) (c : Constr.constr) : Constr.constr :=
  substn_many
    (* ❌ Arrays not handled. *)
    [ make_substituend lam ] 0 c.

Definition substnl_decl
  (laml : list Constr.constr) (k : Z)
  (r : RelDecl.pt Constr.constr Constr.constr)
  : RelDecl.pt Constr.constr Constr.constr :=
  RelDecl.map_constr (fun c =&gt; substnl laml k c) r.

Definition substl_decl
  (laml : list Constr.constr) (r : RelDecl.pt Constr.constr Constr.constr)
  : RelDecl.pt Constr.constr Constr.constr :=
  RelDecl.map_constr (fun c =&gt; substnl laml 0 c) r.

Definition subst1_decl
  (lam : Constr.constr) (r : RelDecl.pt Constr.constr Constr.constr)
  : RelDecl.pt Constr.constr Constr.constr :=
  RelDecl.map_constr (fun c =&gt; subst1 lam c) r.

Definition subst_of_rel_context_instance {A : Set}
  (sign : list (RelDecl.pt Constr.constr A)) (l : list Constr.constr)
  : list Constr.constr :=
  let fix aux {B : Set}
    (subst : list Constr.constr) (sign : list (RelDecl.pt Constr.constr B))
    (l : list Constr.constr) {struct subst} : list Constr.constr :=
    match (sign, l) with
    | (cons (RelDecl.LocalAssum _ _) sign', cons a args') =&gt;
      aux (cons a subst) sign' args'
    | (cons (RelDecl.LocalDef _ c _) sign', args') =&gt;
      aux (cons (substl subst c) subst) sign' args'
    | ([], []) =&gt; subst
    | _ =&gt;
      CErrors.anomaly None None (Pp.str &quot;Instance and signature do not match.&quot;)
    end in
  aux [] (List.rev sign) l.

Definition adjust_subst_to_rel_context {A : Set}
  (sign : list (RelDecl.pt Constr.constr A)) (l : list Constr.constr)
  : list Constr.constr := List.rev (subst_of_rel_context_instance sign l).

Definition adjust_rel_to_rel_context {A B : Set}
  (sign : list (RelDecl.pt A B)) (n : Z) : Z :=
  let fix aux {C D : Set} (sign : list (RelDecl.pt C D)) {struct sign}
    : Z * Z :=
    match sign with
    | cons (RelDecl.LocalAssum _ _) sign' =&gt;
      let '(n', p) := aux sign' in
      ((Z.add n' 1), p)
    | cons (RelDecl.LocalDef _ _c _) sign' =&gt;
      let '(n', p) := aux sign' in
      ((Z.add n' 1),
        (if OCaml.Stdlib.lt n' n then
          Z.add p 1
        else
          p))
    | [] =&gt; (0, n)
    end in
  snd (aux sign).

Fixpoint thin_val (function_parameter : list (Names.Id.t * Constr.constr))
  {struct function_parameter} : list (Names.Id.t * substituend Constr.constr) :=
  match function_parameter with
  | [] =&gt; []
  | cons (id, c) tl =&gt;
    match Constr.kind c with
    | Constr.Var v =&gt;
      if Id.equal id v then
        thin_val tl
      else
        cons (id, (make_substituend c)) (thin_val tl)
    | _ =&gt; cons (id, (make_substituend c)) (thin_val tl)
    end
  end.

Fixpoint find_var {A : Set}
  (id : Names.Id.t) (function_parameter : list (Names.Id.t * A)) {struct id}
  : A :=
  match function_parameter with
  | [] =&gt; Stdlib.raise extensible_type_value
  | cons (idc, c) subst =&gt;
    if Id.equal id idc then
      c
    else
      find_var id subst
  end.

Definition replace_vars
  (var_alist : list (Names.Id.t * Constr.constr)) (x : Constr.constr)
  : Constr.constr :=
  let var_alist := thin_val var_alist in
  match var_alist with
  | [] =&gt; x
  | _ =&gt;
    let fix substrec (n : Z) (c : Constr.constr) {struct n} : Constr.constr :=
      match Constr.kind c with
      | Constr.Var x =&gt;
        (* ❌ Try-with are not handled *)
        try (lift_substituend n (find_var x var_alist))
      | _ =&gt; Constr.map_with_binders Z.succ substrec n c
      end in
    substrec 0 x
  end.

Definition subst_var (str : Names.Id.t) (t : Constr.constr) : Constr.constr :=
  replace_vars [ (str, (Constr.mkRel 1)) ] t.

Definition substn_vars (p : Z) (vars : list Names.Id.t) (c : Constr.constr)
  : Constr.constr :=
  let '(_, subst) :=
    Stdlib.List.fold_left
      (fun function_parameter =&gt;
        let '(n, l) := function_parameter in
        fun var =&gt; ((Z.add n 1), (cons (var, (Constr.mkRel n)) l))) (p, []) vars
    in
  replace_vars (List.rev subst) c.

Definition subst_vars (subst : list Names.Id.t) (c : Constr.constr)
  : Constr.constr := substn_vars 1 subst c.

Import Constr.

Definition subst_univs_level_constr
  (subst : Univ.universe_level_subst) (c : Constr.constr) : Constr.constr :=
  if Univ.is_empty_level_subst subst then
    c
  else
    let f := Univ.Instance.subst_fn (Univ.subst_univs_level_level subst) in
    let changed := Stdlib.__ref_value false in
    let fix aux (t : Constr.constr) {struct t} : Constr.constr :=
      match kind t with
      | Constr.Const (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eqeq u' u then
            t
          else
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            mkConstU (c, u')
      | Constr.Ind (i, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eqeq u' u then
            t
          else
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            mkIndU (i, u')
      | Constr.Construct (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eqeq u' u then
            t
          else
            (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
            (* ❌ instruction_sequence &quot;;&quot; *)
            mkConstructU (c, u')
      | Constr.Sort (Sorts.Type u) =&gt;
        let u' := Univ.subst_univs_level_universe subst u in
        if Stdlib.op_eqeq u' u then
          t
        else
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          mkSort (Sorts.sort_of_univ u')
      | _ =&gt; Constr.map aux t
      end in
    let c' := aux c in
    if Stdlib.op_exclamation changed then
      c'
    else
      c.

Definition subst_univs_level_context (s : Univ.universe_level_subst)
  : Context.Rel.pt Constr.constr Constr.constr -&gt;
  Context.Rel.pt Constr.constr Constr.constr :=
  Context.Rel.map (subst_univs_level_constr s).

Definition subst_instance_constr (subst : Univ.Instance.t) (c : Constr.constr)
  : Constr.constr :=
  if Univ.Instance.is_empty subst then
    c
  else
    let f (u : Univ.Instance.t) : Univ.Instance.t :=
      Univ.subst_instance_instance subst u in
    let fix aux (t : Constr.constr) {struct t} : Constr.constr :=
      match kind t with
      | Constr.Const (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eqeq u' u then
            t
          else
            mkConstU (c, u')
      | Constr.Ind (i, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eqeq u' u then
            t
          else
            mkIndU (i, u')
      | Constr.Construct (c, u) =&gt;
        if Univ.Instance.is_empty u then
          t
        else
          let u' := f u in
          if Stdlib.op_eqeq u' u then
            t
          else
            mkConstructU (c, u')
      | Constr.Sort (Sorts.Type u) =&gt;
        let u' := Univ.subst_instance_universe subst u in
        if Stdlib.op_eqeq u' u then
          t
        else
          mkSort (Sorts.sort_of_univ u')
      | _ =&gt; Constr.map aux t
      end in
    aux c.

Definition univ_instantiate_constr
  (u : Univ.Instance.t) (c : Univ.univ_abstracted Constr.constr)
  : Constr.constr :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  subst_instance_constr u (Univ.univ_abstracted.univ_abstracted_value c).

Definition subst_instance_context
  (s : Univ.Instance.t) (ctx : Context.Rel.pt Constr.constr Constr.constr)
  : Context.Rel.pt Constr.constr Constr.constr :=
  if Univ.Instance.is_empty s then
    ctx
  else
    Context.Rel.map (fun x =&gt; subst_instance_constr s x) ctx.

Definition universes_of_constr (c : Constr.constr) : Univ.LSet.t :=
  let fix aux (s : Univ.LSet.t) (c : Constr.constr) {struct s} : Univ.LSet.t :=
    match
      ((kind c),
        match kind c with
        | Constr.Sort u =&gt; negb (Sorts.is_small u)
        | _ =&gt; false
        end) with
    | (Constr.Const (_c, u), _) =&gt; LSet.fold LSet.add (Instance.levels u) s
    | (Constr.Ind ((_mind, _), u) | Constr.Construct (((_mind, _), _), u), _) =&gt;
      LSet.fold LSet.add (Instance.levels u) s
    | (Constr.Sort u, true) =&gt;
      let u := Sorts.univ_of_sort u in
      LSet.fold LSet.add (Universe.levels u) s
    | (_, _) =&gt; Constr.fold aux s c
    end in
  aux LSet.empty c.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vars.mli">
  <div style="margin: 20px;">
    <h3>Vars_mli</h3>
    <ul>
      <li>OCaml size: 146 lines</li>
      <li>Coq size: 78 lines (-47% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vars.mli"><code>vars.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr

(** {6 Occur checks } *)

(** [closedn n M] is true iff [M] is a (de Bruijn) closed term under n binders *)
val closedn : int -&gt; constr -&gt; bool

(** [closed0 M] is true iff [M] is a (de Bruijn) closed term *)
val closed0 : constr -&gt; bool

(** [noccurn n M] returns true iff [Rel n] does NOT occur in term [M]  *)
val noccurn : int -&gt; constr -&gt; bool

(** [noccur_between n m M] returns true iff [Rel p] does NOT occur in term [M]
  for n &lt;= p &lt; n+m *)
val noccur_between : int -&gt; int -&gt; constr -&gt; bool

(** Checking function for terms containing existential- or
   meta-variables.  The function [noccur_with_meta] does not consider
   meta-variables applied to some terms (intended to be its local
   context) (for existential variables, it is necessarily the case) *)
val noccur_with_meta : int -&gt; int -&gt; constr -&gt; bool

(** {6 Relocation and substitution } *)

(** [exliftn el c] lifts [c] with lifting [el] *)
val exliftn : Esubst.lift -&gt; constr -&gt; constr

(** [liftn n k c] lifts by [n] indexes above or equal to [k] in [c] *)
val liftn : int -&gt; int -&gt; constr -&gt; constr

(** [lift n c] lifts by [n] the positive indexes in [c] *)
val lift : int -&gt; constr -&gt; constr

(** The type [substl] is the type of substitutions [uâ..un] of type
    some context Î and defined in some environment Î. Typing of
    substitutions is defined by:
    - Î â¢ â : â,
    - Î â¢ uâ..u{_n-1} : Î and Î â¢ u{_n} : An\[uâ..u{_n-1}\] implies
      Î â¢ uâ..u{_n} : Î,x{_n}:A{_n}
    - Î â¢ uâ..u{_n-1} : Î and Î â¢ un : A{_n}\[uâ..u{_n-1}\] implies
      Î â¢ uâ..u{_n} : Î,x{_n}:=c{_n}:A{_n} when Î â¢ u{_n} â¡ c{_n}\[uâ..u{_n-1}\]

    Note that [uâ..un] is represented as a list with [un] at the head of
    the list, i.e. as [[un;...;uâ]]. *)

type substl = constr list

(** Let [Î] be a context interleaving declarations [xâ:Tâ..xn:Tn]
   and definitions [yâ:=câ..yp:=cp] in some context [Îâ]. Let
   [uâ..un] be an {e instance} of [Î], i.e. an instance in [Îâ]
   of the [xi]. Then, [subst_of_rel_context_instance Î uâ..un]
   returns the corresponding {e substitution} of [Î], i.e. the
   appropriate interleaving [Ï] of the [uâ..un] with the [câ..cp],
   all of them in [Îâ], so that a derivation [Îâ, Î, Îâ|- t:T]
   can be instantiated into a derivation [Îâ, Îâ |- t[Ï]:T[Ï]] using
   [substnl Ï |Îâ| t].
   Note that the instance [uâ..un] is represented starting with [uâ],
   as if usable in [applist] while the substitution is
   represented the other way round, i.e. ending with either [uâ] or
   [câ], as if usable for [substl]. *)
val subst_of_rel_context_instance : Constr.rel_context -&gt; constr list -&gt; substl

(** For compatibility: returns the substitution reversed *)
val adjust_subst_to_rel_context : Constr.rel_context -&gt; constr list -&gt; constr list

(** Take an index in an instance of a context and returns its index wrt to
    the full context (e.g. 2 in [x:A;y:=b;z:C] is 3, i.e. a reference to z) *)
val adjust_rel_to_rel_context : ('a, 'b) Context.Rel.pt -&gt; int -&gt; int

(** [substnl [aâ;...;an] k c] substitutes in parallel [aâ],...,[an]
    for respectively [Rel(k+1)],...,[Rel(k+n)] in [c]; it relocates
    accordingly indexes in [an],...,[a1] and [c]. In terms of typing, if
    Î â¢ a{_n}..aâ : Î and Î, Î, Î' â¢ c : T with |Î'|=k, then
    Î, Î' â¢ [substnl [aâ;...;an] k c] : [substnl [aâ;...;an] k T]. *)
val substnl : substl -&gt; int -&gt; constr -&gt; constr

(** [substl Ï c] is a short-hand for [substnl Ï 0 c] *)
val substl : substl -&gt; constr -&gt; constr

(** [substl a c] is a short-hand for [substnl [a] 0 c] *)
val subst1 : constr -&gt; constr -&gt; constr

(** [substnl_decl [aâ;...;an] k Î©] substitutes in parallel [aâ], ..., [an]
    for respectively [Rel(k+1)], ..., [Rel(k+n)] in [Î©]; it relocates
    accordingly indexes in [aâ],...,[an] and [c]. In terms of typing, if
    Î â¢ a{_n}..aâ : Î and Î, Î, Î', Î© â¢ with |Î'|=[k], then
    Î, Î', [substnl_decl [aâ;...;an]] k Î© â¢. *)
val substnl_decl : substl -&gt; int -&gt; Constr.rel_declaration -&gt; Constr.rel_declaration

(** [substl_decl Ï Î©] is a short-hand for [substnl_decl Ï 0 Î©] *)
val substl_decl : substl -&gt; Constr.rel_declaration -&gt; Constr.rel_declaration

(** [subst1_decl a Î©] is a short-hand for [substnl_decl [a] 0 Î©] *)
val subst1_decl : constr -&gt; Constr.rel_declaration -&gt; Constr.rel_declaration

(** [replace_vars k [(idâ,câ);...;(idn,cn)] t] substitutes [Var idj] by
    [cj] in [t]. *)
val replace_vars : (Id.t * constr) list -&gt; constr -&gt; constr

(** [substn_vars k [idâ;...;idn] t] substitutes [Var idj] by [Rel j+k-1] in [t].
   If two names are identical, the one of least index is kept. In terms of
   typing, if Î,x{_n}:U{_n},...,xâ:Uâ,Î' â¢ t:T, together with id{_j}:T{_j} and
   Î,x{_n}:U{_n},...,xâ:Uâ,Î' â¢ T{_j}\[id{_j+1}..id{_n}:=x{_j+1}..x{_n}\] â¡ Uj,
   then Î\\{idâ,...,id{_n}\},x{_n}:U{_n},...,xâ:Uâ,Î' â¢ [substn_vars
   (|Î'|+1) [idâ;...;idn] t] : [substn_vars (|Î'|+1) [idâ;...;idn]
   T]. *)
val substn_vars : int -&gt; Id.t list -&gt; constr -&gt; constr

(** [subst_vars [id1;...;idn] t] is a short-hand for [substn_vars
   [id1;...;idn] 1 t]: it substitutes [Var idj] by [Rel j] in [t]. If
   two names are identical, the one of least index is kept. *)
val subst_vars : Id.t list -&gt; constr -&gt; constr

(** [subst_var id t] is a short-hand for [substn_vars [id] 1 t]: it
    substitutes [Var id] by [Rel 1] in [t]. *)
val subst_var : Id.t -&gt; constr -&gt; constr

(** {3 Substitution of universes} *)

open Univ

(** Level substitutions for polymorphism. *)

val subst_univs_level_constr : universe_level_subst -&gt; constr -&gt; constr
val subst_univs_level_context : Univ.universe_level_subst -&gt; Constr.rel_context -&gt; Constr.rel_context

(** Instance substitution for polymorphism. *)
val subst_instance_constr : Instance.t -&gt; constr -&gt; constr
val subst_instance_context : Instance.t -&gt; Constr.rel_context -&gt; Constr.rel_context

val univ_instantiate_constr : Instance.t -&gt; constr univ_abstracted -&gt; constr
(** Ignores the constraints carried by [univ_abstracted]. *)

val universes_of_constr : constr -&gt; Univ.LSet.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vars.mli"><code>Vars_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter closedn : Z -&gt; Constr.constr -&gt; bool.

Parameter closed0 : Constr.constr -&gt; bool.

Parameter noccurn : Z -&gt; Constr.constr -&gt; bool.

Parameter noccur_between : Z -&gt; Z -&gt; Constr.constr -&gt; bool.

Parameter noccur_with_meta : Z -&gt; Z -&gt; Constr.constr -&gt; bool.

Parameter exliftn : Esubst.lift -&gt; Constr.constr -&gt; Constr.constr.

Parameter liftn : Z -&gt; Z -&gt; Constr.constr -&gt; Constr.constr.

Parameter lift : Z -&gt; Constr.constr -&gt; Constr.constr.

Definition substl := list Constr.constr.

Parameter subst_of_rel_context_instance :
  Constr.rel_context -&gt; list Constr.constr -&gt; substl.

Parameter adjust_subst_to_rel_context :
  Constr.rel_context -&gt; list Constr.constr -&gt; list Constr.constr.

Parameter adjust_rel_to_rel_context : forall {a b : Set},
  Context.Rel.pt a b -&gt; Z -&gt; Z.

Parameter substnl : substl -&gt; Z -&gt; Constr.constr -&gt; Constr.constr.

Parameter substl : substl -&gt; Constr.constr -&gt; Constr.constr.

Parameter subst1 : Constr.constr -&gt; Constr.constr -&gt; Constr.constr.

Parameter substnl_decl :
  substl -&gt; Z -&gt; Constr.rel_declaration -&gt; Constr.rel_declaration.

Parameter substl_decl :
  substl -&gt; Constr.rel_declaration -&gt; Constr.rel_declaration.

Parameter subst1_decl :
  Constr.constr -&gt; Constr.rel_declaration -&gt; Constr.rel_declaration.

Parameter replace_vars :
  list (Names.Id.t * Constr.constr) -&gt; Constr.constr -&gt; Constr.constr.

Parameter substn_vars : Z -&gt; list Names.Id.t -&gt; Constr.constr -&gt; Constr.constr.

Parameter subst_vars : list Names.Id.t -&gt; Constr.constr -&gt; Constr.constr.

Parameter subst_var : Names.Id.t -&gt; Constr.constr -&gt; Constr.constr.

Parameter subst_univs_level_constr :
  Univ.universe_level_subst -&gt; Constr.constr -&gt; Constr.constr.

Parameter subst_univs_level_context :
  Univ.universe_level_subst -&gt; Constr.rel_context -&gt; Constr.rel_context.

Parameter subst_instance_constr :
  Univ.Instance.t -&gt; Constr.constr -&gt; Constr.constr.

Parameter subst_instance_context :
  Univ.Instance.t -&gt; Constr.rel_context -&gt; Constr.rel_context.

Parameter univ_instantiate_constr :
  Univ.Instance.t -&gt; Univ.univ_abstracted Constr.constr -&gt; Constr.constr.

Parameter universes_of_constr : Constr.constr -&gt; Univ.LSet.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vconv.ml">
  <div style="margin: 20px;">
    <h3>Vconv</h3>
    <ul>
      <li>OCaml size: 207 lines</li>
      <li>Coq size: 320 lines (+54% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vconv.ml"><code>vconv.ml</code></a>&nbsp;<span class="label label-warning">25 warnings</span>
    
    <pre>open Util
open Names
open Environ
open Reduction
open Vm
open Vmvalues
open Csymtable

(* Test la structure des piles *)

let compare_zipper z1 z2 =
  match z1, z2 with
  | Zapp args1, Zapp args2 -&gt; Int.equal (nargs args1) (nargs args2)
  | Zfix(_f1,args1), Zfix(_f2,args2) -&gt;  Int.equal (nargs args1) (nargs args2)
  | Zswitch _, Zswitch _ | Zproj _, Zproj _ -&gt; true
  | Zapp _ , _ | Zfix _, _ | Zswitch _, _ | Zproj _, _ -&gt; false

let rec compare_stack stk1 stk2 =
  match stk1, stk2 with
  | [], [] -&gt; true
  | z1::stk1, z2::stk2 -&gt;
      if compare_zipper z1 z2 then compare_stack stk1 stk2
      else false
  | _, _ -&gt; false

(* Conversion *)
let conv_vect fconv vect1 vect2 cu =
  let n = Array.length vect1 in
  if Int.equal n (Array.length vect2) then
    let rcu = ref cu in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to n - 1 do
      rcu := fconv vect1.(i) vect2.(i) !rcu
    done;
    !rcu</abbr>
  else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

let rec conv_val env pb k v1 v2 cu =
  if v1 == v2 then cu
  else conv_whd env pb k (whd_val v1) (whd_val v2) cu

and conv_whd env pb k whd1 whd2 cu =
(*  Pp.(msg_debug (str &quot;conv_whd(&quot; ++ pr_whd whd1 ++ str &quot;, &quot; ++ pr_whd whd2 ++ str &quot;)&quot;)) ; *)
  match whd1, whd2 with
  | Vuniv_level _ , _
  | _ , Vuniv_level _ -&gt;
    (** Both of these are invalid since universes are handled via
     ** special cases in the code.
     **)
    <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Vprod p1, Vprod p2 -&gt;
      let cu = conv_val env CONV k (dom p1) (dom p2) cu in
      conv_fun env pb k (codom p1) (codom p2) cu
  | Vfun f1, Vfun f2 -&gt; conv_fun env CONV k f1 f2 cu
  | Vfix (f1,None), Vfix (f2,None) -&gt; conv_fix env k f1 f2 cu
  | Vfix (f1,Some args1), Vfix(f2,Some args2) -&gt;
      if nargs args1 &lt;&gt; nargs args2 then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
      else conv_arguments env k args1 args2 (conv_fix env k f1 f2 cu)
  | Vcofix (cf1,_,None), Vcofix (cf2,_,None) -&gt; conv_cofix env k cf1 cf2 cu
  | Vcofix (cf1,_,Some args1), Vcofix (cf2,_,Some args2) -&gt;
      if nargs args1 &lt;&gt; nargs args2 then raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
      else conv_arguments env k args1 args2 (conv_cofix env k cf1 cf2 cu)
  | Vconstr_const i1, Vconstr_const i2 -&gt;
      if Int.equal i1 i2 then cu else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
  | Vconstr_block b1, Vconstr_block b2 -&gt;
      let tag1 = btag b1 and tag2 = btag b2 in
      let sz = bsize b1 in
      if Int.equal tag1 tag2 &amp;&amp; Int.equal sz (bsize b2) then
        let rcu = ref cu in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to sz - 1 do
          rcu := conv_val env CONV k (bfield b1 i) (bfield b2 i) !rcu
        done;
        !rcu</abbr>
      else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
  | Vint64 i1, Vint64 i2 -&gt;
    if Int64.equal i1 i2 then cu else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
  | Vatom_stk(a1,stk1), Vatom_stk(a2,stk2) -&gt;
      conv_atom env pb k a1 stk1 a2 stk2 cu
  | Vfun _, _ | _, Vfun _ -&gt;
     (* on the fly eta expansion *)
      conv_val env CONV (k+1) (apply_whd k whd1) (apply_whd k whd2) cu

  | Vprod _, _ | Vfix _, _ | Vcofix _, _  | Vconstr_const _, _ | Vint64 _, _
  | Vconstr_block _, _ | Vatom_stk _, _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>


and conv_atom env pb k a1 stk1 a2 stk2 cu =
(*  Pp.(msg_debug (str &quot;conv_atom(&quot; ++ pr_atom a1 ++ str &quot;, &quot; ++ pr_atom a2 ++ str &quot;)&quot;)) ; *)
  match a1, a2 with
  | Aind ((mi,_i) as ind1) , Aind ind2 -&gt;
    if eq_ind ind1 ind2 &amp;&amp; compare_stack stk1 stk2 then
      let ulen = Univ.AUContext.size (Environ.mind_context env mi) in
      if ulen = 0 then
        conv_stack env k stk1 stk2 cu
      else
        match stk1 , stk2 with
        | Zapp args1 :: stk1' , Zapp args2 :: stk2' -&gt;
          <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (ulen &lt;= nargs args1);
          </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (ulen &lt;= nargs args2);
          let u1 = Array.init ulen (fun i -&gt; uni_lvl_val (arg args1 i)) in
          let u2 = Array.init ulen (fun i -&gt; uni_lvl_val (arg args2 i)) in
          let u1 = Univ.Instance.of_array u1 in
          let u2 = Univ.Instance.of_array u2 in
          let cu = convert_instances ~flex:false u1 u2 cu in
          conv_arguments env ~from:ulen k args1 args2
            (conv_stack env k stk1' stk2' cu)</abbr>
        | _, _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* Should not happen if problem is well typed *)
    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
  | Aid ik1, Aid ik2 -&gt;
    if Vmvalues.eq_id_key ik1 ik2 &amp;&amp; compare_stack stk1 stk2 then
        conv_stack env k stk1 stk2 cu
      else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
  | Asort s1, Asort s2 -&gt;
    sort_cmp_universes env pb s1 s2 cu
  | Asort _ , _ | Aind _, _ | Aid _, _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

and conv_stack env k stk1 stk2 cu =
  match stk1, stk2 with
  | [], [] -&gt; cu
  | Zapp args1 :: stk1, Zapp args2 :: stk2 -&gt;
      conv_stack env k stk1 stk2 (conv_arguments env k args1 args2 cu)
  | Zfix(f1,args1) :: stk1, Zfix(f2,args2) :: stk2 -&gt;
      conv_stack env k stk1 stk2
        (conv_arguments env k args1 args2 (conv_fix env k f1 f2 cu))
  | Zswitch sw1 :: stk1, Zswitch sw2 :: stk2 -&gt;
      if check_switch sw1 sw2 then
        let vt1,vt2 = type_of_switch sw1, type_of_switch sw2 in
        let rcu = ref (conv_val env CONV k vt1 vt2 cu) in
        let b1, b2 = branch_of_switch k sw1, branch_of_switch k sw2 in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to Array.length b1 - 1 do
          rcu :=
            conv_val env CONV (k + fst b1.(i)) (snd b1.(i)) (snd b2.(i)) !rcu
        done;
        conv_stack env k stk1 stk2 !rcu</abbr>
      else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
  | Zproj p1 :: stk1, Zproj p2 :: stk2 -&gt;
    if Projection.Repr.equal p1 p2 then conv_stack env k stk1 stk2 cu
    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>
  | [], _ | Zapp _ :: _, _ | Zfix _ :: _, _ | Zswitch _ :: _, _
  | Zproj _ :: _, _ -&gt; raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

and conv_fun env pb k f1 f2 cu =
  if f1 == f2 then cu
  else
    let arity,b1,b2 = decompose_vfun2 k f1 f2 in
    conv_val env pb (k+arity) b1 b2 cu

and conv_fix env k f1 f2 cu =
  if f1 == f2 then cu
  else
    if check_fix f1 f2 then
      let bf1, tf1 = reduce_fix k f1 in
      let bf2, tf2 = reduce_fix k f2 in
      let cu = conv_vect (conv_val env CONV k) tf1 tf2 cu in
      conv_vect (conv_fun env CONV (k + Array.length tf1)) bf1 bf2 cu
    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

and conv_cofix env k cf1 cf2 cu =
  if cf1 == cf2 then cu
  else
    if check_cofix cf1 cf2 then
      let bcf1, tcf1 = reduce_cofix k cf1 in
      let bcf2, tcf2 = reduce_cofix k cf2 in
      let cu = conv_vect (conv_val env CONV k) tcf1 tcf2 cu in
      conv_vect (conv_val env CONV (k + Array.length tcf1)) bcf1 bcf2 cu
    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

and conv_arguments env ?from:(from=0) k args1 args2 cu =
  if args1 == args2 then cu
  else
    let n = nargs args1 in
    if Int.equal n (nargs args2) then
      let rcu = ref cu in
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = from to n - 1 do
        rcu := conv_val env CONV k (arg args1 i) (arg args2 i) !rcu
      done;
      !rcu</abbr>
    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">NotConvertible</abbr>

let warn_bytecode_compiler_failed =
  let open Pp in
  CWarnings.create ~name:&quot;bytecode-compiler-failed&quot; ~category:&quot;bytecode-compiler&quot;
         (fun () -&gt; strbrk &quot;Bytecode compiler failed, &quot; ++
                      strbrk &quot;falling back to standard conversion&quot;)

let vm_conv_gen cv_pb env univs t1 t2 =
  if not (typing_flags env).Declarations.enable_VM then
    Reduction.generic_conv cv_pb ~l2r:false (fun _ -&gt; None)
      TransparentState.full env univs t1 t2
  else
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let v1 = val_of_constr env t1 in
    let v2 = val_of_constr env t2 in
    fst (conv_val env cv_pb (nb_rel env) v1 v2 univs)
  with Not_found | Invalid_argument _ -&gt;
    warn_bytecode_compiler_failed ();
    Reduction.generic_conv cv_pb ~l2r:false (fun _ -&gt; None)
      TransparentState.full env univs t1 t2</abbr>

let vm_conv cv_pb env t1 t2 =
  let univs = Environ.universes env in
  let b =
    if cv_pb = CUMUL then Constr.leq_constr_univs univs t1 t2
    else Constr.eq_constr_univs univs t1 t2
  in
  if not b then
    let univs = (univs, checked_universes) in
    let _ = vm_conv_gen cv_pb env univs t1 t2 in ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vconv.ml"><code>Vconv.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Util.

Import Names.

Import Environ.

Import Reduction.

Import Vm.

Import Vmvalues.

Import Csymtable.

Definition compare_zipper (z1 : Vmvalues.zipper) (z2 : Vmvalues.zipper)
  : bool :=
  match (z1, z2) with
  | (Vmvalues.Zapp args1, Vmvalues.Zapp args2) =&gt;
    Int.equal (nargs args1) (nargs args2)
  | (Vmvalues.Zfix _f1 args1, Vmvalues.Zfix _f2 args2) =&gt;
    Int.equal (nargs args1) (nargs args2)
  |
    (Vmvalues.Zswitch _, Vmvalues.Zswitch _) |
    (Vmvalues.Zproj _, Vmvalues.Zproj _) =&gt; true
  |
    (Vmvalues.Zapp _, _) | (Vmvalues.Zfix _ _, _) | (Vmvalues.Zswitch _, _) |
    (Vmvalues.Zproj _, _) =&gt; false
  end.

Fixpoint compare_stack
  (stk1 : list Vmvalues.zipper) (stk2 : list Vmvalues.zipper) {struct stk1}
  : bool :=
  match (stk1, stk2) with
  | ([], []) =&gt; true
  | (cons z1 stk1, cons z2 stk2) =&gt;
    if compare_zipper z1 z2 then
      compare_stack stk1 stk2
    else
      false
  | (_, _) =&gt; false
  end.

Definition conv_vect {A B C : Set}
  (fconv : A -&gt; B -&gt; C -&gt; C) (vect1 : array A) (vect2 : array B) (cu : C) : C :=
  let n := (|Util.Array|).(CArray.ExtS.length) vect1 in
  if Int.equal n ((|Util.Array|).(CArray.ExtS.length) vect2) then
    let rcu := Stdlib.__ref_value cu in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Stdlib.op_exclamation rcu
  else
    Stdlib.raise extensible_type_value.

Fixpoint conv_val {A : Set}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (v1 : Vmvalues.values)
  (v2 : Vmvalues.values) (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  if Stdlib.op_eqeq v1 v2 then
    cu
  else
    conv_whd env pb k (whd_val v1) (whd_val v2) cu

with conv_whd {A : Set}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (whd1 : Vmvalues.whd)
  (whd2 : Vmvalues.whd) (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  match (whd1, whd2) with
  | (Vmvalues.Vuniv_level _, _) | (_, Vmvalues.Vuniv_level _) =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | (Vmvalues.Vprod p1, Vmvalues.Vprod p2) =&gt;
    let cu := conv_val env Reduction.CONV k (dom p1) (dom p2) cu in
    conv_fun env pb k (codom p1) (codom p2) cu
  | (Vmvalues.Vfun f1, Vmvalues.Vfun f2) =&gt;
    conv_fun env Reduction.CONV k f1 f2 cu
  | (Vmvalues.Vfix f1 None, Vmvalues.Vfix f2 None) =&gt; conv_fix env k f1 f2 cu
  | (Vmvalues.Vfix f1 (Some args1), Vmvalues.Vfix f2 (Some args2)) =&gt;
    if nequiv_decb (nargs args1) (nargs args2) then
      Stdlib.raise extensible_type_value
    else
      conv_arguments env None k args1 args2 (conv_fix env k f1 f2 cu)
  | (Vmvalues.Vcofix cf1 _ None, Vmvalues.Vcofix cf2 _ None) =&gt;
    conv_cofix env k cf1 cf2 cu
  | (Vmvalues.Vcofix cf1 _ (Some args1), Vmvalues.Vcofix cf2 _ (Some args2)) =&gt;
    if nequiv_decb (nargs args1) (nargs args2) then
      Stdlib.raise extensible_type_value
    else
      conv_arguments env None k args1 args2 (conv_cofix env k cf1 cf2 cu)
  | (Vmvalues.Vconstr_const i1, Vmvalues.Vconstr_const i2) =&gt;
    if Int.equal i1 i2 then
      cu
    else
      Stdlib.raise extensible_type_value
  | (Vmvalues.Vconstr_block b1, Vmvalues.Vconstr_block b2) =&gt;
    let tag1 : Z :=
      btag b1
    with tag2 : Z :=
      btag b2 in
    let sz := bsize b1 in
    if andb (Int.equal tag1 tag2) (Int.equal sz (bsize b2)) then
      let rcu := Stdlib.__ref_value cu in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      Stdlib.op_exclamation rcu
    else
      Stdlib.raise extensible_type_value
  | (Vmvalues.Vint64 i1, Vmvalues.Vint64 i2) =&gt;
    if Int64.equal i1 i2 then
      cu
    else
      Stdlib.raise extensible_type_value
  | (Vmvalues.Vatom_stk a1 stk1, Vmvalues.Vatom_stk a2 stk2) =&gt;
    conv_atom env pb k a1 stk1 a2 stk2 cu
  | (Vmvalues.Vfun _, _) | (_, Vmvalues.Vfun _) =&gt;
    conv_val env Reduction.CONV (Z.add k 1) (apply_whd k whd1)
      (apply_whd k whd2) cu
  |
    (Vmvalues.Vprod _, _) | (Vmvalues.Vfix _ _, _) | (Vmvalues.Vcofix _ _ _, _)
    | (Vmvalues.Vconstr_const _, _) | (Vmvalues.Vint64 _, _) |
    (Vmvalues.Vconstr_block _, _) | (Vmvalues.Vatom_stk _ _, _) =&gt;
    Stdlib.raise extensible_type_value
  end

with conv_atom {A : Set}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (a1 : Vmvalues.atom)
  (stk1 : Vmvalues.stack) (a2 : Vmvalues.atom) (stk2 : Vmvalues.stack)
  (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  match (a1, a2) with
  | (Vmvalues.Aind ((mi, _i) as ind1), Vmvalues.Aind ind2) =&gt;
    if andb (eq_ind ind1 ind2) (compare_stack stk1 stk2) then
      let ulen := Univ.AUContext.size (Environ.mind_context env mi) in
      if equiv_decb ulen 0 then
        conv_stack env k stk1 stk2 cu
      else
        match (stk1, stk2) with
        | (cons (Vmvalues.Zapp args1) stk1', cons (Vmvalues.Zapp args2) stk2')
          =&gt;
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          let u1 :=
            (|Util.Array|).(CArray.ExtS.init) ulen
              (fun i =&gt; uni_lvl_val (arg args1 i)) in
          let u2 :=
            (|Util.Array|).(CArray.ExtS.init) ulen
              (fun i =&gt; uni_lvl_val (arg args2 i)) in
          let u1 := Univ.Instance.of_array u1 in
          let u2 := Univ.Instance.of_array u2 in
          let cu := convert_instances false u1 u2 cu in
          conv_arguments env (Some ulen) k args1 args2
            (conv_stack env k stk1' stk2' cu)
        | (_, _) =&gt;
          (* ❌ Assert instruction is not handled. *)
          assert false
        end
    else
      Stdlib.raise extensible_type_value
  | (Vmvalues.Aid ik1, Vmvalues.Aid ik2) =&gt;
    if andb (Vmvalues.eq_id_key ik1 ik2) (compare_stack stk1 stk2) then
      conv_stack env k stk1 stk2 cu
    else
      Stdlib.raise extensible_type_value
  | (Vmvalues.Asort s1, Vmvalues.Asort s2) =&gt; sort_cmp_universes env pb s1 s2 cu
  | (Vmvalues.Asort _, _) | (Vmvalues.Aind _, _) | (Vmvalues.Aid _, _) =&gt;
    Stdlib.raise extensible_type_value
  end

with conv_stack {A : Set}
  (env : Environ.env) (k : Z) (stk1 : Vmvalues.stack) (stk2 : Vmvalues.stack)
  (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  match (stk1, stk2) with
  | ([], []) =&gt; cu
  | (cons (Vmvalues.Zapp args1) stk1, cons (Vmvalues.Zapp args2) stk2) =&gt;
    conv_stack env k stk1 stk2 (conv_arguments env None k args1 args2 cu)
  | (cons (Vmvalues.Zfix f1 args1) stk1, cons (Vmvalues.Zfix f2 args2) stk2) =&gt;
    conv_stack env k stk1 stk2
      (conv_arguments env None k args1 args2 (conv_fix env k f1 f2 cu))
  | (cons (Vmvalues.Zswitch sw1) stk1, cons (Vmvalues.Zswitch sw2) stk2) =&gt;
    if check_switch sw1 sw2 then
      let '(vt1, vt2) := ((type_of_switch sw1), (type_of_switch sw2)) in
      let rcu := Stdlib.__ref_value (conv_val env Reduction.CONV k vt1 vt2 cu)
        in
      let '(b1, b2) := ((branch_of_switch k sw1), (branch_of_switch k sw2)) in
      (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
      (* ❌ instruction_sequence &quot;;&quot; *)
      conv_stack env k stk1 stk2 (Stdlib.op_exclamation rcu)
    else
      Stdlib.raise extensible_type_value
  | (cons (Vmvalues.Zproj p1) stk1, cons (Vmvalues.Zproj p2) stk2) =&gt;
    if Projection.Repr.equal p1 p2 then
      conv_stack env k stk1 stk2 cu
    else
      Stdlib.raise extensible_type_value
  |
    ([], _) | (cons (Vmvalues.Zapp _) _, _) | (cons (Vmvalues.Zfix _ _) _, _) |
    (cons (Vmvalues.Zswitch _) _, _) | (cons (Vmvalues.Zproj _) _, _) =&gt;
    Stdlib.raise extensible_type_value
  end

with conv_fun {A : Set}
  (env : Environ.env) (pb : Reduction.conv_pb) (k : Z) (f1 : Vmvalues.vfun)
  (f2 : Vmvalues.vfun) (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  if Stdlib.op_eqeq f1 f2 then
    cu
  else
    let '(arity, b1, b2) := decompose_vfun2 k f1 f2 in
    conv_val env pb (Z.add k arity) b1 b2 cu

with conv_fix {A : Set}
  (env : Environ.env) (k : Z) (f1 : Vmvalues.vfix) (f2 : Vmvalues.vfix)
  (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  if Stdlib.op_eqeq f1 f2 then
    cu
  else
    if check_fix f1 f2 then
      let '(bf1, tf1) := reduce_fix k f1 in
      let '(bf2, tf2) := reduce_fix k f2 in
      let cu := conv_vect (conv_val env Reduction.CONV k) tf1 tf2 cu in
      conv_vect
        (conv_fun env Reduction.CONV
          (Z.add k ((|Util.Array|).(CArray.ExtS.length) tf1))) bf1 bf2 cu
    else
      Stdlib.raise extensible_type_value

with conv_cofix {A : Set}
  (env : Environ.env) (k : Z) (cf1 : Vmvalues.vcofix) (cf2 : Vmvalues.vcofix)
  (cu : A * Reduction.universe_compare A) {struct env}
  : A * Reduction.universe_compare A :=
  if Stdlib.op_eqeq cf1 cf2 then
    cu
  else
    if check_cofix cf1 cf2 then
      let '(bcf1, tcf1) := reduce_cofix k cf1 in
      let '(bcf2, tcf2) := reduce_cofix k cf2 in
      let cu := conv_vect (conv_val env Reduction.CONV k) tcf1 tcf2 cu in
      conv_vect
        (conv_val env Reduction.CONV
          (Z.add k ((|Util.Array|).(CArray.ExtS.length) tcf1))) bcf1 bcf2 cu
    else
      Stdlib.raise extensible_type_value

with conv_arguments {A : Set} (env : Environ.env) (op_staroptstar : option Z)
  {struct env}
  : Z -&gt; Vmvalues.arguments -&gt; Vmvalues.arguments -&gt;
  A * Reduction.universe_compare A -&gt; A * Reduction.universe_compare A :=
  let from :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; 0
    end in
  fun k =&gt;
    fun args1 =&gt;
      fun args2 =&gt;
        fun cu =&gt;
          if Stdlib.op_eqeq args1 args2 then
            cu
          else
            let n := nargs args1 in
            if Int.equal n (nargs args2) then
              let rcu := Stdlib.__ref_value cu in
              (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
              (* ❌ instruction_sequence &quot;;&quot; *)
              Stdlib.op_exclamation rcu
            else
              Stdlib.raise extensible_type_value.

Definition warn_bytecode_compiler_failed : option Loc.t -&gt; unit -&gt; unit :=
  CWarnings.create &quot;bytecode-compiler-failed&quot; &quot;bytecode-compiler&quot; None
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      op_plusplus (strbrk &quot;Bytecode compiler failed, &quot;)
        (strbrk &quot;falling back to standard conversion&quot;)).

Definition vm_conv_gen {A : Set}
  (cv_pb : Reduction.conv_pb) (env : Environ.env)
  (univs : Reduction.universe_state A) (t1 : Constr.constr) (t2 : Constr.constr)
  : A :=
  if negb (Declarations.typing_flags.enable_VM (typing_flags env)) then
    Reduction.generic_conv cv_pb false
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        None) TransparentState.full env univs t1 t2
  else
    (* ❌ Try-with are not handled *)
    try
      (let v1 := val_of_constr env t1 in
      let v2 := val_of_constr env t2 in
      fst (conv_val env cv_pb (nb_rel env) v1 v2 univs)).

Definition vm_conv
  (cv_pb : Reduction.conv_pb) (env : Environ.env) (t1 : Constr.constr)
  (t2 : Constr.constr) : unit :=
  let univs := Environ.universes env in
  let b :=
    if equiv_decb cv_pb Reduction.CUMUL then
      Constr.leq_constr_univs univs t1 t2
    else
      Constr.eq_constr_univs univs t1 t2 in
  if negb b then
    let univs := (univs, checked_universes) in
    let '_ := vm_conv_gen cv_pb env univs t1 t2 in
    tt
  else
    tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vconv.mli">
  <div style="margin: 20px;">
    <h3>Vconv_mli</h3>
    <ul>
      <li>OCaml size: 20 lines</li>
      <li>Coq size: 16 lines (-20% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vconv.mli"><code>vconv.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Constr
open Reduction

(**********************************************************************
  s conversion functions *)
val vm_conv : conv_pb -&gt; types kernel_conversion_function

(** A conversion function parametrized by a universe comparator. Used outside of
    the kernel. *)
val vm_conv_gen : conv_pb -&gt; (types, 'a) generic_conversion_function
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vconv.mli"><code>Vconv_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter vm_conv :
  Reduction.conv_pb -&gt; Reduction.kernel_conversion_function Constr.types.

Parameter vm_conv_gen : forall {a : Set},
  Reduction.conv_pb -&gt; Reduction.generic_conversion_function Constr.types a.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vm.ml">
  <div style="margin: 20px;">
    <h3>Vm</h3>
    <ul>
      <li>OCaml size: 189 lines</li>
      <li>Coq size: 207 lines (+9% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vm.ml"><code>vm.ml</code></a>&nbsp;<span class="label label-warning">25 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Vmvalues

external set_drawinstr : unit -&gt; unit = &quot;coq_set_drawinstr&quot;

external mkPopStopCode : int -&gt; tcode = &quot;coq_pushpop&quot;

let popstop_tbl =  ref (Array.init 30 mkPopStopCode)

let popstop_code i =
  let len = Array.length !popstop_tbl in
  if i &lt; len then !popstop_tbl.(i)
  else
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
      popstop_tbl :=
        Array.init (i+10)
          (fun j -&gt; if j &lt; len then !popstop_tbl.(j) else mkPopStopCode j);
      !popstop_tbl.(i)
    end</abbr>

let stop = popstop_code 0

(************************************************)
(* Abstract machine *****************************)
(************************************************)

(* gestion de la pile *)
external push_ra : tcode -&gt; unit = &quot;coq_push_ra&quot;
external push_val : values -&gt; unit = &quot;coq_push_val&quot;
external push_arguments : arguments -&gt; unit = &quot;coq_push_arguments&quot;
external push_vstack : vstack -&gt; int -&gt; unit = &quot;coq_push_vstack&quot;


(* interpreteur *)
external coq_interprete : tcode -&gt; values -&gt; atom array -&gt; vm_global -&gt; vm_env -&gt; int -&gt; values =
  &quot;coq_interprete_byte&quot; &quot;coq_interprete_ml&quot;

let interprete code v env k =
  coq_interprete code v (get_atom_rel ()) (Csymtable.get_global_data ()) env k

(* Functions over arguments *)

(* Apply a value to arguments contained in [vargs] *)
let apply_arguments vf vargs =
  let n = nargs vargs in
  if Int.equal n 0 then fun_val vf
  else
   <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
     push_ra stop;
     </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_arguments vargs;
     interprete (fun_code vf) (fun_val vf) (fun_env vf) (n - 1)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
   end</abbr>

(* Apply value [vf] to an array of argument values [varray] *)
let apply_varray vf varray =
  let n = Array.length varray in
  if Int.equal n 0 then fun_val vf
  else
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
      push_ra stop;
      (* The fun code of [vf] will make sure we have enough stack, so we put 0
         here. *)
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_vstack varray 0;
      interprete (fun_code vf) (fun_val vf) (fun_env vf) (n - 1)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
    end</abbr>

let mkrel_vstack k arity =
  let max = k + arity - 1 in
  Array.init arity (fun i -&gt; val_of_rel (max - i))

let reduce_fun k vf =
  let vargs = mkrel_vstack k 1 in
  apply_varray vf vargs

let decompose_vfun2 k vf1 vf2 =
  let arity = min (closure_arity vf1) (closure_arity vf2) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (0 &lt; arity &amp;&amp; arity &lt; Sys.max_array_length);
  let vargs = mkrel_vstack k arity in
  let v1 = apply_varray vf1 vargs in
  let v2 = apply_varray vf2 vargs in
  arity, v1, v2</abbr>

(* Functions over vfix *)

let reduce_fix k vf =
  let fb = first_fix vf in
  (* computing types *)
  let fc_typ = fix_types fb in
  let ndef = Array.length fc_typ in
  let et = offset_closure_fix fb (2*(ndef - 1)) in
  let ftyp =
    Array.map
      (fun c -&gt; interprete c crazy_val et 0) fc_typ in
  (* Construction of the environment of fix bodies *)
  (mk_fix_body k ndef fb, ftyp)

let reduce_cofix k vcf =
  let fc_typ = cofix_types vcf in
  let ndef = Array.length fc_typ in
  let ftyp =
    (* Evaluate types *)
    Array.map (fun c -&gt; interprete c crazy_val (cofix_env vcf) 0) fc_typ in

  (* Construction of the environment of cofix bodies *)
  (mk_cofix_body apply_varray k ndef vcf, ftyp)

let type_of_switch sw =
  (* The fun code of types will make sure we have enough stack, so we put 0
  here. *)
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_vstack sw.sw_stk 0;
  interprete sw.sw_type_code crazy_val sw.sw_env 0</abbr>

let apply_switch sw arg =
  let tc = sw.sw_annot.tailcall in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if tc then
    (push_ra stop;push_vstack sw.sw_stk sw.sw_annot.max_stack_size)
  else
    (push_vstack sw.sw_stk sw.sw_annot.max_stack_size;
     push_ra (popstop_code (Array.length sw.sw_stk)));
  interprete sw.sw_code arg sw.sw_env 0</abbr>

let branch_of_switch k sw =
  let eval_branch (_,arity as ta) =
    let arg = branch_arg k ta in
    let v = apply_switch sw arg in
    (arity, v)
  in
  Array.map eval_branch sw.sw_annot.rtbl

(* Apply the term represented by a under stack stk to argument v *)
(* t = a stk --&gt; t v *)
let rec apply_stack a stk v =
  match stk with
  | [] -&gt; apply_varray (fun_of_val a) <abbr class="mark-warning" title="Arrays not handled.">[|v|]</abbr>
  | Zapp args :: stk -&gt; apply_stack (apply_arguments (fun_of_val a) args) stk v
  | Zproj kn :: stk -&gt; apply_stack (val_of_proj kn a) stk v
  | Zfix(f,args) :: stk -&gt;
      let a,stk =
        match stk with
        | Zapp args' :: stk -&gt;
            <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_ra stop;
            </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_arguments args';
            </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_val a;
            </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_arguments args;
            let a =
              interprete (fix_code f) (fix_val f) (fix_env f)
                (nargs args+ nargs args') in
            a, stk</abbr>
        | _ -&gt;
            <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_ra stop;
            </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_val a;
            </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_arguments args;
            let a =
              interprete (fix_code f) (fix_val f) (fix_env f)
                (nargs args) in
            a, stk</abbr> in
      apply_stack a stk v
  | Zswitch sw :: stk -&gt;
      apply_stack (apply_switch sw a) stk v

let apply_whd k whd =
  let v = val_of_rel k in
  match whd with
  | Vprod _ | Vconstr_const _ | Vconstr_block _ | Vint64 _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Vfun f -&gt; reduce_fun k f
  | Vfix(f, None) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_ra stop;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_val v;
      interprete (fix_code f) (fix_val f) (fix_env f) 0</abbr>
  | Vfix(f, Some args) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_ra stop;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_val v;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_arguments args;
      interprete (fix_code f) (fix_val f) (fix_env f) (nargs args)</abbr>
  | Vcofix(_,to_up,_) -&gt;
      <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_ra stop;
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">push_val v;
      interprete (cofix_upd_code to_up) (cofix_upd_val to_up) (cofix_upd_env to_up) 0</abbr>
  | Vatom_stk(a,stk) -&gt;
      apply_stack (val_of_atom a) stk v
  | Vuniv_level _lvl -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

</pre>
  </div>
  <div class="col-md-6">
    <a href="#vm.ml"><code>Vm.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Vmvalues.

Parameter set_drawinstr : unit -&gt; unit.

Parameter mkPopStopCode : Z -&gt; Vmvalues.tcode.

Definition popstop_tbl : Stdlib.ref (array Vmvalues.tcode) :=
  Stdlib.__ref_value (Array.init 30 mkPopStopCode).

Definition popstop_code (i : Z) : Vmvalues.tcode :=
  let len := Array.length (Stdlib.op_exclamation popstop_tbl) in
  if OCaml.Stdlib.lt i len then
    Array.get (Stdlib.op_exclamation popstop_tbl) i
  else
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Array.get (Stdlib.op_exclamation popstop_tbl) i.

Definition stop : Vmvalues.tcode := popstop_code 0.

Parameter push_ra : Vmvalues.tcode -&gt; unit.

Parameter push_val : Vmvalues.values -&gt; unit.

Parameter push_arguments : Vmvalues.arguments -&gt; unit.

Parameter push_vstack : Vmvalues.vstack -&gt; Z -&gt; unit.

Parameter coq_interprete :
Vmvalues.tcode -&gt; Vmvalues.values -&gt; array Vmvalues.atom -&gt;
Vmvalues.vm_global -&gt; Vmvalues.vm_env -&gt; Z -&gt; Vmvalues.values.

Definition interprete
  (code : Vmvalues.tcode) (v : Vmvalues.values) (env : Vmvalues.vm_env) (k : Z)
  : Vmvalues.values :=
  coq_interprete code v (get_atom_rel tt) (Csymtable.get_global_data tt) env k.

Definition apply_arguments (vf : Vmvalues.vfun) (vargs : Vmvalues.arguments)
  : Vmvalues.values :=
  let n := nargs vargs in
  if Int.equal n 0 then
    fun_val vf
  else
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    interprete (fun_code vf) (fun_val vf) (fun_env vf) (Z.sub n 1).

Definition apply_varray (vf : Vmvalues.vfun) (varray : Vmvalues.vstack)
  : Vmvalues.values :=
  let n := Array.length varray in
  if Int.equal n 0 then
    fun_val vf
  else
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    interprete (fun_code vf) (fun_val vf) (fun_env vf) (Z.sub n 1).

Definition mkrel_vstack (k : Z) (arity : Z) : array Vmvalues.values :=
  let max := Z.sub (Z.add k arity) 1 in
  Array.init arity (fun i =&gt; val_of_rel (Z.sub max i)).

Definition reduce_fun (k : Z) (vf : Vmvalues.vfun) : Vmvalues.values :=
  let vargs := mkrel_vstack k 1 in
  apply_varray vf vargs.

Definition decompose_vfun2 (k : Z) (vf1 : Vmvalues.vfun) (vf2 : Vmvalues.vfun)
  : Z * Vmvalues.values * Vmvalues.values :=
  let arity := OCaml.Stdlib.min (closure_arity vf1) (closure_arity vf2) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let vargs := mkrel_vstack k arity in
  let v1 := apply_varray vf1 vargs in
  let v2 := apply_varray vf2 vargs in
  (arity, v1, v2).

Definition reduce_fix (k : Z) (vf : Vmvalues.vfix)
  : array Vmvalues.vfun * array Vmvalues.values :=
  let fb := first_fix vf in
  let fc_typ := fix_types fb in
  let ndef := Array.length fc_typ in
  let et := offset_closure_fix fb (Z.mul 2 (Z.sub ndef 1)) in
  let ftyp := Array.map (fun c =&gt; interprete c crazy_val et 0) fc_typ in
  ((mk_fix_body k ndef fb), ftyp).

Definition reduce_cofix (k : Z) (vcf : Vmvalues.vcofix)
  : array Vmvalues.values * array Vmvalues.values :=
  let fc_typ := cofix_types vcf in
  let ndef := Array.length fc_typ in
  let ftyp :=
    Array.map (fun c =&gt; interprete c crazy_val (cofix_env vcf) 0) fc_typ in
  ((mk_cofix_body apply_varray k ndef vcf), ftyp).

Definition type_of_switch (sw : Vmvalues.vswitch) : Vmvalues.values :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  interprete (Vmvalues.vswitch.sw_type_code sw) crazy_val
    (Vmvalues.vswitch.sw_env sw) 0.

Definition apply_switch (sw : Vmvalues.vswitch) (arg : Vmvalues.values)
  : Vmvalues.values :=
  let tc := Vmvalues.annot_switch.tailcall (Vmvalues.vswitch.sw_annot sw) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  interprete (Vmvalues.vswitch.sw_code sw) arg (Vmvalues.vswitch.sw_env sw) 0.

Definition branch_of_switch (k : Z) (sw : Vmvalues.vswitch)
  : array (Z * Vmvalues.values) :=
  let eval_branch (function_parameter : Vmvalues.tag * Z)
    : Z * Vmvalues.values :=
    let '(_, arity) as ta := function_parameter in
    let arg := branch_arg k ta in
    let v := apply_switch sw arg in
    (arity, v) in
  Array.map eval_branch
    (Vmvalues.annot_switch.rtbl (Vmvalues.vswitch.sw_annot sw)).

Fixpoint apply_stack
  (a : Vmvalues.values) (stk : list Vmvalues.zipper) (v : Vmvalues.values)
  {struct a} : Vmvalues.values :=
  match stk with
  | [] =&gt;
    apply_varray (fun_of_val a)
      (* ❌ Arrays not handled. *)
      [ v ]
  | cons (Vmvalues.Zapp args) stk =&gt;
    apply_stack (apply_arguments (fun_of_val a) args) stk v
  | cons (Vmvalues.Zproj kn) stk =&gt; apply_stack (val_of_proj kn a) stk v
  | cons (Vmvalues.Zfix f args) stk =&gt;
    let '(a, stk) :=
      match stk with
      | cons (Vmvalues.Zapp args') stk =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let a :=
          interprete (fix_code f) (fix_val f) (fix_env f)
            (Z.add (nargs args) (nargs args')) in
        (a, stk)
      | _ =&gt;
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        let a := interprete (fix_code f) (fix_val f) (fix_env f) (nargs args) in
        (a, stk)
      end in
    apply_stack a stk v
  | cons (Vmvalues.Zswitch sw) stk =&gt; apply_stack (apply_switch sw a) stk v
  end.

Definition apply_whd (k : Z) (whd : Vmvalues.whd) : Vmvalues.values :=
  let v := val_of_rel k in
  match whd with
  |
    Vmvalues.Vprod _ | Vmvalues.Vconstr_const _ | Vmvalues.Vconstr_block _ |
    Vmvalues.Vint64 _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  | Vmvalues.Vfun f =&gt; reduce_fun k f
  | Vmvalues.Vfix f None =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    interprete (fix_code f) (fix_val f) (fix_env f) 0
  | Vmvalues.Vfix f (Some args) =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    interprete (fix_code f) (fix_val f) (fix_env f) (nargs args)
  | Vmvalues.Vcofix _ to_up _ =&gt;
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    interprete (cofix_upd_code to_up) (cofix_upd_val to_up)
      (cofix_upd_env to_up) 0
  | Vmvalues.Vatom_stk a stk =&gt; apply_stack (val_of_atom a) stk v
  | Vmvalues.Vuniv_level _lvl =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vm.mli">
  <div style="margin: 20px;">
    <h3>Vm_mli</h3>
    <ul>
      <li>OCaml size: 36 lines</li>
      <li>Coq size: 30 lines (-17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vm.mli"><code>vm.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Vmvalues

(** Debug printing *)

val set_drawinstr : unit -&gt; unit

val reduce_fix : int -&gt; vfix -&gt; vfun array * values array
                              (** bodies ,  types *)

val reduce_cofix : int -&gt; vcofix -&gt; values array * values array
                                      (** bodies , types *)

val type_of_switch : vswitch -&gt; values

val branch_of_switch : int -&gt; vswitch -&gt; (int * values) array

val reduce_fun : int -&gt; vfun -&gt; values

(** [decompose_vfun2 k f1 f2] takes two functions [f1] and [f2] at current
    DeBruijn level [k], with [n] lambdas in common, returns [n] and the reduced
    bodies under those lambdas. *)
val decompose_vfun2  : int -&gt; vfun -&gt; vfun -&gt; int * values * values

(** Apply a value *)

val apply_whd : int -&gt; whd -&gt; values
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vm.mli"><code>Vm_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter set_drawinstr : unit -&gt; unit.

Parameter reduce_fix :
  Z -&gt; Vmvalues.vfix -&gt; array Vmvalues.vfun * array Vmvalues.values.

Parameter reduce_cofix :
  Z -&gt; Vmvalues.vcofix -&gt; array Vmvalues.values * array Vmvalues.values.

Parameter type_of_switch : Vmvalues.vswitch -&gt; Vmvalues.values.

Parameter branch_of_switch :
  Z -&gt; Vmvalues.vswitch -&gt; array (Z * Vmvalues.values).

Parameter reduce_fun : Z -&gt; Vmvalues.vfun -&gt; Vmvalues.values.

Parameter decompose_vfun2 :
  Z -&gt; Vmvalues.vfun -&gt; Vmvalues.vfun -&gt; Z * Vmvalues.values * Vmvalues.values.

Parameter apply_whd : Z -&gt; Vmvalues.whd -&gt; Vmvalues.values.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vmvalues.ml">
  <div style="margin: 20px;">
    <h3>Vmvalues</h3>
    <ul>
      <li>OCaml size: 689 lines</li>
      <li>Coq size: 833 lines (+20% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vmvalues.ml"><code>vmvalues.ml</code></a>&nbsp;<span class="label label-warning">40 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)
open Names
open Univ
open Constr

(********************************************)
(* Initialization of the abstract machine ***)
(* Necessary for [relaccu_tbl]              *)
(********************************************)

external init_vm : unit -&gt; unit = &quot;init_coq_vm&quot;

let _ = init_vm ()

(******************************************************)
(* Abstract data types and utility functions **********)
(******************************************************)

(* The representation of values relies on this assertion *)
let _ = assert (Int.equal Obj.first_non_constant_constructor_tag 0)

(* Values of the abstract machine *)
type values
type structured_values = values
let val_of_obj v = ((Obj.obj v):values)
let crazy_val = (val_of_obj (Obj.repr 0))

type tag = int

let accu_tag = 0

let type_atom_tag = 2
let max_atom_tag = 2
let proj_tag = 3
let fix_app_tag = 4
let switch_tag = 5
let cofix_tag = 6
let cofix_evaluated_tag = 7

(** Structured constants are constants whose construction is done once. Their
occurrences share the same value modulo kernel name substitutions (for functor
application). Structured values have the additional property that no
substitution will need to be performed, so their runtime value can directly be
shared without reallocating a more structured representation. *)
type structured_constant =
  | Const_sort of Sorts.t
  | Const_ind of inductive
  | Const_b0 of tag
  | Const_univ_level of Univ.Level.t
  | Const_val of structured_values
  | Const_uint of Uint63.t

type reloc_table = (tag * int) array

type annot_switch =
   {ci : case_info; rtbl : reloc_table; tailcall : bool; max_stack_size : int}

let rec eq_structured_values v1 v2 =
  v1 == v2 ||
  let o1 = Obj.repr v1 in
  let o2 = Obj.repr v2 in
  if Obj.is_int o1 &amp;&amp; Obj.is_int o2 then o1 == o2
  else
    let t1 = Obj.tag o1 in
    let t2 = Obj.tag o2 in
    if Int.equal t1 t2 &amp;&amp;
       Int.equal (Obj.size o1) (Obj.size o2)
    then if Int.equal t1 Obj.custom_tag
      then Int64.equal (Obj.magic v1 : int64) (Obj.magic v2 : int64)
    else <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
      assert (t1 &lt;= Obj.last_non_constant_constructor_tag &amp;&amp;
              t2 &lt;= Obj.last_non_constant_constructor_tag);
      let i = ref 0 in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">while (!i &lt; Obj.size o1 &amp;&amp; eq_structured_values
               (Obj.magic (Obj.field o1 !i) : structured_values)
               (Obj.magic (Obj.field o2 !i) : structured_values)) do
        incr i
      done;
      !i &gt;= Obj.size o1</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
    end</abbr>
    else false

let hash_structured_values (v : structured_values) =
  (* We may want a better hash function here *)
  Hashtbl.hash v

let eq_structured_constant c1 c2 = match c1, c2 with
| Const_sort s1, Const_sort s2 -&gt; Sorts.equal s1 s2
| Const_sort _, _ -&gt; false
| Const_ind i1, Const_ind i2 -&gt; eq_ind i1 i2
| Const_ind _, _ -&gt; false
| Const_b0 t1, Const_b0 t2 -&gt; Int.equal t1 t2
| Const_b0 _, _ -&gt; false
| Const_univ_level l1 , Const_univ_level l2 -&gt; Univ.Level.equal l1 l2
| Const_univ_level _ , _ -&gt; false
| Const_val v1, Const_val v2 -&gt; eq_structured_values v1 v2
| Const_val _, _ -&gt; false
| Const_uint i1, Const_uint i2 -&gt; Uint63.equal i1 i2
| Const_uint _, _ -&gt; false

let hash_structured_constant c =
  let open Hashset.Combine in
  match c with
  | Const_sort s -&gt; combinesmall 1 (Sorts.hash s)
  | Const_ind i -&gt; combinesmall 2 (ind_hash i)
  | Const_b0 t -&gt; combinesmall 3 (Int.hash t)
  | Const_univ_level l -&gt; combinesmall 4 (Univ.Level.hash l)
  | Const_val v -&gt; combinesmall 5 (hash_structured_values v)
  | Const_uint i -&gt; combinesmall 6 (Uint63.hash i)

let eq_annot_switch asw1 asw2 =
  let eq_ci ci1 ci2 =
    eq_ind ci1.ci_ind ci2.ci_ind &amp;&amp;
    Int.equal ci1.ci_npar ci2.ci_npar &amp;&amp;
    CArray.equal Int.equal ci1.ci_cstr_ndecls ci2.ci_cstr_ndecls
  in
  let eq_rlc (i1, j1) (i2, j2) = Int.equal i1 i2 &amp;&amp; Int.equal j1 j2 in
  eq_ci asw1.ci asw2.ci &amp;&amp;
  CArray.equal eq_rlc asw1.rtbl asw2.rtbl &amp;&amp;
  (asw1.tailcall : bool) == asw2.tailcall

let hash_annot_switch asw =
  let open Hashset.Combine in
  let h1 = Constr.case_info_hash asw.ci in
  let h2 = Array.fold_left (fun h (t, i) -&gt; combine3 h t i) 0 asw.rtbl in
  let h3 = if asw.tailcall then 1 else 0 in
  combine3 h1 h2 h3

let pp_sort s =
  let open Sorts in
  match s with
  | SProp -&gt; Pp.str &quot;SProp&quot;
  | Prop -&gt; Pp.str &quot;Prop&quot;
  | Set -&gt; Pp.str &quot;Set&quot;
  | Type u -&gt; Pp.(str &quot;Type@{&quot; ++ Univ.pr_uni u ++ str &quot;}&quot;)

let pp_struct_const = function
  | Const_sort s -&gt; pp_sort s
  | Const_ind (mind, i) -&gt; Pp.(MutInd.print mind ++ str&quot;#&quot; ++ int i)
  | Const_b0 i -&gt; Pp.int i
  | Const_univ_level l -&gt; Univ.Level.pr l
  | Const_val _ -&gt; Pp.str &quot;(value)&quot;
  | Const_uint i -&gt; Pp.str (Uint63.to_string i)

(* Abstract data *)
type vprod
type vfun
type vfix
type vcofix
type vblock
type arguments

let fun_val v = (Obj.magic v : values)
let fix_val v = (Obj.magic v : values)
let cofix_upd_val v = (Obj.magic v : values)

type vm_env
type vm_global
let fun_env v = (Obj.magic v : vm_env)
let fix_env v = (Obj.magic v : vm_env)
let cofix_env v = (Obj.magic v : vm_env)
let cofix_upd_env v = (Obj.magic v : vm_env)
type vstack = values array

let fun_of_val v = (Obj.magic v : vfun)

let vm_global (v : values array) = (Obj.magic v : vm_global)

(*******************************************)
(* Machine code *** ************************)
(*******************************************)

type tcode
(** A block whose first field is a C-allocated VM bytecode, encoded as char*.
    This is compatible with the representation of the Coq VM closures. *)

type tcode_array

external mkAccuCode : int -&gt; tcode = &quot;coq_makeaccu&quot;
external offset_tcode : tcode -&gt; int -&gt; tcode = &quot;coq_offset_tcode&quot;

let fun_code v = (Obj.magic v : tcode)
let fix_code = fun_code
let cofix_upd_code = fun_code


type vswitch = {
    sw_type_code : tcode;
    sw_code : tcode;
    sw_annot : annot_switch;
    sw_stk : vstack;
    sw_env : vm_env
  }

(* Representation of values *)
(* + Products : *)
(*   -   vprod = 0_[ dom | codom]                                         *)
(*             dom : values, codom : vfun                                 *)
(*                                                                        *)
(* + Functions have two representations :                                 *)
(*   - unapplied fun :  vf = Ct_[ C | fv1 | ... | fvn]                    *)
(*                                       C:tcode, fvi : values            *)
(*     Remark : a function and its environment is the same value.         *)
(*   - partially applied fun : Ct_[Restart:C| vf | arg1 | ... argn]       *)
(*                                                                        *)
(* + Fixpoints :                                                          *)
(*   -        Ct_[C1|Infix_t|C2|...|Infix_t|Cn|fv1|...|fvn]               *)
(*     One single block to represent all of the fixpoints, each fixpoint  *)
(*     is the pointer to the field holding the pointer to its code, and   *)
(*     the infix tag is used to know where the block starts.              *)
(*   - Partial application follows the scheme of partially applied        *)
(*     functions. Note: only fixpoints not having been applied to its     *)
(*     recursive argument are coded this way. When the rec. arg. is       *)
(*     applied, either it's a constructor and the fix reduces, or it's    *)
(*     and the fix is coded as an accumulator.                            *)
(*                                                                        *)
(* + Cofixpoints : see cbytegen.ml                                        *)
(*                                                                        *)
(* + vblock's encode (non constant) constructors as in Ocaml, but         *)
(*   starting from 0 up. tag 0 ( = accu_tag) is reserved for              *)
(*   accumulators.                                                        *)
(*                                                                        *)
(* + vm_env is the type of the machine environments (i.e. a function or   *)
(*   a fixpoint)                                                          *)
(*                                                                        *)
(* + Accumulators : At_[accumulate| accu | arg1 | ... | argn ]            *)
(*   - representation of [accu] : tag_[....]                              *)
(*     -- tag &lt;= 3 : encoding atom type (sorts, free vars, etc.)          *)
(*     -- 10_[accu|proj name] : a projection blocked by an accu           *)
(*     -- 11_[accu|fix_app] : a fixpoint blocked by an accu               *)
(*     -- 12_[accu|vswitch] : a match blocked by an accu                  *)
(*     -- 13_[fcofix]       : a cofix function                            *)
(*     -- 14_[fcofix|val]   : a cofix function, val represent the value   *)
(*        of the function applied to arg1 ... argn                        *)
(* The [arguments] type, which is abstracted as an array, represents :    *)
(*          tag[ _ | _ |v1|... | vn]                                      *)
(* Generally the first field is a code pointer.                           *)

(* Do not edit this type without editing C code, especially &quot;coq_values.h&quot; *)

type id_key =
| ConstKey of Constant.t
| VarKey of Id.t
| RelKey of Int.t
| EvarKey of Evar.t

let eq_id_key (k1 : id_key) (k2 : id_key) = match k1, k2 with
| ConstKey c1, ConstKey c2 -&gt; Constant.equal c1 c2
| VarKey id1, VarKey id2 -&gt; Id.equal id1 id2
| RelKey n1, RelKey n2 -&gt; Int.equal n1 n2
| EvarKey evk1, EvarKey evk2 -&gt; Evar.equal evk1 evk2
| _ -&gt; false

type atom =
  | Aid of id_key
  | Aind of inductive
  | Asort of Sorts.t

(* Zippers *)

type zipper =
  | Zapp of arguments
  | Zfix of vfix*arguments  (* Possibly empty *)
  | Zswitch of vswitch
  | Zproj of Projection.Repr.t (* name of the projection *)

type stack = zipper list

type to_update = values

type whd =
  | Vprod of vprod
  | Vfun of vfun
  | Vfix of vfix * arguments option
  | Vcofix of vcofix * to_update * arguments option
  | Vconstr_const of int
  | Vconstr_block of vblock
  | Vint64 of int64
  | Vatom_stk of atom * stack
  | Vuniv_level of Univ.Level.t

(* Functions over arguments *)
let nargs : arguments -&gt; int = fun args -&gt; (Obj.size (Obj.repr args)) - 2
let arg args i =
  if  0 &lt;= i &amp;&amp; i &lt; (nargs args) then
    val_of_obj (Obj.field (Obj.repr args) (i+2))
  else invalid_arg
                (&quot;Vm.arg size = &quot;^(string_of_int (nargs args))^
                 &quot; acces &quot;^(string_of_int i))

(*************************************************)
(* Destructors ***********************************)
(*************************************************)

let uni_lvl_val (v : values) : Univ.Level.t =
    let whd = Obj.magic v in
    match whd with
    | Vuniv_level lvl -&gt; lvl
    | _ -&gt;
      let pr =
        let open Pp in
        match whd with
        | Vprod _ -&gt; str &quot;Vprod&quot;
        | Vfun _ -&gt; str &quot;Vfun&quot;
        | Vfix _ -&gt; str &quot;Vfix&quot;
        | Vcofix _ -&gt; str &quot;Vcofix&quot;
        | Vconstr_const _i -&gt; str &quot;Vconstr_const&quot;
        | Vconstr_block _b -&gt; str &quot;Vconstr_block&quot;
        | Vint64 _ -&gt; str &quot;Vint64&quot;
        | Vatom_stk (_a,_stk) -&gt; str &quot;Vatom_stk&quot;
        | Vuniv_level _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
      in
      CErrors.anomaly
        Pp.(   strbrk &quot;Parsing virtual machine value expected universe level, got &quot;
            ++ pr ++ str &quot;.&quot;)

let rec whd_accu a stk =
  let stk =
    if Int.equal (Obj.size a) 2 then stk
    else Zapp (Obj.obj a) :: stk in
  let at = Obj.field a 1 in
  match Obj.tag at with
  | i when Int.equal i type_atom_tag -&gt;
     begin match stk with
     | [] -&gt; Vatom_stk(Obj.magic at, stk)
     | [Zapp args] -&gt;
        let args = Array.init (nargs args) (arg args) in
        let s = Obj.obj (Obj.field at 0) in
        begin match s with
        | Sorts.Type u -&gt;
          let inst = Instance.of_array (Array.map uni_lvl_val args) in
          let u = Univ.subst_instance_universe inst u in
          Vatom_stk (Asort (Sorts.sort_of_univ u), [])
        | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
        end
     | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
     end
  | i when i &lt;= max_atom_tag -&gt;
      Vatom_stk(Obj.magic at, stk)
  | i when Int.equal i proj_tag -&gt;
     let zproj = Zproj (Obj.obj (Obj.field at 0)) in
     whd_accu (Obj.field at 1) (zproj :: stk)
  | i when Int.equal i fix_app_tag -&gt;
      let fa = Obj.field at 1 in
      let zfix  =
        Zfix (Obj.obj (Obj.field fa 1), Obj.obj fa) in
      whd_accu (Obj.field at 0) (zfix :: stk)
  | i when Int.equal i switch_tag -&gt;
      let zswitch = Zswitch (Obj.obj (Obj.field at 1)) in
      whd_accu (Obj.field at 0) (zswitch :: stk)
  | i when Int.equal i cofix_tag -&gt;
      let vcfx = Obj.obj (Obj.field at 0) in
      let to_up = Obj.obj a in
      begin match stk with
      | []          -&gt; Vcofix(vcfx, to_up, None)
      | [Zapp args] -&gt; Vcofix(vcfx, to_up, Some args)
      | _           -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
      end
  | i when Int.equal i cofix_evaluated_tag -&gt;
      let vcofix = Obj.obj (Obj.field at 0) in
      let res = Obj.obj a in
      begin match stk with
      | []          -&gt; Vcofix(vcofix, res, None)
      | [Zapp args] -&gt; Vcofix(vcofix, res, Some args)
      | _           -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
      end
  | i when Int.equal i Obj.custom_tag -&gt;
    Vint64 (Obj.magic i)
  | tg -&gt;
    CErrors.anomaly
      Pp.(strbrk &quot;Failed to parse VM value. Tag = &quot; ++ int tg ++ str &quot;.&quot;)

external kind_of_closure : Obj.t -&gt; int = &quot;coq_kind_of_closure&quot;
external is_accumulate : tcode -&gt; bool = &quot;coq_is_accumulate_code&quot;
external int_tcode : tcode -&gt; int -&gt; int = &quot;coq_int_tcode&quot;
external accumulate : unit -&gt; tcode = &quot;accumulate_code&quot;
external set_bytecode_field : Obj.t -&gt; int -&gt; tcode -&gt; unit = &quot;coq_set_bytecode_field&quot;
let accumulate = accumulate ()

let whd_val : values -&gt; whd =
  fun v -&gt;
    let o = Obj.repr v in
    if Obj.is_int o then Vconstr_const (Obj.obj o)
    else
      let tag = Obj.tag o in
      if tag = accu_tag then
        if is_accumulate (fun_code o) then whd_accu o []
        else Vprod(Obj.obj o)
      else
        if tag = Obj.closure_tag || tag = Obj.infix_tag then
          (match kind_of_closure o with
           | 0 -&gt; Vfun(Obj.obj o)
           | 1 -&gt; Vfix(Obj.obj o, None)
           | 2 -&gt; Vfix(Obj.obj (Obj.field o 1), Some (Obj.obj o))
           | 3 -&gt; Vatom_stk(Aid(RelKey(int_tcode (fun_code o) 1)), [])
           | _ -&gt; CErrors.anomaly ~label:&quot;Vm.whd &quot; (Pp.str &quot;kind_of_closure does not work.&quot;))
        else if Int.equal tag Obj.custom_tag then Vint64 (Obj.magic v)
        else
           Vconstr_block(Obj.obj o)

(**********************************************)
(* Constructors *******************************)
(**********************************************)

let obj_of_atom : atom -&gt; Obj.t =
  fun a -&gt;
    let res = Obj.new_block accu_tag 2 in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_bytecode_field res 0 accumulate;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Obj.set_field res 1 (Obj.repr a);
    res</abbr>

(* obj_of_str_const : structured_constant -&gt; Obj.t *)
let obj_of_str_const str =
  match str with
  | Const_sort s -&gt; obj_of_atom (Asort s)
  | Const_ind ind -&gt; obj_of_atom (Aind ind)
  | Const_b0 tag -&gt; Obj.repr tag
  | Const_univ_level l -&gt; Obj.repr (Vuniv_level l)
  | Const_val v -&gt; Obj.repr v
  | Const_uint i -&gt; Obj.repr i

let val_of_block tag (args : structured_values array) =
  let nargs = Array.length args in
  let r = Obj.new_block tag nargs in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to nargs - 1 do
    Obj.set_field r i (Obj.repr args.(i))
  done;
  (Obj.magic r : structured_values)</abbr>

let val_of_obj o = ((Obj.obj o) : values)

let val_of_str_const str = val_of_obj (obj_of_str_const str)

let val_of_atom a = val_of_obj (obj_of_atom a)

let val_of_int i = (Obj.magic i : values)

let val_of_uint i = (Obj.magic i : values)

let atom_of_proj kn v =
  let r = Obj.new_block proj_tag 2 in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Obj.set_field r 0 (Obj.repr kn);
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Obj.set_field r 1 (Obj.repr v);
  ((Obj.obj r) : atom)</abbr>

let val_of_proj kn v =
  val_of_atom (atom_of_proj kn v)

<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">module IdKeyHash =
struct
  type t = id_key
  let equal = eq_id_key
  </abbr><abbr class="mark-warning" title="Open not handled in module with a named signature

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">open Hashset.Combine</abbr><abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">
  let hash : t -&gt; tag = function
  | ConstKey c -&gt; combinesmall 1 (Constant.hash c)
  | VarKey id -&gt; combinesmall 2 (Id.hash id)
  | RelKey i -&gt; combinesmall 3 (Int.hash i)
  | EvarKey evk -&gt; combinesmall 4 (Evar.hash evk)
end</abbr>

module KeyTable = Hashtbl.Make(<abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.HashedType, Stdlib__hashtbl.SeededHashedType

We were looking for a module signature name for the following shape:
[ equal; hash ]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">IdKeyHash</abbr>)

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">idkey_tbl</abbr> = <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">KeyTable.create</abbr> 31

let <abbr class="mark-warning" title="It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">val_of_idkey</abbr> key =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

It is unclear which name has this signature. At least two similar
signatures found, namely:
Stdlib__hashtbl.S, Stdlib__hashtbl.SeededS

We were looking for a module signature name for the following shape:
[
  create;
  clear;
  reset;
  copy;
  add;
  remove;
  find;
  find_opt;
  find_all;
  replace;
  mem;
  iter;
  filter_map_inplace;
  fold;
  length;
  stats;
  to_seq;
  to_seq_keys;
  to_seq_values;
  add_seq;
  replace_seq;
  of_seq
]
(a shape is a list of names of values and sub-modules)

We use the concept of shape to find the name of a signature for Coq.">KeyTable.find</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> idkey_tbl key
  with Not_found -&gt;
    let v = val_of_atom (Aid key) in
    KeyTable.add idkey_tbl key v;
    v</abbr>

let val_of_rel k = val_of_idkey (RelKey k)

let val_of_named id = val_of_idkey (VarKey id)

let val_of_constant c = val_of_idkey (ConstKey c)

let val_of_evar evk = val_of_idkey (EvarKey evk)

external val_of_annot_switch : annot_switch -&gt; values = &quot;%identity&quot;
external val_of_proj_name : Projection.Repr.t -&gt; values = &quot;%identity&quot;

(*************************************************)
(** Operations manipulating data types ***********)
(*************************************************)

(* Functions over products *)

let dom : vprod -&gt; values = fun p -&gt; val_of_obj (Obj.field (Obj.repr p) 0)
let codom : vprod -&gt; vfun = fun p -&gt; (Obj.obj (Obj.field (Obj.repr p) 1))

(* Functions over vfun *)

external closure_arity : vfun -&gt; int = &quot;coq_closure_arity&quot;

(* Functions over fixpoint *)

external offset : Obj.t -&gt; int = &quot;coq_offset&quot;
external offset_closure : Obj.t -&gt; int -&gt; Obj.t = &quot;coq_offset_closure&quot;
external offset_closure_fix : vfix -&gt; int -&gt; vm_env = &quot;coq_offset_closure&quot;
external tcode_array : tcode_array -&gt; tcode array = &quot;coq_tcode_array&quot;

let first o = (offset_closure o (offset o))
let first_fix (v:vfix) = (Obj.magic (first (Obj.repr v)) : vfix)

let last o = (Obj.field o (Obj.size o - 1))
let fix_types (v:vfix) = tcode_array (Obj.magic (last (Obj.repr v)) : tcode_array)
let cofix_types (v:vcofix) = tcode_array (Obj.magic (last (Obj.repr v)) : tcode_array)

let current_fix vf = - (offset (Obj.repr vf) / 2)

let unsafe_fb_code fb i =
  let off = (2 * i) * (Sys.word_size / 8) in
  Obj.obj (Obj.add_offset (Obj.repr fb) (Int32.of_int off))

let unsafe_rec_arg fb i = int_tcode (unsafe_fb_code fb i) 1

let rec_args vf =
  let fb = first (Obj.repr vf) in
  let size = Obj.size (last fb) in
  Array.init size (unsafe_rec_arg fb)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception FALSE</abbr>

let check_fix f1 f2 =
  let i1, i2 = current_fix f1, current_fix f2 in
  (* Checking starting point *)
  if i1 = i2 then
    let fb1,fb2 = first (Obj.repr f1), first (Obj.repr f2) in
    let n = Obj.size (last fb1) in
    (* Checking number of definitions *)
    if n = Obj.size (last fb2) then
      (* Checking recursive arguments *)
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
        </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to n - 1 do
          if unsafe_rec_arg fb1 i &lt;&gt; unsafe_rec_arg fb2 i
          then raise FALSE
        done;
        true</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
      with FALSE -&gt; false</abbr>
    else false
  else false

let atom_rel : atom array ref =
  let init i = Aid (RelKey i) in
  ref (Array.init 40 init)

let get_atom_rel () = !atom_rel

let realloc_atom_rel n =
  let n = min (2 * n + 0x100) Sys.max_array_length in
  let init i = Aid (RelKey i) in
  let ans = Array.init n init in
  atom_rel := ans

let relaccu_tbl =
  let len = Array.length !atom_rel in
  ref (Array.init len mkAccuCode)

let relaccu_code i =
  let len = Array.length !relaccu_tbl in
  if i &lt; len then !relaccu_tbl.(i)
  else
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin
      realloc_atom_rel i;
      let nl = Array.length !atom_rel in
      </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">relaccu_tbl :=
        Array.init nl
          (fun j -&gt; if j &lt; len then !relaccu_tbl.(j) else mkAccuCode j);
      !relaccu_tbl.(i)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">
    end</abbr>

let mk_fix_body k ndef fb =
  let e = Obj.dup (Obj.repr fb) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to ndef - 1 do
    set_bytecode_field e (2 * i) (relaccu_code (k + i))
  done;
  let fix_body i =
    let c = offset_tcode (unsafe_fb_code fb i) 2 in
    let res = Obj.new_block Obj.closure_tag 2 in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_bytecode_field res 0 c;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Obj.set_field res 1 (offset_closure e (2*i));
    ((Obj.obj res) : vfun)</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">  in
  Array.init ndef fix_body</abbr>

(* Functions over vcofix *)

let get_fcofix vcf i =
  match whd_val (Obj.obj (Obj.field (Obj.repr vcf) (i+1))) with
  | Vcofix(vcfi, _, _) -&gt; vcfi
  | _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

let current_cofix vcf =
  let ndef = Obj.size (last (Obj.repr vcf)) in
  let rec find_cofix pos =
    if pos &lt; ndef then
      if get_fcofix vcf pos == vcf then pos
      else find_cofix (pos+1)
    else raise <abbr class="mark-warning" title="Values of extensible types are not handled">Not_found</abbr> in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try find_cofix 0
  with Not_found -&gt; assert false</abbr>

let check_cofix vcf1 vcf2 =
  (current_cofix vcf1 = current_cofix vcf2) &amp;&amp;
  (Obj.size (last (Obj.repr vcf1)) = Obj.size (last (Obj.repr vcf2)))

let mk_cofix_body apply_varray k ndef vcf =
  let e = Obj.dup (Obj.repr vcf) in
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = 0 to ndef - 1 do
    Obj.set_field e (i+1) (Obj.repr (val_of_rel (k+i)))
  done;

  let cofix_body i =
    let vcfi = get_fcofix vcf i in
    let c = Obj.field (Obj.repr vcfi) 0 in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Obj.set_field e 0 c;
    let atom = Obj.new_block cofix_tag 1 in
    let self = Obj.new_block accu_tag 2 in
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">set_bytecode_field self 0 accumulate;
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Obj.set_field self 1 (Obj.repr atom);
    apply_varray (Obj.obj e) </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Arrays not handled.">[|Obj.obj self|]</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects."> in
  Array.init ndef cofix_body</abbr>

(* Functions over vblock *)

let btag : vblock -&gt; int = fun b -&gt; Obj.tag (Obj.repr b)
let bsize : vblock -&gt; int = fun b -&gt; Obj.size (Obj.repr b)
let bfield b i =
  if 0 &lt;= i &amp;&amp; i &lt; (bsize b) then val_of_obj (Obj.field (Obj.repr b) i)
  else invalid_arg &quot;Vm.bfield&quot;


(* Functions over vswitch *)

let check_switch sw1 sw2 = sw1.sw_annot.rtbl = sw2.sw_annot.rtbl

let branch_arg k (tag,arity) =
  if Int.equal arity 0 then  ((Obj.magic tag):values)
  else
    let b, ofs =
      if tag &lt; Obj.last_non_constant_constructor_tag then Obj.new_block tag arity, 0
      else
        let b = Obj.new_block Obj.last_non_constant_constructor_tag (arity+1) in
        <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Obj.set_field b 0 (Obj.repr (tag-Obj.last_non_constant_constructor_tag));
        b,1</abbr> in
    <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">for i = ofs to ofs + arity - 1 do
      Obj.set_field b i (Obj.repr (val_of_rel (k+i)))
    done;
    val_of_obj b</abbr>

(* Printing *)

let rec pr_atom a =
  Pp.(match a with
  | Aid c -&gt; str &quot;Aid(&quot; ++ (match c with
                            | ConstKey c -&gt; Constant.print c
                            | RelKey i -&gt; str &quot;#&quot; ++ int i
                            | _ -&gt; str &quot;...&quot;) ++ str &quot;)&quot;
  | Aind (mi,i) -&gt; str &quot;Aind(&quot; ++ MutInd.print mi ++ str &quot;#&quot; ++ int i ++ str &quot;)&quot;
  | Asort _ -&gt; str &quot;Asort(&quot;)
and pr_whd w =
  Pp.(match w with
  | Vprod _ -&gt; str &quot;Vprod&quot;
  | Vfun _ -&gt; str &quot;Vfun&quot;
  | Vfix _ -&gt; str &quot;Vfix&quot;
  | Vcofix _ -&gt; str &quot;Vcofix&quot;
  | Vconstr_const i -&gt; str &quot;Vconstr_const(&quot; ++ int i ++ str &quot;)&quot;
  | Vconstr_block _b -&gt; str &quot;Vconstr_block&quot;
  | Vint64 i -&gt; i |&gt; Format.sprintf &quot;Vint64(%LiL)&quot; |&gt; str
  | Vatom_stk (a,stk) -&gt; str &quot;Vatom_stk(&quot; ++ pr_atom a ++ str &quot;, &quot; ++ pr_stack stk ++ str &quot;)&quot;
  | Vuniv_level _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>)
and pr_stack stk =
  Pp.(match stk with
      | [] -&gt; str &quot;[]&quot;
      | s :: stk -&gt; pr_zipper s ++ str &quot; :: &quot; ++ pr_stack stk)
and pr_zipper z =
  Pp.(match z with
  | Zapp args -&gt; str &quot;Zapp(len = &quot; ++ int (nargs args) ++ str &quot;)&quot;
  | Zfix (_f,args) -&gt; str &quot;Zfix(..., len=&quot; ++ int (nargs args) ++ str &quot;)&quot;
  | Zswitch _s -&gt; str &quot;Zswitch(...)&quot;
  | Zproj c -&gt; str &quot;Zproj(&quot; ++ Projection.Repr.print c ++ str &quot;)&quot;)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vmvalues.ml"><code>Vmvalues.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Import Names.

Import Univ.

Import Constr.

Parameter init_vm : unit -&gt; unit.





Parameter values : Set.

Definition structured_values := values.

Definition val_of_obj (v : Stdlib.Obj.t) : values := Obj.obj v.

Definition crazy_val : values := val_of_obj (Obj.repr 0).

Definition tag := Z.

Definition accu_tag : Z := 0.

Definition type_atom_tag : Z := 2.

Definition max_atom_tag : Z := 2.

Definition proj_tag : Z := 3.

Definition fix_app_tag : Z := 4.

Definition switch_tag : Z := 5.

Definition cofix_tag : Z := 6.

Definition cofix_evaluated_tag : Z := 7.

Inductive structured_constant : Set :=
| Const_sort : Sorts.t -&gt; structured_constant
| Const_ind : Names.inductive -&gt; structured_constant
| Const_b0 : tag -&gt; structured_constant
| Const_univ_level : Univ.Level.t -&gt; structured_constant
| Const_val : structured_values -&gt; structured_constant
| Const_uint : Uint63.t -&gt; structured_constant.

Definition reloc_table := array (tag * Z).

Module annot_switch.
  Record record := {
    ci : Constr.case_info;
    rtbl : reloc_table;
    tailcall : bool;
    max_stack_size : Z }.
  Definition with_ci (r : record) ci : record :=
    {| ci := ci; rtbl := rtbl r; tailcall := tailcall r;
      max_stack_size := max_stack_size r |}.
  Definition with_rtbl (r : record) rtbl : record :=
    {| ci := ci r; rtbl := rtbl; tailcall := tailcall r;
      max_stack_size := max_stack_size r |}.
  Definition with_tailcall (r : record) tailcall : record :=
    {| ci := ci r; rtbl := rtbl r; tailcall := tailcall;
      max_stack_size := max_stack_size r |}.
  Definition with_max_stack_size (r : record) max_stack_size : record :=
    {| ci := ci r; rtbl := rtbl r; tailcall := tailcall r;
      max_stack_size := max_stack_size |}.
End annot_switch.
Definition annot_switch := annot_switch.record.

Fixpoint eq_structured_values (v1 : structured_values) (v2 : structured_values)
  {struct v1} : bool :=
  orb (Stdlib.op_eqeq v1 v2)
    (let o1 := Obj.repr v1 in
    let o2 := Obj.repr v2 in
    if andb (Obj.is_int o1) (Obj.is_int o2) then
      Stdlib.op_eqeq o1 o2
    else
      let t1 := Obj.tag o1 in
      let t2 := Obj.tag o2 in
      if andb (Int.equal t1 t2) (Int.equal (Obj.size o1) (Obj.size o2)) then
        if Int.equal t1 Obj.custom_tag then
          Int64.equal (Obj.magic v1) (Obj.magic v2)
        else
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          let i := Stdlib.__ref_value 0 in
          (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
          (* ❌ instruction_sequence &quot;;&quot; *)
          OCaml.Stdlib.ge (Stdlib.op_exclamation i) (Obj.size o1)
      else
        false).

Definition hash_structured_values (v : structured_values) : Z := Hashtbl.hash v.

Definition eq_structured_constant
  (c1 : structured_constant) (c2 : structured_constant) : bool :=
  match (c1, c2) with
  | (Const_sort s1, Const_sort s2) =&gt; Sorts.equal s1 s2
  | (Const_sort _, _) =&gt; false
  | (Const_ind i1, Const_ind i2) =&gt; eq_ind i1 i2
  | (Const_ind _, _) =&gt; false
  | (Const_b0 t1, Const_b0 t2) =&gt; Int.equal t1 t2
  | (Const_b0 _, _) =&gt; false
  | (Const_univ_level l1, Const_univ_level l2) =&gt; Univ.Level.equal l1 l2
  | (Const_univ_level _, _) =&gt; false
  | (Const_val v1, Const_val v2) =&gt; eq_structured_values v1 v2
  | (Const_val _, _) =&gt; false
  | (Const_uint i1, Const_uint i2) =&gt; Uint63.equal i1 i2
  | (Const_uint _, _) =&gt; false
  end.

Definition hash_structured_constant (c : structured_constant) : Z :=
  match c with
  | Const_sort s =&gt; combinesmall 1 (Sorts.hash s)
  | Const_ind i =&gt; combinesmall 2 (ind_hash i)
  | Const_b0 t =&gt; combinesmall 3 (Int.hash t)
  | Const_univ_level l =&gt; combinesmall 4 (Univ.Level.hash l)
  | Const_val v =&gt; combinesmall 5 (hash_structured_values v)
  | Const_uint i =&gt; combinesmall 6 (Uint63.hash i)
  end.

Definition eq_annot_switch (asw1 : annot_switch) (asw2 : annot_switch) : bool :=
  let eq_ci (ci1 : Constr.case_info) (ci2 : Constr.case_info) : bool :=
    andb (eq_ind (Constr.case_info.ci_ind ci1) (Constr.case_info.ci_ind ci2))
      (andb
        (Int.equal (Constr.case_info.ci_npar ci1) (Constr.case_info.ci_npar ci2))
        ((|CArray|).(CArray.ExtS.equal) Int.equal
          (Constr.case_info.ci_cstr_ndecls ci1)
          (Constr.case_info.ci_cstr_ndecls ci2))) in
  let eq_rlc (function_parameter : Int.t * Int.t) : Int.t * Int.t -&gt; bool :=
    let '(i1, j1) := function_parameter in
    fun function_parameter =&gt;
      let '(i2, j2) := function_parameter in
      andb (Int.equal i1 i2) (Int.equal j1 j2) in
  andb (eq_ci (annot_switch.ci asw1) (annot_switch.ci asw2))
    (andb
      ((|CArray|).(CArray.ExtS.equal) eq_rlc (annot_switch.rtbl asw1)
        (annot_switch.rtbl asw2))
      (Stdlib.op_eqeq (annot_switch.tailcall asw1) (annot_switch.tailcall asw2))).

Definition hash_annot_switch (asw : annot_switch) : Z :=
  let h1 := Constr.case_info_hash (annot_switch.ci asw) in
  let h2 :=
    (|Stdlib.Array|).(CArray.S.fold_left)
      (fun h =&gt;
        fun function_parameter =&gt;
          let '(t, i) := function_parameter in
          combine3 h t i) 0 (annot_switch.rtbl asw) in
  let h3 :=
    if annot_switch.tailcall asw then
      1
    else
      0 in
  combine3 h1 h2 h3.

Definition pp_sort (s : Sorts.t) : Pp.t :=
  match s with
  | Sorts.SProp =&gt; Pp.str &quot;SProp&quot;
  | Sorts.Prop =&gt; Pp.str &quot;Prop&quot;
  | Sorts.__Set =&gt; Pp.str &quot;Set&quot;
  | Sorts.Type u =&gt;
    op_plusplus (op_plusplus (str &quot;Type@{&quot;) (Univ.pr_uni u)) (str &quot;}&quot;)
  end.

Definition pp_struct_const (function_parameter : structured_constant) : Pp.t :=
  match function_parameter with
  | Const_sort s =&gt; pp_sort s
  | Const_ind (mind, i) =&gt;
    op_plusplus (op_plusplus (MutInd.print mind) (str &quot;#&quot;)) (int i)
  | Const_b0 i =&gt; Pp.int i
  | Const_univ_level l =&gt; Univ.Level.pr l
  | Const_val _ =&gt; Pp.str &quot;(value)&quot;
  | Const_uint i =&gt; Pp.str (Uint63.to_string i)
  end.

Parameter vprod : Set.

Parameter vfun : Set.

Parameter vfix : Set.

Parameter vcofix : Set.

Parameter vblock : Set.

Parameter arguments : Set.

Definition fun_val {A : Set} (v : A) : values := Obj.magic v.

Definition fix_val {A : Set} (v : A) : values := Obj.magic v.

Definition cofix_upd_val {A : Set} (v : A) : values := Obj.magic v.

Parameter vm_env : Set.

Parameter vm_global : Set.

Definition fun_env {A : Set} (v : A) : vm_env := Obj.magic v.

Definition fix_env {A : Set} (v : A) : vm_env := Obj.magic v.

Definition cofix_env {A : Set} (v : A) : vm_env := Obj.magic v.

Definition cofix_upd_env {A : Set} (v : A) : vm_env := Obj.magic v.

Definition vstack := array values.

Definition fun_of_val {A : Set} (v : A) : vfun := Obj.magic v.

Definition vm_global (v : array values) : vm_global := Obj.magic v.

Parameter tcode : Set.

Parameter tcode_array : Set.

Parameter mkAccuCode : Z -&gt; tcode.

Parameter offset_tcode : tcode -&gt; Z -&gt; tcode.

Definition fun_code {A : Set} (v : A) : tcode := Obj.magic v.

Definition fix_code {A : Set} : A -&gt; tcode := fun_code.

Definition cofix_upd_code {A : Set} : A -&gt; tcode := fun_code.

Module vswitch.
  Record record := {
    sw_type_code : tcode;
    sw_code : tcode;
    sw_annot : annot_switch;
    sw_stk : vstack;
    sw_env : vm_env }.
  Definition with_sw_type_code (r : record) sw_type_code : record :=
    {| sw_type_code := sw_type_code; sw_code := sw_code r;
      sw_annot := sw_annot r; sw_stk := sw_stk r; sw_env := sw_env r |}.
  Definition with_sw_code (r : record) sw_code : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code;
      sw_annot := sw_annot r; sw_stk := sw_stk r; sw_env := sw_env r |}.
  Definition with_sw_annot (r : record) sw_annot : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code r;
      sw_annot := sw_annot; sw_stk := sw_stk r; sw_env := sw_env r |}.
  Definition with_sw_stk (r : record) sw_stk : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code r;
      sw_annot := sw_annot r; sw_stk := sw_stk; sw_env := sw_env r |}.
  Definition with_sw_env (r : record) sw_env : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code r;
      sw_annot := sw_annot r; sw_stk := sw_stk r; sw_env := sw_env |}.
End vswitch.
Definition vswitch := vswitch.record.

Inductive id_key : Set :=
| ConstKey : Names.Constant.t -&gt; id_key
| VarKey : Names.Id.t -&gt; id_key
| RelKey : Int.t -&gt; id_key
| EvarKey : Evar.t -&gt; id_key.

Definition eq_id_key (k1 : id_key) (k2 : id_key) : bool :=
  match (k1, k2) with
  | (ConstKey c1, ConstKey c2) =&gt; Constant.equal c1 c2
  | (VarKey id1, VarKey id2) =&gt; Id.equal id1 id2
  | (RelKey n1, RelKey n2) =&gt; Int.equal n1 n2
  | (EvarKey evk1, EvarKey evk2) =&gt; Evar.equal evk1 evk2
  | _ =&gt; false
  end.

Inductive atom : Set :=
| Aid : id_key -&gt; atom
| Aind : Names.inductive -&gt; atom
| Asort : Sorts.t -&gt; atom.

Inductive zipper : Set :=
| Zapp : arguments -&gt; zipper
| Zfix : vfix -&gt; arguments -&gt; zipper
| Zswitch : vswitch -&gt; zipper
| Zproj : Names.Projection.Repr.t -&gt; zipper.

Definition stack := list zipper.

Definition to_update := values.

Inductive whd : Set :=
| Vprod : vprod -&gt; whd
| Vfun : vfun -&gt; whd
| Vfix : vfix -&gt; option arguments -&gt; whd
| Vcofix : vcofix -&gt; to_update -&gt; option arguments -&gt; whd
| Vconstr_const : Z -&gt; whd
| Vconstr_block : vblock -&gt; whd
| Vint64 : int64 -&gt; whd
| Vatom_stk : atom -&gt; stack -&gt; whd
| Vuniv_level : Univ.Level.t -&gt; whd.

Definition nargs (args : arguments) : Z := Z.sub (Obj.size (Obj.repr args)) 2.

Definition arg (args : arguments) (i : Z) : values :=
  if andb (OCaml.Stdlib.le 0 i) (OCaml.Stdlib.lt i (nargs args)) then
    val_of_obj (Obj.field (Obj.repr args) (Z.add i 2))
  else
    OCaml.Stdlib.invalid_arg
      (String.append &quot;Vm.arg size = &quot;
        (String.append (OCaml.Stdlib.string_of_int (nargs args))
          (String.append &quot; acces &quot; (OCaml.Stdlib.string_of_int i)))).

Definition uni_lvl_val (v : values) : Univ.Level.t :=
  let whd := Obj.magic v in
  match whd with
  | Vuniv_level lvl =&gt; lvl
  | _ =&gt;
    let pr :=
      match whd with
      | Vprod _ =&gt; str &quot;Vprod&quot;
      | Vfun _ =&gt; str &quot;Vfun&quot;
      | Vfix _ _ =&gt; str &quot;Vfix&quot;
      | Vcofix _ _ _ =&gt; str &quot;Vcofix&quot;
      | Vconstr_const _i =&gt; str &quot;Vconstr_const&quot;
      | Vconstr_block _b =&gt; str &quot;Vconstr_block&quot;
      | Vint64 _ =&gt; str &quot;Vint64&quot;
      | Vatom_stk _a _stk =&gt; str &quot;Vatom_stk&quot;
      | Vuniv_level _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end in
    CErrors.anomaly None None
      (op_plusplus
        (op_plusplus
          (strbrk &quot;Parsing virtual machine value expected universe level, got &quot;)
          pr) (str &quot;.&quot;))
  end.

Fixpoint whd_accu (a : Stdlib.Obj.t) (stk : stack) {struct a} : whd :=
  let stk :=
    if Int.equal (Obj.size a) 2 then
      stk
    else
      cons (Zapp (Obj.obj a)) stk in
  let at := Obj.field a 1 in
  match
    ((Obj.tag at),
      match Obj.tag at with
      | i =&gt; Int.equal i type_atom_tag
      | _ =&gt; false
      end,
      match Obj.tag at with
      | i =&gt; OCaml.Stdlib.le i max_atom_tag
      | _ =&gt; false
      end,
      match Obj.tag at with
      | i =&gt; Int.equal i proj_tag
      | _ =&gt; false
      end,
      match Obj.tag at with
      | i =&gt; Int.equal i fix_app_tag
      | _ =&gt; false
      end,
      match Obj.tag at with
      | i =&gt; Int.equal i switch_tag
      | _ =&gt; false
      end,
      match Obj.tag at with
      | i =&gt; Int.equal i cofix_tag
      | _ =&gt; false
      end,
      match Obj.tag at with
      | i =&gt; Int.equal i cofix_evaluated_tag
      | _ =&gt; false
      end,
      match Obj.tag at with
      | i =&gt; Int.equal i Obj.custom_tag
      | _ =&gt; false
      end) with
  | (i, true, _, _, _, _, _, _, _) =&gt;
    match stk with
    | [] =&gt; Vatom_stk (Obj.magic at) stk
    | cons (Zapp args) [] =&gt;
      let args := (|Stdlib.Array|).(CArray.S.init) (nargs args) (arg args) in
      let s := Obj.obj (Obj.field at 0) in
      match s with
      | Sorts.Type u =&gt;
        let inst :=
          Instance.of_array ((|Stdlib.Array|).(CArray.S.map) uni_lvl_val args)
          in
        let u := Univ.subst_instance_universe inst u in
        Vatom_stk (Asort (Sorts.sort_of_univ u)) []
      | _ =&gt;
        (* ❌ Assert instruction is not handled. *)
        assert false
      end
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end
  | (i, _, true, _, _, _, _, _, _) =&gt; Vatom_stk (Obj.magic at) stk
  | (i, _, _, true, _, _, _, _, _) =&gt;
    let zproj := Zproj (Obj.obj (Obj.field at 0)) in
    whd_accu (Obj.field at 1) (cons zproj stk)
  | (i, _, _, _, true, _, _, _, _) =&gt;
    let fa := Obj.field at 1 in
    let zfix := Zfix (Obj.obj (Obj.field fa 1)) (Obj.obj fa) in
    whd_accu (Obj.field at 0) (cons zfix stk)
  | (i, _, _, _, _, true, _, _, _) =&gt;
    let zswitch := Zswitch (Obj.obj (Obj.field at 1)) in
    whd_accu (Obj.field at 0) (cons zswitch stk)
  | (i, _, _, _, _, _, true, _, _) =&gt;
    let vcfx := Obj.obj (Obj.field at 0) in
    let to_up := Obj.obj a in
    match stk with
    | [] =&gt; Vcofix vcfx to_up None
    | cons (Zapp args) [] =&gt; Vcofix vcfx to_up (Some args)
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end
  | (i, _, _, _, _, _, _, true, _) =&gt;
    let vcofix := Obj.obj (Obj.field at 0) in
    let res := Obj.obj a in
    match stk with
    | [] =&gt; Vcofix vcofix res None
    | cons (Zapp args) [] =&gt; Vcofix vcofix res (Some args)
    | _ =&gt;
      (* ❌ Assert instruction is not handled. *)
      assert false
    end
  | (i, _, _, _, _, _, _, _, true) =&gt; Vint64 (Obj.magic i)
  | (tg, _, _, _, _, _, _, _, _) =&gt;
    CErrors.anomaly None None
      (op_plusplus
        (op_plusplus (strbrk &quot;Failed to parse VM value. Tag = &quot;) (int tg))
        (str &quot;.&quot;))
  end.

Parameter kind_of_closure : Stdlib.Obj.t -&gt; Z.

Parameter is_accumulate : tcode -&gt; bool.

Parameter int_tcode : tcode -&gt; Z -&gt; Z.

Parameter accumulate : unit -&gt; tcode.

Parameter set_bytecode_field : Stdlib.Obj.t -&gt; Z -&gt; tcode -&gt; unit.

Definition accumulate : tcode := accumulate tt.

Definition whd_val (v : values) : whd :=
  let o := Obj.repr v in
  if Obj.is_int o then
    Vconstr_const (Obj.obj o)
  else
    let tag := Obj.tag o in
    if equiv_decb tag accu_tag then
      if is_accumulate (fun_code o) then
        whd_accu o []
      else
        Vprod (Obj.obj o)
    else
      if orb (equiv_decb tag Obj.closure_tag) (equiv_decb tag Obj.infix_tag)
        then
        match kind_of_closure o with
        | 0 =&gt; Vfun (Obj.obj o)
        | 1 =&gt; Vfix (Obj.obj o) None
        | 2 =&gt; Vfix (Obj.obj (Obj.field o 1)) (Some (Obj.obj o))
        | 3 =&gt; Vatom_stk (Aid (RelKey (int_tcode (fun_code o) 1))) []
        | _ =&gt;
          CErrors.anomaly None (Some &quot;Vm.whd &quot;)
            (Pp.str &quot;kind_of_closure does not work.&quot;)
        end
      else
        if Int.equal tag Obj.custom_tag then
          Vint64 (Obj.magic v)
        else
          Vconstr_block (Obj.obj o).

Definition obj_of_atom (a : atom) : Stdlib.Obj.t :=
  let res := Obj.new_block accu_tag 2 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  res.

Definition obj_of_str_const (str : structured_constant) : Stdlib.Obj.t :=
  match str with
  | Const_sort s =&gt; obj_of_atom (Asort s)
  | Const_ind ind =&gt; obj_of_atom (Aind ind)
  | Const_b0 tag =&gt; Obj.repr tag
  | Const_univ_level l =&gt; Obj.repr (Vuniv_level l)
  | Const_val v =&gt; Obj.repr v
  | Const_uint i =&gt; Obj.repr i
  end.

Definition val_of_block (tag : Z) (args : array structured_values)
  : structured_values :=
  let nargs := (|Stdlib.Array|).(CArray.S.length) args in
  let r := Obj.new_block tag nargs in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Obj.magic r.

Definition val_of_obj (o : Stdlib.Obj.t) : values := Obj.obj o.

Definition val_of_str_const (str : structured_constant) : values :=
  val_of_obj (obj_of_str_const str).

Definition val_of_atom (a : atom) : values := val_of_obj (obj_of_atom a).

Definition val_of_int {A : Set} (i : A) : values := Obj.magic i.

Definition val_of_uint {A : Set} (i : A) : values := Obj.magic i.

Definition atom_of_proj {A B : Set} (kn : A) (v : B) : atom :=
  let r := Obj.new_block proj_tag 2 in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  Obj.obj r.

Definition val_of_proj {A B : Set} (kn : A) (v : B) : values :=
  val_of_atom (atom_of_proj kn v).

Definition IdKeyHash :=
  let t := id_key in
  let equal := eq_id_key in
  (* ❌ open *)
  let hash (function_parameter : t) : tag :=
    match function_parameter with
    | ConstKey c =&gt; combinesmall 1 (Constant.hash c)
    | VarKey id =&gt; combinesmall 2 (Id.hash id)
    | RelKey i =&gt; combinesmall 3 (Int.hash i)
    | EvarKey evk =&gt; combinesmall 4 (Evar.hash evk)
    end in
  existT (fun _ =&gt; _) tt
    {|
      Stdlib__hashtbl.HashedType.equal := equal;
      Stdlib__hashtbl.HashedType.hash := hash
    |}.

Definition KeyTable :=
  Hashtbl.Make
    (existT _ _
      {|
        Stdlib__hashtbl.HashedType.equal :=
          (|IdKeyHash|).(Stdlib__hashtbl.HashedType.equal);
        Stdlib__hashtbl.HashedType.hash :=
          (|IdKeyHash|).(Stdlib__hashtbl.HashedType.hash)
      |}).

Definition idkey_tbl : (|KeyTable|).(Stdlib__hashtbl.S.t) values :=
  (|KeyTable|).(Stdlib__hashtbl.S.create) 31.

Definition val_of_idkey (key : (|KeyTable|).(Stdlib__hashtbl.S.key)) : values :=
  (* ❌ Try-with are not handled *)
  try ((|KeyTable|).(Stdlib__hashtbl.S.find) idkey_tbl key).

Definition val_of_rel (k : Int.t) : values := val_of_idkey (RelKey k).

Definition val_of_named (id : Names.Id.t) : values := val_of_idkey (VarKey id).

Definition val_of_constant (c : Names.Constant.t) : values :=
  val_of_idkey (ConstKey c).

Definition val_of_evar (evk : Evar.t) : values := val_of_idkey (EvarKey evk).

Parameter val_of_annot_switch : annot_switch -&gt; values.

Parameter val_of_proj_name : Names.Projection.Repr.t -&gt; values.

Definition dom (p : vprod) : values := val_of_obj (Obj.field (Obj.repr p) 0).

Definition codom (p : vprod) : vfun := Obj.obj (Obj.field (Obj.repr p) 1).

Parameter closure_arity : vfun -&gt; Z.

Parameter offset : Stdlib.Obj.t -&gt; Z.

Parameter offset_closure : Stdlib.Obj.t -&gt; Z -&gt; Stdlib.Obj.t.

Parameter offset_closure_fix : vfix -&gt; Z -&gt; vm_env.

Parameter tcode_array : tcode_array -&gt; array tcode.

Definition first (o : Stdlib.Obj.t) : Stdlib.Obj.t :=
  offset_closure o (offset o).

Definition first_fix (v : vfix) : vfix := Obj.magic (first (Obj.repr v)).

Definition last (o : Stdlib.Obj.t) : Stdlib.Obj.t :=
  Obj.field o (Z.sub (Obj.size o) 1).

Definition fix_types (v : vfix) : array tcode :=
  tcode_array (Obj.magic (last (Obj.repr v))).

Definition cofix_types (v : vcofix) : array tcode :=
  tcode_array (Obj.magic (last (Obj.repr v))).

Definition current_fix {A : Set} (vf : A) : Z :=
  Z.opp (Z.div (offset (Obj.repr vf)) 2).

Definition unsafe_fb_code {A B : Set} (fb : A) (i : Z) : B :=
  let off := Z.mul (Z.mul 2 i) (Z.div Sys.word_size 8) in
  Obj.obj (Obj.add_offset (Obj.repr fb) (Int32.of_int off)).

Definition unsafe_rec_arg {A : Set} (fb : A) (i : Z) : Z :=
  int_tcode (unsafe_fb_code fb i) 1.

Definition rec_args {A : Set} (vf : A) : array Z :=
  let fb := first (Obj.repr vf) in
  let size := Obj.size (last fb) in
  (|Stdlib.Array|).(CArray.S.init) size (unsafe_rec_arg fb).

(* ❌ The definition of exceptions is not handled. *)
(* exception FALSE *)

Definition check_fix {A B : Set} (f1 : A) (f2 : B) : bool :=
  let '(i1, i2) := ((current_fix f1), (current_fix f2)) in
  if equiv_decb i1 i2 then
    let '(fb1, fb2) := ((first (Obj.repr f1)), (first (Obj.repr f2))) in
    let n := Obj.size (last fb1) in
    if equiv_decb n (Obj.size (last fb2)) then
      (* ❌ Try-with are not handled *)
      try
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        true
    else
      false
  else
    false.

Definition atom_rel : Stdlib.ref (array atom) :=
  let init (i : Int.t) : atom :=
    Aid (RelKey i) in
  Stdlib.__ref_value ((|Stdlib.Array|).(CArray.S.init) 40 init).

Definition get_atom_rel (function_parameter : unit) : array atom :=
  let '_ := function_parameter in
  Stdlib.op_exclamation atom_rel.

Definition realloc_atom_rel (n : Z) : unit :=
  let n := OCaml.Stdlib.min (Z.add (Z.mul 2 n) 256) Sys.max_array_length in
  let init (i : Int.t) : atom :=
    Aid (RelKey i) in
  let ans := (|Stdlib.Array|).(CArray.S.init) n init in
  Stdlib.op_coloneq atom_rel ans.

Definition relaccu_tbl : Stdlib.ref (array tcode) :=
  let len := (|Stdlib.Array|).(CArray.S.length) (Stdlib.op_exclamation atom_rel)
    in
  Stdlib.__ref_value ((|Stdlib.Array|).(CArray.S.init) len mkAccuCode).

Definition relaccu_code (i : Z) : tcode :=
  let len :=
    (|Stdlib.Array|).(CArray.S.length) (Stdlib.op_exclamation relaccu_tbl) in
  if OCaml.Stdlib.lt i len then
    (|Stdlib.Array|).(CArray.S.get) (Stdlib.op_exclamation relaccu_tbl) i
  else
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let nl :=
      (|Stdlib.Array|).(CArray.S.length) (Stdlib.op_exclamation atom_rel) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (|Stdlib.Array|).(CArray.S.get) (Stdlib.op_exclamation relaccu_tbl) i.

Definition mk_fix_body {A : Set} (k : Z) (ndef : Z) (fb : A) : array vfun :=
  let e := Obj.dup (Obj.repr fb) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let fix_body (i : Z) : vfun :=
    let c := offset_tcode (unsafe_fb_code fb i) 2 in
    let res := Obj.new_block Obj.closure_tag 2 in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    Obj.obj res in
  (|Stdlib.Array|).(CArray.S.init) ndef fix_body.

Definition get_fcofix {A : Set} (vcf : A) (i : Z) : vcofix :=
  match whd_val (Obj.obj (Obj.field (Obj.repr vcf) (Z.add i 1))) with
  | Vcofix vcfi _ _ =&gt; vcfi
  | _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end.

Definition current_cofix (vcf : vcofix) : Z :=
  let ndef := Obj.size (last (Obj.repr vcf)) in
  let fix find_cofix (pos : Z) {struct pos} : Z :=
    if OCaml.Stdlib.lt pos ndef then
      if Stdlib.op_eqeq (get_fcofix vcf pos) vcf then
        pos
      else
        find_cofix (Z.add pos 1)
    else
      Stdlib.raise extensible_type_value in
  (* ❌ Try-with are not handled *)
  try (find_cofix 0).

Definition check_cofix (vcf1 : vcofix) (vcf2 : vcofix) : bool :=
  andb (equiv_decb (current_cofix vcf1) (current_cofix vcf2))
    (equiv_decb (Obj.size (last (Obj.repr vcf1)))
      (Obj.size (last (Obj.repr vcf2)))).

Definition mk_cofix_body {A B C D : Set}
  (apply_varray : A -&gt; array B -&gt; C) (k : Z) (ndef : Z) (vcf : D) : array C :=
  let e := Obj.dup (Obj.repr vcf) in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let cofix_body (i : Z) : C :=
    let vcfi := get_fcofix vcf i in
    let c := Obj.field (Obj.repr vcfi) 0 in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    let atom := Obj.new_block cofix_tag 1 in
    let self := Obj.new_block accu_tag 2 in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    apply_varray (Obj.obj e)
      (* ❌ Arrays not handled. *)
      [ Obj.obj self ] in
  (|Stdlib.Array|).(CArray.S.init) ndef cofix_body.

Definition btag (b : vblock) : Z := Obj.tag (Obj.repr b).

Definition bsize (b : vblock) : Z := Obj.size (Obj.repr b).

Definition bfield (b : vblock) (i : Z) : values :=
  if andb (OCaml.Stdlib.le 0 i) (OCaml.Stdlib.lt i (bsize b)) then
    val_of_obj (Obj.field (Obj.repr b) i)
  else
    OCaml.Stdlib.invalid_arg &quot;Vm.bfield&quot;.

Definition check_switch (sw1 : vswitch) (sw2 : vswitch) : bool :=
  equiv_decb (annot_switch.rtbl (vswitch.sw_annot sw1))
    (annot_switch.rtbl (vswitch.sw_annot sw2)).

Definition branch_arg (k : Z) (function_parameter : Z * Int.t) : values :=
  let '(tag, arity) := function_parameter in
  if Int.equal arity 0 then
    Obj.magic tag
  else
    let '(b, ofs) :=
      if OCaml.Stdlib.lt tag Obj.last_non_constant_constructor_tag then
        ((Obj.new_block tag arity), 0)
      else
        let b :=
          Obj.new_block Obj.last_non_constant_constructor_tag (Z.add arity 1) in
        (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
        (* ❌ instruction_sequence &quot;;&quot; *)
        (b, 1) in
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    val_of_obj b.

Fixpoint pr_atom (a : atom) {struct a} : Pp.t :=
  match a with
  | Aid c =&gt;
    op_plusplus
      (op_plusplus (str &quot;Aid(&quot;)
        match c with
        | ConstKey c =&gt; Constant.print c
        | RelKey i =&gt; op_plusplus (str &quot;#&quot;) (int i)
        | _ =&gt; str &quot;...&quot;
        end) (str &quot;)&quot;)
  | Aind (mi, i) =&gt;
    op_plusplus
      (op_plusplus
        (op_plusplus (op_plusplus (str &quot;Aind(&quot;) (MutInd.print mi)) (str &quot;#&quot;))
        (int i)) (str &quot;)&quot;)
  | Asort _ =&gt; str &quot;Asort(&quot;
  end

with pr_whd (w : whd) {struct w} : Pp.t :=
  match w with
  | Vprod _ =&gt; str &quot;Vprod&quot;
  | Vfun _ =&gt; str &quot;Vfun&quot;
  | Vfix _ _ =&gt; str &quot;Vfix&quot;
  | Vcofix _ _ _ =&gt; str &quot;Vcofix&quot;
  | Vconstr_const i =&gt;
    op_plusplus (op_plusplus (str &quot;Vconstr_const(&quot;) (int i)) (str &quot;)&quot;)
  | Vconstr_block _b =&gt; str &quot;Vconstr_block&quot;
  | Vint64 i =&gt;
    OCaml.Stdlib.reverse_apply
      (OCaml.Stdlib.reverse_apply i
        (Format.sprintf
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;Vint64(&quot;
              (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_i
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                (CamlinternalFormatBasics.String_literal &quot;L)&quot;
                  CamlinternalFormatBasics.End_of_format))) &quot;Vint64(%LiL)&quot;)))
      str
  | Vatom_stk a stk =&gt;
    op_plusplus
      (op_plusplus
        (op_plusplus (op_plusplus (str &quot;Vatom_stk(&quot;) (pr_atom a)) (str &quot;, &quot;))
        (pr_stack stk)) (str &quot;)&quot;)
  | Vuniv_level _ =&gt;
    (* ❌ Assert instruction is not handled. *)
    assert false
  end

with pr_stack (stk : stack) {struct stk} : Pp.t :=
  match stk with
  | [] =&gt; str &quot;[]&quot;
  | cons s stk =&gt;
    op_plusplus (op_plusplus (pr_zipper s) (str &quot; :: &quot;)) (pr_stack stk)
  end

with pr_zipper (z : zipper) {struct z} : Pp.t :=
  match z with
  | Zapp args =&gt;
    op_plusplus (op_plusplus (str &quot;Zapp(len = &quot;) (int (nargs args))) (str &quot;)&quot;)
  | Zfix _f args =&gt;
    op_plusplus (op_plusplus (str &quot;Zfix(..., len=&quot;) (int (nargs args)))
      (str &quot;)&quot;)
  | Zswitch _s =&gt; str &quot;Zswitch(...)&quot;
  | Zproj c =&gt;
    op_plusplus (op_plusplus (str &quot;Zproj(&quot;) (Projection.Repr.print c)) (str &quot;)&quot;)
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vmvalues.mli">
  <div style="margin: 20px;">
    <h3>Vmvalues_mli</h3>
    <ul>
      <li>OCaml size: 199 lines</li>
      <li>Coq size: 260 lines (+30% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vmvalues.mli"><code>vmvalues.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Names
open Constr

(** Values *)

type values
type structured_values
type vm_env
type vm_global
type vprod
type vfun
type vfix
type vcofix
type vblock
type arguments
type vstack = values array
type to_update

type tag = int

val accu_tag : tag

val type_atom_tag : tag
val max_atom_tag : tag
val proj_tag : tag
val fix_app_tag : tag
val switch_tag : tag
val cofix_tag : tag
val cofix_evaluated_tag : tag

type structured_constant =
  | Const_sort of Sorts.t
  | Const_ind of inductive
  | Const_b0 of tag
  | Const_univ_level of Univ.Level.t
  | Const_val of structured_values
  | Const_uint of Uint63.t

val pp_struct_const : structured_constant -&gt; Pp.t

type reloc_table = (tag * int) array

type annot_switch =
   {ci : case_info; rtbl : reloc_table; tailcall : bool; max_stack_size : int}

val eq_structured_constant : structured_constant -&gt; structured_constant -&gt; bool
val hash_structured_constant : structured_constant -&gt; int

val eq_annot_switch : annot_switch -&gt; annot_switch -&gt; bool
val hash_annot_switch : annot_switch -&gt; int

val fun_val : vfun -&gt; values
val fix_val : vfix -&gt; values
val cofix_upd_val : to_update -&gt; values

val fun_env : vfun -&gt; vm_env
val fix_env : vfix -&gt; vm_env
val cofix_env : vcofix -&gt; vm_env
val cofix_upd_env : to_update -&gt; vm_env

val vm_global : values array -&gt; vm_global

(** Cast a value known to be a function, unsafe in general *)
val fun_of_val : values -&gt; vfun

val crazy_val : values

(** Machine code *)

type tcode

type vswitch = {
    sw_type_code : tcode;
    sw_code : tcode;
    sw_annot : annot_switch;
    sw_stk : vstack;
    sw_env : vm_env
  }

external mkAccuCode : int -&gt; tcode = &quot;coq_makeaccu&quot;

val fun_code : vfun -&gt; tcode
val fix_code : vfix -&gt; tcode
val cofix_upd_code : to_update -&gt; tcode

type id_key =
| ConstKey of Constant.t
| VarKey of Id.t
| RelKey of Int.t
| EvarKey of Evar.t

val eq_id_key : id_key -&gt; id_key -&gt; bool

type atom =
  | Aid of id_key
  | Aind of inductive
  | Asort of Sorts.t

val get_atom_rel : unit -&gt; atom array
(** Global table of rels *)

(** Zippers *)

type zipper =
  | Zapp of arguments
  | Zfix of vfix * arguments  (** might be empty *)
  | Zswitch of vswitch
  | Zproj of Projection.Repr.t (* name of the projection *)

type stack = zipper list

type whd =
  | Vprod of vprod
  | Vfun of vfun
  | Vfix of vfix * arguments option
  | Vcofix of vcofix * to_update * arguments option
  | Vconstr_const of int
  | Vconstr_block of vblock
  | Vint64 of int64
  | Vatom_stk of atom * stack
  | Vuniv_level of Univ.Level.t

(** For debugging purposes only *)

val pr_atom : atom -&gt; Pp.t
val pr_whd : whd -&gt; Pp.t
val pr_stack : stack -&gt; Pp.t

(** Constructors *)

val val_of_str_const : structured_constant -&gt; values
val val_of_rel : int -&gt; values
val val_of_named : Id.t -&gt; values
val val_of_constant : Constant.t -&gt; values
val val_of_evar : Evar.t -&gt; values
val val_of_proj : Projection.Repr.t -&gt; values -&gt; values
val val_of_atom : atom -&gt; values
val val_of_int : int -&gt; structured_values
val val_of_block : tag -&gt; structured_values array -&gt; structured_values
val val_of_uint : Uint63.t -&gt; structured_values

external val_of_annot_switch : annot_switch -&gt; values = &quot;%identity&quot;
external val_of_proj_name : Projection.Repr.t -&gt; values = &quot;%identity&quot;

(** Destructors *)

val whd_val : values -&gt; whd
val uni_lvl_val : values -&gt; Univ.Level.t

(** Arguments *)

val nargs : arguments -&gt; int
val arg : arguments -&gt; int -&gt; values

(** Product *)

val dom : vprod -&gt; values
val codom : vprod -&gt; vfun

(** Fun *)
external closure_arity : vfun -&gt; int = &quot;coq_closure_arity&quot;

(** Fix *)

val current_fix : vfix -&gt; int
val check_fix : vfix -&gt; vfix -&gt; bool
val rec_args : vfix -&gt; int array
val first_fix : vfix -&gt; vfix
val fix_types : vfix -&gt; tcode array
val cofix_types : vcofix -&gt; tcode array
external offset_closure_fix : vfix -&gt; int -&gt; vm_env = &quot;coq_offset_closure&quot;
val mk_fix_body : int -&gt; int -&gt; vfix -&gt; vfun array

(** CoFix *)

val current_cofix : vcofix -&gt; int
val check_cofix : vcofix -&gt; vcofix -&gt; bool
val mk_cofix_body : (vfun -&gt; vstack -&gt; values) -&gt; int -&gt; int -&gt; vcofix -&gt; values array

(** Block *)

val btag  : vblock -&gt; int
val bsize : vblock -&gt; int
val bfield : vblock -&gt; int -&gt; values

(** Switch *)

val check_switch : vswitch -&gt; vswitch -&gt; bool
val branch_arg : int -&gt; tag * int -&gt; values
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vmvalues.mli"><code>Vmvalues_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Parameter values : Set.

Parameter structured_values : Set.

Parameter vm_env : Set.

Parameter vm_global : Set.

Parameter vprod : Set.

Parameter vfun : Set.

Parameter vfix : Set.

Parameter vcofix : Set.

Parameter vblock : Set.

Parameter arguments : Set.

Definition vstack := array values.

Parameter to_update : Set.

Definition tag := Z.

Parameter accu_tag : tag.

Parameter type_atom_tag : tag.

Parameter max_atom_tag : tag.

Parameter proj_tag : tag.

Parameter fix_app_tag : tag.

Parameter switch_tag : tag.

Parameter cofix_tag : tag.

Parameter cofix_evaluated_tag : tag.

Inductive structured_constant : Set :=
| Const_sort : Sorts.t -&gt; structured_constant
| Const_ind : Names.inductive -&gt; structured_constant
| Const_b0 : tag -&gt; structured_constant
| Const_univ_level : Univ.Level.t -&gt; structured_constant
| Const_val : structured_values -&gt; structured_constant
| Const_uint : Uint63.t -&gt; structured_constant.

Parameter pp_struct_const : structured_constant -&gt; Pp.t.

Definition reloc_table := array (tag * Z).

Module annot_switch.
  Record record := {
    ci : Constr.case_info;
    rtbl : reloc_table;
    tailcall : bool;
    max_stack_size : Z }.
  Definition with_ci (r : record) ci : record :=
    {| ci := ci; rtbl := rtbl r; tailcall := tailcall r;
      max_stack_size := max_stack_size r |}.
  Definition with_rtbl (r : record) rtbl : record :=
    {| ci := ci r; rtbl := rtbl; tailcall := tailcall r;
      max_stack_size := max_stack_size r |}.
  Definition with_tailcall (r : record) tailcall : record :=
    {| ci := ci r; rtbl := rtbl r; tailcall := tailcall;
      max_stack_size := max_stack_size r |}.
  Definition with_max_stack_size (r : record) max_stack_size : record :=
    {| ci := ci r; rtbl := rtbl r; tailcall := tailcall r;
      max_stack_size := max_stack_size |}.
End annot_switch.
Definition annot_switch := annot_switch.record.

Parameter eq_structured_constant :
  structured_constant -&gt; structured_constant -&gt; bool.

Parameter hash_structured_constant : structured_constant -&gt; Z.

Parameter eq_annot_switch : annot_switch -&gt; annot_switch -&gt; bool.

Parameter hash_annot_switch : annot_switch -&gt; Z.

Parameter fun_val : vfun -&gt; values.

Parameter fix_val : vfix -&gt; values.

Parameter cofix_upd_val : to_update -&gt; values.

Parameter fun_env : vfun -&gt; vm_env.

Parameter fix_env : vfix -&gt; vm_env.

Parameter cofix_env : vcofix -&gt; vm_env.

Parameter cofix_upd_env : to_update -&gt; vm_env.

Parameter vm_global : array values -&gt; vm_global.

Parameter fun_of_val : values -&gt; vfun.

Parameter crazy_val : values.

Parameter tcode : Set.

Module vswitch.
  Record record := {
    sw_type_code : tcode;
    sw_code : tcode;
    sw_annot : annot_switch;
    sw_stk : vstack;
    sw_env : vm_env }.
  Definition with_sw_type_code (r : record) sw_type_code : record :=
    {| sw_type_code := sw_type_code; sw_code := sw_code r;
      sw_annot := sw_annot r; sw_stk := sw_stk r; sw_env := sw_env r |}.
  Definition with_sw_code (r : record) sw_code : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code;
      sw_annot := sw_annot r; sw_stk := sw_stk r; sw_env := sw_env r |}.
  Definition with_sw_annot (r : record) sw_annot : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code r;
      sw_annot := sw_annot; sw_stk := sw_stk r; sw_env := sw_env r |}.
  Definition with_sw_stk (r : record) sw_stk : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code r;
      sw_annot := sw_annot r; sw_stk := sw_stk; sw_env := sw_env r |}.
  Definition with_sw_env (r : record) sw_env : record :=
    {| sw_type_code := sw_type_code r; sw_code := sw_code r;
      sw_annot := sw_annot r; sw_stk := sw_stk r; sw_env := sw_env |}.
End vswitch.
Definition vswitch := vswitch.record.

Parameter mkAccuCode : Z -&gt; tcode.

Parameter fun_code : vfun -&gt; tcode.

Parameter fix_code : vfix -&gt; tcode.

Parameter cofix_upd_code : to_update -&gt; tcode.

Inductive id_key : Set :=
| ConstKey : Names.Constant.t -&gt; id_key
| VarKey : Names.Id.t -&gt; id_key
| RelKey : Int.t -&gt; id_key
| EvarKey : Evar.t -&gt; id_key.

Parameter eq_id_key : id_key -&gt; id_key -&gt; bool.

Inductive atom : Set :=
| Aid : id_key -&gt; atom
| Aind : Names.inductive -&gt; atom
| Asort : Sorts.t -&gt; atom.

Parameter get_atom_rel : unit -&gt; array atom.

Inductive zipper : Set :=
| Zapp : arguments -&gt; zipper
| Zfix : vfix -&gt; arguments -&gt; zipper
| Zswitch : vswitch -&gt; zipper
| Zproj : Names.Projection.Repr.t -&gt; zipper.

Definition stack := list zipper.

Inductive whd : Set :=
| Vprod : vprod -&gt; whd
| Vfun : vfun -&gt; whd
| Vfix : vfix -&gt; option arguments -&gt; whd
| Vcofix : vcofix -&gt; to_update -&gt; option arguments -&gt; whd
| Vconstr_const : Z -&gt; whd
| Vconstr_block : vblock -&gt; whd
| Vint64 : int64 -&gt; whd
| Vatom_stk : atom -&gt; stack -&gt; whd
| Vuniv_level : Univ.Level.t -&gt; whd.

Parameter pr_atom : atom -&gt; Pp.t.

Parameter pr_whd : whd -&gt; Pp.t.

Parameter pr_stack : stack -&gt; Pp.t.

Parameter val_of_str_const : structured_constant -&gt; values.

Parameter val_of_rel : Z -&gt; values.

Parameter val_of_named : Names.Id.t -&gt; values.

Parameter val_of_constant : Names.Constant.t -&gt; values.

Parameter val_of_evar : Evar.t -&gt; values.

Parameter val_of_proj : Names.Projection.Repr.t -&gt; values -&gt; values.

Parameter val_of_atom : atom -&gt; values.

Parameter val_of_int : Z -&gt; structured_values.

Parameter val_of_block : tag -&gt; array structured_values -&gt; structured_values.

Parameter val_of_uint : Uint63.t -&gt; structured_values.

Parameter val_of_annot_switch : annot_switch -&gt; values.

Parameter val_of_proj_name : Names.Projection.Repr.t -&gt; values.

Parameter whd_val : values -&gt; whd.

Parameter uni_lvl_val : values -&gt; Univ.Level.t.

Parameter nargs : arguments -&gt; Z.

Parameter arg : arguments -&gt; Z -&gt; values.

Parameter dom : vprod -&gt; values.

Parameter codom : vprod -&gt; vfun.

Parameter closure_arity : vfun -&gt; Z.

Parameter current_fix : vfix -&gt; Z.

Parameter check_fix : vfix -&gt; vfix -&gt; bool.

Parameter rec_args : vfix -&gt; array Z.

Parameter first_fix : vfix -&gt; vfix.

Parameter fix_types : vfix -&gt; array tcode.

Parameter cofix_types : vcofix -&gt; array tcode.

Parameter offset_closure_fix : vfix -&gt; Z -&gt; vm_env.

Parameter mk_fix_body : Z -&gt; Z -&gt; vfix -&gt; array vfun.

Parameter current_cofix : vcofix -&gt; Z.

Parameter check_cofix : vcofix -&gt; vcofix -&gt; bool.

Parameter mk_cofix_body :
  (vfun -&gt; vstack -&gt; values) -&gt; Z -&gt; Z -&gt; vcofix -&gt; array values.

Parameter btag : vblock -&gt; Z.

Parameter bsize : vblock -&gt; Z.

Parameter bfield : vblock -&gt; Z -&gt; values.

Parameter check_switch : vswitch -&gt; vswitch -&gt; bool.

Parameter branch_arg : Z -&gt; tag * Z -&gt; values.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="write_uint63.ml">
  <div style="margin: 20px;">
    <h3>Write_uint63</h3>
    <ul>
      <li>OCaml size: 38 lines</li>
      <li>Coq size: 44 lines (+15% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#write_uint63.ml"><code>write_uint63.ml</code></a>&nbsp;<span class="label label-warning">8 warnings</span>
    
    <pre>(************************************************************************)
(*         *   The Coq Proof Assistant / The Coq Development Team       *)
(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)
(* &lt;O___,, *       (see CREDITS file for the list of authors)           *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

(** Equivalent of rm -f *)
let safe_remove f =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Unix.chmod f 0o644; Sys.remove f</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case."> with _ -&gt; ()</abbr>

(** * Generate an implementation of 63-bit arithmetic *)
let ml_file_copy input output =
  <abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">safe_remove output;
  let i = open_in input in
  let o = open_out output in
  let pr s = Printf.fprintf o s in
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">pr &quot;(* DO NOT EDIT THIS FILE: automatically generated by ./write_uint63.ml *)\n&quot;;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">pr &quot;(* see uint63_amd64.ml and uint63_x86.ml *)\n&quot;;
  </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    </abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

——————————

While loops not handled.">while true do
      output_string o (input_line i); output_char o '\n'
    done</abbr><abbr class="mark-warning" title="Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Sequences of instructions are not handled (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.

——————————

Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
  with End_of_file -&gt;
    close_in i;
    close_out o;
    Unix.chmod output 0o444</abbr>

let write_uint63 () =
  ml_file_copy
    (if max_int = 1073741823 (* 32-bits *) then &quot;uint63_x86.ml&quot;
     else (* 64 bits *) &quot;uint63_amd64.ml&quot;)
    &quot;uint63.ml&quot;

<abbr class="mark-warning" title="Top-level evaluations are not handled">let () = write_uint63 ()</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#write_uint63.ml"><code>Write_uint63.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import TypingFlags.Loader.
Unset Guard Checking.

Definition safe_remove (f : string) : unit :=
  (* ❌ Try-with are not handled *)
  try
    (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
    (* ❌ instruction_sequence &quot;;&quot; *)
    (Sys.remove f).

Definition ml_file_copy (input : string) (output : string) : unit :=
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  let i := Stdlib.open_in input in
  let o := Stdlib.open_out output in
  let pr {A : Set} (s : Stdlib.format A Stdlib.out_channel unit) : A :=
    Printf.fprintf o s in
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Sequences of instructions are not handled (operator &quot;;&quot;) *)
  (* ❌ instruction_sequence &quot;;&quot; *)
  (* ❌ Try-with are not handled *)
  try
    (* ❌ While loops not handled. *)
    while.

Definition write_uint63 (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  ml_file_copy
    (if equiv_decb Stdlib.max_int 1073741823 then
      &quot;uint63_x86.ml&quot;
    else
      &quot;uint63_amd64.ml&quot;) &quot;uint63.ml&quot;.

(* ❌ Top-level evaluations are not handled *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

      </div>
      <hr/>
      <div class="footer" style="margin-bottom: 40px;">
        <p class="text-center">
          <small>Sources of&nbsp;<a href="https://clarus.github.io/coq-of-ocaml/">coq-of-ocaml</a> are on&nbsp;<a href="https://github.com/clarus/coq-of-ocaml">GitHub</a>. © Guillaume Claret.</small>
        </p>
      </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
  </body>
</html>

