(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_gas.
Require Tezos.Script_expr_hash.
Require Tezos.Script_ir_annot.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Script.

Import Script_typed_ir.

Import Script_tc_errors.

Import Script_ir_annot.

Module Typecheck_costs := Michelson_v1_gas.Cost_of.Typechecking.

Module Unparse_costs := Michelson_v1_gas.Cost_of.Unparse.

Inductive ex_comparable_ty : Set :=
| Ex_comparable_ty : forall {a : Set},
  Script_typed_ir.comparable_ty a -> ex_comparable_ty.

Inductive ex_ty : Set :=
| Ex_ty : forall {a : Set}, Script_typed_ir.ty a -> ex_ty.

Inductive ex_stack_ty : Set :=
| Ex_stack_ty : forall {a : Set}, Script_typed_ir.stack_ty a -> ex_stack_ty.

Module tc_context.
  Module Toplevel.
    Record record {storage_type param_type root_name
      legacy_create_contract_literal : Set} := {
      storage_type : storage_type;
      param_type : param_type;
      root_name : root_name;
      legacy_create_contract_literal : legacy_create_contract_literal }.
    Arguments record : clear implicits.
  End Toplevel.
  Definition Toplevel_skeleton := Toplevel.record.
End tc_context.

Reserved Notation "'tc_context.Toplevel".

Inductive tc_context : Set :=
| Lambda : tc_context
| Dip : forall {a : Set}, Script_typed_ir.stack_ty a -> tc_context -> tc_context
| Toplevel : forall {param sto : Set},
  'tc_context.Toplevel param sto -> tc_context

where "'tc_context.Toplevel" := (fun (t_param t_sto : Set) =>
  tc_context.Toplevel_skeleton (Script_typed_ir.ty t_sto)
    (Script_typed_ir.ty t_param) (option string) bool).

Module ConstructorRecordNotations_tc_context.
  Module tc_context.
    Definition Toplevel := 'tc_context.Toplevel.
  End tc_context.
End ConstructorRecordNotations_tc_context.
Import ConstructorRecordNotations_tc_context.

Inductive unparsing_mode : Set :=
| Optimized : unparsing_mode
| Readable : unparsing_mode.

Definition type_logger :=
  Z -> list (Alpha_context.Script.expr * Alpha_context.Script.annot) ->
  list (Alpha_context.Script.expr * Alpha_context.Script.annot) -> unit.

Definition add_dip {A : Set}
  (ty : Script_typed_ir.ty A) (annot : option Script_typed_ir.var_annot)
  (prev : tc_context) : tc_context :=
  match prev with
  | Lambda | Toplevel _ =>
    Dip (Script_typed_ir.Item_t ty Script_typed_ir.Empty_t annot) prev
  | Dip stack _ =>
    let 'existT _ __Dip_'a stack :=
      existT (fun __Dip_'a : Set => (Script_typed_ir.stack_ty __Dip_'a)) _ stack
      in
    Dip (Script_typed_ir.Item_t ty stack annot) prev
  end.

Fixpoint comparable_type_size {a t : Set}
  (ty : Script_typed_ir.comparable_struct t a) {struct ty} : Z :=
  match ty with
  | Script_typed_ir.Int_key _ => 1
  | Script_typed_ir.Nat_key _ => 1
  | Script_typed_ir.String_key _ => 1
  | Script_typed_ir.Bytes_key _ => 1
  | Script_typed_ir.Mutez_key _ => 1
  | Script_typed_ir.Bool_key _ => 1
  | Script_typed_ir.Key_hash_key _ => 1
  | Script_typed_ir.Timestamp_key _ => 1
  | Script_typed_ir.Address_key _ => 1
  | Script_typed_ir.Pair_key _ (__t_value, _) _ =>
    let 'existT _ [__1, __Pair_key] __t_value :=
      existT
        (fun '[__1, __Pair_key] =>
          (Script_typed_ir.comparable_struct __1 __Pair_key)) _ __t_value in
    Pervasives.op_plus 1 (comparable_type_size __t_value)
  end.

Fixpoint type_size {t : Set} (ty : Script_typed_ir.ty t) {struct ty} : Z :=
  match ty with
  | Script_typed_ir.Unit_t _ => 1
  | Script_typed_ir.Int_t _ => 1
  | Script_typed_ir.Nat_t _ => 1
  | Script_typed_ir.Signature_t _ => 1
  | Script_typed_ir.Bytes_t _ => 1
  | Script_typed_ir.String_t _ => 1
  | Script_typed_ir.Mutez_t _ => 1
  | Script_typed_ir.Key_hash_t _ => 1
  | Script_typed_ir.Key_t _ => 1
  | Script_typed_ir.Timestamp_t _ => 1
  | Script_typed_ir.Address_t _ => 1
  | Script_typed_ir.Bool_t _ => 1
  | Script_typed_ir.Operation_t _ => 1
  | Script_typed_ir.Pair_t (l, _, _) (r, _, _) _ _ =>
    let 'existT _ [__0, __1] [l, r] :=
      existT
        (fun '[__0, __1] =>
          [(Script_typed_ir.ty __0) ** (Script_typed_ir.ty __1)]) _ [l, r] in
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l)) (type_size r)
  | Script_typed_ir.Union_t (l, _) (r, _) _ _ =>
    let 'existT _ [__2, __3] [l, r] :=
      existT
        (fun '[__2, __3] =>
          [(Script_typed_ir.ty __2) ** (Script_typed_ir.ty __3)]) _ [l, r] in
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l)) (type_size r)
  | Script_typed_ir.Lambda_t arg ret _ =>
    let 'existT _ [__4, __5] [arg, ret] :=
      existT
        (fun '[__4, __5] =>
          [(Script_typed_ir.ty __4) ** (Script_typed_ir.ty __5)]) _ [arg, ret]
      in
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size arg)) (type_size ret)
  | Script_typed_ir.Option_t __t_value _ _ =>
    let 'existT _ __6 __t_value :=
      existT (fun __6 : Set => (Script_typed_ir.ty __6)) _ __t_value in
    Pervasives.op_plus 1 (type_size __t_value)
  | Script_typed_ir.List_t __t_value _ _ =>
    let 'existT _ __7 __t_value :=
      existT (fun __7 : Set => (Script_typed_ir.ty __7)) _ __t_value in
    Pervasives.op_plus 1 (type_size __t_value)
  | Script_typed_ir.Set_t k _ =>
    let 'existT _ __8 k :=
      existT (fun __8 : Set => (Script_typed_ir.comparable_ty __8)) _ k in
    Pervasives.op_plus 1 (comparable_type_size k)
  | Script_typed_ir.Map_t k v _ _ =>
    let 'existT _ [__10, __9] [k, v] :=
      existT
        (fun '[__10, __9] =>
          [(Script_typed_ir.comparable_ty __9) ** (Script_typed_ir.ty __10)]) _
        [k, v] in
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Big_map_t k v _ =>
    let 'existT _ [__11, __12] [k, v] :=
      existT
        (fun '[__11, __12] =>
          [(Script_typed_ir.comparable_ty __11) ** (Script_typed_ir.ty __12)]) _
        [k, v] in
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Contract_t arg _ =>
    let 'existT _ __13 arg :=
      existT (fun __13 : Set => (Script_typed_ir.ty __13)) _ arg in
    Pervasives.op_plus 1 (type_size arg)
  | Script_typed_ir.Chain_id_t _ => 1
  end.

Fixpoint type_size_of_stack_head {st : Set}
  (stack : Script_typed_ir.stack_ty st) (up_to : Z) {struct stack} : Z :=
  match stack with
  | Script_typed_ir.Empty_t => 0
  | Script_typed_ir.Item_t head tail _annot =>
    let 'existT _ [__0, __1] [head, tail, _annot] :=
      existT
        (fun '[__0, __1] =>
          [(Script_typed_ir.ty __0) ** (Script_typed_ir.stack_ty __1) **
            (option Script_typed_ir.var_annot)]) _ [head, tail, _annot] in
    if (|Compare.Int|).(Compare.S.op_gt) up_to 0 then
      (|Compare.Int|).(Compare.S.max) (type_size head)
        (type_size_of_stack_head tail (Pervasives.op_minus up_to 1))
    else
      0
  end.

Definition number_of_generated_growing_types {a b : Set}
  (function_parameter : Script_typed_ir.instr b a) : Z :=
  match function_parameter with
  | Script_typed_ir.Drop => 0
  | Script_typed_ir.Dup => 0
  | Script_typed_ir.Swap => 0
  | Script_typed_ir.Const _ => 1
  | Script_typed_ir.Cons_pair => 1
  | Script_typed_ir.Car => 0
  | Script_typed_ir.Cdr => 0
  | Script_typed_ir.Cons_some => 1
  | Script_typed_ir.Cons_none _ => 1
  | Script_typed_ir.If_none _ _ => 0
  | Script_typed_ir.Left => 0
  | Script_typed_ir.Right => 0
  | Script_typed_ir.If_left _ _ => 0
  | Script_typed_ir.Cons_list => 1
  | Script_typed_ir.Nil => 1
  | Script_typed_ir.If_cons _ _ => 0
  | Script_typed_ir.List_map _ => 1
  | Script_typed_ir.List_size => 0
  | Script_typed_ir.List_iter _ => 1
  | Script_typed_ir.Empty_set _ => 1
  | Script_typed_ir.Set_iter _ => 0
  | Script_typed_ir.Set_mem => 0
  | Script_typed_ir.Set_update => 0
  | Script_typed_ir.Set_size => 0
  | Script_typed_ir.Empty_map _ _ => 1
  | Script_typed_ir.Map_map _ => 1
  | Script_typed_ir.Map_iter _ => 1
  | Script_typed_ir.Map_mem => 0
  | Script_typed_ir.Map_get => 0
  | Script_typed_ir.Map_update => 0
  | Script_typed_ir.Map_size => 0
  | Script_typed_ir.Empty_big_map _ _ => 1
  | Script_typed_ir.Big_map_get => 0
  | Script_typed_ir.Big_map_update => 0
  | Script_typed_ir.Big_map_mem => 0
  | Script_typed_ir.Concat_string => 0
  | Script_typed_ir.Concat_string_pair => 0
  | Script_typed_ir.Slice_string => 0
  | Script_typed_ir.String_size => 0
  | Script_typed_ir.Concat_bytes => 0
  | Script_typed_ir.Concat_bytes_pair => 0
  | Script_typed_ir.Slice_bytes => 0
  | Script_typed_ir.Bytes_size => 0
  | Script_typed_ir.Add_seconds_to_timestamp => 0
  | Script_typed_ir.Add_timestamp_to_seconds => 0
  | Script_typed_ir.Sub_timestamp_seconds => 0
  | Script_typed_ir.Diff_timestamps => 0
  | Script_typed_ir.Add_tez => 0
  | Script_typed_ir.Sub_tez => 0
  | Script_typed_ir.Mul_teznat => 0
  | Script_typed_ir.Mul_nattez => 0
  | Script_typed_ir.Ediv_teznat => 0
  | Script_typed_ir.Ediv_tez => 0
  | Script_typed_ir.Or => 0
  | Script_typed_ir.And => 0
  | Script_typed_ir.Xor => 0
  | Script_typed_ir.Not => 0
  | Script_typed_ir.Is_nat => 0
  | Script_typed_ir.Neg_nat => 0
  | Script_typed_ir.Neg_int => 0
  | Script_typed_ir.Abs_int => 0
  | Script_typed_ir.Int_nat => 0
  | Script_typed_ir.Add_intint => 0
  | Script_typed_ir.Add_intnat => 0
  | Script_typed_ir.Add_natint => 0
  | Script_typed_ir.Add_natnat => 0
  | Script_typed_ir.Sub_int => 0
  | Script_typed_ir.Mul_intint => 0
  | Script_typed_ir.Mul_intnat => 0
  | Script_typed_ir.Mul_natint => 0
  | Script_typed_ir.Mul_natnat => 0
  | Script_typed_ir.Ediv_intint => 0
  | Script_typed_ir.Ediv_intnat => 0
  | Script_typed_ir.Ediv_natint => 0
  | Script_typed_ir.Ediv_natnat => 0
  | Script_typed_ir.Lsl_nat => 0
  | Script_typed_ir.Lsr_nat => 0
  | Script_typed_ir.Or_nat => 0
  | Script_typed_ir.And_nat => 0
  | Script_typed_ir.And_int_nat => 0
  | Script_typed_ir.Xor_nat => 0
  | Script_typed_ir.Not_nat => 0
  | Script_typed_ir.Not_int => 0
  | Script_typed_ir.Seq _ _ => 0
  | Script_typed_ir.If _ _ => 0
  | Script_typed_ir.Loop _ => 0
  | Script_typed_ir.Loop_left _ => 0
  | Script_typed_ir.Dip _ => 0
  | Script_typed_ir.Exec => 0
  | Script_typed_ir.Apply _ => 0
  | Script_typed_ir.Lambda _ => 1
  | Script_typed_ir.Failwith _ => 1
  | Script_typed_ir.Nop => 0
  | Script_typed_ir.Compare _ => 1
  | Script_typed_ir.Eq => 0
  | Script_typed_ir.Neq => 0
  | Script_typed_ir.Lt => 0
  | Script_typed_ir.Gt => 0
  | Script_typed_ir.Le => 0
  | Script_typed_ir.Ge => 0
  | Script_typed_ir.Address => 0
  | Script_typed_ir.Contract _ _ => 1
  | Script_typed_ir.Transfer_tokens => 1
  | Script_typed_ir.Create_account => 0
  | Script_typed_ir.Implicit_account => 0
  | Script_typed_ir.Create_contract _ _ _ _ => 1
  | Script_typed_ir.Create_contract_2 _ _ _ _ => 1
  | Script_typed_ir.Now => 0
  | Script_typed_ir.Balance => 0
  | Script_typed_ir.Check_signature => 0
  | Script_typed_ir.Hash_key => 0
  | Script_typed_ir.Blake2b => 0
  | Script_typed_ir.Sha256 => 0
  | Script_typed_ir.Sha512 => 0
  | Script_typed_ir.Steps_to_quota => 0
  | Script_typed_ir.Source => 0
  | Script_typed_ir.Sender => 0
  | Script_typed_ir.Self _ _ => 1
  | Script_typed_ir.Amount => 0
  | Script_typed_ir.Set_delegate => 0
  | Script_typed_ir.Pack _ => 0
  | Script_typed_ir.Unpack _ => 1
  | Script_typed_ir.Dig _ _ => 0
  | Script_typed_ir.Dug _ _ => 0
  | Script_typed_ir.Dipn _ _ _ => 0
  | Script_typed_ir.Dropn _ _ => 0
  | Script_typed_ir.ChainId => 0
  end.

Definition location {A B : Set} (function_parameter : Micheline.node A B) : A :=
  match function_parameter with
  |
    Micheline.Prim loc _ _ _ | Micheline.Int loc _ | Micheline.String loc _ |
    Micheline.Bytes loc _ | Micheline.Seq loc _ => loc
  end.

Definition kind {A B : Set} (function_parameter : Micheline.node A B)
  : Script_tc_errors.kind :=
  match function_parameter with
  | Micheline.Int _ _ => Script_tc_errors.Int_kind
  | Micheline.String _ _ => Script_tc_errors.String_kind
  | Micheline.Bytes _ _ => Script_tc_errors.Bytes_kind
  | Micheline.Prim _ _ _ _ => Script_tc_errors.Prim_kind
  | Micheline.Seq _ _ => Script_tc_errors.Seq_kind
  end.

Definition namespace (function_parameter : Alpha_context.Script.prim)
  : Script_tc_errors.namespace :=
  match function_parameter with
  |
    Alpha_context.Script.K_parameter | Alpha_context.Script.K_storage |
    Alpha_context.Script.K_code => Script_tc_errors.Keyword_namespace
  |
    Alpha_context.Script.D_False | Alpha_context.Script.D_Elt |
    Alpha_context.Script.D_Left | Alpha_context.Script.D_None |
    Alpha_context.Script.D_Pair | Alpha_context.Script.D_Right |
    Alpha_context.Script.D_Some | Alpha_context.Script.D_True |
    Alpha_context.Script.D_Unit => Script_tc_errors.Constant_namespace
  |
    Alpha_context.Script.I_PACK | Alpha_context.Script.I_UNPACK |
    Alpha_context.Script.I_BLAKE2B | Alpha_context.Script.I_SHA256 |
    Alpha_context.Script.I_SHA512 | Alpha_context.Script.I_ABS |
    Alpha_context.Script.I_ADD | Alpha_context.Script.I_AMOUNT |
    Alpha_context.Script.I_AND | Alpha_context.Script.I_BALANCE |
    Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
    Alpha_context.Script.I_CHAIN_ID | Alpha_context.Script.I_CHECK_SIGNATURE |
    Alpha_context.Script.I_COMPARE | Alpha_context.Script.I_CONCAT |
    Alpha_context.Script.I_CONS | Alpha_context.Script.I_CREATE_ACCOUNT |
    Alpha_context.Script.I_CREATE_CONTRACT |
    Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_DIP |
    Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
    Alpha_context.Script.I_EDIV | Alpha_context.Script.I_EMPTY_BIG_MAP |
    Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_EMPTY_SET |
    Alpha_context.Script.I_EQ | Alpha_context.Script.I_EXEC |
    Alpha_context.Script.I_APPLY | Alpha_context.Script.I_FAILWITH |
    Alpha_context.Script.I_GE | Alpha_context.Script.I_GET |
    Alpha_context.Script.I_GT | Alpha_context.Script.I_HASH_KEY |
    Alpha_context.Script.I_IF | Alpha_context.Script.I_IF_CONS |
    Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_NONE |
    Alpha_context.Script.I_INT | Alpha_context.Script.I_LAMBDA |
    Alpha_context.Script.I_LE | Alpha_context.Script.I_LEFT |
    Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LSL |
    Alpha_context.Script.I_LSR | Alpha_context.Script.I_LT |
    Alpha_context.Script.I_MAP | Alpha_context.Script.I_MEM |
    Alpha_context.Script.I_MUL | Alpha_context.Script.I_NEG |
    Alpha_context.Script.I_NEQ | Alpha_context.Script.I_NIL |
    Alpha_context.Script.I_NONE | Alpha_context.Script.I_NOT |
    Alpha_context.Script.I_NOW | Alpha_context.Script.I_OR |
    Alpha_context.Script.I_PAIR | Alpha_context.Script.I_PUSH |
    Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_SIZE |
    Alpha_context.Script.I_SOME | Alpha_context.Script.I_SOURCE |
    Alpha_context.Script.I_SENDER | Alpha_context.Script.I_SELF |
    Alpha_context.Script.I_SLICE | Alpha_context.Script.I_STEPS_TO_QUOTA |
    Alpha_context.Script.I_SUB | Alpha_context.Script.I_SWAP |
    Alpha_context.Script.I_TRANSFER_TOKENS | Alpha_context.Script.I_SET_DELEGATE
    | Alpha_context.Script.I_UNIT | Alpha_context.Script.I_UPDATE |
    Alpha_context.Script.I_XOR | Alpha_context.Script.I_ITER |
    Alpha_context.Script.I_LOOP_LEFT | Alpha_context.Script.I_ADDRESS |
    Alpha_context.Script.I_CONTRACT | Alpha_context.Script.I_ISNAT |
    Alpha_context.Script.I_CAST | Alpha_context.Script.I_RENAME |
    Alpha_context.Script.I_DIG | Alpha_context.Script.I_DUG =>
    Script_tc_errors.Instr_namespace
  |
    Alpha_context.Script.T_bool | Alpha_context.Script.T_contract |
    Alpha_context.Script.T_int | Alpha_context.Script.T_key |
    Alpha_context.Script.T_key_hash | Alpha_context.Script.T_lambda |
    Alpha_context.Script.T_list | Alpha_context.Script.T_map |
    Alpha_context.Script.T_big_map | Alpha_context.Script.T_nat |
    Alpha_context.Script.T_option | Alpha_context.Script.T_or |
    Alpha_context.Script.T_pair | Alpha_context.Script.T_set |
    Alpha_context.Script.T_signature | Alpha_context.Script.T_string |
    Alpha_context.Script.T_bytes | Alpha_context.Script.T_mutez |
    Alpha_context.Script.T_timestamp | Alpha_context.Script.T_unit |
    Alpha_context.Script.T_operation | Alpha_context.Script.T_address |
    Alpha_context.Script.T_chain_id => Script_tc_errors.Type_namespace
  end.

Definition unexpected
  (expr : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  (exp_kinds : list Script_tc_errors.kind) (exp_ns : Script_tc_errors.namespace)
  (exp_prims : list Alpha_context.Script.prim) : Error_monad.__error :=
  match expr with
  | Micheline.Int loc _ => extensible_type_value
  | Micheline.String loc _ => extensible_type_value
  | Micheline.Bytes loc _ => extensible_type_value
  | Micheline.Seq loc _ => extensible_type_value
  | Micheline.Prim loc name _ _ =>
    match ((namespace name), exp_ns) with
    |
      (Script_tc_errors.Type_namespace, Script_tc_errors.Type_namespace) |
      (Script_tc_errors.Instr_namespace, Script_tc_errors.Instr_namespace) |
      (Script_tc_errors.Constant_namespace, Script_tc_errors.Constant_namespace)
      => extensible_type_value
    | (ns, _) => extensible_type_value
    end
  end.

Definition check_kind {A : Set}
  (kinds : list Script_tc_errors.kind)
  (expr : Micheline.node Alpha_context.Script.location A)
  : Lwt.t (Error_monad.tzresult unit) :=
  let kind := kind expr in
  if List.mem kind kinds then
    Error_monad.return_unit
  else
    let loc := location expr in
    Error_monad.fail extensible_type_value.

Definition wrap_compare {A B : Set}
  (compare : A -> B -> (|Compare.Int|).(Compare.S.t)) (a : A) (b : B) : Z :=
  let res := compare a b in
  if (|Compare.Int|).(Compare.S.op_eq) res 0 then
    0
  else
    if (|Compare.Int|).(Compare.S.op_gt) res 0 then
      1
    else
      (-1).

Fixpoint compare_comparable {a s : Set}
  (kind : Script_typed_ir.comparable_struct a s) {struct kind} : a -> a -> Z :=
  match kind with
  | Script_typed_ir.String_key _ =>
    wrap_compare (|Compare.String|).(Compare.S.compare)
  | Script_typed_ir.Bool_key _ =>
    wrap_compare (|Compare.Bool|).(Compare.S.compare)
  | Script_typed_ir.Mutez_key _ => wrap_compare Alpha_context.Tez.compare
  | Script_typed_ir.Key_hash_key _ =>
    wrap_compare (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
  | Script_typed_ir.Int_key _ => wrap_compare Alpha_context.Script_int.compare
  | Script_typed_ir.Nat_key _ => wrap_compare Alpha_context.Script_int.compare
  | Script_typed_ir.Timestamp_key _ =>
    wrap_compare Alpha_context.Script_timestamp.compare
  | Script_typed_ir.Address_key _ =>
    Pervasives.op_atat wrap_compare
      (fun function_parameter =>
        let '(x, ex) := function_parameter in
        fun function_parameter =>
          let '(y, ey) := function_parameter in
          let lres := Alpha_context.Contract.compare x y in
          if (|Compare.Int|).(Compare.S.op_eq) lres 0 then
            (|Compare.String|).(Compare.S.compare) ex ey
          else
            lres)
  | Script_typed_ir.Bytes_key _ => wrap_compare MBytes.compare
  | Script_typed_ir.Pair_key (tl, _) (tr, _) _ =>
    let 'existT _ [__0, __1, __Pair_key] [tl, tr] :=
      existT
        (fun '[__0, __1, __Pair_key] =>
          [(Script_typed_ir.comparable_struct __0 Script_typed_ir.leaf) **
            (Script_typed_ir.comparable_struct __1 __Pair_key)]) _ [tl, tr] in
    fun function_parameter =>
      let '(lx, rx) := function_parameter in
      fun function_parameter =>
        let '(ly, ry) := function_parameter in
        let lres := compare_comparable tl lx ly in
        if (|Compare.Int|).(Compare.S.op_eq) lres 0 then
          compare_comparable tr rx ry
        else
          lres
  end.

Definition empty_set {a : Set} (ty : Script_typed_ir.comparable_ty a)
  : Script_typed_ir.set a :=
  let OPS :=
    __Set.Make
      (let t := a in
      let compare := compare_comparable ty in
      existT (A := Set) _ _
        {|
          Compare.COMPARABLE.compare := compare
        |}) in
  let elt := a in
  let elt_ty := ty in
  let OPS := existT (A := unit) (fun _ => _) tt (|OPS|) in
  let boxed := (|OPS|).(S.SET.empty) in
  let size := 0 in
  existT (A := Set) _ _
    {|
      Script_typed_ir.Boxed_set.elt_ty := elt_ty;
      Script_typed_ir.Boxed_set.OPS := (|OPS|);
      Script_typed_ir.Boxed_set.boxed := boxed;
      Script_typed_ir.Boxed_set.size := size
    |}.

Definition set_update {a : Set} (v : a) (b : bool) (Box : Script_typed_ir.set a)
  : Script_typed_ir.set a :=
  let elt := a in
  let elt_ty := (|Box|).(Script_typed_ir.Boxed_set.elt_ty) in
  let OPS :=
    existT (A := unit) (fun _ => _) tt (|Box|).(Script_typed_ir.Boxed_set.OPS)
    in
  let boxed :=
    if b then
      (|Box|).(Script_typed_ir.Boxed_set.OPS).(S.SET.add) v
        (|Box|).(Script_typed_ir.Boxed_set.boxed)
    else
      (|Box|).(Script_typed_ir.Boxed_set.OPS).(S.SET.remove) v
        (|Box|).(Script_typed_ir.Boxed_set.boxed) in
  let size :=
    let mem :=
      (|Box|).(Script_typed_ir.Boxed_set.OPS).(S.SET.mem) v
        (|Box|).(Script_typed_ir.Boxed_set.boxed) in
    if mem then
      if b then
        (|Box|).(Script_typed_ir.Boxed_set.size)
      else
        Pervasives.op_minus (|Box|).(Script_typed_ir.Boxed_set.size) 1
    else
      if b then
        Pervasives.op_plus (|Box|).(Script_typed_ir.Boxed_set.size) 1
      else
        (|Box|).(Script_typed_ir.Boxed_set.size) in
  existT (A := Set) _ _
    {|
      Script_typed_ir.Boxed_set.elt_ty := elt_ty;
      Script_typed_ir.Boxed_set.OPS := (|OPS|);
      Script_typed_ir.Boxed_set.boxed := boxed;
      Script_typed_ir.Boxed_set.size := size
    |}.

Definition set_mem {elt : Set} (v : elt) (Box : Script_typed_ir.set elt)
  : bool :=
  (|Box|).(Script_typed_ir.Boxed_set.OPS).(S.SET.mem) v
    (|Box|).(Script_typed_ir.Boxed_set.boxed).

Definition set_fold {acc elt : Set}
  (f : elt -> acc -> acc) (Box : Script_typed_ir.set elt) : acc -> acc :=
  (|Box|).(Script_typed_ir.Boxed_set.OPS).(S.SET.fold) f
    (|Box|).(Script_typed_ir.Boxed_set.boxed).

Definition set_size {elt : Set} (Box : Script_typed_ir.set elt)
  : Alpha_context.Script_int.num Alpha_context.Script_int.n :=
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int (|Box|).(Script_typed_ir.Boxed_set.size)).

Definition map_key_ty {a b : Set} (Box : Script_typed_ir.map a b)
  : Script_typed_ir.comparable_ty a :=
  (|Box|).(Script_typed_ir.Boxed_map.key_ty).

Definition empty_map {a b : Set} (ty : Script_typed_ir.comparable_ty a)
  : Script_typed_ir.map a b :=
  let OPS :=
    Map.Make
      (let t := a in
      let compare := compare_comparable ty in
      existT (A := Set) _ _
        {|
          Compare.COMPARABLE.compare := compare
        |}) in
  let key := a in
  let value := b in
  let key_ty := ty in
  let OPS := existT (A := unit) (fun _ => _) tt (|OPS|) in
  let boxed {C : Set} : (|OPS|).(S.MAP.t) C * Z :=
    ((|OPS|).(S.MAP.empty), 0) in
  existT (A := Set -> Set) _ _
    {|
      Script_typed_ir.Boxed_map.key_ty := key_ty;
      Script_typed_ir.Boxed_map.OPS := (|OPS|);
      Script_typed_ir.Boxed_map.boxed := boxed
    |}.

Definition map_get {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : option value :=
  (|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.find_opt) k
    (Pervasives.fst (|Box|).(Script_typed_ir.Boxed_map.boxed)).

Definition map_update {a b : Set}
  (k : a) (v : option b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let key := a in
  let value := b in
  let key_ty := (|Box|).(Script_typed_ir.Boxed_map.key_ty) in
  let OPS :=
    existT (A := unit) (fun _ => _) tt (|Box|).(Script_typed_ir.Boxed_map.OPS)
    in
  let boxed :=
    let '(map, size) := (|Box|).(Script_typed_ir.Boxed_map.boxed) in
    let contains := (|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k map in
    match v with
    | Some v =>
      (((|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k v map),
        (Pervasives.op_plus size
          (if contains then
            0
          else
            1)))
    | None =>
      (((|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.remove) k map),
        (Pervasives.op_minus size
          (if contains then
            1
          else
            0)))
    end in
  existT (A := Set -> Set) _ _
    {|
      Script_typed_ir.Boxed_map.key_ty := key_ty;
      Script_typed_ir.Boxed_map.OPS := (|OPS|);
      Script_typed_ir.Boxed_map.boxed := boxed
    |}.

Definition map_set {a b : Set} (k : a) (v : b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let key := a in
  let value := b in
  let key_ty := (|Box|).(Script_typed_ir.Boxed_map.key_ty) in
  let OPS :=
    existT (A := unit) (fun _ => _) tt (|Box|).(Script_typed_ir.Boxed_map.OPS)
    in
  let boxed :=
    let '(map, size) := (|Box|).(Script_typed_ir.Boxed_map.boxed) in
    (((|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k v map),
      (if (|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k map then
        size
      else
        Pervasives.op_plus size 1)) in
  existT (A := Set -> Set) _ _
    {|
      Script_typed_ir.Boxed_map.key_ty := key_ty;
      Script_typed_ir.Boxed_map.OPS := (|OPS|);
      Script_typed_ir.Boxed_map.boxed := boxed
    |}.

Definition map_mem {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : bool :=
  (|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k
    (Pervasives.fst (|Box|).(Script_typed_ir.Boxed_map.boxed)).

Definition map_fold {acc key value : Set}
  (f : key -> value -> acc -> acc) (Box : Script_typed_ir.map key value)
  : acc -> acc :=
  (|Box|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.fold) f
    (Pervasives.fst (|Box|).(Script_typed_ir.Boxed_map.boxed)).

Definition map_size {key value : Set} (Box : Script_typed_ir.map key value)
  : Alpha_context.Script_int.num Alpha_context.Script_int.n :=
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int
      (Pervasives.snd (|Box|).(Script_typed_ir.Boxed_map.boxed))).

Fixpoint ty_of_comparable_ty {a s : Set}
  (function_parameter : Script_typed_ir.comparable_struct a s)
  {struct function_parameter} : Script_typed_ir.ty a :=
  match function_parameter with
  | Script_typed_ir.Int_key tname => Script_typed_ir.Int_t tname
  | Script_typed_ir.Nat_key tname => Script_typed_ir.Nat_t tname
  | Script_typed_ir.String_key tname => Script_typed_ir.String_t tname
  | Script_typed_ir.Bytes_key tname => Script_typed_ir.Bytes_t tname
  | Script_typed_ir.Mutez_key tname => Script_typed_ir.Mutez_t tname
  | Script_typed_ir.Bool_key tname => Script_typed_ir.Bool_t tname
  | Script_typed_ir.Key_hash_key tname => Script_typed_ir.Key_hash_t tname
  | Script_typed_ir.Timestamp_key tname => Script_typed_ir.Timestamp_t tname
  | Script_typed_ir.Address_key tname => Script_typed_ir.Address_t tname
  | Script_typed_ir.Pair_key (l, al) (r, ar) tname =>
    let 'existT _ [__0, __1, __Pair_key] [l, al, r, ar, tname] :=
      existT
        (fun '[__0, __1, __Pair_key] =>
          [(Script_typed_ir.comparable_struct __0 Script_typed_ir.leaf) **
            (option Script_typed_ir.field_annot) **
            (Script_typed_ir.comparable_struct __1 __Pair_key) **
            (option Script_typed_ir.field_annot) **
            (option Script_typed_ir.type_annot)]) _ [l, al, r, ar, tname] in
    Script_typed_ir.Pair_t ((ty_of_comparable_ty l), al, None)
      ((ty_of_comparable_ty r), ar, None) tname false
  end.

Fixpoint comparable_ty_of_ty {a : Set}
  (function_parameter : Script_typed_ir.ty a) {struct function_parameter}
  : option (Script_typed_ir.comparable_ty a) :=
  match function_parameter with
  | Script_typed_ir.Int_t tname => Some (Script_typed_ir.Int_key tname)
  | Script_typed_ir.Nat_t tname => Some (Script_typed_ir.Nat_key tname)
  | Script_typed_ir.String_t tname => Some (Script_typed_ir.String_key tname)
  | Script_typed_ir.Bytes_t tname => Some (Script_typed_ir.Bytes_key tname)
  | Script_typed_ir.Mutez_t tname => Some (Script_typed_ir.Mutez_key tname)
  | Script_typed_ir.Bool_t tname => Some (Script_typed_ir.Bool_key tname)
  | Script_typed_ir.Key_hash_t tname =>
    Some (Script_typed_ir.Key_hash_key tname)
  | Script_typed_ir.Timestamp_t tname =>
    Some (Script_typed_ir.Timestamp_key tname)
  | Script_typed_ir.Address_t tname => Some (Script_typed_ir.Address_key tname)
  | Script_typed_ir.Pair_t (l, al, _) (r, ar, _) pname _ =>
    let 'existT _ [__0, __1] [l, al, r, ar, pname] :=
      existT
        (fun '[__0, __1] =>
          [(Script_typed_ir.ty __0) ** (option Script_typed_ir.field_annot) **
            (Script_typed_ir.ty __1) ** (option Script_typed_ir.field_annot) **
            (option Script_typed_ir.type_annot)]) _ [l, al, r, ar, pname] in
    match comparable_ty_of_ty r with
    | None => None
    | Some rty =>
      match comparable_ty_of_ty l with
      | None => None
      | Some (Script_typed_ir.Pair_key _ _ _) => None
      | Some (Script_typed_ir.Int_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Int_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Nat_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Nat_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.String_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.String_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bytes_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bytes_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Mutez_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Mutez_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bool_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bool_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Key_hash_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Key_hash_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Timestamp_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Timestamp_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Address_key tname) =>
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Address_key tname), al)
            (rty, ar) pname)
      end
    end
  | _ => None
  end.

Definition add_field_annot {A B : Set}
  (a : option Script_typed_ir.field_annot)
  (var : option Script_typed_ir.var_annot)
  (function_parameter : Micheline.node A B) : Micheline.node A B :=
  match function_parameter with
  | Micheline.Prim loc prim args annots =>
    Micheline.Prim loc prim args
      (Pervasives.op_at annots
        (Pervasives.op_at (Script_ir_annot.unparse_field_annot a)
          (Script_ir_annot.unparse_var_annot var)))
  | expr => expr
  end.

Fixpoint unparse_comparable_ty {a s : Set}
  (function_parameter : Script_typed_ir.comparable_struct a s)
  {struct function_parameter} : Alpha_context.Script.node :=
  match function_parameter with
  | Script_typed_ir.Int_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_int nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Nat_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_nat nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.String_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_string nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bytes_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_bytes nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Mutez_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_mutez nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bool_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_bool nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Key_hash_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_key_hash nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Timestamp_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_timestamp nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Address_key tname =>
    Micheline.Prim (-1) Alpha_context.Script.T_address nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Pair_key (l, al) (r, ar) pname =>
    let 'existT _ [__0, __1, __Pair_key] [l, al, r, ar, pname] :=
      existT
        (fun '[__0, __1, __Pair_key] =>
          [(Script_typed_ir.comparable_struct __0 Script_typed_ir.leaf) **
            (option Script_typed_ir.field_annot) **
            (Script_typed_ir.comparable_struct __1 __Pair_key) **
            (option Script_typed_ir.field_annot) **
            (option Script_typed_ir.type_annot)]) _ [l, al, r, ar, pname] in
    let tl := add_field_annot al None (unparse_comparable_ty l) in
    let tr := add_field_annot ar None (unparse_comparable_ty r) in
    Micheline.Prim (-1) Alpha_context.Script.T_pair [ tl; tr ]
      (Script_ir_annot.unparse_type_annot pname)
  end.

Fixpoint unparse_ty_no_lwt {a : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty a) {struct ctxt}
  : Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Unparse_costs.cycle)
    (fun ctxt =>
      let __return {B : Set}
        (ctxt : Alpha_context.context)
        (function_parameter : B * list (Micheline.node Z B) * Micheline.annot)
        : Error_monad.tzresult (Micheline.node Z B * Alpha_context.context) :=
        let '(name, args, annot) := function_parameter in
        let __result_value := Micheline.Prim (-1) name args annot in
        Error_monad.op_gtgtquestion
          (Alpha_context.Gas.consume ctxt
            (Unparse_costs.prim_cost (List.length args) annot))
          (fun ctxt => Error_monad.ok (__result_value, ctxt)) in
      match ty with
      | Script_typed_ir.Unit_t tname =>
        __return ctxt
          (Alpha_context.Script.T_unit, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Int_t tname =>
        __return ctxt
          (Alpha_context.Script.T_int, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Nat_t tname =>
        __return ctxt
          (Alpha_context.Script.T_nat, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.String_t tname =>
        __return ctxt
          (Alpha_context.Script.T_string, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Bytes_t tname =>
        __return ctxt
          (Alpha_context.Script.T_bytes, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Mutez_t tname =>
        __return ctxt
          (Alpha_context.Script.T_mutez, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Bool_t tname =>
        __return ctxt
          (Alpha_context.Script.T_bool, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Key_hash_t tname =>
        __return ctxt
          (Alpha_context.Script.T_key_hash, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Key_t tname =>
        __return ctxt
          (Alpha_context.Script.T_key, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Timestamp_t tname =>
        __return ctxt
          (Alpha_context.Script.T_timestamp, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Address_t tname =>
        __return ctxt
          (Alpha_context.Script.T_address, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Signature_t tname =>
        __return ctxt
          (Alpha_context.Script.T_signature, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Operation_t tname =>
        __return ctxt
          (Alpha_context.Script.T_operation, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Chain_id_t tname =>
        __return ctxt
          (Alpha_context.Script.T_chain_id, nil,
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Contract_t ut tname =>
        let 'existT _ __0 [ut, tname] :=
          existT
            (fun __0 : Set =>
              [(Script_typed_ir.ty __0) ** (option Script_typed_ir.type_annot)])
            _ [ut, tname] in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ut)
          (fun function_parameter =>
            let '(__t_value, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_contract, [ __t_value ],
                (Script_ir_annot.unparse_type_annot tname)))
      |
        Script_typed_ir.Pair_t (utl, l_field, l_var) (utr, r_field, r_var) tname
          _ =>
        let 'existT _ [__1, __2]
          [utl, l_field, l_var, utr, r_field, r_var, tname] :=
          existT
            (fun '[__1, __2] =>
              [(Script_typed_ir.ty __1) ** (option Script_typed_ir.field_annot)
                ** (option Script_typed_ir.var_annot) **
                (Script_typed_ir.ty __2) ** (option Script_typed_ir.field_annot)
                ** (option Script_typed_ir.var_annot) **
                (option Script_typed_ir.type_annot)]) _
            [utl, l_field, l_var, utr, r_field, r_var, tname] in
        let annot := Script_ir_annot.unparse_type_annot tname in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utl)
          (fun function_parameter =>
            let '(utl, ctxt) := function_parameter in
            let tl := add_field_annot l_field l_var utl in
            Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
              (fun function_parameter =>
                let '(utr, ctxt) := function_parameter in
                let tr := add_field_annot r_field r_var utr in
                __return ctxt (Alpha_context.Script.T_pair, [ tl; tr ], annot)))
      | Script_typed_ir.Union_t (utl, l_field) (utr, r_field) tname _ =>
        let 'existT _ [__3, __4] [utl, l_field, utr, r_field, tname] :=
          existT
            (fun '[__3, __4] =>
              [(Script_typed_ir.ty __3) ** (option Script_typed_ir.field_annot)
                ** (Script_typed_ir.ty __4) **
                (option Script_typed_ir.field_annot) **
                (option Script_typed_ir.type_annot)]) _
            [utl, l_field, utr, r_field, tname] in
        let annot := Script_ir_annot.unparse_type_annot tname in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utl)
          (fun function_parameter =>
            let '(utl, ctxt) := function_parameter in
            let tl := add_field_annot l_field None utl in
            Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
              (fun function_parameter =>
                let '(utr, ctxt) := function_parameter in
                let tr := add_field_annot r_field None utr in
                __return ctxt (Alpha_context.Script.T_or, [ tl; tr ], annot)))
      | Script_typed_ir.Lambda_t uta utr tname =>
        let 'existT _ [__5, __6] [uta, utr, tname] :=
          existT
            (fun '[__5, __6] =>
              [(Script_typed_ir.ty __5) ** (Script_typed_ir.ty __6) **
                (option Script_typed_ir.type_annot)]) _ [uta, utr, tname] in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt uta)
          (fun function_parameter =>
            let '(ta, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
              (fun function_parameter =>
                let '(tr, ctxt) := function_parameter in
                __return ctxt
                  (Alpha_context.Script.T_lambda, [ ta; tr ],
                    (Script_ir_annot.unparse_type_annot tname))))
      | Script_typed_ir.Option_t ut tname _ =>
        let 'existT _ __7 [ut, tname] :=
          existT
            (fun __7 : Set =>
              [(Script_typed_ir.ty __7) ** (option Script_typed_ir.type_annot)])
            _ [ut, tname] in
        let annot := Script_ir_annot.unparse_type_annot tname in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ut)
          (fun function_parameter =>
            let '(ut, ctxt) := function_parameter in
            __return ctxt (Alpha_context.Script.T_option, [ ut ], annot))
      | Script_typed_ir.List_t ut tname _ =>
        let 'existT _ __8 [ut, tname] :=
          existT
            (fun __8 : Set =>
              [(Script_typed_ir.ty __8) ** (option Script_typed_ir.type_annot)])
            _ [ut, tname] in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ut)
          (fun function_parameter =>
            let '(__t_value, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_list, [ __t_value ],
                (Script_ir_annot.unparse_type_annot tname)))
      | Script_typed_ir.Set_t ut tname =>
        let 'existT _ __9 [ut, tname] :=
          existT
            (fun __9 : Set =>
              [(Script_typed_ir.comparable_ty __9) **
                (option Script_typed_ir.type_annot)]) _ [ut, tname] in
        let __t_value := unparse_comparable_ty ut in
        __return ctxt
          (Alpha_context.Script.T_set, [ __t_value ],
            (Script_ir_annot.unparse_type_annot tname))
      | Script_typed_ir.Map_t uta utr tname _ =>
        let 'existT _ [__10, __11] [uta, utr, tname] :=
          existT
            (fun '[__10, __11] =>
              [(Script_typed_ir.comparable_ty __10) ** (Script_typed_ir.ty __11)
                ** (option Script_typed_ir.type_annot)]) _ [uta, utr, tname] in
        let ta := unparse_comparable_ty uta in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
          (fun function_parameter =>
            let '(tr, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_map, [ ta; tr ],
                (Script_ir_annot.unparse_type_annot tname)))
      | Script_typed_ir.Big_map_t uta utr tname =>
        let 'existT _ [__12, __13] [uta, utr, tname] :=
          existT
            (fun '[__12, __13] =>
              [(Script_typed_ir.comparable_ty __12) ** (Script_typed_ir.ty __13)
                ** (option Script_typed_ir.type_annot)]) _ [uta, utr, tname] in
        let ta := unparse_comparable_ty uta in
        Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt utr)
          (fun function_parameter =>
            let '(tr, ctxt) := function_parameter in
            __return ctxt
              (Alpha_context.Script.T_big_map, [ ta; tr ],
                (Script_ir_annot.unparse_type_annot tname)))
      end).

Definition unparse_ty {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty A)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  Lwt.__return (unparse_ty_no_lwt ctxt ty).

Fixpoint strip_var_annots {A B : Set} (function_parameter : Micheline.node A B)
  {struct function_parameter} : Micheline.node A B :=
  match function_parameter with
  | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom =>
    atom
  | Micheline.Seq loc args => Micheline.Seq loc (List.map strip_var_annots args)
  | Micheline.Prim loc name args annots =>
    let not_var_annot (s : string) : bool :=
      (|Compare.Char|).(Compare.S.op_ltgt) (String.get s 0) "@" % char in
    let annots := List.filter not_var_annot annots in
    Micheline.Prim loc name (List.map strip_var_annots args) annots
  end.

Definition serialize_ty_for_error {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty A)
  : Error_monad.tzresult
    (Micheline.canonical Alpha_context.Script.prim * Alpha_context.context) :=
  Error_monad.op_gtpipequestion
    (Pervasives.op_pipegt (unparse_ty_no_lwt ctxt ty)
      (Error_monad.record_trace extensible_type_value))
    (fun function_parameter =>
      let '(ty, ctxt) := function_parameter in
      ((Micheline.strip_locations (strip_var_annots ty)), ctxt)).

Fixpoint unparse_stack {a : Set}
  (ctxt : Alpha_context.context)
  (function_parameter : Script_typed_ir.stack_ty a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  match function_parameter with
  | Script_typed_ir.Empty_t => Error_monad.__return (nil, ctxt)
  | Script_typed_ir.Item_t ty rest annot =>
    let 'existT _ [__0, __1] [ty, rest, annot] :=
      existT
        (fun '[__0, __1] =>
          [(Script_typed_ir.ty __0) ** (Script_typed_ir.stack_ty __1) **
            (option Script_typed_ir.var_annot)]) _ [ty, rest, annot] in
    Error_monad.op_gtgteqquestion (unparse_ty ctxt ty)
      (fun function_parameter =>
        let '(uty, ctxt) := function_parameter in
        Error_monad.op_gtgteqquestion (unparse_stack ctxt rest)
          (fun function_parameter =>
            let '(urest, ctxt) := function_parameter in
            Error_monad.__return
              ((cons
                ((Micheline.strip_locations uty),
                  (Script_ir_annot.unparse_var_annot annot)) urest), ctxt)))
  end.

Definition serialize_stack_for_error {A : Set}
  (ctxt : Alpha_context.context) (stack_ty : Script_typed_ir.stack_ty A)
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  Error_monad.trace extensible_type_value (unparse_stack ctxt stack_ty).

Definition name_of_ty {a : Set} (function_parameter : Script_typed_ir.ty a)
  : option Script_typed_ir.type_annot :=
  match function_parameter with
  | Script_typed_ir.Unit_t tname => tname
  | Script_typed_ir.Int_t tname => tname
  | Script_typed_ir.Nat_t tname => tname
  | Script_typed_ir.String_t tname => tname
  | Script_typed_ir.Bytes_t tname => tname
  | Script_typed_ir.Mutez_t tname => tname
  | Script_typed_ir.Bool_t tname => tname
  | Script_typed_ir.Key_hash_t tname => tname
  | Script_typed_ir.Key_t tname => tname
  | Script_typed_ir.Timestamp_t tname => tname
  | Script_typed_ir.Address_t tname => tname
  | Script_typed_ir.Signature_t tname => tname
  | Script_typed_ir.Operation_t tname => tname
  | Script_typed_ir.Chain_id_t tname => tname
  | Script_typed_ir.Contract_t _ tname => tname
  | Script_typed_ir.Pair_t _ _ tname _ => tname
  | Script_typed_ir.Union_t _ _ tname _ => tname
  | Script_typed_ir.Lambda_t _ _ tname => tname
  | Script_typed_ir.Option_t _ tname _ => tname
  | Script_typed_ir.List_t _ tname _ => tname
  | Script_typed_ir.Set_t _ tname => tname
  | Script_typed_ir.Map_t _ _ tname _ => tname
  | Script_typed_ir.Big_map_t _ _ tname => tname
  end.

Reserved Notation "'eq".

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where "'eq" := (fun (_ _ : Set) => eq_gadt).

Definition eq := 'eq.

Definition comparable_ty_eq {ta tb : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.comparable_ty ta)
  (tb : Script_typed_ir.comparable_ty tb)
  : Error_monad.tzresult
    (eq (Script_typed_ir.comparable_ty ta) (Script_typed_ir.comparable_ty tb)) :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key _, Script_typed_ir.Int_key _) => Pervasives.Ok Eq
  | (Script_typed_ir.Nat_key _, Script_typed_ir.Nat_key _) => Pervasives.Ok Eq
  | (Script_typed_ir.String_key _, Script_typed_ir.String_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Bytes_key _, Script_typed_ir.Bytes_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Mutez_key _, Script_typed_ir.Mutez_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Bool_key _, Script_typed_ir.Bool_key _) => Pervasives.Ok Eq
  | (Script_typed_ir.Key_hash_key _, Script_typed_ir.Key_hash_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Timestamp_key _, Script_typed_ir.Timestamp_key _) =>
    Pervasives.Ok Eq
  | (Script_typed_ir.Address_key _, Script_typed_ir.Address_key _) =>
    Pervasives.Ok Eq
  | (_, _) =>
    Error_monad.op_gtgtquestion
      (serialize_ty_for_error ctxt (ty_of_comparable_ty ta))
      (fun function_parameter =>
        let '(ta, ctxt) := function_parameter in
        Error_monad.op_gtgtquestion
          (serialize_ty_for_error ctxt (ty_of_comparable_ty tb))
          (fun function_parameter =>
            let '(tb, _ctxt) := function_parameter in
            Error_monad.__error_value extensible_type_value))
  end.

Definition record_inconsistent {A B C : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty A)
  (tb : Script_typed_ir.ty B)
  : Error_monad.tzresult C -> Error_monad.tzresult C :=
  Error_monad.record_trace_eval
    (fun function_parameter =>
      let '_ := function_parameter in
      Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt ta)
        (fun function_parameter =>
          let '(ta, ctxt) := function_parameter in
          Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
            (fun function_parameter =>
              let '(tb, _ctxt) := function_parameter in
              extensible_type_value))).

Definition record_inconsistent_type_annotations {A B C : Set}
  (ctxt : Alpha_context.context) (loc : Alpha_context.Script.location)
  (ta : Script_typed_ir.ty A) (tb : Script_typed_ir.ty B)
  : Error_monad.tzresult C -> Error_monad.tzresult C :=
  Error_monad.record_trace_eval
    (fun function_parameter =>
      let '_ := function_parameter in
      Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt ta)
        (fun function_parameter =>
          let '(ta, ctxt) := function_parameter in
          Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
            (fun function_parameter =>
              let '(tb, _ctxt) := function_parameter in
              extensible_type_value))).

Fixpoint ty_eq {ta tb : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty ta)
  (tb : Script_typed_ir.ty tb) {struct ctxt}
  : Error_monad.tzresult
    (eq (Script_typed_ir.ty ta) (Script_typed_ir.ty tb) * Alpha_context.context) :=
  let ok
    (__eq_value : eq (Script_typed_ir.ty ta) (Script_typed_ir.ty tb))
    (ctxt : Alpha_context.context) (nb_args : Z)
    : Error_monad.tzresult
      (eq (Script_typed_ir.ty ta) (Script_typed_ir.ty tb) *
        Alpha_context.context) :=
    Error_monad.op_gtgtquestion
      (Alpha_context.Gas.consume ctxt
        (Typecheck_costs.type_ (Pervasives.op_star 2 nb_args)))
      (fun ctxt => Pervasives.Ok (__eq_value, ctxt)) in
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =>
      match (ta, tb) with
      | (Script_typed_ir.Unit_t _, Script_typed_ir.Unit_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Int_t _, Script_typed_ir.Int_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Nat_t _, Script_typed_ir.Nat_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Key_t _, Script_typed_ir.Key_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Key_hash_t _, Script_typed_ir.Key_hash_t _) =>
        ok Eq ctxt 0
      | (Script_typed_ir.String_t _, Script_typed_ir.String_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Bytes_t _, Script_typed_ir.Bytes_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Signature_t _, Script_typed_ir.Signature_t _) =>
        ok Eq ctxt 0
      | (Script_typed_ir.Mutez_t _, Script_typed_ir.Mutez_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Timestamp_t _, Script_typed_ir.Timestamp_t _) =>
        ok Eq ctxt 0
      | (Script_typed_ir.Chain_id_t _, Script_typed_ir.Chain_id_t _) =>
        ok Eq ctxt 0
      | (Script_typed_ir.Address_t _, Script_typed_ir.Address_t _) =>
        ok Eq ctxt 0
      | (Script_typed_ir.Bool_t _, Script_typed_ir.Bool_t _) => ok Eq ctxt 0
      | (Script_typed_ir.Operation_t _, Script_typed_ir.Operation_t _) =>
        ok Eq ctxt 0
      | (Script_typed_ir.Map_t tal tar _ _, Script_typed_ir.Map_t tbl tbr _ _)
        =>
        let 'existT _ [__0, __1, __2, __3] [tal, tar, tbl, tbr] :=
          existT
            (fun '[__0, __1, __2, __3] =>
              [(Script_typed_ir.comparable_ty __0) ** (Script_typed_ir.ty __1)
                ** (Script_typed_ir.comparable_ty __2) **
                (Script_typed_ir.ty __3)]) _ [tal, tar, tbl, tbr] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt tal tbl)
            (fun function_parameter =>
              let 'Eq := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      |
        (Script_typed_ir.Big_map_t tal tar _,
          Script_typed_ir.Big_map_t tbl tbr _) =>
        let 'existT _ [__4, __5, __6, __7] [tal, tar, tbl, tbr] :=
          existT
            (fun '[__4, __5, __6, __7] =>
              [(Script_typed_ir.comparable_ty __4) ** (Script_typed_ir.ty __5)
                ** (Script_typed_ir.comparable_ty __6) **
                (Script_typed_ir.ty __7)]) _ [tal, tar, tbl, tbr] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt tal tbl)
            (fun function_parameter =>
              let 'Eq := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Set_t ea _, Script_typed_ir.Set_t eb _) =>
        let 'existT _ [__8, __9] [ea, eb] :=
          existT
            (fun '[__8, __9] =>
              [(Script_typed_ir.comparable_ty __8) **
                (Script_typed_ir.comparable_ty __9)]) _ [ea, eb] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt ea eb)
            (fun function_parameter =>
              let 'Eq := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      |
        (Script_typed_ir.Pair_t (tal, _, _) (tar, _, _) _ _,
          Script_typed_ir.Pair_t (tbl, _, _) (tbr, _, _) _ _) =>
        let 'existT _ [__10, __11, __12, __13] [tal, tar, tbl, tbr] :=
          existT
            (fun '[__10, __11, __12, __13] =>
              [(Script_typed_ir.ty __10) ** (Script_typed_ir.ty __11) **
                (Script_typed_ir.ty __12) ** (Script_typed_ir.ty __13)]) _
            [tal, tar, tbl, tbr] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =>
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      |
        (Script_typed_ir.Union_t (tal, _) (tar, _) _ _,
          Script_typed_ir.Union_t (tbl, _) (tbr, _) _ _) =>
        let 'existT _ [__14, __15, __16, __17] [tal, tar, tbl, tbr] :=
          existT
            (fun '[__14, __15, __16, __17] =>
              [(Script_typed_ir.ty __14) ** (Script_typed_ir.ty __15) **
                (Script_typed_ir.ty __16) ** (Script_typed_ir.ty __17)]) _
            [tal, tar, tbl, tbr] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =>
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Lambda_t tal tar _, Script_typed_ir.Lambda_t tbl tbr _)
        =>
        let 'existT _ [__18, __19, __20, __21] [tal, tar, tbl, tbr] :=
          existT
            (fun '[__18, __19, __20, __21] =>
              [(Script_typed_ir.ty __18) ** (Script_typed_ir.ty __19) **
                (Script_typed_ir.ty __20) ** (Script_typed_ir.ty __21)]) _
            [tal, tar, tbl, tbr] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =>
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar tbr)
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  ok Eq ctxt 2))) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Contract_t tal _, Script_typed_ir.Contract_t tbl _) =>
        let 'existT _ [__22, __23] [tal, tbl] :=
          existT
            (fun '[__22, __23] =>
              [(Script_typed_ir.ty __22) ** (Script_typed_ir.ty __23)]) _
            [tal, tbl] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tal tbl)
            (fun function_parameter =>
              let '(Eq, ctxt) := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.Option_t tva _ _, Script_typed_ir.Option_t tvb _ _) =>
        let 'existT _ [__24, __25] [tva, tvb] :=
          existT
            (fun '[__24, __25] =>
              [(Script_typed_ir.ty __24) ** (Script_typed_ir.ty __25)]) _
            [tva, tvb] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tva tvb)
            (fun function_parameter =>
              let '(Eq, ctxt) := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      | (Script_typed_ir.List_t tva _ _, Script_typed_ir.List_t tvb _ _) =>
        let 'existT _ [__26, __27] [tva, tvb] :=
          existT
            (fun '[__26, __27] =>
              [(Script_typed_ir.ty __26) ** (Script_typed_ir.ty __27)]) _
            [tva, tvb] in
        Pervasives.op_pipegt
          (Error_monad.op_gtgtquestion (ty_eq ctxt tva tvb)
            (fun function_parameter =>
              let '(Eq, ctxt) := function_parameter in
              ok Eq ctxt 1)) (record_inconsistent ctxt ta tb)
      | (_, _) =>
        Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt ta)
          (fun function_parameter =>
            let '(ta, ctxt) := function_parameter in
            Error_monad.op_gtgtquestion (serialize_ty_for_error ctxt tb)
              (fun function_parameter =>
                let '(tb, _ctxt) := function_parameter in
                Error_monad.__error_value extensible_type_value))
      end).

Fixpoint stack_ty_eq {ta tb : Set}
  (ctxt : Alpha_context.context) (lvl : Z) (ta : Script_typed_ir.stack_ty ta)
  (tb : Script_typed_ir.stack_ty tb) {struct ctxt}
  : Error_monad.tzresult
    (eq (Script_typed_ir.stack_ty ta) (Script_typed_ir.stack_ty tb) *
      Alpha_context.context) :=
  match (ta, tb) with
  | (Script_typed_ir.Item_t tva ra _, Script_typed_ir.Item_t tvb rb _) =>
    let 'existT _ [__0, __1, __2, __3] [tva, ra, tvb, rb] :=
      existT
        (fun '[__0, __1, __2, __3] =>
          [(Script_typed_ir.ty __0) ** (Script_typed_ir.stack_ty __1) **
            (Script_typed_ir.ty __2) ** (Script_typed_ir.stack_ty __3)]) _
        [tva, ra, tvb, rb] in
    Error_monad.op_gtgtquestion
      (Pervasives.op_pipegt (ty_eq ctxt tva tvb)
        (Error_monad.record_trace extensible_type_value))
      (fun function_parameter =>
        let '(Eq, ctxt) := function_parameter in
        Error_monad.op_gtgtquestion
          (stack_ty_eq ctxt (Pervasives.op_plus lvl 1) ra rb)
          (fun function_parameter =>
            let '(Eq, ctxt) := function_parameter in
            Pervasives.Ok (Eq, ctxt)))
  | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =>
    Pervasives.Ok (Eq, ctxt)
  | (_, _) => Error_monad.__error_value extensible_type_value
  end.

Definition merge_comparable_types {ta : Set}
  (legacy : bool) (ta : Script_typed_ir.comparable_ty ta)
  (tb : Script_typed_ir.comparable_ty ta)
  : Error_monad.tzresult (Script_typed_ir.comparable_ty ta) :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key annot_a, Script_typed_ir.Int_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Int_key annot)
  | (Script_typed_ir.Nat_key annot_a, Script_typed_ir.Nat_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Nat_key annot)
  | (Script_typed_ir.String_key annot_a, Script_typed_ir.String_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.String_key annot)
  | (Script_typed_ir.Bytes_key annot_a, Script_typed_ir.Bytes_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Bytes_key annot)
  | (Script_typed_ir.Mutez_key annot_a, Script_typed_ir.Mutez_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Mutez_key annot)
  | (Script_typed_ir.Bool_key annot_a, Script_typed_ir.Bool_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Bool_key annot)
  | (Script_typed_ir.Key_hash_key annot_a, Script_typed_ir.Key_hash_key annot_b)
    =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Key_hash_key annot)
  |
    (Script_typed_ir.Timestamp_key annot_a,
      Script_typed_ir.Timestamp_key annot_b) =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Timestamp_key annot)
  | (Script_typed_ir.Address_key annot_a, Script_typed_ir.Address_key annot_b)
    =>
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot => Script_typed_ir.Address_key annot)
  | (_, _) =>
    (*  Assert instruction is not handled. *)
    assert false
  end.

Definition merge_types {b : Set} (legacy : bool)
  : Alpha_context.context -> Alpha_context.Script.location ->
  Script_typed_ir.ty b -> Script_typed_ir.ty b ->
  Error_monad.tzresult (Script_typed_ir.ty b * Alpha_context.context) :=
  let fix help {a : Set}
    (ctxt : Alpha_context.context) (ty1 : Script_typed_ir.ty a)
    (ty2 : Script_typed_ir.ty a) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.ty a * Alpha_context.context) :=
    match (ty1, ty2) with
    | (Script_typed_ir.Unit_t tn1, Script_typed_ir.Unit_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Unit_t tname), ctxt))
    | (Script_typed_ir.Int_t tn1, Script_typed_ir.Int_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Int_t tname), ctxt))
    | (Script_typed_ir.Nat_t tn1, Script_typed_ir.Nat_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Nat_t tname), ctxt))
    | (Script_typed_ir.Key_t tn1, Script_typed_ir.Key_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Key_t tname), ctxt))
    | (Script_typed_ir.Key_hash_t tn1, Script_typed_ir.Key_hash_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Key_hash_t tname), ctxt))
    | (Script_typed_ir.String_t tn1, Script_typed_ir.String_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.String_t tname), ctxt))
    | (Script_typed_ir.Bytes_t tn1, Script_typed_ir.Bytes_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Bytes_t tname), ctxt))
    | (Script_typed_ir.Signature_t tn1, Script_typed_ir.Signature_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Signature_t tname), ctxt))
    | (Script_typed_ir.Mutez_t tn1, Script_typed_ir.Mutez_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Mutez_t tname), ctxt))
    | (Script_typed_ir.Timestamp_t tn1, Script_typed_ir.Timestamp_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Timestamp_t tname), ctxt))
    | (Script_typed_ir.Address_t tn1, Script_typed_ir.Address_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Address_t tname), ctxt))
    | (Script_typed_ir.Bool_t tn1, Script_typed_ir.Bool_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Bool_t tname), ctxt))
    | (Script_typed_ir.Chain_id_t tn1, Script_typed_ir.Chain_id_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Chain_id_t tname), ctxt))
    | (Script_typed_ir.Operation_t tn1, Script_typed_ir.Operation_t tn2) =>
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname => ((Script_typed_ir.Operation_t tname), ctxt))
    |
      (Script_typed_ir.Map_t tal tar tn1 has_big_map,
        Script_typed_ir.Map_t tbl tbr tn2 _) =>
      let 'existT _ [__0, __1] [tal, tar, tn1, has_big_map, tbl, tbr, tn2] :=
        existT
          (fun '[__0, __1] =>
            [(Script_typed_ir.comparable_ty __0) ** (Script_typed_ir.ty __1) **
              (option Script_typed_ir.type_annot) ** bool **
              (Script_typed_ir.comparable_ty __0) ** (Script_typed_ir.ty __1) **
              (option Script_typed_ir.type_annot)]) _
          [tal, tar, tn1, has_big_map, tbl, tbr, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtgtquestion (help ctxt tar tbr)
            (fun function_parameter =>
              let '(value, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar value)
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  Error_monad.op_gtpipequestion
                    (merge_comparable_types legacy tal tbl)
                    (fun tk =>
                      ((Script_typed_ir.Map_t tk value tname has_big_map), ctxt)))))
    |
      (Script_typed_ir.Big_map_t tal tar tn1,
        Script_typed_ir.Big_map_t tbl tbr tn2) =>
      let 'existT _ [__2, __3] [tal, tar, tn1, tbl, tbr, tn2] :=
        existT
          (fun '[__2, __3] =>
            [(Script_typed_ir.comparable_ty __2) ** (Script_typed_ir.ty __3) **
              (option Script_typed_ir.type_annot) **
              (Script_typed_ir.comparable_ty __2) ** (Script_typed_ir.ty __3) **
              (option Script_typed_ir.type_annot)]) _
          [tal, tar, tn1, tbl, tbr, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtgtquestion (help ctxt tar tbr)
            (fun function_parameter =>
              let '(value, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (ty_eq ctxt tar value)
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  Error_monad.op_gtpipequestion
                    (merge_comparable_types legacy tal tbl)
                    (fun tk =>
                      ((Script_typed_ir.Big_map_t tk value tname), ctxt)))))
    | (Script_typed_ir.Set_t ea tn1, Script_typed_ir.Set_t eb tn2) =>
      let 'existT _ __4 [ea, tn1, eb, tn2] :=
        existT
          (fun __4 : Set =>
            [(Script_typed_ir.comparable_ty __4) **
              (option Script_typed_ir.type_annot) **
              (Script_typed_ir.comparable_ty __4) **
              (option Script_typed_ir.type_annot)]) _ [ea, tn1, eb, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtpipequestion (merge_comparable_types legacy ea eb)
            (fun e => ((Script_typed_ir.Set_t e tname), ctxt)))
    |
      (Script_typed_ir.Pair_t (tal, l_field1, l_var1) (tar, r_field1, r_var1)
        tn1 has_big_map,
        Script_typed_ir.Pair_t (tbl, l_field2, l_var2) (tbr, r_field2, r_var2)
          tn2 _) =>
      let 'existT _ [__5, __6]
        [tal, l_field1, l_var1, tar, r_field1, r_var1, tn1, has_big_map, tbl,
          l_field2, l_var2, tbr, r_field2, r_var2, tn2] :=
        existT
          (fun '[__5, __6] =>
            [(Script_typed_ir.ty __5) ** (option Script_typed_ir.field_annot) **
              (option Script_typed_ir.var_annot) ** (Script_typed_ir.ty __6) **
              (option Script_typed_ir.field_annot) **
              (option Script_typed_ir.var_annot) **
              (option Script_typed_ir.type_annot) ** bool **
              (Script_typed_ir.ty __5) ** (option Script_typed_ir.field_annot)
              ** (option Script_typed_ir.var_annot) ** (Script_typed_ir.ty __6)
              ** (option Script_typed_ir.field_annot) **
              (option Script_typed_ir.var_annot) **
              (option Script_typed_ir.type_annot)]) _
          [tal, l_field1, l_var1, tar, r_field1, r_var1, tn1, has_big_map, tbl,
            l_field2, l_var2, tbr, r_field2, r_var2, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtgtquestion
            (Script_ir_annot.merge_field_annot legacy l_field1 l_field2)
            (fun l_field =>
              Error_monad.op_gtgtquestion
                (Script_ir_annot.merge_field_annot legacy r_field1 r_field2)
                (fun r_field =>
                  let l_var := Script_ir_annot.merge_var_annot l_var1 l_var2 in
                  let r_var := Script_ir_annot.merge_var_annot r_var1 r_var2 in
                  Error_monad.op_gtgtquestion (help ctxt tal tbl)
                    (fun function_parameter =>
                      let '(left_ty, ctxt) := function_parameter in
                      Error_monad.op_gtpipequestion (help ctxt tar tbr)
                        (fun function_parameter =>
                          let '(right_ty, ctxt) := function_parameter in
                          ((Script_typed_ir.Pair_t (left_ty, l_field, l_var)
                            (right_ty, r_field, r_var) tname has_big_map), ctxt))))))
    |
      (Script_typed_ir.Union_t (tal, tal_annot) (tar, tar_annot) tn1 has_big_map,
        Script_typed_ir.Union_t (tbl, tbl_annot) (tbr, tbr_annot) tn2 _) =>
      let 'existT _ [__7, __8]
        [tal, tal_annot, tar, tar_annot, tn1, has_big_map, tbl, tbl_annot, tbr,
          tbr_annot, tn2] :=
        existT
          (fun '[__7, __8] =>
            [(Script_typed_ir.ty __7) ** (option Script_typed_ir.field_annot) **
              (Script_typed_ir.ty __8) ** (option Script_typed_ir.field_annot)
              ** (option Script_typed_ir.type_annot) ** bool **
              (Script_typed_ir.ty __7) ** (option Script_typed_ir.field_annot)
              ** (Script_typed_ir.ty __8) **
              (option Script_typed_ir.field_annot) **
              (option Script_typed_ir.type_annot)]) _
          [tal, tal_annot, tar, tar_annot, tn1, has_big_map, tbl, tbl_annot,
            tbr, tbr_annot, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtgtquestion
            (Script_ir_annot.merge_field_annot legacy tal_annot tbl_annot)
            (fun left_annot =>
              Error_monad.op_gtgtquestion
                (Script_ir_annot.merge_field_annot legacy tar_annot tbr_annot)
                (fun right_annot =>
                  Error_monad.op_gtgtquestion (help ctxt tal tbl)
                    (fun function_parameter =>
                      let '(left_ty, ctxt) := function_parameter in
                      Error_monad.op_gtpipequestion (help ctxt tar tbr)
                        (fun function_parameter =>
                          let '(right_ty, ctxt) := function_parameter in
                          ((Script_typed_ir.Union_t (left_ty, left_annot)
                            (right_ty, right_annot) tname has_big_map), ctxt))))))
    |
      (Script_typed_ir.Lambda_t tal tar tn1,
        Script_typed_ir.Lambda_t tbl tbr tn2) =>
      let 'existT _ [__10, __9] [tal, tar, tn1, tbl, tbr, tn2] :=
        existT
          (fun '[__10, __9] =>
            [(Script_typed_ir.ty __9) ** (Script_typed_ir.ty __10) **
              (option Script_typed_ir.type_annot) ** (Script_typed_ir.ty __9) **
              (Script_typed_ir.ty __10) ** (option Script_typed_ir.type_annot)])
          _ [tal, tar, tn1, tbl, tbr, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtgtquestion (help ctxt tal tbl)
            (fun function_parameter =>
              let '(left_ty, ctxt) := function_parameter in
              Error_monad.op_gtpipequestion (help ctxt tar tbr)
                (fun function_parameter =>
                  let '(right_ty, ctxt) := function_parameter in
                  ((Script_typed_ir.Lambda_t left_ty right_ty tname), ctxt))))
    | (Script_typed_ir.Contract_t tal tn1, Script_typed_ir.Contract_t tbl tn2)
      =>
      let 'existT _ __11 [tal, tn1, tbl, tn2] :=
        existT
          (fun __11 : Set =>
            [(Script_typed_ir.ty __11) ** (option Script_typed_ir.type_annot) **
              (Script_typed_ir.ty __11) ** (option Script_typed_ir.type_annot)])
          _ [tal, tn1, tbl, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtpipequestion (help ctxt tal tbl)
            (fun function_parameter =>
              let '(arg_ty, ctxt) := function_parameter in
              ((Script_typed_ir.Contract_t arg_ty tname), ctxt)))
    |
      (Script_typed_ir.Option_t tva tn1 has_big_map,
        Script_typed_ir.Option_t tvb tn2 _) =>
      let 'existT _ __12 [tva, tn1, has_big_map, tvb, tn2] :=
        existT
          (fun __12 : Set =>
            [(Script_typed_ir.ty __12) ** (option Script_typed_ir.type_annot) **
              bool ** (Script_typed_ir.ty __12) **
              (option Script_typed_ir.type_annot)]) _
          [tva, tn1, has_big_map, tvb, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtpipequestion (help ctxt tva tvb)
            (fun function_parameter =>
              let '(ty, ctxt) := function_parameter in
              ((Script_typed_ir.Option_t ty tname has_big_map), ctxt)))
    |
      (Script_typed_ir.List_t tva tn1 has_big_map,
        Script_typed_ir.List_t tvb tn2 _) =>
      let 'existT _ __13 [tva, tn1, has_big_map, tvb, tn2] :=
        existT
          (fun __13 : Set =>
            [(Script_typed_ir.ty __13) ** (option Script_typed_ir.type_annot) **
              bool ** (Script_typed_ir.ty __13) **
              (option Script_typed_ir.type_annot)]) _
          [tva, tn1, has_big_map, tvb, tn2] in
      Error_monad.op_gtgtquestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =>
          Error_monad.op_gtpipequestion (help ctxt tva tvb)
            (fun function_parameter =>
              let '(ty, ctxt) := function_parameter in
              ((Script_typed_ir.List_t ty tname has_big_map), ctxt)))
    | (_, _) =>
      (*  Assert instruction is not handled. *)
      assert false
    end in
  fun ctxt =>
    fun loc =>
      fun ty1 =>
        fun ty2 =>
          record_inconsistent_type_annotations ctxt loc ty1 ty2
            (help ctxt ty1 ty2).

Definition merge_stacks {ta : Set}
  (legacy : bool) (loc : Alpha_context.Script.location)
  : Alpha_context.context -> Script_typed_ir.stack_ty ta ->
  Script_typed_ir.stack_ty ta ->
  Error_monad.tzresult (Script_typed_ir.stack_ty ta * Alpha_context.context) :=
  let fix help {a : Set}
    (ctxt : Alpha_context.context) (stack1 : Script_typed_ir.stack_ty a)
    (stack2 : Script_typed_ir.stack_ty a) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.stack_ty a * Alpha_context.context) :=
    match (stack1, stack2) with
    | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =>
      Error_monad.ok (Script_typed_ir.Empty_t, ctxt)
    |
      (Script_typed_ir.Item_t ty1 rest1 annot1,
        Script_typed_ir.Item_t ty2 rest2 annot2) =>
      let 'existT _ [__0, __1] [ty1, rest1, annot1, ty2, rest2, annot2] :=
        existT
          (fun '[__0, __1] =>
            [(Script_typed_ir.ty __0) ** (Script_typed_ir.stack_ty __1) **
              (option Script_typed_ir.var_annot) ** (Script_typed_ir.ty __0) **
              (Script_typed_ir.stack_ty __1) **
              (option Script_typed_ir.var_annot)]) _
          [ty1, rest1, annot1, ty2, rest2, annot2] in
      let annot := Script_ir_annot.merge_var_annot annot1 annot2 in
      Error_monad.op_gtgtquestion (merge_types legacy ctxt loc ty1 ty2)
        (fun function_parameter =>
          let '(ty, ctxt) := function_parameter in
          Error_monad.op_gtpipequestion (help ctxt rest1 rest2)
            (fun function_parameter =>
              let '(rest, ctxt) := function_parameter in
              ((Script_typed_ir.Item_t ty rest annot), ctxt)))
    end in
  help.

Definition has_big_map {t : Set} (function_parameter : Script_typed_ir.ty t)
  : bool :=
  match function_parameter with
  | Script_typed_ir.Unit_t _ => false
  | Script_typed_ir.Int_t _ => false
  | Script_typed_ir.Nat_t _ => false
  | Script_typed_ir.Signature_t _ => false
  | Script_typed_ir.String_t _ => false
  | Script_typed_ir.Bytes_t _ => false
  | Script_typed_ir.Mutez_t _ => false
  | Script_typed_ir.Key_hash_t _ => false
  | Script_typed_ir.Key_t _ => false
  | Script_typed_ir.Timestamp_t _ => false
  | Script_typed_ir.Address_t _ => false
  | Script_typed_ir.Bool_t _ => false
  | Script_typed_ir.Lambda_t _ _ _ => false
  | Script_typed_ir.Set_t _ _ => false
  | Script_typed_ir.Big_map_t _ _ _ => true
  | Script_typed_ir.Contract_t _ _ => false
  | Script_typed_ir.Operation_t _ => false
  | Script_typed_ir.Chain_id_t _ => false
  | Script_typed_ir.Pair_t _ _ _ has_big_map => has_big_map
  | Script_typed_ir.Union_t _ _ _ has_big_map => has_big_map
  | Script_typed_ir.Option_t _ _ has_big_map => has_big_map
  | Script_typed_ir.List_t _ _ has_big_map => has_big_map
  | Script_typed_ir.Map_t _ _ _ has_big_map => has_big_map
  end.

Module judgement.
  Module Failed.
    Record record {descr : Set} := {
      descr : descr }.
    Arguments record : clear implicits.
  End Failed.
  Definition Failed_skeleton := Failed.record.
End judgement.

Reserved Notation "'judgement.Failed".

Inductive judgement (bef : Set) : Set :=
| Typed : forall {aft : Set}, Script_typed_ir.descr bef aft -> judgement bef
| Failed : forall {aft : Set}, 'judgement.Failed aft bef -> judgement bef

where "'judgement.Failed" := (fun (t_aft t_bef : Set) =>
  judgement.Failed_skeleton
    ((Script_typed_ir.stack_ty t_aft -> Script_typed_ir.descr t_bef t_aft) *
      t_aft)).

Module ConstructorRecordNotations_judgement.
  Module judgement.
    Definition Failed := 'judgement.Failed.
  End judgement.
End ConstructorRecordNotations_judgement.
Import ConstructorRecordNotations_judgement.

Arguments Typed {_ _}.
Arguments Failed {_ _}.

Module branch.
  Record record {t f b : Set} := Build {
    branch :
      (Script_typed_ir.descr t r -> Script_typed_ir.descr f r ->
      Script_typed_ir.descr b r) * r }.
  Arguments record : clear implicits.
  Definition with_branch {t_t t_f t_b} branch (r : record t_t t_f t_b) :=
    Build t_t t_f t_b branch.
End branch.
Definition branch := branch.record.

Definition merge_branches {a b bef : Set}
  (legacy : bool) (ctxt : Alpha_context.context) (loc : Z) (btr : judgement a)
  (bfr : judgement b) (function_parameter : branch a b bef)
  : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
  let '{| branch.branch := branch |} := function_parameter in
  match (btr, bfr) with
  |
    (Typed ({| Script_typed_ir.descr.aft := aftbt |} as dbt),
      Typed ({| Script_typed_ir.descr.aft := aftbf |} as dbf)) =>
    let 'existT _ [__Typed_'aft, __Typed_'aft1] [aftbt, dbt, aftbf, dbf] :=
      existT
        (fun '[__Typed_'aft, __Typed_'aft1] =>
          [(Script_typed_ir.stack_ty __Typed_'aft) **
            (Script_typed_ir.descr a __Typed_'aft) **
            (Script_typed_ir.stack_ty __Typed_'aft1) **
            (Script_typed_ir.descr b __Typed_'aft1)]) _ [aftbt, dbt, aftbf, dbf]
      in
    let unmatched_branches (function_parameter : unit)
      : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
      let '_ := function_parameter in
      Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt aftbt)
        (fun function_parameter =>
          let '(aftbt, ctxt) := function_parameter in
          Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt aftbf)
            (fun function_parameter =>
              let '(aftbf, _ctxt) := function_parameter in
              extensible_type_value)) in
    Error_monad.trace_eval unmatched_branches
      (Error_monad.op_gtgteqquestion
        (Lwt.__return (stack_ty_eq ctxt 1 aftbt aftbf))
        (fun function_parameter =>
          let '(Eq, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Lwt.__return (merge_stacks legacy loc ctxt aftbt aftbf))
            (fun function_parameter =>
              let '(merged_stack, ctxt) := function_parameter in
              Error_monad.__return
                ((Typed
                  (branch (Script_typed_ir.descr.with_aft merged_stack dbt)
                    (Script_typed_ir.descr.with_aft merged_stack dbf))), ctxt))))
  |
    (Failed {| judgement.Failed.descr := descrt |},
      Failed {| judgement.Failed.descr := descrf |}) =>
    let __descr_value {D : Set} (ret : Script_typed_ir.stack_ty D)
      : Script_typed_ir.descr bef D :=
      branch (descrt ret) (descrf ret) in
    Error_monad.__return
      ((Failed {| judgement.Failed.descr := __descr_value |}), ctxt)
  | (Typed dbt, Failed {| judgement.Failed.descr := descrf |}) =>
    let 'existT _ __Typed_'aft2 [dbt, descrf] :=
      existT
        (fun __Typed_'aft2 : Set =>
          [(Script_typed_ir.descr a __Typed_'aft2) **
            (Script_typed_ir.stack_ty D -> Script_typed_ir.descr b D)]) _
        [dbt, descrf] in
    Error_monad.__return
      ((Typed (branch dbt (descrf dbt.(Script_typed_ir.descr.aft)))), ctxt)
  | (Failed {| judgement.Failed.descr := descrt |}, Typed dbf) =>
    let 'existT _ __Typed_'aft3 [descrt, dbf] :=
      existT
        (fun __Typed_'aft3 : Set =>
          [(Script_typed_ir.stack_ty D -> Script_typed_ir.descr a D) **
            (Script_typed_ir.descr b __Typed_'aft3)]) _ [descrt, dbf] in
    Error_monad.__return
      ((Typed (branch (descrt dbf.(Script_typed_ir.descr.aft)) dbf)), ctxt)
  end.

Fixpoint parse_comparable_ty
  (ctxt : Alpha_context.context) (ty : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_comparable_ty * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =>
      Error_monad.op_gtgtquestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
        (fun ctxt =>
          match ty with
          | Micheline.Prim loc Alpha_context.Script.T_int [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Int_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_nat [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Nat_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_string [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.String_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_bytes [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Bytes_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_mutez [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Mutez_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_bool [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Bool_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Key_hash_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Timestamp_key tname)), ctxt))
          | Micheline.Prim loc Alpha_context.Script.T_address [] annot =>
            Error_monad.op_gtpipequestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun tname =>
                ((Ex_comparable_ty (Script_typed_ir.Address_key tname)), ctxt))
          |
            Micheline.Prim loc
              ((Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
              Alpha_context.Script.T_string | Alpha_context.Script.T_mutez |
              Alpha_context.Script.T_bool | Alpha_context.Script.T_key |
              Alpha_context.Script.T_address | Alpha_context.Script.T_timestamp)
                as prim) l _ => Error_monad.__error_value extensible_type_value
          |
            Micheline.Prim loc
              (Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
              Alpha_context.Script.T_set | Alpha_context.Script.T_map |
              Alpha_context.Script.T_list | Alpha_context.Script.T_option |
              Alpha_context.Script.T_lambda | Alpha_context.Script.T_unit |
              Alpha_context.Script.T_signature | Alpha_context.Script.T_contract)
              _ _ => Error_monad.__error_value extensible_type_value
          | expr =>
            Pervasives.op_atat Error_monad.__error_value
              (unexpected expr nil Script_tc_errors.Type_namespace
                [
                  Alpha_context.Script.T_int;
                  Alpha_context.Script.T_nat;
                  Alpha_context.Script.T_string;
                  Alpha_context.Script.T_mutez;
                  Alpha_context.Script.T_bool;
                  Alpha_context.Script.T_key;
                  Alpha_context.Script.T_key_hash;
                  Alpha_context.Script.T_timestamp
                ])
          end))

with parse_packable_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node ->
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy false false legacy

with parse_parameter_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node ->
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true false true

with parse_any_ty (ctxt : Alpha_context.context) (legacy : bool) {struct ctxt}
  : Alpha_context.Script.node ->
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true true true

with parse_ty
  (ctxt : Alpha_context.context) (legacy : bool) (allow_big_map : bool)
  (allow_operation : bool) (allow_contract : bool)
  (node : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =>
      match
        (node,
          match node with
          | Micheline.Prim loc Alpha_context.Script.T_big_map args annot =>
            allow_big_map
          | _ => false
          end) with
      | (Micheline.Prim loc Alpha_context.Script.T_unit [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Unit_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_int [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Int_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_nat [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Nat_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_string [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.String_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_bytes [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Bytes_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_mutez [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Mutez_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_bool [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Bool_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_key [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Key_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Key_hash_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Timestamp_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_address [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Address_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_signature [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Signature_t ty_name)), ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_operation [] annot, _) =>
        if allow_operation then
          Error_monad.op_gtgtquestion
            (Script_ir_annot.parse_type_annot loc annot)
            (fun ty_name =>
              Error_monad.op_gtpipequestion
                (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
                (fun ctxt =>
                  ((Ex_ty (Script_typed_ir.Operation_t ty_name)), ctxt)))
        else
          Error_monad.__error_value extensible_type_value
      | (Micheline.Prim loc Alpha_context.Script.T_chain_id [] annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.parse_type_annot loc annot)
          (fun ty_name =>
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
              (fun ctxt => ((Ex_ty (Script_typed_ir.Chain_id_t ty_name)), ctxt)))
      |
        (Micheline.Prim loc Alpha_context.Script.T_contract (cons utl []) annot,
          _) =>
        if allow_contract then
          Error_monad.op_gtgtquestion (parse_parameter_ty ctxt legacy utl)
            (fun function_parameter =>
              let '(Ex_ty tl, ctxt) := function_parameter in
              let 'existT _ __Ex_ty_'a [tl, ctxt] :=
                existT
                  (fun __Ex_ty_'a : Set =>
                    [(Script_typed_ir.ty __Ex_ty_'a) ** Alpha_context.context])
                  _ [tl, ctxt] in
              Error_monad.op_gtgtquestion
                (Script_ir_annot.parse_type_annot loc annot)
                (fun ty_name =>
                  Error_monad.op_gtpipequestion
                    (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
                    (fun ctxt =>
                      ((Ex_ty (Script_typed_ir.Contract_t tl ty_name)), ctxt))))
        else
          Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc Alpha_context.Script.T_pair (cons utl (cons utr []))
          annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.extract_field_annot utl)
          (fun function_parameter =>
            let '(utl, left_field) := function_parameter in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.extract_field_annot utr)
              (fun function_parameter =>
                let '(utr, right_field) := function_parameter in
                Error_monad.op_gtgtquestion
                  (parse_ty ctxt legacy allow_big_map allow_operation
                    allow_contract utl)
                  (fun function_parameter =>
                    let '(Ex_ty tl, ctxt) := function_parameter in
                    let 'existT _ __Ex_ty_'a1 [tl, ctxt] :=
                      existT
                        (fun __Ex_ty_'a1 : Set =>
                          [(Script_typed_ir.ty __Ex_ty_'a1) **
                            Alpha_context.context]) _ [tl, ctxt] in
                    Error_monad.op_gtgtquestion
                      (parse_ty ctxt legacy allow_big_map allow_operation
                        allow_contract utr)
                      (fun function_parameter =>
                        let '(Ex_ty tr, ctxt) := function_parameter in
                        let 'existT _ __Ex_ty_'a2 [tr, ctxt] :=
                          existT
                            (fun __Ex_ty_'a2 : Set =>
                              [(Script_typed_ir.ty __Ex_ty_'a2) **
                                Alpha_context.context]) _ [tr, ctxt] in
                        Error_monad.op_gtgtquestion
                          (Script_ir_annot.parse_type_annot loc annot)
                          (fun ty_name =>
                            Error_monad.op_gtpipequestion
                              (Alpha_context.Gas.consume ctxt
                                (Typecheck_costs.type_ 2))
                              (fun ctxt =>
                                ((Ex_ty
                                  (Script_typed_ir.Pair_t (tl, left_field, None)
                                    (tr, right_field, None) ty_name
                                    (Pervasives.op_pipepipe (has_big_map tl)
                                      (has_big_map tr)))), ctxt)))))))
      |
        (Micheline.Prim loc Alpha_context.Script.T_or (cons utl (cons utr []))
          annot, _) =>
        Error_monad.op_gtgtquestion (Script_ir_annot.extract_field_annot utl)
          (fun function_parameter =>
            let '(utl, left_constr) := function_parameter in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.extract_field_annot utr)
              (fun function_parameter =>
                let '(utr, right_constr) := function_parameter in
                Error_monad.op_gtgtquestion
                  (parse_ty ctxt legacy allow_big_map allow_operation
                    allow_contract utl)
                  (fun function_parameter =>
                    let '(Ex_ty tl, ctxt) := function_parameter in
                    let 'existT _ __Ex_ty_'a3 [tl, ctxt] :=
                      existT
                        (fun __Ex_ty_'a3 : Set =>
                          [(Script_typed_ir.ty __Ex_ty_'a3) **
                            Alpha_context.context]) _ [tl, ctxt] in
                    Error_monad.op_gtgtquestion
                      (parse_ty ctxt legacy allow_big_map allow_operation
                        allow_contract utr)
                      (fun function_parameter =>
                        let '(Ex_ty tr, ctxt) := function_parameter in
                        let 'existT _ __Ex_ty_'a4 [tr, ctxt] :=
                          existT
                            (fun __Ex_ty_'a4 : Set =>
                              [(Script_typed_ir.ty __Ex_ty_'a4) **
                                Alpha_context.context]) _ [tr, ctxt] in
                        Error_monad.op_gtgtquestion
                          (Script_ir_annot.parse_type_annot loc annot)
                          (fun ty_name =>
                            Error_monad.op_gtpipequestion
                              (Alpha_context.Gas.consume ctxt
                                (Typecheck_costs.type_ 2))
                              (fun ctxt =>
                                ((Ex_ty
                                  (Script_typed_ir.Union_t (tl, left_constr)
                                    (tr, right_constr) ty_name
                                    (Pervasives.op_pipepipe (has_big_map tl)
                                      (has_big_map tr)))), ctxt)))))))
      |
        (Micheline.Prim loc Alpha_context.Script.T_lambda
          (cons uta (cons utr [])) annot, _) =>
        Error_monad.op_gtgtquestion (parse_any_ty ctxt legacy uta)
          (fun function_parameter =>
            let '(Ex_ty ta, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a5 [ta, ctxt] :=
              existT
                (fun __Ex_ty_'a5 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a5) ** Alpha_context.context]) _
                [ta, ctxt] in
            Error_monad.op_gtgtquestion (parse_any_ty ctxt legacy utr)
              (fun function_parameter =>
                let '(Ex_ty tr, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a6 [tr, ctxt] :=
                  existT
                    (fun __Ex_ty_'a6 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a6) **
                        Alpha_context.context]) _ [tr, ctxt] in
                Error_monad.op_gtgtquestion
                  (Script_ir_annot.parse_type_annot loc annot)
                  (fun ty_name =>
                    Error_monad.op_gtpipequestion
                      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
                      (fun ctxt =>
                        ((Ex_ty (Script_typed_ir.Lambda_t ta tr ty_name)), ctxt)))))
      | (Micheline.Prim loc Alpha_context.Script.T_option (cons ut []) annot, _)
        =>
        Error_monad.op_gtgtquestion
          (if legacy then
            Error_monad.op_gtgtquestion (Script_ir_annot.extract_field_annot ut)
              (fun function_parameter =>
                let '(ut, _some_constr) := function_parameter in
                Error_monad.op_gtgtquestion
                  (Script_ir_annot.parse_composed_type_annot loc annot)
                  (fun function_parameter =>
                    let '(ty_name, _none_constr, _) := function_parameter in
                    Error_monad.ok (ut, ty_name)))
          else
            Error_monad.op_gtgtquestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun ty_name => Error_monad.ok (ut, ty_name)))
          (fun function_parameter =>
            let '(ut, ty_name) := function_parameter in
            Error_monad.op_gtgtquestion
              (parse_ty ctxt legacy allow_big_map allow_operation allow_contract
                ut)
              (fun function_parameter =>
                let '(Ex_ty __t_value, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a7 [__t_value, ctxt] :=
                  existT
                    (fun __Ex_ty_'a7 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a7) **
                        Alpha_context.context]) _ [__t_value, ctxt] in
                Error_monad.op_gtpipequestion
                  (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
                  (fun ctxt =>
                    ((Ex_ty
                      (Script_typed_ir.Option_t __t_value ty_name
                        (has_big_map __t_value))), ctxt))))
      | (Micheline.Prim loc Alpha_context.Script.T_list (cons ut []) annot, _)
        =>
        Error_monad.op_gtgtquestion
          (parse_ty ctxt legacy allow_big_map allow_operation allow_contract ut)
          (fun function_parameter =>
            let '(Ex_ty __t_value, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a8 [__t_value, ctxt] :=
              existT
                (fun __Ex_ty_'a8 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a8) ** Alpha_context.context]) _
                [__t_value, ctxt] in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun ty_name =>
                Error_monad.op_gtpipequestion
                  (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
                  (fun ctxt =>
                    ((Ex_ty
                      (Script_typed_ir.List_t __t_value ty_name
                        (has_big_map __t_value))), ctxt))))
      | (Micheline.Prim loc Alpha_context.Script.T_set (cons ut []) annot, _) =>
        Error_monad.op_gtgtquestion (parse_comparable_ty ctxt ut)
          (fun function_parameter =>
            let '(Ex_comparable_ty __t_value, ctxt) := function_parameter in
            let 'existT _ __Ex_comparable_ty_'a [__t_value, ctxt] :=
              existT
                (fun __Ex_comparable_ty_'a : Set =>
                  [(Script_typed_ir.comparable_ty __Ex_comparable_ty_'a) **
                    Alpha_context.context]) _ [__t_value, ctxt] in
            Error_monad.op_gtgtquestion
              (Script_ir_annot.parse_type_annot loc annot)
              (fun ty_name =>
                Error_monad.op_gtpipequestion
                  (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
                  (fun ctxt =>
                    ((Ex_ty (Script_typed_ir.Set_t __t_value ty_name)), ctxt))))
      |
        (Micheline.Prim loc Alpha_context.Script.T_map (cons uta (cons utr []))
          annot, _) =>
        Error_monad.op_gtgtquestion (parse_comparable_ty ctxt uta)
          (fun function_parameter =>
            let '(Ex_comparable_ty ta, ctxt) := function_parameter in
            let 'existT _ __Ex_comparable_ty_'a1 [ta, ctxt] :=
              existT
                (fun __Ex_comparable_ty_'a1 : Set =>
                  [(Script_typed_ir.comparable_ty __Ex_comparable_ty_'a1) **
                    Alpha_context.context]) _ [ta, ctxt] in
            Error_monad.op_gtgtquestion
              (parse_ty ctxt legacy allow_big_map allow_operation allow_contract
                utr)
              (fun function_parameter =>
                let '(Ex_ty tr, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a9 [tr, ctxt] :=
                  existT
                    (fun __Ex_ty_'a9 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a9) **
                        Alpha_context.context]) _ [tr, ctxt] in
                Error_monad.op_gtgtquestion
                  (Script_ir_annot.parse_type_annot loc annot)
                  (fun ty_name =>
                    Error_monad.op_gtpipequestion
                      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
                      (fun ctxt =>
                        ((Ex_ty
                          (Script_typed_ir.Map_t ta tr ty_name (has_big_map tr))),
                          ctxt)))))
      | (Micheline.Prim loc Alpha_context.Script.T_big_map args annot, true) =>
        Error_monad.op_gtgtquestion
          (parse_big_map_ty ctxt legacy loc args annot)
          (fun function_parameter =>
            let '(big_map_ty, ctxt) := function_parameter in
            Error_monad.op_gtpipequestion
              (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
              (fun ctxt => (big_map_ty, ctxt)))
      | (Micheline.Prim loc Alpha_context.Script.T_big_map _ _, _) =>
        Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc
          ((Alpha_context.Script.T_unit | Alpha_context.Script.T_signature |
          Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
          Alpha_context.Script.T_string | Alpha_context.Script.T_bytes |
          Alpha_context.Script.T_mutez | Alpha_context.Script.T_bool |
          Alpha_context.Script.T_key | Alpha_context.Script.T_key_hash |
          Alpha_context.Script.T_timestamp | Alpha_context.Script.T_address) as
            prim) l _, _) => Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc
          ((Alpha_context.Script.T_set | Alpha_context.Script.T_list |
          Alpha_context.Script.T_option | Alpha_context.Script.T_contract) as
            prim) l _, _) => Error_monad.__error_value extensible_type_value
      |
        (Micheline.Prim loc
          ((Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
          Alpha_context.Script.T_map | Alpha_context.Script.T_lambda) as prim) l
          _, _) => Error_monad.__error_value extensible_type_value
      | (expr, _) =>
        Pervasives.op_atat Error_monad.__error_value
          (unexpected expr nil Script_tc_errors.Type_namespace
            [
              Alpha_context.Script.T_pair;
              Alpha_context.Script.T_or;
              Alpha_context.Script.T_set;
              Alpha_context.Script.T_map;
              Alpha_context.Script.T_list;
              Alpha_context.Script.T_option;
              Alpha_context.Script.T_lambda;
              Alpha_context.Script.T_unit;
              Alpha_context.Script.T_signature;
              Alpha_context.Script.T_contract;
              Alpha_context.Script.T_int;
              Alpha_context.Script.T_nat;
              Alpha_context.Script.T_operation;
              Alpha_context.Script.T_string;
              Alpha_context.Script.T_bytes;
              Alpha_context.Script.T_mutez;
              Alpha_context.Script.T_bool;
              Alpha_context.Script.T_key;
              Alpha_context.Script.T_key_hash;
              Alpha_context.Script.T_timestamp;
              Alpha_context.Script.T_chain_id
            ])
      end)

with parse_big_map_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (big_map_loc : Alpha_context.Script.location)
  (args :
    list
      (Micheline.node Alpha_context.Script.location Alpha_context.Script.prim))
  (map_annot : Micheline.annot) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  Error_monad.op_gtgtquestion
    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
    (fun ctxt =>
      match args with
      | cons key_ty (cons value_ty []) =>
        Error_monad.op_gtgtquestion (parse_comparable_ty ctxt key_ty)
          (fun function_parameter =>
            let '(Ex_comparable_ty key_ty, ctxt) := function_parameter in
            let 'existT _ __Ex_comparable_ty_'a2 [key_ty, ctxt] :=
              existT
                (fun __Ex_comparable_ty_'a2 : Set =>
                  [(Script_typed_ir.comparable_ty __Ex_comparable_ty_'a2) **
                    Alpha_context.context]) _ [key_ty, ctxt] in
            Error_monad.op_gtgtquestion (parse_packable_ty ctxt legacy value_ty)
              (fun function_parameter =>
                let '(Ex_ty value_ty, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a10 [value_ty, ctxt] :=
                  existT
                    (fun __Ex_ty_'a10 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a10) **
                        Alpha_context.context]) _ [value_ty, ctxt] in
                Error_monad.op_gtpipequestion
                  (Script_ir_annot.parse_type_annot big_map_loc map_annot)
                  (fun map_name =>
                    let big_map_ty :=
                      Script_typed_ir.Big_map_t key_ty value_ty map_name in
                    ((Ex_ty big_map_ty), ctxt))))
      | args =>
        Pervasives.op_atat Error_monad.__error_value extensible_type_value
      end)

with parse_storage_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (node : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  match
    (node,
      match node with
      |
        Micheline.Prim loc Alpha_context.Script.T_pair
          (cons
            (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
              map_annot) (cons remaining_storage [])) storage_annot => legacy
      | _ => false
      end) with
  |
    (Micheline.Prim loc Alpha_context.Script.T_pair
      (cons
        (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
          map_annot) (cons remaining_storage [])) storage_annot, true) =>
    match
      (storage_annot,
        match storage_annot with
        | cons single [] =>
          Pervasives.op_andand
            ((|Compare.Int|).(Compare.S.op_gt) (String.length single) 0)
            ((|Compare.Char|).(Compare.S.op_eq) (String.get single 0) "%" % char)
        | _ => false
        end) with
    | ([], _) => parse_ty ctxt legacy true false legacy node
    | (cons single [], true) => parse_ty ctxt legacy true false legacy node
    | (_, _) =>
      Error_monad.op_gtgtquestion
        (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
        (fun ctxt =>
          Error_monad.op_gtgtquestion
            (parse_big_map_ty ctxt legacy big_map_loc args map_annot)
            (fun function_parameter =>
              let '(Ex_ty big_map_ty, ctxt) := function_parameter in
              let 'existT _ __Ex_ty_'a11 [big_map_ty, ctxt] :=
                existT
                  (fun __Ex_ty_'a11 : Set =>
                    [(Script_typed_ir.ty __Ex_ty_'a11) ** Alpha_context.context])
                  _ [big_map_ty, ctxt] in
              Error_monad.op_gtgtquestion
                (parse_ty ctxt legacy true false legacy remaining_storage)
                (fun function_parameter =>
                  let '(Ex_ty remaining_storage, ctxt) := function_parameter in
                  let 'existT _ __Ex_ty_'a12 [remaining_storage, ctxt] :=
                    existT
                      (fun __Ex_ty_'a12 : Set =>
                        [(Script_typed_ir.ty __Ex_ty_'a12) **
                          Alpha_context.context]) _ [remaining_storage, ctxt] in
                  Error_monad.op_gtgtquestion
                    (Script_ir_annot.parse_composed_type_annot loc storage_annot)
                    (fun function_parameter =>
                      let '(ty_name, map_field, storage_field) :=
                        function_parameter in
                      Error_monad.op_gtpipequestion
                        (Alpha_context.Gas.consume ctxt
                          (Typecheck_costs.type_ 5))
                        (fun ctxt =>
                          ((Ex_ty
                            (Script_typed_ir.Pair_t
                              (big_map_ty, map_field, None)
                              (remaining_storage, storage_field, None) ty_name
                              true)), ctxt))))))
    end
  | (_, _) => parse_ty ctxt legacy true false legacy node
  end.

Definition check_packable {A : Set}
  (legacy : bool) (loc : Alpha_context.Script.location)
  (root : Script_typed_ir.ty A) : Error_monad.tzresult unit :=
  let fix check {t : Set} (function_parameter : Script_typed_ir.ty t)
    {struct function_parameter} : Error_monad.tzresult unit :=
    match
      (function_parameter,
        match function_parameter with
        | Script_typed_ir.Contract_t _ _ => legacy
        | _ => false
        end) with
    | (Script_typed_ir.Big_map_t _ _ _, _) =>
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Operation_t _, _) =>
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Unit_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Int_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Nat_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Signature_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.String_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Bytes_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Mutez_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Key_hash_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Key_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Timestamp_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Address_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Bool_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Chain_id_t _, _) => Error_monad.ok tt
    | (Script_typed_ir.Pair_t (l_ty, _, _) (r_ty, _, _) _ _, _) =>
      let 'existT _ [__2, __3] [l_ty, r_ty] :=
        existT
          (fun '[__2, __3] =>
            [(Script_typed_ir.ty __2) ** (Script_typed_ir.ty __3)]) _
          [l_ty, r_ty] in
      Error_monad.op_gtgtquestion (check l_ty)
        (fun function_parameter =>
          let '_ := function_parameter in
          check r_ty)
    | (Script_typed_ir.Union_t (l_ty, _) (r_ty, _) _ _, _) =>
      let 'existT _ [__4, __5] [l_ty, r_ty] :=
        existT
          (fun '[__4, __5] =>
            [(Script_typed_ir.ty __4) ** (Script_typed_ir.ty __5)]) _
          [l_ty, r_ty] in
      Error_monad.op_gtgtquestion (check l_ty)
        (fun function_parameter =>
          let '_ := function_parameter in
          check r_ty)
    | (Script_typed_ir.Option_t v_ty _ _, _) =>
      let 'existT _ __6 v_ty :=
        existT (fun __6 : Set => (Script_typed_ir.ty __6)) _ v_ty in
      check v_ty
    | (Script_typed_ir.List_t elt_ty _ _, _) =>
      let 'existT _ __7 elt_ty :=
        existT (fun __7 : Set => (Script_typed_ir.ty __7)) _ elt_ty in
      check elt_ty
    | (Script_typed_ir.Set_t _ _, _) => Error_monad.ok tt
    | (Script_typed_ir.Map_t _ elt_ty _ _, _) =>
      let 'existT _ __10 elt_ty :=
        existT (fun __10 : Set => (Script_typed_ir.ty __10)) _ elt_ty in
      check elt_ty
    | (Script_typed_ir.Lambda_t _l_ty _r_ty _, _) =>
      let 'existT _ [__11, __12] [_l_ty, _r_ty] :=
        existT
          (fun '[__11, __12] =>
            [(Script_typed_ir.ty __11) ** (Script_typed_ir.ty __12)]) _
          [_l_ty, _r_ty] in
      Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, true) => Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, _) =>
      Error_monad.__error_value extensible_type_value
    end in
  check root.

Inductive ex_script : Set :=
| Ex_script : forall {a c : Set}, Script_typed_ir.script a c -> ex_script.

Inductive dig_proof_argument (bef : Set) : Set :=
| Dig_proof_argument : forall {aft rest x : Set},
  Script_typed_ir.stack_prefix_preservation_witness (x * rest) rest bef aft *
    (Script_typed_ir.ty x * option Script_typed_ir.var_annot) *
    Script_typed_ir.stack_ty aft -> dig_proof_argument bef.

Arguments Dig_proof_argument {_ _ _ _}.

Inductive dug_proof_argument (bef x : Set) : Set :=
| Dug_proof_argument : forall {aft rest : Set},
  Script_typed_ir.stack_prefix_preservation_witness rest (x * rest) bef aft *
    unit * Script_typed_ir.stack_ty aft -> dug_proof_argument bef x.

Arguments Dug_proof_argument {_ _ _ _}.

Inductive dipn_proof_argument (bef : Set) : Set :=
| Dipn_proof_argument : forall {aft faft fbef : Set},
  Script_typed_ir.stack_prefix_preservation_witness fbef faft bef aft *
    (Alpha_context.context * Script_typed_ir.descr fbef faft) *
    Script_typed_ir.stack_ty aft -> dipn_proof_argument bef.

Arguments Dipn_proof_argument {_ _ _ _}.

Inductive dropn_proof_argument (bef : Set) : Set :=
| Dropn_proof_argument : forall {aft rest : Set},
  Script_typed_ir.stack_prefix_preservation_witness rest rest bef aft *
    Script_typed_ir.stack_ty rest * Script_typed_ir.stack_ty aft ->
  dropn_proof_argument bef.

Arguments Dropn_proof_argument {_ _ _}.

Definition parse_var_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t (Error_monad.tzresult (option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_annot loc default annot).

Definition parse_entrypoint_annot
  (loc : Z) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return (Script_ir_annot.parse_entrypoint_annot loc default annot).

Definition parse_constr_annot
  (loc : Z) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
        option Script_typed_ir.field_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_constr_annot loc if_special_first if_special_second
      annot).

Definition parse_two_var_annot (loc : Z) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_two_var_annot loc annot).

Definition parse_destr_annot
  (loc : Z) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_destr_annot loc annot default_accessor field_name
      pair_annot value_annot).

Definition parse_var_type_annot (loc : Z) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_type_annot loc annot).

Definition find_entrypoint {A : Set}
  (full : Script_typed_ir.ty A)
  (root_name : option (|Compare.String|).(Compare.S.t))
  (entrypoint : (|Compare.String|).(Compare.S.t))
  : Error_monad.tzresult
    ((Alpha_context.Script.node -> Alpha_context.Script.node) * ex_ty) :=
  let fix find_entrypoint {t : Set}
    (__t_value : Script_typed_ir.ty t) (entrypoint : string) {struct __t_value}
    : (Alpha_context.Script.node -> Alpha_context.Script.node) * ex_ty :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =>
      let 'existT _ [__0, __1] [tl, al, tr, ar] :=
        existT
          (fun '[__0, __1] =>
            [(Script_typed_ir.ty __0) ** (option Script_typed_ir.field_annot) **
              (Script_typed_ir.ty __1) ** (option Script_typed_ir.field_annot)])
          _ [tl, al, tr, ar] in
      if
        match al with
        | None => false
        | Some (Field_annot l) =>
          (|Compare.String|).(Compare.S.op_eq) l entrypoint
        end then
        ((fun e => Micheline.Prim 0 Alpha_context.Script.D_Left [ e ] nil),
          (Ex_ty tl))
      else
        if
          match ar with
          | None => false
          | Some (Field_annot r) =>
            (|Compare.String|).(Compare.S.op_eq) r entrypoint
          end then
          ((fun e => Micheline.Prim 0 Alpha_context.Script.D_Right [ e ] nil),
            (Ex_ty tr))
        else
          (*  Try-with are not handled *)
          try
            (let '(f, __t_value) := find_entrypoint tl entrypoint in
            ((fun e => Micheline.Prim 0 Alpha_context.Script.D_Left [ f e ] nil),
              __t_value))
    | _ => Pervasives.raise extensible_type_value
    end in
  let entrypoint :=
    if (|Compare.String|).(Compare.S.op_eq) entrypoint "" then
      "default"
    else
      entrypoint in
  if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31 then
    Error_monad.__error_value extensible_type_value
  else
    match
      (root_name,
        match root_name with
        | Some root_name =>
          (|Compare.String|).(Compare.S.op_eq) entrypoint root_name
        | _ => false
        end) with
    | (Some root_name, true) => Error_monad.ok ((fun e => e), (Ex_ty full))
    | (_, _) =>
      (*  Try-with are not handled *)
      try (Error_monad.ok (find_entrypoint full entrypoint))
    end.

Definition find_entrypoint_for_type {A B : Set}
  (full : Script_typed_ir.ty A) (expected : Script_typed_ir.ty B)
  (root_name : option (|Compare.String|).(Compare.S.t))
  (entrypoint : (|Compare.String|).(Compare.S.t)) (ctxt : Alpha_context.context)
  : Error_monad.tzresult (Alpha_context.context * string * Script_typed_ir.ty B) :=
  match (entrypoint, root_name) with
  | ("default", Some "root") =>
    match find_entrypoint full root_name entrypoint with
    | (Pervasives.Error _) as err => err
    | Pervasives.Ok (_, Ex_ty ty) =>
      let 'existT _ __Ex_ty_'a ty :=
        existT (fun __Ex_ty_'a : Set => (Script_typed_ir.ty __Ex_ty_'a)) _ ty in
      match ty_eq ctxt expected ty with
      | Pervasives.Ok (Eq, ctxt) => Error_monad.ok (ctxt, "default", ty)
      | Pervasives.Error _ =>
        Error_monad.op_gtgtquestion (ty_eq ctxt expected full)
          (fun function_parameter =>
            let '(Eq, ctxt) := function_parameter in
            Error_monad.ok (ctxt, "root", full))
      end
    end
  | _ =>
    Error_monad.op_gtgtquestion (find_entrypoint full root_name entrypoint)
      (fun function_parameter =>
        let '(_, Ex_ty ty) := function_parameter in
        let 'existT _ __Ex_ty_'a1 ty :=
          existT (fun __Ex_ty_'a1 : Set => (Script_typed_ir.ty __Ex_ty_'a1)) _
            ty in
        Error_monad.op_gtgtquestion (ty_eq ctxt expected ty)
          (fun function_parameter =>
            let '(Eq, ctxt) := function_parameter in
            Error_monad.ok (ctxt, entrypoint, ty)))
  end.

Definition Entrypoints :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := String.compare
      |}).

(*  The definition of exceptions is not handled. *)
(* exception Duplicate *)

(*  The definition of exceptions is not handled. *)
(* exception Too_long *)

Definition well_formed_entrypoints {A : Set}
  (full : Script_typed_ir.ty A) (root_name : option (|Entrypoints|).(S.SET.elt))
  : Error_monad.tzresult unit :=
  let merge {B C : Set}
    (path : list B)
    (annot : option (* `Field_annot *) (|Entrypoints|).(S.SET.elt))
    (ty : Script_typed_ir.ty C) (reachable : bool)
    (function_parameter : option (list B) * (|Entrypoints|).(S.SET.t))
    : option (list B) * (|Entrypoints|).(S.SET.t) :=
    let '(first_unreachable, all) as acc := function_parameter in
    match annot with
    | None | Some (Field_annot "") =>
      if reachable then
        acc
      else
        match ty with
        | Script_typed_ir.Union_t _ _ _ _ => acc
        | _ =>
          match first_unreachable with
          | None => ((Some (List.rev path)), all)
          | Some _ => acc
          end
        end
    | Some (Field_annot name) =>
      if (|Compare.Int|).(Compare.S.op_gt) (String.length name) 31 then
        Pervasives.raise extensible_type_value
      else
        if (|Entrypoints|).(S.SET.mem) name all then
          Pervasives.raise extensible_type_value
        else
          (first_unreachable, ((|Entrypoints|).(S.SET.add) name all))
    end in
  let fix check {t : Set}
    (__t_value : Script_typed_ir.ty t) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc : option (list Alpha_context.Script.prim) * (|Entrypoints|).(S.SET.t))
    {struct __t_value}
    : option (list Alpha_context.Script.prim) * (|Entrypoints|).(S.SET.t) :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =>
      let 'existT _ [__2, __3] [tl, al, tr, ar] :=
        existT
          (fun '[__2, __3] =>
            [(Script_typed_ir.ty __2) ** (option Script_typed_ir.field_annot) **
              (Script_typed_ir.ty __3) ** (option Script_typed_ir.field_annot)])
          _ [tl, al, tr, ar] in
      let acc :=
        merge (cons Alpha_context.Script.D_Left path) al tl reachable acc in
      let acc :=
        merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc in
      let acc :=
        check tl (cons Alpha_context.Script.D_Left path)
          match al with
          | Some _ => true
          | None => reachable
          end acc in
      check tr (cons Alpha_context.Script.D_Right path)
        match ar with
        | Some _ => true
        | None => reachable
        end acc
    | _ => acc
    end in
  (*  Try-with are not handled *)
  try
    (let '(init, reachable) :=
      match root_name with
      | None | Some "" => ((|Entrypoints|).(S.SET.empty), false)
      | Some name => (((|Entrypoints|).(S.SET.singleton) name), true)
      end in
    let '(first_unreachable, all) := check full nil reachable (None, init) in
    if Pervasives.not ((|Entrypoints|).(S.SET.mem) "default" all) then
      Error_monad.ok tt
    else
      match first_unreachable with
      | None => Error_monad.ok tt
      | Some path => Error_monad.__error_value extensible_type_value
      end).

Fixpoint parse_data {a : Set}
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (ty : Script_typed_ir.ty a)
  (script_data : Alpha_context.Script.node) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
    (fun ctxt =>
      let __error_value (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (Lwt.__return (serialize_ty_for_error ctxt ty))
          (fun function_parameter =>
            let '(ty, _ctxt) := function_parameter in
            extensible_type_value) in
      let traced {B : Set} (body : Lwt.t (Error_monad.tzresult B))
        : Lwt.t (Error_monad.tzresult B) :=
        Error_monad.trace_eval __error_value body in
      let parse_items {B C D E : Set}
        (type_logger : option type_logger) (loc : Alpha_context.Script.location)
        (ctxt : Alpha_context.context)
        (expr : Micheline.node B Alpha_context.Script.prim)
        (key_type : Script_typed_ir.comparable_ty C)
        (value_type : Script_typed_ir.ty D)
        (items :
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)) (item_wrapper : D -> E)
        : Lwt.t
          (Error_monad.tzresult
            (Script_typed_ir.map C E * Alpha_context.context)) :=
        let length := List.length items in
        Error_monad.op_gtgtpipequestion
          (Pervasives.op_pipegt
            (Error_monad.fold_left_s
              (fun function_parameter =>
                let '(last_value, map, ctxt) := function_parameter in
                fun item =>
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Typecheck_costs.map_element length)))
                    (fun ctxt =>
                      match item with
                      |
                        Micheline.Prim _ Alpha_context.Script.D_Elt
                          (cons k (cons v [])) _ =>
                        Error_monad.op_gtgteqquestion
                          (parse_comparable_data type_logger ctxt key_type k)
                          (fun function_parameter =>
                            let '(k, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (parse_data type_logger ctxt legacy value_type v)
                              (fun function_parameter =>
                                let '(v, ctxt) := function_parameter in
                                Error_monad.op_gtgteqquestion
                                  match last_value with
                                  | Some value =>
                                    if
                                      (|Compare.Int|).(Compare.S.op_lteq) 0
                                        (compare_comparable key_type value k)
                                      then
                                      if
                                        (|Compare.Int|).(Compare.S.op_eq) 0
                                          (compare_comparable key_type value k)
                                        then
                                        Error_monad.fail extensible_type_value
                                      else
                                        Error_monad.fail extensible_type_value
                                    else
                                      Error_monad.return_unit
                                  | None => Error_monad.return_unit
                                  end
                                  (fun function_parameter =>
                                    let '_ := function_parameter in
                                    Error_monad.__return
                                      ((Some k),
                                        (map_update k (Some (item_wrapper v))
                                          map), ctxt))))
                      | Micheline.Prim loc Alpha_context.Script.D_Elt l _ =>
                        Pervasives.op_atat Error_monad.fail
                          extensible_type_value
                      | Micheline.Prim loc name _ _ =>
                        Pervasives.op_atat Error_monad.fail
                          extensible_type_value
                      |
                        Micheline.Int _ _ | Micheline.String _ _ |
                        Micheline.Bytes _ _ | Micheline.Seq _ _ =>
                        Error_monad.op_gtgteqquestion (__error_value tt)
                          Error_monad.fail
                      end)) (None, (empty_map key_type), ctxt) items) traced)
          (fun function_parameter =>
            let '(_, items, ctxt) := function_parameter in
            (items, ctxt)) in
      match (ty, script_data) with
      |
        (Script_typed_ir.Unit_t _,
          Micheline.Prim loc Alpha_context.Script.D_Unit [] annot) =>
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.__unit_value))
              (fun ctxt => (tt, ctxt)))
      |
        (Script_typed_ir.Unit_t _,
          Micheline.Prim loc Alpha_context.Script.D_Unit l _) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Unit_t _, expr) =>
        traced
          (Error_monad.fail
            (unexpected expr nil Script_tc_errors.Constant_namespace
              [ Alpha_context.Script.D_Unit ]))
      |
        (Script_typed_ir.Bool_t _,
          Micheline.Prim loc Alpha_context.Script.D_True [] annot) =>
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
              (fun ctxt => (true, ctxt)))
      |
        (Script_typed_ir.Bool_t _,
          Micheline.Prim loc Alpha_context.Script.D_False [] annot) =>
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
              (fun ctxt => (false, ctxt)))
      |
        (Script_typed_ir.Bool_t _,
          Micheline.Prim loc
            ((Alpha_context.Script.D_True | Alpha_context.Script.D_False) as c)
            l _) => traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Bool_t _, expr) =>
        traced
          (Error_monad.fail
            (unexpected expr nil Script_tc_errors.Constant_namespace
              [ Alpha_context.Script.D_True; Alpha_context.Script.D_False ]))
      | (Script_typed_ir.String_t _, Micheline.String _ v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Typecheck_costs.__string_value (String.length v))))
          (fun ctxt =>
            let fix check_printable_ascii (i : (|Compare.Int|).(Compare.S.t))
              {struct i} : bool :=
              if (|Compare.Int|).(Compare.S.op_lt) i 0 then
                true
              else
                match String.get v i with
                |
                  "010" % char | " " % char | "!" % char | """" % char |
                  "#" % char | "$" % char | "%" % char | "&" % char | "'" % char
                  | "(" % char | ")" % char | "*" % char | "+" % char |
                  "," % char | "-" % char | "." % char | "/" % char | "0" % char
                  | "1" % char | "2" % char | "3" % char | "4" % char |
                  "5" % char | "6" % char | "7" % char | "8" % char | "9" % char
                  | ":" % char | ";" % char | "<" % char | "=" % char |
                  ">" % char | "?" % char | "@" % char | "A" % char | "B" % char
                  | "C" % char | "D" % char | "E" % char | "F" % char |
                  "G" % char | "H" % char | "I" % char | "J" % char | "K" % char
                  | "L" % char | "M" % char | "N" % char | "O" % char |
                  "P" % char | "Q" % char | "R" % char | "S" % char | "T" % char
                  | "U" % char | "V" % char | "W" % char | "X" % char |
                  "Y" % char | "Z" % char | "[" % char | "\" % char | "]" % char
                  | "^" % char | "_" % char | "`" % char | "a" % char |
                  "b" % char | "c" % char | "d" % char | "e" % char | "f" % char
                  | "g" % char | "h" % char | "i" % char | "j" % char |
                  "k" % char | "l" % char | "m" % char | "n" % char | "o" % char
                  | "p" % char | "q" % char | "r" % char | "s" % char |
                  "t" % char | "u" % char | "v" % char | "w" % char | "x" % char
                  | "y" % char | "z" % char | "{" % char | "|" % char |
                  "}" % char | "~" % char =>
                  check_printable_ascii (Pervasives.op_minus i 1)
                | _ => false
                end in
            if check_printable_ascii (Pervasives.op_minus (String.length v) 1)
              then
              Error_monad.__return (v, ctxt)
            else
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail)
      | (Script_typed_ir.String_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Bytes_t _, Micheline.Bytes _ v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Typecheck_costs.__string_value (MBytes.length v))))
          (fun ctxt => Error_monad.__return (v, ctxt))
      | (Script_typed_ir.Bytes_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Int_t _, Micheline.Int _ v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)))
          (fun ctxt =>
            Error_monad.__return ((Alpha_context.Script_int.of_zint v), ctxt))
      | (Script_typed_ir.Nat_t _, Micheline.Int _ v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)))
          (fun ctxt =>
            let v := Alpha_context.Script_int.of_zint v in
            if
              (|Compare.Int|).(Compare.S.op_gteq)
                (Alpha_context.Script_int.compare v
                  Alpha_context.Script_int.zero) 0 then
              Error_monad.__return ((Alpha_context.Script_int.abs v), ctxt)
            else
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail)
      | (Script_typed_ir.Int_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Nat_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Mutez_t _, Micheline.Int _ v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Error_monad.op_gtgtquestion
              (Alpha_context.Gas.consume ctxt Typecheck_costs.tez)
              (fun ctxt =>
                Alpha_context.Gas.consume ctxt
                  Michelson_v1_gas.Cost_of.Legacy.z_to_int64)))
          (fun ctxt =>
            (*  Try-with are not handled *)
            try
              match Alpha_context.Tez.of_mutez (Z.to_int64 v) with
              | None => Pervasives.raise extensible_type_value
              | Some tez => Error_monad.__return (tez, ctxt)
              end)
      | (Script_typed_ir.Mutez_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Timestamp_t _, Micheline.Int _ v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)))
          (fun ctxt =>
            Error_monad.__return
              ((Alpha_context.Script_timestamp.of_zint v), ctxt))
      | (Script_typed_ir.Timestamp_t _, Micheline.String _ s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.string_timestamp))
          (fun ctxt =>
            match Alpha_context.Script_timestamp.of_string s with
            | Some v => Error_monad.__return (v, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Timestamp_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Key_t _, Micheline.Bytes _ __bytes_value) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key))
          (fun ctxt =>
            match
              Data_encoding.Binary.of_bytes
                (|Signature.Public_key|).(S.SPublic_key.encoding) __bytes_value
              with
            | Some k => Error_monad.__return (k, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_t _, Micheline.String _ s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key))
          (fun ctxt =>
            match (|Signature.Public_key|).(S.SPublic_key.of_b58check_opt) s
              with
            | Some k => Error_monad.__return (k, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Key_hash_t _, Micheline.Bytes _ __bytes_value) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash))
          (fun ctxt =>
            match
              Data_encoding.Binary.of_bytes
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
                __bytes_value with
            | Some k => Error_monad.__return (k, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_hash_t _, Micheline.String _ s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash))
          (fun ctxt =>
            match
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_b58check_opt)
                s with
            | Some k => Error_monad.__return (k, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Key_hash_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Signature_t _, Micheline.Bytes _ __bytes_value) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.signature))
          (fun ctxt =>
            match Data_encoding.Binary.of_bytes Signature.encoding __bytes_value
              with
            | Some k => Error_monad.__return (k, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Signature_t _, Micheline.String _ s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.signature))
          (fun ctxt =>
            match Signature.of_b58check_opt s with
            | Some s => Error_monad.__return (s, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Signature_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Operation_t _, _) =>
        (*  Assert instruction is not handled. *)
        assert false
      | (Script_typed_ir.Chain_id_t _, Micheline.Bytes _ __bytes_value) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id))
          (fun ctxt =>
            match
              Data_encoding.Binary.of_bytes (|Chain_id|).(S.HASH.encoding)
                __bytes_value with
            | Some k => Error_monad.__return (k, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Chain_id_t _, Micheline.String _ s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id))
          (fun ctxt =>
            match (|Chain_id|).(S.HASH.of_b58check_opt) s with
            | Some s => Error_monad.__return (s, ctxt)
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Chain_id_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Address_t _, Micheline.Bytes loc __bytes_value) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =>
            match
              Data_encoding.Binary.of_bytes
                (Data_encoding.tup2 Alpha_context.Contract.encoding
                  Data_encoding.__Variable.__string_value) __bytes_value with
            | Some (c, entrypoint) =>
              if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31
                then
                Error_monad.fail extensible_type_value
              else
                Error_monad.op_gtgteqquestion
                  match entrypoint with
                  | "" => Error_monad.__return "default"
                  | "default" => Error_monad.fail extensible_type_value
                  | name => Error_monad.__return name
                  end
                  (fun entrypoint =>
                    Error_monad.__return ((c, entrypoint), ctxt))
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Address_t _, Micheline.String loc s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =>
            Error_monad.op_gtgteqquestion
              match String.index_opt s "%" % char with
              | None => Error_monad.__return (s, "default")
              | Some pos =>
                let len :=
                  Pervasives.op_minus
                    (Pervasives.op_minus (String.length s) pos) 1 in
                let name := String.sub s (Pervasives.op_plus pos 1) len in
                if (|Compare.Int|).(Compare.S.op_gt) len 31 then
                  Error_monad.fail extensible_type_value
                else
                  match ((String.sub s 0 pos), name) with
                  | (_, "default") =>
                    traced (Error_monad.fail extensible_type_value)
                  | addr_and_name => Error_monad.__return addr_and_name
                  end
              end
              (fun function_parameter =>
                let '(addr, entrypoint) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return (Alpha_context.Contract.of_b58check addr))
                  (fun c => Error_monad.__return ((c, entrypoint), ctxt))))
      | (Script_typed_ir.Address_t _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Contract_t ty _, Micheline.Bytes loc __bytes_value) =>
        let 'existT _ __0 [ty, loc, __bytes_value] :=
          existT
            (fun __0 : Set =>
              [(Script_typed_ir.ty __0) ** Alpha_context.Script.location **
                MBytes.t]) _ [ty, loc, __bytes_value] in
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =>
            match
              Data_encoding.Binary.of_bytes
                (Data_encoding.tup2 Alpha_context.Contract.encoding
                  Data_encoding.__Variable.__string_value) __bytes_value with
            | Some (c, entrypoint) =>
              if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31
                then
                Error_monad.fail extensible_type_value
              else
                Error_monad.op_gtgteqquestion
                  match entrypoint with
                  | "" => Error_monad.__return "default"
                  | "default" => traced (Error_monad.fail extensible_type_value)
                  | name => Error_monad.__return name
                  end
                  (fun entrypoint =>
                    Error_monad.op_gtgteqquestion
                      (traced (parse_contract legacy ctxt loc ty c entrypoint))
                      (fun function_parameter =>
                        let '(ctxt, _) := function_parameter in
                        Error_monad.__return ((ty, (c, entrypoint)), ctxt)))
            | None =>
              Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
            end)
      | (Script_typed_ir.Contract_t ty _, Micheline.String loc s) =>
        let 'existT _ __1 [ty, loc, s] :=
          existT
            (fun __1 : Set =>
              [(Script_typed_ir.ty __1) ** Alpha_context.Script.location **
                string]) _ [ty, loc, s] in
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Typecheck_costs.contract))
          (fun ctxt =>
            Error_monad.op_gtgteqquestion
              match String.index_opt s "%" % char with
              | None => Error_monad.__return (s, "default")
              | Some pos =>
                let len :=
                  Pervasives.op_minus
                    (Pervasives.op_minus (String.length s) pos) 1 in
                let name := String.sub s (Pervasives.op_plus pos 1) len in
                if (|Compare.Int|).(Compare.S.op_gt) len 31 then
                  Error_monad.fail extensible_type_value
                else
                  match ((String.sub s 0 pos), name) with
                  | (_, "default") =>
                    traced (Error_monad.fail extensible_type_value)
                  | addr_and_name => Error_monad.__return addr_and_name
                  end
              end
              (fun function_parameter =>
                let '(addr, entrypoint) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (traced
                    (Lwt.__return (Alpha_context.Contract.of_b58check addr)))
                  (fun c =>
                    Error_monad.op_gtgteqquestion
                      (parse_contract legacy ctxt loc ty c entrypoint)
                      (fun function_parameter =>
                        let '(ctxt, _) := function_parameter in
                        Error_monad.__return ((ty, (c, entrypoint)), ctxt)))))
      | (Script_typed_ir.Contract_t _ _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      |
        (Script_typed_ir.Pair_t (ta, _, _) (tb, _, _) _ _,
          Micheline.Prim loc Alpha_context.Script.D_Pair (cons va (cons vb []))
            annot) =>
        let 'existT _ [__3, __4] [ta, tb, loc, va, vb, annot] :=
          existT
            (fun '[__3, __4] =>
              [(Script_typed_ir.ty __3) ** (Script_typed_ir.ty __4) **
                Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot]) _
            [ta, tb, loc, va, vb, annot] in
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.pair))
              (fun ctxt =>
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy ta va))
                  (fun function_parameter =>
                    let '(va, ctxt) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (parse_data type_logger ctxt legacy tb vb)
                      (fun function_parameter =>
                        let '(vb, ctxt) := function_parameter in
                        Error_monad.__return ((va, vb), ctxt)))))
      |
        (Script_typed_ir.Pair_t _ _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Pair l _) =>
        Pervasives.op_atat Error_monad.fail extensible_type_value
      | (Script_typed_ir.Pair_t _ _ _ _, expr) =>
        traced
          (Error_monad.fail
            (unexpected expr nil Script_tc_errors.Constant_namespace
              [ Alpha_context.Script.D_Pair ]))
      |
        (Script_typed_ir.Union_t (tl, _) _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Left (cons v []) annot) =>
        let 'existT _ __9 [tl, loc, v, annot] :=
          existT
            (fun __9 : Set =>
              [(Script_typed_ir.ty __9) ** Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot]) _
            [tl, loc, v, annot] in
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.union))
              (fun ctxt =>
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy tl v))
                  (fun function_parameter =>
                    let '(v, ctxt) := function_parameter in
                    Error_monad.__return ((Script_typed_ir.L v), ctxt))))
      |
        (Script_typed_ir.Union_t _ _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Left l _) =>
        Pervasives.op_atat Error_monad.fail extensible_type_value
      |
        (Script_typed_ir.Union_t _ (tr, _) _ _,
          Micheline.Prim loc Alpha_context.Script.D_Right (cons v []) annot) =>
        let 'existT _ __14 [tr, loc, v, annot] :=
          existT
            (fun __14 : Set =>
              [(Script_typed_ir.ty __14) ** Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot]) _
            [tr, loc, v, annot] in
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.union))
              (fun ctxt =>
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy tr v))
                  (fun function_parameter =>
                    let '(v, ctxt) := function_parameter in
                    Error_monad.__return ((Script_typed_ir.R v), ctxt))))
      |
        (Script_typed_ir.Union_t _ _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Right l _) =>
        Pervasives.op_atat Error_monad.fail extensible_type_value
      | (Script_typed_ir.Union_t _ _ _ _, expr) =>
        traced
          (Error_monad.fail
            (unexpected expr nil Script_tc_errors.Constant_namespace
              [ Alpha_context.Script.D_Left; Alpha_context.Script.D_Right ]))
      |
        (Script_typed_ir.Lambda_t ta tr _ty_name,
          (Micheline.Seq _loc _) as script_instr) =>
        let 'existT _ [__19, __20] [ta, tr, _ty_name, _loc, script_instr] :=
          existT
            (fun '[__19, __20] =>
              [(Script_typed_ir.ty __19) ** (Script_typed_ir.ty __20) **
                (option Script_typed_ir.type_annot) **
                Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim)]) _
            [ta, tr, _ty_name, _loc, script_instr] in
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.lambda))
          (fun ctxt =>
            Pervasives.op_atat traced
              (parse_returning type_logger Lambda ctxt legacy
                (ta, (Some (Var_annot "@arg"))) tr script_instr))
      | (Script_typed_ir.Lambda_t _ _ _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      |
        (Script_typed_ir.Option_t __t_value _ _,
          Micheline.Prim loc Alpha_context.Script.D_Some (cons v []) annot) =>
        let 'existT _ __23 [__t_value, loc, v, annot] :=
          existT
            (fun __23 : Set =>
              [(Script_typed_ir.ty __23) ** Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot]) _
            [__t_value, loc, v, annot] in
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.some))
              (fun ctxt =>
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat traced
                    (parse_data type_logger ctxt legacy __t_value v))
                  (fun function_parameter =>
                    let '(v, ctxt) := function_parameter in
                    Error_monad.__return ((Some v), ctxt))))
      |
        (Script_typed_ir.Option_t _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_Some l _) =>
        Pervasives.op_atat Error_monad.fail extensible_type_value
      |
        (Script_typed_ir.Option_t _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_None [] annot) =>
        Error_monad.op_gtgteqquestion
          (if legacy then
            Error_monad.__return tt
          else
            Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.none))
              (fun ctxt => Error_monad.__return (None, ctxt)))
      |
        (Script_typed_ir.Option_t _ _ _,
          Micheline.Prim loc Alpha_context.Script.D_None l _) =>
        Pervasives.op_atat Error_monad.fail extensible_type_value
      | (Script_typed_ir.Option_t _ _ _, expr) =>
        traced
          (Error_monad.fail
            (unexpected expr nil Script_tc_errors.Constant_namespace
              [ Alpha_context.Script.D_Some; Alpha_context.Script.D_None ]))
      | (Script_typed_ir.List_t __t_value _ty_name _, Micheline.Seq _loc items)
        =>
        let 'existT _ __28 [__t_value, _ty_name, _loc, items] :=
          existT
            (fun __28 : Set =>
              [(Script_typed_ir.ty __28) ** (option Script_typed_ir.type_annot)
                ** Alpha_context.Script.location **
                (list
                  (Micheline.node Alpha_context.Script.location
                    Alpha_context.Script.prim))]) _
            [__t_value, _ty_name, _loc, items] in
        Pervasives.op_atat traced
          (Error_monad.fold_right_s
            (fun v =>
              fun function_parameter =>
                let '(rest, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Typecheck_costs.list_element))
                  (fun ctxt =>
                    Error_monad.op_gtgteqquestion
                      (parse_data type_logger ctxt legacy __t_value v)
                      (fun function_parameter =>
                        let '(v, ctxt) := function_parameter in
                        Error_monad.__return ((cons v rest), ctxt)))) items
            (nil, ctxt))
      | (Script_typed_ir.List_t _ _ _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      |
        (Script_typed_ir.Set_t __t_value _ty_name,
          (Micheline.Seq loc vs) as expr) =>
        let 'existT _ __30 [__t_value, _ty_name, loc, vs, expr] :=
          existT
            (fun __30 : Set =>
              [(Script_typed_ir.comparable_ty __30) **
                (option Script_typed_ir.type_annot) **
                Alpha_context.Script.location **
                (list
                  (Micheline.node Alpha_context.Script.location
                    Alpha_context.Script.prim)) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim)]) _
            [__t_value, _ty_name, loc, vs, expr] in
        let length := List.length vs in
        Error_monad.op_gtgtpipequestion
          (Pervasives.op_atat traced
            (Error_monad.fold_left_s
              (fun function_parameter =>
                let '(last_value, set, ctxt) := function_parameter in
                fun v =>
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Typecheck_costs.set_element length)))
                    (fun ctxt =>
                      Error_monad.op_gtgteqquestion
                        (parse_comparable_data type_logger ctxt __t_value v)
                        (fun function_parameter =>
                          let '(v, ctxt) := function_parameter in
                          Error_monad.op_gtgteqquestion
                            match last_value with
                            | Some value =>
                              if
                                (|Compare.Int|).(Compare.S.op_lteq) 0
                                  (compare_comparable __t_value value v) then
                                if
                                  (|Compare.Int|).(Compare.S.op_eq) 0
                                    (compare_comparable __t_value value v) then
                                  Error_monad.fail extensible_type_value
                                else
                                  Error_monad.fail extensible_type_value
                              else
                                Error_monad.return_unit
                            | None => Error_monad.return_unit
                            end
                            (fun function_parameter =>
                              let '_ := function_parameter in
                              Error_monad.op_gtgteqquestion
                                (Lwt.__return
                                  (Alpha_context.Gas.consume ctxt
                                    (Michelson_v1_gas.Cost_of.Legacy.set_update
                                      v false set)))
                                (fun ctxt =>
                                  Error_monad.__return
                                    ((Some v), (set_update v true set), ctxt))))))
              (None, (empty_set __t_value), ctxt) vs))
          (fun function_parameter =>
            let '(_, set, ctxt) := function_parameter in
            (set, ctxt))
      | (Script_typed_ir.Set_t _ _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      | (Script_typed_ir.Map_t tk tv _ty_name _, (Micheline.Seq loc vs) as expr)
        =>
        let 'existT _ [__32, __33] [tk, tv, _ty_name, loc, vs, expr] :=
          existT
            (fun '[__32, __33] =>
              [(Script_typed_ir.comparable_ty __32) ** (Script_typed_ir.ty __33)
                ** (option Script_typed_ir.type_annot) **
                Alpha_context.Script.location **
                (list
                  (Micheline.node Alpha_context.Script.location
                    Alpha_context.Script.prim)) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim)]) _
            [tk, tv, _ty_name, loc, vs, expr] in
        parse_items type_logger loc ctxt expr tk tv vs (fun x => x)
      | (Script_typed_ir.Map_t _ _ _ _, expr) =>
        traced (Error_monad.fail extensible_type_value)
      |
        (Script_typed_ir.Big_map_t tk tv _ty_name,
          (Micheline.Seq loc vs) as expr) =>
        let 'existT _ [__36, __37] [tk, tv, _ty_name, loc, vs, expr] :=
          existT
            (fun '[__36, __37] =>
              [(Script_typed_ir.comparable_ty __36) ** (Script_typed_ir.ty __37)
                ** (option Script_typed_ir.type_annot) **
                Alpha_context.Script.location **
                (list
                  (Micheline.node Alpha_context.Script.location
                    Alpha_context.Script.prim)) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim)]) _
            [tk, tv, _ty_name, loc, vs, expr] in
        Error_monad.op_gtgtpipequestion
          (parse_items type_logger loc ctxt expr tk tv vs (fun x => Some x))
          (fun function_parameter =>
            let '(diff, ctxt) := function_parameter in
            ({| Script_typed_ir.big_map.id := None;
              Script_typed_ir.big_map.diff := diff;
              Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
              Script_typed_ir.big_map.value_type := tv |}, ctxt))
      | (Script_typed_ir.Big_map_t tk tv _ty_name, Micheline.Int loc id) =>
        let 'existT _ [__38, __39] [tk, tv, _ty_name, loc, id] :=
          existT
            (fun '[__38, __39] =>
              [(Script_typed_ir.comparable_ty __38) ** (Script_typed_ir.ty __39)
                ** (option Script_typed_ir.type_annot) **
                Alpha_context.Script.location ** Z.t]) _
            [tk, tv, _ty_name, loc, id] in
        Error_monad.op_gtgteqquestion (Alpha_context.Big_map.__exists ctxt id)
          (fun function_parameter =>
            match function_parameter with
            | (_, None) => traced (Error_monad.fail extensible_type_value)
            | (ctxt, Some (btk, btv)) =>
              Lwt.__return
                (Error_monad.op_gtgtquestion
                  (parse_comparable_ty ctxt (Micheline.root btk))
                  (fun function_parameter =>
                    let '(Ex_comparable_ty btk, ctxt) := function_parameter in
                    let 'existT _ __Ex_comparable_ty_'a [btk, ctxt] :=
                      existT
                        (fun __Ex_comparable_ty_'a : Set =>
                          [(Script_typed_ir.comparable_ty __Ex_comparable_ty_'a)
                            ** Alpha_context.context]) _ [btk, ctxt] in
                    Error_monad.op_gtgtquestion
                      (parse_packable_ty ctxt legacy (Micheline.root btv))
                      (fun function_parameter =>
                        let '(Ex_ty btv, ctxt) := function_parameter in
                        let 'existT _ __Ex_ty_'a [btv, ctxt] :=
                          existT
                            (fun __Ex_ty_'a : Set =>
                              [(Script_typed_ir.ty __Ex_ty_'a) **
                                Alpha_context.context]) _ [btv, ctxt] in
                        Error_monad.op_gtgtquestion
                          (comparable_ty_eq ctxt tk btk)
                          (fun function_parameter =>
                            let 'Eq := function_parameter in
                            Error_monad.op_gtgtquestion (ty_eq ctxt tv btv)
                              (fun function_parameter =>
                                let '(Eq, ctxt) := function_parameter in
                                Error_monad.ok
                                  ({| Script_typed_ir.big_map.id := Some id;
                                    Script_typed_ir.big_map.diff := empty_map tk;
                                    Script_typed_ir.big_map.key_type :=
                                      ty_of_comparable_ty tk;
                                    Script_typed_ir.big_map.value_type := tv |},
                                    ctxt))))))
            end)
      | (Script_typed_ir.Big_map_t _tk _tv _, expr) =>
        let 'existT _ [__40, __41] [_tk, _tv, expr] :=
          existT
            (fun '[__40, __41] =>
              [(Script_typed_ir.comparable_ty __40) ** (Script_typed_ir.ty __41)
                ** Alpha_context.Script.node]) _ [_tk, _tv, expr] in
        traced (Error_monad.fail extensible_type_value)
      end)

with parse_comparable_data {a : Set}
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (ty : Script_typed_ir.comparable_ty a)
  (script_data : Alpha_context.Script.node) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  parse_data type_logger ctxt false (ty_of_comparable_ty ty) script_data

with parse_returning {arg ret : Set}
  (type_logger : option type_logger) (tc_context : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (function_parameter :
    Script_typed_ir.ty arg * option Script_typed_ir.var_annot)
  {struct type_logger}
  : Script_typed_ir.ty ret -> Alpha_context.Script.node ->
  Lwt.t
    (Error_monad.tzresult
      (Script_typed_ir.lambda arg ret * Alpha_context.context)) :=
  let '(arg, arg_annot) := function_parameter in
  fun ret =>
    fun script_instr =>
      Error_monad.op_gtgteqquestion
        (parse_instr type_logger tc_context ctxt legacy script_instr
          (Script_typed_ir.Item_t arg Script_typed_ir.Empty_t arg_annot))
        (fun function_parameter =>
          match function_parameter with
          |
            (Typed
              ({|
                Script_typed_ir.descr.loc := loc;
                  Script_typed_ir.descr.aft :=
                    (Script_typed_ir.Item_t ty
                      Script_typed_ir.Empty_t _) as
                      stack_ty
                  |} as __descr_value), ctxt) =>
            let 'existT _ [__42, __Typed_'aft]
              [loc, ty, stack_ty, __descr_value, ctxt] :=
              existT
                (fun '[__42, __Typed_'aft] =>
                  [Alpha_context.Script.location ** (Script_typed_ir.ty __42) **
                    (Script_typed_ir.stack_ty
                      (__42 * Script_typed_ir.end_of_stack)) **
                    (Script_typed_ir.descr (arg * Script_typed_ir.end_of_stack)
                      __Typed_'aft) ** Alpha_context.context]) _
                [loc, ty, stack_ty, __descr_value, ctxt] in
            Error_monad.trace_eval
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return (serialize_ty_for_error ctxt ret))
                  (fun function_parameter =>
                    let '(ret, ctxt) := function_parameter in
                    Error_monad.op_gtgtpipequestion
                      (serialize_stack_for_error ctxt stack_ty)
                      (fun function_parameter =>
                        let '(stack_ty, _ctxt) := function_parameter in
                        extensible_type_value)))
              (Error_monad.op_gtgteqquestion (Lwt.__return (ty_eq ctxt ty ret))
                (fun function_parameter =>
                  let '(Eq, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return (merge_types legacy ctxt loc ty ret))
                    (fun function_parameter =>
                      let '(_ret, ctxt) := function_parameter in
                      Error_monad.__return
                        ((Script_typed_ir.Lam __descr_value script_instr), ctxt))))
          |
            (Typed {|
              Script_typed_ir.descr.loc := loc;
                Script_typed_ir.descr.aft := stack_ty
                |}, ctxt) =>
            let 'existT _ __Typed_'aft1 [loc, stack_ty, ctxt] :=
              existT
                (fun __Typed_'aft1 : Set =>
                  [Alpha_context.Script.location **
                    (Script_typed_ir.stack_ty __Typed_'aft1) **
                    Alpha_context.context]) _ [loc, stack_ty, ctxt] in
            Error_monad.op_gtgteqquestion
              (Lwt.__return (serialize_ty_for_error ctxt ret))
              (fun function_parameter =>
                let '(ret, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (serialize_stack_for_error ctxt stack_ty)
                  (fun function_parameter =>
                    let '(stack_ty, _ctxt) := function_parameter in
                    Error_monad.fail extensible_type_value))
          | (Failed {| judgement.Failed.descr := __descr_value |}, ctxt) =>
            Error_monad.__return
              ((Script_typed_ir.Lam
                (__descr_value
                  (Script_typed_ir.Item_t ret Script_typed_ir.Empty_t None))
                script_instr), ctxt)
          end)

with parse_int32
  (n : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  {struct n} : Error_monad.tzresult Z :=
  let error' (function_parameter : unit) : Error_monad.__error :=
    let '_ := function_parameter in
    extensible_type_value in
  match n with
  | Micheline.Int _ n' =>
    (*  Try-with are not handled *)
    try
      (let n'' := Z.to_int n' in
      if
        Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_lteq) 0 n'')
          ((|Compare.Int|).(Compare.S.op_lteq) n'' (Int32.to_int Int32.max_int))
        then
        Error_monad.ok n''
      else
        Pervasives.op_atat Error_monad.__error_value (error' tt))
  | _ => Pervasives.op_atat Error_monad.__error_value (error' tt)
  end

with parse_instr {bef : Set}
  (type_logger : option type_logger) (tc_context : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (script_instr : Alpha_context.Script.node)
  (stack_ty : Script_typed_ir.stack_ty bef) {struct type_logger}
  : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
  let _check_item {B : Set}
    (check : Error_monad.tzresult B) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : Z) (m : Z)
    : Lwt.t (Error_monad.tzresult B) :=
    Pervasives.op_atat
      (Error_monad.trace_eval
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtpipequestion
            (serialize_stack_for_error ctxt stack_ty)
            (fun function_parameter =>
              let '(stack_ty, _ctxt) := function_parameter in
              extensible_type_value)))
      (Pervasives.op_atat (Error_monad.trace extensible_type_value)
        (Lwt.__return check)) in
  let check_item_ty {B C : Set}
    (ctxt : Alpha_context.context) (exp : Script_typed_ir.ty B)
    (got : Script_typed_ir.ty C) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : Z) (m : Z)
    : Lwt.t
      (Error_monad.tzresult
        (eq B C * Script_typed_ir.ty B * Alpha_context.context)) :=
    Pervasives.op_atat
      (Error_monad.trace_eval
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtpipequestion
            (serialize_stack_for_error ctxt stack_ty)
            (fun function_parameter =>
              let '(stack_ty, _ctxt) := function_parameter in
              extensible_type_value)))
      (Pervasives.op_atat (Error_monad.trace extensible_type_value)
        (Lwt.__return
          (Error_monad.op_gtgtquestion (ty_eq ctxt exp got)
            (fun function_parameter =>
              let '(Eq, ctxt) := function_parameter in
              Error_monad.op_gtgtquestion (merge_types legacy ctxt loc exp got)
                (fun function_parameter =>
                  let '(ty, ctxt) := function_parameter in
                  Error_monad.ok (Eq, ty, ctxt)))))) in
  let check_item_comparable_ty {B C : Set}
    (exp : Script_typed_ir.comparable_ty B)
    (got : Script_typed_ir.comparable_ty C)
    (loc : Alpha_context.Script.location) (name : Alpha_context.Script.prim)
    (n : Z) (m : Z)
    : Lwt.t (Error_monad.tzresult (eq B C * Script_typed_ir.comparable_ty B)) :=
    Pervasives.op_atat
      (Error_monad.trace_eval
        (fun function_parameter =>
          let '_ := function_parameter in
          Error_monad.op_gtgtpipequestion
            (serialize_stack_for_error ctxt stack_ty)
            (fun function_parameter =>
              let '(stack_ty, _ctxt) := function_parameter in
              extensible_type_value)))
      (Pervasives.op_atat (Error_monad.trace extensible_type_value)
        (Lwt.__return
          (Error_monad.op_gtgtquestion (comparable_ty_eq ctxt exp got)
            (fun function_parameter =>
              let 'Eq := function_parameter in
              Error_monad.op_gtgtquestion
                (merge_comparable_types legacy exp got)
                (fun ty => Error_monad.ok (Eq, ty)))))) in
  let log_stack {B C : Set}
    (ctxt : Alpha_context.context) (loc : Z)
    (stack_ty : Script_typed_ir.stack_ty B) (aft : Script_typed_ir.stack_ty C)
    : Lwt.t (Error_monad.tzresult unit) :=
    match (type_logger, script_instr) with
    |
      (None, _) |
      (Some _,
        Micheline.Seq (-1) _ | Micheline.Int _ _ | Micheline.String _ _ |
        Micheline.Bytes _ _) => Error_monad.return_unit
    | (Some log, Micheline.Prim _ _ _ _ | Micheline.Seq _ _) =>
      let ctxt := Alpha_context.Gas.set_unlimited ctxt in
      Error_monad.op_gtgteqquestion (unparse_stack ctxt stack_ty)
        (fun function_parameter =>
          let '(stack_ty, _) := function_parameter in
          Error_monad.op_gtgteqquestion (unparse_stack ctxt aft)
            (fun function_parameter =>
              let '(aft, _) := function_parameter in
              (*  Sequences of instructions are ignored (operator ";") *)
              (*  instruction_sequence ";" *)
              Error_monad.return_unit))
    end in
  let outer_return {B : Set} : B -> Lwt.t (Error_monad.tzresult B) :=
    Error_monad.__return in
  let __return (ctxt : Alpha_context.context) (judgement : judgement bef)
    : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
    match judgement with
    |
      Typed {|
        Script_typed_ir.descr.loc := loc;
          Script_typed_ir.descr.aft := aft;
          Script_typed_ir.descr.instr := instr
          |} =>
      let 'existT _ __Typed_'aft2 [loc, aft, instr] :=
        existT
          (fun __Typed_'aft2 : Set =>
            [Alpha_context.Script.location **
              (Script_typed_ir.stack_ty __Typed_'aft2) **
              (Script_typed_ir.instr bef __Typed_'aft2)]) _ [loc, aft, instr] in
      let maximum_type_size :=
        Alpha_context.Constants.michelson_maximum_type_size ctxt in
      let type_size :=
        type_size_of_stack_head aft (number_of_generated_growing_types instr) in
      if (|Compare.Int|).(Compare.S.op_gt) type_size maximum_type_size then
        Error_monad.fail extensible_type_value
      else
        Error_monad.__return (judgement, ctxt)
    | Failed _ => Error_monad.__return (judgement, ctxt)
    end in
  let typed {B : Set}
    (ctxt : Alpha_context.context) (loc : Z)
    (instr : Script_typed_ir.instr bef B) (aft : Script_typed_ir.stack_ty B)
    : Lwt.t (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
    Error_monad.op_gtgteqquestion (log_stack ctxt loc stack_ty aft)
      (fun function_parameter =>
        let '_ := function_parameter in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return
            (Alpha_context.Gas.consume ctxt (Typecheck_costs.instr instr)))
          (fun ctxt =>
            __return ctxt
              (Typed
                {| Script_typed_ir.descr.loc := loc;
                  Script_typed_ir.descr.bef := stack_ty;
                  Script_typed_ir.descr.aft := aft;
                  Script_typed_ir.descr.instr := instr |}))) in
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
    (fun ctxt =>
      match
        ((script_instr, stack_ty),
          match (script_instr, stack_ty) with
          |
            (Micheline.Prim loc Alpha_context.Script.I_DIP
              (cons n (cons code [])) result_annot, stack) =>
            match parse_int32 n with
            | Pervasives.Ok _ => true
            | Pervasives.Error _ => false
            end
          | _ => false
          end) with
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DROP [] annot,
          Script_typed_ir.Item_t _ rest _), _) =>
        let 'existT _ __45 [loc, annot, rest] :=
          existT
            (fun __45 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __45)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            typed ctxt loc Script_typed_ir.Drop rest)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DROP (cons n [])
          result_annot, whole_stack), _) =>
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun whole_n =>
            let fix make_proof_argument {tstk : Set}
              (n : Z) (stk : Script_typed_ir.stack_ty tstk) {struct n}
              : Lwt.t (Error_monad.tzresult (dropn_proof_argument tstk)) :=
              match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
              | (true, rest) =>
                Pervasives.op_atat outer_return
                  (Dropn_proof_argument (Script_typed_ir.Rest, rest, rest))
              | (false, Script_typed_ir.Item_t v rest annot) =>
                let 'existT _ [__470, __471] [v, rest, annot] :=
                  existT
                    (fun '[__470, __471] =>
                      [(Script_typed_ir.ty __470) **
                        (Script_typed_ir.stack_ty __471) **
                        (option Script_typed_ir.var_annot)]) _ [v, rest, annot]
                  in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument (Pervasives.op_minus n 1) rest)
                  (fun function_parameter =>
                    let 'Dropn_proof_argument (n', stack_after_drops, aft') :=
                      function_parameter in
                    let 'existT _
                      [__Dropn_proof_argument_'aft,
                        __Dropn_proof_argument_'rest]
                      [n', stack_after_drops, aft'] :=
                      existT
                        (fun
                          '[__Dropn_proof_argument_'aft,
                            __Dropn_proof_argument_'rest] =>
                          [(Script_typed_ir.stack_prefix_preservation_witness
                            __Dropn_proof_argument_'rest
                            __Dropn_proof_argument_'rest __471
                            __Dropn_proof_argument_'aft) **
                            (Script_typed_ir.stack_ty
                              __Dropn_proof_argument_'rest) **
                            (Script_typed_ir.stack_ty
                              __Dropn_proof_argument_'aft)]) _
                        [n', stack_after_drops, aft'] in
                    Pervasives.op_atat outer_return
                      (Dropn_proof_argument
                        ((Script_typed_ir.Prefix n'), stack_after_drops,
                          (Script_typed_ir.Item_t v aft' annot))))
              | (_, _) =>
                Error_monad.op_gtgteqquestion
                  (serialize_stack_for_error ctxt whole_stack)
                  (fun function_parameter =>
                    let '(whole_stack, _ctxt) := function_parameter in
                    Error_monad.fail extensible_type_value)
              end in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument whole_n whole_stack)
                  (fun function_parameter =>
                    let 'Dropn_proof_argument (n', stack_after_drops, _aft) :=
                      function_parameter in
                    let 'existT _
                      [__Dropn_proof_argument_'aft1,
                        __Dropn_proof_argument_'rest1]
                      [n', stack_after_drops, _aft] :=
                      existT
                        (fun
                          '[__Dropn_proof_argument_'aft1,
                            __Dropn_proof_argument_'rest1] =>
                          [(Script_typed_ir.stack_prefix_preservation_witness
                            __Dropn_proof_argument_'rest1
                            __Dropn_proof_argument_'rest1 bef
                            __Dropn_proof_argument_'aft1) **
                            (Script_typed_ir.stack_ty
                              __Dropn_proof_argument_'rest1) **
                            (Script_typed_ir.stack_ty
                              __Dropn_proof_argument_'aft1)]) _
                        [n', stack_after_drops, _aft] in
                    typed ctxt loc (Script_typed_ir.Dropn whole_n n')
                      stack_after_drops)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DROP
          ((cons _ (cons _ _)) as l) _, _), _) =>
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUP [] annot,
          Script_typed_ir.Item_t v rest stack_annot), _) =>
        let 'existT _ [__46, __47] [loc, annot, v, rest, stack_annot] :=
          existT
            (fun '[__46, __47] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __46) ** (Script_typed_ir.stack_ty __47) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, v, rest, stack_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some stack_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Dup
              (Script_typed_ir.Item_t v
                (Script_typed_ir.Item_t v rest stack_annot) annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIG (cons n []) result_annot,
          stack), _) =>
        let fix make_proof_argument {tstk : Set}
          (n : Z) (stk : Script_typed_ir.stack_ty tstk) {struct n}
          : Lwt.t (Error_monad.tzresult (dig_proof_argument tstk)) :=
          match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
          | (true, Script_typed_ir.Item_t v rest annot) =>
            let 'existT _ [__472, __473] [v, rest, annot] :=
              existT
                (fun '[__472, __473] =>
                  [(Script_typed_ir.ty __472) **
                    (Script_typed_ir.stack_ty __473) **
                    (option Script_typed_ir.var_annot)]) _ [v, rest, annot] in
            Pervasives.op_atat outer_return
              (Dig_proof_argument (Script_typed_ir.Rest, (v, annot), rest))
          | (false, Script_typed_ir.Item_t v rest annot) =>
            let 'existT _ [__474, __475] [v, rest, annot] :=
              existT
                (fun '[__474, __475] =>
                  [(Script_typed_ir.ty __474) **
                    (Script_typed_ir.stack_ty __475) **
                    (option Script_typed_ir.var_annot)]) _ [v, rest, annot] in
            Error_monad.op_gtgteqquestion
              (make_proof_argument (Pervasives.op_minus n 1) rest)
              (fun function_parameter =>
                let 'Dig_proof_argument (n', (x, xv), aft') :=
                  function_parameter in
                let 'existT _
                  [__Dig_proof_argument_'aft, __Dig_proof_argument_'rest,
                    __Dig_proof_argument_'x] [n', x, xv, aft'] :=
                  existT
                    (fun
                      '[__Dig_proof_argument_'aft, __Dig_proof_argument_'rest,
                        __Dig_proof_argument_'x] =>
                      [(Script_typed_ir.stack_prefix_preservation_witness
                        (__Dig_proof_argument_'x * __Dig_proof_argument_'rest)
                        __Dig_proof_argument_'rest __475
                        __Dig_proof_argument_'aft) **
                        (Script_typed_ir.ty __Dig_proof_argument_'x) **
                        (option Script_typed_ir.var_annot) **
                        (Script_typed_ir.stack_ty __Dig_proof_argument_'aft)]) _
                    [n', x, xv, aft'] in
                Pervasives.op_atat outer_return
                  (Dig_proof_argument
                    ((Script_typed_ir.Prefix n'), (x, xv),
                      (Script_typed_ir.Item_t v aft' annot))))
          | (_, _) =>
            Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
              (fun function_parameter =>
                let '(whole_stack, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value)
          end in
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun n =>
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion (make_proof_argument n stack)
                  (fun function_parameter =>
                    let 'Dig_proof_argument (n', (x, stack_annot), aft) :=
                      function_parameter in
                    let 'existT _
                      [__Dig_proof_argument_'aft1, __Dig_proof_argument_'rest1,
                        __Dig_proof_argument_'x1] [n', x, stack_annot, aft] :=
                      existT
                        (fun
                          '[__Dig_proof_argument_'aft1,
                            __Dig_proof_argument_'rest1,
                            __Dig_proof_argument_'x1] =>
                          [(Script_typed_ir.stack_prefix_preservation_witness
                            (__Dig_proof_argument_'x1 *
                              __Dig_proof_argument_'rest1)
                            __Dig_proof_argument_'rest1 bef
                            __Dig_proof_argument_'aft1) **
                            (Script_typed_ir.ty __Dig_proof_argument_'x1) **
                            (option Script_typed_ir.var_annot) **
                            (Script_typed_ir.stack_ty __Dig_proof_argument_'aft1)])
                        _ [n', x, stack_annot, aft] in
                    typed ctxt loc (Script_typed_ir.Dig n n')
                      (Script_typed_ir.Item_t x aft stack_annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIG
          (([] | cons _ (cons _ _)) as l) _, _), _) =>
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons n []) result_annot,
          Script_typed_ir.Item_t x whole_stack stack_annot), _) =>
        let 'existT _ [__48, __49]
          [loc, n, result_annot, x, whole_stack, stack_annot] :=
          existT
            (fun '[__48, __49] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __48) ** (Script_typed_ir.stack_ty __49) **
                (option Script_typed_ir.var_annot)]) _
            [loc, n, result_annot, x, whole_stack, stack_annot] in
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun whole_n =>
            let fix make_proof_argument {tstk x : Set}
              (n : Z) (x : Script_typed_ir.ty x)
              (stack_annot : option Script_typed_ir.var_annot)
              (stk : Script_typed_ir.stack_ty tstk) {struct n}
              : Lwt.t (Error_monad.tzresult (dug_proof_argument tstk x)) :=
              match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
              | (true, rest) =>
                Pervasives.op_atat outer_return
                  (Dug_proof_argument
                    (Script_typed_ir.Rest, tt,
                      (Script_typed_ir.Item_t x rest stack_annot)))
              | (false, Script_typed_ir.Item_t v rest annot) =>
                let 'existT _ [__476, __477] [v, rest, annot] :=
                  existT
                    (fun '[__476, __477] =>
                      [(Script_typed_ir.ty __476) **
                        (Script_typed_ir.stack_ty __477) **
                        (option Script_typed_ir.var_annot)]) _ [v, rest, annot]
                  in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument (Pervasives.op_minus n 1) x stack_annot
                    rest)
                  (fun function_parameter =>
                    let 'Dug_proof_argument (n', _, aft') := function_parameter
                      in
                    let 'existT _
                      [__Dug_proof_argument_'aft, __Dug_proof_argument_'rest]
                      [n', aft'] :=
                      existT
                        (fun
                          '[__Dug_proof_argument_'aft,
                            __Dug_proof_argument_'rest] =>
                          [(Script_typed_ir.stack_prefix_preservation_witness
                            __Dug_proof_argument_'rest
                            (x * __Dug_proof_argument_'rest) __477
                            __Dug_proof_argument_'aft) **
                            (Script_typed_ir.stack_ty __Dug_proof_argument_'aft)])
                        _ [n', aft'] in
                    Pervasives.op_atat outer_return
                      (Dug_proof_argument
                        ((Script_typed_ir.Prefix n'), tt,
                          (Script_typed_ir.Item_t v aft' annot))))
              | (_, _) =>
                Error_monad.op_gtgteqquestion
                  (serialize_stack_for_error ctxt whole_stack)
                  (fun function_parameter =>
                    let '(whole_stack, _ctxt) := function_parameter in
                    Error_monad.fail extensible_type_value)
              end in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument whole_n x stack_annot whole_stack)
                  (fun function_parameter =>
                    let 'Dug_proof_argument (n', _, aft) := function_parameter
                      in
                    let 'existT _
                      [__Dug_proof_argument_'aft1, __Dug_proof_argument_'rest1]
                      [n', aft] :=
                      existT
                        (fun
                          '[__Dug_proof_argument_'aft1,
                            __Dug_proof_argument_'rest1] =>
                          [(Script_typed_ir.stack_prefix_preservation_witness
                            __Dug_proof_argument_'rest1
                            (__48 * __Dug_proof_argument_'rest1) __49
                            __Dug_proof_argument_'aft1) **
                            (Script_typed_ir.stack_ty __Dug_proof_argument_'aft1)])
                        _ [n', aft] in
                    typed ctxt loc (Script_typed_ir.Dug whole_n n') aft)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons _ []) result_annot,
          Script_typed_ir.Empty_t as stack), _) =>
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc result_annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
              (fun function_parameter =>
                let '(stack, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DUG
          (([] | cons _ (cons _ _)) as l) _, _), _) =>
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SWAP [] annot,
          Script_typed_ir.Item_t v (Script_typed_ir.Item_t w rest stack_annot)
            cur_top_annot), _) =>
        let 'existT _ [__50, __52, __53]
          [loc, annot, v, w, rest, stack_annot, cur_top_annot] :=
          existT
            (fun '[__50, __52, __53] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __50) ** (Script_typed_ir.ty __52) **
                (Script_typed_ir.stack_ty __53) **
                (option Script_typed_ir.var_annot) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, v, w, rest, stack_annot, cur_top_annot] in
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            typed ctxt loc Script_typed_ir.Swap
              (Script_typed_ir.Item_t w
                (Script_typed_ir.Item_t v rest cur_top_annot) stack_annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_PUSH
          (cons __t_value (cons d [])) annot, stack), _) =>
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (parse_packable_ty ctxt legacy __t_value))
              (fun function_parameter =>
                let '(Ex_ty __t_value, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a1 [__t_value, ctxt] :=
                  existT
                    (fun __Ex_ty_'a1 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a1) **
                        Alpha_context.context]) _ [__t_value, ctxt] in
                Error_monad.op_gtgteqquestion
                  (parse_data type_logger ctxt legacy __t_value d)
                  (fun function_parameter =>
                    let '(v, ctxt) := function_parameter in
                    typed ctxt loc (Script_typed_ir.Const v)
                      (Script_typed_ir.Item_t __t_value stack annot))))
      | ((Micheline.Prim loc Alpha_context.Script.I_UNIT [] annot, stack), _) =>
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =>
            let '(annot, ty_name) := function_parameter in
            typed ctxt loc (Script_typed_ir.Const tt)
              (Script_typed_ir.Item_t (Script_typed_ir.Unit_t ty_name) stack
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SOME [] annot,
          Script_typed_ir.Item_t __t_value rest _), _) =>
        let 'existT _ [__54, __55] [loc, annot, __t_value, rest] :=
          existT
            (fun '[__54, __55] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __54) ** (Script_typed_ir.stack_ty __55)]) _
            [loc, annot, __t_value, rest] in
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =>
            let '(annot, ty_name) := function_parameter in
            typed ctxt loc Script_typed_ir.Cons_some
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t __t_value ty_name
                  (has_big_map __t_value)) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NONE (cons __t_value [])
          annot, stack), _) =>
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy __t_value))
          (fun function_parameter =>
            let '(Ex_ty __t_value, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a2 [__t_value, ctxt] :=
              existT
                (fun __Ex_ty_'a2 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a2) ** Alpha_context.context]) _
                [__t_value, ctxt] in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =>
                let '(annot, ty_name) := function_parameter in
                typed ctxt loc (Script_typed_ir.Cons_none __t_value)
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t __t_value ty_name
                      (has_big_map __t_value)) stack annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF_NONE
          (cons bt (cons bf [])) annot,
          (Script_typed_ir.Item_t (Script_typed_ir.Option_t __t_value _ _) rest
            option_annot) as bef), _) =>
        let 'existT _ [__57, __58]
          [loc, bt, bf, annot, __t_value, rest, option_annot, bef] :=
          existT
            (fun '[__57, __58] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __58) ** (Script_typed_ir.stack_ty __57) **
                (option Script_typed_ir.var_annot) **
                (Script_typed_ir.stack_ty (option __58 * __57))]) _
            [loc, bt, bf, annot, __t_value, rest, option_annot, bef] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] bt)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind [ Script_tc_errors.Seq_kind ] bf)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =>
                    let '_ := function_parameter in
                    let annot :=
                      Script_ir_annot.gen_access_annot option_annot None
                        Script_ir_annot.default_some_annot in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt rest)
                      (fun function_parameter =>
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            (Script_typed_ir.Item_t __t_value rest annot))
                          (fun function_parameter =>
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt : Script_typed_ir.descr __57 B)
                              (ibf : Script_typed_ir.descr (__58 * __57) B)
                              : Script_typed_ir.descr (option __58 * __57) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  ibt.(Script_typed_ir.descr.aft);
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If_none ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =>
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_PAIR [] annot,
          Script_typed_ir.Item_t a (Script_typed_ir.Item_t b rest snd_annot)
            fst_annot), _) =>
        let 'existT _ [__59, __61, __62]
          [loc, annot, a, b, rest, snd_annot, fst_annot] :=
          existT
            (fun '[__59, __61, __62] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __59) ** (Script_typed_ir.ty __61) **
                (Script_typed_ir.stack_ty __62) **
                (option Script_typed_ir.var_annot) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, a, b, rest, snd_annot, fst_annot] in
        Error_monad.op_gtgteqquestion
          (parse_constr_annot loc
            (Some (Script_ir_annot.var_to_field_annot fst_annot))
            (Some (Script_ir_annot.var_to_field_annot snd_annot)) annot)
          (fun function_parameter =>
            let '(annot, ty_name, l_field, r_field) := function_parameter in
            typed ctxt loc Script_typed_ir.Cons_pair
              (Script_typed_ir.Item_t
                (Script_typed_ir.Pair_t (a, l_field, fst_annot)
                  (b, r_field, snd_annot) ty_name
                  (Pervasives.op_pipepipe (has_big_map a) (has_big_map b))) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CAR [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Pair_t (a, expected_field_annot, a_annot) _ _ _)
            rest pair_annot), _) =>
        let 'existT _ [__64, __65]
          [loc, annot, a, expected_field_annot, a_annot, rest, pair_annot] :=
          existT
            (fun '[__64, __65] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __65) **
                (option Script_typed_ir.field_annot) **
                (option Script_typed_ir.var_annot) **
                (Script_typed_ir.stack_ty __64) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, a, expected_field_annot, a_annot, rest, pair_annot] in
        Error_monad.op_gtgteqquestion
          (parse_destr_annot loc annot Script_ir_annot.default_car_annot
            expected_field_annot pair_annot a_annot)
          (fun function_parameter =>
            let '(annot, field_annot) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.check_correct_field field_annot
                  expected_field_annot))
              (fun function_parameter =>
                let '_ := function_parameter in
                typed ctxt loc Script_typed_ir.Car
                  (Script_typed_ir.Item_t a rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CDR [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Pair_t _ (b, expected_field_annot, b_annot) _ _)
            rest pair_annot), _) =>
        let 'existT _ [__68, __70]
          [loc, annot, b, expected_field_annot, b_annot, rest, pair_annot] :=
          existT
            (fun '[__68, __70] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __70) **
                (option Script_typed_ir.field_annot) **
                (option Script_typed_ir.var_annot) **
                (Script_typed_ir.stack_ty __68) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, b, expected_field_annot, b_annot, rest, pair_annot] in
        Error_monad.op_gtgteqquestion
          (parse_destr_annot loc annot Script_ir_annot.default_cdr_annot
            expected_field_annot pair_annot b_annot)
          (fun function_parameter =>
            let '(annot, field_annot) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.check_correct_field field_annot
                  expected_field_annot))
              (fun function_parameter =>
                let '_ := function_parameter in
                typed ctxt loc Script_typed_ir.Cdr
                  (Script_typed_ir.Item_t b rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LEFT (cons tr []) annot,
          Script_typed_ir.Item_t tl rest stack_annot), _) =>
        let 'existT _ [__71, __72] [loc, tr, annot, tl, rest, stack_annot] :=
          existT
            (fun '[__71, __72] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __71) ** (Script_typed_ir.stack_ty __72) **
                (option Script_typed_ir.var_annot)]) _
            [loc, tr, annot, tl, rest, stack_annot] in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy tr))
          (fun function_parameter =>
            let '(Ex_ty tr, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a3 [tr, ctxt] :=
              existT
                (fun __Ex_ty_'a3 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a3) ** Alpha_context.context]) _
                [tr, ctxt] in
            Error_monad.op_gtgteqquestion
              (parse_constr_annot loc
                (Some (Script_ir_annot.var_to_field_annot stack_annot)) None
                annot)
              (fun function_parameter =>
                let '(annot, tname, l_field, r_field) := function_parameter in
                typed ctxt loc Script_typed_ir.Left
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
                      (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))
                    rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_RIGHT (cons tl []) annot,
          Script_typed_ir.Item_t tr rest stack_annot), _) =>
        let 'existT _ [__73, __74] [loc, tl, annot, tr, rest, stack_annot] :=
          existT
            (fun '[__73, __74] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __73) ** (Script_typed_ir.stack_ty __74) **
                (option Script_typed_ir.var_annot)]) _
            [loc, tl, annot, tr, rest, stack_annot] in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy tl))
          (fun function_parameter =>
            let '(Ex_ty tl, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a4 [tl, ctxt] :=
              existT
                (fun __Ex_ty_'a4 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a4) ** Alpha_context.context]) _
                [tl, ctxt] in
            Error_monad.op_gtgteqquestion
              (parse_constr_annot loc None
                (Some (Script_ir_annot.var_to_field_annot stack_annot)) annot)
              (fun function_parameter =>
                let '(annot, tname, l_field, r_field) := function_parameter in
                typed ctxt loc Script_typed_ir.Right
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
                      (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))
                    rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF_LEFT
          (cons bt (cons bf [])) annot,
          (Script_typed_ir.Item_t
            (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) _ _) rest
            union_annot) as bef), _) =>
        let 'existT _ [__76, __77, __78]
          [loc, bt, bf, annot, tl, l_field, tr, r_field, rest, union_annot, bef]
          :=
          existT
            (fun '[__76, __77, __78] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __77) **
                (option Script_typed_ir.field_annot) **
                (Script_typed_ir.ty __78) **
                (option Script_typed_ir.field_annot) **
                (Script_typed_ir.stack_ty __76) **
                (option Script_typed_ir.var_annot) **
                (Script_typed_ir.stack_ty
                  (Script_typed_ir.union __77 __78 * __76))]) _
            [loc, bt, bf, annot, tl, l_field, tr, r_field, rest, union_annot,
              bef] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] bt)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind [ Script_tc_errors.Seq_kind ] bf)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =>
                    let '_ := function_parameter in
                    let left_annot :=
                      Script_ir_annot.gen_access_annot union_annot
                        (Some Script_ir_annot.default_left_annot) l_field in
                    let right_annot :=
                      Script_ir_annot.gen_access_annot union_annot
                        (Some Script_ir_annot.default_right_annot) r_field in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt
                        (Script_typed_ir.Item_t tl rest left_annot))
                      (fun function_parameter =>
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            (Script_typed_ir.Item_t tr rest right_annot))
                          (fun function_parameter =>
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt : Script_typed_ir.descr (__77 * __76) B)
                              (ibf : Script_typed_ir.descr (__78 * __76) B)
                              : Script_typed_ir.descr
                                (Script_typed_ir.union __77 __78 * __76) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  ibt.(Script_typed_ir.descr.aft);
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If_left ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =>
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NIL (cons __t_value [])
          annot, stack), _) =>
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy __t_value))
          (fun function_parameter =>
            let '(Ex_ty __t_value, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a5 [__t_value, ctxt] :=
              existT
                (fun __Ex_ty_'a5 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a5) ** Alpha_context.context]) _
                [__t_value, ctxt] in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =>
                let '(annot, ty_name) := function_parameter in
                typed ctxt loc Script_typed_ir.Nil
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.List_t __t_value ty_name
                      (has_big_map __t_value)) stack annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONS [] annot,
          Script_typed_ir.Item_t tv
            (Script_typed_ir.Item_t
              (Script_typed_ir.List_t __t_value ty_name has_big_map) rest _) _),
          _) =>
        let 'existT _ [__79, __82, __83]
          [loc, annot, tv, __t_value, ty_name, has_big_map, rest] :=
          existT
            (fun '[__79, __82, __83] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __79) ** (Script_typed_ir.ty __83) **
                (option Script_typed_ir.type_annot) ** bool **
                (Script_typed_ir.stack_ty __82)]) _
            [loc, annot, tv, __t_value, ty_name, has_big_map, rest] in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt tv __t_value loc Alpha_context.Script.I_CONS 1 2)
          (fun function_parameter =>
            let '(Eq, __t_value, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                typed ctxt loc Script_typed_ir.Cons_list
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.List_t __t_value ty_name has_big_map) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF_CONS
          (cons bt (cons bf [])) annot,
          (Script_typed_ir.Item_t
            (Script_typed_ir.List_t __t_value ty_name has_big_map) rest
            list_annot) as bef), _) =>
        let 'existT _ [__85, __86]
          [loc, bt, bf, annot, __t_value, ty_name, has_big_map, rest,
            list_annot, bef] :=
          existT
            (fun '[__85, __86] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __86) ** (option Script_typed_ir.type_annot)
                ** bool ** (Script_typed_ir.stack_ty __85) **
                (option Script_typed_ir.var_annot) **
                (Script_typed_ir.stack_ty (list __86 * __85))]) _
            [loc, bt, bf, annot, __t_value, ty_name, has_big_map, rest,
              list_annot, bef] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] bt)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind [ Script_tc_errors.Seq_kind ] bf)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =>
                    let '_ := function_parameter in
                    let hd_annot :=
                      Script_ir_annot.gen_access_annot list_annot None
                        Script_ir_annot.default_hd_annot in
                    let tl_annot :=
                      Script_ir_annot.gen_access_annot list_annot None
                        Script_ir_annot.default_tl_annot in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt
                        (Script_typed_ir.Item_t __t_value
                          (Script_typed_ir.Item_t
                            (Script_typed_ir.List_t __t_value ty_name
                              has_big_map) rest tl_annot) hd_annot))
                      (fun function_parameter =>
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            rest)
                          (fun function_parameter =>
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt :
                                Script_typed_ir.descr
                                  (__86 * (list __86 * __85)) B)
                              (ibf : Script_typed_ir.descr __85 B)
                              : Script_typed_ir.descr (list __86 * __85) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  ibt.(Script_typed_ir.descr.aft);
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If_cons ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =>
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.List_t _ _ _) rest _), _) =>
        let 'existT _ __88 [loc, annot, rest] :=
          existT
            (fun __88 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __88)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =>
            let '(annot, tname) := function_parameter in
            typed ctxt loc Script_typed_ir.List_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.List_t elt _ _) starting_rest
            list_annot), _) =>
        let 'existT _ [__91, __92]
          [loc, body, annot, elt, starting_rest, list_annot] :=
          existT
            (fun '[__91, __92] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __92) ** (Script_typed_ir.stack_ty __91) **
                (option Script_typed_ir.var_annot)]) _
            [loc, body, annot, elt, starting_rest, list_annot] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] body)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =>
                let '(ret_annot, list_ty_name) := function_parameter in
                let elt_annot :=
                  Script_ir_annot.gen_access_annot list_annot None
                    Script_ir_annot.default_elt_annot in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t elt starting_rest elt_annot))
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    |
                      Typed
                        ({|
                          Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _
                            |} as ibody) =>
                      let 'existT _ [__478, __479, __Typed_'aft3]
                        [ret, rest, ibody] :=
                        existT
                          (fun '[__478, __479, __Typed_'aft3] =>
                            [(Script_typed_ir.ty __478) **
                              (Script_typed_ir.stack_ty __479) **
                              (Script_typed_ir.descr (__92 * __91) __Typed_'aft3)])
                          _ [ret, rest, ibody] in
                      let invalid_map_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let '_ := function_parameter in
                        Error_monad.op_gtgtpipequestion
                          (serialize_stack_for_error ctxt
                            ibody.(Script_typed_ir.descr.aft))
                          (fun function_parameter =>
                            let '(aft, _ctxt) := function_parameter in
                            extensible_type_value) in
                      Error_monad.trace_eval invalid_map_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 rest starting_rest))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt rest starting_rest))
                              (fun function_parameter =>
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.List_map ibody)
                                  (Script_typed_ir.Item_t
                                    (Script_typed_ir.List_t ret list_ty_name
                                      (has_big_map ret)) rest ret_annot))))
                    | Typed {| Script_typed_ir.descr.aft := aft |} =>
                      let 'existT _ __Typed_'aft4 aft :=
                        existT
                          (fun __Typed_'aft4 : Set =>
                            (Script_typed_ir.stack_ty __Typed_'aft4)) _ aft in
                      Error_monad.op_gtgteqquestion
                        (serialize_stack_for_error ctxt aft)
                        (fun function_parameter =>
                          let '(aft, _ctxt) := function_parameter in
                          Error_monad.fail extensible_type_value)
                    | Failed _ => Error_monad.fail extensible_type_value
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.List_t elt _ _) rest
            list_annot), _) =>
        let 'existT _ [__94, __95] [loc, body, annot, elt, rest, list_annot] :=
          existT
            (fun '[__94, __95] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __95) ** (Script_typed_ir.stack_ty __94) **
                (option Script_typed_ir.var_annot)]) _
            [loc, body, annot, elt, rest, list_annot] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] body)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                let elt_annot :=
                  Script_ir_annot.gen_access_annot list_annot None
                    Script_ir_annot.default_elt_annot in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t elt rest elt_annot))
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =>
                      let 'existT _ __Typed_'aft5 [aft, ibody] :=
                        existT
                          (fun __Typed_'aft5 : Set =>
                            [(Script_typed_ir.stack_ty __Typed_'aft5) **
                              (Script_typed_ir.descr (__95 * __94) __Typed_'aft5)])
                          _ [aft, ibody] in
                      let invalid_iter_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let '_ := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            ibody.(Script_typed_ir.descr.aft))
                          (fun function_parameter =>
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt rest)
                              (fun function_parameter =>
                                let '(rest, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval invalid_iter_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 aft rest))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt aft rest))
                              (fun function_parameter =>
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.List_iter ibody)
                                  rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =>
                      typed ctxt loc
                        (Script_typed_ir.List_iter (__descr_value rest)) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_SET
          (cons __t_value []) annot, rest), _) =>
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_comparable_ty ctxt __t_value))
          (fun function_parameter =>
            let '(Ex_comparable_ty __t_value, ctxt) := function_parameter in
            let 'existT _ __Ex_comparable_ty_'a1 [__t_value, ctxt] :=
              existT
                (fun __Ex_comparable_ty_'a1 : Set =>
                  [(Script_typed_ir.comparable_ty __Ex_comparable_ty_'a1) **
                    Alpha_context.context]) _ [__t_value, ctxt] in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =>
                let '(annot, tname) := function_parameter in
                typed ctxt loc (Script_typed_ir.Empty_set __t_value)
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Set_t __t_value tname) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Set_t comp_elt _) rest
            set_annot), _) =>
        let 'existT _ [__97, __98] [loc, body, annot, comp_elt, rest, set_annot]
          :=
          existT
            (fun '[__97, __98] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.comparable_ty __98) **
                (Script_typed_ir.stack_ty __97) **
                (option Script_typed_ir.var_annot)]) _
            [loc, body, annot, comp_elt, rest, set_annot] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] body)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                let elt_annot :=
                  Script_ir_annot.gen_access_annot set_annot None
                    Script_ir_annot.default_elt_annot in
                let elt := ty_of_comparable_ty comp_elt in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t elt rest elt_annot))
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =>
                      let 'existT _ __Typed_'aft6 [aft, ibody] :=
                        existT
                          (fun __Typed_'aft6 : Set =>
                            [(Script_typed_ir.stack_ty __Typed_'aft6) **
                              (Script_typed_ir.descr (__98 * __97) __Typed_'aft6)])
                          _ [aft, ibody] in
                      let invalid_iter_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let '_ := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            ibody.(Script_typed_ir.descr.aft))
                          (fun function_parameter =>
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt rest)
                              (fun function_parameter =>
                                let '(rest, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval invalid_iter_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 aft rest))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt aft rest))
                              (fun function_parameter =>
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Set_iter ibody)
                                  rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =>
                      typed ctxt loc
                        (Script_typed_ir.Set_iter (__descr_value rest)) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
          Script_typed_ir.Item_t v
            (Script_typed_ir.Item_t (Script_typed_ir.Set_t elt _) rest _) _), _)
        =>
        let 'existT _ [__102, __103, __99] [loc, annot, v, elt, rest] :=
          existT
            (fun '[__102, __103, __99] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __99) **
                (Script_typed_ir.comparable_ty __103) **
                (Script_typed_ir.stack_ty __102)]) _ [loc, annot, v, elt, rest]
          in
        let elt := ty_of_comparable_ty elt in
        Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
          (fun function_parameter =>
            let '(annot, tname) := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt elt v loc Alpha_context.Script.I_MEM 1 2)
              (fun function_parameter =>
                let '(Eq, _, ctxt) := function_parameter in
                typed ctxt loc Script_typed_ir.Set_mem
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
          Script_typed_ir.Item_t v
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Set_t elt tname) rest
                set_annot) _) _), _) =>
        let 'existT _ [__104, __109, __110]
          [loc, annot, v, elt, tname, rest, set_annot] :=
          existT
            (fun '[__104, __109, __110] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __104) **
                (Script_typed_ir.comparable_ty __110) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __109) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, v, elt, tname, rest, set_annot] in
        match comparable_ty_of_ty v with
        | None =>
          Error_monad.op_gtgteqquestion (unparse_ty ctxt v)
            (fun function_parameter =>
              let '(v, _ctxt) := function_parameter in
              Error_monad.fail extensible_type_value)
        | Some v =>
          Error_monad.op_gtgteqquestion
            (parse_var_annot loc (Some set_annot) annot)
            (fun annot =>
              Error_monad.op_gtgteqquestion
                (check_item_comparable_ty elt v loc
                  Alpha_context.Script.I_UPDATE 1 3)
                (fun function_parameter =>
                  let '(Eq, elt) := function_parameter in
                  typed ctxt loc Script_typed_ir.Set_update
                    (Script_typed_ir.Item_t (Script_typed_ir.Set_t elt tname)
                      rest annot)))
        end
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Set_t _ _) rest _), _) =>
        let 'existT _ __112 [loc, annot, rest] :=
          existT
            (fun __112 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __112)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Set_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_MAP
          (cons tk (cons tv [])) annot, stack), _) =>
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_comparable_ty ctxt tk))
          (fun function_parameter =>
            let '(Ex_comparable_ty tk, ctxt) := function_parameter in
            let 'existT _ __Ex_comparable_ty_'a2 [tk, ctxt] :=
              existT
                (fun __Ex_comparable_ty_'a2 : Set =>
                  [(Script_typed_ir.comparable_ty __Ex_comparable_ty_'a2) **
                    Alpha_context.context]) _ [tk, ctxt] in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy tv))
              (fun function_parameter =>
                let '(Ex_ty tv, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a6 [tv, ctxt] :=
                  existT
                    (fun __Ex_ty_'a6 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a6) **
                        Alpha_context.context]) _ [tv, ctxt] in
                Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
                  (fun function_parameter =>
                    let '(annot, ty_name) := function_parameter in
                    typed ctxt loc (Script_typed_ir.Empty_map tk tv)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Map_t tk tv ty_name (has_big_map tv))
                        stack annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Map_t ck elt _ _)
            starting_rest _map_annot), _) =>
        let 'existT _ [__115, __116, __117]
          [loc, body, annot, ck, elt, starting_rest, _map_annot] :=
          existT
            (fun '[__115, __116, __117] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.comparable_ty __116) **
                (Script_typed_ir.ty __117) ** (Script_typed_ir.stack_ty __115)
                ** (option Script_typed_ir.var_annot)]) _
            [loc, body, annot, ck, elt, starting_rest, _map_annot] in
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] body)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =>
                let '(ret_annot, ty_name) := function_parameter in
                let k_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_key_annot in
                let e_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_elt_annot in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t
                      (Script_typed_ir.Pair_t (k, None, k_name)
                        (elt, None, e_name) None (has_big_map elt))
                      starting_rest None))
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    |
                      Typed
                        ({|
                          Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _
                            |} as ibody) =>
                      let 'existT _ [__480, __481, __Typed_'aft7]
                        [ret, rest, ibody] :=
                        existT
                          (fun '[__480, __481, __Typed_'aft7] =>
                            [(Script_typed_ir.ty __480) **
                              (Script_typed_ir.stack_ty __481) **
                              (Script_typed_ir.descr
                                (Script_typed_ir.pair __116 __117 * __115)
                                __Typed_'aft7)]) _ [ret, rest, ibody] in
                      let invalid_map_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let '_ := function_parameter in
                        Error_monad.op_gtgtpipequestion
                          (serialize_stack_for_error ctxt
                            ibody.(Script_typed_ir.descr.aft))
                          (fun function_parameter =>
                            let '(aft, _ctxt) := function_parameter in
                            extensible_type_value) in
                      Error_monad.trace_eval invalid_map_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 rest starting_rest))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt rest starting_rest))
                              (fun function_parameter =>
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Map_map ibody)
                                  (Script_typed_ir.Item_t
                                    (Script_typed_ir.Map_t ck ret ty_name
                                      (has_big_map ret)) rest ret_annot))))
                    | Typed {| Script_typed_ir.descr.aft := aft |} =>
                      let 'existT _ __Typed_'aft8 aft :=
                        existT
                          (fun __Typed_'aft8 : Set =>
                            (Script_typed_ir.stack_ty __Typed_'aft8)) _ aft in
                      Error_monad.op_gtgteqquestion
                        (serialize_stack_for_error ctxt aft)
                        (fun function_parameter =>
                          let '(aft, _ctxt) := function_parameter in
                          Error_monad.fail extensible_type_value)
                    | Failed _ => Error_monad.fail extensible_type_value
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Map_t comp_elt element_ty _ _)
            rest _map_annot), _) =>
        let 'existT _ [__119, __120, __121]
          [loc, body, annot, comp_elt, element_ty, rest, _map_annot] :=
          existT
            (fun '[__119, __120, __121] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.comparable_ty __120) **
                (Script_typed_ir.ty __121) ** (Script_typed_ir.stack_ty __119)
                ** (option Script_typed_ir.var_annot)]) _
            [loc, body, annot, comp_elt, element_ty, rest, _map_annot] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] body)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                let k_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_key_annot in
                let e_name :=
                  Script_ir_annot.field_to_var_annot
                    Script_ir_annot.default_elt_annot in
                let key := ty_of_comparable_ty comp_elt in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t
                      (Script_typed_ir.Pair_t (key, None, k_name)
                        (element_ty, None, e_name) None (has_big_map element_ty))
                      rest None))
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =>
                      let 'existT _ __Typed_'aft9 [aft, ibody] :=
                        existT
                          (fun __Typed_'aft9 : Set =>
                            [(Script_typed_ir.stack_ty __Typed_'aft9) **
                              (Script_typed_ir.descr
                                (Script_typed_ir.pair __120 __121 * __119)
                                __Typed_'aft9)]) _ [aft, ibody] in
                      let invalid_iter_body (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let '_ := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            ibody.(Script_typed_ir.descr.aft))
                          (fun function_parameter =>
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt rest)
                              (fun function_parameter =>
                                let '(rest, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval invalid_iter_body
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1 aft rest))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt aft rest))
                              (fun function_parameter =>
                                let '(rest, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Map_iter ibody)
                                  rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =>
                      typed ctxt loc
                        (Script_typed_ir.Map_iter (__descr_value rest)) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck _ _ _) rest _) _),
          _) =>
        let 'existT _ [__122, __125, __126] [loc, annot, vk, ck, rest] :=
          existT
            (fun '[__122, __125, __126] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __122) **
                (Script_typed_ir.comparable_ty __126) **
                (Script_typed_ir.stack_ty __125)]) _ [loc, annot, vk, ck, rest]
          in
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_MEM 1 2)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                typed ctxt loc Script_typed_ir.Map_mem
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck elt _ has_big_map)
              rest _) _), _) =>
        let 'existT _ [__128, __131, __132, __133]
          [loc, annot, vk, ck, elt, has_big_map, rest] :=
          existT
            (fun '[__128, __131, __132, __133] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __128) **
                (Script_typed_ir.comparable_ty __132) **
                (Script_typed_ir.ty __133) ** bool **
                (Script_typed_ir.stack_ty __131)]) _
            [loc, annot, vk, ck, elt, has_big_map, rest] in
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                typed ctxt loc Script_typed_ir.Map_get
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t elt None has_big_map) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Option_t vv _ _)
              (Script_typed_ir.Item_t
                (Script_typed_ir.Map_t ck v map_name has_big_map) rest map_annot)
              _) _), _) =>
        let 'existT _ [__134, __138, __140, __141, __142]
          [loc, annot, vk, vv, ck, v, map_name, has_big_map, rest, map_annot] :=
          existT
            (fun '[__134, __138, __140, __141, __142] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __134) ** (Script_typed_ir.ty __138) **
                (Script_typed_ir.comparable_ty __141) **
                (Script_typed_ir.ty __142) **
                (option Script_typed_ir.type_annot) ** bool **
                (Script_typed_ir.stack_ty __140) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, vk, vv, ck, v, map_name, has_big_map, rest, map_annot]
          in
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_UPDATE 1 3)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt vv v loc Alpha_context.Script.I_UPDATE 2 3)
              (fun function_parameter =>
                let '(Eq, v, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_var_annot loc (Some map_annot) annot)
                  (fun annot =>
                    typed ctxt loc Script_typed_ir.Map_update
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Map_t ck v map_name has_big_map) rest
                        annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Map_t _ _ _ _) rest _), _) =>
        let 'existT _ __144 [loc, annot, rest] :=
          existT
            (fun __144 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __144)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Map_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_BIG_MAP
          (cons tk (cons tv [])) annot, stack), _) =>
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_comparable_ty ctxt tk))
          (fun function_parameter =>
            let '(Ex_comparable_ty tk, ctxt) := function_parameter in
            let 'existT _ __Ex_comparable_ty_'a3 [tk, ctxt] :=
              existT
                (fun __Ex_comparable_ty_'a3 : Set =>
                  [(Script_typed_ir.comparable_ty __Ex_comparable_ty_'a3) **
                    Alpha_context.context]) _ [tk, ctxt] in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (parse_packable_ty ctxt legacy tv))
              (fun function_parameter =>
                let '(Ex_ty tv, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a7 [tv, ctxt] :=
                  existT
                    (fun __Ex_ty_'a7 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a7) **
                        Alpha_context.context]) _ [tv, ctxt] in
                Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
                  (fun function_parameter =>
                    let '(annot, ty_name) := function_parameter in
                    typed ctxt loc (Script_typed_ir.Empty_big_map tk tv)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Big_map_t tk tv ty_name) stack annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
          Script_typed_ir.Item_t set_key
            (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t map_key _ _) rest
              _) _), _) =>
        let 'existT _ [__147, __150, __151] [loc, annot, set_key, map_key, rest]
          :=
          existT
            (fun '[__147, __150, __151] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __147) **
                (Script_typed_ir.comparable_ty __151) **
                (Script_typed_ir.stack_ty __150)]) _
            [loc, annot, set_key, map_key, rest] in
        let k := ty_of_comparable_ty map_key in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt set_key k loc Alpha_context.Script.I_MEM 1 2)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                typed ctxt loc Script_typed_ir.Big_map_mem
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
          Script_typed_ir.Item_t vk
            (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t ck elt _) rest _)
            _), _) =>
        let 'existT _ [__153, __156, __157, __158]
          [loc, annot, vk, ck, elt, rest] :=
          existT
            (fun '[__153, __156, __157, __158] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __153) **
                (Script_typed_ir.comparable_ty __157) **
                (Script_typed_ir.ty __158) ** (Script_typed_ir.stack_ty __156)])
            _ [loc, annot, vk, ck, elt, rest] in
        let k := ty_of_comparable_ty ck in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                typed ctxt loc Script_typed_ir.Big_map_get
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t elt None (has_big_map elt)) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
          Script_typed_ir.Item_t set_key
            (Script_typed_ir.Item_t (Script_typed_ir.Option_t set_value _ _)
              (Script_typed_ir.Item_t
                (Script_typed_ir.Big_map_t map_key map_value map_name) rest
                map_annot) _) _), _) =>
        let 'existT _ [__159, __163, __165, __166, __167]
          [loc, annot, set_key, set_value, map_key, map_value, map_name, rest,
            map_annot] :=
          existT
            (fun '[__159, __163, __165, __166, __167] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __159) ** (Script_typed_ir.ty __163) **
                (Script_typed_ir.comparable_ty __166) **
                (Script_typed_ir.ty __167) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __165) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, set_key, set_value, map_key, map_value, map_name, rest,
              map_annot] in
        let k := ty_of_comparable_ty map_key in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt set_key k loc Alpha_context.Script.I_UPDATE 1 3)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt set_value map_value loc
                Alpha_context.Script.I_UPDATE 2 3)
              (fun function_parameter =>
                let '(Eq, map_value, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_var_annot loc (Some map_annot) annot)
                  (fun annot =>
                    typed ctxt loc Script_typed_ir.Big_map_update
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Big_map_t map_key map_value map_name)
                        rest annot))))
      | ((Micheline.Seq loc [], stack), _) =>
        typed ctxt loc Script_typed_ir.Nop stack
      | ((Micheline.Seq loc (cons single []), stack), _) =>
        Error_monad.op_gtgteqquestion
          (parse_instr type_logger tc_context ctxt legacy single stack)
          (fun function_parameter =>
            let '(judgement, ctxt) := function_parameter in
            match judgement with
            | Typed ({| Script_typed_ir.descr.aft := aft |} as instr) =>
              let 'existT _ __Typed_'aft10 [aft, instr] :=
                existT
                  (fun __Typed_'aft10 : Set =>
                    [(Script_typed_ir.stack_ty __Typed_'aft10) **
                      (Script_typed_ir.descr bef __Typed_'aft10)]) _
                  [aft, instr] in
              let nop :=
                {| Script_typed_ir.descr.loc := loc;
                  Script_typed_ir.descr.bef := aft;
                  Script_typed_ir.descr.aft := aft;
                  Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
              typed ctxt loc (Script_typed_ir.Seq instr nop) aft
            | Failed {| judgement.Failed.descr := __descr_value |} =>
              let __descr_value {B : Set} (aft : Script_typed_ir.stack_ty B)
                : Script_typed_ir.descr bef B :=
                let nop :=
                  {| Script_typed_ir.descr.loc := loc;
                    Script_typed_ir.descr.bef := aft;
                    Script_typed_ir.descr.aft := aft;
                    Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
                let __descr_value := __descr_value aft in
                Script_typed_ir.descr.with_instr
                  (Script_typed_ir.Seq __descr_value nop) __descr_value in
              __return ctxt
                (Failed {| judgement.Failed.descr := __descr_value |})
            end)
      | ((Micheline.Seq loc (cons hd tl), stack), _) =>
        Error_monad.op_gtgteqquestion
          (parse_instr type_logger tc_context ctxt legacy hd stack)
          (fun function_parameter =>
            let '(judgement, ctxt) := function_parameter in
            match judgement with
            | Failed _ => Error_monad.fail extensible_type_value
            | Typed ({| Script_typed_ir.descr.aft := middle |} as ihd) =>
              let 'existT _ __Typed_'aft11 [middle, ihd] :=
                existT
                  (fun __Typed_'aft11 : Set =>
                    [(Script_typed_ir.stack_ty __Typed_'aft11) **
                      (Script_typed_ir.descr bef __Typed_'aft11)]) _
                  [middle, ihd] in
              Error_monad.op_gtgteqquestion
                (parse_instr type_logger tc_context ctxt legacy
                  (Micheline.Seq (-1) tl) middle)
                (fun function_parameter =>
                  let '(judgement, ctxt) := function_parameter in
                  match judgement with
                  | Failed {| judgement.Failed.descr := __descr_value |} =>
                    let __descr_value {B : Set}
                      (ret : Script_typed_ir.stack_ty B)
                      : Script_typed_ir.descr bef B :=
                      {| Script_typed_ir.descr.loc := loc;
                        Script_typed_ir.descr.bef := stack;
                        Script_typed_ir.descr.aft := ret;
                        Script_typed_ir.descr.instr :=
                          Script_typed_ir.Seq ihd (__descr_value ret) |} in
                    __return ctxt
                      (Failed {| judgement.Failed.descr := __descr_value |})
                  | Typed itl =>
                    let 'existT _ __Typed_'aft12 itl :=
                      existT
                        (fun __Typed_'aft12 : Set =>
                          (Script_typed_ir.descr __Typed_'aft11 __Typed_'aft12))
                        _ itl in
                    typed ctxt loc (Script_typed_ir.Seq ihd itl)
                      itl.(Script_typed_ir.descr.aft)
                  end)
            end)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IF (cons bt (cons bf []))
          annot,
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _) as bef), _)
        =>
        let 'existT _ __169 [loc, bt, bf, annot, rest, bef] :=
          existT
            (fun __169 : Set =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.stack_ty __169) **
                (Script_typed_ir.stack_ty (bool * __169))]) _
            [loc, bt, bf, annot, rest, bef] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] bt)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind [ Script_tc_errors.Seq_kind ] bf)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Script_ir_annot.fail_unexpected_annot loc annot)
                  (fun function_parameter =>
                    let '_ := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (parse_instr type_logger tc_context ctxt legacy bt rest)
                      (fun function_parameter =>
                        let '(btr, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (parse_instr type_logger tc_context ctxt legacy bf
                            rest)
                          (fun function_parameter =>
                            let '(bfr, ctxt) := function_parameter in
                            let branch {B : Set}
                              (ibt : Script_typed_ir.descr __169 B)
                              (ibf : Script_typed_ir.descr __169 B)
                              : Script_typed_ir.descr (bool * __169) B :=
                              {| Script_typed_ir.descr.loc := loc;
                                Script_typed_ir.descr.bef := bef;
                                Script_typed_ir.descr.aft :=
                                  ibt.(Script_typed_ir.descr.aft);
                                Script_typed_ir.descr.instr :=
                                  Script_typed_ir.If ibt ibf |} in
                            Error_monad.op_gtgteqquestion
                              (merge_branches legacy ctxt loc btr bfr
                                {| branch.branch := branch |})
                              (fun function_parameter =>
                                let '(judgement, ctxt) := function_parameter in
                                __return ctxt judgement))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LOOP (cons body []) annot,
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _stack_annot)
            as stack), _) =>
        let 'existT _ __171 [loc, body, annot, rest, _stack_annot, stack] :=
          existT
            (fun __171 : Set =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.stack_ty __171) **
                (option Script_typed_ir.var_annot) **
                (Script_typed_ir.stack_ty (bool * __171))]) _
            [loc, body, annot, rest, _stack_annot, stack] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] body)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body rest)
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ibody =>
                      let 'existT _ __Typed_'aft13 ibody :=
                        existT
                          (fun __Typed_'aft13 : Set =>
                            (Script_typed_ir.descr __171 __Typed_'aft13)) _
                          ibody in
                      let unmatched_branches (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let '_ := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            ibody.(Script_typed_ir.descr.aft))
                          (fun function_parameter =>
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt stack)
                              (fun function_parameter =>
                                let '(stack, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval unmatched_branches
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1
                              ibody.(Script_typed_ir.descr.aft) stack))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt
                                  ibody.(Script_typed_ir.descr.aft) stack))
                              (fun function_parameter =>
                                let '(_stack, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Loop ibody) rest)))
                    | Failed {| judgement.Failed.descr := __descr_value |} =>
                      let ibody := __descr_value stack in
                      typed ctxt loc (Script_typed_ir.Loop ibody) rest
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LOOP_LEFT (cons body [])
          annot,
          (Script_typed_ir.Item_t
            (Script_typed_ir.Union_t (tl, l_field) (tr, _) _ _) rest union_annot)
            as stack), _) =>
        let 'existT _ [__173, __174, __175]
          [loc, body, annot, tl, l_field, tr, rest, union_annot, stack] :=
          existT
            (fun '[__173, __174, __175] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __174) **
                (option Script_typed_ir.field_annot) **
                (Script_typed_ir.ty __175) ** (Script_typed_ir.stack_ty __173)
                ** (option Script_typed_ir.var_annot) **
                (Script_typed_ir.stack_ty
                  (Script_typed_ir.union __174 __175 * __173))]) _
            [loc, body, annot, tl, l_field, tr, rest, union_annot, stack] in
        Error_monad.op_gtgteqquestion
          (check_kind [ Script_tc_errors.Seq_kind ] body)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                let l_annot :=
                  Script_ir_annot.gen_access_annot union_annot
                    (Some Script_ir_annot.default_left_annot) l_field in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger tc_context ctxt legacy body
                    (Script_typed_ir.Item_t tl rest l_annot))
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed ibody =>
                      let 'existT _ __Typed_'aft14 ibody :=
                        existT
                          (fun __Typed_'aft14 : Set =>
                            (Script_typed_ir.descr (__174 * __173)
                              __Typed_'aft14)) _ ibody in
                      let unmatched_branches (function_parameter : unit)
                        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
                        let '_ := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (serialize_stack_for_error ctxt
                            ibody.(Script_typed_ir.descr.aft))
                          (fun function_parameter =>
                            let '(aft, ctxt) := function_parameter in
                            Error_monad.op_gtgtpipequestion
                              (serialize_stack_for_error ctxt stack)
                              (fun function_parameter =>
                                let '(stack, _ctxt) := function_parameter in
                                extensible_type_value)) in
                      Error_monad.trace_eval unmatched_branches
                        (Error_monad.op_gtgteqquestion
                          (Pervasives.op_atat Lwt.__return
                            (stack_ty_eq ctxt 1
                              ibody.(Script_typed_ir.descr.aft) stack))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            Error_monad.op_gtgteqquestion
                              (Pervasives.op_atat Lwt.__return
                                (merge_stacks legacy loc ctxt
                                  ibody.(Script_typed_ir.descr.aft) stack))
                              (fun function_parameter =>
                                let '(_stack, ctxt) := function_parameter in
                                typed ctxt loc (Script_typed_ir.Loop_left ibody)
                                  (Script_typed_ir.Item_t tr rest annot))))
                    | Failed {| judgement.Failed.descr := __descr_value |} =>
                      let ibody := __descr_value stack in
                      typed ctxt loc (Script_typed_ir.Loop_left ibody)
                        (Script_typed_ir.Item_t tr rest annot)
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
          (cons arg (cons ret (cons code []))) annot, stack), _) =>
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy arg))
          (fun function_parameter =>
            let '(Ex_ty arg, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a8 [arg, ctxt] :=
              existT
                (fun __Ex_ty_'a8 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a8) ** Alpha_context.context]) _
                [arg, ctxt] in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy ret))
              (fun function_parameter =>
                let '(Ex_ty ret, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a9 [ret, ctxt] :=
                  existT
                    (fun __Ex_ty_'a9 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a9) **
                        Alpha_context.context]) _ [ret, ctxt] in
                Error_monad.op_gtgteqquestion
                  (check_kind [ Script_tc_errors.Seq_kind ] code)
                  (fun function_parameter =>
                    let '_ := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (parse_var_annot loc None annot)
                      (fun annot =>
                        Error_monad.op_gtgteqquestion
                          (parse_returning type_logger Lambda ctxt legacy
                            (arg, Script_ir_annot.default_arg_annot) ret code)
                          (fun function_parameter =>
                            let '(lambda, ctxt) := function_parameter in
                            typed ctxt loc (Script_typed_ir.Lambda lambda)
                              (Script_typed_ir.Item_t
                                (Script_typed_ir.Lambda_t arg ret None) stack
                                annot))))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EXEC [] annot,
          Script_typed_ir.Item_t arg
            (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t param ret _) rest
              _) _), _) =>
        let 'existT _ [__176, __179, __180, __181]
          [loc, annot, arg, param, ret, rest] :=
          existT
            (fun '[__176, __179, __180, __181] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __176) ** (Script_typed_ir.ty __180) **
                (Script_typed_ir.ty __181) ** (Script_typed_ir.stack_ty __179)])
            _ [loc, annot, arg, param, ret, rest] in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt arg param loc Alpha_context.Script.I_EXEC 1 2)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                typed ctxt loc Script_typed_ir.Exec
                  (Script_typed_ir.Item_t ret rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_APPLY [] annot,
          Script_typed_ir.Item_t capture
            (Script_typed_ir.Item_t
              (Script_typed_ir.Lambda_t
                (Script_typed_ir.Pair_t (capture_ty, _, _) (arg_ty, _, _)
                  lam_annot _) ret _) rest _) _), _) =>
        let 'existT _ [__182, __185, __187, __188, __189]
          [loc, annot, capture, capture_ty, arg_ty, lam_annot, ret, rest] :=
          existT
            (fun '[__182, __185, __187, __188, __189] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __182) ** (Script_typed_ir.ty __188) **
                (Script_typed_ir.ty __189) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.ty __187) ** (Script_typed_ir.stack_ty __185)])
            _ [loc, annot, capture, capture_ty, arg_ty, lam_annot, ret, rest] in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (check_packable false loc capture_ty))
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt capture capture_ty loc
                Alpha_context.Script.I_APPLY 1 2)
              (fun function_parameter =>
                let '(Eq, capture_ty, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
                  (fun annot =>
                    typed ctxt loc (Script_typed_ir.Apply capture_ty)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Lambda_t arg_ty ret lam_annot) rest
                        annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons code []) annot,
          Script_typed_ir.Item_t v rest stack_annot), _) =>
        let 'existT _ [__190, __191] [loc, code, annot, v, rest, stack_annot] :=
          existT
            (fun '[__190, __191] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __190) ** (Script_typed_ir.stack_ty __191)
                ** (option Script_typed_ir.var_annot)]) _
            [loc, code, annot, v, rest, stack_annot] in
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (check_kind [ Script_tc_errors.Seq_kind ] code)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (parse_instr type_logger (add_dip v stack_annot tc_context)
                    ctxt legacy code rest)
                  (fun function_parameter =>
                    let '(judgement, ctxt) := function_parameter in
                    match judgement with
                    | Typed __descr_value =>
                      let 'existT _ __Typed_'aft15 __descr_value :=
                        existT
                          (fun __Typed_'aft15 : Set =>
                            (Script_typed_ir.descr __191 __Typed_'aft15)) _
                          __descr_value in
                      typed ctxt loc (Script_typed_ir.Dip __descr_value)
                        (Script_typed_ir.Item_t v
                          __descr_value.(Script_typed_ir.descr.aft) stack_annot)
                    | Failed _ => Error_monad.fail extensible_type_value
                    end)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons n (cons code []))
          result_annot, stack), true) =>
        let fix make_proof_argument {tstk : Set}
          (n : Z) (inner_tc_context : tc_context)
          (stk : Script_typed_ir.stack_ty tstk) {struct n}
          : Lwt.t (Error_monad.tzresult (dipn_proof_argument tstk)) :=
          match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
          | (true, rest) =>
            Error_monad.op_gtgteqquestion
              (parse_instr type_logger inner_tc_context ctxt legacy code rest)
              (fun function_parameter =>
                let '(judgement, ctxt) := function_parameter in
                match judgement with
                | Typed __descr_value =>
                  let 'existT _ __Typed_'aft16 __descr_value :=
                    existT
                      (fun __Typed_'aft16 : Set =>
                        (Script_typed_ir.descr tstk __Typed_'aft16)) _
                      __descr_value in
                  Pervasives.op_atat outer_return
                    (Dipn_proof_argument
                      (Script_typed_ir.Rest, (ctxt, __descr_value),
                        __descr_value.(Script_typed_ir.descr.aft)))
                | Failed _ => Error_monad.fail extensible_type_value
                end)
          | (false, Script_typed_ir.Item_t v rest annot) =>
            let 'existT _ [__482, __483] [v, rest, annot] :=
              existT
                (fun '[__482, __483] =>
                  [(Script_typed_ir.ty __482) **
                    (Script_typed_ir.stack_ty __483) **
                    (option Script_typed_ir.var_annot)]) _ [v, rest, annot] in
            Error_monad.op_gtgteqquestion
              (make_proof_argument (Pervasives.op_minus n 1)
                (add_dip v annot tc_context) rest)
              (fun function_parameter =>
                let 'Dipn_proof_argument (n', __descr_value, aft') :=
                  function_parameter in
                let 'existT _
                  [__Dipn_proof_argument_'aft, __Dipn_proof_argument_'faft,
                    __Dipn_proof_argument_'fbef] [n', __descr_value, aft'] :=
                  existT
                    (fun
                      '[__Dipn_proof_argument_'aft, __Dipn_proof_argument_'faft,
                        __Dipn_proof_argument_'fbef] =>
                      [(Script_typed_ir.stack_prefix_preservation_witness
                        __Dipn_proof_argument_'fbef __Dipn_proof_argument_'faft
                        __483 __Dipn_proof_argument_'aft) **
                        (Alpha_context.context *
                          Script_typed_ir.descr __Dipn_proof_argument_'fbef
                            __Dipn_proof_argument_'faft) **
                        (Script_typed_ir.stack_ty __Dipn_proof_argument_'aft)])
                    _ [n', __descr_value, aft'] in
                Pervasives.op_atat outer_return
                  (Dipn_proof_argument
                    ((Script_typed_ir.Prefix n'), __descr_value,
                      (Script_typed_ir.Item_t v aft' annot))))
          | (_, _) =>
            Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
              (fun function_parameter =>
                let '(whole_stack, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value)
          end in
        Error_monad.op_gtgteqquestion (Lwt.__return (parse_int32 n))
          (fun n =>
            Error_monad.op_gtgteqquestion
              (Script_ir_annot.fail_unexpected_annot loc result_annot)
              (fun function_parameter =>
                let '_ := function_parameter in
                Error_monad.op_gtgteqquestion
                  (make_proof_argument n tc_context stack)
                  (fun function_parameter =>
                    let
                      'Dipn_proof_argument (n', (new_ctxt, __descr_value), aft) :=
                      function_parameter in
                    let 'existT _
                      [__Dipn_proof_argument_'aft1,
                        __Dipn_proof_argument_'faft1,
                        __Dipn_proof_argument_'fbef1]
                      [n', new_ctxt, __descr_value, aft] :=
                      existT
                        (fun
                          '[__Dipn_proof_argument_'aft1,
                            __Dipn_proof_argument_'faft1,
                            __Dipn_proof_argument_'fbef1] =>
                          [(Script_typed_ir.stack_prefix_preservation_witness
                            __Dipn_proof_argument_'fbef1
                            __Dipn_proof_argument_'faft1 bef
                            __Dipn_proof_argument_'aft1) **
                            Alpha_context.context **
                            (Script_typed_ir.descr __Dipn_proof_argument_'fbef1
                              __Dipn_proof_argument_'faft1) **
                            (Script_typed_ir.stack_ty
                              __Dipn_proof_argument_'aft1)]) _
                        [n', new_ctxt, __descr_value, aft] in
                    typed new_ctxt loc (Script_typed_ir.Dipn n n' __descr_value)
                      aft)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_DIP
          (([] | cons _ (cons _ (cons _ _))) as l) _, _), _) =>
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_FAILWITH [] annot,
          Script_typed_ir.Item_t v _rest _), _) =>
        let 'existT _ [__192, __193] [loc, annot, v, _rest] :=
          existT
            (fun '[__192, __193] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __192) ** (Script_typed_ir.stack_ty __193)])
            _ [loc, annot, v, _rest] in
        Error_monad.op_gtgteqquestion
          (Script_ir_annot.fail_unexpected_annot loc annot)
          (fun function_parameter =>
            let '_ := function_parameter in
            let __descr_value {B : Set} (aft : Script_typed_ir.stack_ty B)
              : Script_typed_ir.descr bef B :=
              {| Script_typed_ir.descr.loc := loc;
                Script_typed_ir.descr.bef := stack_ty;
                Script_typed_ir.descr.aft := aft;
                Script_typed_ir.descr.instr := Script_typed_ir.Failwith v |} in
            Error_monad.op_gtgteqquestion
              (log_stack ctxt loc stack_ty Script_typed_ir.Empty_t)
              (fun function_parameter =>
                let '_ := function_parameter in
                __return ctxt
                  (Failed {| judgement.Failed.descr := __descr_value |})))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =>
        let 'existT _ __197 [loc, annot, tname, rest] :=
          existT
            (fun __197 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __197)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Add_timestamp_to_seconds
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest _)
            _), _) =>
        let 'existT _ __201 [loc, annot, tname, rest] :=
          existT
            (fun __201 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __201)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Add_seconds_to_timestamp
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =>
        let 'existT _ __205 [loc, annot, tname, rest] :=
          existT
            (fun __205 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __205)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Sub_timestamp_seconds
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn2) rest _) _),
          _) =>
        let 'existT _ __209 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __209 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __209)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Diff_timestamps
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.String_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.String_t tn2) rest _) _), _)
        =>
        let 'existT _ __213 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __213 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __213)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Concat_string_pair
                  (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.List_t (Script_typed_ir.String_t tname) _ _) rest
            list_annot), _) =>
        let 'existT _ __215 [loc, annot, tname, rest, list_annot] :=
          existT
            (fun __215 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __215) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, tname, rest, list_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some list_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Concat_string
              (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
                string_annot) _) _), _) =>
        let 'existT _ __222 [loc, annot, tname, rest, string_annot] :=
          existT
            (fun __222 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __222) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, tname, rest, string_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc
            (Some
              (Script_ir_annot.gen_access_annot string_annot None
                Script_ir_annot.default_slice_annot)) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Slice_string
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t (Script_typed_ir.String_t tname) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.String_t _) rest _), _) =>
        let 'existT _ __224 [loc, annot, rest] :=
          existT
            (fun __224 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __224)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.String_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn2) rest _) _), _)
        =>
        let 'existT _ __228 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __228 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __228)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Concat_bytes_pair
                  (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.List_t (Script_typed_ir.Bytes_t tname) _ _) rest
            list_annot), _) =>
        let 'existT _ __230 [loc, annot, tname, rest, list_annot] :=
          existT
            (fun __230 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __230) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, tname, rest, list_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some list_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Concat_bytes
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest
                bytes_annot) _) _), _) =>
        let 'existT _ __237 [loc, annot, tname, rest, bytes_annot] :=
          existT
            (fun __237 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __237) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, tname, rest, bytes_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc
            (Some
              (Script_ir_annot.gen_access_annot bytes_annot None
                Script_ir_annot.default_slice_annot)) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Slice_bytes
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t (Script_typed_ir.Bytes_t tname) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
        let 'existT _ __239 [loc, annot, rest] :=
          existT
            (fun __239 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __239)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Bytes_size
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _)
        =>
        let 'existT _ __243 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __243 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __243)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Add_tez
                  (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _)
        =>
        let 'existT _ __247 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __247 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __247)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Sub_tez
                  (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
        let 'existT _ __251 [loc, annot, tname, rest] :=
          existT
            (fun __251 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __251)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Mul_teznat
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest _) _),
          _) =>
        let 'existT _ __255 [loc, annot, tname, rest] :=
          existT
            (fun __255 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __255)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Mul_nattez
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _)
        =>
        let 'existT _ __259 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __259 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __259)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Or
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _)
        =>
        let 'existT _ __263 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __263 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __263)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.And
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _)
        =>
        let 'existT _ __267 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __267 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __267)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Xor
                  (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest _), _) =>
        let 'existT _ __269 [loc, annot, tname, rest] :=
          existT
            (fun __269 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __269)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Not
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ABS [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
        let 'existT _ __271 [loc, annot, rest] :=
          existT
            (fun __271 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __271)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Abs_int
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ISNAT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest int_annot), _)
        =>
        let 'existT _ __273 [loc, annot, rest, int_annot] :=
          existT
            (fun __273 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __273) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, rest, int_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some int_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Is_nat
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t (Script_typed_ir.Nat_t None) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_INT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =>
        let 'existT _ __275 [loc, annot, rest] :=
          existT
            (fun __275 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __275)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Int_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =>
        let 'existT _ __277 [loc, annot, tname, rest] :=
          existT
            (fun __277 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __277)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Neg_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =>
        let 'existT _ __279 [loc, annot, rest] :=
          existT
            (fun __279 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __279)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Neg_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =>
        let 'existT _ __283 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __283 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __283)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Add_intint
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
        let 'existT _ __287 [loc, annot, tname, rest] :=
          existT
            (fun __287 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __287)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Add_intnat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _)
        =>
        let 'existT _ __291 [loc, annot, tname, rest] :=
          existT
            (fun __291 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __291)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Add_natint
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __295 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __295 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __295)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Add_natnat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =>
        let 'existT _ __299 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __299 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __299)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Sub_int
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
        let 'existT _ __303 [loc, annot, tname, rest] :=
          existT
            (fun __303 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __303)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Sub_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _)
        =>
        let 'existT _ __307 [loc, annot, tname, rest] :=
          existT
            (fun __307 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __307)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Sub_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __311 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __311 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __311)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun _tname =>
                typed ctxt loc Script_typed_ir.Sub_int
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =>
        let 'existT _ __315 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __315 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __315)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Mul_intint
                  (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
        let 'existT _ __319 [loc, annot, tname, rest] :=
          existT
            (fun __319 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __319)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Mul_intnat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _)
        =>
        let 'existT _ __323 [loc, annot, tname, rest] :=
          existT
            (fun __323 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __323)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Mul_natint
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __327 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __327 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __327)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Mul_natnat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
        let 'existT _ __331 [loc, annot, tname, rest] :=
          existT
            (fun __331 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __331)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Ediv_teznat
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t
                  (Script_typed_ir.Pair_t
                    ((Script_typed_ir.Mutez_t tname), None, None)
                    ((Script_typed_ir.Mutez_t tname), None, None) None false)
                  None false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _)
        =>
        let 'existT _ __335 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __335 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __335)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Ediv_tez
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t
                      (Script_typed_ir.Pair_t
                        ((Script_typed_ir.Nat_t None), None, None)
                        ((Script_typed_ir.Mutez_t tname), None, None) None false)
                      None false) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _)
        =>
        let 'existT _ __339 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __339 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __339)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Ediv_intint
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t
                      (Script_typed_ir.Pair_t
                        ((Script_typed_ir.Int_t tname), None, None)
                        ((Script_typed_ir.Nat_t None), None, None) None false)
                      None false) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =>
        let 'existT _ __343 [loc, annot, tname, rest] :=
          existT
            (fun __343 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __343)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Ediv_intnat
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t
                  (Script_typed_ir.Pair_t
                    ((Script_typed_ir.Int_t tname), None, None)
                    ((Script_typed_ir.Nat_t None), None, None) None false) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname)
            (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =>
        let 'existT _ __347 [loc, annot, tname, rest] :=
          existT
            (fun __347 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __347)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Ediv_natint
              (Script_typed_ir.Item_t
                (Script_typed_ir.Option_t
                  (Script_typed_ir.Pair_t
                    ((Script_typed_ir.Int_t None), None, None)
                    ((Script_typed_ir.Nat_t tname), None, None) None false) None
                  false) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __351 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __351 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __351)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Ediv_natnat
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t
                      (Script_typed_ir.Pair_t
                        ((Script_typed_ir.Nat_t tname), None, None)
                        ((Script_typed_ir.Nat_t tname), None, None) None false)
                      None false) rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LSL [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __355 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __355 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __355)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Lsl_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LSR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __359 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __359 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __359)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Lsr_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __363 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __363 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __363)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Or_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __367 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __367 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __367)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.And_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest _) _), _)
        =>
        let 'existT _ __371 [loc, annot, tname, rest] :=
          existT
            (fun __371 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __371)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.And_int_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
            (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _)
        =>
        let 'existT _ __375 [loc, annot, tn1, tn2, rest] :=
          existT
            (fun __375 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __375)]) _
            [loc, annot, tn1, tn2, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Script_ir_annot.merge_type_annot legacy tn1 tn2))
              (fun tname =>
                typed ctxt loc Script_typed_ir.Xor_nat
                  (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =>
        let 'existT _ __377 [loc, annot, tname, rest] :=
          existT
            (fun __377 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (option Script_typed_ir.type_annot) **
                (Script_typed_ir.stack_ty __377)]) _ [loc, annot, tname, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Not_int
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =>
        let 'existT _ __379 [loc, annot, rest] :=
          existT
            (fun __379 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __379)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Not_nat
              (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_COMPARE [] annot,
          Script_typed_ir.Item_t t1 (Script_typed_ir.Item_t t2 rest _) _), _) =>
        let 'existT _ [__380, __382, __383] [loc, annot, t1, t2, rest] :=
          existT
            (fun '[__380, __382, __383] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __380) ** (Script_typed_ir.ty __382) **
                (Script_typed_ir.stack_ty __383)]) _ [loc, annot, t1, t2, rest]
          in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (check_item_ty ctxt t1 t2 loc Alpha_context.Script.I_COMPARE 1 2)
              (fun function_parameter =>
                let '(Eq, __t_value, ctxt) := function_parameter in
                match comparable_ty_of_ty __t_value with
                | None =>
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return (serialize_ty_for_error ctxt __t_value))
                    (fun function_parameter =>
                      let '(__t_value, _ctxt) := function_parameter in
                      Error_monad.fail extensible_type_value)
                | Some key =>
                  typed ctxt loc (Script_typed_ir.Compare key)
                    (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest
                      annot)
                end))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_EQ [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
        let 'existT _ __385 [loc, annot, rest] :=
          existT
            (fun __385 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __385)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Eq
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_NEQ [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
        let 'existT _ __387 [loc, annot, rest] :=
          existT
            (fun __387 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __387)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Neq
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
        let 'existT _ __389 [loc, annot, rest] :=
          existT
            (fun __389 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __389)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Lt
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
        let 'existT _ __391 [loc, annot, rest] :=
          existT
            (fun __391 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __391)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Gt
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
        let 'existT _ __393 [loc, annot, rest] :=
          existT
            (fun __393 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __393)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Le
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_GE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =>
        let 'existT _ __395 [loc, annot, rest] :=
          existT
            (fun __395 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __395)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Ge
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CAST (cons cast_t []) annot,
          Script_typed_ir.Item_t __t_value stack item_annot), _) =>
        let 'existT _ [__396, __397]
          [loc, cast_t, annot, __t_value, stack, item_annot] :=
          existT
            (fun '[__396, __397] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __396) ** (Script_typed_ir.stack_ty __397)
                ** (option Script_typed_ir.var_annot)]) _
            [loc, cast_t, annot, __t_value, stack, item_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some item_annot) annot)
          (fun annot =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (parse_any_ty ctxt legacy cast_t))
              (fun function_parameter =>
                let '(Ex_ty cast_t, ctxt) := function_parameter in
                let 'existT _ __Ex_ty_'a10 [cast_t, ctxt] :=
                  existT
                    (fun __Ex_ty_'a10 : Set =>
                      [(Script_typed_ir.ty __Ex_ty_'a10) **
                        Alpha_context.context]) _ [cast_t, ctxt] in
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat Lwt.__return (ty_eq ctxt cast_t __t_value))
                  (fun function_parameter =>
                    let '(Eq, ctxt) := function_parameter in
                    Error_monad.op_gtgteqquestion
                      (Pervasives.op_atat Lwt.__return
                        (merge_types legacy ctxt loc cast_t __t_value))
                      (fun function_parameter =>
                        let '(_, ctxt) := function_parameter in
                        typed ctxt loc Script_typed_ir.Nop
                          (Script_typed_ir.Item_t cast_t stack annot)))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_RENAME [] annot,
          Script_typed_ir.Item_t __t_value stack _), _) =>
        let 'existT _ [__398, __399] [loc, annot, __t_value, stack] :=
          existT
            (fun '[__398, __399] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __398) ** (Script_typed_ir.stack_ty __399)])
            _ [loc, annot, __t_value, stack] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Nop
              (Script_typed_ir.Item_t __t_value stack annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_PACK [] annot,
          Script_typed_ir.Item_t __t_value rest unpacked_annot), _) =>
        let 'existT _ [__400, __401]
          [loc, annot, __t_value, rest, unpacked_annot] :=
          existT
            (fun '[__400, __401] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __400) ** (Script_typed_ir.stack_ty __401)
                ** (option Script_typed_ir.var_annot)]) _
            [loc, annot, __t_value, rest, unpacked_annot] in
        Error_monad.op_gtgteqquestion
          (Lwt.__return (check_packable true loc __t_value))
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgteqquestion
              (parse_var_annot loc
                (Some
                  (Script_ir_annot.gen_access_annot unpacked_annot None
                    Script_ir_annot.default_pack_annot)) annot)
              (fun annot =>
                typed ctxt loc (Script_typed_ir.Pack __t_value)
                  (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_UNPACK (cons ty []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest packed_annot),
          _) =>
        let 'existT _ __403 [loc, ty, annot, rest, packed_annot] :=
          existT
            (fun __403 : Set =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.stack_ty __403) **
                (option Script_typed_ir.var_annot)]) _
            [loc, ty, annot, rest, packed_annot] in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_packable_ty ctxt legacy ty))
          (fun function_parameter =>
            let '(Ex_ty __t_value, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a11 [__t_value, ctxt] :=
              existT
                (fun __Ex_ty_'a11 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a11) ** Alpha_context.context])
                _ [__t_value, ctxt] in
            Error_monad.op_gtgteqquestion (parse_var_type_annot loc annot)
              (fun function_parameter =>
                let '(annot, ty_name) := function_parameter in
                let annot :=
                  Script_ir_annot.default_annot
                    (Script_ir_annot.gen_access_annot packed_annot None
                      Script_ir_annot.default_unpack_annot) annot in
                typed ctxt loc (Script_typed_ir.Unpack __t_value)
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Option_t __t_value ty_name false) rest
                    annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_ADDRESS [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Contract_t _ _) rest
            contract_annot), _) =>
        let 'existT _ __405 [loc, annot, rest, contract_annot] :=
          existT
            (fun __405 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __405) **
                (option Script_typed_ir.var_annot)]) _
            [loc, annot, rest, contract_annot] in
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc
            (Some
              (Script_ir_annot.gen_access_annot contract_annot None
                Script_ir_annot.default_addr_annot)) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Address
              (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CONTRACT (cons ty []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Address_t _) rest addr_annot),
          _) =>
        let 'existT _ __408 [loc, ty, annot, rest, addr_annot] :=
          existT
            (fun __408 : Set =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.stack_ty __408) **
                (option Script_typed_ir.var_annot)]) _
            [loc, ty, annot, rest, addr_annot] in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (parse_parameter_ty ctxt legacy ty))
          (fun function_parameter =>
            let '(Ex_ty __t_value, ctxt) := function_parameter in
            let 'existT _ __Ex_ty_'a12 [__t_value, ctxt] :=
              existT
                (fun __Ex_ty_'a12 : Set =>
                  [(Script_typed_ir.ty __Ex_ty_'a12) ** Alpha_context.context])
                _ [__t_value, ctxt] in
            Error_monad.op_gtgteqquestion
              (parse_entrypoint_annot loc
                (Some
                  (Script_ir_annot.gen_access_annot addr_annot None
                    Script_ir_annot.default_contract_annot)) annot)
              (fun function_parameter =>
                let '(annot, entrypoint) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat Lwt.__return
                    match entrypoint with
                    | None => Pervasives.Ok "default"
                    | Some (Field_annot "default") =>
                      Error_monad.__error_value extensible_type_value
                    | Some (Field_annot entrypoint) =>
                      if
                        (|Compare.Int|).(Compare.S.op_gt)
                          (String.length entrypoint) 31 then
                        Error_monad.__error_value extensible_type_value
                      else
                        Pervasives.Ok entrypoint
                    end)
                  (fun entrypoint =>
                    typed ctxt loc
                      (Script_typed_ir.Contract __t_value entrypoint)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Option_t
                          (Script_typed_ir.Contract_t __t_value None) None false)
                        rest annot))))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] annot,
          Script_typed_ir.Item_t p
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Contract_t cp _) rest _)
              _) _), _) =>
        let 'existT _ [__409, __414, __415] [loc, annot, p, cp, rest] :=
          existT
            (fun '[__409, __414, __415] =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.ty __409) ** (Script_typed_ir.ty __415) **
                (Script_typed_ir.stack_ty __414)]) _ [loc, annot, p, cp, rest]
          in
        Error_monad.op_gtgteqquestion
          (check_item_ty ctxt p cp loc Alpha_context.Script.I_TRANSFER_TOKENS 1
            4)
          (fun function_parameter =>
            let '(Eq, _, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
              (fun annot =>
                typed ctxt loc Script_typed_ir.Transfer_tokens
                  (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
                    rest annot)))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SET_DELEGATE [] annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _) rest _),
          _) =>
        let 'existT _ __417 [loc, annot, rest] :=
          existT
            (fun __417 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __417)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Set_delegate
              (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
            (Script_typed_ir.Item_t
              (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
                (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _) rest _) _) _)
            _), _) =>
        let 'existT _ __427 [loc, annot, rest] :=
          existT
            (fun __427 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __427)]) _ [loc, annot, rest] in
        if legacy then
          Error_monad.op_gtgteqquestion (parse_two_var_annot loc annot)
            (fun function_parameter =>
              let '(op_annot, addr_annot) := function_parameter in
              typed ctxt loc Script_typed_ir.Create_account
                (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
                  (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
                    addr_annot) op_annot))
        else
          Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_IMPLICIT_ACCOUNT [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _) rest _), _) =>
        let 'existT _ __429 [loc, annot, rest] :=
          existT
            (fun __429 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __429)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Implicit_account
              (Script_typed_ir.Item_t
                (Script_typed_ir.Contract_t (Script_typed_ir.Unit_t None) None)
                rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
          (cons ((Micheline.Seq _ _) as code) []) annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
            (Script_typed_ir.Item_t
              (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
                (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
                  (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
                    (Script_typed_ir.Item_t ginit rest _) _) _) _) _) _), _) =>
        let 'existT _ [__441, __442] [loc, code, annot, ginit, rest] :=
          existT
            (fun '[__441, __442] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __441) ** (Script_typed_ir.stack_ty __442)])
            _ [loc, code, annot, ginit, rest] in
        if legacy then
          Error_monad.op_gtgteqquestion (parse_two_var_annot loc annot)
            (fun function_parameter =>
              let '(op_annot, addr_annot) := function_parameter in
              let cannonical_code :=
                Pervasives.op_atat Pervasives.fst
                  (Micheline.extract_locations code) in
              Error_monad.op_gtgteqquestion
                (Pervasives.op_atat Lwt.__return
                  (parse_toplevel legacy cannonical_code))
                (fun function_parameter =>
                  let '(arg_type, storage_type, code_field, root_name) :=
                    function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Error_monad.trace extensible_type_value
                      (Pervasives.op_atat Lwt.__return
                        (parse_parameter_ty ctxt legacy arg_type)))
                    (fun function_parameter =>
                      let '(Ex_ty arg_type, ctxt) := function_parameter in
                      let 'existT _ __Ex_ty_'a13 [arg_type, ctxt] :=
                        existT
                          (fun __Ex_ty_'a13 : Set =>
                            [(Script_typed_ir.ty __Ex_ty_'a13) **
                              Alpha_context.context]) _ [arg_type, ctxt] in
                      Error_monad.op_gtgteqquestion
                        (if legacy then
                          Error_monad.__return tt
                        else
                          Lwt.__return
                            (well_formed_entrypoints arg_type root_name))
                        (fun function_parameter =>
                          let '_ := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (Error_monad.trace extensible_type_value
                              (Pervasives.op_atat Lwt.__return
                                (parse_storage_ty ctxt legacy storage_type)))
                            (fun function_parameter =>
                              let '(Ex_ty storage_type, ctxt) :=
                                function_parameter in
                              let 'existT _ __Ex_ty_'a14 [storage_type, ctxt] :=
                                existT
                                  (fun __Ex_ty_'a14 : Set =>
                                    [(Script_typed_ir.ty __Ex_ty_'a14) **
                                      Alpha_context.context]) _
                                  [storage_type, ctxt] in
                              let arg_annot :=
                                Script_ir_annot.default_annot
                                  Script_ir_annot.default_param_annot
                                  (Script_ir_annot.type_to_var_annot
                                    (name_of_ty arg_type)) in
                              let storage_annot :=
                                Script_ir_annot.default_annot
                                  Script_ir_annot.default_storage_annot
                                  (Script_ir_annot.type_to_var_annot
                                    (name_of_ty storage_type)) in
                              let arg_type_full :=
                                Script_typed_ir.Pair_t
                                  (arg_type, None, arg_annot)
                                  (storage_type, None, storage_annot) None
                                  (Pervasives.op_pipepipe (has_big_map arg_type)
                                    (has_big_map storage_type)) in
                              let ret_type_full :=
                                Script_typed_ir.Pair_t
                                  ((Script_typed_ir.List_t
                                    (Script_typed_ir.Operation_t None) None
                                    false), None, None)
                                  (storage_type, None, None) None
                                  (has_big_map storage_type) in
                              Error_monad.op_gtgteqquestion
                                (Error_monad.trace extensible_type_value
                                  (parse_returning type_logger
                                    (Toplevel
                                      {|
                                        tc_context.Toplevel.storage_type :=
                                          storage_type;
                                        tc_context.Toplevel.param_type :=
                                          arg_type;
                                        tc_context.Toplevel.root_name :=
                                          root_name;
                                        tc_context.Toplevel.legacy_create_contract_literal :=
                                          true |}) ctxt legacy
                                    (arg_type_full, None) ret_type_full
                                    code_field))
                                (fun function_parameter =>
                                  let
                                    '((Script_typed_ir.Lam {|
                                      Script_typed_ir.descr.bef :=
                                        Script_typed_ir.Item_t arg
                                          Script_typed_ir.Empty_t
                                          _;
                                        Script_typed_ir.descr.aft :=
                                          Script_typed_ir.Item_t
                                            ret
                                            Script_typed_ir.Empty_t
                                            _
                                        |} _) as lambda, ctxt) :=
                                    function_parameter in
                                  Error_monad.op_gtgteqquestion
                                    (Pervasives.op_atat Lwt.__return
                                      (ty_eq ctxt arg arg_type_full))
                                    (fun function_parameter =>
                                      let '(Eq, ctxt) := function_parameter in
                                      Error_monad.op_gtgteqquestion
                                        (Pervasives.op_atat Lwt.__return
                                          (merge_types legacy ctxt loc arg
                                            arg_type_full))
                                        (fun function_parameter =>
                                          let '(_, ctxt) := function_parameter
                                            in
                                          Error_monad.op_gtgteqquestion
                                            (Pervasives.op_atat Lwt.__return
                                              (ty_eq ctxt ret ret_type_full))
                                            (fun function_parameter =>
                                              let '(Eq, ctxt) :=
                                                function_parameter in
                                              Error_monad.op_gtgteqquestion
                                                (Pervasives.op_atat Lwt.__return
                                                  (merge_types legacy ctxt loc
                                                    ret ret_type_full))
                                                (fun function_parameter =>
                                                  let '(_, ctxt) :=
                                                    function_parameter in
                                                  Error_monad.op_gtgteqquestion
                                                    (Pervasives.op_atat
                                                      Lwt.__return
                                                      (ty_eq ctxt storage_type
                                                        ginit))
                                                    (fun function_parameter =>
                                                      let '(Eq, ctxt) :=
                                                        function_parameter in
                                                      Error_monad.op_gtgteqquestion
                                                        (Pervasives.op_atat
                                                          Lwt.__return
                                                          (merge_types legacy
                                                            ctxt loc
                                                            storage_type ginit))
                                                        (fun function_parameter
                                                          =>
                                                          let '(_, ctxt) :=
                                                            function_parameter
                                                            in
                                                          typed ctxt loc
                                                            (Script_typed_ir.Create_contract
                                                              storage_type
                                                              arg_type lambda
                                                              root_name)
                                                            (Script_typed_ir.Item_t
                                                              (Script_typed_ir.Operation_t
                                                                None)
                                                              (Script_typed_ir.Item_t
                                                                (Script_typed_ir.Address_t
                                                                  None) rest
                                                                addr_annot)
                                                              op_annot)))))))))))))
        else
          Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
          (cons ((Micheline.Seq _ _) as code) []) annot,
          Script_typed_ir.Item_t
            (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
              (Script_typed_ir.Item_t ginit rest _) _) _), _) =>
        let 'existT _ [__448, __449] [loc, code, annot, ginit, rest] :=
          existT
            (fun '[__448, __449] =>
              [Alpha_context.Script.location **
                (Micheline.node Alpha_context.Script.location
                  Alpha_context.Script.prim) ** Micheline.annot **
                (Script_typed_ir.ty __448) ** (Script_typed_ir.stack_ty __449)])
            _ [loc, code, annot, ginit, rest] in
        Error_monad.op_gtgteqquestion (parse_two_var_annot loc annot)
          (fun function_parameter =>
            let '(op_annot, addr_annot) := function_parameter in
            let cannonical_code :=
              Pervasives.op_atat Pervasives.fst
                (Micheline.extract_locations code) in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (parse_toplevel legacy cannonical_code))
              (fun function_parameter =>
                let '(arg_type, storage_type, code_field, root_name) :=
                  function_parameter in
                Error_monad.op_gtgteqquestion
                  (Error_monad.trace extensible_type_value
                    (Pervasives.op_atat Lwt.__return
                      (parse_parameter_ty ctxt legacy arg_type)))
                  (fun function_parameter =>
                    let '(Ex_ty arg_type, ctxt) := function_parameter in
                    let 'existT _ __Ex_ty_'a15 [arg_type, ctxt] :=
                      existT
                        (fun __Ex_ty_'a15 : Set =>
                          [(Script_typed_ir.ty __Ex_ty_'a15) **
                            Alpha_context.context]) _ [arg_type, ctxt] in
                    Error_monad.op_gtgteqquestion
                      (if legacy then
                        Error_monad.__return tt
                      else
                        Lwt.__return
                          (well_formed_entrypoints arg_type root_name))
                      (fun function_parameter =>
                        let '_ := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (Error_monad.trace extensible_type_value
                            (Pervasives.op_atat Lwt.__return
                              (parse_storage_ty ctxt legacy storage_type)))
                          (fun function_parameter =>
                            let '(Ex_ty storage_type, ctxt) :=
                              function_parameter in
                            let 'existT _ __Ex_ty_'a16 [storage_type, ctxt] :=
                              existT
                                (fun __Ex_ty_'a16 : Set =>
                                  [(Script_typed_ir.ty __Ex_ty_'a16) **
                                    Alpha_context.context]) _
                                [storage_type, ctxt] in
                            let arg_annot :=
                              Script_ir_annot.default_annot
                                Script_ir_annot.default_param_annot
                                (Script_ir_annot.type_to_var_annot
                                  (name_of_ty arg_type)) in
                            let storage_annot :=
                              Script_ir_annot.default_annot
                                Script_ir_annot.default_storage_annot
                                (Script_ir_annot.type_to_var_annot
                                  (name_of_ty storage_type)) in
                            let arg_type_full :=
                              Script_typed_ir.Pair_t (arg_type, None, arg_annot)
                                (storage_type, None, storage_annot) None
                                (Pervasives.op_pipepipe (has_big_map arg_type)
                                  (has_big_map storage_type)) in
                            let ret_type_full :=
                              Script_typed_ir.Pair_t
                                ((Script_typed_ir.List_t
                                  (Script_typed_ir.Operation_t None) None false),
                                  None, None) (storage_type, None, None) None
                                (has_big_map storage_type) in
                            Error_monad.op_gtgteqquestion
                              (Error_monad.trace extensible_type_value
                                (parse_returning type_logger
                                  (Toplevel
                                    {|
                                      tc_context.Toplevel.storage_type :=
                                        storage_type;
                                      tc_context.Toplevel.param_type := arg_type;
                                      tc_context.Toplevel.root_name := root_name;
                                      tc_context.Toplevel.legacy_create_contract_literal :=
                                        false |}) ctxt legacy
                                  (arg_type_full, None) ret_type_full code_field))
                              (fun function_parameter =>
                                let
                                  '((Script_typed_ir.Lam {|
                                    Script_typed_ir.descr.bef :=
                                      Script_typed_ir.Item_t arg
                                        Script_typed_ir.Empty_t
                                        _;
                                      Script_typed_ir.descr.aft :=
                                        Script_typed_ir.Item_t
                                          ret
                                          Script_typed_ir.Empty_t
                                          _
                                      |} _) as lambda, ctxt) :=
                                  function_parameter in
                                Error_monad.op_gtgteqquestion
                                  (Pervasives.op_atat Lwt.__return
                                    (ty_eq ctxt arg arg_type_full))
                                  (fun function_parameter =>
                                    let '(Eq, ctxt) := function_parameter in
                                    Error_monad.op_gtgteqquestion
                                      (Pervasives.op_atat Lwt.__return
                                        (merge_types legacy ctxt loc arg
                                          arg_type_full))
                                      (fun function_parameter =>
                                        let '(_, ctxt) := function_parameter in
                                        Error_monad.op_gtgteqquestion
                                          (Pervasives.op_atat Lwt.__return
                                            (ty_eq ctxt ret ret_type_full))
                                          (fun function_parameter =>
                                            let '(Eq, ctxt) :=
                                              function_parameter in
                                            Error_monad.op_gtgteqquestion
                                              (Pervasives.op_atat Lwt.__return
                                                (merge_types legacy ctxt loc ret
                                                  ret_type_full))
                                              (fun function_parameter =>
                                                let '(_, ctxt) :=
                                                  function_parameter in
                                                Error_monad.op_gtgteqquestion
                                                  (Pervasives.op_atat
                                                    Lwt.__return
                                                    (ty_eq ctxt storage_type
                                                      ginit))
                                                  (fun function_parameter =>
                                                    let '(Eq, ctxt) :=
                                                      function_parameter in
                                                    Error_monad.op_gtgteqquestion
                                                      (Pervasives.op_atat
                                                        Lwt.__return
                                                        (merge_types legacy ctxt
                                                          loc storage_type ginit))
                                                      (fun function_parameter =>
                                                        let '(_, ctxt) :=
                                                          function_parameter in
                                                        typed ctxt loc
                                                          (Script_typed_ir.Create_contract_2
                                                            storage_type
                                                            arg_type lambda
                                                            root_name)
                                                          (Script_typed_ir.Item_t
                                                            (Script_typed_ir.Operation_t
                                                              None)
                                                            (Script_typed_ir.Item_t
                                                              (Script_typed_ir.Address_t
                                                                None) rest
                                                              addr_annot)
                                                            op_annot)))))))))))))
      | ((Micheline.Prim loc Alpha_context.Script.I_NOW [] annot, stack), _) =>
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_now_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Now
              (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_AMOUNT [] annot, stack), _)
        =>
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_amount_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Amount
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) stack annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CHAIN_ID [] annot, stack), _)
        =>
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.ChainId
              (Script_typed_ir.Item_t (Script_typed_ir.Chain_id_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_BALANCE [] annot, stack), _)
        =>
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_balance_annot)
            annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Balance
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) stack annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_HASH_KEY [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_t _) rest _), _) =>
        let 'existT _ __451 [loc, annot, rest] :=
          existT
            (fun __451 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __451)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Hash_key
              (Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t None) rest
                annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CHECK_SIGNATURE [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Key_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Signature_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _) _) _),
          _) =>
        let 'existT _ __457 [loc, annot, rest] :=
          existT
            (fun __457 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __457)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Check_signature
              (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_BLAKE2B [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
        let 'existT _ __459 [loc, annot, rest] :=
          existT
            (fun __459 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __459)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Blake2b
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SHA256 [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
        let 'existT _ __461 [loc, annot, rest] :=
          existT
            (fun __461 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __461)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Sha256
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_SHA512 [] annot,
          Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =>
        let 'existT _ __463 [loc, annot, rest] :=
          existT
            (fun __463 : Set =>
              [Alpha_context.Script.location ** Micheline.annot **
                (Script_typed_ir.stack_ty __463)]) _ [loc, annot, rest] in
        Error_monad.op_gtgteqquestion (parse_var_annot loc None annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Sha512
              (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot))
      |
        ((Micheline.Prim loc Alpha_context.Script.I_STEPS_TO_QUOTA [] annot,
          stack), _) =>
        if legacy then
          Error_monad.op_gtgteqquestion
            (parse_var_annot loc (Some Script_ir_annot.default_steps_annot)
              annot)
            (fun annot =>
              typed ctxt loc Script_typed_ir.Steps_to_quota
                (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) stack annot))
        else
          Error_monad.fail extensible_type_value
      | ((Micheline.Prim loc Alpha_context.Script.I_SOURCE [] annot, stack), _)
        =>
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_source_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Source
              (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_SENDER [] annot, stack), _)
        =>
        Error_monad.op_gtgteqquestion
          (parse_var_annot loc (Some Script_ir_annot.default_sender_annot) annot)
          (fun annot =>
            typed ctxt loc Script_typed_ir.Sender
              (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) stack
                annot))
      | ((Micheline.Prim loc Alpha_context.Script.I_SELF [] annot, stack), _) =>
        Error_monad.op_gtgteqquestion
          (parse_entrypoint_annot loc (Some Script_ir_annot.default_self_annot)
            annot)
          (fun function_parameter =>
            let '(annot, entrypoint) := function_parameter in
            let entrypoint :=
              Option.unopt_map
                (fun function_parameter =>
                  let 'Field_annot annot := function_parameter in
                  annot) "default" entrypoint in
            let fix get_toplevel_type (function_parameter : tc_context)
              {struct function_parameter}
              : Lwt.t
                (Error_monad.tzresult (judgement bef * Alpha_context.context)) :=
              match function_parameter with
              | Lambda => Error_monad.fail extensible_type_value
              | Dip _ prev => get_toplevel_type prev
              |
                Toplevel {|
                  tc_context.Toplevel.param_type := param_type;
                    tc_context.Toplevel.root_name := root_name;
                    tc_context.Toplevel.legacy_create_contract_literal := false
                    |} =>
                let 'existT _ __Toplevel_'param [param_type, root_name] :=
                  existT
                    (fun __Toplevel_'param : Set =>
                      [(Script_typed_ir.ty __Toplevel_'param) **
                        (option string)]) _ [param_type, root_name] in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (find_entrypoint param_type root_name entrypoint))
                  (fun function_parameter =>
                    let '(_, Ex_ty param_type) := function_parameter in
                    let 'existT _ __Ex_ty_'a17 param_type :=
                      existT
                        (fun __Ex_ty_'a17 : Set =>
                          (Script_typed_ir.ty __Ex_ty_'a17)) _ param_type in
                    typed ctxt loc (Script_typed_ir.Self param_type entrypoint)
                      (Script_typed_ir.Item_t
                        (Script_typed_ir.Contract_t param_type None) stack annot))
              |
                Toplevel {|
                  tc_context.Toplevel.param_type := param_type;
                    tc_context.Toplevel.root_name := _;
                    tc_context.Toplevel.legacy_create_contract_literal := true
                    |} =>
                let 'existT _ __Toplevel_'param1 param_type :=
                  existT
                    (fun __Toplevel_'param1 : Set =>
                      (Script_typed_ir.ty __Toplevel_'param1)) _ param_type in
                typed ctxt loc (Script_typed_ir.Self param_type "default")
                  (Script_typed_ir.Item_t
                    (Script_typed_ir.Contract_t param_type None) stack annot)
              end in
            get_toplevel_type tc_context)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_DUP | Alpha_context.Script.I_SWAP |
          Alpha_context.Script.I_SOME | Alpha_context.Script.I_UNIT |
          Alpha_context.Script.I_PAIR | Alpha_context.Script.I_CAR |
          Alpha_context.Script.I_CDR | Alpha_context.Script.I_CONS |
          Alpha_context.Script.I_CONCAT | Alpha_context.Script.I_SLICE |
          Alpha_context.Script.I_MEM | Alpha_context.Script.I_UPDATE |
          Alpha_context.Script.I_MAP | Alpha_context.Script.I_GET |
          Alpha_context.Script.I_EXEC | Alpha_context.Script.I_FAILWITH |
          Alpha_context.Script.I_SIZE | Alpha_context.Script.I_ADD |
          Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
          Alpha_context.Script.I_EDIV | Alpha_context.Script.I_OR |
          Alpha_context.Script.I_AND | Alpha_context.Script.I_XOR |
          Alpha_context.Script.I_NOT | Alpha_context.Script.I_ABS |
          Alpha_context.Script.I_NEG | Alpha_context.Script.I_LSL |
          Alpha_context.Script.I_LSR | Alpha_context.Script.I_COMPARE |
          Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
          Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
          Alpha_context.Script.I_LE | Alpha_context.Script.I_GE |
          Alpha_context.Script.I_TRANSFER_TOKENS |
          Alpha_context.Script.I_CREATE_ACCOUNT |
          Alpha_context.Script.I_SET_DELEGATE | Alpha_context.Script.I_NOW |
          Alpha_context.Script.I_IMPLICIT_ACCOUNT |
          Alpha_context.Script.I_AMOUNT | Alpha_context.Script.I_BALANCE |
          Alpha_context.Script.I_CHECK_SIGNATURE |
          Alpha_context.Script.I_HASH_KEY | Alpha_context.Script.I_SOURCE |
          Alpha_context.Script.I_SENDER | Alpha_context.Script.I_BLAKE2B |
          Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
          Alpha_context.Script.I_STEPS_TO_QUOTA | Alpha_context.Script.I_ADDRESS)
            as name) ((cons _ _) as l) _, _), _) =>
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_NONE | Alpha_context.Script.I_LEFT |
          Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_NIL |
          Alpha_context.Script.I_MAP | Alpha_context.Script.I_ITER |
          Alpha_context.Script.I_EMPTY_SET | Alpha_context.Script.I_DIP |
          Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LOOP_LEFT |
          Alpha_context.Script.I_CONTRACT) as name)
          (([] | cons _ (cons _ _)) as l) _, _), _) =>
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_PUSH | Alpha_context.Script.I_IF_NONE |
          Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_CONS |
          Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_IF) as name)
          (([] | cons _ [] | cons _ (cons _ (cons _ _))) as l) _, _), _) =>
        Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
          (([] | cons _ [] | cons _ (cons _ (cons _ (cons _ _)))) as l) _, _), _)
        => Error_monad.fail extensible_type_value
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_ADD | Alpha_context.Script.I_SUB |
          Alpha_context.Script.I_MUL | Alpha_context.Script.I_EDIV |
          Alpha_context.Script.I_AND | Alpha_context.Script.I_OR |
          Alpha_context.Script.I_XOR | Alpha_context.Script.I_LSL |
          Alpha_context.Script.I_LSR) as name) [] _,
          Script_typed_ir.Item_t ta (Script_typed_ir.Item_t tb _ _) _), _) =>
        let 'existT _ [__464, __466] [loc, name, ta, tb] :=
          existT
            (fun '[__464, __466] =>
              [Alpha_context.Script.location ** Alpha_context.Script.prim **
                (Script_typed_ir.ty __464) ** (Script_typed_ir.ty __466)]) _
            [loc, name, ta, tb] in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return (serialize_ty_for_error ctxt ta))
          (fun function_parameter =>
            let '(ta, ctxt) := function_parameter in
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return (serialize_ty_for_error ctxt tb))
              (fun function_parameter =>
                let '(tb, _ctxt) := function_parameter in
                Error_monad.fail extensible_type_value))
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_NEG | Alpha_context.Script.I_ABS |
          Alpha_context.Script.I_NOT | Alpha_context.Script.I_CONCAT |
          Alpha_context.Script.I_SIZE | Alpha_context.Script.I_EQ |
          Alpha_context.Script.I_NEQ | Alpha_context.Script.I_LT |
          Alpha_context.Script.I_GT | Alpha_context.Script.I_LE |
          Alpha_context.Script.I_GE) as name) [] _,
          Script_typed_ir.Item_t __t_value _ _), _) =>
        let 'existT _ __468 [loc, name, __t_value] :=
          existT
            (fun __468 : Set =>
              [Alpha_context.Script.location ** Alpha_context.Script.prim **
                (Script_typed_ir.ty __468)]) _ [loc, name, __t_value] in
        Error_monad.op_gtgteqquestion
          (Pervasives.op_atat Lwt.__return
            (serialize_ty_for_error ctxt __t_value))
          (fun function_parameter =>
            let '(__t_value, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_UPDATE | Alpha_context.Script.I_SLICE) as
            name) [] _, stack), _) =>
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =>
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT _ _, stack),
          _) =>
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =>
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] _, stack),
          _) =>
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =>
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] _, stack),
          _) =>
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =>
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
          Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
          Alpha_context.Script.I_SOME | Alpha_context.Script.I_BLAKE2B |
          Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
          Alpha_context.Script.I_DIP | Alpha_context.Script.I_IF_NONE |
          Alpha_context.Script.I_LEFT | Alpha_context.Script.I_RIGHT |
          Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF |
          Alpha_context.Script.I_LOOP | Alpha_context.Script.I_IF_CONS |
          Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_NEG |
          Alpha_context.Script.I_ABS | Alpha_context.Script.I_INT |
          Alpha_context.Script.I_NOT | Alpha_context.Script.I_HASH_KEY |
          Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
          Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
          Alpha_context.Script.I_LE | Alpha_context.Script.I_GE) as name) _ _,
          stack), _) =>
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =>
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      |
        ((Micheline.Prim loc
          ((Alpha_context.Script.I_SWAP | Alpha_context.Script.I_PAIR |
          Alpha_context.Script.I_CONS | Alpha_context.Script.I_GET |
          Alpha_context.Script.I_MEM | Alpha_context.Script.I_EXEC |
          Alpha_context.Script.I_CHECK_SIGNATURE | Alpha_context.Script.I_ADD |
          Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
          Alpha_context.Script.I_EDIV | Alpha_context.Script.I_AND |
          Alpha_context.Script.I_OR | Alpha_context.Script.I_XOR |
          Alpha_context.Script.I_LSL | Alpha_context.Script.I_LSR) as name) _ _,
          stack), _) =>
        Error_monad.op_gtgteqquestion (serialize_stack_for_error ctxt stack)
          (fun function_parameter =>
            let '(stack, _ctxt) := function_parameter in
            Error_monad.fail extensible_type_value)
      | ((expr, _), _) =>
        Pervasives.op_atat Error_monad.fail
          (unexpected expr [ Script_tc_errors.Seq_kind ]
            Script_tc_errors.Instr_namespace
            [
              Alpha_context.Script.I_DROP;
              Alpha_context.Script.I_DUP;
              Alpha_context.Script.I_DIG;
              Alpha_context.Script.I_DUG;
              Alpha_context.Script.I_SWAP;
              Alpha_context.Script.I_SOME;
              Alpha_context.Script.I_UNIT;
              Alpha_context.Script.I_PAIR;
              Alpha_context.Script.I_CAR;
              Alpha_context.Script.I_CDR;
              Alpha_context.Script.I_CONS;
              Alpha_context.Script.I_MEM;
              Alpha_context.Script.I_UPDATE;
              Alpha_context.Script.I_MAP;
              Alpha_context.Script.I_ITER;
              Alpha_context.Script.I_GET;
              Alpha_context.Script.I_EXEC;
              Alpha_context.Script.I_FAILWITH;
              Alpha_context.Script.I_SIZE;
              Alpha_context.Script.I_CONCAT;
              Alpha_context.Script.I_ADD;
              Alpha_context.Script.I_SUB;
              Alpha_context.Script.I_MUL;
              Alpha_context.Script.I_EDIV;
              Alpha_context.Script.I_OR;
              Alpha_context.Script.I_AND;
              Alpha_context.Script.I_XOR;
              Alpha_context.Script.I_NOT;
              Alpha_context.Script.I_ABS;
              Alpha_context.Script.I_INT;
              Alpha_context.Script.I_NEG;
              Alpha_context.Script.I_LSL;
              Alpha_context.Script.I_LSR;
              Alpha_context.Script.I_COMPARE;
              Alpha_context.Script.I_EQ;
              Alpha_context.Script.I_NEQ;
              Alpha_context.Script.I_LT;
              Alpha_context.Script.I_GT;
              Alpha_context.Script.I_LE;
              Alpha_context.Script.I_GE;
              Alpha_context.Script.I_TRANSFER_TOKENS;
              Alpha_context.Script.I_CREATE_ACCOUNT;
              Alpha_context.Script.I_CREATE_CONTRACT;
              Alpha_context.Script.I_NOW;
              Alpha_context.Script.I_AMOUNT;
              Alpha_context.Script.I_BALANCE;
              Alpha_context.Script.I_IMPLICIT_ACCOUNT;
              Alpha_context.Script.I_CHECK_SIGNATURE;
              Alpha_context.Script.I_BLAKE2B;
              Alpha_context.Script.I_SHA256;
              Alpha_context.Script.I_SHA512;
              Alpha_context.Script.I_HASH_KEY;
              Alpha_context.Script.I_STEPS_TO_QUOTA;
              Alpha_context.Script.I_PUSH;
              Alpha_context.Script.I_NONE;
              Alpha_context.Script.I_LEFT;
              Alpha_context.Script.I_RIGHT;
              Alpha_context.Script.I_NIL;
              Alpha_context.Script.I_EMPTY_SET;
              Alpha_context.Script.I_DIP;
              Alpha_context.Script.I_LOOP;
              Alpha_context.Script.I_IF_NONE;
              Alpha_context.Script.I_IF_LEFT;
              Alpha_context.Script.I_IF_CONS;
              Alpha_context.Script.I_EMPTY_MAP;
              Alpha_context.Script.I_IF;
              Alpha_context.Script.I_SOURCE;
              Alpha_context.Script.I_SENDER;
              Alpha_context.Script.I_SELF;
              Alpha_context.Script.I_LAMBDA
            ])
      end)

with parse_contract {arg : Set}
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty arg)
  (contract : Alpha_context.Contract.t) (entrypoint : string) {struct legacy}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Script_typed_ir.typed_contract arg)) :=
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists))
    (fun ctxt =>
      Error_monad.op_gtgteqquestion
        (Alpha_context.Contract.__exists ctxt contract)
        (fun function_parameter =>
          match function_parameter with
          | false => Error_monad.fail extensible_type_value
          | true =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script))
              (fun ctxt =>
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat (Error_monad.trace extensible_type_value)
                    (Alpha_context.Contract.get_script_code ctxt contract))
                  (fun function_parameter =>
                    let '(ctxt, code) := function_parameter in
                    match code with
                    | None =>
                      Lwt.__return
                        (Error_monad.op_gtgtquestion
                          (ty_eq ctxt arg (Script_typed_ir.Unit_t None))
                          (fun function_parameter =>
                            let '(Eq, ctxt) := function_parameter in
                            match entrypoint with
                            | "default" =>
                              let contract := (arg, (contract, entrypoint)) in
                              Error_monad.ok (ctxt, contract)
                            | entrypoint =>
                              Error_monad.__error_value extensible_type_value
                            end))
                    | Some code =>
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Script.force_decode ctxt code)
                        (fun function_parameter =>
                          let '(code, ctxt) := function_parameter in
                          Lwt.__return
                            (Error_monad.op_gtgtquestion
                              (parse_toplevel true code)
                              (fun function_parameter =>
                                let '(arg_type, _, _, root_name) :=
                                  function_parameter in
                                Error_monad.op_gtgtquestion
                                  (parse_parameter_ty ctxt true arg_type)
                                  (fun function_parameter =>
                                    let '(Ex_ty targ, ctxt) :=
                                      function_parameter in
                                    let 'existT _ __Ex_ty_'a18 [targ, ctxt] :=
                                      existT
                                        (fun __Ex_ty_'a18 : Set =>
                                          [(Script_typed_ir.ty __Ex_ty_'a18) **
                                            Alpha_context.context]) _
                                        [targ, ctxt] in
                                    let __return
                                      (ctxt : Alpha_context.context)
                                      (targ : Script_typed_ir.ty arg)
                                      (entrypoint : string)
                                      : Error_monad.tzresult
                                        (Alpha_context.context *
                                          Script_typed_ir.typed_contract arg) :=
                                      Error_monad.op_gtgtquestion
                                        (merge_types legacy ctxt loc targ arg)
                                        (fun function_parameter =>
                                          let '(arg, ctxt) := function_parameter
                                            in
                                          let contract :=
                                            (arg, (contract, entrypoint)) in
                                          Error_monad.ok (ctxt, contract)) in
                                    Error_monad.op_gtgtquestion
                                      (find_entrypoint_for_type targ arg
                                        root_name entrypoint ctxt)
                                      (fun function_parameter =>
                                        let '(ctxt, entrypoint, targ) :=
                                          function_parameter in
                                        Error_monad.op_gtgtquestion
                                          (merge_types legacy ctxt loc targ arg)
                                          (fun function_parameter =>
                                            let '(targ, ctxt) :=
                                              function_parameter in
                                            __return ctxt targ entrypoint))))))
                    end))
          end))

with parse_contract_for_script {arg : Set}
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty arg)
  (contract : Alpha_context.Contract.t) (entrypoint : string) {struct legacy}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * option (Script_typed_ir.typed_contract arg))) :=
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists))
    (fun ctxt =>
      Error_monad.op_gtgteqquestion
        (Alpha_context.Contract.__exists ctxt contract)
        (fun function_parameter =>
          match function_parameter with
          | false => Error_monad.__return (ctxt, None)
          | true =>
            Error_monad.op_gtgteqquestion
              (Pervasives.op_atat Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script))
              (fun ctxt =>
                Error_monad.op_gtgteqquestion
                  (Pervasives.op_atat (Error_monad.trace extensible_type_value)
                    (Alpha_context.Contract.get_script_code ctxt contract))
                  (fun function_parameter =>
                    let '(ctxt, code) := function_parameter in
                    match code with
                    | None =>
                      match entrypoint with
                      | "default" =>
                        Lwt.__return
                          match ty_eq ctxt arg (Script_typed_ir.Unit_t None)
                            with
                          | Pervasives.Ok (Eq, ctxt) =>
                            let contract := (arg, (contract, entrypoint)) in
                            Error_monad.ok (ctxt, (Some contract))
                          | Pervasives.Error _ =>
                            Error_monad.op_gtgtquestion
                              (Alpha_context.Gas.consume ctxt
                                Typecheck_costs.cycle)
                              (fun ctxt => Error_monad.ok (ctxt, None))
                          end
                      | _ => Error_monad.__return (ctxt, None)
                      end
                    | Some code =>
                      Error_monad.op_gtgteqquestion
                        (Alpha_context.Script.force_decode ctxt code)
                        (fun function_parameter =>
                          let '(code, ctxt) := function_parameter in
                          Lwt.__return
                            match parse_toplevel true code with
                            | Pervasives.Error _ =>
                              Error_monad.__error_value extensible_type_value
                            | Pervasives.Ok (arg_type, _, _, root_name) =>
                              match parse_parameter_ty ctxt true arg_type with
                              | Pervasives.Error _ =>
                                Error_monad.__error_value extensible_type_value
                              | Pervasives.Ok (Ex_ty targ, ctxt) =>
                                let 'existT _ __Ex_ty_'a19 [targ, ctxt] :=
                                  existT
                                    (fun __Ex_ty_'a19 : Set =>
                                      [(Script_typed_ir.ty __Ex_ty_'a19) **
                                        Alpha_context.context]) _ [targ, ctxt]
                                  in
                                match
                                  Error_monad.op_gtgtquestion
                                    (find_entrypoint_for_type targ arg root_name
                                      entrypoint ctxt)
                                    (fun function_parameter =>
                                      let '(ctxt, entrypoint, targ) :=
                                        function_parameter in
                                      Error_monad.op_gtgtquestion
                                        (merge_types legacy ctxt loc targ arg)
                                        (fun function_parameter =>
                                          let '(targ, ctxt) :=
                                            function_parameter in
                                          Error_monad.op_gtgtquestion
                                            (merge_types legacy ctxt loc targ
                                              arg)
                                            (fun function_parameter =>
                                              let '(arg, ctxt) :=
                                                function_parameter in
                                              let contract :=
                                                (arg, (contract, entrypoint)) in
                                              Error_monad.ok
                                                (ctxt, (Some contract))))) with
                                | Pervasives.Ok res => Error_monad.ok res
                                | Pervasives.Error _ =>
                                  Error_monad.op_gtgtquestion
                                    (ty_eq ctxt targ targ)
                                    (fun function_parameter =>
                                      let '(Eq, ctxt) := function_parameter in
                                      Error_monad.op_gtgtquestion
                                        (merge_types legacy ctxt loc targ targ)
                                        (fun function_parameter =>
                                          let '(_, ctxt) := function_parameter
                                            in
                                          Error_monad.ok (ctxt, None)))
                                end
                              end
                            end)
                    end))
          end))

with parse_toplevel (legacy : bool) (toplevel : Alpha_context.Script.expr)
  {struct legacy}
  : Error_monad.tzresult
    (Alpha_context.Script.node * Alpha_context.Script.node *
      Alpha_context.Script.node * option string) :=
  Pervasives.op_atat (Error_monad.record_trace extensible_type_value)
    match Micheline.root toplevel with
    | Micheline.Int loc _ => Error_monad.__error_value extensible_type_value
    | Micheline.String loc _ => Error_monad.__error_value extensible_type_value
    | Micheline.Bytes loc _ => Error_monad.__error_value extensible_type_value
    | Micheline.Prim loc _ _ _ =>
      Error_monad.__error_value extensible_type_value
    | Micheline.Seq _ fields =>
      let fix find_fields
        (p :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (s :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (c :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (fields :
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)) {struct p}
        : Error_monad.tzresult
          (option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot)) :=
        match fields with
        | [] => Error_monad.ok (p, s, c)
        | cons (Micheline.Int loc _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.String loc _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Bytes loc _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Seq loc _) _ =>
          Error_monad.__error_value extensible_type_value
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_parameter (cons arg [])
              annot) rest =>
          match p with
          | None => find_fields (Some (arg, loc, annot)) s c rest
          | Some _ => Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_storage (cons arg [])
              annot) rest =>
          match s with
          | None => find_fields p (Some (arg, loc, annot)) c rest
          | Some _ => Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_code (cons arg []) annot)
            rest =>
          match c with
          | None => find_fields p s (Some (arg, loc, annot)) rest
          | Some _ => Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc
              ((Alpha_context.Script.K_parameter |
              Alpha_context.Script.K_storage | Alpha_context.Script.K_code) as
                name) args _) _ =>
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Prim loc name _ _) _ =>
          let allowed :=
            [
              Alpha_context.Script.K_parameter;
              Alpha_context.Script.K_storage;
              Alpha_context.Script.K_code
            ] in
          Error_monad.__error_value extensible_type_value
        end in
      Error_monad.op_gtgtquestion (find_fields None None None fields)
        (fun function_parameter =>
          match function_parameter with
          | (None, _, _) => Error_monad.__error_value extensible_type_value
          | (Some _, None, _) => Error_monad.__error_value extensible_type_value
          | (Some _, Some _, None) =>
            Error_monad.__error_value extensible_type_value
          |
            (Some (p, ploc, pannot), Some (s, sloc, sannot),
              Some (c, cloc, carrot)) =>
            let maybe_root_name :=
              Error_monad.op_gtgtquestion
                (Script_ir_annot.extract_field_annot p)
                (fun function_parameter =>
                  let '(p, root_name) := function_parameter in
                  match root_name with
                  | Some (Field_annot root_name) =>
                    Error_monad.ok (p, pannot, (Some root_name))
                  | None =>
                    match
                      (pannot,
                        match pannot with
                        | cons single [] =>
                          Pervasives.op_andand
                            ((|Compare.Int|).(Compare.S.op_gt)
                              (String.length single) 0)
                            ((|Compare.Char|).(Compare.S.op_eq)
                              (String.get single 0) "%" % char)
                        | _ => false
                        end) with
                    | (cons single [], true) =>
                      Error_monad.ok
                        (p, nil,
                          (Some
                            (String.sub single 1
                              (Pervasives.op_minus (String.length single) 1))))
                    | (_, _) => Error_monad.ok (p, pannot, None)
                    end
                  end) in
            if legacy then
              let '(p, root_name) :=
                match maybe_root_name with
                | Pervasives.Ok (p, _, root_name) => (p, root_name)
                | Pervasives.Error _ => (p, None)
                end in
              Error_monad.ok (p, s, c, root_name)
            else
              Error_monad.op_gtgtquestion maybe_root_name
                (fun function_parameter =>
                  let '(p, pannot, root_name) := function_parameter in
                  Error_monad.op_gtgtquestion
                    (Script_ir_annot.error_unexpected_annot ploc pannot)
                    (fun function_parameter =>
                      let '_ := function_parameter in
                      Error_monad.op_gtgtquestion
                        (Script_ir_annot.error_unexpected_annot cloc carrot)
                        (fun function_parameter =>
                          let '_ := function_parameter in
                          Error_monad.op_gtgtquestion
                            (Script_ir_annot.error_unexpected_annot sloc sannot)
                            (fun function_parameter =>
                              let '_ := function_parameter in
                              Error_monad.ok (p, s, c, root_name)))))
          end)
    end.

Definition parse_script
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (function_parameter : Alpha_context.Script.t)
  : Lwt.t (Error_monad.tzresult (ex_script * Alpha_context.context)) :=
  let '{|
    Alpha_context.Script.t.code := code;
      Alpha_context.Script.t.storage := storage
      |} := function_parameter in
  Error_monad.op_gtgteqquestion (Alpha_context.Script.force_decode ctxt code)
    (fun function_parameter =>
      let '(code, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Alpha_context.Script.force_decode ctxt storage)
        (fun function_parameter =>
          let '(storage, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Pervasives.op_atat Lwt.__return (parse_toplevel legacy code))
            (fun function_parameter =>
              let '(arg_type, storage_type, code_field, root_name) :=
                function_parameter in
              Error_monad.op_gtgteqquestion
                (Error_monad.trace extensible_type_value
                  (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)))
                (fun function_parameter =>
                  let '(Ex_ty arg_type, ctxt) := function_parameter in
                  let 'existT _ __Ex_ty_'a [arg_type, ctxt] :=
                    existT
                      (fun __Ex_ty_'a : Set =>
                        [(Script_typed_ir.ty __Ex_ty_'a) **
                          Alpha_context.context]) _ [arg_type, ctxt] in
                  Error_monad.op_gtgteqquestion
                    (if legacy then
                      Error_monad.__return tt
                    else
                      Lwt.__return (well_formed_entrypoints arg_type root_name))
                    (fun function_parameter =>
                      let '_ := function_parameter in
                      Error_monad.op_gtgteqquestion
                        (Error_monad.trace extensible_type_value
                          (Lwt.__return
                            (parse_storage_ty ctxt legacy storage_type)))
                        (fun function_parameter =>
                          let '(Ex_ty storage_type, ctxt) := function_parameter
                            in
                          let 'existT _ __Ex_ty_'a1 [storage_type, ctxt] :=
                            existT
                              (fun __Ex_ty_'a1 : Set =>
                                [(Script_typed_ir.ty __Ex_ty_'a1) **
                                  Alpha_context.context]) _ [storage_type, ctxt]
                            in
                          let arg_annot :=
                            Script_ir_annot.default_annot
                              Script_ir_annot.default_param_annot
                              (Script_ir_annot.type_to_var_annot
                                (name_of_ty arg_type)) in
                          let storage_annot :=
                            Script_ir_annot.default_annot
                              Script_ir_annot.default_storage_annot
                              (Script_ir_annot.type_to_var_annot
                                (name_of_ty storage_type)) in
                          let arg_type_full :=
                            Script_typed_ir.Pair_t (arg_type, None, arg_annot)
                              (storage_type, None, storage_annot) None
                              (Pervasives.op_pipepipe (has_big_map arg_type)
                                (has_big_map storage_type)) in
                          let ret_type_full :=
                            Script_typed_ir.Pair_t
                              ((Script_typed_ir.List_t
                                (Script_typed_ir.Operation_t None) None false),
                                None, None) (storage_type, None, None) None
                              (has_big_map storage_type) in
                          Error_monad.op_gtgteqquestion
                            (Error_monad.trace_eval
                              (fun function_parameter =>
                                let '_ := function_parameter in
                                Error_monad.op_gtgtpipequestion
                                  (Pervasives.op_atat Lwt.__return
                                    (serialize_ty_for_error ctxt storage_type))
                                  (fun function_parameter =>
                                    let '(storage_type, _ctxt) :=
                                      function_parameter in
                                    extensible_type_value))
                              (parse_data type_logger ctxt legacy storage_type
                                (Micheline.root storage)))
                            (fun function_parameter =>
                              let '(storage, ctxt) := function_parameter in
                              Error_monad.op_gtgteqquestion
                                (Error_monad.trace extensible_type_value
                                  (parse_returning type_logger
                                    (Toplevel
                                      {|
                                        tc_context.Toplevel.storage_type :=
                                          storage_type;
                                        tc_context.Toplevel.param_type :=
                                          arg_type;
                                        tc_context.Toplevel.root_name :=
                                          root_name;
                                        tc_context.Toplevel.legacy_create_contract_literal :=
                                          false |}) ctxt legacy
                                    (arg_type_full, None) ret_type_full
                                    code_field))
                                (fun function_parameter =>
                                  let '(code, ctxt) := function_parameter in
                                  Error_monad.__return
                                    ((Ex_script
                                      {| Script_typed_ir.script.code := code;
                                        Script_typed_ir.script.arg_type :=
                                          arg_type;
                                        Script_typed_ir.script.storage :=
                                          storage;
                                        Script_typed_ir.script.storage_type :=
                                          storage_type;
                                        Script_typed_ir.script.root_name :=
                                          root_name |}), ctxt))))))))).

Definition typecheck_code
  (ctxt : Alpha_context.context) (code : Alpha_context.Script.expr)
  : Lwt.t
    (Error_monad.tzresult (Script_tc_errors.type_map * Alpha_context.context)) :=
  let legacy := false in
  Error_monad.op_gtgteqquestion
    (Pervasives.op_atat Lwt.__return (parse_toplevel legacy code))
    (fun function_parameter =>
      let '(arg_type, storage_type, code_field, root_name) := function_parameter
        in
      let type_map := Pervasives.__ref_value nil in
      Error_monad.op_gtgteqquestion
        (Error_monad.trace extensible_type_value
          (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)))
        (fun function_parameter =>
          let '(Ex_ty arg_type, ctxt) := function_parameter in
          let 'existT _ __Ex_ty_'a [arg_type, ctxt] :=
            existT
              (fun __Ex_ty_'a : Set =>
                [(Script_typed_ir.ty __Ex_ty_'a) ** Alpha_context.context]) _
              [arg_type, ctxt] in
          Error_monad.op_gtgteqquestion
            (if legacy then
              Error_monad.__return tt
            else
              Lwt.__return (well_formed_entrypoints arg_type root_name))
            (fun function_parameter =>
              let '_ := function_parameter in
              Error_monad.op_gtgteqquestion
                (Error_monad.trace extensible_type_value
                  (Lwt.__return (parse_storage_ty ctxt legacy storage_type)))
                (fun function_parameter =>
                  let '(Ex_ty storage_type, ctxt) := function_parameter in
                  let 'existT _ __Ex_ty_'a1 [storage_type, ctxt] :=
                    existT
                      (fun __Ex_ty_'a1 : Set =>
                        [(Script_typed_ir.ty __Ex_ty_'a1) **
                          Alpha_context.context]) _ [storage_type, ctxt] in
                  let arg_annot :=
                    Script_ir_annot.default_annot
                      Script_ir_annot.default_param_annot
                      (Script_ir_annot.type_to_var_annot (name_of_ty arg_type))
                    in
                  let storage_annot :=
                    Script_ir_annot.default_annot
                      Script_ir_annot.default_storage_annot
                      (Script_ir_annot.type_to_var_annot
                        (name_of_ty storage_type)) in
                  let arg_type_full :=
                    Script_typed_ir.Pair_t (arg_type, None, arg_annot)
                      (storage_type, None, storage_annot) None
                      (Pervasives.op_pipepipe (has_big_map arg_type)
                        (has_big_map storage_type)) in
                  let ret_type_full :=
                    Script_typed_ir.Pair_t
                      ((Script_typed_ir.List_t
                        (Script_typed_ir.Operation_t None) None false), None,
                        None) (storage_type, None, None) None
                      (has_big_map storage_type) in
                  let __result_value :=
                    parse_returning
                      (Some
                        (fun loc =>
                          fun bef =>
                            fun aft =>
                              Pervasives.op_coloneq type_map
                                (cons (loc, (bef, aft))
                                  (Pervasives.op_exclamation type_map))))
                      (Toplevel
                        {| tc_context.Toplevel.storage_type := storage_type;
                          tc_context.Toplevel.param_type := arg_type;
                          tc_context.Toplevel.root_name := root_name;
                          tc_context.Toplevel.legacy_create_contract_literal :=
                            false |}) ctxt legacy (arg_type_full, None)
                      ret_type_full code_field in
                  Error_monad.op_gtgteqquestion
                    (Error_monad.trace extensible_type_value __result_value)
                    (fun function_parameter =>
                      let '(Script_typed_ir.Lam _ _, ctxt) := function_parameter
                        in
                      Error_monad.__return
                        ((Pervasives.op_exclamation type_map), ctxt)))))).

Definition typecheck_data
  (type_logger : option type_logger) (ctxt : Alpha_context.context)
  (function_parameter : Alpha_context.Script.expr * Alpha_context.Script.expr)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let '(data, exp_ty) := function_parameter in
  let legacy := false in
  Error_monad.op_gtgteqquestion
    (Error_monad.trace extensible_type_value
      (Pervasives.op_atat Lwt.__return
        (parse_packable_ty ctxt legacy (Micheline.root exp_ty))))
    (fun function_parameter =>
      let '(Ex_ty exp_ty, ctxt) := function_parameter in
      let 'existT _ __Ex_ty_'a [exp_ty, ctxt] :=
        existT
          (fun __Ex_ty_'a : Set =>
            [(Script_typed_ir.ty __Ex_ty_'a) ** Alpha_context.context]) _
          [exp_ty, ctxt] in
      Error_monad.op_gtgteqquestion
        (Error_monad.trace_eval
          (fun function_parameter =>
            let '_ := function_parameter in
            Error_monad.op_gtgtpipequestion
              (Pervasives.op_atat Lwt.__return
                (serialize_ty_for_error ctxt exp_ty))
              (fun function_parameter =>
                let '(exp_ty, _ctxt) := function_parameter in
                extensible_type_value))
          (parse_data type_logger ctxt legacy exp_ty (Micheline.root data)))
        (fun function_parameter =>
          let '(_, ctxt) := function_parameter in
          Error_monad.__return ctxt)).

Definition Entrypoints_map :=
  Map.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := String.compare
      |}).

Definition list_entrypoints {A : Set}
  (full : Script_typed_ir.ty A) (ctxt : Alpha_context.context)
  (root_name : option (|Entrypoints_map|).(S.MAP.key))
  : Error_monad.tzresult
    (list (list Alpha_context.Script.prim) *
      (|Entrypoints_map|).(S.MAP.t)
        (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
  let merge {B C : Set}
    (path : list B)
    (annot : option (* `Field_annot *) (|Entrypoints_map|).(S.MAP.key))
    (ty : Script_typed_ir.ty C) (reachable : bool)
    (function_parameter :
      list (list B) *
        (|Entrypoints_map|).(S.MAP.t) (list B * Alpha_context.Script.node))
    : Error_monad.tzresult
      (list (list B) *
        (|Entrypoints_map|).(S.MAP.t) (list B * Alpha_context.Script.node)) :=
    let '(unreachables, all) as acc := function_parameter in
    match annot with
    | None | Some (Field_annot "") =>
      Pervasives.op_atat Error_monad.ok
        (if reachable then
          acc
        else
          match ty with
          | Script_typed_ir.Union_t _ _ _ _ => acc
          | _ => ((cons (List.rev path) unreachables), all)
          end)
    | Some (Field_annot name) =>
      if (|Compare.Int|).(Compare.S.op_gt) (String.length name) 31 then
        Error_monad.ok ((cons (List.rev path) unreachables), all)
      else
        if (|Entrypoints_map|).(S.MAP.mem) name all then
          Error_monad.ok ((cons (List.rev path) unreachables), all)
        else
          Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt ty)
            (fun function_parameter =>
              let '(unparsed_ty, _) := function_parameter in
              Error_monad.ok
                (unreachables,
                  ((|Entrypoints_map|).(S.MAP.add) name
                    ((List.rev path), unparsed_ty) all)))
    end in
  let fix fold_tree {t : Set}
    (__t_value : Script_typed_ir.ty t) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc :
      list (list Alpha_context.Script.prim) *
        (|Entrypoints_map|).(S.MAP.t)
          (list Alpha_context.Script.prim * Alpha_context.Script.node))
    {struct __t_value}
    : Error_monad.tzresult
      (list (list Alpha_context.Script.prim) *
        (|Entrypoints_map|).(S.MAP.t)
          (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =>
      let 'existT _ [__2, __3] [tl, al, tr, ar] :=
        existT
          (fun '[__2, __3] =>
            [(Script_typed_ir.ty __2) ** (option Script_typed_ir.field_annot) **
              (Script_typed_ir.ty __3) ** (option Script_typed_ir.field_annot)])
          _ [tl, al, tr, ar] in
      Error_monad.op_gtgtquestion
        (merge (cons Alpha_context.Script.D_Left path) al tl reachable acc)
        (fun acc =>
          Error_monad.op_gtgtquestion
            (merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc)
            (fun acc =>
              Error_monad.op_gtgtquestion
                (fold_tree tl (cons Alpha_context.Script.D_Left path)
                  match al with
                  | Some _ => true
                  | None => reachable
                  end acc)
                (fun acc =>
                  fold_tree tr (cons Alpha_context.Script.D_Right path)
                    match ar with
                    | Some _ => true
                    | None => reachable
                    end acc)))
    | _ => Error_monad.ok acc
    end in
  Error_monad.op_gtgtquestion (unparse_ty_no_lwt ctxt full)
    (fun function_parameter =>
      let '(unparsed_full, _) := function_parameter in
      in
      fold_tree full nil reachable (nil, init)).

Fixpoint unparse_data {a : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (ty : Script_typed_ir.ty a) (a : a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion
    (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.cycle))
    (fun ctxt =>
      match (ty, a) with
      | (Script_typed_ir.Unit_t _, _) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Unparse_costs.__unit_value))
          (fun ctxt =>
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_Unit nil nil), ctxt))
      | (Script_typed_ir.Int_t _, v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Unparse_costs.int v)))
          (fun ctxt =>
            Error_monad.__return
              ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt))
      | (Script_typed_ir.Nat_t _, v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt (Unparse_costs.int v)))
          (fun ctxt =>
            Error_monad.__return
              ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt))
      | (Script_typed_ir.String_t _, s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt (Unparse_costs.__string_value s)))
          (fun ctxt => Error_monad.__return ((Micheline.String (-1) s), ctxt))
      | (Script_typed_ir.Bytes_t _, s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt (Unparse_costs.__bytes_value s)))
          (fun ctxt => Error_monad.__return ((Micheline.Bytes (-1) s), ctxt))
      | (Script_typed_ir.Bool_t _, true) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Unparse_costs.__bool_value))
          (fun ctxt =>
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_True nil nil), ctxt))
      | (Script_typed_ir.Bool_t _, false) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt Unparse_costs.__bool_value))
          (fun ctxt =>
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_False nil nil), ctxt))
      | (Script_typed_ir.Timestamp_t _, __t_value) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt (Unparse_costs.timestamp __t_value)))
          (fun ctxt =>
            match mode with
            | Optimized =>
              Error_monad.__return
                ((Micheline.Int (-1)
                  (Alpha_context.Script_timestamp.to_zint __t_value)), ctxt)
            | Readable =>
              match Alpha_context.Script_timestamp.to_notation __t_value with
              | None =>
                Error_monad.__return
                  ((Micheline.Int (-1)
                    (Alpha_context.Script_timestamp.to_zint __t_value)), ctxt)
              | Some s => Error_monad.__return ((Micheline.String (-1) s), ctxt)
              end
            end)
      | (Script_typed_ir.Address_t _, (c, entrypoint)) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract))
          (fun ctxt =>
            match mode with
            | Optimized =>
              let entrypoint :=
                match entrypoint with
                | "default" => ""
                | name => name
                end in
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  (Data_encoding.tup2 Alpha_context.Contract.encoding
                    Data_encoding.__Variable.__string_value) (c, entrypoint) in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =>
              let notation :=
                match entrypoint with
                | "default" => Alpha_context.Contract.to_b58check c
                | entrypoint =>
                  Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
                    (Pervasives.op_caret "%" entrypoint)
                end in
              Error_monad.__return ((Micheline.String (-1) notation), ctxt)
            end)
      | (Script_typed_ir.Contract_t _ _, (_, (c, entrypoint))) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract))
          (fun ctxt =>
            match mode with
            | Optimized =>
              let entrypoint :=
                match entrypoint with
                | "default" => ""
                | name => name
                end in
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  (Data_encoding.tup2 Alpha_context.Contract.encoding
                    Data_encoding.__Variable.__string_value) (c, entrypoint) in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =>
              let notation :=
                match entrypoint with
                | "default" => Alpha_context.Contract.to_b58check c
                | entrypoint =>
                  Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
                    (Pervasives.op_caret "%" entrypoint)
                end in
              Error_monad.__return ((Micheline.String (-1) notation), ctxt)
            end)
      | (Script_typed_ir.Signature_t _, s) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.signature))
          (fun ctxt =>
            match mode with
            | Optimized =>
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn Signature.encoding s in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =>
              Error_monad.__return
                ((Micheline.String (-1) (Signature.to_b58check s)), ctxt)
            end)
      | (Script_typed_ir.Mutez_t _, v) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.tez))
          (fun ctxt =>
            Error_monad.__return
              ((Micheline.Int (-1) (Z.of_int64 (Alpha_context.Tez.to_mutez v))),
                ctxt))
      | (Script_typed_ir.Key_t _, k) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.key))
          (fun ctxt =>
            match mode with
            | Optimized =>
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  (|Signature.Public_key|).(S.SPublic_key.encoding) k in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =>
              Error_monad.__return
                ((Micheline.String (-1)
                  ((|Signature.Public_key|).(S.SPublic_key.to_b58check) k)),
                  ctxt)
            end)
      | (Script_typed_ir.Key_hash_t _, k) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.key_hash))
          (fun ctxt =>
            match mode with
            | Optimized =>
              let __bytes_value :=
                Data_encoding.Binary.to_bytes_exn
                  (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding) k
                in
              Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
            | Readable =>
              Error_monad.__return
                ((Micheline.String (-1)
                  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.to_b58check)
                    k)), ctxt)
            end)
      | (Script_typed_ir.Operation_t _, (op, _big_map_diff)) =>
        let __bytes_value :=
          Data_encoding.Binary.to_bytes_exn
            Alpha_context.Operation.internal_operation_encoding op in
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Unparse_costs.operation __bytes_value)))
          (fun ctxt =>
            Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt))
      | (Script_typed_ir.Chain_id_t _, chain_id) =>
        let __bytes_value :=
          Data_encoding.Binary.to_bytes_exn (|Chain_id|).(S.HASH.encoding)
            chain_id in
        Error_monad.op_gtgteqquestion
          (Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Unparse_costs.chain_id __bytes_value)))
          (fun ctxt =>
            Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt))
      | (Script_typed_ir.Pair_t (tl, _, _) (tr, _, _) _ _, (l, r)) =>
        let 'existT _ [__1, __2] [tl, tr, l, r] :=
          existT
            (fun '[__1, __2] =>
              [(Script_typed_ir.ty __1) ** (Script_typed_ir.ty __2) ** __1 **
                __2]) _ [tl, tr, l, r] in
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.pair))
          (fun ctxt =>
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode tl l)
              (fun function_parameter =>
                let '(l, ctxt) := function_parameter in
                Error_monad.op_gtgteqquestion (unparse_data ctxt mode tr r)
                  (fun function_parameter =>
                    let '(r, ctxt) := function_parameter in
                    Error_monad.__return
                      ((Micheline.Prim (-1) Alpha_context.Script.D_Pair [ l; r ]
                        nil), ctxt))))
      | (Script_typed_ir.Union_t (tl, _) _ _ _, Script_typed_ir.L l) =>
        let 'existT _ __3 [tl, l] :=
          existT (fun __3 : Set => [(Script_typed_ir.ty __3) ** __3]) _ [tl, l]
          in
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.union))
          (fun ctxt =>
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode tl l)
              (fun function_parameter =>
                let '(l, ctxt) := function_parameter in
                Error_monad.__return
                  ((Micheline.Prim (-1) Alpha_context.Script.D_Left [ l ] nil),
                    ctxt)))
      | (Script_typed_ir.Union_t _ (tr, _) _ _, Script_typed_ir.R r) =>
        let 'existT _ __6 [tr, r] :=
          existT (fun __6 : Set => [(Script_typed_ir.ty __6) ** __6]) _ [tr, r]
          in
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.union))
          (fun ctxt =>
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode tr r)
              (fun function_parameter =>
                let '(r, ctxt) := function_parameter in
                Error_monad.__return
                  ((Micheline.Prim (-1) Alpha_context.Script.D_Right [ r ] nil),
                    ctxt)))
      | (Script_typed_ir.Option_t __t_value _ _, Some v) =>
        let 'existT _ __7 [__t_value, v] :=
          existT (fun __7 : Set => [(Script_typed_ir.ty __7) ** __7]) _
            [__t_value, v] in
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.some))
          (fun ctxt =>
            Error_monad.op_gtgteqquestion (unparse_data ctxt mode __t_value v)
              (fun function_parameter =>
                let '(v, ctxt) := function_parameter in
                Error_monad.__return
                  ((Micheline.Prim (-1) Alpha_context.Script.D_Some [ v ] nil),
                    ctxt)))
      | (Script_typed_ir.Option_t _ _ _, None) =>
        Error_monad.op_gtgteqquestion
          (Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.none))
          (fun ctxt =>
            Error_monad.__return
              ((Micheline.Prim (-1) Alpha_context.Script.D_None nil nil), ctxt))
      | (Script_typed_ir.List_t __t_value _ _, items) =>
        let 'existT _ __9 [__t_value, items] :=
          existT (fun __9 : Set => [(Script_typed_ir.ty __9) ** a]) _
            [__t_value, items] in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =>
              let '(l, ctxt) := function_parameter in
              fun element =>
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.list_element))
                  (fun ctxt =>
                    Error_monad.op_gtgteqquestion
                      (unparse_data ctxt mode __t_value element)
                      (fun function_parameter =>
                        let '(unparsed, ctxt) := function_parameter in
                        Error_monad.__return ((cons unparsed l), ctxt))))
            (nil, ctxt) items)
          (fun function_parameter =>
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) (List.rev items)), ctxt))
      | (Script_typed_ir.Set_t __t_value _, set) =>
        let 'existT _ __10 [__t_value, set] :=
          existT (fun __10 : Set => [(Script_typed_ir.comparable_ty __10) ** a])
            _ [__t_value, set] in
        let __t_value := ty_of_comparable_ty __t_value in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =>
              let '(l, ctxt) := function_parameter in
              fun item =>
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.set_element))
                  (fun ctxt =>
                    Error_monad.op_gtgteqquestion
                      (unparse_data ctxt mode __t_value item)
                      (fun function_parameter =>
                        let '(item, ctxt) := function_parameter in
                        Error_monad.__return ((cons item l), ctxt))))
            (nil, ctxt) (set_fold (fun e => fun acc => cons e acc) set nil))
          (fun function_parameter =>
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) items), ctxt))
      | (Script_typed_ir.Map_t kt vt _ _, map) =>
        let 'existT _ [__11, __12] [kt, vt, map] :=
          existT
            (fun '[__11, __12] =>
              [(Script_typed_ir.comparable_ty __11) ** (Script_typed_ir.ty __12)
                ** a]) _ [kt, vt, map] in
        let kt := ty_of_comparable_ty kt in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =>
              let '(l, ctxt) := function_parameter in
              fun function_parameter =>
                let '(k, v) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.map_element))
                  (fun ctxt =>
                    Error_monad.op_gtgteqquestion (unparse_data ctxt mode kt k)
                      (fun function_parameter =>
                        let '(key, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (unparse_data ctxt mode vt v)
                          (fun function_parameter =>
                            let '(value, ctxt) := function_parameter in
                            Error_monad.__return
                              ((cons
                                (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                                  [ key; value ] nil) l), ctxt))))) (nil, ctxt)
            (map_fold (fun k => fun v => fun acc => cons (k, v) acc) map nil))
          (fun function_parameter =>
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) items), ctxt))
      |
        (Script_typed_ir.Big_map_t kt vt _, {|
          Script_typed_ir.big_map.id := None;
            Script_typed_ir.big_map.diff := Diff
            |}) =>
        let 'existT _ [__13, __14] [kt, vt, Diff] :=
          existT
            (fun '[__13, __14] =>
              [(Script_typed_ir.comparable_ty __13) ** (Script_typed_ir.ty __14)
                ** (Script_typed_ir.map __13 (option __14))]) _ [kt, vt, Diff]
          in
        let kt := ty_of_comparable_ty kt in
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =>
              let '(l, ctxt) := function_parameter in
              fun function_parameter =>
                let '(k, v) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Unparse_costs.map_element))
                  (fun ctxt =>
                    Error_monad.op_gtgteqquestion (unparse_data ctxt mode kt k)
                      (fun function_parameter =>
                        let '(key, ctxt) := function_parameter in
                        Error_monad.op_gtgteqquestion
                          (unparse_data ctxt mode vt v)
                          (fun function_parameter =>
                            let '(value, ctxt) := function_parameter in
                            Error_monad.__return
                              ((cons
                                (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                                  [ key; value ] nil) l), ctxt))))) (nil, ctxt)
            ((|Diff|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.fold)
              (fun k =>
                fun v =>
                  fun acc =>
                    match v with
                    | None => acc
                    | Some v => cons (k, v) acc
                    end)
              (Pervasives.fst (|Diff|).(Script_typed_ir.Boxed_map.boxed)) nil))
          (fun function_parameter =>
            let '(items, ctxt) := function_parameter in
            Error_monad.__return ((Micheline.Seq (-1) items), ctxt))
      |
        (Script_typed_ir.Big_map_t _kt _kv _, {|
          Script_typed_ir.big_map.id := Some id;
            Script_typed_ir.big_map.diff := Diff
            |}) =>
        let 'existT _ [__15, __16] [_kt, _kv, id, Diff] :=
          existT
            (fun '[__15, __16] =>
              [(Script_typed_ir.comparable_ty __15) ** (Script_typed_ir.ty __16)
                ** Z.t ** (Script_typed_ir.map __15 (option __16))]) _
            [_kt, _kv, id, Diff] in
        if
          (|Compare.Int|).(Compare.S.op_eq)
            ((|Diff|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.cardinal)
              (Pervasives.fst (|Diff|).(Script_typed_ir.Boxed_map.boxed))) 0
          then
          Error_monad.__return ((Micheline.Int (-1) id), ctxt)
        else
          (*  Assert instruction is not handled. *)
          assert false
      | (Script_typed_ir.Lambda_t _ _ _, Script_typed_ir.Lam _ original_code) =>
        unparse_code ctxt mode original_code
      end)

with unparse_code (ctxt : Alpha_context.context) (mode : unparsing_mode)
  {struct ctxt}
  : Alpha_context.Script.node ->
  Lwt.t
    (Error_monad.tzresult
      (Micheline.node Z Alpha_context.Script.prim * Alpha_context.context)) :=
  let legacy := true in
  fun function_parameter =>
    match function_parameter with
    |
      Micheline.Prim loc Alpha_context.Script.I_PUSH (cons ty (cons data []))
        annot =>
      Error_monad.op_gtgteqquestion
        (Lwt.__return (parse_packable_ty ctxt legacy ty))
        (fun function_parameter =>
          let '(Ex_ty __t_value, ctxt) := function_parameter in
          let 'existT _ __Ex_ty_'a [__t_value, ctxt] :=
            existT
              (fun __Ex_ty_'a : Set =>
                [(Script_typed_ir.ty __Ex_ty_'a) ** Alpha_context.context]) _
              [__t_value, ctxt] in
          Error_monad.op_gtgteqquestion
            (parse_data None ctxt legacy __t_value data)
            (fun function_parameter =>
              let '(data, ctxt) := function_parameter in
              Error_monad.op_gtgteqquestion
                (unparse_data ctxt mode __t_value data)
                (fun function_parameter =>
                  let '(data, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt
                        (Unparse_costs.prim_cost 2 annot)))
                    (fun ctxt =>
                      Error_monad.__return
                        ((Micheline.Prim loc Alpha_context.Script.I_PUSH
                          [ ty; data ] annot), ctxt)))))
    | Micheline.Seq loc items =>
      Error_monad.op_gtgteqquestion
        (Error_monad.fold_left_s
          (fun function_parameter =>
            let '(l, ctxt) := function_parameter in
            fun item =>
              Error_monad.op_gtgteqquestion (unparse_code ctxt mode item)
                (fun function_parameter =>
                  let '(item, ctxt) := function_parameter in
                  Error_monad.__return ((cons item l), ctxt))) (nil, ctxt) items)
        (fun function_parameter =>
          let '(items, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Unparse_costs.seq_cost (List.length items))))
            (fun ctxt =>
              Error_monad.__return ((Micheline.Seq loc (List.rev items)), ctxt)))
    | Micheline.Prim loc prim items annot =>
      Error_monad.op_gtgteqquestion
        (Error_monad.fold_left_s
          (fun function_parameter =>
            let '(l, ctxt) := function_parameter in
            fun item =>
              Error_monad.op_gtgteqquestion (unparse_code ctxt mode item)
                (fun function_parameter =>
                  let '(item, ctxt) := function_parameter in
                  Error_monad.__return ((cons item l), ctxt))) (nil, ctxt) items)
        (fun function_parameter =>
          let '(items, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion
            (Lwt.__return
              (Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 3 annot)))
            (fun ctxt =>
              Error_monad.__return
                ((Micheline.Prim loc prim (List.rev items) annot), ctxt)))
    | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom
      => Error_monad.__return (atom, ctxt)
    end.

Definition unparse_script {A B : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (function_parameter : Script_typed_ir.script A B)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.t * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.script.code := code;
      Script_typed_ir.script.arg_type := arg_type;
      Script_typed_ir.script.storage := storage;
      Script_typed_ir.script.storage_type := storage_type;
      Script_typed_ir.script.root_name := root_name
      |} := function_parameter in
  let 'Script_typed_ir.Lam _ original_code := code in
  Error_monad.op_gtgteqquestion (unparse_code ctxt mode original_code)
    (fun function_parameter =>
      let '(code, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (unparse_data ctxt mode storage_type storage)
        (fun function_parameter =>
          let '(storage, ctxt) := function_parameter in
          Error_monad.op_gtgteqquestion (unparse_ty ctxt arg_type)
            (fun function_parameter =>
              let '(arg_type, ctxt) := function_parameter in
              Error_monad.op_gtgteqquestion (unparse_ty ctxt storage_type)
                (fun function_parameter =>
                  let '(storage_type, ctxt) := function_parameter in
                  let arg_type :=
                    add_field_annot
                      (Option.map (fun n => Field_annot n) root_name) None
                      arg_type in
                  let code :=
                    Micheline.Seq (-1)
                      [
                        Micheline.Prim (-1) Alpha_context.Script.K_parameter
                          [ arg_type ] nil;
                        Micheline.Prim (-1) Alpha_context.Script.K_storage
                          [ storage_type ] nil;
                        Micheline.Prim (-1) Alpha_context.Script.K_code [ code ]
                          nil
                      ] in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Error_monad.op_gtgtquestion
                        (Alpha_context.Gas.consume ctxt
                          (Unparse_costs.seq_cost 3))
                        (fun ctxt =>
                          Error_monad.op_gtgtquestion
                            (Alpha_context.Gas.consume ctxt
                              (Unparse_costs.prim_cost 1 nil))
                            (fun ctxt =>
                              Error_monad.op_gtgtquestion
                                (Alpha_context.Gas.consume ctxt
                                  (Unparse_costs.prim_cost 1 nil))
                                (fun ctxt =>
                                  Alpha_context.Gas.consume ctxt
                                    (Unparse_costs.prim_cost 1 nil))))))
                    (fun ctxt =>
                      Error_monad.__return
                        ({|
                          Alpha_context.Script.t.code :=
                            Alpha_context.Script.__lazy_expr_value
                              (Micheline.strip_locations code);
                          Alpha_context.Script.t.storage :=
                            Alpha_context.Script.__lazy_expr_value
                              (Micheline.strip_locations storage) |}, ctxt)))))).

Definition pack_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty A) (data : A)
  : Lwt.t (Error_monad.tzresult (MBytes.t * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion (unparse_data ctxt Optimized typ data)
    (fun function_parameter =>
      let '(unparsed, ctxt) := function_parameter in
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn Alpha_context.Script.expr_encoding
          (Micheline.strip_locations unparsed) in
      Error_monad.op_gtgteqquestion
        (Pervasives.op_atat Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Alpha_context.Script.serialized_cost __bytes_value)))
        (fun ctxt =>
          let __bytes_value :=
            MBytes.concat "" [ MBytes.of_string "\005"; __bytes_value ] in
          Error_monad.op_gtgteqquestion
            (Pervasives.op_atat Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Alpha_context.Script.serialized_cost __bytes_value)))
            (fun ctxt => Error_monad.__return (__bytes_value, ctxt)))).

Definition hash_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty A) (data : A)
  : Lwt.t (Error_monad.tzresult (Script_expr_hash.t * Alpha_context.context)) :=
  Error_monad.op_gtgteqquestion (pack_data ctxt typ data)
    (fun function_parameter =>
      let '(__bytes_value, ctxt) := function_parameter in
      Error_monad.op_gtgteqquestion
        (Pervasives.op_atat Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Michelson_v1_gas.Cost_of.Legacy.__hash_value __bytes_value
              Script_expr_hash.size)))
        (fun ctxt =>
          Error_monad.__return
            ((Script_expr_hash.hash_bytes None [ __bytes_value ]), ctxt))).

Definition empty_big_map {A B : Set}
  (tk : Script_typed_ir.comparable_ty A) (tv : Script_typed_ir.ty B)
  : Script_typed_ir.big_map A B :=
  {| Script_typed_ir.big_map.id := None;
    Script_typed_ir.big_map.diff := empty_map tk;
    Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
    Script_typed_ir.big_map.value_type := tv |}.

Definition big_map_mem {A B : Set}
  (ctxt : Alpha_context.context) (key : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (bool * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type
      |} := function_parameter in
  match ((map_get key diff), id) with
  | (None, None) => Error_monad.__return (false, ctxt)
  | (None, Some id) =>
    Error_monad.op_gtgteqquestion (hash_data ctxt key_type key)
      (fun function_parameter =>
        let '(__hash_value, ctxt) := function_parameter in
        Error_monad.op_gtgteqquestion
          (Alpha_context.Big_map.mem ctxt id __hash_value)
          (fun function_parameter =>
            let '(ctxt, res) := function_parameter in
            Error_monad.__return (res, ctxt)))
  | (Some None, _) => Error_monad.__return (false, ctxt)
  | (Some (Some _), _) => Error_monad.__return (true, ctxt)
  end.

Definition big_map_get {A B : Set}
  (ctxt : Alpha_context.context) (key : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (option B * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  match ((map_get key diff), id) with
  | (Some x, _) => Error_monad.__return (x, ctxt)
  | (None, None) => Error_monad.__return (None, ctxt)
  | (None, Some id) =>
    Error_monad.op_gtgteqquestion (hash_data ctxt key_type key)
      (fun function_parameter =>
        let '(__hash_value, ctxt) := function_parameter in
        Error_monad.op_gtgteqquestion
          (Alpha_context.Big_map.get_opt ctxt id __hash_value)
          (fun function_parameter =>
            match function_parameter with
            | (ctxt, None) => Error_monad.__return (None, ctxt)
            | (ctxt, Some value) =>
              Error_monad.op_gtgteqquestion
                (parse_data None ctxt true value_type (Micheline.root value))
                (fun function_parameter =>
                  let '(x, ctxt) := function_parameter in
                  Error_monad.__return ((Some x), ctxt))
            end))
  end.

Definition big_map_update {A B : Set}
  (key : A) (value : option B)
  (function_parameter : Script_typed_ir.big_map A B)
  : Script_typed_ir.big_map A B :=
  let '{| Script_typed_ir.big_map.diff := diff |} as map := function_parameter
    in
  Script_typed_ir.big_map.with_diff (map_set key value diff) map.

Definition Ids :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := (|Compare.Z|).(Compare.S.compare)
      |}).

Definition big_map_ids := (|Ids|).(S.SET.t).

Definition no_big_map_id : (|Ids|).(S.SET.t) := (|Ids|).(S.SET.empty).

Definition diff_of_big_map {A B : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context ->
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : (|Ids|).(S.SET.t))
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t
    (Error_monad.tzresult
      (list Alpha_context.Contract.big_map_diff_item * Alpha_context.Big_map.id
        * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  Error_monad.op_gtgteqquestion
    (Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Michelson_v1_gas.Cost_of.Legacy.map_to_list diff)))
    (fun ctxt =>
      Error_monad.op_gtgteqquestion
        match id with
        | Some id =>
          if (|Ids|).(S.SET.mem) id ids then
            Error_monad.op_gtgteqquestion (fresh ctxt)
              (fun function_parameter =>
                let '(ctxt, duplicate) := function_parameter in
                Error_monad.__return
                  (ctxt, [ Alpha_context.Contract.Copy id duplicate ], duplicate))
          else
            Error_monad.__return (ctxt, nil, id)
        | None =>
          Error_monad.op_gtgteqquestion (fresh ctxt)
            (fun function_parameter =>
              let '(ctxt, id) := function_parameter in
              Error_monad.op_gtgteqquestion (unparse_ty ctxt key_type)
                (fun function_parameter =>
                  let '(kt, ctxt) := function_parameter in
                  Error_monad.op_gtgteqquestion (unparse_ty ctxt value_type)
                    (fun function_parameter =>
                      let '(kv, ctxt) := function_parameter in
                      Error_monad.__return
                        (ctxt,
                          [
                            Alpha_context.Contract.Alloc
                              {|
                                Alpha_context.Contract.big_map_diff_item.Alloc.big_map :=
                                  id;
                                Alpha_context.Contract.big_map_diff_item.Alloc.key_type :=
                                  Micheline.strip_locations
                                    kt;
                                Alpha_context.Contract.big_map_diff_item.Alloc.value_type :=
                                  Micheline.strip_locations
                                    kv
                                |}
                          ], id))))
        end
        (fun function_parameter =>
          let '(ctxt, init, big_map) := function_parameter in
          let pairs :=
            map_fold (fun key => fun value => fun acc => cons (key, value) acc)
              diff nil in
          Error_monad.op_gtgteqquestion
            (Error_monad.fold_left_s
              (fun function_parameter =>
                let '(acc, ctxt) := function_parameter in
                fun function_parameter =>
                  let '(key, value) := function_parameter in
                  Error_monad.op_gtgteqquestion
                    (Lwt.__return
                      (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
                    (fun ctxt =>
                      Error_monad.op_gtgteqquestion
                        (hash_data ctxt key_type key)
                        (fun function_parameter =>
                          let '(diff_key_hash, ctxt) := function_parameter in
                          Error_monad.op_gtgteqquestion
                            (unparse_data ctxt mode key_type key)
                            (fun function_parameter =>
                              let '(key_node, ctxt) := function_parameter in
                              let diff_key := Micheline.strip_locations key_node
                                in
                              Error_monad.op_gtgteqquestion
                                match value with
                                | None => Error_monad.__return (None, ctxt)
                                | Some x =>
                                  Error_monad.op_gtgteqquestion
                                    (unparse_data ctxt mode value_type x)
                                    (fun function_parameter =>
                                      let '(node, ctxt) := function_parameter in
                                      Error_monad.__return
                                        ((Some (Micheline.strip_locations node)),
                                          ctxt))
                                end
                                (fun function_parameter =>
                                  let '(diff_value, ctxt) := function_parameter
                                    in
                                  let diff_item :=
                                    Alpha_context.Contract.Update
                                      {|
                                        Alpha_context.Contract.big_map_diff_item.Update.big_map :=
                                          big_map;
                                        Alpha_context.Contract.big_map_diff_item.Update.diff_key :=
                                          diff_key;
                                        Alpha_context.Contract.big_map_diff_item.Update.diff_key_hash :=
                                          diff_key_hash;
                                        Alpha_context.Contract.big_map_diff_item.Update.diff_value :=
                                          diff_value |} in
                                  Error_monad.__return
                                    ((cons diff_item acc), ctxt))))))
              (nil, ctxt) pairs)
            (fun function_parameter =>
              let '(diff, ctxt) := function_parameter in
              Error_monad.__return ((Pervasives.op_at init diff), big_map, ctxt)))).

Fixpoint extract_big_map_updates {a : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context ->
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : (|Ids|).(S.SET.t))
  (acc : list Alpha_context.Contract.big_map_diff) (ty : Script_typed_ir.ty a)
  (x : a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * a * (|Ids|).(S.SET.t) *
        list Alpha_context.Contract.big_map_diff)) :=
  match (ty, x) with
  | (Script_typed_ir.Big_map_t _ _ _, map) =>
    Error_monad.op_gtgteqquestion (diff_of_big_map ctxt fresh mode ids map)
      (fun function_parameter =>
        let '(diff, id, ctxt) := function_parameter in
        let Map := map.(Script_typed_ir.big_map.diff) in
        let map :=
          Script_typed_ir.big_map.with_diff
            (empty_map (|Map|).(Script_typed_ir.Boxed_map.key_ty))
            (Script_typed_ir.big_map.with_id (Some id) map) in
        Error_monad.__return
          (ctxt, map, ((|Ids|).(S.SET.add) id ids), (cons diff acc)))
  | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, (xl, xr)) =>
    let 'existT _ [__2, __3] [tyl, tyr, xl, xr] :=
      existT
        (fun '[__2, __3] =>
          [(Script_typed_ir.ty __2) ** (Script_typed_ir.ty __3) ** __2 ** __3])
        _ [tyl, tyr, xl, xr] in
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =>
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc tyl xl)
          (fun function_parameter =>
            let '(ctxt, xl, ids, acc) := function_parameter in
            Error_monad.op_gtgteqquestion
              (extract_big_map_updates ctxt fresh mode ids acc tyr xr)
              (fun function_parameter =>
                let '(ctxt, xr, ids, acc) := function_parameter in
                Error_monad.__return (ctxt, (xl, xr), ids, acc))))
  | (Script_typed_ir.Union_t (ty, _) (_, _) _ true, Script_typed_ir.L x) =>
    let 'existT _ __4 [ty, x] :=
      existT (fun __4 : Set => [(Script_typed_ir.ty __4) ** __4]) _ [ty, x] in
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =>
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc ty x)
          (fun function_parameter =>
            let '(ctxt, x, ids, acc) := function_parameter in
            Error_monad.__return (ctxt, (Script_typed_ir.L x), ids, acc)))
  | (Script_typed_ir.Union_t (_, _) (ty, _) _ true, Script_typed_ir.R x) =>
    let 'existT _ __7 [ty, x] :=
      existT (fun __7 : Set => [(Script_typed_ir.ty __7) ** __7]) _ [ty, x] in
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =>
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc ty x)
          (fun function_parameter =>
            let '(ctxt, x, ids, acc) := function_parameter in
            Error_monad.__return (ctxt, (Script_typed_ir.R x), ids, acc)))
  | (Script_typed_ir.Option_t ty _ true, Some x) =>
    let 'existT _ __8 [ty, x] :=
      existT (fun __8 : Set => [(Script_typed_ir.ty __8) ** __8]) _ [ty, x] in
    Error_monad.op_gtgteqquestion
      (Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
      (fun ctxt =>
        Error_monad.op_gtgteqquestion
          (extract_big_map_updates ctxt fresh mode ids acc ty x)
          (fun function_parameter =>
            let '(ctxt, x, ids, acc) := function_parameter in
            Error_monad.__return (ctxt, (Some x), ids, acc)))
  | (Script_typed_ir.List_t ty _ true, l) =>
    let 'existT _ __9 [ty, l] :=
      existT (fun __9 : Set => [(Script_typed_ir.ty __9) ** a]) _ [ty, l] in
    Error_monad.op_gtgteqquestion
      (Error_monad.fold_left_s
        (fun function_parameter =>
          let '(ctxt, l, ids, acc) := function_parameter in
          fun x =>
            Error_monad.op_gtgteqquestion
              (Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
              (fun ctxt =>
                Error_monad.op_gtgteqquestion
                  (extract_big_map_updates ctxt fresh mode ids acc ty x)
                  (fun function_parameter =>
                    let '(ctxt, x, ids, acc) := function_parameter in
                    Error_monad.__return (ctxt, (cons x l), ids, acc))))
        (ctxt, nil, ids, acc) l)
      (fun function_parameter =>
        let '(ctxt, l, ids, acc) := function_parameter in
        Error_monad.__return (ctxt, (List.rev l), ids, acc))
  | (Script_typed_ir.Map_t _ ty _ true, M as m) =>
    let 'existT _ __11 [ty, M, m] :=
      existT (fun __11 : Set => [(Script_typed_ir.ty __11) ** a ** a]) _
        [ty, M, m] in
    Error_monad.op_gtgteqquestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Michelson_v1_gas.Cost_of.Legacy.map_to_list m)))
      (fun ctxt =>
        Error_monad.op_gtgteqquestion
          (Error_monad.fold_left_s
            (fun function_parameter =>
              let '(ctxt, m, ids, acc) := function_parameter in
              fun function_parameter =>
                let '(k, x) := function_parameter in
                Error_monad.op_gtgteqquestion
                  (Lwt.__return
                    (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle))
                  (fun ctxt =>
                    Error_monad.op_gtgteqquestion
                      (extract_big_map_updates ctxt fresh mode ids acc ty x)
                      (fun function_parameter =>
                        let '(ctxt, x, ids, acc) := function_parameter in
                        Error_monad.__return
                          (ctxt,
                            ((|M|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k
                              x m), ids, acc))))
            (ctxt, (|M|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.empty), ids, acc)
            ((|M|).(Script_typed_ir.Boxed_map.OPS).(S.MAP.bindings)
              (Pervasives.fst (|M|).(Script_typed_ir.Boxed_map.boxed))))
          (fun function_parameter =>
            let '(ctxt, m, ids, acc) := function_parameter in
            let M :=
              let OPS :=
                existT (A := unit) (fun _ => _) tt
                  (|M|).(Script_typed_ir.Boxed_map.OPS) in
              let key := (|M|).(Script_typed_ir.Boxed_map.key) in
              let value := (|M|).(Script_typed_ir.Boxed_map.value) in
              let key_ty := (|M|).(Script_typed_ir.Boxed_map.key_ty) in
              let boxed :=
                (m, (Pervasives.snd (|M|).(Script_typed_ir.Boxed_map.boxed))) in
              existT (A := unit) (fun _ => _) tt
                {|
                  Script_typed_ir.Boxed_map.OPS := (|OPS|);
                  Script_typed_ir.Boxed_map.key_ty := key_ty;
                  Script_typed_ir.Boxed_map.boxed := boxed
                |} in
            Error_monad.__return
              (ctxt, (existT (A := Set -> Set) _ _ (|M|)), ids, acc)))
  | (Script_typed_ir.Option_t _ _ true, None) =>
    Error_monad.__return (ctxt, None, ids, acc)
  | (Script_typed_ir.List_t _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Map_t _ _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Option_t _ _ false, None) =>
    Error_monad.__return (ctxt, None, ids, acc)
  | (Script_typed_ir.Pair_t _ _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Union_t _ _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Option_t _ _ false, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Chain_id_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Set_t _ _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Unit_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Int_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Nat_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Signature_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.String_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Bytes_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Mutez_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Key_hash_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Key_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Timestamp_t _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Address_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Bool_t _, v) => Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Lambda_t _ _ _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Contract_t _ _, v) =>
    Error_monad.__return (ctxt, v, ids, acc)
  | (Script_typed_ir.Operation_t _, _) =>
    (*  Assert instruction is not handled. *)
    assert false
  end.

Definition collect_big_maps {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty A) (x : A)
  : Lwt.t (Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context)) :=
  let fix collect {a : Set}
    (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty a) (x : a)
    (acc : (|Ids|).(S.SET.t)) {struct ctxt}
    : Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context) :=
    match (ty, x) with
    |
      (Script_typed_ir.Big_map_t _ _ _, {|
        Script_typed_ir.big_map.id := Some id |}) =>
      Error_monad.op_gtgtquestion
        (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
        (fun ctxt => Error_monad.ok (((|Ids|).(S.SET.add) id acc), ctxt))
    | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, (xl, xr)) =>
      let 'existT _ [__2, __3] [tyl, tyr, xl, xr] :=
        existT
          (fun '[__2, __3] =>
            [(Script_typed_ir.ty __2) ** (Script_typed_ir.ty __3) ** __2 ** __3])
          _ [tyl, tyr, xl, xr] in
      Error_monad.op_gtgtquestion (collect ctxt tyl xl acc)
        (fun function_parameter =>
          let '(acc, ctxt) := function_parameter in
          collect ctxt tyr xr acc)
    | (Script_typed_ir.Union_t (ty, _) (_, _) _ true, Script_typed_ir.L x) =>
      let 'existT _ __4 [ty, x] :=
        existT (fun __4 : Set => [(Script_typed_ir.ty __4) ** __4]) _ [ty, x] in
      collect ctxt ty x acc
    | (Script_typed_ir.Union_t (_, _) (ty, _) _ true, Script_typed_ir.R x) =>
      let 'existT _ __7 [ty, x] :=
        existT (fun __7 : Set => [(Script_typed_ir.ty __7) ** __7]) _ [ty, x] in
      collect ctxt ty x acc
    | (Script_typed_ir.Option_t ty _ true, Some x) =>
      let 'existT _ __8 [ty, x] :=
        existT (fun __8 : Set => [(Script_typed_ir.ty __8) ** __8]) _ [ty, x] in
      collect ctxt ty x acc
    | (Script_typed_ir.List_t ty _ true, l) =>
      let 'existT _ __9 [ty, l] :=
        existT (fun __9 : Set => [(Script_typed_ir.ty __9) ** a]) _ [ty, l] in
      List.fold_left
        (fun acc =>
          fun x =>
            Error_monad.op_gtgtquestion acc
              (fun function_parameter =>
                let '(acc, ctxt) := function_parameter in
                collect ctxt ty x acc)) (Error_monad.ok (acc, ctxt)) l
    | (Script_typed_ir.Map_t _ ty _ true, m) =>
      let 'existT _ __11 [ty, m] :=
        existT (fun __11 : Set => [(Script_typed_ir.ty __11) ** a]) _ [ty, m] in
      map_fold
        (fun function_parameter =>
          let '_ := function_parameter in
          fun v =>
            fun acc =>
              Error_monad.op_gtgtquestion acc
                (fun function_parameter =>
                  let '(acc, ctxt) := function_parameter in
                  collect ctxt ty v acc)) m (Error_monad.ok (acc, ctxt))
    | (Script_typed_ir.List_t _ _ false, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Map_t _ _ _ false, _) => Error_monad.ok (acc, ctxt)
    |
      (Script_typed_ir.Big_map_t _ _ _, {| Script_typed_ir.big_map.id := None |})
      => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Option_t _ _ true, None) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Option_t _ _ false, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Union_t _ _ _ false, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Pair_t _ _ _ false, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Chain_id_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Set_t _ _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Unit_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Int_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Nat_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Signature_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.String_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Bytes_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Mutez_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Key_hash_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Key_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Timestamp_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Address_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Bool_t _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Lambda_t _ _ _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Contract_t _ _, _) => Error_monad.ok (acc, ctxt)
    | (Script_typed_ir.Operation_t _, _) =>
      (*  Assert instruction is not handled. *)
      assert false
    end in
  Lwt.__return (collect ctxt ty x no_big_map_id).

Definition extract_big_map_diff {A : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode) (temporary : bool)
  (to_duplicate : (|Ids|).(S.SET.t)) (to_update : (|Ids|).(S.SET.t))
  (ty : Script_typed_ir.ty A) (v : A)
  : Lwt.t
    (Error_monad.tzresult
      (A * option (list Alpha_context.Contract.big_map_diff_item) *
        Alpha_context.context)) :=
  let to_duplicate := (|Ids|).(S.SET.diff) to_duplicate to_update in
  let fresh :=
    if temporary then
      fun c => Error_monad.__return (Alpha_context.Big_map.fresh_temporary c)
    else
      Alpha_context.Big_map.fresh in
  Error_monad.op_gtgteqquestion
    (extract_big_map_updates ctxt fresh mode to_duplicate nil ty v)
    (fun function_parameter =>
      let '(ctxt, v, alive, diffs) := function_parameter in
      let diffs :=
        if temporary then
          diffs
        else
          let dead := (|Ids|).(S.SET.diff) to_update alive in
          cons
            ((|Ids|).(S.SET.fold)
              (fun id => fun acc => cons (Alpha_context.Contract.Clear id) acc)
              dead nil) diffs in
      match diffs with
      | [] => Error_monad.__return (v, None, ctxt)
      | diffs => Error_monad.__return (v, (Some (List.flatten diffs)), ctxt)
      end).

Definition list_of_big_map_ids (ids : (|Ids|).(S.SET.t))
  : list (|Ids|).(S.SET.elt) := (|Ids|).(S.SET.elements) ids.
