(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Block_header_repr.
Require Tezos.Contract_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Reserved Notation "'manager".
  
  Inductive manager_gadt : Set :=
  | Reveal_manager_kind : manager_gadt
  | Transaction_manager_kind : manager_gadt
  | Origination_manager_kind : manager_gadt
  | Delegation_manager_kind : manager_gadt
  
  where "'manager" := (fun (_ : Set) => manager_gadt).
  
  Definition manager := 'manager.
End Kind.

Module raw.
  Record record : Set := Build {
    shell : Operation.shell_header;
    proto : MBytes.t }.
  Definition with_shell shell (r : record) :=
    Build shell r.(proto).
  Definition with_proto proto (r : record) :=
    Build r.(shell) proto.
End raw.
Definition raw := raw.record.

Definition raw_encoding : Data_encoding.t Operation.t := Operation.encoding.

Module contents.
  Module Endorsement.
    Record record {level : Set} : Set := {
      level : level }.
    Arguments record : clear implicits.
  End Endorsement.
  Definition Endorsement_skeleton := Endorsement.record.
  
  Module Seed_nonce_revelation.
    Record record {level nonce : Set} : Set := {
      level : level;
      nonce : nonce }.
    Arguments record : clear implicits.
  End Seed_nonce_revelation.
  Definition Seed_nonce_revelation_skeleton := Seed_nonce_revelation.record.
  
  Module Double_endorsement_evidence.
    Record record {op1 op2 : Set} : Set := {
      op1 : op1;
      op2 : op2 }.
    Arguments record : clear implicits.
  End Double_endorsement_evidence.
  Definition Double_endorsement_evidence_skeleton :=
    Double_endorsement_evidence.record.
  
  Module Double_baking_evidence.
    Record record {bh1 bh2 : Set} : Set := {
      bh1 : bh1;
      bh2 : bh2 }.
    Arguments record : clear implicits.
  End Double_baking_evidence.
  Definition Double_baking_evidence_skeleton := Double_baking_evidence.record.
  
  Module Activate_account.
    Record record {id activation_code : Set} : Set := {
      id : id;
      activation_code : activation_code }.
    Arguments record : clear implicits.
  End Activate_account.
  Definition Activate_account_skeleton := Activate_account.record.
  
  Module Proposals.
    Record record {source period proposals : Set} : Set := {
      source : source;
      period : period;
      proposals : proposals }.
    Arguments record : clear implicits.
  End Proposals.
  Definition Proposals_skeleton := Proposals.record.
  
  Module Ballot.
    Record record {source period proposal ballot : Set} : Set := {
      source : source;
      period : period;
      proposal : proposal;
      ballot : ballot }.
    Arguments record : clear implicits.
  End Ballot.
  Definition Ballot_skeleton := Ballot.record.
  
  Module Manager_operation.
    Record record {source fee counter operation gas_limit storage_limit : Set} :
      Set := {
      source : source;
      fee : fee;
      counter : counter;
      operation : operation;
      gas_limit : gas_limit;
      storage_limit : storage_limit }.
    Arguments record : clear implicits.
  End Manager_operation.
  Definition Manager_operation_skeleton := Manager_operation.record.
End contents.

Module manager_operation.
  Module Transaction.
    Record record {amount parameters entrypoint destination : Set} : Set := {
      amount : amount;
      parameters : parameters;
      entrypoint : entrypoint;
      destination : destination }.
    Arguments record : clear implicits.
  End Transaction.
  Definition Transaction_skeleton := Transaction.record.
  
  Module Origination.
    Record record {delegate script credit preorigination : Set} : Set := {
      delegate : delegate;
      script : script;
      credit : credit;
      preorigination : preorigination }.
    Arguments record : clear implicits.
  End Origination.
  Definition Origination_skeleton := Origination.record.
End manager_operation.

Module operation.
  Record record {shell protocol_data : Set} : Set := Build {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
  Definition with_shell {t_shell t_protocol_data} shell
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data shell r.(protocol_data).
  Definition with_protocol_data {t_shell t_protocol_data} protocol_data
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data r.(shell) protocol_data.
End operation.
Definition operation_skeleton := operation.record.

Module protocol_data.
  Record record {contents signature : Set} : Set := Build {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
  Definition with_contents {t_contents t_signature} contents
    (r : record t_contents t_signature) :=
    Build t_contents t_signature contents r.(signature).
  Definition with_signature {t_contents t_signature} signature
    (r : record t_contents t_signature) :=
    Build t_contents t_signature r.(contents) signature.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Reserved Notation "'contents.Endorsement".
Reserved Notation "'contents.Seed_nonce_revelation".
Reserved Notation "'contents.Double_endorsement_evidence".
Reserved Notation "'contents.Double_baking_evidence".
Reserved Notation "'contents.Activate_account".
Reserved Notation "'contents.Proposals".
Reserved Notation "'contents.Ballot".
Reserved Notation "'contents.Manager_operation".
Reserved Notation "'manager_operation.Transaction".
Reserved Notation "'manager_operation.Origination".
Reserved Notation "'contents_list".
Reserved Notation "'protocol_data".
Reserved Notation "'operation".
Reserved Notation "'contents".
Reserved Notation "'manager_operation".
Reserved Notation "'counter".

Inductive contents_list_gadt : Set :=
| Single : forall {kind : Set}, 'contents kind -> contents_list_gadt
| Cons : forall {kind : Set},
  'contents (Kind.manager kind) -> contents_list_gadt -> contents_list_gadt

with contents_gadt : Set :=
| Endorsement : 'contents.Endorsement -> contents_gadt
| Seed_nonce_revelation : 'contents.Seed_nonce_revelation -> contents_gadt
| Double_endorsement_evidence :
  'contents.Double_endorsement_evidence -> contents_gadt
| Double_baking_evidence : 'contents.Double_baking_evidence -> contents_gadt
| Activate_account : 'contents.Activate_account -> contents_gadt
| Proposals : 'contents.Proposals -> contents_gadt
| Ballot : 'contents.Ballot -> contents_gadt
| Manager_operation : forall {kind : Set},
  'contents.Manager_operation kind -> contents_gadt

with manager_operation_gadt : Set :=
| Reveal : (|Signature.Public_key|).(S.SPublic_key.t) -> manager_operation_gadt
| Transaction : 'manager_operation.Transaction -> manager_operation_gadt
| Origination : 'manager_operation.Origination -> manager_operation_gadt
| Delegation :
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) ->
  manager_operation_gadt

where "'contents_list" := (fun (_ : Set) => contents_list_gadt)
and "'protocol_data" := (fun (t_kind : Set) =>
  protocol_data_skeleton ('contents_list t_kind) (option Signature.t))
and "'operation" := (fun (t_kind : Set) =>
  operation_skeleton Operation.shell_header ('protocol_data t_kind))
and "'contents" := (fun (_ : Set) => contents_gadt)
and "'manager_operation" := (fun (_ : Set) => manager_operation_gadt)
and "'counter" := (Z.t)
and "'contents.Endorsement" := (contents.Endorsement_skeleton Raw_level_repr.t)
and "'contents.Seed_nonce_revelation" :=
  (contents.Seed_nonce_revelation_skeleton Raw_level_repr.t Seed_repr.nonce)
and "'contents.Double_endorsement_evidence" :=
  (contents.Double_endorsement_evidence_skeleton ('operation Kind.endorsement)
    ('operation Kind.endorsement))
and "'contents.Double_baking_evidence" :=
  (contents.Double_baking_evidence_skeleton Block_header_repr.t
    Block_header_repr.t)
and "'contents.Activate_account" :=
  (contents.Activate_account_skeleton
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code)
and "'contents.Proposals" :=
  (contents.Proposals_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Voting_period_repr.t
    (list (|Protocol_hash|).(S.HASH.t)))
and "'contents.Ballot" :=
  (contents.Ballot_skeleton (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)
    Voting_period_repr.t (|Protocol_hash|).(S.HASH.t) Vote_repr.ballot)
and "'contents.Manager_operation" := (fun (t_kind : Set) =>
  contents.Manager_operation_skeleton Signature.public_key_hash Tez_repr.tez
    'counter ('manager_operation t_kind) Z.t Z.t)
and "'manager_operation.Transaction" :=
  (manager_operation.Transaction_skeleton Tez_repr.tez Script_repr.lazy_expr
    string Contract_repr.contract)
and "'manager_operation.Origination" :=
  (manager_operation.Origination_skeleton
    (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) Script_repr.t
    Tez_repr.tez (option Contract_repr.t)).

Module
  ConstructorRecordNotations_contents_list_gadt_contents_gadt_manager_operation_gadt.
  Module contents.
    Definition Endorsement := 'contents.Endorsement.
    Definition Seed_nonce_revelation := 'contents.Seed_nonce_revelation.
    Definition Double_endorsement_evidence :=
      'contents.Double_endorsement_evidence.
    Definition Double_baking_evidence := 'contents.Double_baking_evidence.
    Definition Activate_account := 'contents.Activate_account.
    Definition Proposals := 'contents.Proposals.
    Definition Ballot := 'contents.Ballot.
    Definition Manager_operation := 'contents.Manager_operation.
  End contents.
  Module manager_operation.
    Definition Transaction := 'manager_operation.Transaction.
    Definition Origination := 'manager_operation.Origination.
  End manager_operation.
End
  ConstructorRecordNotations_contents_list_gadt_contents_gadt_manager_operation_gadt.
Import
  ConstructorRecordNotations_contents_list_gadt_contents_gadt_manager_operation_gadt.

Definition contents_list := 'contents_list.
Definition protocol_data := 'protocol_data.
Definition operation := 'operation.
Definition contents := 'contents.
Definition manager_operation := 'manager_operation.
Definition counter := 'counter.

Definition manager_kind {kind : Set}
  (function_parameter : manager_operation kind) : Kind.manager kind :=
  match function_parameter with
  | Reveal _ => Kind.Reveal_manager_kind
  | Transaction _ => Kind.Transaction_manager_kind
  | Origination _ => Kind.Origination_manager_kind
  | Delegation _ => Kind.Delegation_manager_kind
  end.

Module internal_operation.
  Record record {kind : Set} : Set := Build {
    source : Contract_repr.contract;
    operation : manager_operation kind;
    nonce : Z }.
  Arguments record : clear implicits.
  Definition with_source {t_kind} source (r : record t_kind) :=
    Build t_kind source r.(operation) r.(nonce).
  Definition with_operation {t_kind} operation (r : record t_kind) :=
    Build t_kind r.(source) operation r.(nonce).
  Definition with_nonce {t_kind} nonce (r : record t_kind) :=
    Build t_kind r.(source) r.(operation) nonce.
End internal_operation.
Definition internal_operation := internal_operation.record.

Inductive packed_manager_operation : Set :=
| Manager : forall {kind : Set},
  manager_operation kind -> packed_manager_operation.

Inductive packed_contents : Set :=
| Contents : forall {kind : Set}, contents kind -> packed_contents.

Inductive packed_contents_list : Set :=
| Contents_list : forall {kind : Set},
  contents_list kind -> packed_contents_list.

Inductive packed_protocol_data : Set :=
| Operation_data : forall {kind : Set},
  protocol_data kind -> packed_protocol_data.

Module packed_operation.
  Record record : Set := Build {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End packed_operation.
Definition packed_operation := packed_operation.record.

Definition pack {A : Set} (function_parameter : operation A)
  : packed_operation :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  {| packed_operation.shell := shell;
    packed_operation.protocol_data := Operation_data protocol_data |}.

Inductive packed_internal_operation : Set :=
| Internal_operation : forall {kind : Set},
  internal_operation kind -> packed_internal_operation.

Fixpoint to_list (function_parameter : packed_contents_list)
  {struct function_parameter} : list packed_contents :=
  let 'Contents_list content := function_parameter in
  let 'existT _ __Contents_list_'kind content :=
    existT (A := Set)
      (fun __Contents_list_'kind => contents_list __Contents_list_'kind) _
      content in
  match content with
  | Single o =>
    let o := obj_magic (contents __Contents_list_'kind) o in
    obj_magic (list packed_contents) [ Contents o ]
  | Cons o os =>
    let 'existT _ [__0, __1] [o, os] :=
      obj_magic_exists (Es := [Set ** Set])
        (fun '[__0, __1] =>
          [contents (Kind.manager __0) ** contents_list (Kind.manager __1)])
        [o, os] in
    obj_magic (list packed_contents)
      (cons (Contents o) (to_list (Contents_list os)))
  end.

Fixpoint of_list (function_parameter : list packed_contents)
  {struct function_parameter} : packed_contents_list :=
  match function_parameter with
  | [] =>
    (* âŒ Assert instruction is not handled. *)
    assert false
  | cons (Contents o) [] =>
    let 'existT _ __Contents_'kind o :=
      existT (A := Set) (fun __Contents_'kind => contents __Contents_'kind) _ o
      in
    Contents_list (Single o)
  | cons (Contents o) os =>
    let 'existT _ __Contents_'kind1 [o, os] :=
      existT (A := Set)
        (fun __Contents_'kind1 =>
          [contents __Contents_'kind1 ** list packed_contents]) _ [o, os] in
    let 'Contents_list os := of_list os in
    let 'existT _ __Contents_list_'kind os :=
      existT (A := Set)
        (fun __Contents_list_'kind => contents_list __Contents_list_'kind) _ os
      in
    match (o, os) with
    | (Manager_operation _, Single (Manager_operation _)) =>
      Contents_list (Cons o os)
    | (Manager_operation _, Cons _ _) => Contents_list (Cons o os)
    | _ =>
      Pervasives.failwith
        "Operation list of length > 1 should only contains manager operations."
    end
  end.

Module Encoding.
  Import Data_encoding.
  
  Definition __case_value {A B : Set}
    (tag : Data_encoding.case_tag) (name : string)
    (args : Data_encoding.encoding A) (proj : B -> option A) (inj : A -> B)
    : Data_encoding.case B :=
    Data_encoding.__case_value (String.capitalize_ascii name) None tag
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None "kind" (Data_encoding.constant name)))
        args)
      (fun x =>
        match proj x with
        | None => None
        | Some x => Some (tt, x)
        end)
      (fun function_parameter =>
        let '(_, x) := function_parameter in
        inj x).
  
  Module Manager_operations.
    Module case.
      Module MCase.
        Record record {tag name encoding select proj inj : Set} : Set := {
          tag : tag;
          name : name;
          encoding : encoding;
          select : select;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
      End MCase.
      Definition MCase_skeleton := MCase.record.
    End case.
    
    Reserved Notation "'case.MCase".
    
    Inductive case (kind : Set) : Set :=
    | MCase : forall {a : Set}, 'case.MCase a kind -> case kind
    
    where "'case.MCase" := (fun (t_a t_kind : Set) =>
      case.MCase_skeleton Z string (Data_encoding.t t_a)
        (packed_manager_operation -> option (manager_operation t_kind))
        (manager_operation t_kind -> t_a) (t_a -> manager_operation t_kind)).
    
    Module ConstructorRecordNotations_case.
      Module case.
        Definition MCase := 'case.MCase.
      End case.
    End ConstructorRecordNotations_case.
    Import ConstructorRecordNotations_case.
    
    Arguments MCase {_ _}.
    
    Definition reveal_case : case Kind.reveal :=
      MCase
        {| case.MCase.tag := 0; case.MCase.name := "reveal";
          case.MCase.encoding :=
            Data_encoding.obj1
              (Data_encoding.req None None "public_key"
                (|Signature.Public_key|).(S.SPublic_key.encoding));
          case.MCase.select :=
            fun function_parameter =>
              match function_parameter with
              | Manager ((Reveal _) as op) => Some op
              | _ => None
              end;
          case.MCase.proj :=
            fun function_parameter =>
              let 'Reveal pkh := function_parameter in
              pkh; case.MCase.inj := fun pkh => Reveal pkh |}.
    
    Definition entrypoint_encoding
      : Data_encoding.encoding (|Compare.String|).(Compare.S.t) :=
      (Data_encoding.def "entrypoint" (Some "entrypoint")
        (Some "Named entrypoint to a Michelson smart contract"))
        (let builtin_case (tag : Z) (name : (|Compare.String|).(Compare.S.t))
          : Data_encoding.case (|Compare.String|).(Compare.S.t) :=
          Data_encoding.__case_value name None (Data_encoding.Tag tag)
            (Data_encoding.constant name)
            (fun n =>
              if (|Compare.String|).(Compare.S.op_eq) n name then
                Some tt
              else
                None)
            (fun function_parameter =>
              let '_ := function_parameter in
              name) in
        Data_encoding.union None
          [
            builtin_case 0 "default";
            builtin_case 1 "root";
            builtin_case 2 "do";
            builtin_case 3 "set_delegate";
            builtin_case 4 "remove_delegate";
            Data_encoding.__case_value "named" None (Data_encoding.Tag 255)
              (Data_encoding.Bounded.__string_value 31)
              (fun s => Some s) (fun s => s)
          ]).
    
    Definition transaction_case : case Kind.transaction :=
      MCase
        {| case.MCase.tag := 1; case.MCase.name := "transaction";
          case.MCase.encoding :=
            Data_encoding.obj3
              (Data_encoding.req None None "amount" Tez_repr.encoding)
              (Data_encoding.req None None "destination" Contract_repr.encoding)
              (Data_encoding.opt None None "parameters"
                (Data_encoding.obj2
                  (Data_encoding.req None None "entrypoint" entrypoint_encoding)
                  (Data_encoding.req None None "value"
                    Script_repr.lazy_expr_encoding)));
          case.MCase.select :=
            fun function_parameter =>
              match function_parameter with
              | Manager ((Transaction _) as op) => Some op
              | _ => None
              end;
          case.MCase.proj :=
            fun function_parameter =>
              let
                'Transaction {|
                  manager_operation.Transaction.amount := amount;
                    manager_operation.Transaction.parameters := parameters;
                    manager_operation.Transaction.entrypoint := entrypoint;
                    manager_operation.Transaction.destination := destination
                    |} := function_parameter in
              let parameters :=
                if
                  Pervasives.op_andand
                    (Script_repr.is_unit_parameter parameters)
                    ((|Compare.String|).(Compare.S.op_eq) entrypoint "default")
                  then
                  None
                else
                  Some (entrypoint, parameters) in
              (amount, destination, parameters);
          case.MCase.inj :=
            fun function_parameter =>
              let '(amount, destination, parameters) := function_parameter in
              let '(entrypoint, parameters) :=
                match parameters with
                | None => ("default", Script_repr.unit_parameter)
                | Some (entrypoint, value) => (entrypoint, value)
                end in
              Transaction
                {| manager_operation.Transaction.amount := amount;
                  manager_operation.Transaction.parameters := parameters;
                  manager_operation.Transaction.entrypoint := entrypoint;
                  manager_operation.Transaction.destination := destination |} |}.
    
    Definition origination_case : case Kind.origination :=
      MCase
        {| case.MCase.tag := 2; case.MCase.name := "origination";
          case.MCase.encoding :=
            Data_encoding.obj3
              (Data_encoding.req None None "balance" Tez_repr.encoding)
              (Data_encoding.opt None None "delegate"
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
              (Data_encoding.req None None "script" Script_repr.encoding);
          case.MCase.select :=
            fun function_parameter =>
              match function_parameter with
              | Manager ((Origination _) as op) => Some op
              | _ => None
              end;
          case.MCase.proj :=
            fun function_parameter =>
              let
                'Origination {|
                  manager_operation.Origination.delegate := delegate;
                    manager_operation.Origination.script := script;
                    manager_operation.Origination.credit := credit;
                    manager_operation.Origination.preorigination := _
                    |} := function_parameter in
              (credit, delegate, script);
          case.MCase.inj :=
            fun function_parameter =>
              let '(credit, delegate, script) := function_parameter in
              Origination
                {| manager_operation.Origination.delegate := delegate;
                  manager_operation.Origination.script := script;
                  manager_operation.Origination.credit := credit;
                  manager_operation.Origination.preorigination := None |} |}.
    
    Definition delegation_case : case Kind.delegation :=
      MCase
        {| case.MCase.tag := 3; case.MCase.name := "delegation";
          case.MCase.encoding :=
            Data_encoding.obj1
              (Data_encoding.opt None None "delegate"
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding));
          case.MCase.select :=
            fun function_parameter =>
              match function_parameter with
              | Manager ((Delegation _) as op) => Some op
              | _ => None
              end;
          case.MCase.proj :=
            fun function_parameter =>
              let 'Delegation __key_value := function_parameter in
              __key_value;
          case.MCase.inj := fun __key_value => Delegation __key_value |}.
    
    Definition encoding : Data_encoding.encoding packed_manager_operation :=
      let make {A : Set} (function_parameter : case A)
        : Data_encoding.case packed_manager_operation :=
        let
          'MCase {|
            case.MCase.tag := tag;
              case.MCase.name := name;
              case.MCase.encoding := encoding;
              case.MCase.select := select;
              case.MCase.proj := proj;
              case.MCase.inj := inj
              |} := function_parameter in
        let 'existT _ __MCase_'a [tag, name, encoding, select, proj, inj] :=
          existT (A := Set)
            (fun __MCase_'a =>
              [Z ** string ** Data_encoding.t __MCase_'a **
                packed_manager_operation -> option (manager_operation A) **
                manager_operation A -> __MCase_'a **
                __MCase_'a -> manager_operation A]) _
            [tag, name, encoding, select, proj, inj] in
        __case_value (Data_encoding.Tag tag) name encoding
          (fun o =>
            match select o with
            | None => None
            | Some o => Some (proj o)
            end) (fun x => Manager (inj x)) in
      Data_encoding.union (Some Data_encoding.Uint8)
        [
          make reveal_case;
          make transaction_case;
          make origination_case;
          make delegation_case
        ].
  End Manager_operations.
  
  Module case.
    Module Case.
      Record record {tag name encoding select proj inj : Set} : Set := {
        tag : tag;
        name : name;
        encoding : encoding;
        select : select;
        proj : proj;
        inj : inj }.
      Arguments record : clear implicits.
    End Case.
    Definition Case_skeleton := Case.record.
  End case.
  
  Reserved Notation "'case.Case".
  
  Inductive case (b : Set) : Set :=
  | Case : forall {a : Set}, 'case.Case a b -> case b
  
  where "'case.Case" := (fun (t_a t_b : Set) =>
    case.Case_skeleton Z string (Data_encoding.t t_a)
      (packed_contents -> option (contents t_b)) (contents t_b -> t_a)
      (t_a -> contents t_b)).
  
  Module ConstructorRecordNotations_case.
    Module case.
      Definition Case := 'case.Case.
    End case.
  End ConstructorRecordNotations_case.
  Import ConstructorRecordNotations_case.
  
  Arguments Case {_ _}.
  
  Definition endorsement_encoding
    : Data_encoding.encoding Raw_level_repr.raw_level :=
    Data_encoding.obj1
      (Data_encoding.req None None "level" Raw_level_repr.encoding).
  
  Definition endorsement_case : case Kind.endorsement :=
    Case
      {| case.Case.tag := 0; case.Case.name := "endorsement";
        case.Case.encoding := endorsement_encoding;
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents ((Endorsement _) as op) => Some op
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let 'Endorsement {| contents.Endorsement.level := level |} :=
              function_parameter in
            level;
        case.Case.inj :=
          fun level => Endorsement {| contents.Endorsement.level := level |} |}.
  
  Definition endorsement_encoding
    : Data_encoding.encoding (operation Kind.endorsement) :=
    let make {A : Set} (function_parameter : case A)
      : Data_encoding.case (contents A) :=
      let
        'Case {|
          case.Case.tag := tag;
            case.Case.name := name;
            case.Case.encoding := encoding;
            case.Case.select := _;
            case.Case.proj := proj;
            case.Case.inj := inj
            |} := function_parameter in
      let 'existT _ __Case_'a [tag, name, encoding, proj, inj] :=
        existT (A := Set)
          (fun __Case_'a =>
            [Z ** string ** Data_encoding.t __Case_'a ** contents A -> __Case_'a
              ** __Case_'a -> contents A]) _ [tag, name, encoding, proj, inj] in
      __case_value (Data_encoding.Tag tag) name encoding
        (fun o => Some (proj o)) (fun x => inj x) in
    let to_list (function_parameter : contents_list Kind.endorsement)
      : contents Kind.endorsement :=
      let 'Single o := function_parameter in
      o in
    let of_list (o : contents Kind.endorsement)
      : contents_list Kind.endorsement :=
      Single o in
    (let arg := Data_encoding.def "inlined.endorsement" in
    fun eta => arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =>
          let '{|
            operation.shell := shell;
              operation.protocol_data := {|
                protocol_data.contents := contents;
                  protocol_data.signature := signature
                  |}
              |} := function_parameter in
          (shell, (contents, signature)))
        (fun function_parameter =>
          let '(shell, (contents, signature)) := function_parameter in
          {| operation.shell := shell;
            operation.protocol_data :=
              {| protocol_data.contents := contents;
                protocol_data.signature := signature |} |}) None
        (Data_encoding.merge_objs Operation.shell_header_encoding
          (Data_encoding.obj2
            (Data_encoding.req None None "operations"
              ((let arg := Data_encoding.conv to_list of_list in
              fun eta => arg None eta)
                ((let arg := Data_encoding.def "inlined.endorsement.contents" in
                fun eta => arg None None eta)
                  (Data_encoding.union None [ make endorsement_case ]))))
            (Data_encoding.varopt None None "signature" Signature.encoding)))).
  
  Definition seed_nonce_revelation_case : case Kind.seed_nonce_revelation :=
    Case
      {| case.Case.tag := 1; case.Case.name := "seed_nonce_revelation";
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None "level" Raw_level_repr.encoding)
            (Data_encoding.req None None "nonce" Seed_repr.nonce_encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents ((Seed_nonce_revelation _) as op) => Some op
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              'Seed_nonce_revelation {|
                contents.Seed_nonce_revelation.level := level;
                  contents.Seed_nonce_revelation.nonce := __nonce_value
                  |} := function_parameter in
            (level, __nonce_value);
        case.Case.inj :=
          fun function_parameter =>
            let '(level, __nonce_value) := function_parameter in
            Seed_nonce_revelation
              {| contents.Seed_nonce_revelation.level := level;
                contents.Seed_nonce_revelation.nonce := __nonce_value |} |}.
  
  Definition double_endorsement_evidence_case
    : case Kind.double_endorsement_evidence :=
    Case
      {| case.Case.tag := 2; case.Case.name := "double_endorsement_evidence";
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None "op1"
              (Data_encoding.dynamic_size None endorsement_encoding))
            (Data_encoding.req None None "op2"
              (Data_encoding.dynamic_size None endorsement_encoding));
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents ((Double_endorsement_evidence _) as op) => Some op
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              'Double_endorsement_evidence {|
                contents.Double_endorsement_evidence.op1 := op1;
                  contents.Double_endorsement_evidence.op2 := op2
                  |} := function_parameter in
            (op1, op2);
        case.Case.inj :=
          fun function_parameter =>
            let '(op1, op2) := function_parameter in
            Double_endorsement_evidence
              {| contents.Double_endorsement_evidence.op1 := op1;
                contents.Double_endorsement_evidence.op2 := op2 |} |}.
  
  Definition double_baking_evidence_case : case Kind.double_baking_evidence :=
    Case
      {| case.Case.tag := 3; case.Case.name := "double_baking_evidence";
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None "bh1"
              (Data_encoding.dynamic_size None Block_header_repr.encoding))
            (Data_encoding.req None None "bh2"
              (Data_encoding.dynamic_size None Block_header_repr.encoding));
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents ((Double_baking_evidence _) as op) => Some op
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              'Double_baking_evidence {|
                contents.Double_baking_evidence.bh1 := bh1;
                  contents.Double_baking_evidence.bh2 := bh2
                  |} := function_parameter in
            (bh1, bh2);
        case.Case.inj :=
          fun function_parameter =>
            let '(bh1, bh2) := function_parameter in
            Double_baking_evidence
              {| contents.Double_baking_evidence.bh1 := bh1;
                contents.Double_baking_evidence.bh2 := bh2 |} |}.
  
  Definition activate_account_case : case Kind.activate_account :=
    Case
      {| case.Case.tag := 4; case.Case.name := "activate_account";
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None "pkh"
              (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None "secret"
              Blinded_public_key_hash.activation_code_encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents ((Activate_account _) as op) => Some op
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              'Activate_account {|
                contents.Activate_account.id := id;
                  contents.Activate_account.activation_code := activation_code
                  |} := function_parameter in
            (id, activation_code);
        case.Case.inj :=
          fun function_parameter =>
            let '(id, activation_code) := function_parameter in
            Activate_account
              {| contents.Activate_account.id := id;
                contents.Activate_account.activation_code := activation_code |}
        |}.
  
  Definition proposals_case : case Kind.proposals :=
    Case
      {| case.Case.tag := 5; case.Case.name := "proposals";
        case.Case.encoding :=
          Data_encoding.obj3
            (Data_encoding.req None None "source"
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None "period" Voting_period_repr.encoding)
            (Data_encoding.req None None "proposals"
              (Data_encoding.__list_value None
                (|Protocol_hash|).(S.HASH.encoding)));
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents ((Proposals _) as op) => Some op
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              'Proposals {|
                contents.Proposals.source := source;
                  contents.Proposals.period := period;
                  contents.Proposals.proposals := proposals
                  |} := function_parameter in
            (source, period, proposals);
        case.Case.inj :=
          fun function_parameter =>
            let '(source, period, proposals) := function_parameter in
            Proposals
              {| contents.Proposals.source := source;
                contents.Proposals.period := period;
                contents.Proposals.proposals := proposals |} |}.
  
  Definition ballot_case : case Kind.ballot :=
    Case
      {| case.Case.tag := 6; case.Case.name := "ballot";
        case.Case.encoding :=
          Data_encoding.obj4
            (Data_encoding.req None None "source"
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None "period" Voting_period_repr.encoding)
            (Data_encoding.req None None "proposal"
              (|Protocol_hash|).(S.HASH.encoding))
            (Data_encoding.req None None "ballot" Vote_repr.ballot_encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            | Contents ((Ballot _) as op) => Some op
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              'Ballot {|
                contents.Ballot.source := source;
                  contents.Ballot.period := period;
                  contents.Ballot.proposal := proposal;
                  contents.Ballot.ballot := ballot
                  |} := function_parameter in
            (source, period, proposal, ballot);
        case.Case.inj :=
          fun function_parameter =>
            let '(source, period, proposal, ballot) := function_parameter in
            Ballot
              {| contents.Ballot.source := source;
                contents.Ballot.period := period;
                contents.Ballot.proposal := proposal;
                contents.Ballot.ballot := ballot |} |}.
  
  Definition manager_encoding
    : Data_encoding.encoding
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * Tez_repr.t * Z.t *
        Z.t * Z.t) :=
    Data_encoding.obj5
      (Data_encoding.req None None "source"
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
      (Data_encoding.req None None "fee" Tez_repr.encoding)
      (Data_encoding.req None None "counter"
        (Data_encoding.check_size 10 Data_encoding.n))
      (Data_encoding.req None None "gas_limit"
        (Data_encoding.check_size 10 Data_encoding.n))
      (Data_encoding.req None None "storage_limit"
        (Data_encoding.check_size 10 Data_encoding.n)).
  
  Definition extract {A : Set} (function_parameter : contents (Kind.manager A))
    : Signature.public_key_hash * Tez_repr.tez * counter * Z.t * Z.t :=
    let
      'Manager_operation {|
        contents.Manager_operation.source := source;
          contents.Manager_operation.fee := fee;
          contents.Manager_operation.counter := counter;
          contents.Manager_operation.operation := _;
          contents.Manager_operation.gas_limit := gas_limit;
          contents.Manager_operation.storage_limit := storage_limit
          |} := function_parameter in
    (source, fee, counter, gas_limit, storage_limit).
  
  Definition rebuild {A : Set}
    (function_parameter :
      Signature.public_key_hash * Tez_repr.tez * counter * Z.t * Z.t)
    : manager_operation A -> contents (Kind.manager A) :=
    let '(source, fee, counter, gas_limit, storage_limit) := function_parameter
      in
    fun operation =>
      Manager_operation
        {| contents.Manager_operation.source := source;
          contents.Manager_operation.fee := fee;
          contents.Manager_operation.counter := counter;
          contents.Manager_operation.operation := operation;
          contents.Manager_operation.gas_limit := gas_limit;
          contents.Manager_operation.storage_limit := storage_limit |}.
  
  Definition make_manager_case {A : Set}
    (tag : Z) (function_parameter : Manager_operations.case A)
    : case (Kind.manager A) :=
    let 'Manager_operations.MCase mcase := function_parameter in
    let 'existT _ __MCase_'a mcase :=
      existT (A := Set)
        (fun __MCase_'a => Manager_operations.case.MCase __MCase_'a kind) _
        mcase in
    Case
      {| case.Case.tag := tag;
        case.Case.name := mcase.(Manager_operations.case.MCase.name);
        case.Case.encoding :=
          Data_encoding.merge_objs manager_encoding
            mcase.(Manager_operations.case.MCase.encoding);
        case.Case.select :=
          fun function_parameter =>
            match function_parameter with
            |
              Contents
                (Manager_operation
                  ({| contents.Manager_operation.operation := operation |} as op))
              =>
              let 'existT _ __0 [operation, op] :=
                existT (A := Set)
                  (fun __0 =>
                    [manager_operation __0 ** contents.Manager_operation __0]) _
                  [operation, op] in
              match
                mcase.(Manager_operations.case.MCase.select) (Manager operation)
                with
              | None => None
              | Some operation =>
                Some
                  (Manager_operation
                    (contents.Manager_operation.with_operation operation op))
              end
            | _ => None
            end;
        case.Case.proj :=
          fun function_parameter =>
            let
              '(Manager_operation {|
                contents.Manager_operation.operation := operation |}) as op :=
              function_parameter in
            ((extract op),
              (mcase.(Manager_operations.case.MCase.proj) operation));
        case.Case.inj :=
          fun function_parameter =>
            let '(op, contents) := function_parameter in
            rebuild op (mcase.(Manager_operations.case.MCase.inj) contents) |}.
  
  Definition reveal_case : case (Kind.manager Kind.reveal) :=
    make_manager_case 107 Manager_operations.reveal_case.
  
  Definition transaction_case : case (Kind.manager Kind.transaction) :=
    make_manager_case 108 Manager_operations.transaction_case.
  
  Definition origination_case : case (Kind.manager Kind.origination) :=
    make_manager_case 109 Manager_operations.origination_case.
  
  Definition delegation_case : case (Kind.manager Kind.delegation) :=
    make_manager_case 110 Manager_operations.delegation_case.
  
  Definition contents_encoding : Data_encoding.encoding packed_contents :=
    let make {A : Set} (function_parameter : case A)
      : Data_encoding.case packed_contents :=
      let
        'Case {|
          case.Case.tag := tag;
            case.Case.name := name;
            case.Case.encoding := encoding;
            case.Case.select := select;
            case.Case.proj := proj;
            case.Case.inj := inj
            |} := function_parameter in
      let 'existT _ __Case_'a [tag, name, encoding, select, proj, inj] :=
        existT (A := Set)
          (fun __Case_'a =>
            [Z ** string ** Data_encoding.t __Case_'a **
              packed_contents -> option (contents A) ** contents A -> __Case_'a
              ** __Case_'a -> contents A]) _
          [tag, name, encoding, select, proj, inj] in
      __case_value (Data_encoding.Tag tag) name encoding
        (fun o =>
          match select o with
          | None => None
          | Some o => Some (proj o)
          end) (fun x => Contents (inj x)) in
    (let arg := Data_encoding.def "operation.alpha.contents" in
    fun eta => arg None None eta)
      (Data_encoding.union None
        [
          make endorsement_case;
          make seed_nonce_revelation_case;
          make double_endorsement_evidence_case;
          make double_baking_evidence_case;
          make activate_account_case;
          make proposals_case;
          make ballot_case;
          make reveal_case;
          make transaction_case;
          make origination_case;
          make delegation_case
        ]).
  
  Definition contents_list_encoding
    : Data_encoding.encoding packed_contents_list :=
    Data_encoding.conv to_list of_list None
      (Data_encoding.__Variable.__list_value None contents_encoding).
  
  Definition optional_signature_encoding
    : Data_encoding.encoding (option Signature.t) :=
    Data_encoding.conv
      (fun function_parameter =>
        match function_parameter with
        | Some s => s
        | None => Signature.zero
        end)
      (fun s =>
        if Signature.equal s Signature.zero then
          None
        else
          Some s) None Signature.encoding.
  
  Definition protocol_data_encoding
    : Data_encoding.encoding packed_protocol_data :=
    (let arg := Data_encoding.def "operation.alpha.contents_and_signature" in
    fun eta => arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =>
          let
            'Operation_data {|
              protocol_data.contents := contents;
                protocol_data.signature := signature
                |} := function_parameter in
          let 'existT _ __Operation_data_'kind [contents, signature] :=
            existT (A := Set)
              (fun __Operation_data_'kind =>
                [contents_list __Operation_data_'kind ** option Signature.t]) _
              [contents, signature] in
          ((Contents_list contents), signature))
        (fun function_parameter =>
          let '(Contents_list contents, signature) := function_parameter in
          let 'existT _ __Contents_list_'kind [contents, signature] :=
            existT (A := Set)
              (fun __Contents_list_'kind =>
                [contents_list __Contents_list_'kind ** option Signature.t]) _
              [contents, signature] in
          Operation_data
            {| protocol_data.contents := contents;
              protocol_data.signature := signature |}) None
        (Data_encoding.obj2
          (Data_encoding.req None None "contents" contents_list_encoding)
          (Data_encoding.req None None "signature" optional_signature_encoding))).
  
  Definition operation_encoding : Data_encoding.encoding packed_operation :=
    Data_encoding.conv
      (fun function_parameter =>
        let '{|
          packed_operation.shell := shell;
            packed_operation.protocol_data := protocol_data
            |} := function_parameter in
        (shell, protocol_data))
      (fun function_parameter =>
        let '(shell, protocol_data) := function_parameter in
        {| packed_operation.shell := shell;
          packed_operation.protocol_data := protocol_data |}) None
      (Data_encoding.merge_objs Operation.shell_header_encoding
        protocol_data_encoding).
  
  Definition unsigned_operation_encoding
    : Data_encoding.encoding (Operation.shell_header * packed_contents_list) :=
    (let arg := Data_encoding.def "operation.alpha.unsigned_operation" in
    fun eta => arg None None eta)
      (Data_encoding.merge_objs Operation.shell_header_encoding
        (Data_encoding.obj1
          (Data_encoding.req None None "contents" contents_list_encoding))).
  
  Definition internal_operation_encoding
    : Data_encoding.encoding packed_internal_operation :=
    (let arg := Data_encoding.def "operation.alpha.internal_operation" in
    fun eta => arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =>
          let
            'Internal_operation {|
              internal_operation.source := source;
                internal_operation.operation := operation;
                internal_operation.nonce := __nonce_value
                |} := function_parameter in
          let 'existT _ __Internal_operation_'kind
            [source, operation, __nonce_value] :=
            existT (A := Set)
              (fun __Internal_operation_'kind =>
                [Contract_repr.contract **
                  manager_operation __Internal_operation_'kind ** Z]) _
              [source, operation, __nonce_value] in
          ((source, __nonce_value), (Manager operation)))
        (fun function_parameter =>
          let '((source, __nonce_value), Manager operation) :=
            function_parameter in
          let 'existT _ __Manager_'kind [source, __nonce_value, operation] :=
            existT (A := Set)
              (fun __Manager_'kind =>
                [Contract_repr.contract ** Z **
                  manager_operation __Manager_'kind]) _
              [source, __nonce_value, operation] in
          Internal_operation
            {| internal_operation.source := source;
              internal_operation.operation := operation;
              internal_operation.nonce := __nonce_value |}) None
        (Data_encoding.merge_objs
          (Data_encoding.obj2
            (Data_encoding.req None None "source" Contract_repr.encoding)
            (Data_encoding.req None None "nonce" Data_encoding.uint16))
          Manager_operations.encoding)).
End Encoding.

Definition encoding : Data_encoding.encoding packed_operation :=
  Encoding.operation_encoding.

Definition contents_encoding : Data_encoding.encoding packed_contents :=
  Encoding.contents_encoding.

Definition contents_list_encoding
  : Data_encoding.encoding packed_contents_list :=
  Encoding.contents_list_encoding.

Definition protocol_data_encoding
  : Data_encoding.encoding packed_protocol_data :=
  Encoding.protocol_data_encoding.

Definition unsigned_operation_encoding
  : Data_encoding.encoding (Operation.shell_header * packed_contents_list) :=
  Encoding.unsigned_operation_encoding.

Definition internal_operation_encoding
  : Data_encoding.encoding packed_internal_operation :=
  Encoding.internal_operation_encoding.

Definition __raw_value {A : Set} (function_parameter : operation A)
  : Operation.t :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      (Operation_data protocol_data) in
  {| Operation.t.shell := shell; Operation.t.proto := proto |}.

Definition acceptable_passes (op : packed_operation) : list Z :=
  let 'Operation_data protocol_data := op.(packed_operation.protocol_data) in
  let 'existT _ __Operation_data_'kind protocol_data :=
    existT (A := Set)
      (fun __Operation_data_'kind => protocol_data __Operation_data_'kind) _
      protocol_data in
  match protocol_data.(protocol_data.contents) with
  | Single (Endorsement _) => [ 0 ]
  | Single (Proposals _) => [ 1 ]
  | Single (Ballot _) => [ 1 ]
  | Single (Seed_nonce_revelation _) => [ 2 ]
  | Single (Double_endorsement_evidence _) => [ 2 ]
  | Single (Double_baking_evidence _) => [ 2 ]
  | Single (Activate_account _) => [ 2 ]
  | Single (Manager_operation _) => [ 3 ]
  | Cons _ _ => [ 3 ]
  end.

(* âŒ Structure item `typext` not handled. *)
(* type_extension *)

(* âŒ Structure item `typext` not handled. *)
(* type_extension *)

(* âŒ Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition check_signature_sync {A : Set}
  (__key_value : (|Signature.Public_key|).(S.SPublic_key.t))
  (chain_id : (|Chain_id|).(S.HASH.t)) (function_parameter : operation A)
  : Error_monad.tzresult unit :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  let check
    (watermark : Signature.watermark) (contents : packed_contents_list)
    (signature : Signature.t)
    : Pervasives.result unit (list Error_monad.__error) :=
    let unsigned_operation :=
      Data_encoding.Binary.to_bytes_exn unsigned_operation_encoding
        (shell, contents) in
    if Signature.check (Some watermark) __key_value signature unsigned_operation
      then
      Pervasives.Ok tt
    else
      Error_monad.__error_value extensible_type_value in
  match
    (protocol_data.(protocol_data.contents),
      protocol_data.(protocol_data.signature)) with
  | (Single _, None) => Error_monad.__error_value extensible_type_value
  | (Cons _ _, None) => Error_monad.__error_value extensible_type_value
  | ((Single (Endorsement _)) as contents, Some signature) =>
    check (Signature.Endorsement chain_id) (Contents_list contents) signature
  | ((Single _) as contents, Some signature) =>
    check Signature.Generic_operation (Contents_list contents) signature
  | ((Cons _ _) as contents, Some signature) =>
    let 'existT _ [__2, __3] [contents, signature] :=
      existT (A := [Set ** Set])
        (fun '[__2, __3] =>
          [contents_list (Kind.manager (__2 * __3)) ** Signature.t]) [_, _]
        [contents, signature] in
    check Signature.Generic_operation (Contents_list contents) signature
  end.

Definition check_signature {A : Set}
  (pk : (|Signature.Public_key|).(S.SPublic_key.t))
  (chain_id : (|Chain_id|).(S.HASH.t)) (op : operation A)
  : Lwt.t (Error_monad.tzresult unit) :=
  Lwt.__return (check_signature_sync pk chain_id op).

Definition hash_raw : Operation.t -> (|Operation_hash|).(S.HASH.t) :=
  Operation.__hash_value.

Definition __hash_value {A : Set} (o : operation A)
  : (|Operation_hash|).(S.HASH.t) :=
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      (Operation_data o.(operation.protocol_data)) in
  Operation.__hash_value
    {| raw.shell := o.(operation.shell); raw.proto := proto |}.

Definition hash_packed (o : packed_operation) : (|Operation_hash|).(S.HASH.t) :=
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      o.(packed_operation.protocol_data) in
  Operation.__hash_value
    {| raw.shell := o.(packed_operation.shell); raw.proto := proto |}.

Reserved Notation "'eq".

Inductive eq_gadt : Set :=
| Eq : eq_gadt

where "'eq" := (fun (_ _ : Set) => eq_gadt).

Definition eq := 'eq.

Definition equal_manager_operation_kind {a b : Set}
  (op1 : manager_operation a) (op2 : manager_operation b) : option (eq a b) :=
  match (op1, op2) with
  | (Reveal _, Reveal _) => Some Eq
  | (Reveal _, _) => None
  | (Transaction _, Transaction _) => Some Eq
  | (Transaction _, _) => None
  | (Origination _, Origination _) => Some Eq
  | (Origination _, _) => None
  | (Delegation _, Delegation _) => Some Eq
  | (Delegation _, _) => None
  end.

Definition equal_contents_kind {a b : Set} (op1 : contents a) (op2 : contents b)
  : option (eq a b) :=
  match (op1, op2) with
  | (Endorsement _, Endorsement _) => Some Eq
  | (Endorsement _, _) => None
  | (Seed_nonce_revelation _, Seed_nonce_revelation _) => Some Eq
  | (Seed_nonce_revelation _, _) => None
  | (Double_endorsement_evidence _, Double_endorsement_evidence _) => Some Eq
  | (Double_endorsement_evidence _, _) => None
  | (Double_baking_evidence _, Double_baking_evidence _) => Some Eq
  | (Double_baking_evidence _, _) => None
  | (Activate_account _, Activate_account _) => Some Eq
  | (Activate_account _, _) => None
  | (Proposals _, Proposals _) => Some Eq
  | (Proposals _, _) => None
  | (Ballot _, Ballot _) => Some Eq
  | (Ballot _, _) => None
  | (Manager_operation op1, Manager_operation op2) =>
    let 'existT _ [__0, __1] [op1, op2] :=
      existT (A := [Set ** Set])
        (fun '[__0, __1] =>
          [contents.Manager_operation __0 ** contents.Manager_operation __1])
        [_, _] [op1, op2] in
    match
      equal_manager_operation_kind op1.(contents.Manager_operation.operation)
        op2.(contents.Manager_operation.operation) with
    | None => None
    | Some Eq => Some Eq
    end
  | (Manager_operation _, _) => None
  end.

Fixpoint equal_contents_kind_list {a b : Set}
  (op1 : contents_list a) (op2 : contents_list b) {struct op1}
  : option (eq a b) :=
  match (op1, op2) with
  | (Single op1, Single op2) => equal_contents_kind op1 op2
  | (Single _, Cons _ _) => None
  | (Cons _ _, Single _) => None
  | (Cons op1 ops1, Cons op2 ops2) =>
    let 'existT _ [__4, __5, __6, __7] [op1, ops1, op2, ops2] :=
      existT (A := [Set ** Set ** Set ** Set])
        (fun '[__4, __5, __6, __7] =>
          [contents (Kind.manager __4) ** contents_list (Kind.manager __5) **
            contents (Kind.manager __6) ** contents_list (Kind.manager __7)])
        [_, _, _, _] [op1, ops1, op2, ops2] in
    match equal_contents_kind op1 op2 with
    | None => None
    | Some Eq =>
      match equal_contents_kind_list ops1 ops2 with
      | None => None
      | Some Eq => Some Eq
      end
    end
  end.

Definition equal {a b : Set} (op1 : operation a) (op2 : operation b)
  : option (eq a b) :=
  if
    Pervasives.not
      ((|Operation_hash|).(S.HASH.equal) (__hash_value op1) (__hash_value op2))
    then
    None
  else
    equal_contents_kind_list
      op1.(operation.protocol_data).(protocol_data.contents)
      op2.(operation.protocol_data).(protocol_data.contents).
